[
  {
    "function_name": "tl_shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
    "lines": "2680-2687",
    "snippet": "void\ntl_shutdown(xsc)\n\tvoid *xsc;\n{\n\tstruct tl_softc *sc = xsc;\n\n\ttl_stop(sc);\n}",
    "includes": [
      "#include <dev/pci/if_tlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void tl_stop",
      "void tl_shutdown"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tl_stop",
          "args": [
            "sc"
          ],
          "line": 2686
        },
        "resolved": true,
        "details": {
          "function_name": "tl_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "2335-2399",
          "snippet": "void tl_stop(sc)\n\tstruct tl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/* Stop the stats updater. */\n\tuntimeout(tl_stats_update, sc);\n\tuntimeout(tl_wait_up, sc);\n\n\t/* Stop the transmitter */\n\tCMD_CLR(sc, TL_CMD_RT);\n\tCMD_SET(sc, TL_CMD_STOP);\n\tCSR_WRITE_4(sc, TL_CH_PARM, 0);\n\n\t/* Stop the receiver */\n\tCMD_SET(sc, TL_CMD_RT);\n\tCMD_SET(sc, TL_CMD_STOP);\n\tCSR_WRITE_4(sc, TL_CH_PARM, 0);\n\n\t/*\n\t * Disable host interrupts.\n\t */\n\tCMD_SET(sc, TL_CMD_INTSOFF);\n\n\t/*\n\t * Disable MII interrupts.\n\t */\n\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\n\t/*\n\t * Clear list pointer.\n\t */\n\tCSR_WRITE_4(sc, TL_CH_PARM, 0);\n\n\t/*\n\t * Free the RX lists.\n\t */\n\tfor (i = 0; i < TL_RX_LIST_CNT; i++) {\n\t\tif (sc->tl_cdata.tl_rx_chain[i].tl_mbuf != NULL) {\n\t\t\tm_freem(sc->tl_cdata.tl_rx_chain[i].tl_mbuf);\n\t\t\tsc->tl_cdata.tl_rx_chain[i].tl_mbuf = NULL;\n\t\t}\n\t}\n\tbzero((char *)&sc->tl_ldata->tl_rx_list,\n\t\tsizeof(sc->tl_ldata->tl_rx_list));\n\n\t/*\n\t * Free the TX list buffers.\n\t */\n\tfor (i = 0; i < TL_TX_LIST_CNT; i++) {\n\t\tif (sc->tl_cdata.tl_tx_chain[i].tl_mbuf != NULL) {\n\t\t\tm_freem(sc->tl_cdata.tl_tx_chain[i].tl_mbuf);\n\t\t\tsc->tl_cdata.tl_tx_chain[i].tl_mbuf = NULL;\n\t\t}\n\t}\n\tbzero((char *)&sc->tl_ldata->tl_tx_list,\n\t\tsizeof(sc->tl_ldata->tl_tx_list));\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void tl_wait_up",
            "void tl_stats_update",
            "void tl_stop",
            "void tl_dio_clrbit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_wait_up;\nvoid tl_stats_update;\nvoid tl_stop;\nvoid tl_dio_clrbit;\n\nvoid tl_stop(sc)\n\tstruct tl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/* Stop the stats updater. */\n\tuntimeout(tl_stats_update, sc);\n\tuntimeout(tl_wait_up, sc);\n\n\t/* Stop the transmitter */\n\tCMD_CLR(sc, TL_CMD_RT);\n\tCMD_SET(sc, TL_CMD_STOP);\n\tCSR_WRITE_4(sc, TL_CH_PARM, 0);\n\n\t/* Stop the receiver */\n\tCMD_SET(sc, TL_CMD_RT);\n\tCMD_SET(sc, TL_CMD_STOP);\n\tCSR_WRITE_4(sc, TL_CH_PARM, 0);\n\n\t/*\n\t * Disable host interrupts.\n\t */\n\tCMD_SET(sc, TL_CMD_INTSOFF);\n\n\t/*\n\t * Disable MII interrupts.\n\t */\n\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\n\t/*\n\t * Clear list pointer.\n\t */\n\tCSR_WRITE_4(sc, TL_CH_PARM, 0);\n\n\t/*\n\t * Free the RX lists.\n\t */\n\tfor (i = 0; i < TL_RX_LIST_CNT; i++) {\n\t\tif (sc->tl_cdata.tl_rx_chain[i].tl_mbuf != NULL) {\n\t\t\tm_freem(sc->tl_cdata.tl_rx_chain[i].tl_mbuf);\n\t\t\tsc->tl_cdata.tl_rx_chain[i].tl_mbuf = NULL;\n\t\t}\n\t}\n\tbzero((char *)&sc->tl_ldata->tl_rx_list,\n\t\tsizeof(sc->tl_ldata->tl_rx_list));\n\n\t/*\n\t * Free the TX list buffers.\n\t */\n\tfor (i = 0; i < TL_TX_LIST_CNT; i++) {\n\t\tif (sc->tl_cdata.tl_tx_chain[i].tl_mbuf != NULL) {\n\t\t\tm_freem(sc->tl_cdata.tl_tx_chain[i].tl_mbuf);\n\t\t\tsc->tl_cdata.tl_tx_chain[i].tl_mbuf = NULL;\n\t\t}\n\t}\n\tbzero((char *)&sc->tl_ldata->tl_tx_list,\n\t\tsizeof(sc->tl_ldata->tl_tx_list));\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_stop;\nvoid tl_shutdown;\n\nvoid\ntl_shutdown(xsc)\n\tvoid *xsc;\n{\n\tstruct tl_softc *sc = xsc;\n\n\ttl_stop(sc);\n}"
  },
  {
    "function_name": "tl_wait_up",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
    "lines": "2669-2678",
    "snippet": "void\ntl_wait_up(xsc)\n\tvoid *xsc;\n{\n\tstruct tl_softc *sc = xsc;\n\tstruct ifnet *ifp = &sc->arpcom.ac_if;\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n}",
    "includes": [
      "#include <dev/pci/if_tlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void tl_wait_up"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_wait_up;\n\nvoid\ntl_wait_up(xsc)\n\tvoid *xsc;\n{\n\tstruct tl_softc *sc = xsc;\n\tstruct ifnet *ifp = &sc->arpcom.ac_if;\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n}"
  },
  {
    "function_name": "tl_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
    "lines": "2445-2667",
    "snippet": "void\ntl_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct tl_softc *sc = (struct tl_softc *)self;\n\tstruct pci_attach_args *pa = aux;\n\tpci_chipset_tag_t pc = pa->pa_pc;\n\tpci_intr_handle_t ih;\n\tconst char *intrstr = NULL;\n\tstruct ifnet *ifp = &sc->arpcom.ac_if;\n\tbus_addr_t iobase;\n\tbus_size_t iosize;\n\tu_int32_t command;\n\tu_int round;\n\tu_int8_t *roundptr;\n\tint i, phys;\n\n\t/*\n\t * Map control/status registers.\n\t */\n\tcommand = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);\n\n#ifdef TL_USEIOSPACE\n\tif (!(command & PCI_COMMAND_IO_ENABLE)) {\n\t\tprintf(\": failed to enable I/O ports\\n\");\n\t\treturn;\n\t}\n\tif (pci_io_find(pc, pa->pa_tag, TL_PCI_LOIO, &iobase, &iosize)) {\n\t\tif (pci_io_find(pc, pa->pa_tag, TL_PCI_LOMEM,\n\t\t    &iobase, &iosize)) {\n\t\t\tprintf(\": failed to find i/o space\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\tif (bus_space_map(pa->pa_iot, iobase, iosize, 0, &sc->tl_bhandle)) {\n\t\tprintf(\": failed map i/o space\\n\");\n\t\treturn;\n\t}\n\tsc->tl_btag = pa->pa_iot;\n#else\n\tif (!(command & PCI_COMMAND_MEM_ENABLE)) {\n\t\tprintf(\": failed to enable memory mapping\\n\");\n\t\treturn;\n\t}\n\tif (pci_mem_find(pc, pa->pa_tag, TL_PCI_LOMEM, &iobase, &iosize, NULL)){\n\t\tif (pci_mem_find(pc, pa->pa_tag, TL_PCI_LOIO,\n\t\t    &iobase, &iosize, NULL)) {\n\t\t\tprintf(\": failed to find memory space\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\tif (bus_space_map(pa->pa_memt, iobase, iosize, 0, &sc->tl_bhandle)) {\n\t\tprintf(\": failed map memory space\\n\");\n\t\treturn;\n\t}\n\tsc->tl_btag = pa->pa_memt;\n#endif\n\n\t/*\n\t * Manual wants the PCI latency timer jacked up to 0xff\n\t */\n\tcommand = pci_conf_read(pa->pa_pc, pa->pa_tag, TL_PCI_LATENCY_TIMER);\n\tcommand |= 0x0000ff00;\n\tpci_conf_write(pa->pa_pc, pa->pa_tag, TL_PCI_LATENCY_TIMER, command);\n\n\t/*\n\t * Allocate our interrupt.\n\t */\n\tif (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin,\n\t    pa->pa_intrline, &ih)) {\n\t\tprintf(\": couldn't map interrupt\\n\");\n\t\treturn;\n\t}\n\tintrstr = pci_intr_string(pc, ih);\n\tsc->sc_ih = pci_intr_establish(pc, ih, IPL_NET, tl_intr, sc,\n\t    self->dv_xname);\n\tif (sc->sc_ih == NULL) {\n\t\tprintf(\": could not establish interrupt\");\n\t\tif (intrstr != NULL)\n\t\t\tprintf(\" at %s\", intrstr);\n\t\tprintf(\"\\n\");\n\t\treturn;\n\t}\n\tprintf(\": %s\", intrstr);\n\n\tsc->tl_ldata_ptr = malloc(sizeof(struct tl_list_data) + 8,\n\t\t\t\tM_DEVBUF, M_NOWAIT);\n\tif (sc->tl_ldata_ptr == NULL) {\n\t\tprintf(\"\\n%s: no memory for list buffers\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\tbzero(sc->tl_ldata_ptr, sizeof(struct tl_list_data) + 8);\n\n\tsc->tl_ldata = (struct tl_list_data *)sc->tl_ldata_ptr;\n#ifdef __i386__\n\tround = (u_int32_t)sc->tl_ldata_ptr & 0xF;\n#endif\n#ifdef __alpha__\n\tround = (u_int64_t)sc->tl_ldata_ptr & 0xF;\n#endif\n\troundptr = sc->tl_ldata_ptr;\n\tfor (i = 0; i < 8; i++) {\n\t\tif (round % 8) {\n\t\t\tround++;\n\t\t\troundptr++;\n\t\t} else\n\t\t\tbreak;\n\t}\n\tsc->tl_ldata = (struct tl_list_data *)roundptr;\n\n\tsc->tl_unit = sc->sc_dev.dv_unit;\n\tif (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_COMPAQ ||\n\t    PCI_VENDOR(pa->pa_id) == PCI_VENDOR_TI)\n\t\tsc->tl_eeaddr = TL_EEPROM_EADDR;\n\tif (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_OLICOM)\n\t\tsc->tl_eeaddr = TL_EEPROM_EADDR_OC;\n\n\t/*\n\t * Reset adapter.\n\t */\n\ttl_softreset(sc, 1);\n\ttl_hardreset(sc);\n\tDELAY(1000000);\n\ttl_softreset(sc, 1);\n\n\t/*\n\t * Get station address from the EEPROM.\n\t */\n\tif (tl_read_eeprom(sc, (caddr_t)&sc->arpcom.ac_enaddr,\n\t    sc->tl_eeaddr, ETHER_ADDR_LEN)) {\n\t\tprintf(\"\\n%s: failed to read station address\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t    return;\n\t}\n\n\tif (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_OLICOM) {\n\t\tfor (i = 0; i < ETHER_ADDR_LEN; i += 2) {\n\t\t\tu_int16_t *p;\n\n\t\t\tp = (u_int16_t *)&sc->arpcom.ac_enaddr[i];\n\t\t\t*p = ntohs(*p);\n\t\t}\n\t}\n\n\tprintf(\" address %s\\n\", ether_sprintf(sc->arpcom.ac_enaddr));\n\n\tifp = &sc->arpcom.ac_if;\n\tifp->if_softc = sc;\n\tifp->if_mtu = ETHERMTU;\n\tifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;\n\tifp->if_ioctl = tl_ioctl;\n\tifp->if_output = ether_output;\n\tifp->if_start = tl_start;\n\tifp->if_watchdog = tl_watchdog;\n\tifp->if_baudrate = 10000000;\n\tifp->if_snd.ifq_maxlen = IFQ_MAXLEN;\n\tbcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\n\t/*\n\t * Reset adapter (again).\n\t */\n\ttl_softreset(sc, 1);\n\ttl_hardreset(sc);\n\tDELAY(1000000);\n\ttl_softreset(sc, 1);\n\n\tfor (i = TL_PHYADDR_MIN; i < TL_PHYADDR_MAX + 1; i++) {\n\t\tsc->tl_phy_addr = i;\n\t\ttl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_RESET);\n\t\tDELAY(500);\n\t\twhile(tl_phy_readreg(sc, PHY_BMCR) & PHY_BMCR_RESET);\n\t\tsc->tl_phy_sts = tl_phy_readreg(sc, PHY_BMSR);\n\t\tif (!sc->tl_phy_sts)\n\t\t\tcontinue;\n\t\tif (tl_attach_phy(sc)) {\n\t\t\tprintf(\"%s: failed to attach a phy %d\\n\",\n\t\t\t    sc->sc_dev.dv_xname, i);\n\t\t\treturn;\n\t\t}\n\t\tphys++;\n\t\tif (phys && i != TL_PHYADDR_MAX)\n\t\t\tbreak;\n\t}\n\tif (!phys) {\n\t\tstruct ifmedia *ifm;\n\t\tsc->tl_bitrate = 1;\n\t\tifmedia_init(&sc->ifmedia, 0, tl_ifmedia_upd, tl_ifmedia_sts);\n\t\tifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_10_T, 0, NULL);\n\t\tifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_10_T|IFM_HDX, 0, NULL);\n\t\tifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_10_T|IFM_FDX, 0, NULL);\n\t\tifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_10_5, 0, NULL);\n\t\tifmedia_set(&sc->ifmedia, IFM_ETHER|IFM_10_T);\n\t\t/* Reset again, this time setting bitrate mode. */\n\t\ttl_softreset(sc, 1);\n\t\tifm = &sc->ifmedia;\n\t\tifm->ifm_media = ifm->ifm_cur->ifm_media;\n\t\ttl_ifmedia_upd(ifp);\n\t}\n\n\ttl_intvec_adchk((void *)sc, 0);\n\ttl_stop(sc);\n\n\t/*\n\t * Attempt to clear stray interrupts\n\t */\n\tsc->tl_empty_intr = 1;\n\ttl_intr((void *)sc);\n\tsc->tl_empty_intr = 0;\n\n\t/*\n\t * Attach us everywhere.\n\t */\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n\n#if NBPFILTER > 0\n\tbpfattach(&sc->arpcom.ac_if.if_bpf, ifp,\n\t    DLT_EN10MB, sizeof(struct ether_header));\n#endif\n\tshutdownhook_establish(tl_shutdown, sc);\n}",
    "includes": [
      "#include <dev/pci/if_tlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define TL_USEIOSPACE"
    ],
    "globals_used": [
      "void tl_attach",
      "int tl_attach_phy",
      "int tl_intvec_adchk",
      "int tl_intr",
      "void tl_start",
      "int tl_ioctl",
      "void tl_stop",
      "void tl_watchdog",
      "void tl_shutdown",
      "int tl_ifmedia_upd",
      "void tl_ifmedia_sts",
      "int tl_read_eeprom",
      "u_int16_t tl_phy_readreg",
      "void tl_phy_writereg",
      "void tl_softreset",
      "void tl_hardreset"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "shutdownhook_establish",
          "args": [
            "tl_shutdown",
            "sc"
          ],
          "line": 2666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpfattach",
          "args": [
            "&sc->arpcom.ac_if.if_bpf",
            "ifp",
            "DLT_EN10MB",
            "sizeof(struct ether_header)"
          ],
          "line": 2663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_ifattach",
          "args": [
            "ifp"
          ],
          "line": 2660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_attach",
          "args": [
            "ifp"
          ],
          "line": 2659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tl_intr",
          "args": [
            "(void *)sc"
          ],
          "line": 2653
        },
        "resolved": true,
        "details": {
          "function_name": "tl_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "1754-1825",
          "snippet": "int tl_intr(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct tl_softc\t\t*sc;\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\tr = 0;\n\tu_int32_t\t\ttype = 0;\n\tu_int16_t\t\tints = 0;\n\tu_int8_t\t\tivec = 0;\n\n\tsc = xsc;\n\n\t/* Disable interrupts */\n\tints = CSR_READ_2(sc, TL_HOST_INT);\n\tCSR_WRITE_2(sc, TL_HOST_INT, ints);\n\ttype = (ints << 16) & 0xFFFF0000;\n\tivec = (ints & TL_VEC_MASK) >> 5;\n\tints = (ints & TL_INT_MASK) >> 2;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tswitch(ints) {\n\tcase (TL_INTR_INVALID):\n#ifdef DIAGNOSTIC\n\t\tif (sc->tl_empty_intr == 0)\n\t\t\tprintf(\"tl%d: got an invalid interrupt!\\n\", sc->tl_unit);\n#endif\n\t\t/* Re-enable interrupts but don't ack this one. */\n\t\tCMD_PUT(sc, type);\n\t\tr = 0;\n\t\tbreak;\n\tcase (TL_INTR_TXEOF):\n\t\tr = tl_intvec_txeof((void *)sc, type);\n\t\tbreak;\n\tcase (TL_INTR_TXEOC):\n\t\tr = tl_intvec_txeoc((void *)sc, type);\n\t\tbreak;\n\tcase (TL_INTR_STATOFLOW):\n\t\ttl_stats_update(sc);\n\t\tr = 1;\n\t\tbreak;\n\tcase (TL_INTR_RXEOF):\n\t\tr = tl_intvec_rxeof((void *)sc, type);\n\t\tbreak;\n\tcase (TL_INTR_DUMMY):\n\t\tprintf(\"tl%d: got a dummy interrupt\\n\", sc->tl_unit);\n\t\tr = 1;\n\t\tbreak;\n\tcase (TL_INTR_ADCHK):\n\t\tif (ivec)\n\t\t\tr = tl_intvec_adchk((void *)sc, type);\n\t\telse\n\t\t\tr = tl_intvec_netsts((void *)sc, type);\n\t\tbreak;\n\tcase (TL_INTR_RXEOC):\n\t\tr = tl_intvec_rxeoc((void *)sc, type);\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"tl%d: bogus interrupt type\\n\", sc->tl_unit);\n\t\tbreak;\n\t}\n\n\t/* Re-enable interrupts */\n\tif (r) {\n\t\tCMD_PUT(sc, TL_CMD_ACK | r | type);\n\t}\n\n\tif (ifp->if_snd.ifq_head != NULL)\n\t\ttl_start(ifp);\n\n\treturn r;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int tl_intvec_rxeoc",
            "int tl_intvec_txeoc",
            "int tl_intvec_txeof",
            "int tl_intvec_rxeof",
            "int tl_intvec_adchk",
            "int tl_intvec_netsts",
            "void tl_stats_update",
            "int tl_intr",
            "void tl_start"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint tl_intvec_rxeoc;\nint tl_intvec_txeoc;\nint tl_intvec_txeof;\nint tl_intvec_rxeof;\nint tl_intvec_adchk;\nint tl_intvec_netsts;\nvoid tl_stats_update;\nint tl_intr;\nvoid tl_start;\n\nint tl_intr(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct tl_softc\t\t*sc;\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\tr = 0;\n\tu_int32_t\t\ttype = 0;\n\tu_int16_t\t\tints = 0;\n\tu_int8_t\t\tivec = 0;\n\n\tsc = xsc;\n\n\t/* Disable interrupts */\n\tints = CSR_READ_2(sc, TL_HOST_INT);\n\tCSR_WRITE_2(sc, TL_HOST_INT, ints);\n\ttype = (ints << 16) & 0xFFFF0000;\n\tivec = (ints & TL_VEC_MASK) >> 5;\n\tints = (ints & TL_INT_MASK) >> 2;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tswitch(ints) {\n\tcase (TL_INTR_INVALID):\n#ifdef DIAGNOSTIC\n\t\tif (sc->tl_empty_intr == 0)\n\t\t\tprintf(\"tl%d: got an invalid interrupt!\\n\", sc->tl_unit);\n#endif\n\t\t/* Re-enable interrupts but don't ack this one. */\n\t\tCMD_PUT(sc, type);\n\t\tr = 0;\n\t\tbreak;\n\tcase (TL_INTR_TXEOF):\n\t\tr = tl_intvec_txeof((void *)sc, type);\n\t\tbreak;\n\tcase (TL_INTR_TXEOC):\n\t\tr = tl_intvec_txeoc((void *)sc, type);\n\t\tbreak;\n\tcase (TL_INTR_STATOFLOW):\n\t\ttl_stats_update(sc);\n\t\tr = 1;\n\t\tbreak;\n\tcase (TL_INTR_RXEOF):\n\t\tr = tl_intvec_rxeof((void *)sc, type);\n\t\tbreak;\n\tcase (TL_INTR_DUMMY):\n\t\tprintf(\"tl%d: got a dummy interrupt\\n\", sc->tl_unit);\n\t\tr = 1;\n\t\tbreak;\n\tcase (TL_INTR_ADCHK):\n\t\tif (ivec)\n\t\t\tr = tl_intvec_adchk((void *)sc, type);\n\t\telse\n\t\t\tr = tl_intvec_netsts((void *)sc, type);\n\t\tbreak;\n\tcase (TL_INTR_RXEOC):\n\t\tr = tl_intvec_rxeoc((void *)sc, type);\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"tl%d: bogus interrupt type\\n\", sc->tl_unit);\n\t\tbreak;\n\t}\n\n\t/* Re-enable interrupts */\n\tif (r) {\n\t\tCMD_PUT(sc, TL_CMD_ACK | r | type);\n\t}\n\n\tif (ifp->if_snd.ifq_head != NULL)\n\t\ttl_start(ifp);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tl_stop",
          "args": [
            "sc"
          ],
          "line": 2647
        },
        "resolved": true,
        "details": {
          "function_name": "tl_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "2335-2399",
          "snippet": "void tl_stop(sc)\n\tstruct tl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/* Stop the stats updater. */\n\tuntimeout(tl_stats_update, sc);\n\tuntimeout(tl_wait_up, sc);\n\n\t/* Stop the transmitter */\n\tCMD_CLR(sc, TL_CMD_RT);\n\tCMD_SET(sc, TL_CMD_STOP);\n\tCSR_WRITE_4(sc, TL_CH_PARM, 0);\n\n\t/* Stop the receiver */\n\tCMD_SET(sc, TL_CMD_RT);\n\tCMD_SET(sc, TL_CMD_STOP);\n\tCSR_WRITE_4(sc, TL_CH_PARM, 0);\n\n\t/*\n\t * Disable host interrupts.\n\t */\n\tCMD_SET(sc, TL_CMD_INTSOFF);\n\n\t/*\n\t * Disable MII interrupts.\n\t */\n\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\n\t/*\n\t * Clear list pointer.\n\t */\n\tCSR_WRITE_4(sc, TL_CH_PARM, 0);\n\n\t/*\n\t * Free the RX lists.\n\t */\n\tfor (i = 0; i < TL_RX_LIST_CNT; i++) {\n\t\tif (sc->tl_cdata.tl_rx_chain[i].tl_mbuf != NULL) {\n\t\t\tm_freem(sc->tl_cdata.tl_rx_chain[i].tl_mbuf);\n\t\t\tsc->tl_cdata.tl_rx_chain[i].tl_mbuf = NULL;\n\t\t}\n\t}\n\tbzero((char *)&sc->tl_ldata->tl_rx_list,\n\t\tsizeof(sc->tl_ldata->tl_rx_list));\n\n\t/*\n\t * Free the TX list buffers.\n\t */\n\tfor (i = 0; i < TL_TX_LIST_CNT; i++) {\n\t\tif (sc->tl_cdata.tl_tx_chain[i].tl_mbuf != NULL) {\n\t\t\tm_freem(sc->tl_cdata.tl_tx_chain[i].tl_mbuf);\n\t\t\tsc->tl_cdata.tl_tx_chain[i].tl_mbuf = NULL;\n\t\t}\n\t}\n\tbzero((char *)&sc->tl_ldata->tl_tx_list,\n\t\tsizeof(sc->tl_ldata->tl_tx_list));\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void tl_wait_up",
            "void tl_stats_update",
            "void tl_stop",
            "void tl_dio_clrbit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_wait_up;\nvoid tl_stats_update;\nvoid tl_stop;\nvoid tl_dio_clrbit;\n\nvoid tl_stop(sc)\n\tstruct tl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/* Stop the stats updater. */\n\tuntimeout(tl_stats_update, sc);\n\tuntimeout(tl_wait_up, sc);\n\n\t/* Stop the transmitter */\n\tCMD_CLR(sc, TL_CMD_RT);\n\tCMD_SET(sc, TL_CMD_STOP);\n\tCSR_WRITE_4(sc, TL_CH_PARM, 0);\n\n\t/* Stop the receiver */\n\tCMD_SET(sc, TL_CMD_RT);\n\tCMD_SET(sc, TL_CMD_STOP);\n\tCSR_WRITE_4(sc, TL_CH_PARM, 0);\n\n\t/*\n\t * Disable host interrupts.\n\t */\n\tCMD_SET(sc, TL_CMD_INTSOFF);\n\n\t/*\n\t * Disable MII interrupts.\n\t */\n\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\n\t/*\n\t * Clear list pointer.\n\t */\n\tCSR_WRITE_4(sc, TL_CH_PARM, 0);\n\n\t/*\n\t * Free the RX lists.\n\t */\n\tfor (i = 0; i < TL_RX_LIST_CNT; i++) {\n\t\tif (sc->tl_cdata.tl_rx_chain[i].tl_mbuf != NULL) {\n\t\t\tm_freem(sc->tl_cdata.tl_rx_chain[i].tl_mbuf);\n\t\t\tsc->tl_cdata.tl_rx_chain[i].tl_mbuf = NULL;\n\t\t}\n\t}\n\tbzero((char *)&sc->tl_ldata->tl_rx_list,\n\t\tsizeof(sc->tl_ldata->tl_rx_list));\n\n\t/*\n\t * Free the TX list buffers.\n\t */\n\tfor (i = 0; i < TL_TX_LIST_CNT; i++) {\n\t\tif (sc->tl_cdata.tl_tx_chain[i].tl_mbuf != NULL) {\n\t\t\tm_freem(sc->tl_cdata.tl_tx_chain[i].tl_mbuf);\n\t\t\tsc->tl_cdata.tl_tx_chain[i].tl_mbuf = NULL;\n\t\t}\n\t}\n\tbzero((char *)&sc->tl_ldata->tl_tx_list,\n\t\tsizeof(sc->tl_ldata->tl_tx_list));\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tl_intvec_adchk",
          "args": [
            "(void *)sc",
            "0"
          ],
          "line": 2646
        },
        "resolved": true,
        "details": {
          "function_name": "tl_intvec_adchk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "1699-1735",
          "snippet": "int tl_intvec_adchk(xsc, type)\n\tvoid\t\t\t*xsc;\n\tu_int32_t\t\ttype;\n{\n\tstruct tl_softc\t\t*sc;\n\tu_int16_t\t\tbmcr, ctl;\n\n\tsc = xsc;\n\n\tif (type)\n\t\tprintf(\"tl%d: adapter check: %x\\n\", sc->tl_unit,\n\t\t\t(unsigned int)CSR_READ_4(sc, TL_CH_PARM));\n\n\t/*\n\t * Before resetting the adapter, try reading the PHY\n\t * settings so we can put them back later. This is\n\t * necessary to keep the chip operating at the same\n\t * speed and duplex settings after the reset completes.\n\t */\n\tif (!sc->tl_bitrate) {\n\t\tbmcr = tl_phy_readreg(sc, PHY_BMCR);\n\t\tctl = tl_phy_readreg(sc, TL_PHY_CTL);\n\t\ttl_softreset(sc, 1);\n\t\ttl_phy_writereg(sc, PHY_BMCR, bmcr);\n\t\ttl_phy_writereg(sc, TL_PHY_CTL, ctl);\n\t\tif (bmcr & PHY_BMCR_DUPLEX) {\n\t\t\ttl_dio_setbit(sc, TL_NETCMD, TL_CMD_DUPLEX);\n\t\t} else {\n\t\t\ttl_dio_clrbit(sc, TL_NETCMD, TL_CMD_DUPLEX);\n\t\t}\n\t}\n\ttl_stop(sc);\n\ttl_init(sc);\n\tCMD_SET(sc, TL_CMD_INTSON);\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int tl_intvec_adchk",
            "void tl_init",
            "void tl_stop",
            "u_int16_t tl_phy_readreg",
            "void tl_phy_writereg",
            "void tl_softreset",
            "void tl_dio_setbit",
            "void tl_dio_clrbit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint tl_intvec_adchk;\nvoid tl_init;\nvoid tl_stop;\nu_int16_t tl_phy_readreg;\nvoid tl_phy_writereg;\nvoid tl_softreset;\nvoid tl_dio_setbit;\nvoid tl_dio_clrbit;\n\nint tl_intvec_adchk(xsc, type)\n\tvoid\t\t\t*xsc;\n\tu_int32_t\t\ttype;\n{\n\tstruct tl_softc\t\t*sc;\n\tu_int16_t\t\tbmcr, ctl;\n\n\tsc = xsc;\n\n\tif (type)\n\t\tprintf(\"tl%d: adapter check: %x\\n\", sc->tl_unit,\n\t\t\t(unsigned int)CSR_READ_4(sc, TL_CH_PARM));\n\n\t/*\n\t * Before resetting the adapter, try reading the PHY\n\t * settings so we can put them back later. This is\n\t * necessary to keep the chip operating at the same\n\t * speed and duplex settings after the reset completes.\n\t */\n\tif (!sc->tl_bitrate) {\n\t\tbmcr = tl_phy_readreg(sc, PHY_BMCR);\n\t\tctl = tl_phy_readreg(sc, TL_PHY_CTL);\n\t\ttl_softreset(sc, 1);\n\t\ttl_phy_writereg(sc, PHY_BMCR, bmcr);\n\t\ttl_phy_writereg(sc, TL_PHY_CTL, ctl);\n\t\tif (bmcr & PHY_BMCR_DUPLEX) {\n\t\t\ttl_dio_setbit(sc, TL_NETCMD, TL_CMD_DUPLEX);\n\t\t} else {\n\t\t\ttl_dio_clrbit(sc, TL_NETCMD, TL_CMD_DUPLEX);\n\t\t}\n\t}\n\ttl_stop(sc);\n\ttl_init(sc);\n\tCMD_SET(sc, TL_CMD_INTSON);\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tl_ifmedia_upd",
          "args": [
            "ifp"
          ],
          "line": 2643
        },
        "resolved": true,
        "details": {
          "function_name": "tl_ifmedia_upd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "2161-2179",
          "snippet": "int tl_ifmedia_upd(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct tl_softc\t\t*sc;\n\tstruct ifmedia\t\t*ifm;\n\n\tsc = ifp->if_softc;\n\tifm = &sc->ifmedia;\n\n\tif (IFM_TYPE(ifm->ifm_media) != IFM_ETHER)\n\t\treturn(EINVAL);\n\n\tif (IFM_SUBTYPE(ifm->ifm_media) == IFM_AUTO)\n\t\ttl_autoneg(sc, TL_FLAG_SCHEDDELAY, 1);\n\telse\n\t\ttl_setmode(sc, ifm->ifm_media);\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int tl_ifmedia_upd",
            "void tl_autoneg",
            "void tl_setmode"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint tl_ifmedia_upd;\nvoid tl_autoneg;\nvoid tl_setmode;\n\nint tl_ifmedia_upd(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct tl_softc\t\t*sc;\n\tstruct ifmedia\t\t*ifm;\n\n\tsc = ifp->if_softc;\n\tifm = &sc->ifmedia;\n\n\tif (IFM_TYPE(ifm->ifm_media) != IFM_ETHER)\n\t\treturn(EINVAL);\n\n\tif (IFM_SUBTYPE(ifm->ifm_media) == IFM_AUTO)\n\t\ttl_autoneg(sc, TL_FLAG_SCHEDDELAY, 1);\n\telse\n\t\ttl_setmode(sc, ifm->ifm_media);\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tl_softreset",
          "args": [
            "sc",
            "1"
          ],
          "line": 2640
        },
        "resolved": true,
        "details": {
          "function_name": "tl_softreset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "1208-1276",
          "snippet": "void tl_softreset(sc, internal)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\tinternal;\n{\n        u_int32_t               cmd, dummy, i;\n\n        /* Assert the adapter reset bit. */\n\tCMD_SET(sc, TL_CMD_ADRST);\n        /* Turn off interrupts */\n\tCMD_SET(sc, TL_CMD_INTSOFF);\n\n\t/* First, clear the stats registers. */\n\tfor (i = 0; i < 5; i++)\n\t\tdummy = tl_dio_read32(sc, TL_TXGOODFRAMES);\n\n        /* Clear Areg and Hash registers */\n\tfor (i = 0; i < 8; i++)\n\t\ttl_dio_write32(sc, TL_AREG0_B5, 0x00000000);\n\n        /*\n\t * Set up Netconfig register. Enable one channel and\n\t * one fragment mode.\n\t */\n\ttl_dio_setbit16(sc, TL_NETCONFIG, TL_CFG_ONECHAN|TL_CFG_ONEFRAG);\n\tif (internal && !sc->tl_bitrate) {\n\t\ttl_dio_setbit16(sc, TL_NETCONFIG, TL_CFG_PHYEN);\n\t} else {\n\t\ttl_dio_clrbit16(sc, TL_NETCONFIG, TL_CFG_PHYEN);\n\t}\n\n\t/* Handle cards with bitrate devices. */\n\tif (sc->tl_bitrate)\n\t\ttl_dio_setbit16(sc, TL_NETCONFIG, TL_CFG_BITRATE);\n\n        /* Set PCI burst size */\n\ttl_dio_write8(sc, TL_BSIZEREG, 0x33);\n\n\t/*\n\t * Load adapter irq pacing timer and tx threshold.\n\t * We make the transmit threshold 1 initially but we may\n\t * change that later.\n\t */\n\tcmd = CSR_READ_4(sc, TL_HOSTCMD);\n\tcmd |= TL_CMD_NES;\n\tcmd &= ~(TL_CMD_RT|TL_CMD_EOC|TL_CMD_ACK_MASK|TL_CMD_CHSEL_MASK);\n\tCMD_PUT(sc, cmd | (TL_CMD_LDTHR | TX_THR));\n\tCMD_PUT(sc, cmd | (TL_CMD_LDTMR | 0x00000003));\n\n        /* Unreset the MII */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_NMRST);\n\n\t/* Clear status register */\n        tl_dio_setbit16(sc, TL_NETSTS, TL_STS_MIRQ);\n        tl_dio_setbit16(sc, TL_NETSTS, TL_STS_HBEAT);\n        tl_dio_setbit16(sc, TL_NETSTS, TL_STS_TXSTOP);\n        tl_dio_setbit16(sc, TL_NETSTS, TL_STS_RXSTOP);\n\n\t/* Enable network status interrupts for everything. */\n\ttl_dio_setbit(sc, TL_NETMASK, TL_MASK_MASK7|TL_MASK_MASK6|\n\t\t\tTL_MASK_MASK5|TL_MASK_MASK4);\n\n\t/* Take the adapter out of reset */\n\ttl_dio_setbit(sc, TL_NETCMD, TL_CMD_NRESET|TL_CMD_NWRAP);\n\n\t/* Wait for things to settle down a little. */\n\tDELAY(500);\n\n        return;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void tl_softreset",
            "u_int32_t tl_dio_read32",
            "void tl_dio_write8",
            "void tl_dio_write32",
            "void tl_dio_setbit",
            "void tl_dio_setbit16",
            "void tl_dio_clrbit16"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_softreset;\nu_int32_t tl_dio_read32;\nvoid tl_dio_write8;\nvoid tl_dio_write32;\nvoid tl_dio_setbit;\nvoid tl_dio_setbit16;\nvoid tl_dio_clrbit16;\n\nvoid tl_softreset(sc, internal)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\tinternal;\n{\n        u_int32_t               cmd, dummy, i;\n\n        /* Assert the adapter reset bit. */\n\tCMD_SET(sc, TL_CMD_ADRST);\n        /* Turn off interrupts */\n\tCMD_SET(sc, TL_CMD_INTSOFF);\n\n\t/* First, clear the stats registers. */\n\tfor (i = 0; i < 5; i++)\n\t\tdummy = tl_dio_read32(sc, TL_TXGOODFRAMES);\n\n        /* Clear Areg and Hash registers */\n\tfor (i = 0; i < 8; i++)\n\t\ttl_dio_write32(sc, TL_AREG0_B5, 0x00000000);\n\n        /*\n\t * Set up Netconfig register. Enable one channel and\n\t * one fragment mode.\n\t */\n\ttl_dio_setbit16(sc, TL_NETCONFIG, TL_CFG_ONECHAN|TL_CFG_ONEFRAG);\n\tif (internal && !sc->tl_bitrate) {\n\t\ttl_dio_setbit16(sc, TL_NETCONFIG, TL_CFG_PHYEN);\n\t} else {\n\t\ttl_dio_clrbit16(sc, TL_NETCONFIG, TL_CFG_PHYEN);\n\t}\n\n\t/* Handle cards with bitrate devices. */\n\tif (sc->tl_bitrate)\n\t\ttl_dio_setbit16(sc, TL_NETCONFIG, TL_CFG_BITRATE);\n\n        /* Set PCI burst size */\n\ttl_dio_write8(sc, TL_BSIZEREG, 0x33);\n\n\t/*\n\t * Load adapter irq pacing timer and tx threshold.\n\t * We make the transmit threshold 1 initially but we may\n\t * change that later.\n\t */\n\tcmd = CSR_READ_4(sc, TL_HOSTCMD);\n\tcmd |= TL_CMD_NES;\n\tcmd &= ~(TL_CMD_RT|TL_CMD_EOC|TL_CMD_ACK_MASK|TL_CMD_CHSEL_MASK);\n\tCMD_PUT(sc, cmd | (TL_CMD_LDTHR | TX_THR));\n\tCMD_PUT(sc, cmd | (TL_CMD_LDTMR | 0x00000003));\n\n        /* Unreset the MII */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_NMRST);\n\n\t/* Clear status register */\n        tl_dio_setbit16(sc, TL_NETSTS, TL_STS_MIRQ);\n        tl_dio_setbit16(sc, TL_NETSTS, TL_STS_HBEAT);\n        tl_dio_setbit16(sc, TL_NETSTS, TL_STS_TXSTOP);\n        tl_dio_setbit16(sc, TL_NETSTS, TL_STS_RXSTOP);\n\n\t/* Enable network status interrupts for everything. */\n\ttl_dio_setbit(sc, TL_NETMASK, TL_MASK_MASK7|TL_MASK_MASK6|\n\t\t\tTL_MASK_MASK5|TL_MASK_MASK4);\n\n\t/* Take the adapter out of reset */\n\ttl_dio_setbit(sc, TL_NETCMD, TL_CMD_NRESET|TL_CMD_NWRAP);\n\n\t/* Wait for things to settle down a little. */\n\tDELAY(500);\n\n        return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ifmedia_set",
          "args": [
            "&sc->ifmedia",
            "IFM_ETHER|IFM_10_T"
          ],
          "line": 2638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "&sc->ifmedia",
            "IFM_ETHER|IFM_10_5",
            "0",
            "NULL"
          ],
          "line": 2637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "&sc->ifmedia",
            "IFM_ETHER|IFM_10_T|IFM_FDX",
            "0",
            "NULL"
          ],
          "line": 2636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "&sc->ifmedia",
            "IFM_ETHER|IFM_10_T|IFM_HDX",
            "0",
            "NULL"
          ],
          "line": 2635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "&sc->ifmedia",
            "IFM_ETHER|IFM_10_T",
            "0",
            "NULL"
          ],
          "line": 2634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_init",
          "args": [
            "&sc->ifmedia",
            "0",
            "tl_ifmedia_upd",
            "tl_ifmedia_sts"
          ],
          "line": 2633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: failed to attach a phy %d\\n\"",
            "sc->sc_dev.dv_xname",
            "i"
          ],
          "line": 2622
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tl_attach_phy",
          "args": [
            "sc"
          ],
          "line": 2621
        },
        "resolved": true,
        "details": {
          "function_name": "tl_attach_phy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "1282-1378",
          "snippet": "int tl_attach_phy(sc)\n\tstruct tl_softc\t\t*sc;\n{\n\tint\t\t\tphy_ctl;\n\tint\t\t\tmedia = IFM_ETHER|IFM_100_TX|IFM_FDX;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tsc->tl_phy_did = tl_phy_readreg(sc, TL_PHY_DEVID);\n\tsc->tl_phy_vid = tl_phy_readreg(sc, TL_PHY_VENID);\n\tsc->tl_phy_sts = tl_phy_readreg(sc, TL_PHY_GENSTS);\n\tphy_ctl = tl_phy_readreg(sc, TL_PHY_GENCTL);\n\n\tif (sc->tl_phy_sts & PHY_BMSR_100BT4 ||\n\t\tsc->tl_phy_sts & PHY_BMSR_100BTXFULL ||\n\t\tsc->tl_phy_sts & PHY_BMSR_100BTXHALF) \n\t\tifp->if_baudrate = 100000000;\n\telse\n\t\tifp->if_baudrate = 10000000;\n\n\tif (sc->tl_phy_sts & PHY_BMSR_100BT4 ||\n\t\tsc->tl_phy_sts & PHY_BMSR_100BTXHALF ||\n\t\tsc->tl_phy_sts & PHY_BMSR_100BTXHALF) {\n\t} else {\n\t\tmedia &= ~IFM_100_TX;\n\t\tmedia |= IFM_10_T;\n\t}\n\n\tif (sc->tl_phy_sts & PHY_BMSR_100BTXFULL ||\n\t\tsc->tl_phy_sts & PHY_BMSR_10BTFULL) {\n\t} else {\n\t\tmedia &= ~IFM_FDX;\n\t}\n\n\tif (sc->tl_phy_sts & PHY_BMSR_CANAUTONEG) {\n\t\tmedia = IFM_ETHER|IFM_AUTO;\n\t}\n\n\t/* Set up ifmedia data and callbacks. */\n\tifmedia_init(&sc->ifmedia, 0, tl_ifmedia_upd, tl_ifmedia_sts);\n\n\t/*\n\t * All ThunderLANs support at least 10baseT half duplex.\n\t * They also support AUI selection if used in 10Mb/s modes.\n\t */\n\tifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_10_T|IFM_HDX, 0, NULL);\n\tifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_10_T, 0, NULL);\n\tifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_10_5, 0, NULL);\n\n\t/* Some ThunderLAN PHYs support autonegotiation. */\n\tif (sc->tl_phy_sts & PHY_BMSR_CANAUTONEG)\n\t\tifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_AUTO, 0, NULL);\n\n\t/* Some support 10baseT full duplex. */\n\tif (sc->tl_phy_sts & PHY_BMSR_10BTFULL)\n\t\tifmedia_add(&sc->ifmedia,\n\t\t\tIFM_ETHER|IFM_10_T|IFM_FDX, 0, NULL);\n\n\t/* Some support 100BaseTX half duplex. */\n\tif (sc->tl_phy_sts & PHY_BMSR_100BTXHALF)\n\t\tifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_100_TX, 0, NULL);\n\tif (sc->tl_phy_sts & PHY_BMSR_100BTXHALF)\n\t\tifmedia_add(&sc->ifmedia,\n\t\t\tIFM_ETHER|IFM_100_TX|IFM_HDX, 0, NULL);\n\n\t/* Some support 100BaseTX full duplex. */\n\tif (sc->tl_phy_sts & PHY_BMSR_100BTXFULL)\n\t\tifmedia_add(&sc->ifmedia,\n\t\t\tIFM_ETHER|IFM_100_TX|IFM_FDX, 0, NULL);\n\n\t/* Some also support 100BaseT4. */\n\tif (sc->tl_phy_sts & PHY_BMSR_100BT4)\n\t\tifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_100_T4, 0, NULL);\n\n\t/* Set default media. */\n\tifmedia_set(&sc->ifmedia, media);\n\n\t/*\n\t * Kick off an autonegotiation session if this PHY supports it.\n\t * This is necessary to make sure the chip's duplex mode matches\n\t * the PHY's duplex mode. It may not: once enabled, the PHY may\n\t * autonegotiate full-duplex mode with its link partner, but the\n\t * ThunderLAN chip defaults to half-duplex and stays there unless\n\t * told otherwise.\n\t */\n\tif (sc->tl_phy_sts & PHY_BMSR_CANAUTONEG) {\n\t\ttl_init(sc);\n#ifdef TL_BACKGROUND_AUTONEG\n\t\ttl_autoneg(sc, TL_FLAG_SCHEDDELAY, 1);\n#else\n\t\ttl_autoneg(sc, TL_FLAG_FORCEDELAY, 1);\n#endif\n\t}\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int tl_attach_phy",
            "void tl_init",
            "int tl_ifmedia_upd",
            "void tl_ifmedia_sts",
            "u_int16_t tl_phy_readreg",
            "void tl_autoneg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint tl_attach_phy;\nvoid tl_init;\nint tl_ifmedia_upd;\nvoid tl_ifmedia_sts;\nu_int16_t tl_phy_readreg;\nvoid tl_autoneg;\n\nint tl_attach_phy(sc)\n\tstruct tl_softc\t\t*sc;\n{\n\tint\t\t\tphy_ctl;\n\tint\t\t\tmedia = IFM_ETHER|IFM_100_TX|IFM_FDX;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tsc->tl_phy_did = tl_phy_readreg(sc, TL_PHY_DEVID);\n\tsc->tl_phy_vid = tl_phy_readreg(sc, TL_PHY_VENID);\n\tsc->tl_phy_sts = tl_phy_readreg(sc, TL_PHY_GENSTS);\n\tphy_ctl = tl_phy_readreg(sc, TL_PHY_GENCTL);\n\n\tif (sc->tl_phy_sts & PHY_BMSR_100BT4 ||\n\t\tsc->tl_phy_sts & PHY_BMSR_100BTXFULL ||\n\t\tsc->tl_phy_sts & PHY_BMSR_100BTXHALF) \n\t\tifp->if_baudrate = 100000000;\n\telse\n\t\tifp->if_baudrate = 10000000;\n\n\tif (sc->tl_phy_sts & PHY_BMSR_100BT4 ||\n\t\tsc->tl_phy_sts & PHY_BMSR_100BTXHALF ||\n\t\tsc->tl_phy_sts & PHY_BMSR_100BTXHALF) {\n\t} else {\n\t\tmedia &= ~IFM_100_TX;\n\t\tmedia |= IFM_10_T;\n\t}\n\n\tif (sc->tl_phy_sts & PHY_BMSR_100BTXFULL ||\n\t\tsc->tl_phy_sts & PHY_BMSR_10BTFULL) {\n\t} else {\n\t\tmedia &= ~IFM_FDX;\n\t}\n\n\tif (sc->tl_phy_sts & PHY_BMSR_CANAUTONEG) {\n\t\tmedia = IFM_ETHER|IFM_AUTO;\n\t}\n\n\t/* Set up ifmedia data and callbacks. */\n\tifmedia_init(&sc->ifmedia, 0, tl_ifmedia_upd, tl_ifmedia_sts);\n\n\t/*\n\t * All ThunderLANs support at least 10baseT half duplex.\n\t * They also support AUI selection if used in 10Mb/s modes.\n\t */\n\tifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_10_T|IFM_HDX, 0, NULL);\n\tifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_10_T, 0, NULL);\n\tifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_10_5, 0, NULL);\n\n\t/* Some ThunderLAN PHYs support autonegotiation. */\n\tif (sc->tl_phy_sts & PHY_BMSR_CANAUTONEG)\n\t\tifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_AUTO, 0, NULL);\n\n\t/* Some support 10baseT full duplex. */\n\tif (sc->tl_phy_sts & PHY_BMSR_10BTFULL)\n\t\tifmedia_add(&sc->ifmedia,\n\t\t\tIFM_ETHER|IFM_10_T|IFM_FDX, 0, NULL);\n\n\t/* Some support 100BaseTX half duplex. */\n\tif (sc->tl_phy_sts & PHY_BMSR_100BTXHALF)\n\t\tifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_100_TX, 0, NULL);\n\tif (sc->tl_phy_sts & PHY_BMSR_100BTXHALF)\n\t\tifmedia_add(&sc->ifmedia,\n\t\t\tIFM_ETHER|IFM_100_TX|IFM_HDX, 0, NULL);\n\n\t/* Some support 100BaseTX full duplex. */\n\tif (sc->tl_phy_sts & PHY_BMSR_100BTXFULL)\n\t\tifmedia_add(&sc->ifmedia,\n\t\t\tIFM_ETHER|IFM_100_TX|IFM_FDX, 0, NULL);\n\n\t/* Some also support 100BaseT4. */\n\tif (sc->tl_phy_sts & PHY_BMSR_100BT4)\n\t\tifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_100_T4, 0, NULL);\n\n\t/* Set default media. */\n\tifmedia_set(&sc->ifmedia, media);\n\n\t/*\n\t * Kick off an autonegotiation session if this PHY supports it.\n\t * This is necessary to make sure the chip's duplex mode matches\n\t * the PHY's duplex mode. It may not: once enabled, the PHY may\n\t * autonegotiate full-duplex mode with its link partner, but the\n\t * ThunderLAN chip defaults to half-duplex and stays there unless\n\t * told otherwise.\n\t */\n\tif (sc->tl_phy_sts & PHY_BMSR_CANAUTONEG) {\n\t\ttl_init(sc);\n#ifdef TL_BACKGROUND_AUTONEG\n\t\ttl_autoneg(sc, TL_FLAG_SCHEDDELAY, 1);\n#else\n\t\ttl_autoneg(sc, TL_FLAG_FORCEDELAY, 1);\n#endif\n\t}\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tl_phy_readreg",
          "args": [
            "sc",
            "PHY_BMSR"
          ],
          "line": 2618
        },
        "resolved": true,
        "details": {
          "function_name": "tl_phy_readreg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "722-738",
          "snippet": "u_int16_t tl_phy_readreg(sc, reg)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tstruct tl_mii_frame\tframe;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = sc->tl_phy_addr;\n\tframe.mii_regaddr = reg;\n\ttl_mii_readreg(sc, &frame);\n\n\t/* Reenable MII interrupts, just in case. */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\n\treturn(frame.mii_data);\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int tl_mii_readreg",
            "u_int16_t tl_phy_readreg",
            "void tl_dio_setbit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint tl_mii_readreg;\nu_int16_t tl_phy_readreg;\nvoid tl_dio_setbit;\n\nu_int16_t tl_phy_readreg(sc, reg)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tstruct tl_mii_frame\tframe;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = sc->tl_phy_addr;\n\tframe.mii_regaddr = reg;\n\ttl_mii_readreg(sc, &frame);\n\n\t/* Reenable MII interrupts, just in case. */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\n\treturn(frame.mii_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "500"
          ],
          "line": 2616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tl_phy_writereg",
          "args": [
            "sc",
            "PHY_BMCR",
            "PHY_BMCR_RESET"
          ],
          "line": 2615
        },
        "resolved": true,
        "details": {
          "function_name": "tl_phy_writereg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "740-759",
          "snippet": "void tl_phy_writereg(sc, reg, data)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tdata;\n{\n\tstruct tl_mii_frame\tframe;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = sc->tl_phy_addr;\n\tframe.mii_regaddr = reg;\n\tframe.mii_data = data;\n\n\ttl_mii_writereg(sc, &frame);\n\n\t/* Reenable MII interrupts, just in case. */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int tl_mii_writereg",
            "void tl_phy_writereg",
            "void tl_dio_setbit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint tl_mii_writereg;\nvoid tl_phy_writereg;\nvoid tl_dio_setbit;\n\nvoid tl_phy_writereg(sc, reg, data)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tdata;\n{\n\tstruct tl_mii_frame\tframe;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = sc->tl_phy_addr;\n\tframe.mii_regaddr = reg;\n\tframe.mii_data = data;\n\n\ttl_mii_writereg(sc, &frame);\n\n\t/* Reenable MII interrupts, just in case. */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1000000"
          ],
          "line": 2610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tl_hardreset",
          "args": [
            "sc"
          ],
          "line": 2609
        },
        "resolved": true,
        "details": {
          "function_name": "tl_hardreset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "1172-1206",
          "snippet": "void tl_hardreset(sc)\n\tstruct tl_softc\t\t*sc;\n{\n\tint\t\t\ti;\n\tu_int16_t\t\told_addr, flags;\n\n\told_addr = sc->tl_phy_addr;\n\n\tfor (i = 0; i < TL_PHYADDR_MAX + 1; i++) {\n\t\tsc->tl_phy_addr = i;\n\t\ttl_mii_sync(sc);\n\t}\n\n\tflags = PHY_BMCR_LOOPBK|PHY_BMCR_ISOLATE|PHY_BMCR_PWRDOWN;\n\n\tfor (i = 0; i < TL_PHYADDR_MAX + 1; i++) {\n\t\tsc->tl_phy_addr = i;\n\t\ttl_phy_writereg(sc, PHY_BMCR, flags);\n\t}\n\n\tsc->tl_phy_addr = TL_PHYADDR_MAX;\n\ttl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_ISOLATE);\n\n\tDELAY(50000);\n\n\ttl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_LOOPBK|PHY_BMCR_ISOLATE);\n\n\ttl_mii_sync(sc);\n\n\twhile(tl_phy_readreg(sc, PHY_BMCR) & PHY_BMCR_RESET);\n\n\tsc->tl_phy_addr = old_addr;\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void tl_mii_sync",
            "u_int16_t tl_phy_readreg",
            "void tl_phy_writereg",
            "void tl_hardreset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_mii_sync;\nu_int16_t tl_phy_readreg;\nvoid tl_phy_writereg;\nvoid tl_hardreset;\n\nvoid tl_hardreset(sc)\n\tstruct tl_softc\t\t*sc;\n{\n\tint\t\t\ti;\n\tu_int16_t\t\told_addr, flags;\n\n\told_addr = sc->tl_phy_addr;\n\n\tfor (i = 0; i < TL_PHYADDR_MAX + 1; i++) {\n\t\tsc->tl_phy_addr = i;\n\t\ttl_mii_sync(sc);\n\t}\n\n\tflags = PHY_BMCR_LOOPBK|PHY_BMCR_ISOLATE|PHY_BMCR_PWRDOWN;\n\n\tfor (i = 0; i < TL_PHYADDR_MAX + 1; i++) {\n\t\tsc->tl_phy_addr = i;\n\t\ttl_phy_writereg(sc, PHY_BMCR, flags);\n\t}\n\n\tsc->tl_phy_addr = TL_PHYADDR_MAX;\n\ttl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_ISOLATE);\n\n\tDELAY(50000);\n\n\ttl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_LOOPBK|PHY_BMCR_ISOLATE);\n\n\ttl_mii_sync(sc);\n\n\twhile(tl_phy_readreg(sc, PHY_BMCR) & PHY_BMCR_RESET);\n\n\tsc->tl_phy_addr = old_addr;\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "sc->sc_dev.dv_xname",
            "ifp->if_xname",
            "IFNAMSIZ"
          ],
          "line": 2603
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ether_sprintf",
          "args": [
            "sc->arpcom.ac_enaddr"
          ],
          "line": 2591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "*p"
          ],
          "line": 2587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_VENDOR",
          "args": [
            "pa->pa_id"
          ],
          "line": 2582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tl_read_eeprom",
          "args": [
            "sc",
            "(caddr_t)&sc->arpcom.ac_enaddr",
            "sc->tl_eeaddr",
            "ETHER_ADDR_LEN"
          ],
          "line": 2575
        },
        "resolved": true,
        "details": {
          "function_name": "tl_read_eeprom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "519-536",
          "snippet": "int tl_read_eeprom(sc, dest, off, cnt)\n\tstruct tl_softc\t\t*sc;\n\tcaddr_t\t\t\tdest;\n\tint\t\t\toff;\n\tint\t\t\tcnt;\n{\n\tint\t\t\terr = 0, i;\n\tu_int8_t\t\tbyte = 0;\n\n\tfor (i = 0; i < cnt; i++) {\n\t\terr = tl_eeprom_getbyte(sc, off + i, &byte);\n\t\tif (err)\n\t\t\tbreak;\n\t\t*(dest + i) = byte;\n\t}\n\n\treturn(err ? 1 : 0);\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "u_int8_t\ttl_eeprom_getbyte",
            "int tl_read_eeprom"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int8_t\ttl_eeprom_getbyte;\nint tl_read_eeprom;\n\nint tl_read_eeprom(sc, dest, off, cnt)\n\tstruct tl_softc\t\t*sc;\n\tcaddr_t\t\t\tdest;\n\tint\t\t\toff;\n\tint\t\t\tcnt;\n{\n\tint\t\t\terr = 0, i;\n\tu_int8_t\t\tbyte = 0;\n\n\tfor (i = 0; i < cnt; i++) {\n\t\terr = tl_eeprom_getbyte(sc, off + i, &byte);\n\t\tif (err)\n\t\t\tbreak;\n\t\t*(dest + i) = byte;\n\t}\n\n\treturn(err ? 1 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1000000"
          ],
          "line": 2569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_VENDOR",
          "args": [
            "pa->pa_id"
          ],
          "line": 2561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_VENDOR",
          "args": [
            "pa->pa_id"
          ],
          "line": 2559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_VENDOR",
          "args": [
            "pa->pa_id"
          ],
          "line": 2558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "sc->tl_ldata_ptr",
            "sizeof(struct tl_list_data) + 8"
          ],
          "line": 2538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(struct tl_list_data) + 8",
            "M_DEVBUF",
            "M_NOWAIT"
          ],
          "line": 2531
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_intr_establish",
          "args": [
            "pc",
            "ih",
            "IPL_NET",
            "tl_intr",
            "sc",
            "self->dv_xname"
          ],
          "line": 2520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_intr_string",
          "args": [
            "pc",
            "ih"
          ],
          "line": 2519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_intr_map",
          "args": [
            "pc",
            "pa->pa_intrtag",
            "pa->pa_intrpin",
            "pa->pa_intrline",
            "&ih"
          ],
          "line": 2514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pa->pa_pc",
            "pa->pa_tag",
            "TL_PCI_LATENCY_TIMER",
            "command"
          ],
          "line": 2509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pa->pa_pc",
            "pa->pa_tag",
            "TL_PCI_LATENCY_TIMER"
          ],
          "line": 2507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "pa->pa_memt",
            "iobase",
            "iosize",
            "0",
            "&sc->tl_bhandle"
          ],
          "line": 2497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_mem_find",
          "args": [
            "pc",
            "pa->pa_tag",
            "TL_PCI_LOIO",
            "&iobase",
            "&iosize",
            "NULL"
          ],
          "line": 2491
        },
        "resolved": true,
        "details": {
          "function_name": "pci_mem_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pci_map.c",
          "lines": "197-208",
          "snippet": "int\npci_mem_find(pc, pcitag, reg, membasep, memsizep, cacheablep)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pcitag;\n\tint reg;\n\tbus_addr_t *membasep;\n\tbus_size_t *memsizep;\n\tint *cacheablep;\n{\n\treturn (nbsd_pci_mem_find(pc, pcitag, reg, -1, membasep, memsizep,\n\t\t\t\t  cacheablep));\n}",
          "includes": [
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nbsd_pci_mem_find"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int nbsd_pci_mem_find;\n\nint\npci_mem_find(pc, pcitag, reg, membasep, memsizep, cacheablep)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pcitag;\n\tint reg;\n\tbus_addr_t *membasep;\n\tbus_size_t *memsizep;\n\tint *cacheablep;\n{\n\treturn (nbsd_pci_mem_find(pc, pcitag, reg, -1, membasep, memsizep,\n\t\t\t\t  cacheablep));\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "pa->pa_iot",
            "iobase",
            "iosize",
            "0",
            "&sc->tl_bhandle"
          ],
          "line": 2480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_io_find",
          "args": [
            "pc",
            "pa->pa_tag",
            "TL_PCI_LOMEM",
            "&iobase",
            "&iosize"
          ],
          "line": 2474
        },
        "resolved": true,
        "details": {
          "function_name": "pci_io_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pci_map.c",
          "lines": "186-195",
          "snippet": "int\npci_io_find(pc, pcitag, reg, iobasep, iosizep)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pcitag;\n\tint reg;\n\tbus_addr_t *iobasep;\n\tbus_size_t *iosizep;\n{\n\treturn (nbsd_pci_io_find(pc, pcitag, reg, 0, iobasep, iosizep, 0));\n}",
          "includes": [
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nbsd_pci_io_find"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int nbsd_pci_io_find;\n\nint\npci_io_find(pc, pcitag, reg, iobasep, iosizep)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pcitag;\n\tint reg;\n\tbus_addr_t *iobasep;\n\tbus_size_t *iosizep;\n{\n\treturn (nbsd_pci_io_find(pc, pcitag, reg, 0, iobasep, iosizep, 0));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pa->pa_pc",
            "pa->pa_tag",
            "PCI_COMMAND_STATUS_REG"
          ],
          "line": 2466
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define TL_USEIOSPACE\n\nvoid tl_attach;\nint tl_attach_phy;\nint tl_intvec_adchk;\nint tl_intr;\nvoid tl_start;\nint tl_ioctl;\nvoid tl_stop;\nvoid tl_watchdog;\nvoid tl_shutdown;\nint tl_ifmedia_upd;\nvoid tl_ifmedia_sts;\nint tl_read_eeprom;\nu_int16_t tl_phy_readreg;\nvoid tl_phy_writereg;\nvoid tl_softreset;\nvoid tl_hardreset;\n\nvoid\ntl_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct tl_softc *sc = (struct tl_softc *)self;\n\tstruct pci_attach_args *pa = aux;\n\tpci_chipset_tag_t pc = pa->pa_pc;\n\tpci_intr_handle_t ih;\n\tconst char *intrstr = NULL;\n\tstruct ifnet *ifp = &sc->arpcom.ac_if;\n\tbus_addr_t iobase;\n\tbus_size_t iosize;\n\tu_int32_t command;\n\tu_int round;\n\tu_int8_t *roundptr;\n\tint i, phys;\n\n\t/*\n\t * Map control/status registers.\n\t */\n\tcommand = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);\n\n#ifdef TL_USEIOSPACE\n\tif (!(command & PCI_COMMAND_IO_ENABLE)) {\n\t\tprintf(\": failed to enable I/O ports\\n\");\n\t\treturn;\n\t}\n\tif (pci_io_find(pc, pa->pa_tag, TL_PCI_LOIO, &iobase, &iosize)) {\n\t\tif (pci_io_find(pc, pa->pa_tag, TL_PCI_LOMEM,\n\t\t    &iobase, &iosize)) {\n\t\t\tprintf(\": failed to find i/o space\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\tif (bus_space_map(pa->pa_iot, iobase, iosize, 0, &sc->tl_bhandle)) {\n\t\tprintf(\": failed map i/o space\\n\");\n\t\treturn;\n\t}\n\tsc->tl_btag = pa->pa_iot;\n#else\n\tif (!(command & PCI_COMMAND_MEM_ENABLE)) {\n\t\tprintf(\": failed to enable memory mapping\\n\");\n\t\treturn;\n\t}\n\tif (pci_mem_find(pc, pa->pa_tag, TL_PCI_LOMEM, &iobase, &iosize, NULL)){\n\t\tif (pci_mem_find(pc, pa->pa_tag, TL_PCI_LOIO,\n\t\t    &iobase, &iosize, NULL)) {\n\t\t\tprintf(\": failed to find memory space\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\tif (bus_space_map(pa->pa_memt, iobase, iosize, 0, &sc->tl_bhandle)) {\n\t\tprintf(\": failed map memory space\\n\");\n\t\treturn;\n\t}\n\tsc->tl_btag = pa->pa_memt;\n#endif\n\n\t/*\n\t * Manual wants the PCI latency timer jacked up to 0xff\n\t */\n\tcommand = pci_conf_read(pa->pa_pc, pa->pa_tag, TL_PCI_LATENCY_TIMER);\n\tcommand |= 0x0000ff00;\n\tpci_conf_write(pa->pa_pc, pa->pa_tag, TL_PCI_LATENCY_TIMER, command);\n\n\t/*\n\t * Allocate our interrupt.\n\t */\n\tif (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin,\n\t    pa->pa_intrline, &ih)) {\n\t\tprintf(\": couldn't map interrupt\\n\");\n\t\treturn;\n\t}\n\tintrstr = pci_intr_string(pc, ih);\n\tsc->sc_ih = pci_intr_establish(pc, ih, IPL_NET, tl_intr, sc,\n\t    self->dv_xname);\n\tif (sc->sc_ih == NULL) {\n\t\tprintf(\": could not establish interrupt\");\n\t\tif (intrstr != NULL)\n\t\t\tprintf(\" at %s\", intrstr);\n\t\tprintf(\"\\n\");\n\t\treturn;\n\t}\n\tprintf(\": %s\", intrstr);\n\n\tsc->tl_ldata_ptr = malloc(sizeof(struct tl_list_data) + 8,\n\t\t\t\tM_DEVBUF, M_NOWAIT);\n\tif (sc->tl_ldata_ptr == NULL) {\n\t\tprintf(\"\\n%s: no memory for list buffers\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\tbzero(sc->tl_ldata_ptr, sizeof(struct tl_list_data) + 8);\n\n\tsc->tl_ldata = (struct tl_list_data *)sc->tl_ldata_ptr;\n#ifdef __i386__\n\tround = (u_int32_t)sc->tl_ldata_ptr & 0xF;\n#endif\n#ifdef __alpha__\n\tround = (u_int64_t)sc->tl_ldata_ptr & 0xF;\n#endif\n\troundptr = sc->tl_ldata_ptr;\n\tfor (i = 0; i < 8; i++) {\n\t\tif (round % 8) {\n\t\t\tround++;\n\t\t\troundptr++;\n\t\t} else\n\t\t\tbreak;\n\t}\n\tsc->tl_ldata = (struct tl_list_data *)roundptr;\n\n\tsc->tl_unit = sc->sc_dev.dv_unit;\n\tif (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_COMPAQ ||\n\t    PCI_VENDOR(pa->pa_id) == PCI_VENDOR_TI)\n\t\tsc->tl_eeaddr = TL_EEPROM_EADDR;\n\tif (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_OLICOM)\n\t\tsc->tl_eeaddr = TL_EEPROM_EADDR_OC;\n\n\t/*\n\t * Reset adapter.\n\t */\n\ttl_softreset(sc, 1);\n\ttl_hardreset(sc);\n\tDELAY(1000000);\n\ttl_softreset(sc, 1);\n\n\t/*\n\t * Get station address from the EEPROM.\n\t */\n\tif (tl_read_eeprom(sc, (caddr_t)&sc->arpcom.ac_enaddr,\n\t    sc->tl_eeaddr, ETHER_ADDR_LEN)) {\n\t\tprintf(\"\\n%s: failed to read station address\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t    return;\n\t}\n\n\tif (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_OLICOM) {\n\t\tfor (i = 0; i < ETHER_ADDR_LEN; i += 2) {\n\t\t\tu_int16_t *p;\n\n\t\t\tp = (u_int16_t *)&sc->arpcom.ac_enaddr[i];\n\t\t\t*p = ntohs(*p);\n\t\t}\n\t}\n\n\tprintf(\" address %s\\n\", ether_sprintf(sc->arpcom.ac_enaddr));\n\n\tifp = &sc->arpcom.ac_if;\n\tifp->if_softc = sc;\n\tifp->if_mtu = ETHERMTU;\n\tifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;\n\tifp->if_ioctl = tl_ioctl;\n\tifp->if_output = ether_output;\n\tifp->if_start = tl_start;\n\tifp->if_watchdog = tl_watchdog;\n\tifp->if_baudrate = 10000000;\n\tifp->if_snd.ifq_maxlen = IFQ_MAXLEN;\n\tbcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\n\t/*\n\t * Reset adapter (again).\n\t */\n\ttl_softreset(sc, 1);\n\ttl_hardreset(sc);\n\tDELAY(1000000);\n\ttl_softreset(sc, 1);\n\n\tfor (i = TL_PHYADDR_MIN; i < TL_PHYADDR_MAX + 1; i++) {\n\t\tsc->tl_phy_addr = i;\n\t\ttl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_RESET);\n\t\tDELAY(500);\n\t\twhile(tl_phy_readreg(sc, PHY_BMCR) & PHY_BMCR_RESET);\n\t\tsc->tl_phy_sts = tl_phy_readreg(sc, PHY_BMSR);\n\t\tif (!sc->tl_phy_sts)\n\t\t\tcontinue;\n\t\tif (tl_attach_phy(sc)) {\n\t\t\tprintf(\"%s: failed to attach a phy %d\\n\",\n\t\t\t    sc->sc_dev.dv_xname, i);\n\t\t\treturn;\n\t\t}\n\t\tphys++;\n\t\tif (phys && i != TL_PHYADDR_MAX)\n\t\t\tbreak;\n\t}\n\tif (!phys) {\n\t\tstruct ifmedia *ifm;\n\t\tsc->tl_bitrate = 1;\n\t\tifmedia_init(&sc->ifmedia, 0, tl_ifmedia_upd, tl_ifmedia_sts);\n\t\tifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_10_T, 0, NULL);\n\t\tifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_10_T|IFM_HDX, 0, NULL);\n\t\tifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_10_T|IFM_FDX, 0, NULL);\n\t\tifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_10_5, 0, NULL);\n\t\tifmedia_set(&sc->ifmedia, IFM_ETHER|IFM_10_T);\n\t\t/* Reset again, this time setting bitrate mode. */\n\t\ttl_softreset(sc, 1);\n\t\tifm = &sc->ifmedia;\n\t\tifm->ifm_media = ifm->ifm_cur->ifm_media;\n\t\ttl_ifmedia_upd(ifp);\n\t}\n\n\ttl_intvec_adchk((void *)sc, 0);\n\ttl_stop(sc);\n\n\t/*\n\t * Attempt to clear stray interrupts\n\t */\n\tsc->tl_empty_intr = 1;\n\ttl_intr((void *)sc);\n\tsc->tl_empty_intr = 0;\n\n\t/*\n\t * Attach us everywhere.\n\t */\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n\n#if NBPFILTER > 0\n\tbpfattach(&sc->arpcom.ac_if.if_bpf, ifp,\n\t    DLT_EN10MB, sizeof(struct ether_header));\n#endif\n\tshutdownhook_establish(tl_shutdown, sc);\n}"
  },
  {
    "function_name": "tl_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
    "lines": "2401-2443",
    "snippet": "int\ntl_probe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match;\n\tvoid *aux;\n{\n\tstruct pci_attach_args *pa = (struct pci_attach_args *) aux;\n\n\tif (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_TI) {\n\t\tif (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_TI_TLAN)\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\n\tif (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_COMPAQ) {\n\t\tswitch (PCI_PRODUCT(pa->pa_id)) {\n\t\tcase PCI_PRODUCT_COMPAQ_N100TX:\n\t\tcase PCI_PRODUCT_COMPAQ_N10T:\n\t\tcase PCI_PRODUCT_COMPAQ_IntNF3P:\n\t\tcase PCI_PRODUCT_COMPAQ_DPNet100TX:\n\t\tcase PCI_PRODUCT_COMPAQ_IntPL100TX:\n\t\tcase PCI_PRODUCT_COMPAQ_DP4000:\n\t\tcase PCI_PRODUCT_COMPAQ_N10T2:\n\t\tcase PCI_PRODUCT_COMPAQ_N10_TX_UTP:\n\t\tcase PCI_PRODUCT_COMPAQ_NF3P:\n\t\tcase PCI_PRODUCT_COMPAQ_NF3P_BNC:\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_OLICOM) {\n\t\tswitch (PCI_PRODUCT(pa->pa_id)) {\n\t\tcase PCI_PRODUCT_OLICOM_OC2183:\n\t\tcase PCI_PRODUCT_OLICOM_OC2325:\n\t\tcase PCI_PRODUCT_OLICOM_OC2326:\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <dev/pci/if_tlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int tl_probe"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PCI_PRODUCT",
          "args": [
            "pa->pa_id"
          ],
          "line": 2433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_VENDOR",
          "args": [
            "pa->pa_id"
          ],
          "line": 2432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_PRODUCT",
          "args": [
            "pa->pa_id"
          ],
          "line": 2416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_VENDOR",
          "args": [
            "pa->pa_id"
          ],
          "line": 2415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_PRODUCT",
          "args": [
            "pa->pa_id"
          ],
          "line": 2410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_VENDOR",
          "args": [
            "pa->pa_id"
          ],
          "line": 2409
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint tl_probe;\n\nint\ntl_probe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match;\n\tvoid *aux;\n{\n\tstruct pci_attach_args *pa = (struct pci_attach_args *) aux;\n\n\tif (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_TI) {\n\t\tif (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_TI_TLAN)\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\n\tif (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_COMPAQ) {\n\t\tswitch (PCI_PRODUCT(pa->pa_id)) {\n\t\tcase PCI_PRODUCT_COMPAQ_N100TX:\n\t\tcase PCI_PRODUCT_COMPAQ_N10T:\n\t\tcase PCI_PRODUCT_COMPAQ_IntNF3P:\n\t\tcase PCI_PRODUCT_COMPAQ_DPNet100TX:\n\t\tcase PCI_PRODUCT_COMPAQ_IntPL100TX:\n\t\tcase PCI_PRODUCT_COMPAQ_DP4000:\n\t\tcase PCI_PRODUCT_COMPAQ_N10T2:\n\t\tcase PCI_PRODUCT_COMPAQ_N10_TX_UTP:\n\t\tcase PCI_PRODUCT_COMPAQ_NF3P:\n\t\tcase PCI_PRODUCT_COMPAQ_NF3P_BNC:\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_OLICOM) {\n\t\tswitch (PCI_PRODUCT(pa->pa_id)) {\n\t\tcase PCI_PRODUCT_OLICOM_OC2183:\n\t\tcase PCI_PRODUCT_OLICOM_OC2325:\n\t\tcase PCI_PRODUCT_OLICOM_OC2326:\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "tl_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
    "lines": "2335-2399",
    "snippet": "void tl_stop(sc)\n\tstruct tl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/* Stop the stats updater. */\n\tuntimeout(tl_stats_update, sc);\n\tuntimeout(tl_wait_up, sc);\n\n\t/* Stop the transmitter */\n\tCMD_CLR(sc, TL_CMD_RT);\n\tCMD_SET(sc, TL_CMD_STOP);\n\tCSR_WRITE_4(sc, TL_CH_PARM, 0);\n\n\t/* Stop the receiver */\n\tCMD_SET(sc, TL_CMD_RT);\n\tCMD_SET(sc, TL_CMD_STOP);\n\tCSR_WRITE_4(sc, TL_CH_PARM, 0);\n\n\t/*\n\t * Disable host interrupts.\n\t */\n\tCMD_SET(sc, TL_CMD_INTSOFF);\n\n\t/*\n\t * Disable MII interrupts.\n\t */\n\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\n\t/*\n\t * Clear list pointer.\n\t */\n\tCSR_WRITE_4(sc, TL_CH_PARM, 0);\n\n\t/*\n\t * Free the RX lists.\n\t */\n\tfor (i = 0; i < TL_RX_LIST_CNT; i++) {\n\t\tif (sc->tl_cdata.tl_rx_chain[i].tl_mbuf != NULL) {\n\t\t\tm_freem(sc->tl_cdata.tl_rx_chain[i].tl_mbuf);\n\t\t\tsc->tl_cdata.tl_rx_chain[i].tl_mbuf = NULL;\n\t\t}\n\t}\n\tbzero((char *)&sc->tl_ldata->tl_rx_list,\n\t\tsizeof(sc->tl_ldata->tl_rx_list));\n\n\t/*\n\t * Free the TX list buffers.\n\t */\n\tfor (i = 0; i < TL_TX_LIST_CNT; i++) {\n\t\tif (sc->tl_cdata.tl_tx_chain[i].tl_mbuf != NULL) {\n\t\t\tm_freem(sc->tl_cdata.tl_tx_chain[i].tl_mbuf);\n\t\t\tsc->tl_cdata.tl_tx_chain[i].tl_mbuf = NULL;\n\t\t}\n\t}\n\tbzero((char *)&sc->tl_ldata->tl_tx_list,\n\t\tsizeof(sc->tl_ldata->tl_tx_list));\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/if_tlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void tl_wait_up",
      "void tl_stats_update",
      "void tl_stop",
      "void tl_dio_clrbit"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char *)&sc->tl_ldata->tl_tx_list",
            "sizeof(sc->tl_ldata->tl_tx_list)"
          ],
          "line": 2393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "sc->tl_cdata.tl_tx_chain[i].tl_mbuf"
          ],
          "line": 2389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char *)&sc->tl_ldata->tl_rx_list",
            "sizeof(sc->tl_ldata->tl_rx_list)"
          ],
          "line": 2381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "sc->tl_cdata.tl_rx_chain[i].tl_mbuf"
          ],
          "line": 2377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TL_CH_PARM",
            "0"
          ],
          "line": 2370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tl_dio_clrbit",
          "args": [
            "sc",
            "TL_NETSIO",
            "TL_SIO_MINTEN"
          ],
          "line": 2365
        },
        "resolved": true,
        "details": {
          "function_name": "tl_dio_clrbit16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "389-402",
          "snippet": "void tl_dio_clrbit16(sc, reg, bit)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tbit;\n{\n\tu_int16_t\t\t\tf;\n\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tf = CSR_READ_2(sc, TL_DIO_DATA + (reg & 3));\n\tf &= ~bit;\n\tCSR_WRITE_2(sc, TL_DIO_DATA + (reg & 3), f);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void tl_dio_clrbit16"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_dio_clrbit16;\n\nvoid tl_dio_clrbit16(sc, reg, bit)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tbit;\n{\n\tu_int16_t\t\t\tf;\n\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tf = CSR_READ_2(sc, TL_DIO_DATA + (reg & 3));\n\tf &= ~bit;\n\tCSR_WRITE_2(sc, TL_DIO_DATA + (reg & 3), f);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CMD_SET",
          "args": [
            "sc",
            "TL_CMD_INTSOFF"
          ],
          "line": 2360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TL_CH_PARM",
            "0"
          ],
          "line": 2355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CMD_SET",
          "args": [
            "sc",
            "TL_CMD_STOP"
          ],
          "line": 2354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CMD_SET",
          "args": [
            "sc",
            "TL_CMD_RT"
          ],
          "line": 2353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TL_CH_PARM",
            "0"
          ],
          "line": 2350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CMD_SET",
          "args": [
            "sc",
            "TL_CMD_STOP"
          ],
          "line": 2349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CMD_CLR",
          "args": [
            "sc",
            "TL_CMD_RT"
          ],
          "line": 2348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "untimeout",
          "args": [
            "tl_wait_up",
            "sc"
          ],
          "line": 2345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "untimeout",
          "args": [
            "tl_stats_update",
            "sc"
          ],
          "line": 2344
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_wait_up;\nvoid tl_stats_update;\nvoid tl_stop;\nvoid tl_dio_clrbit;\n\nvoid tl_stop(sc)\n\tstruct tl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/* Stop the stats updater. */\n\tuntimeout(tl_stats_update, sc);\n\tuntimeout(tl_wait_up, sc);\n\n\t/* Stop the transmitter */\n\tCMD_CLR(sc, TL_CMD_RT);\n\tCMD_SET(sc, TL_CMD_STOP);\n\tCSR_WRITE_4(sc, TL_CH_PARM, 0);\n\n\t/* Stop the receiver */\n\tCMD_SET(sc, TL_CMD_RT);\n\tCMD_SET(sc, TL_CMD_STOP);\n\tCSR_WRITE_4(sc, TL_CH_PARM, 0);\n\n\t/*\n\t * Disable host interrupts.\n\t */\n\tCMD_SET(sc, TL_CMD_INTSOFF);\n\n\t/*\n\t * Disable MII interrupts.\n\t */\n\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\n\t/*\n\t * Clear list pointer.\n\t */\n\tCSR_WRITE_4(sc, TL_CH_PARM, 0);\n\n\t/*\n\t * Free the RX lists.\n\t */\n\tfor (i = 0; i < TL_RX_LIST_CNT; i++) {\n\t\tif (sc->tl_cdata.tl_rx_chain[i].tl_mbuf != NULL) {\n\t\t\tm_freem(sc->tl_cdata.tl_rx_chain[i].tl_mbuf);\n\t\t\tsc->tl_cdata.tl_rx_chain[i].tl_mbuf = NULL;\n\t\t}\n\t}\n\tbzero((char *)&sc->tl_ldata->tl_rx_list,\n\t\tsizeof(sc->tl_ldata->tl_rx_list));\n\n\t/*\n\t * Free the TX list buffers.\n\t */\n\tfor (i = 0; i < TL_TX_LIST_CNT; i++) {\n\t\tif (sc->tl_cdata.tl_tx_chain[i].tl_mbuf != NULL) {\n\t\t\tm_freem(sc->tl_cdata.tl_tx_chain[i].tl_mbuf);\n\t\t\tsc->tl_cdata.tl_tx_chain[i].tl_mbuf = NULL;\n\t\t}\n\t}\n\tbzero((char *)&sc->tl_ldata->tl_tx_list,\n\t\tsizeof(sc->tl_ldata->tl_tx_list));\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\treturn;\n}"
  },
  {
    "function_name": "tl_watchdog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
    "lines": "2302-2329",
    "snippet": "void tl_watchdog(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct tl_softc\t\t*sc;\n\tu_int16_t\t\tbmsr;\n\n\tsc = ifp->if_softc;\n\n\tif (sc->tl_autoneg) {\n\t\ttl_autoneg(sc, TL_FLAG_DELAYTIMEO, 1);\n\t\treturn;\n\t}\n\n\t/* Check that we're still connected. */\n\ttl_phy_readreg(sc, PHY_BMSR);\n\tbmsr = tl_phy_readreg(sc, PHY_BMSR);\n\tif (!(bmsr & PHY_BMSR_LINKSTAT)) {\n\t\tprintf(\"tl%d: no carrier\\n\", sc->tl_unit);\n\t\ttl_autoneg(sc, TL_FLAG_SCHEDDELAY, 1);\n\t} else\n\t\tprintf(\"tl%d: device timeout\\n\", sc->tl_unit);\n\n\tifp->if_oerrors++;\n\n\ttl_init(sc);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/if_tlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void tl_init",
      "void tl_watchdog",
      "u_int16_t tl_phy_readreg",
      "void tl_autoneg"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tl_init",
          "args": [
            "sc"
          ],
          "line": 2326
        },
        "resolved": true,
        "details": {
          "function_name": "tl_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "2052-2156",
          "snippet": "void tl_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct tl_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n        int\t\t\ts;\n\tu_int16_t\t\tphy_sts;\n\n\tif (sc->tl_autoneg)\n\t\treturn;\n\n\ts = splimp();\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/*\n\t * Cancel pending I/O.\n\t */\n\ttl_stop(sc);\n\n\t/*\n\t * Set 'capture all frames' bit for promiscuous mode.\n\t */\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\ttl_dio_setbit(sc, TL_NETCMD, TL_CMD_CAF);\n\telse\n\t\ttl_dio_clrbit(sc, TL_NETCMD, TL_CMD_CAF);\n\n\t/*\n\t * Set capture broadcast bit to capture broadcast frames.\n\t */\n\tif (ifp->if_flags & IFF_BROADCAST)\n\t\ttl_dio_clrbit(sc, TL_NETCMD, TL_CMD_NOBRX);\n\telse\n\t\ttl_dio_setbit(sc, TL_NETCMD, TL_CMD_NOBRX);\n\n\t/* Init our MAC address */\n\ttl_setfilt(sc, (caddr_t)&sc->arpcom.ac_enaddr, 0);\n\n\t/* Init multicast filter, if needed. */\n\ttl_setmulti(sc);\n\n\t/* Init circular RX list. */\n\tif (tl_list_rx_init(sc) == ENOBUFS) {\n\t\tprintf(\"tl%d: initialization failed: no \"\n\t\t\t\"memory for rx buffers\\n\", sc->tl_unit);\n\t\ttl_stop(sc);\n\t\treturn;\n\t}\n\n\t/* Init TX pointers. */\n\ttl_list_tx_init(sc);\n\n\t/*\n\t * Enable PHY interrupts.\n\t */\n\tphy_sts = tl_phy_readreg(sc, TL_PHY_CTL);\n\tphy_sts |= PHY_CTL_INTEN;\n\ttl_phy_writereg(sc, TL_PHY_CTL, phy_sts);\n\n\t/* Enable MII interrupts. */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\n\t/* Enable PCI interrupts. */\n\tCMD_SET(sc, TL_CMD_INTSON);\n\n\t/* Load the address of the rx list */\n\tCMD_SET(sc, TL_CMD_RT);\n\tCSR_WRITE_4(sc, TL_CH_PARM, vtophys(&sc->tl_ldata->tl_rx_list[0]));\n\n\t/*\n\t * XXX This is a kludge to handle adapters with the Micro Linear\n\t * ML6692 100BaseTX PHY, which only supports 100Mbps modes and\n\t * relies on the controller's internal 10Mbps PHY to provide\n\t * 10Mbps modes. The ML6692 always shows up with a vendor/device ID\n\t * of 0 (it doesn't actually have vendor/device ID registers)\n\t * so we use that property to detect it. In theory there ought to\n\t * be a better way to 'spot the looney' but I can't find one.\n         */\n        if (!sc->tl_phy_vid) {\n                u_int8_t                        addr = 0;\n                u_int16_t                       bmcr;\n\n                bmcr = tl_phy_readreg(sc, PHY_BMCR);\n                addr = sc->tl_phy_addr;\n                sc->tl_phy_addr = TL_PHYADDR_MAX;\n                tl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_RESET);\n                if (bmcr & PHY_BMCR_SPEEDSEL)\n                        tl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_ISOLATE);\n                else\n                        tl_phy_writereg(sc, PHY_BMCR, bmcr);\n                sc->tl_phy_addr = addr;\n        }\n\n\t/* Send the RX go command */\n\tCMD_SET(sc, TL_CMD_GO|TL_CMD_RT);\n\n\t(void)splx(s);\n\n\t/* Start the stats update counter */\n\ttimeout(tl_stats_update, sc, hz);\n\ttimeout(tl_wait_up, sc, 2 * hz);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void tl_wait_up",
            "void tl_stats_update",
            "void tl_init",
            "void tl_stop",
            "u_int16_t tl_phy_readreg",
            "void tl_phy_writereg",
            "void tl_autoneg",
            "void tl_setmulti",
            "void tl_setfilt",
            "int tl_list_rx_init",
            "int tl_list_tx_init",
            "void tl_dio_setbit",
            "void tl_dio_clrbit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_wait_up;\nvoid tl_stats_update;\nvoid tl_init;\nvoid tl_stop;\nu_int16_t tl_phy_readreg;\nvoid tl_phy_writereg;\nvoid tl_autoneg;\nvoid tl_setmulti;\nvoid tl_setfilt;\nint tl_list_rx_init;\nint tl_list_tx_init;\nvoid tl_dio_setbit;\nvoid tl_dio_clrbit;\n\nvoid tl_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct tl_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n        int\t\t\ts;\n\tu_int16_t\t\tphy_sts;\n\n\tif (sc->tl_autoneg)\n\t\treturn;\n\n\ts = splimp();\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/*\n\t * Cancel pending I/O.\n\t */\n\ttl_stop(sc);\n\n\t/*\n\t * Set 'capture all frames' bit for promiscuous mode.\n\t */\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\ttl_dio_setbit(sc, TL_NETCMD, TL_CMD_CAF);\n\telse\n\t\ttl_dio_clrbit(sc, TL_NETCMD, TL_CMD_CAF);\n\n\t/*\n\t * Set capture broadcast bit to capture broadcast frames.\n\t */\n\tif (ifp->if_flags & IFF_BROADCAST)\n\t\ttl_dio_clrbit(sc, TL_NETCMD, TL_CMD_NOBRX);\n\telse\n\t\ttl_dio_setbit(sc, TL_NETCMD, TL_CMD_NOBRX);\n\n\t/* Init our MAC address */\n\ttl_setfilt(sc, (caddr_t)&sc->arpcom.ac_enaddr, 0);\n\n\t/* Init multicast filter, if needed. */\n\ttl_setmulti(sc);\n\n\t/* Init circular RX list. */\n\tif (tl_list_rx_init(sc) == ENOBUFS) {\n\t\tprintf(\"tl%d: initialization failed: no \"\n\t\t\t\"memory for rx buffers\\n\", sc->tl_unit);\n\t\ttl_stop(sc);\n\t\treturn;\n\t}\n\n\t/* Init TX pointers. */\n\ttl_list_tx_init(sc);\n\n\t/*\n\t * Enable PHY interrupts.\n\t */\n\tphy_sts = tl_phy_readreg(sc, TL_PHY_CTL);\n\tphy_sts |= PHY_CTL_INTEN;\n\ttl_phy_writereg(sc, TL_PHY_CTL, phy_sts);\n\n\t/* Enable MII interrupts. */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\n\t/* Enable PCI interrupts. */\n\tCMD_SET(sc, TL_CMD_INTSON);\n\n\t/* Load the address of the rx list */\n\tCMD_SET(sc, TL_CMD_RT);\n\tCSR_WRITE_4(sc, TL_CH_PARM, vtophys(&sc->tl_ldata->tl_rx_list[0]));\n\n\t/*\n\t * XXX This is a kludge to handle adapters with the Micro Linear\n\t * ML6692 100BaseTX PHY, which only supports 100Mbps modes and\n\t * relies on the controller's internal 10Mbps PHY to provide\n\t * 10Mbps modes. The ML6692 always shows up with a vendor/device ID\n\t * of 0 (it doesn't actually have vendor/device ID registers)\n\t * so we use that property to detect it. In theory there ought to\n\t * be a better way to 'spot the looney' but I can't find one.\n         */\n        if (!sc->tl_phy_vid) {\n                u_int8_t                        addr = 0;\n                u_int16_t                       bmcr;\n\n                bmcr = tl_phy_readreg(sc, PHY_BMCR);\n                addr = sc->tl_phy_addr;\n                sc->tl_phy_addr = TL_PHYADDR_MAX;\n                tl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_RESET);\n                if (bmcr & PHY_BMCR_SPEEDSEL)\n                        tl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_ISOLATE);\n                else\n                        tl_phy_writereg(sc, PHY_BMCR, bmcr);\n                sc->tl_phy_addr = addr;\n        }\n\n\t/* Send the RX go command */\n\tCMD_SET(sc, TL_CMD_GO|TL_CMD_RT);\n\n\t(void)splx(s);\n\n\t/* Start the stats update counter */\n\ttimeout(tl_stats_update, sc, hz);\n\ttimeout(tl_wait_up, sc, 2 * hz);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"tl%d: device timeout\\n\"",
            "sc->tl_unit"
          ],
          "line": 2322
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tl_autoneg",
          "args": [
            "sc",
            "TL_FLAG_SCHEDDELAY",
            "1"
          ],
          "line": 2320
        },
        "resolved": true,
        "details": {
          "function_name": "tl_autoneg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "808-963",
          "snippet": "void tl_autoneg(sc, flag, verbose)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\tflag;\n\tint\t\t\tverbose;\n{\n\tu_int16_t\t\tphy_sts = 0, media = 0, advert, ability;\n\tstruct ifnet\t\t*ifp;\n\tstruct ifmedia\t\t*ifm;\n\n\tifm = &sc->ifmedia;\n\tifp = &sc->arpcom.ac_if;\n\n\t/*\n\t * First, see if autoneg is supported. If not, there's\n\t * no point in continuing.\n\t */\n\tphy_sts = tl_phy_readreg(sc, PHY_BMSR);\n\tif (!(phy_sts & PHY_BMSR_CANAUTONEG)) {\n\t\tif (verbose)\n\t\t\tprintf(\"tl%d: autonegotiation not supported\\n\",\n\t\t\t\t\t\t\tsc->tl_unit);\n\t\treturn;\n\t}\n\n\tswitch (flag) {\n\tcase TL_FLAG_FORCEDELAY:\n\t\t/*\n\t \t * XXX Never use this option anywhere but in the probe\n\t \t * routine: making the kernel stop dead in its tracks\n \t\t * for three whole seconds after we've gone multi-user\n\t\t * is really bad manners.\n\t \t */\n\t\ttl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_RESET);\n\t\tDELAY(500);\n\t\tphy_sts = tl_phy_readreg(sc, PHY_BMCR);\n\t\tphy_sts |= PHY_BMCR_AUTONEGENBL|PHY_BMCR_AUTONEGRSTR;\n\t\ttl_phy_writereg(sc, PHY_BMCR, phy_sts);\n\t\tDELAY(5000000);\n\t\tbreak;\n\tcase TL_FLAG_SCHEDDELAY:\n\t\t/*\n\t\t * Wait for the transmitter to go idle before starting\n\t\t * an autoneg session, otherwise tl_start() may clobber\n\t \t * our timeout, and we don't want to allow transmission\n\t\t * during an autoneg session since that can screw it up.\n\t \t */\n\t\tif (!sc->tl_txeoc) {\n\t\t\tsc->tl_want_auto = 1;\n\t\t\treturn;\n\t\t}\n\t\ttl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_RESET);\n\t\tDELAY(500);\n\t\tphy_sts = tl_phy_readreg(sc, PHY_BMCR);\n\t\tphy_sts |= PHY_BMCR_AUTONEGENBL|PHY_BMCR_AUTONEGRSTR;\n\t\ttl_phy_writereg(sc, PHY_BMCR, phy_sts);\n\t\tifp->if_timer = 10;\n\t\tsc->tl_autoneg = 1;\n\t\tsc->tl_want_auto = 0;\n\t\treturn;\n\tcase TL_FLAG_DELAYTIMEO:\n\t\tifp->if_timer = 0;\n\t\tsc->tl_autoneg = 0;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"tl%d: invalid autoneg flag: %d\\n\", sc->tl_unit, flag);\n\t\treturn;\n\t}\n\n\t/*\n \t * Read the BMSR register twice: the LINKSTAT bit is a\n\t * latching bit.\n\t */\n\ttl_phy_readreg(sc, PHY_BMSR);\n\tphy_sts = tl_phy_readreg(sc, PHY_BMSR);\n\tif (phy_sts & PHY_BMSR_AUTONEGCOMP) {\n\t\tif (verbose)\n\t\t\tprintf(\"tl%d: autoneg complete, \", sc->tl_unit);\n\t\tphy_sts = tl_phy_readreg(sc, PHY_BMSR);\n\t} else {\n\t\tif (verbose)\n\t\t\tprintf(\"tl%d: autoneg not complete, \", sc->tl_unit);\n\t}\n\n\t/* Link is good. Report modes and set duplex mode. */\n\tif (phy_sts & PHY_BMSR_LINKSTAT) {\n\t\tif (verbose)\n\t\t\tprintf(\"link status good \");\n\n\t\tadvert = tl_phy_readreg(sc, TL_PHY_ANAR);\n\t\tability = tl_phy_readreg(sc, TL_PHY_LPAR);\n\t\tmedia = tl_phy_readreg(sc, PHY_BMCR);\n\n\t\t/*\n\t \t * Be sure to turn off the ISOLATE and\n\t\t * LOOPBACK bits in the control register,\n\t\t * otherwise we may not be able to communicate.\n\t\t */\n\t\tmedia &= ~(PHY_BMCR_LOOPBK|PHY_BMCR_ISOLATE);\n\t\t/* Set the DUPLEX bit in the NetCmd register accordingly. */\n\t\tif (advert & PHY_ANAR_100BT4 && ability & PHY_ANAR_100BT4) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_100_T4;\n\t\t\tmedia |= PHY_BMCR_SPEEDSEL;\n\t\t\tmedia &= ~PHY_BMCR_DUPLEX;\n\t\t\tif (verbose)\n\t\t\t\tprintf(\"(100baseT4)\\n\");\n\t\t} else if (advert & PHY_ANAR_100BTXFULL &&\n\t\t\tability & PHY_ANAR_100BTXFULL) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_100_TX|IFM_FDX;\n\t\t\tmedia |= PHY_BMCR_SPEEDSEL;\n\t\t\tmedia |= PHY_BMCR_DUPLEX;\n\t\t\tif (verbose)\n\t\t\t\tprintf(\"(full-duplex, 100Mbps)\\n\");\n\t\t} else if (advert & PHY_ANAR_100BTXHALF &&\n\t\t\tability & PHY_ANAR_100BTXHALF) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_100_TX|IFM_HDX;\n\t\t\tmedia |= PHY_BMCR_SPEEDSEL;\n\t\t\tmedia &= ~PHY_BMCR_DUPLEX;\n\t\t\tif (verbose)\n\t\t\t\tprintf(\"(half-duplex, 100Mbps)\\n\");\n\t\t} else if (advert & PHY_ANAR_10BTFULL &&\n\t\t\tability & PHY_ANAR_10BTFULL) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_10_T|IFM_FDX;\n\t\t\tmedia &= ~PHY_BMCR_SPEEDSEL;\n\t\t\tmedia |= PHY_BMCR_DUPLEX;\n\t\t\tif (verbose)\n\t\t\t\tprintf(\"(full-duplex, 10Mbps)\\n\");\n\t\t} else {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_10_T|IFM_HDX;\n\t\t\tmedia &= ~PHY_BMCR_SPEEDSEL;\n\t\t\tmedia &= ~PHY_BMCR_DUPLEX;\n\t\t\tif (verbose)\n\t\t\t\tprintf(\"(half-duplex, 10Mbps)\\n\");\n\t\t}\n\n\t\tif (media & PHY_BMCR_DUPLEX)\n\t\t\ttl_dio_setbit(sc, TL_NETCMD, TL_CMD_DUPLEX);\n\t\telse\n\t\t\ttl_dio_clrbit(sc, TL_NETCMD, TL_CMD_DUPLEX);\n\n\t\tmedia &= ~PHY_BMCR_AUTONEGENBL;\n\t\ttl_phy_writereg(sc, PHY_BMCR, media);\n\t} else {\n\t\tif (verbose)\n\t\t\tprintf(\"no carrier\\n\");\n\t}\n\n\ttl_init(sc);\n\n\tif (sc->tl_tx_pend) {\n\t\tsc->tl_autoneg = 0;\n\t\tsc->tl_tx_pend = 0;\n\t\ttl_start(ifp);\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void tl_start",
            "void tl_init",
            "u_int16_t tl_phy_readreg",
            "void tl_phy_writereg",
            "void tl_autoneg",
            "void tl_dio_setbit",
            "void tl_dio_clrbit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_start;\nvoid tl_init;\nu_int16_t tl_phy_readreg;\nvoid tl_phy_writereg;\nvoid tl_autoneg;\nvoid tl_dio_setbit;\nvoid tl_dio_clrbit;\n\nvoid tl_autoneg(sc, flag, verbose)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\tflag;\n\tint\t\t\tverbose;\n{\n\tu_int16_t\t\tphy_sts = 0, media = 0, advert, ability;\n\tstruct ifnet\t\t*ifp;\n\tstruct ifmedia\t\t*ifm;\n\n\tifm = &sc->ifmedia;\n\tifp = &sc->arpcom.ac_if;\n\n\t/*\n\t * First, see if autoneg is supported. If not, there's\n\t * no point in continuing.\n\t */\n\tphy_sts = tl_phy_readreg(sc, PHY_BMSR);\n\tif (!(phy_sts & PHY_BMSR_CANAUTONEG)) {\n\t\tif (verbose)\n\t\t\tprintf(\"tl%d: autonegotiation not supported\\n\",\n\t\t\t\t\t\t\tsc->tl_unit);\n\t\treturn;\n\t}\n\n\tswitch (flag) {\n\tcase TL_FLAG_FORCEDELAY:\n\t\t/*\n\t \t * XXX Never use this option anywhere but in the probe\n\t \t * routine: making the kernel stop dead in its tracks\n \t\t * for three whole seconds after we've gone multi-user\n\t\t * is really bad manners.\n\t \t */\n\t\ttl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_RESET);\n\t\tDELAY(500);\n\t\tphy_sts = tl_phy_readreg(sc, PHY_BMCR);\n\t\tphy_sts |= PHY_BMCR_AUTONEGENBL|PHY_BMCR_AUTONEGRSTR;\n\t\ttl_phy_writereg(sc, PHY_BMCR, phy_sts);\n\t\tDELAY(5000000);\n\t\tbreak;\n\tcase TL_FLAG_SCHEDDELAY:\n\t\t/*\n\t\t * Wait for the transmitter to go idle before starting\n\t\t * an autoneg session, otherwise tl_start() may clobber\n\t \t * our timeout, and we don't want to allow transmission\n\t\t * during an autoneg session since that can screw it up.\n\t \t */\n\t\tif (!sc->tl_txeoc) {\n\t\t\tsc->tl_want_auto = 1;\n\t\t\treturn;\n\t\t}\n\t\ttl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_RESET);\n\t\tDELAY(500);\n\t\tphy_sts = tl_phy_readreg(sc, PHY_BMCR);\n\t\tphy_sts |= PHY_BMCR_AUTONEGENBL|PHY_BMCR_AUTONEGRSTR;\n\t\ttl_phy_writereg(sc, PHY_BMCR, phy_sts);\n\t\tifp->if_timer = 10;\n\t\tsc->tl_autoneg = 1;\n\t\tsc->tl_want_auto = 0;\n\t\treturn;\n\tcase TL_FLAG_DELAYTIMEO:\n\t\tifp->if_timer = 0;\n\t\tsc->tl_autoneg = 0;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"tl%d: invalid autoneg flag: %d\\n\", sc->tl_unit, flag);\n\t\treturn;\n\t}\n\n\t/*\n \t * Read the BMSR register twice: the LINKSTAT bit is a\n\t * latching bit.\n\t */\n\ttl_phy_readreg(sc, PHY_BMSR);\n\tphy_sts = tl_phy_readreg(sc, PHY_BMSR);\n\tif (phy_sts & PHY_BMSR_AUTONEGCOMP) {\n\t\tif (verbose)\n\t\t\tprintf(\"tl%d: autoneg complete, \", sc->tl_unit);\n\t\tphy_sts = tl_phy_readreg(sc, PHY_BMSR);\n\t} else {\n\t\tif (verbose)\n\t\t\tprintf(\"tl%d: autoneg not complete, \", sc->tl_unit);\n\t}\n\n\t/* Link is good. Report modes and set duplex mode. */\n\tif (phy_sts & PHY_BMSR_LINKSTAT) {\n\t\tif (verbose)\n\t\t\tprintf(\"link status good \");\n\n\t\tadvert = tl_phy_readreg(sc, TL_PHY_ANAR);\n\t\tability = tl_phy_readreg(sc, TL_PHY_LPAR);\n\t\tmedia = tl_phy_readreg(sc, PHY_BMCR);\n\n\t\t/*\n\t \t * Be sure to turn off the ISOLATE and\n\t\t * LOOPBACK bits in the control register,\n\t\t * otherwise we may not be able to communicate.\n\t\t */\n\t\tmedia &= ~(PHY_BMCR_LOOPBK|PHY_BMCR_ISOLATE);\n\t\t/* Set the DUPLEX bit in the NetCmd register accordingly. */\n\t\tif (advert & PHY_ANAR_100BT4 && ability & PHY_ANAR_100BT4) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_100_T4;\n\t\t\tmedia |= PHY_BMCR_SPEEDSEL;\n\t\t\tmedia &= ~PHY_BMCR_DUPLEX;\n\t\t\tif (verbose)\n\t\t\t\tprintf(\"(100baseT4)\\n\");\n\t\t} else if (advert & PHY_ANAR_100BTXFULL &&\n\t\t\tability & PHY_ANAR_100BTXFULL) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_100_TX|IFM_FDX;\n\t\t\tmedia |= PHY_BMCR_SPEEDSEL;\n\t\t\tmedia |= PHY_BMCR_DUPLEX;\n\t\t\tif (verbose)\n\t\t\t\tprintf(\"(full-duplex, 100Mbps)\\n\");\n\t\t} else if (advert & PHY_ANAR_100BTXHALF &&\n\t\t\tability & PHY_ANAR_100BTXHALF) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_100_TX|IFM_HDX;\n\t\t\tmedia |= PHY_BMCR_SPEEDSEL;\n\t\t\tmedia &= ~PHY_BMCR_DUPLEX;\n\t\t\tif (verbose)\n\t\t\t\tprintf(\"(half-duplex, 100Mbps)\\n\");\n\t\t} else if (advert & PHY_ANAR_10BTFULL &&\n\t\t\tability & PHY_ANAR_10BTFULL) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_10_T|IFM_FDX;\n\t\t\tmedia &= ~PHY_BMCR_SPEEDSEL;\n\t\t\tmedia |= PHY_BMCR_DUPLEX;\n\t\t\tif (verbose)\n\t\t\t\tprintf(\"(full-duplex, 10Mbps)\\n\");\n\t\t} else {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_10_T|IFM_HDX;\n\t\t\tmedia &= ~PHY_BMCR_SPEEDSEL;\n\t\t\tmedia &= ~PHY_BMCR_DUPLEX;\n\t\t\tif (verbose)\n\t\t\t\tprintf(\"(half-duplex, 10Mbps)\\n\");\n\t\t}\n\n\t\tif (media & PHY_BMCR_DUPLEX)\n\t\t\ttl_dio_setbit(sc, TL_NETCMD, TL_CMD_DUPLEX);\n\t\telse\n\t\t\ttl_dio_clrbit(sc, TL_NETCMD, TL_CMD_DUPLEX);\n\n\t\tmedia &= ~PHY_BMCR_AUTONEGENBL;\n\t\ttl_phy_writereg(sc, PHY_BMCR, media);\n\t} else {\n\t\tif (verbose)\n\t\t\tprintf(\"no carrier\\n\");\n\t}\n\n\ttl_init(sc);\n\n\tif (sc->tl_tx_pend) {\n\t\tsc->tl_autoneg = 0;\n\t\tsc->tl_tx_pend = 0;\n\t\ttl_start(ifp);\n\t}\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tl_phy_readreg",
          "args": [
            "sc",
            "PHY_BMSR"
          ],
          "line": 2317
        },
        "resolved": true,
        "details": {
          "function_name": "tl_phy_readreg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "722-738",
          "snippet": "u_int16_t tl_phy_readreg(sc, reg)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tstruct tl_mii_frame\tframe;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = sc->tl_phy_addr;\n\tframe.mii_regaddr = reg;\n\ttl_mii_readreg(sc, &frame);\n\n\t/* Reenable MII interrupts, just in case. */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\n\treturn(frame.mii_data);\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int tl_mii_readreg",
            "u_int16_t tl_phy_readreg",
            "void tl_dio_setbit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint tl_mii_readreg;\nu_int16_t tl_phy_readreg;\nvoid tl_dio_setbit;\n\nu_int16_t tl_phy_readreg(sc, reg)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tstruct tl_mii_frame\tframe;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = sc->tl_phy_addr;\n\tframe.mii_regaddr = reg;\n\ttl_mii_readreg(sc, &frame);\n\n\t/* Reenable MII interrupts, just in case. */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\n\treturn(frame.mii_data);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_init;\nvoid tl_watchdog;\nu_int16_t tl_phy_readreg;\nvoid tl_autoneg;\n\nvoid tl_watchdog(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct tl_softc\t\t*sc;\n\tu_int16_t\t\tbmsr;\n\n\tsc = ifp->if_softc;\n\n\tif (sc->tl_autoneg) {\n\t\ttl_autoneg(sc, TL_FLAG_DELAYTIMEO, 1);\n\t\treturn;\n\t}\n\n\t/* Check that we're still connected. */\n\ttl_phy_readreg(sc, PHY_BMSR);\n\tbmsr = tl_phy_readreg(sc, PHY_BMSR);\n\tif (!(bmsr & PHY_BMSR_LINKSTAT)) {\n\t\tprintf(\"tl%d: no carrier\\n\", sc->tl_unit);\n\t\ttl_autoneg(sc, TL_FLAG_SCHEDDELAY, 1);\n\t} else\n\t\tprintf(\"tl%d: device timeout\\n\", sc->tl_unit);\n\n\tifp->if_oerrors++;\n\n\ttl_init(sc);\n\n\treturn;\n}"
  },
  {
    "function_name": "tl_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
    "lines": "2232-2300",
    "snippet": "int tl_ioctl(ifp, command, data)\n\tstruct ifnet\t\t*ifp;\n\tu_long\t\t\tcommand;\n\tcaddr_t\t\t\tdata;\n{\n\tstruct tl_softc\t\t*sc = ifp->if_softc;\n\tstruct ifreq\t\t*ifr = (struct ifreq *) data;\n\tstruct ifaddr *ifa = (struct ifaddr *)data;\n\tint\t\t\ts, error = 0;\n\n\ts = splimp();\n\n\tif ((error = ether_ioctl(ifp, &sc->arpcom, command, data)) > 0) {\n\t\tsplx(s);\n\t\treturn error;\n\t}\n\n\tswitch(command) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\ttl_init(sc);\n\t\t\tarp_ifinit(&sc->arpcom, ifa);\n\t\t\tbreak;\n#endif /* INET */\n\t\tdefault:\n\t\t\ttl_init(sc);\n\t\t\tbreak;\n\t\t}\n\tcase SIOCSIFFLAGS:\n\t\tif (ifp->if_flags & IFF_UP) {\n\t\t\ttl_init(sc);\n\t\t} else {\n\t\t\tif (ifp->if_flags & IFF_RUNNING) {\n\t\t\t\ttl_stop(sc);\n\t\t\t}\n\t\t}\n\t\terror = 0;\n\t\tbreak;\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\t\terror = (command == SIOCADDMULTI) ?\n\t\t    ether_addmulti(ifr, &sc->arpcom) :\n\t\t    ether_delmulti(ifr, &sc->arpcom);\n\n\t\tif (error == ENETRESET) {\n\t\t\t/*\n\t\t\t * Multicast list has changed; set the hardware\n\t\t\t * filter accordingly.\n\t\t\t */\n\t\t\ttl_setmulti(sc);\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\tcase SIOCSIFMEDIA:\n\tcase SIOCGIFMEDIA:\n\t\terror = ifmedia_ioctl(ifp, ifr, &sc->ifmedia, command);\n\t\tbreak;\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\t(void)splx(s);\n\n\treturn(error);\n}",
    "includes": [
      "#include <dev/pci/if_tlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int tl_ioctl",
      "void tl_init",
      "void tl_stop",
      "void tl_setmulti"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 2297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_ioctl",
          "args": [
            "ifp",
            "ifr",
            "&sc->ifmedia",
            "command"
          ],
          "line": 2290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tl_setmulti",
          "args": [
            "sc"
          ],
          "line": 2284
        },
        "resolved": true,
        "details": {
          "function_name": "tl_setmulti",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "1118-1164",
          "snippet": "void tl_setmulti(sc)\n\tstruct tl_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tu_int32_t\t\thashes[2] = { 0, 0 };\n\tint\t\t\th, i;\n\tstruct arpcom *ac = &sc->arpcom;\n\tstruct ether_multistep step;\n\tstruct ether_multi *enm;\n\tu_int8_t\t\tdummy[] = { 0, 0, 0, 0, 0 ,0 };\n\tifp = &sc->arpcom.ac_if;\n\n\t/* First, zot all the existing filters. */\n\tfor (i = 1; i < 4; i++)\n\t\ttl_setfilt(sc, (caddr_t)&dummy, i);\n\ttl_dio_write32(sc, TL_HASH1, 0);\n\ttl_dio_write32(sc, TL_HASH2, 0);\n\n\t/* Now program new ones. */\n\tif (ifp->if_flags & IFF_ALLMULTI) {\n\t\thashes[0] = 0xFFFFFFFF;\n\t\thashes[1] = 0xFFFFFFFF;\n\t} else {\n\t\ti = 1;\n\t\tETHER_FIRST_MULTI(step, ac, enm);\n\t\twhile (enm != NULL) {\n\t\t\tif (i < 4) {\n\t\t\t\ttl_setfilt(sc, enm->enm_addrlo, i);\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\th = tl_calchash(enm->enm_addrlo);\n\t\t\tif (h < 32)\n\t\t\t\thashes[0] |= (1 << h);\n\t\t\telse\n\t\t\t\thashes[1] |= (1 << (h - 32));\n\t\t\t\t\n\t\t\tETHER_NEXT_MULTI(step, enm);\n\t\t}\n\t}\n\n\ttl_dio_write32(sc, TL_HASH1, hashes[0]);\n\ttl_dio_write32(sc, TL_HASH2, hashes[1]);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int tl_calchash",
            "void tl_setmulti",
            "void tl_setfilt",
            "void tl_dio_write32"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint tl_calchash;\nvoid tl_setmulti;\nvoid tl_setfilt;\nvoid tl_dio_write32;\n\nvoid tl_setmulti(sc)\n\tstruct tl_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tu_int32_t\t\thashes[2] = { 0, 0 };\n\tint\t\t\th, i;\n\tstruct arpcom *ac = &sc->arpcom;\n\tstruct ether_multistep step;\n\tstruct ether_multi *enm;\n\tu_int8_t\t\tdummy[] = { 0, 0, 0, 0, 0 ,0 };\n\tifp = &sc->arpcom.ac_if;\n\n\t/* First, zot all the existing filters. */\n\tfor (i = 1; i < 4; i++)\n\t\ttl_setfilt(sc, (caddr_t)&dummy, i);\n\ttl_dio_write32(sc, TL_HASH1, 0);\n\ttl_dio_write32(sc, TL_HASH2, 0);\n\n\t/* Now program new ones. */\n\tif (ifp->if_flags & IFF_ALLMULTI) {\n\t\thashes[0] = 0xFFFFFFFF;\n\t\thashes[1] = 0xFFFFFFFF;\n\t} else {\n\t\ti = 1;\n\t\tETHER_FIRST_MULTI(step, ac, enm);\n\t\twhile (enm != NULL) {\n\t\t\tif (i < 4) {\n\t\t\t\ttl_setfilt(sc, enm->enm_addrlo, i);\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\th = tl_calchash(enm->enm_addrlo);\n\t\t\tif (h < 32)\n\t\t\t\thashes[0] |= (1 << h);\n\t\t\telse\n\t\t\t\thashes[1] |= (1 << (h - 32));\n\t\t\t\t\n\t\t\tETHER_NEXT_MULTI(step, enm);\n\t\t}\n\t}\n\n\ttl_dio_write32(sc, TL_HASH1, hashes[0]);\n\ttl_dio_write32(sc, TL_HASH2, hashes[1]);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ether_delmulti",
          "args": [
            "ifr",
            "&sc->arpcom"
          ],
          "line": 2277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_addmulti",
          "args": [
            "ifr",
            "&sc->arpcom"
          ],
          "line": 2276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tl_stop",
          "args": [
            "sc"
          ],
          "line": 2268
        },
        "resolved": true,
        "details": {
          "function_name": "tl_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "2335-2399",
          "snippet": "void tl_stop(sc)\n\tstruct tl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/* Stop the stats updater. */\n\tuntimeout(tl_stats_update, sc);\n\tuntimeout(tl_wait_up, sc);\n\n\t/* Stop the transmitter */\n\tCMD_CLR(sc, TL_CMD_RT);\n\tCMD_SET(sc, TL_CMD_STOP);\n\tCSR_WRITE_4(sc, TL_CH_PARM, 0);\n\n\t/* Stop the receiver */\n\tCMD_SET(sc, TL_CMD_RT);\n\tCMD_SET(sc, TL_CMD_STOP);\n\tCSR_WRITE_4(sc, TL_CH_PARM, 0);\n\n\t/*\n\t * Disable host interrupts.\n\t */\n\tCMD_SET(sc, TL_CMD_INTSOFF);\n\n\t/*\n\t * Disable MII interrupts.\n\t */\n\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\n\t/*\n\t * Clear list pointer.\n\t */\n\tCSR_WRITE_4(sc, TL_CH_PARM, 0);\n\n\t/*\n\t * Free the RX lists.\n\t */\n\tfor (i = 0; i < TL_RX_LIST_CNT; i++) {\n\t\tif (sc->tl_cdata.tl_rx_chain[i].tl_mbuf != NULL) {\n\t\t\tm_freem(sc->tl_cdata.tl_rx_chain[i].tl_mbuf);\n\t\t\tsc->tl_cdata.tl_rx_chain[i].tl_mbuf = NULL;\n\t\t}\n\t}\n\tbzero((char *)&sc->tl_ldata->tl_rx_list,\n\t\tsizeof(sc->tl_ldata->tl_rx_list));\n\n\t/*\n\t * Free the TX list buffers.\n\t */\n\tfor (i = 0; i < TL_TX_LIST_CNT; i++) {\n\t\tif (sc->tl_cdata.tl_tx_chain[i].tl_mbuf != NULL) {\n\t\t\tm_freem(sc->tl_cdata.tl_tx_chain[i].tl_mbuf);\n\t\t\tsc->tl_cdata.tl_tx_chain[i].tl_mbuf = NULL;\n\t\t}\n\t}\n\tbzero((char *)&sc->tl_ldata->tl_tx_list,\n\t\tsizeof(sc->tl_ldata->tl_tx_list));\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void tl_wait_up",
            "void tl_stats_update",
            "void tl_stop",
            "void tl_dio_clrbit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_wait_up;\nvoid tl_stats_update;\nvoid tl_stop;\nvoid tl_dio_clrbit;\n\nvoid tl_stop(sc)\n\tstruct tl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/* Stop the stats updater. */\n\tuntimeout(tl_stats_update, sc);\n\tuntimeout(tl_wait_up, sc);\n\n\t/* Stop the transmitter */\n\tCMD_CLR(sc, TL_CMD_RT);\n\tCMD_SET(sc, TL_CMD_STOP);\n\tCSR_WRITE_4(sc, TL_CH_PARM, 0);\n\n\t/* Stop the receiver */\n\tCMD_SET(sc, TL_CMD_RT);\n\tCMD_SET(sc, TL_CMD_STOP);\n\tCSR_WRITE_4(sc, TL_CH_PARM, 0);\n\n\t/*\n\t * Disable host interrupts.\n\t */\n\tCMD_SET(sc, TL_CMD_INTSOFF);\n\n\t/*\n\t * Disable MII interrupts.\n\t */\n\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\n\t/*\n\t * Clear list pointer.\n\t */\n\tCSR_WRITE_4(sc, TL_CH_PARM, 0);\n\n\t/*\n\t * Free the RX lists.\n\t */\n\tfor (i = 0; i < TL_RX_LIST_CNT; i++) {\n\t\tif (sc->tl_cdata.tl_rx_chain[i].tl_mbuf != NULL) {\n\t\t\tm_freem(sc->tl_cdata.tl_rx_chain[i].tl_mbuf);\n\t\t\tsc->tl_cdata.tl_rx_chain[i].tl_mbuf = NULL;\n\t\t}\n\t}\n\tbzero((char *)&sc->tl_ldata->tl_rx_list,\n\t\tsizeof(sc->tl_ldata->tl_rx_list));\n\n\t/*\n\t * Free the TX list buffers.\n\t */\n\tfor (i = 0; i < TL_TX_LIST_CNT; i++) {\n\t\tif (sc->tl_cdata.tl_tx_chain[i].tl_mbuf != NULL) {\n\t\t\tm_freem(sc->tl_cdata.tl_tx_chain[i].tl_mbuf);\n\t\t\tsc->tl_cdata.tl_tx_chain[i].tl_mbuf = NULL;\n\t\t}\n\t}\n\tbzero((char *)&sc->tl_ldata->tl_tx_list,\n\t\tsizeof(sc->tl_ldata->tl_tx_list));\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tl_init",
          "args": [
            "sc"
          ],
          "line": 2265
        },
        "resolved": true,
        "details": {
          "function_name": "tl_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "2052-2156",
          "snippet": "void tl_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct tl_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n        int\t\t\ts;\n\tu_int16_t\t\tphy_sts;\n\n\tif (sc->tl_autoneg)\n\t\treturn;\n\n\ts = splimp();\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/*\n\t * Cancel pending I/O.\n\t */\n\ttl_stop(sc);\n\n\t/*\n\t * Set 'capture all frames' bit for promiscuous mode.\n\t */\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\ttl_dio_setbit(sc, TL_NETCMD, TL_CMD_CAF);\n\telse\n\t\ttl_dio_clrbit(sc, TL_NETCMD, TL_CMD_CAF);\n\n\t/*\n\t * Set capture broadcast bit to capture broadcast frames.\n\t */\n\tif (ifp->if_flags & IFF_BROADCAST)\n\t\ttl_dio_clrbit(sc, TL_NETCMD, TL_CMD_NOBRX);\n\telse\n\t\ttl_dio_setbit(sc, TL_NETCMD, TL_CMD_NOBRX);\n\n\t/* Init our MAC address */\n\ttl_setfilt(sc, (caddr_t)&sc->arpcom.ac_enaddr, 0);\n\n\t/* Init multicast filter, if needed. */\n\ttl_setmulti(sc);\n\n\t/* Init circular RX list. */\n\tif (tl_list_rx_init(sc) == ENOBUFS) {\n\t\tprintf(\"tl%d: initialization failed: no \"\n\t\t\t\"memory for rx buffers\\n\", sc->tl_unit);\n\t\ttl_stop(sc);\n\t\treturn;\n\t}\n\n\t/* Init TX pointers. */\n\ttl_list_tx_init(sc);\n\n\t/*\n\t * Enable PHY interrupts.\n\t */\n\tphy_sts = tl_phy_readreg(sc, TL_PHY_CTL);\n\tphy_sts |= PHY_CTL_INTEN;\n\ttl_phy_writereg(sc, TL_PHY_CTL, phy_sts);\n\n\t/* Enable MII interrupts. */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\n\t/* Enable PCI interrupts. */\n\tCMD_SET(sc, TL_CMD_INTSON);\n\n\t/* Load the address of the rx list */\n\tCMD_SET(sc, TL_CMD_RT);\n\tCSR_WRITE_4(sc, TL_CH_PARM, vtophys(&sc->tl_ldata->tl_rx_list[0]));\n\n\t/*\n\t * XXX This is a kludge to handle adapters with the Micro Linear\n\t * ML6692 100BaseTX PHY, which only supports 100Mbps modes and\n\t * relies on the controller's internal 10Mbps PHY to provide\n\t * 10Mbps modes. The ML6692 always shows up with a vendor/device ID\n\t * of 0 (it doesn't actually have vendor/device ID registers)\n\t * so we use that property to detect it. In theory there ought to\n\t * be a better way to 'spot the looney' but I can't find one.\n         */\n        if (!sc->tl_phy_vid) {\n                u_int8_t                        addr = 0;\n                u_int16_t                       bmcr;\n\n                bmcr = tl_phy_readreg(sc, PHY_BMCR);\n                addr = sc->tl_phy_addr;\n                sc->tl_phy_addr = TL_PHYADDR_MAX;\n                tl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_RESET);\n                if (bmcr & PHY_BMCR_SPEEDSEL)\n                        tl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_ISOLATE);\n                else\n                        tl_phy_writereg(sc, PHY_BMCR, bmcr);\n                sc->tl_phy_addr = addr;\n        }\n\n\t/* Send the RX go command */\n\tCMD_SET(sc, TL_CMD_GO|TL_CMD_RT);\n\n\t(void)splx(s);\n\n\t/* Start the stats update counter */\n\ttimeout(tl_stats_update, sc, hz);\n\ttimeout(tl_wait_up, sc, 2 * hz);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void tl_wait_up",
            "void tl_stats_update",
            "void tl_init",
            "void tl_stop",
            "u_int16_t tl_phy_readreg",
            "void tl_phy_writereg",
            "void tl_autoneg",
            "void tl_setmulti",
            "void tl_setfilt",
            "int tl_list_rx_init",
            "int tl_list_tx_init",
            "void tl_dio_setbit",
            "void tl_dio_clrbit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_wait_up;\nvoid tl_stats_update;\nvoid tl_init;\nvoid tl_stop;\nu_int16_t tl_phy_readreg;\nvoid tl_phy_writereg;\nvoid tl_autoneg;\nvoid tl_setmulti;\nvoid tl_setfilt;\nint tl_list_rx_init;\nint tl_list_tx_init;\nvoid tl_dio_setbit;\nvoid tl_dio_clrbit;\n\nvoid tl_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct tl_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n        int\t\t\ts;\n\tu_int16_t\t\tphy_sts;\n\n\tif (sc->tl_autoneg)\n\t\treturn;\n\n\ts = splimp();\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/*\n\t * Cancel pending I/O.\n\t */\n\ttl_stop(sc);\n\n\t/*\n\t * Set 'capture all frames' bit for promiscuous mode.\n\t */\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\ttl_dio_setbit(sc, TL_NETCMD, TL_CMD_CAF);\n\telse\n\t\ttl_dio_clrbit(sc, TL_NETCMD, TL_CMD_CAF);\n\n\t/*\n\t * Set capture broadcast bit to capture broadcast frames.\n\t */\n\tif (ifp->if_flags & IFF_BROADCAST)\n\t\ttl_dio_clrbit(sc, TL_NETCMD, TL_CMD_NOBRX);\n\telse\n\t\ttl_dio_setbit(sc, TL_NETCMD, TL_CMD_NOBRX);\n\n\t/* Init our MAC address */\n\ttl_setfilt(sc, (caddr_t)&sc->arpcom.ac_enaddr, 0);\n\n\t/* Init multicast filter, if needed. */\n\ttl_setmulti(sc);\n\n\t/* Init circular RX list. */\n\tif (tl_list_rx_init(sc) == ENOBUFS) {\n\t\tprintf(\"tl%d: initialization failed: no \"\n\t\t\t\"memory for rx buffers\\n\", sc->tl_unit);\n\t\ttl_stop(sc);\n\t\treturn;\n\t}\n\n\t/* Init TX pointers. */\n\ttl_list_tx_init(sc);\n\n\t/*\n\t * Enable PHY interrupts.\n\t */\n\tphy_sts = tl_phy_readreg(sc, TL_PHY_CTL);\n\tphy_sts |= PHY_CTL_INTEN;\n\ttl_phy_writereg(sc, TL_PHY_CTL, phy_sts);\n\n\t/* Enable MII interrupts. */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\n\t/* Enable PCI interrupts. */\n\tCMD_SET(sc, TL_CMD_INTSON);\n\n\t/* Load the address of the rx list */\n\tCMD_SET(sc, TL_CMD_RT);\n\tCSR_WRITE_4(sc, TL_CH_PARM, vtophys(&sc->tl_ldata->tl_rx_list[0]));\n\n\t/*\n\t * XXX This is a kludge to handle adapters with the Micro Linear\n\t * ML6692 100BaseTX PHY, which only supports 100Mbps modes and\n\t * relies on the controller's internal 10Mbps PHY to provide\n\t * 10Mbps modes. The ML6692 always shows up with a vendor/device ID\n\t * of 0 (it doesn't actually have vendor/device ID registers)\n\t * so we use that property to detect it. In theory there ought to\n\t * be a better way to 'spot the looney' but I can't find one.\n         */\n        if (!sc->tl_phy_vid) {\n                u_int8_t                        addr = 0;\n                u_int16_t                       bmcr;\n\n                bmcr = tl_phy_readreg(sc, PHY_BMCR);\n                addr = sc->tl_phy_addr;\n                sc->tl_phy_addr = TL_PHYADDR_MAX;\n                tl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_RESET);\n                if (bmcr & PHY_BMCR_SPEEDSEL)\n                        tl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_ISOLATE);\n                else\n                        tl_phy_writereg(sc, PHY_BMCR, bmcr);\n                sc->tl_phy_addr = addr;\n        }\n\n\t/* Send the RX go command */\n\tCMD_SET(sc, TL_CMD_GO|TL_CMD_RT);\n\n\t(void)splx(s);\n\n\t/* Start the stats update counter */\n\ttimeout(tl_stats_update, sc, hz);\n\ttimeout(tl_wait_up, sc, 2 * hz);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arp_ifinit",
          "args": [
            "&sc->arpcom",
            "ifa"
          ],
          "line": 2256
        },
        "resolved": true,
        "details": {
          "function_name": "arp_ifinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_devar.h",
          "lines": "929-936",
          "snippet": "static void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}",
          "includes": [
            "#include <sys/devconf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/devconf.h>\n\nstatic void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 2245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_ioctl",
          "args": [
            "ifp",
            "&sc->arpcom",
            "command",
            "data"
          ],
          "line": 2244
        },
        "resolved": true,
        "details": {
          "function_name": "wx_ether_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
          "lines": "303-356",
          "snippet": "static int\nwx_ether_ioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tIOCTL_CMD_TYPE cmd;\n\tcaddr_t data;\n{\n\tstruct ifaddr *ifa = (struct ifaddr *) data;\n\tint error = 0;\n\twx_softc_t *sc = SOFTC_IFP(ifp);\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\t\terror = wx_init(sc);\n\t\tif (error) {\n\t\t\tifp->if_flags &= ~IFF_UP;\n\t\t\tbreak;\n\t\t}\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n#ifdef __OpenBSD__\n\t\t\tarp_ifinit(&sc->w.arpcom, ifa);\n#else\n\t\t\tarp_ifinit(ifp, ifa);\n#endif\n\t\t\tbreak;\n#endif\n#ifdef NS\n\t\tcase AF_NS:\n\t\t{\n\t\t\t register struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;\n\t\t\t if (ns_nullhost(*ina))\n\t\t\t\tina->x_host = *(union ns_host *)\n\t\t\t\t    LLADDR(ifp->if_sadl);\n\t\t\t else\n\t\t\t\tbcopy(ina->x_host.c_host, LLADDR(ifp->if_sadl),\n\t\t\t\t    ifp->if_addrlen);\n\t\t\t break;\n\t\t}\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <pci/if_wxvar.h>",
            "#include <dev/pci/if_wxvar.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int wx_init",
            "wx_eeprom_sibits __P((wx_softc_t *));",
            "wx_eeprom_cleanup __P((wx_softc_t *));",
            "wx_read_eeprom_word __P((wx_softc_t *, int));",
            "wx_mwi_whackon\t__P((wx_softc_t *));",
            "wx_mwi_unwhack\t__P((wx_softc_t *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic int wx_init;\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic int\nwx_ether_ioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tIOCTL_CMD_TYPE cmd;\n\tcaddr_t data;\n{\n\tstruct ifaddr *ifa = (struct ifaddr *) data;\n\tint error = 0;\n\twx_softc_t *sc = SOFTC_IFP(ifp);\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\t\terror = wx_init(sc);\n\t\tif (error) {\n\t\t\tifp->if_flags &= ~IFF_UP;\n\t\t\tbreak;\n\t\t}\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n#ifdef __OpenBSD__\n\t\t\tarp_ifinit(&sc->w.arpcom, ifa);\n#else\n\t\t\tarp_ifinit(ifp, ifa);\n#endif\n\t\t\tbreak;\n#endif\n#ifdef NS\n\t\tcase AF_NS:\n\t\t{\n\t\t\t register struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;\n\t\t\t if (ns_nullhost(*ina))\n\t\t\t\tina->x_host = *(union ns_host *)\n\t\t\t\t    LLADDR(ifp->if_sadl);\n\t\t\t else\n\t\t\t\tbcopy(ina->x_host.c_host, LLADDR(ifp->if_sadl),\n\t\t\t\t    ifp->if_addrlen);\n\t\t\t break;\n\t\t}\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 2242
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint tl_ioctl;\nvoid tl_init;\nvoid tl_stop;\nvoid tl_setmulti;\n\nint tl_ioctl(ifp, command, data)\n\tstruct ifnet\t\t*ifp;\n\tu_long\t\t\tcommand;\n\tcaddr_t\t\t\tdata;\n{\n\tstruct tl_softc\t\t*sc = ifp->if_softc;\n\tstruct ifreq\t\t*ifr = (struct ifreq *) data;\n\tstruct ifaddr *ifa = (struct ifaddr *)data;\n\tint\t\t\ts, error = 0;\n\n\ts = splimp();\n\n\tif ((error = ether_ioctl(ifp, &sc->arpcom, command, data)) > 0) {\n\t\tsplx(s);\n\t\treturn error;\n\t}\n\n\tswitch(command) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\ttl_init(sc);\n\t\t\tarp_ifinit(&sc->arpcom, ifa);\n\t\t\tbreak;\n#endif /* INET */\n\t\tdefault:\n\t\t\ttl_init(sc);\n\t\t\tbreak;\n\t\t}\n\tcase SIOCSIFFLAGS:\n\t\tif (ifp->if_flags & IFF_UP) {\n\t\t\ttl_init(sc);\n\t\t} else {\n\t\t\tif (ifp->if_flags & IFF_RUNNING) {\n\t\t\t\ttl_stop(sc);\n\t\t\t}\n\t\t}\n\t\terror = 0;\n\t\tbreak;\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\t\terror = (command == SIOCADDMULTI) ?\n\t\t    ether_addmulti(ifr, &sc->arpcom) :\n\t\t    ether_delmulti(ifr, &sc->arpcom);\n\n\t\tif (error == ENETRESET) {\n\t\t\t/*\n\t\t\t * Multicast list has changed; set the hardware\n\t\t\t * filter accordingly.\n\t\t\t */\n\t\t\ttl_setmulti(sc);\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\tcase SIOCSIFMEDIA:\n\tcase SIOCGIFMEDIA:\n\t\terror = ifmedia_ioctl(ifp, ifr, &sc->ifmedia, command);\n\t\tbreak;\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\t(void)splx(s);\n\n\treturn(error);\n}"
  },
  {
    "function_name": "tl_ifmedia_sts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
    "lines": "2184-2230",
    "snippet": "void tl_ifmedia_sts(ifp, ifmr)\n\tstruct ifnet\t\t*ifp;\n\tstruct ifmediareq\t*ifmr;\n{\n\tu_int16_t\t\tphy_ctl;\n\tu_int16_t\t\tphy_sts;\n\tstruct tl_softc\t\t*sc;\n\n\tsc = ifp->if_softc;\n\n\tifmr->ifm_active = IFM_ETHER;\n\tif (sc->tl_bitrate) {\n\t\tif (tl_dio_read8(sc, TL_ACOMMIT) & TL_AC_MTXD1)\n\t\t\tifmr->ifm_active = IFM_ETHER|IFM_10_5;\n\t\telse\n\t\t\tifmr->ifm_active = IFM_ETHER|IFM_10_T;\n\t\tif (tl_dio_read8(sc, TL_ACOMMIT) & TL_AC_MTXD3)\n\t\t\tifmr->ifm_active |= IFM_HDX;\n\t\telse\n\t\t\tifmr->ifm_active |= IFM_FDX;\n\t\treturn;\n\t}\n\n\tphy_ctl = tl_phy_readreg(sc, PHY_BMCR);\n\tphy_sts = tl_phy_readreg(sc, TL_PHY_CTL);\n\n\tif (phy_sts & PHY_CTL_AUISEL)\n\t\tifmr->ifm_active = IFM_ETHER|IFM_10_5;\n\n\tif (phy_ctl & PHY_BMCR_LOOPBK)\n\t\tifmr->ifm_active = IFM_ETHER|IFM_LOOP;\n\n\tif (phy_ctl & PHY_BMCR_SPEEDSEL)\n\t\tifmr->ifm_active = IFM_ETHER|IFM_100_TX;\n\telse\n\t\tifmr->ifm_active = IFM_ETHER|IFM_10_T;\n\n\tif (phy_ctl & PHY_BMCR_DUPLEX) {\n\t\tifmr->ifm_active |= IFM_FDX;\n\t\tifmr->ifm_active &= ~IFM_HDX;\n\t} else {\n\t\tifmr->ifm_active &= ~IFM_FDX;\n\t\tifmr->ifm_active |= IFM_HDX;\n\t}\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/if_tlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void tl_ifmedia_sts",
      "u_int16_t tl_phy_readreg",
      "u_int8_t tl_dio_read8"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tl_phy_readreg",
          "args": [
            "sc",
            "TL_PHY_CTL"
          ],
          "line": 2208
        },
        "resolved": true,
        "details": {
          "function_name": "tl_phy_readreg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "722-738",
          "snippet": "u_int16_t tl_phy_readreg(sc, reg)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tstruct tl_mii_frame\tframe;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = sc->tl_phy_addr;\n\tframe.mii_regaddr = reg;\n\ttl_mii_readreg(sc, &frame);\n\n\t/* Reenable MII interrupts, just in case. */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\n\treturn(frame.mii_data);\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int tl_mii_readreg",
            "u_int16_t tl_phy_readreg",
            "void tl_dio_setbit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint tl_mii_readreg;\nu_int16_t tl_phy_readreg;\nvoid tl_dio_setbit;\n\nu_int16_t tl_phy_readreg(sc, reg)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tstruct tl_mii_frame\tframe;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = sc->tl_phy_addr;\n\tframe.mii_regaddr = reg;\n\ttl_mii_readreg(sc, &frame);\n\n\t/* Reenable MII interrupts, just in case. */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\n\treturn(frame.mii_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tl_dio_read8",
          "args": [
            "sc",
            "TL_ACOMMIT"
          ],
          "line": 2200
        },
        "resolved": true,
        "details": {
          "function_name": "tl_dio_read8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "290-296",
          "snippet": "u_int8_t tl_dio_read8(sc, reg)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\treturn(CSR_READ_1(sc, TL_DIO_DATA + (reg & 3)));\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "u_int8_t tl_dio_read8"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int8_t tl_dio_read8;\n\nu_int8_t tl_dio_read8(sc, reg)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\treturn(CSR_READ_1(sc, TL_DIO_DATA + (reg & 3)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_ifmedia_sts;\nu_int16_t tl_phy_readreg;\nu_int8_t tl_dio_read8;\n\nvoid tl_ifmedia_sts(ifp, ifmr)\n\tstruct ifnet\t\t*ifp;\n\tstruct ifmediareq\t*ifmr;\n{\n\tu_int16_t\t\tphy_ctl;\n\tu_int16_t\t\tphy_sts;\n\tstruct tl_softc\t\t*sc;\n\n\tsc = ifp->if_softc;\n\n\tifmr->ifm_active = IFM_ETHER;\n\tif (sc->tl_bitrate) {\n\t\tif (tl_dio_read8(sc, TL_ACOMMIT) & TL_AC_MTXD1)\n\t\t\tifmr->ifm_active = IFM_ETHER|IFM_10_5;\n\t\telse\n\t\t\tifmr->ifm_active = IFM_ETHER|IFM_10_T;\n\t\tif (tl_dio_read8(sc, TL_ACOMMIT) & TL_AC_MTXD3)\n\t\t\tifmr->ifm_active |= IFM_HDX;\n\t\telse\n\t\t\tifmr->ifm_active |= IFM_FDX;\n\t\treturn;\n\t}\n\n\tphy_ctl = tl_phy_readreg(sc, PHY_BMCR);\n\tphy_sts = tl_phy_readreg(sc, TL_PHY_CTL);\n\n\tif (phy_sts & PHY_CTL_AUISEL)\n\t\tifmr->ifm_active = IFM_ETHER|IFM_10_5;\n\n\tif (phy_ctl & PHY_BMCR_LOOPBK)\n\t\tifmr->ifm_active = IFM_ETHER|IFM_LOOP;\n\n\tif (phy_ctl & PHY_BMCR_SPEEDSEL)\n\t\tifmr->ifm_active = IFM_ETHER|IFM_100_TX;\n\telse\n\t\tifmr->ifm_active = IFM_ETHER|IFM_10_T;\n\n\tif (phy_ctl & PHY_BMCR_DUPLEX) {\n\t\tifmr->ifm_active |= IFM_FDX;\n\t\tifmr->ifm_active &= ~IFM_HDX;\n\t} else {\n\t\tifmr->ifm_active &= ~IFM_FDX;\n\t\tifmr->ifm_active |= IFM_HDX;\n\t}\n\n\treturn;\n}"
  },
  {
    "function_name": "tl_ifmedia_upd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
    "lines": "2161-2179",
    "snippet": "int tl_ifmedia_upd(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct tl_softc\t\t*sc;\n\tstruct ifmedia\t\t*ifm;\n\n\tsc = ifp->if_softc;\n\tifm = &sc->ifmedia;\n\n\tif (IFM_TYPE(ifm->ifm_media) != IFM_ETHER)\n\t\treturn(EINVAL);\n\n\tif (IFM_SUBTYPE(ifm->ifm_media) == IFM_AUTO)\n\t\ttl_autoneg(sc, TL_FLAG_SCHEDDELAY, 1);\n\telse\n\t\ttl_setmode(sc, ifm->ifm_media);\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/pci/if_tlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int tl_ifmedia_upd",
      "void tl_autoneg",
      "void tl_setmode"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tl_setmode",
          "args": [
            "sc",
            "ifm->ifm_media"
          ],
          "line": 2176
        },
        "resolved": true,
        "details": {
          "function_name": "tl_setmode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "969-1058",
          "snippet": "void tl_setmode(sc, media)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\tmedia;\n{\n\tu_int16_t\t\tbmcr;\n\n\tif (sc->tl_bitrate) {\n\t\tif (IFM_SUBTYPE(media) == IFM_10_5)\n\t\t\ttl_dio_setbit(sc, TL_ACOMMIT, TL_AC_MTXD1);\n\t\tif (IFM_SUBTYPE(media) == IFM_10_T) {\n\t\t\ttl_dio_clrbit(sc, TL_ACOMMIT, TL_AC_MTXD1);\n\t\t\tif ((media & IFM_GMASK) == IFM_FDX) {\n\t\t\t\ttl_dio_clrbit(sc, TL_ACOMMIT, TL_AC_MTXD3);\n\t\t\t\ttl_dio_setbit(sc, TL_NETCMD, TL_CMD_DUPLEX);\n\t\t\t} else {\n\t\t\t\ttl_dio_setbit(sc, TL_ACOMMIT, TL_AC_MTXD3);\n\t\t\t\ttl_dio_clrbit(sc, TL_NETCMD, TL_CMD_DUPLEX);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\tbmcr = tl_phy_readreg(sc, PHY_BMCR);\n\n\tbmcr &= ~(PHY_BMCR_SPEEDSEL|PHY_BMCR_DUPLEX|PHY_BMCR_AUTONEGENBL|\n\t\t  PHY_BMCR_LOOPBK|PHY_BMCR_ISOLATE);\n\n\tif (IFM_SUBTYPE(media) == IFM_LOOP)\n\t\tbmcr |= PHY_BMCR_LOOPBK;\n\n\tif (IFM_SUBTYPE(media) == IFM_AUTO)\n\t\tbmcr |= PHY_BMCR_AUTONEGENBL;\n\n\t/*\n\t * The ThunderLAN's internal PHY has an AUI transceiver\n\t * that can be selected. This is usually attached to a\n\t * 10base2/BNC port. In order to activate this port, we\n\t * have to set the AUISEL bit in the internal PHY's\n\t * special control register.\n\t */\n\tif (IFM_SUBTYPE(media) == IFM_10_5) {\n\t\tu_int16_t\t\taddr, ctl;\n\t\taddr = sc->tl_phy_addr;\n\t\tsc->tl_phy_addr = TL_PHYADDR_MAX;\n\t\tctl = tl_phy_readreg(sc, TL_PHY_CTL);\n\t\tctl |= PHY_CTL_AUISEL;\n\t\ttl_phy_writereg(sc, TL_PHY_CTL, ctl);\n\t\ttl_phy_writereg(sc, PHY_BMCR, bmcr);\n\t\tsc->tl_phy_addr = addr;\n\t\tbmcr |= PHY_BMCR_ISOLATE;\n\t} else {\n\t\tu_int16_t\t\taddr, ctl;\n\t\taddr = sc->tl_phy_addr;\n\t\tsc->tl_phy_addr = TL_PHYADDR_MAX;\n\t\tctl = tl_phy_readreg(sc, TL_PHY_CTL);\n\t\tctl &= ~PHY_CTL_AUISEL;\n\t\ttl_phy_writereg(sc, TL_PHY_CTL, ctl);\n\t\ttl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_ISOLATE);\n\t\tsc->tl_phy_addr = addr;\n\t\tbmcr &= ~PHY_BMCR_ISOLATE;\n\t}\n\n\tif (IFM_SUBTYPE(media) == IFM_100_TX) {\n\t\tbmcr |= PHY_BMCR_SPEEDSEL;\n\t\tif ((media & IFM_GMASK) == IFM_FDX) {\n\t\t\tbmcr |= PHY_BMCR_DUPLEX;\n\t\t\ttl_dio_setbit(sc, TL_NETCMD, TL_CMD_DUPLEX);\n\t\t} else {\n\t\t\tbmcr &= ~PHY_BMCR_DUPLEX;\n\t\t\ttl_dio_clrbit(sc, TL_NETCMD, TL_CMD_DUPLEX);\n\t\t}\n\t}\n\n\tif (IFM_SUBTYPE(media) == IFM_10_T) {\n\t\tbmcr &= ~PHY_BMCR_SPEEDSEL;\n\t\tif ((media & IFM_GMASK) == IFM_FDX) {\n\t\t\tbmcr |= PHY_BMCR_DUPLEX;\n\t\t\ttl_dio_setbit(sc, TL_NETCMD, TL_CMD_DUPLEX);\n\t\t} else {\n\t\t\tbmcr &= ~PHY_BMCR_DUPLEX;\n\t\t\ttl_dio_clrbit(sc, TL_NETCMD, TL_CMD_DUPLEX);\n\t\t}\n\t}\n\n\ttl_phy_writereg(sc, PHY_BMCR, bmcr);\n\n\ttl_init(sc);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void tl_init",
            "u_int16_t tl_phy_readreg",
            "void tl_phy_writereg",
            "void tl_setmode",
            "void tl_dio_setbit",
            "void tl_dio_clrbit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_init;\nu_int16_t tl_phy_readreg;\nvoid tl_phy_writereg;\nvoid tl_setmode;\nvoid tl_dio_setbit;\nvoid tl_dio_clrbit;\n\nvoid tl_setmode(sc, media)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\tmedia;\n{\n\tu_int16_t\t\tbmcr;\n\n\tif (sc->tl_bitrate) {\n\t\tif (IFM_SUBTYPE(media) == IFM_10_5)\n\t\t\ttl_dio_setbit(sc, TL_ACOMMIT, TL_AC_MTXD1);\n\t\tif (IFM_SUBTYPE(media) == IFM_10_T) {\n\t\t\ttl_dio_clrbit(sc, TL_ACOMMIT, TL_AC_MTXD1);\n\t\t\tif ((media & IFM_GMASK) == IFM_FDX) {\n\t\t\t\ttl_dio_clrbit(sc, TL_ACOMMIT, TL_AC_MTXD3);\n\t\t\t\ttl_dio_setbit(sc, TL_NETCMD, TL_CMD_DUPLEX);\n\t\t\t} else {\n\t\t\t\ttl_dio_setbit(sc, TL_ACOMMIT, TL_AC_MTXD3);\n\t\t\t\ttl_dio_clrbit(sc, TL_NETCMD, TL_CMD_DUPLEX);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\tbmcr = tl_phy_readreg(sc, PHY_BMCR);\n\n\tbmcr &= ~(PHY_BMCR_SPEEDSEL|PHY_BMCR_DUPLEX|PHY_BMCR_AUTONEGENBL|\n\t\t  PHY_BMCR_LOOPBK|PHY_BMCR_ISOLATE);\n\n\tif (IFM_SUBTYPE(media) == IFM_LOOP)\n\t\tbmcr |= PHY_BMCR_LOOPBK;\n\n\tif (IFM_SUBTYPE(media) == IFM_AUTO)\n\t\tbmcr |= PHY_BMCR_AUTONEGENBL;\n\n\t/*\n\t * The ThunderLAN's internal PHY has an AUI transceiver\n\t * that can be selected. This is usually attached to a\n\t * 10base2/BNC port. In order to activate this port, we\n\t * have to set the AUISEL bit in the internal PHY's\n\t * special control register.\n\t */\n\tif (IFM_SUBTYPE(media) == IFM_10_5) {\n\t\tu_int16_t\t\taddr, ctl;\n\t\taddr = sc->tl_phy_addr;\n\t\tsc->tl_phy_addr = TL_PHYADDR_MAX;\n\t\tctl = tl_phy_readreg(sc, TL_PHY_CTL);\n\t\tctl |= PHY_CTL_AUISEL;\n\t\ttl_phy_writereg(sc, TL_PHY_CTL, ctl);\n\t\ttl_phy_writereg(sc, PHY_BMCR, bmcr);\n\t\tsc->tl_phy_addr = addr;\n\t\tbmcr |= PHY_BMCR_ISOLATE;\n\t} else {\n\t\tu_int16_t\t\taddr, ctl;\n\t\taddr = sc->tl_phy_addr;\n\t\tsc->tl_phy_addr = TL_PHYADDR_MAX;\n\t\tctl = tl_phy_readreg(sc, TL_PHY_CTL);\n\t\tctl &= ~PHY_CTL_AUISEL;\n\t\ttl_phy_writereg(sc, TL_PHY_CTL, ctl);\n\t\ttl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_ISOLATE);\n\t\tsc->tl_phy_addr = addr;\n\t\tbmcr &= ~PHY_BMCR_ISOLATE;\n\t}\n\n\tif (IFM_SUBTYPE(media) == IFM_100_TX) {\n\t\tbmcr |= PHY_BMCR_SPEEDSEL;\n\t\tif ((media & IFM_GMASK) == IFM_FDX) {\n\t\t\tbmcr |= PHY_BMCR_DUPLEX;\n\t\t\ttl_dio_setbit(sc, TL_NETCMD, TL_CMD_DUPLEX);\n\t\t} else {\n\t\t\tbmcr &= ~PHY_BMCR_DUPLEX;\n\t\t\ttl_dio_clrbit(sc, TL_NETCMD, TL_CMD_DUPLEX);\n\t\t}\n\t}\n\n\tif (IFM_SUBTYPE(media) == IFM_10_T) {\n\t\tbmcr &= ~PHY_BMCR_SPEEDSEL;\n\t\tif ((media & IFM_GMASK) == IFM_FDX) {\n\t\t\tbmcr |= PHY_BMCR_DUPLEX;\n\t\t\ttl_dio_setbit(sc, TL_NETCMD, TL_CMD_DUPLEX);\n\t\t} else {\n\t\t\tbmcr &= ~PHY_BMCR_DUPLEX;\n\t\t\ttl_dio_clrbit(sc, TL_NETCMD, TL_CMD_DUPLEX);\n\t\t}\n\t}\n\n\ttl_phy_writereg(sc, PHY_BMCR, bmcr);\n\n\ttl_init(sc);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tl_autoneg",
          "args": [
            "sc",
            "TL_FLAG_SCHEDDELAY",
            "1"
          ],
          "line": 2174
        },
        "resolved": true,
        "details": {
          "function_name": "tl_autoneg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "808-963",
          "snippet": "void tl_autoneg(sc, flag, verbose)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\tflag;\n\tint\t\t\tverbose;\n{\n\tu_int16_t\t\tphy_sts = 0, media = 0, advert, ability;\n\tstruct ifnet\t\t*ifp;\n\tstruct ifmedia\t\t*ifm;\n\n\tifm = &sc->ifmedia;\n\tifp = &sc->arpcom.ac_if;\n\n\t/*\n\t * First, see if autoneg is supported. If not, there's\n\t * no point in continuing.\n\t */\n\tphy_sts = tl_phy_readreg(sc, PHY_BMSR);\n\tif (!(phy_sts & PHY_BMSR_CANAUTONEG)) {\n\t\tif (verbose)\n\t\t\tprintf(\"tl%d: autonegotiation not supported\\n\",\n\t\t\t\t\t\t\tsc->tl_unit);\n\t\treturn;\n\t}\n\n\tswitch (flag) {\n\tcase TL_FLAG_FORCEDELAY:\n\t\t/*\n\t \t * XXX Never use this option anywhere but in the probe\n\t \t * routine: making the kernel stop dead in its tracks\n \t\t * for three whole seconds after we've gone multi-user\n\t\t * is really bad manners.\n\t \t */\n\t\ttl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_RESET);\n\t\tDELAY(500);\n\t\tphy_sts = tl_phy_readreg(sc, PHY_BMCR);\n\t\tphy_sts |= PHY_BMCR_AUTONEGENBL|PHY_BMCR_AUTONEGRSTR;\n\t\ttl_phy_writereg(sc, PHY_BMCR, phy_sts);\n\t\tDELAY(5000000);\n\t\tbreak;\n\tcase TL_FLAG_SCHEDDELAY:\n\t\t/*\n\t\t * Wait for the transmitter to go idle before starting\n\t\t * an autoneg session, otherwise tl_start() may clobber\n\t \t * our timeout, and we don't want to allow transmission\n\t\t * during an autoneg session since that can screw it up.\n\t \t */\n\t\tif (!sc->tl_txeoc) {\n\t\t\tsc->tl_want_auto = 1;\n\t\t\treturn;\n\t\t}\n\t\ttl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_RESET);\n\t\tDELAY(500);\n\t\tphy_sts = tl_phy_readreg(sc, PHY_BMCR);\n\t\tphy_sts |= PHY_BMCR_AUTONEGENBL|PHY_BMCR_AUTONEGRSTR;\n\t\ttl_phy_writereg(sc, PHY_BMCR, phy_sts);\n\t\tifp->if_timer = 10;\n\t\tsc->tl_autoneg = 1;\n\t\tsc->tl_want_auto = 0;\n\t\treturn;\n\tcase TL_FLAG_DELAYTIMEO:\n\t\tifp->if_timer = 0;\n\t\tsc->tl_autoneg = 0;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"tl%d: invalid autoneg flag: %d\\n\", sc->tl_unit, flag);\n\t\treturn;\n\t}\n\n\t/*\n \t * Read the BMSR register twice: the LINKSTAT bit is a\n\t * latching bit.\n\t */\n\ttl_phy_readreg(sc, PHY_BMSR);\n\tphy_sts = tl_phy_readreg(sc, PHY_BMSR);\n\tif (phy_sts & PHY_BMSR_AUTONEGCOMP) {\n\t\tif (verbose)\n\t\t\tprintf(\"tl%d: autoneg complete, \", sc->tl_unit);\n\t\tphy_sts = tl_phy_readreg(sc, PHY_BMSR);\n\t} else {\n\t\tif (verbose)\n\t\t\tprintf(\"tl%d: autoneg not complete, \", sc->tl_unit);\n\t}\n\n\t/* Link is good. Report modes and set duplex mode. */\n\tif (phy_sts & PHY_BMSR_LINKSTAT) {\n\t\tif (verbose)\n\t\t\tprintf(\"link status good \");\n\n\t\tadvert = tl_phy_readreg(sc, TL_PHY_ANAR);\n\t\tability = tl_phy_readreg(sc, TL_PHY_LPAR);\n\t\tmedia = tl_phy_readreg(sc, PHY_BMCR);\n\n\t\t/*\n\t \t * Be sure to turn off the ISOLATE and\n\t\t * LOOPBACK bits in the control register,\n\t\t * otherwise we may not be able to communicate.\n\t\t */\n\t\tmedia &= ~(PHY_BMCR_LOOPBK|PHY_BMCR_ISOLATE);\n\t\t/* Set the DUPLEX bit in the NetCmd register accordingly. */\n\t\tif (advert & PHY_ANAR_100BT4 && ability & PHY_ANAR_100BT4) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_100_T4;\n\t\t\tmedia |= PHY_BMCR_SPEEDSEL;\n\t\t\tmedia &= ~PHY_BMCR_DUPLEX;\n\t\t\tif (verbose)\n\t\t\t\tprintf(\"(100baseT4)\\n\");\n\t\t} else if (advert & PHY_ANAR_100BTXFULL &&\n\t\t\tability & PHY_ANAR_100BTXFULL) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_100_TX|IFM_FDX;\n\t\t\tmedia |= PHY_BMCR_SPEEDSEL;\n\t\t\tmedia |= PHY_BMCR_DUPLEX;\n\t\t\tif (verbose)\n\t\t\t\tprintf(\"(full-duplex, 100Mbps)\\n\");\n\t\t} else if (advert & PHY_ANAR_100BTXHALF &&\n\t\t\tability & PHY_ANAR_100BTXHALF) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_100_TX|IFM_HDX;\n\t\t\tmedia |= PHY_BMCR_SPEEDSEL;\n\t\t\tmedia &= ~PHY_BMCR_DUPLEX;\n\t\t\tif (verbose)\n\t\t\t\tprintf(\"(half-duplex, 100Mbps)\\n\");\n\t\t} else if (advert & PHY_ANAR_10BTFULL &&\n\t\t\tability & PHY_ANAR_10BTFULL) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_10_T|IFM_FDX;\n\t\t\tmedia &= ~PHY_BMCR_SPEEDSEL;\n\t\t\tmedia |= PHY_BMCR_DUPLEX;\n\t\t\tif (verbose)\n\t\t\t\tprintf(\"(full-duplex, 10Mbps)\\n\");\n\t\t} else {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_10_T|IFM_HDX;\n\t\t\tmedia &= ~PHY_BMCR_SPEEDSEL;\n\t\t\tmedia &= ~PHY_BMCR_DUPLEX;\n\t\t\tif (verbose)\n\t\t\t\tprintf(\"(half-duplex, 10Mbps)\\n\");\n\t\t}\n\n\t\tif (media & PHY_BMCR_DUPLEX)\n\t\t\ttl_dio_setbit(sc, TL_NETCMD, TL_CMD_DUPLEX);\n\t\telse\n\t\t\ttl_dio_clrbit(sc, TL_NETCMD, TL_CMD_DUPLEX);\n\n\t\tmedia &= ~PHY_BMCR_AUTONEGENBL;\n\t\ttl_phy_writereg(sc, PHY_BMCR, media);\n\t} else {\n\t\tif (verbose)\n\t\t\tprintf(\"no carrier\\n\");\n\t}\n\n\ttl_init(sc);\n\n\tif (sc->tl_tx_pend) {\n\t\tsc->tl_autoneg = 0;\n\t\tsc->tl_tx_pend = 0;\n\t\ttl_start(ifp);\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void tl_start",
            "void tl_init",
            "u_int16_t tl_phy_readreg",
            "void tl_phy_writereg",
            "void tl_autoneg",
            "void tl_dio_setbit",
            "void tl_dio_clrbit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_start;\nvoid tl_init;\nu_int16_t tl_phy_readreg;\nvoid tl_phy_writereg;\nvoid tl_autoneg;\nvoid tl_dio_setbit;\nvoid tl_dio_clrbit;\n\nvoid tl_autoneg(sc, flag, verbose)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\tflag;\n\tint\t\t\tverbose;\n{\n\tu_int16_t\t\tphy_sts = 0, media = 0, advert, ability;\n\tstruct ifnet\t\t*ifp;\n\tstruct ifmedia\t\t*ifm;\n\n\tifm = &sc->ifmedia;\n\tifp = &sc->arpcom.ac_if;\n\n\t/*\n\t * First, see if autoneg is supported. If not, there's\n\t * no point in continuing.\n\t */\n\tphy_sts = tl_phy_readreg(sc, PHY_BMSR);\n\tif (!(phy_sts & PHY_BMSR_CANAUTONEG)) {\n\t\tif (verbose)\n\t\t\tprintf(\"tl%d: autonegotiation not supported\\n\",\n\t\t\t\t\t\t\tsc->tl_unit);\n\t\treturn;\n\t}\n\n\tswitch (flag) {\n\tcase TL_FLAG_FORCEDELAY:\n\t\t/*\n\t \t * XXX Never use this option anywhere but in the probe\n\t \t * routine: making the kernel stop dead in its tracks\n \t\t * for three whole seconds after we've gone multi-user\n\t\t * is really bad manners.\n\t \t */\n\t\ttl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_RESET);\n\t\tDELAY(500);\n\t\tphy_sts = tl_phy_readreg(sc, PHY_BMCR);\n\t\tphy_sts |= PHY_BMCR_AUTONEGENBL|PHY_BMCR_AUTONEGRSTR;\n\t\ttl_phy_writereg(sc, PHY_BMCR, phy_sts);\n\t\tDELAY(5000000);\n\t\tbreak;\n\tcase TL_FLAG_SCHEDDELAY:\n\t\t/*\n\t\t * Wait for the transmitter to go idle before starting\n\t\t * an autoneg session, otherwise tl_start() may clobber\n\t \t * our timeout, and we don't want to allow transmission\n\t\t * during an autoneg session since that can screw it up.\n\t \t */\n\t\tif (!sc->tl_txeoc) {\n\t\t\tsc->tl_want_auto = 1;\n\t\t\treturn;\n\t\t}\n\t\ttl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_RESET);\n\t\tDELAY(500);\n\t\tphy_sts = tl_phy_readreg(sc, PHY_BMCR);\n\t\tphy_sts |= PHY_BMCR_AUTONEGENBL|PHY_BMCR_AUTONEGRSTR;\n\t\ttl_phy_writereg(sc, PHY_BMCR, phy_sts);\n\t\tifp->if_timer = 10;\n\t\tsc->tl_autoneg = 1;\n\t\tsc->tl_want_auto = 0;\n\t\treturn;\n\tcase TL_FLAG_DELAYTIMEO:\n\t\tifp->if_timer = 0;\n\t\tsc->tl_autoneg = 0;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"tl%d: invalid autoneg flag: %d\\n\", sc->tl_unit, flag);\n\t\treturn;\n\t}\n\n\t/*\n \t * Read the BMSR register twice: the LINKSTAT bit is a\n\t * latching bit.\n\t */\n\ttl_phy_readreg(sc, PHY_BMSR);\n\tphy_sts = tl_phy_readreg(sc, PHY_BMSR);\n\tif (phy_sts & PHY_BMSR_AUTONEGCOMP) {\n\t\tif (verbose)\n\t\t\tprintf(\"tl%d: autoneg complete, \", sc->tl_unit);\n\t\tphy_sts = tl_phy_readreg(sc, PHY_BMSR);\n\t} else {\n\t\tif (verbose)\n\t\t\tprintf(\"tl%d: autoneg not complete, \", sc->tl_unit);\n\t}\n\n\t/* Link is good. Report modes and set duplex mode. */\n\tif (phy_sts & PHY_BMSR_LINKSTAT) {\n\t\tif (verbose)\n\t\t\tprintf(\"link status good \");\n\n\t\tadvert = tl_phy_readreg(sc, TL_PHY_ANAR);\n\t\tability = tl_phy_readreg(sc, TL_PHY_LPAR);\n\t\tmedia = tl_phy_readreg(sc, PHY_BMCR);\n\n\t\t/*\n\t \t * Be sure to turn off the ISOLATE and\n\t\t * LOOPBACK bits in the control register,\n\t\t * otherwise we may not be able to communicate.\n\t\t */\n\t\tmedia &= ~(PHY_BMCR_LOOPBK|PHY_BMCR_ISOLATE);\n\t\t/* Set the DUPLEX bit in the NetCmd register accordingly. */\n\t\tif (advert & PHY_ANAR_100BT4 && ability & PHY_ANAR_100BT4) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_100_T4;\n\t\t\tmedia |= PHY_BMCR_SPEEDSEL;\n\t\t\tmedia &= ~PHY_BMCR_DUPLEX;\n\t\t\tif (verbose)\n\t\t\t\tprintf(\"(100baseT4)\\n\");\n\t\t} else if (advert & PHY_ANAR_100BTXFULL &&\n\t\t\tability & PHY_ANAR_100BTXFULL) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_100_TX|IFM_FDX;\n\t\t\tmedia |= PHY_BMCR_SPEEDSEL;\n\t\t\tmedia |= PHY_BMCR_DUPLEX;\n\t\t\tif (verbose)\n\t\t\t\tprintf(\"(full-duplex, 100Mbps)\\n\");\n\t\t} else if (advert & PHY_ANAR_100BTXHALF &&\n\t\t\tability & PHY_ANAR_100BTXHALF) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_100_TX|IFM_HDX;\n\t\t\tmedia |= PHY_BMCR_SPEEDSEL;\n\t\t\tmedia &= ~PHY_BMCR_DUPLEX;\n\t\t\tif (verbose)\n\t\t\t\tprintf(\"(half-duplex, 100Mbps)\\n\");\n\t\t} else if (advert & PHY_ANAR_10BTFULL &&\n\t\t\tability & PHY_ANAR_10BTFULL) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_10_T|IFM_FDX;\n\t\t\tmedia &= ~PHY_BMCR_SPEEDSEL;\n\t\t\tmedia |= PHY_BMCR_DUPLEX;\n\t\t\tif (verbose)\n\t\t\t\tprintf(\"(full-duplex, 10Mbps)\\n\");\n\t\t} else {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_10_T|IFM_HDX;\n\t\t\tmedia &= ~PHY_BMCR_SPEEDSEL;\n\t\t\tmedia &= ~PHY_BMCR_DUPLEX;\n\t\t\tif (verbose)\n\t\t\t\tprintf(\"(half-duplex, 10Mbps)\\n\");\n\t\t}\n\n\t\tif (media & PHY_BMCR_DUPLEX)\n\t\t\ttl_dio_setbit(sc, TL_NETCMD, TL_CMD_DUPLEX);\n\t\telse\n\t\t\ttl_dio_clrbit(sc, TL_NETCMD, TL_CMD_DUPLEX);\n\n\t\tmedia &= ~PHY_BMCR_AUTONEGENBL;\n\t\ttl_phy_writereg(sc, PHY_BMCR, media);\n\t} else {\n\t\tif (verbose)\n\t\t\tprintf(\"no carrier\\n\");\n\t}\n\n\ttl_init(sc);\n\n\tif (sc->tl_tx_pend) {\n\t\tsc->tl_autoneg = 0;\n\t\tsc->tl_tx_pend = 0;\n\t\ttl_start(ifp);\n\t}\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IFM_SUBTYPE",
          "args": [
            "ifm->ifm_media"
          ],
          "line": 2173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFM_TYPE",
          "args": [
            "ifm->ifm_media"
          ],
          "line": 2170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint tl_ifmedia_upd;\nvoid tl_autoneg;\nvoid tl_setmode;\n\nint tl_ifmedia_upd(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct tl_softc\t\t*sc;\n\tstruct ifmedia\t\t*ifm;\n\n\tsc = ifp->if_softc;\n\tifm = &sc->ifmedia;\n\n\tif (IFM_TYPE(ifm->ifm_media) != IFM_ETHER)\n\t\treturn(EINVAL);\n\n\tif (IFM_SUBTYPE(ifm->ifm_media) == IFM_AUTO)\n\t\ttl_autoneg(sc, TL_FLAG_SCHEDDELAY, 1);\n\telse\n\t\ttl_setmode(sc, ifm->ifm_media);\n\n\treturn(0);\n}"
  },
  {
    "function_name": "tl_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
    "lines": "2052-2156",
    "snippet": "void tl_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct tl_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n        int\t\t\ts;\n\tu_int16_t\t\tphy_sts;\n\n\tif (sc->tl_autoneg)\n\t\treturn;\n\n\ts = splimp();\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/*\n\t * Cancel pending I/O.\n\t */\n\ttl_stop(sc);\n\n\t/*\n\t * Set 'capture all frames' bit for promiscuous mode.\n\t */\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\ttl_dio_setbit(sc, TL_NETCMD, TL_CMD_CAF);\n\telse\n\t\ttl_dio_clrbit(sc, TL_NETCMD, TL_CMD_CAF);\n\n\t/*\n\t * Set capture broadcast bit to capture broadcast frames.\n\t */\n\tif (ifp->if_flags & IFF_BROADCAST)\n\t\ttl_dio_clrbit(sc, TL_NETCMD, TL_CMD_NOBRX);\n\telse\n\t\ttl_dio_setbit(sc, TL_NETCMD, TL_CMD_NOBRX);\n\n\t/* Init our MAC address */\n\ttl_setfilt(sc, (caddr_t)&sc->arpcom.ac_enaddr, 0);\n\n\t/* Init multicast filter, if needed. */\n\ttl_setmulti(sc);\n\n\t/* Init circular RX list. */\n\tif (tl_list_rx_init(sc) == ENOBUFS) {\n\t\tprintf(\"tl%d: initialization failed: no \"\n\t\t\t\"memory for rx buffers\\n\", sc->tl_unit);\n\t\ttl_stop(sc);\n\t\treturn;\n\t}\n\n\t/* Init TX pointers. */\n\ttl_list_tx_init(sc);\n\n\t/*\n\t * Enable PHY interrupts.\n\t */\n\tphy_sts = tl_phy_readreg(sc, TL_PHY_CTL);\n\tphy_sts |= PHY_CTL_INTEN;\n\ttl_phy_writereg(sc, TL_PHY_CTL, phy_sts);\n\n\t/* Enable MII interrupts. */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\n\t/* Enable PCI interrupts. */\n\tCMD_SET(sc, TL_CMD_INTSON);\n\n\t/* Load the address of the rx list */\n\tCMD_SET(sc, TL_CMD_RT);\n\tCSR_WRITE_4(sc, TL_CH_PARM, vtophys(&sc->tl_ldata->tl_rx_list[0]));\n\n\t/*\n\t * XXX This is a kludge to handle adapters with the Micro Linear\n\t * ML6692 100BaseTX PHY, which only supports 100Mbps modes and\n\t * relies on the controller's internal 10Mbps PHY to provide\n\t * 10Mbps modes. The ML6692 always shows up with a vendor/device ID\n\t * of 0 (it doesn't actually have vendor/device ID registers)\n\t * so we use that property to detect it. In theory there ought to\n\t * be a better way to 'spot the looney' but I can't find one.\n         */\n        if (!sc->tl_phy_vid) {\n                u_int8_t                        addr = 0;\n                u_int16_t                       bmcr;\n\n                bmcr = tl_phy_readreg(sc, PHY_BMCR);\n                addr = sc->tl_phy_addr;\n                sc->tl_phy_addr = TL_PHYADDR_MAX;\n                tl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_RESET);\n                if (bmcr & PHY_BMCR_SPEEDSEL)\n                        tl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_ISOLATE);\n                else\n                        tl_phy_writereg(sc, PHY_BMCR, bmcr);\n                sc->tl_phy_addr = addr;\n        }\n\n\t/* Send the RX go command */\n\tCMD_SET(sc, TL_CMD_GO|TL_CMD_RT);\n\n\t(void)splx(s);\n\n\t/* Start the stats update counter */\n\ttimeout(tl_stats_update, sc, hz);\n\ttimeout(tl_wait_up, sc, 2 * hz);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/if_tlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void tl_wait_up",
      "void tl_stats_update",
      "void tl_init",
      "void tl_stop",
      "u_int16_t tl_phy_readreg",
      "void tl_phy_writereg",
      "void tl_autoneg",
      "void tl_setmulti",
      "void tl_setfilt",
      "int tl_list_rx_init",
      "int tl_list_tx_init",
      "void tl_dio_setbit",
      "void tl_dio_clrbit"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "tl_wait_up",
            "sc",
            "2 * hz"
          ],
          "line": 2153
        },
        "resolved": true,
        "details": {
          "function_name": "midi_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/midi.c",
          "lines": "478-486",
          "snippet": "void\nmidi_timeout(arg)\n\tvoid *arg;\n{\n\tstruct midi_softc *sc = arg;\n\n\tDPRINTFN(3,(\"midi_timeout: %p\\n\", sc));\n\tmidi_start_output(sc, 1);\n}",
          "includes": [
            "#include <dev/midivar.h>",
            "#include <dev/midi_if.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/midiio.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"sequencer.h\"",
            "#include \"midi.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n#include \"midi.h\"\n\nvoid\nmidi_timeout(arg)\n\tvoid *arg;\n{\n\tstruct midi_softc *sc = arg;\n\n\tDPRINTFN(3,(\"midi_timeout: %p\\n\", sc));\n\tmidi_start_output(sc, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 2149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CMD_SET",
          "args": [
            "sc",
            "TL_CMD_GO|TL_CMD_RT"
          ],
          "line": 2147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tl_phy_writereg",
          "args": [
            "sc",
            "PHY_BMCR",
            "bmcr"
          ],
          "line": 2142
        },
        "resolved": true,
        "details": {
          "function_name": "tl_phy_writereg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "740-759",
          "snippet": "void tl_phy_writereg(sc, reg, data)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tdata;\n{\n\tstruct tl_mii_frame\tframe;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = sc->tl_phy_addr;\n\tframe.mii_regaddr = reg;\n\tframe.mii_data = data;\n\n\ttl_mii_writereg(sc, &frame);\n\n\t/* Reenable MII interrupts, just in case. */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int tl_mii_writereg",
            "void tl_phy_writereg",
            "void tl_dio_setbit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint tl_mii_writereg;\nvoid tl_phy_writereg;\nvoid tl_dio_setbit;\n\nvoid tl_phy_writereg(sc, reg, data)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tdata;\n{\n\tstruct tl_mii_frame\tframe;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = sc->tl_phy_addr;\n\tframe.mii_regaddr = reg;\n\tframe.mii_data = data;\n\n\ttl_mii_writereg(sc, &frame);\n\n\t/* Reenable MII interrupts, just in case. */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tl_phy_readreg",
          "args": [
            "sc",
            "PHY_BMCR"
          ],
          "line": 2135
        },
        "resolved": true,
        "details": {
          "function_name": "tl_phy_readreg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "722-738",
          "snippet": "u_int16_t tl_phy_readreg(sc, reg)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tstruct tl_mii_frame\tframe;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = sc->tl_phy_addr;\n\tframe.mii_regaddr = reg;\n\ttl_mii_readreg(sc, &frame);\n\n\t/* Reenable MII interrupts, just in case. */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\n\treturn(frame.mii_data);\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int tl_mii_readreg",
            "u_int16_t tl_phy_readreg",
            "void tl_dio_setbit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint tl_mii_readreg;\nu_int16_t tl_phy_readreg;\nvoid tl_dio_setbit;\n\nu_int16_t tl_phy_readreg(sc, reg)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tstruct tl_mii_frame\tframe;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = sc->tl_phy_addr;\n\tframe.mii_regaddr = reg;\n\ttl_mii_readreg(sc, &frame);\n\n\t/* Reenable MII interrupts, just in case. */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\n\treturn(frame.mii_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TL_CH_PARM",
            "vtophys(&sc->tl_ldata->tl_rx_list[0])"
          ],
          "line": 2120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "&sc->tl_ldata->tl_rx_list[0]"
          ],
          "line": 2120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CMD_SET",
          "args": [
            "sc",
            "TL_CMD_RT"
          ],
          "line": 2119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CMD_SET",
          "args": [
            "sc",
            "TL_CMD_INTSON"
          ],
          "line": 2116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tl_dio_setbit",
          "args": [
            "sc",
            "TL_NETSIO",
            "TL_SIO_MINTEN"
          ],
          "line": 2113
        },
        "resolved": true,
        "details": {
          "function_name": "tl_dio_setbit16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "374-387",
          "snippet": "void tl_dio_setbit16(sc, reg, bit)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tbit;\n{\n\tu_int16_t\t\t\tf;\n\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tf = CSR_READ_2(sc, TL_DIO_DATA + (reg & 3));\n\tf |= bit;\n\tCSR_WRITE_2(sc, TL_DIO_DATA + (reg & 3), f);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void tl_dio_setbit16"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_dio_setbit16;\n\nvoid tl_dio_setbit16(sc, reg, bit)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tbit;\n{\n\tu_int16_t\t\t\tf;\n\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tf = CSR_READ_2(sc, TL_DIO_DATA + (reg & 3));\n\tf |= bit;\n\tCSR_WRITE_2(sc, TL_DIO_DATA + (reg & 3), f);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tl_list_tx_init",
          "args": [
            "sc"
          ],
          "line": 2103
        },
        "resolved": true,
        "details": {
          "function_name": "tl_list_tx_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "1383-1405",
          "snippet": "int tl_list_tx_init(sc)\n\tstruct tl_softc\t\t*sc;\n{\n\tstruct tl_chain_data\t*cd;\n\tstruct tl_list_data\t*ld;\n\tint\t\t\ti;\n\n\tcd = &sc->tl_cdata;\n\tld = sc->tl_ldata;\n\tfor (i = 0; i < TL_TX_LIST_CNT; i++) {\n\t\tcd->tl_tx_chain[i].tl_ptr = &ld->tl_tx_list[i];\n\t\tif (i == (TL_TX_LIST_CNT - 1))\n\t\t\tcd->tl_tx_chain[i].tl_next = NULL;\n\t\telse\n\t\t\tcd->tl_tx_chain[i].tl_next = &cd->tl_tx_chain[i + 1];\n\t}\n\n\tcd->tl_tx_free = &cd->tl_tx_chain[0];\n\tcd->tl_tx_tail = cd->tl_tx_head = NULL;\n\tsc->tl_txeoc = 1;\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int tl_list_tx_init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint tl_list_tx_init;\n\nint tl_list_tx_init(sc)\n\tstruct tl_softc\t\t*sc;\n{\n\tstruct tl_chain_data\t*cd;\n\tstruct tl_list_data\t*ld;\n\tint\t\t\ti;\n\n\tcd = &sc->tl_cdata;\n\tld = sc->tl_ldata;\n\tfor (i = 0; i < TL_TX_LIST_CNT; i++) {\n\t\tcd->tl_tx_chain[i].tl_ptr = &ld->tl_tx_list[i];\n\t\tif (i == (TL_TX_LIST_CNT - 1))\n\t\t\tcd->tl_tx_chain[i].tl_next = NULL;\n\t\telse\n\t\t\tcd->tl_tx_chain[i].tl_next = &cd->tl_tx_chain[i + 1];\n\t}\n\n\tcd->tl_tx_free = &cd->tl_tx_chain[0];\n\tcd->tl_tx_tail = cd->tl_tx_head = NULL;\n\tsc->tl_txeoc = 1;\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tl_stop",
          "args": [
            "sc"
          ],
          "line": 2098
        },
        "resolved": true,
        "details": {
          "function_name": "tl_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "2335-2399",
          "snippet": "void tl_stop(sc)\n\tstruct tl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/* Stop the stats updater. */\n\tuntimeout(tl_stats_update, sc);\n\tuntimeout(tl_wait_up, sc);\n\n\t/* Stop the transmitter */\n\tCMD_CLR(sc, TL_CMD_RT);\n\tCMD_SET(sc, TL_CMD_STOP);\n\tCSR_WRITE_4(sc, TL_CH_PARM, 0);\n\n\t/* Stop the receiver */\n\tCMD_SET(sc, TL_CMD_RT);\n\tCMD_SET(sc, TL_CMD_STOP);\n\tCSR_WRITE_4(sc, TL_CH_PARM, 0);\n\n\t/*\n\t * Disable host interrupts.\n\t */\n\tCMD_SET(sc, TL_CMD_INTSOFF);\n\n\t/*\n\t * Disable MII interrupts.\n\t */\n\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\n\t/*\n\t * Clear list pointer.\n\t */\n\tCSR_WRITE_4(sc, TL_CH_PARM, 0);\n\n\t/*\n\t * Free the RX lists.\n\t */\n\tfor (i = 0; i < TL_RX_LIST_CNT; i++) {\n\t\tif (sc->tl_cdata.tl_rx_chain[i].tl_mbuf != NULL) {\n\t\t\tm_freem(sc->tl_cdata.tl_rx_chain[i].tl_mbuf);\n\t\t\tsc->tl_cdata.tl_rx_chain[i].tl_mbuf = NULL;\n\t\t}\n\t}\n\tbzero((char *)&sc->tl_ldata->tl_rx_list,\n\t\tsizeof(sc->tl_ldata->tl_rx_list));\n\n\t/*\n\t * Free the TX list buffers.\n\t */\n\tfor (i = 0; i < TL_TX_LIST_CNT; i++) {\n\t\tif (sc->tl_cdata.tl_tx_chain[i].tl_mbuf != NULL) {\n\t\t\tm_freem(sc->tl_cdata.tl_tx_chain[i].tl_mbuf);\n\t\t\tsc->tl_cdata.tl_tx_chain[i].tl_mbuf = NULL;\n\t\t}\n\t}\n\tbzero((char *)&sc->tl_ldata->tl_tx_list,\n\t\tsizeof(sc->tl_ldata->tl_tx_list));\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void tl_wait_up",
            "void tl_stats_update",
            "void tl_stop",
            "void tl_dio_clrbit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_wait_up;\nvoid tl_stats_update;\nvoid tl_stop;\nvoid tl_dio_clrbit;\n\nvoid tl_stop(sc)\n\tstruct tl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/* Stop the stats updater. */\n\tuntimeout(tl_stats_update, sc);\n\tuntimeout(tl_wait_up, sc);\n\n\t/* Stop the transmitter */\n\tCMD_CLR(sc, TL_CMD_RT);\n\tCMD_SET(sc, TL_CMD_STOP);\n\tCSR_WRITE_4(sc, TL_CH_PARM, 0);\n\n\t/* Stop the receiver */\n\tCMD_SET(sc, TL_CMD_RT);\n\tCMD_SET(sc, TL_CMD_STOP);\n\tCSR_WRITE_4(sc, TL_CH_PARM, 0);\n\n\t/*\n\t * Disable host interrupts.\n\t */\n\tCMD_SET(sc, TL_CMD_INTSOFF);\n\n\t/*\n\t * Disable MII interrupts.\n\t */\n\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\n\t/*\n\t * Clear list pointer.\n\t */\n\tCSR_WRITE_4(sc, TL_CH_PARM, 0);\n\n\t/*\n\t * Free the RX lists.\n\t */\n\tfor (i = 0; i < TL_RX_LIST_CNT; i++) {\n\t\tif (sc->tl_cdata.tl_rx_chain[i].tl_mbuf != NULL) {\n\t\t\tm_freem(sc->tl_cdata.tl_rx_chain[i].tl_mbuf);\n\t\t\tsc->tl_cdata.tl_rx_chain[i].tl_mbuf = NULL;\n\t\t}\n\t}\n\tbzero((char *)&sc->tl_ldata->tl_rx_list,\n\t\tsizeof(sc->tl_ldata->tl_rx_list));\n\n\t/*\n\t * Free the TX list buffers.\n\t */\n\tfor (i = 0; i < TL_TX_LIST_CNT; i++) {\n\t\tif (sc->tl_cdata.tl_tx_chain[i].tl_mbuf != NULL) {\n\t\t\tm_freem(sc->tl_cdata.tl_tx_chain[i].tl_mbuf);\n\t\t\tsc->tl_cdata.tl_tx_chain[i].tl_mbuf = NULL;\n\t\t}\n\t}\n\tbzero((char *)&sc->tl_ldata->tl_tx_list,\n\t\tsizeof(sc->tl_ldata->tl_tx_list));\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"tl%d: initialization failed: no \"\n\t\t\t\"memory for rx buffers\\n\"",
            "sc->tl_unit"
          ],
          "line": 2096
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tl_list_rx_init",
          "args": [
            "sc"
          ],
          "line": 2095
        },
        "resolved": true,
        "details": {
          "function_name": "tl_list_rx_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "1410-1439",
          "snippet": "int tl_list_rx_init(sc)\n\tstruct tl_softc\t\t*sc;\n{\n\tstruct tl_chain_data\t*cd;\n\tstruct tl_list_data\t*ld;\n\tint\t\t\ti;\n\n\tcd = &sc->tl_cdata;\n\tld = sc->tl_ldata;\n\n\tfor (i = 0; i < TL_RX_LIST_CNT; i++) {\n\t\tcd->tl_rx_chain[i].tl_ptr =\n\t\t\t(struct tl_list_onefrag *)&ld->tl_rx_list[i];\n\t\tif (tl_newbuf(sc, &cd->tl_rx_chain[i]) == ENOBUFS)\n\t\t\treturn(ENOBUFS);\n\t\tif (i == (TL_RX_LIST_CNT - 1)) {\n\t\t\tcd->tl_rx_chain[i].tl_next = NULL;\n\t\t\tld->tl_rx_list[i].tlist_fptr = 0;\n\t\t} else {\n\t\t\tcd->tl_rx_chain[i].tl_next = &cd->tl_rx_chain[i + 1];\n\t\t\tld->tl_rx_list[i].tlist_fptr =\n\t\t\t\t\tvtophys(&ld->tl_rx_list[i + 1]);\n\t\t}\n\t}\n\n\tcd->tl_rx_head = &cd->tl_rx_chain[0];\n\tcd->tl_rx_tail = &cd->tl_rx_chain[TL_RX_LIST_CNT - 1];\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int tl_newbuf",
            "int tl_list_rx_init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint tl_newbuf;\nint tl_list_rx_init;\n\nint tl_list_rx_init(sc)\n\tstruct tl_softc\t\t*sc;\n{\n\tstruct tl_chain_data\t*cd;\n\tstruct tl_list_data\t*ld;\n\tint\t\t\ti;\n\n\tcd = &sc->tl_cdata;\n\tld = sc->tl_ldata;\n\n\tfor (i = 0; i < TL_RX_LIST_CNT; i++) {\n\t\tcd->tl_rx_chain[i].tl_ptr =\n\t\t\t(struct tl_list_onefrag *)&ld->tl_rx_list[i];\n\t\tif (tl_newbuf(sc, &cd->tl_rx_chain[i]) == ENOBUFS)\n\t\t\treturn(ENOBUFS);\n\t\tif (i == (TL_RX_LIST_CNT - 1)) {\n\t\t\tcd->tl_rx_chain[i].tl_next = NULL;\n\t\t\tld->tl_rx_list[i].tlist_fptr = 0;\n\t\t} else {\n\t\t\tcd->tl_rx_chain[i].tl_next = &cd->tl_rx_chain[i + 1];\n\t\t\tld->tl_rx_list[i].tlist_fptr =\n\t\t\t\t\tvtophys(&ld->tl_rx_list[i + 1]);\n\t\t}\n\t}\n\n\tcd->tl_rx_head = &cd->tl_rx_chain[0];\n\tcd->tl_rx_tail = &cd->tl_rx_chain[TL_RX_LIST_CNT - 1];\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tl_setmulti",
          "args": [
            "sc"
          ],
          "line": 2092
        },
        "resolved": true,
        "details": {
          "function_name": "tl_setmulti",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "1118-1164",
          "snippet": "void tl_setmulti(sc)\n\tstruct tl_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tu_int32_t\t\thashes[2] = { 0, 0 };\n\tint\t\t\th, i;\n\tstruct arpcom *ac = &sc->arpcom;\n\tstruct ether_multistep step;\n\tstruct ether_multi *enm;\n\tu_int8_t\t\tdummy[] = { 0, 0, 0, 0, 0 ,0 };\n\tifp = &sc->arpcom.ac_if;\n\n\t/* First, zot all the existing filters. */\n\tfor (i = 1; i < 4; i++)\n\t\ttl_setfilt(sc, (caddr_t)&dummy, i);\n\ttl_dio_write32(sc, TL_HASH1, 0);\n\ttl_dio_write32(sc, TL_HASH2, 0);\n\n\t/* Now program new ones. */\n\tif (ifp->if_flags & IFF_ALLMULTI) {\n\t\thashes[0] = 0xFFFFFFFF;\n\t\thashes[1] = 0xFFFFFFFF;\n\t} else {\n\t\ti = 1;\n\t\tETHER_FIRST_MULTI(step, ac, enm);\n\t\twhile (enm != NULL) {\n\t\t\tif (i < 4) {\n\t\t\t\ttl_setfilt(sc, enm->enm_addrlo, i);\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\th = tl_calchash(enm->enm_addrlo);\n\t\t\tif (h < 32)\n\t\t\t\thashes[0] |= (1 << h);\n\t\t\telse\n\t\t\t\thashes[1] |= (1 << (h - 32));\n\t\t\t\t\n\t\t\tETHER_NEXT_MULTI(step, enm);\n\t\t}\n\t}\n\n\ttl_dio_write32(sc, TL_HASH1, hashes[0]);\n\ttl_dio_write32(sc, TL_HASH2, hashes[1]);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int tl_calchash",
            "void tl_setmulti",
            "void tl_setfilt",
            "void tl_dio_write32"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint tl_calchash;\nvoid tl_setmulti;\nvoid tl_setfilt;\nvoid tl_dio_write32;\n\nvoid tl_setmulti(sc)\n\tstruct tl_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tu_int32_t\t\thashes[2] = { 0, 0 };\n\tint\t\t\th, i;\n\tstruct arpcom *ac = &sc->arpcom;\n\tstruct ether_multistep step;\n\tstruct ether_multi *enm;\n\tu_int8_t\t\tdummy[] = { 0, 0, 0, 0, 0 ,0 };\n\tifp = &sc->arpcom.ac_if;\n\n\t/* First, zot all the existing filters. */\n\tfor (i = 1; i < 4; i++)\n\t\ttl_setfilt(sc, (caddr_t)&dummy, i);\n\ttl_dio_write32(sc, TL_HASH1, 0);\n\ttl_dio_write32(sc, TL_HASH2, 0);\n\n\t/* Now program new ones. */\n\tif (ifp->if_flags & IFF_ALLMULTI) {\n\t\thashes[0] = 0xFFFFFFFF;\n\t\thashes[1] = 0xFFFFFFFF;\n\t} else {\n\t\ti = 1;\n\t\tETHER_FIRST_MULTI(step, ac, enm);\n\t\twhile (enm != NULL) {\n\t\t\tif (i < 4) {\n\t\t\t\ttl_setfilt(sc, enm->enm_addrlo, i);\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\th = tl_calchash(enm->enm_addrlo);\n\t\t\tif (h < 32)\n\t\t\t\thashes[0] |= (1 << h);\n\t\t\telse\n\t\t\t\thashes[1] |= (1 << (h - 32));\n\t\t\t\t\n\t\t\tETHER_NEXT_MULTI(step, enm);\n\t\t}\n\t}\n\n\ttl_dio_write32(sc, TL_HASH1, hashes[0]);\n\ttl_dio_write32(sc, TL_HASH2, hashes[1]);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tl_setfilt",
          "args": [
            "sc",
            "(caddr_t)&sc->arpcom.ac_enaddr",
            "0"
          ],
          "line": 2089
        },
        "resolved": true,
        "details": {
          "function_name": "tl_setfilt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "1086-1100",
          "snippet": "void tl_setfilt(sc, addr, slot)\n\tstruct tl_softc\t\t*sc;\n\tcaddr_t\t\t\taddr;\n\tint\t\t\tslot;\n{\n\tint\t\t\ti;\n\tu_int16_t\t\tregaddr;\n\n\tregaddr = TL_AREG0_B5 + (slot * ETHER_ADDR_LEN);\n\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++)\n\t\ttl_dio_write8(sc, regaddr + i, *(addr + i));\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void tl_setfilt",
            "void tl_dio_write8"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_setfilt;\nvoid tl_dio_write8;\n\nvoid tl_setfilt(sc, addr, slot)\n\tstruct tl_softc\t\t*sc;\n\tcaddr_t\t\t\taddr;\n\tint\t\t\tslot;\n{\n\tint\t\t\ti;\n\tu_int16_t\t\tregaddr;\n\n\tregaddr = TL_AREG0_B5 + (slot * ETHER_ADDR_LEN);\n\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++)\n\t\ttl_dio_write8(sc, regaddr + i, *(addr + i));\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tl_dio_clrbit",
          "args": [
            "sc",
            "TL_NETCMD",
            "TL_CMD_NOBRX"
          ],
          "line": 2084
        },
        "resolved": true,
        "details": {
          "function_name": "tl_dio_clrbit16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "389-402",
          "snippet": "void tl_dio_clrbit16(sc, reg, bit)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tbit;\n{\n\tu_int16_t\t\t\tf;\n\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tf = CSR_READ_2(sc, TL_DIO_DATA + (reg & 3));\n\tf &= ~bit;\n\tCSR_WRITE_2(sc, TL_DIO_DATA + (reg & 3), f);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void tl_dio_clrbit16"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_dio_clrbit16;\n\nvoid tl_dio_clrbit16(sc, reg, bit)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tbit;\n{\n\tu_int16_t\t\t\tf;\n\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tf = CSR_READ_2(sc, TL_DIO_DATA + (reg & 3));\n\tf &= ~bit;\n\tCSR_WRITE_2(sc, TL_DIO_DATA + (reg & 3), f);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 2063
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_wait_up;\nvoid tl_stats_update;\nvoid tl_init;\nvoid tl_stop;\nu_int16_t tl_phy_readreg;\nvoid tl_phy_writereg;\nvoid tl_autoneg;\nvoid tl_setmulti;\nvoid tl_setfilt;\nint tl_list_rx_init;\nint tl_list_tx_init;\nvoid tl_dio_setbit;\nvoid tl_dio_clrbit;\n\nvoid tl_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct tl_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n        int\t\t\ts;\n\tu_int16_t\t\tphy_sts;\n\n\tif (sc->tl_autoneg)\n\t\treturn;\n\n\ts = splimp();\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/*\n\t * Cancel pending I/O.\n\t */\n\ttl_stop(sc);\n\n\t/*\n\t * Set 'capture all frames' bit for promiscuous mode.\n\t */\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\ttl_dio_setbit(sc, TL_NETCMD, TL_CMD_CAF);\n\telse\n\t\ttl_dio_clrbit(sc, TL_NETCMD, TL_CMD_CAF);\n\n\t/*\n\t * Set capture broadcast bit to capture broadcast frames.\n\t */\n\tif (ifp->if_flags & IFF_BROADCAST)\n\t\ttl_dio_clrbit(sc, TL_NETCMD, TL_CMD_NOBRX);\n\telse\n\t\ttl_dio_setbit(sc, TL_NETCMD, TL_CMD_NOBRX);\n\n\t/* Init our MAC address */\n\ttl_setfilt(sc, (caddr_t)&sc->arpcom.ac_enaddr, 0);\n\n\t/* Init multicast filter, if needed. */\n\ttl_setmulti(sc);\n\n\t/* Init circular RX list. */\n\tif (tl_list_rx_init(sc) == ENOBUFS) {\n\t\tprintf(\"tl%d: initialization failed: no \"\n\t\t\t\"memory for rx buffers\\n\", sc->tl_unit);\n\t\ttl_stop(sc);\n\t\treturn;\n\t}\n\n\t/* Init TX pointers. */\n\ttl_list_tx_init(sc);\n\n\t/*\n\t * Enable PHY interrupts.\n\t */\n\tphy_sts = tl_phy_readreg(sc, TL_PHY_CTL);\n\tphy_sts |= PHY_CTL_INTEN;\n\ttl_phy_writereg(sc, TL_PHY_CTL, phy_sts);\n\n\t/* Enable MII interrupts. */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\n\t/* Enable PCI interrupts. */\n\tCMD_SET(sc, TL_CMD_INTSON);\n\n\t/* Load the address of the rx list */\n\tCMD_SET(sc, TL_CMD_RT);\n\tCSR_WRITE_4(sc, TL_CH_PARM, vtophys(&sc->tl_ldata->tl_rx_list[0]));\n\n\t/*\n\t * XXX This is a kludge to handle adapters with the Micro Linear\n\t * ML6692 100BaseTX PHY, which only supports 100Mbps modes and\n\t * relies on the controller's internal 10Mbps PHY to provide\n\t * 10Mbps modes. The ML6692 always shows up with a vendor/device ID\n\t * of 0 (it doesn't actually have vendor/device ID registers)\n\t * so we use that property to detect it. In theory there ought to\n\t * be a better way to 'spot the looney' but I can't find one.\n         */\n        if (!sc->tl_phy_vid) {\n                u_int8_t                        addr = 0;\n                u_int16_t                       bmcr;\n\n                bmcr = tl_phy_readreg(sc, PHY_BMCR);\n                addr = sc->tl_phy_addr;\n                sc->tl_phy_addr = TL_PHYADDR_MAX;\n                tl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_RESET);\n                if (bmcr & PHY_BMCR_SPEEDSEL)\n                        tl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_ISOLATE);\n                else\n                        tl_phy_writereg(sc, PHY_BMCR, bmcr);\n                sc->tl_phy_addr = addr;\n        }\n\n\t/* Send the RX go command */\n\tCMD_SET(sc, TL_CMD_GO|TL_CMD_RT);\n\n\t(void)splx(s);\n\n\t/* Start the stats update counter */\n\ttimeout(tl_stats_update, sc, hz);\n\ttimeout(tl_wait_up, sc, 2 * hz);\n\n\treturn;\n}"
  },
  {
    "function_name": "tl_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
    "lines": "1957-2050",
    "snippet": "void tl_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct tl_softc\t\t*sc;\n\tstruct mbuf\t\t*m_head = NULL;\n\tu_int32_t\t\tcmd;\n\tstruct tl_chain\t\t*prev = NULL, *cur_tx = NULL, *start_tx;\n\n\tsc = ifp->if_softc;\n\n\tif (sc->tl_autoneg) {\n\t\tsc->tl_tx_pend = 1;\n\t\treturn;\n\t}\n\n\t/*\n\t * Check for an available queue slot. If there are none,\n\t * punt.\n\t */\n\tif (sc->tl_cdata.tl_tx_free == NULL) {\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t\treturn;\n\t}\n\n\tstart_tx = sc->tl_cdata.tl_tx_free;\n\n\twhile(sc->tl_cdata.tl_tx_free != NULL) {\n\t\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\t\tif (m_head == NULL)\n\t\t\tbreak;\n\n\t\t/* Pick a chain member off the free list. */\n\t\tcur_tx = sc->tl_cdata.tl_tx_free;\n\t\tsc->tl_cdata.tl_tx_free = cur_tx->tl_next;\n\n\t\tcur_tx->tl_next = NULL;\n\n\t\t/* Pack the data into the list. */\n\t\ttl_encap(sc, cur_tx, m_head);\n\n\t\t/* Chain it together */\n\t\tif (prev != NULL) {\n\t\t\tprev->tl_next = cur_tx;\n\t\t\tprev->tl_ptr->tlist_fptr = vtophys(cur_tx->tl_ptr);\n\t\t}\n\t\tprev = cur_tx;\n\n\t\t/*\n\t\t * If there's a BPF listener, bounce a copy of this frame\n\t\t * to him.\n\t\t */\n#if NBPFILTER > 0\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, cur_tx->tl_mbuf);\n#endif\n\t}\n\n\t/*\n\t * If there are no packets queued, bail.\n\t */\n\tif (cur_tx == NULL)\n\t\treturn;\n\n\t/*\n\t * That's all we can stands, we can't stands no more.\n\t * If there are no other transfers pending, then issue the\n\t * TX GO command to the adapter to start things moving.\n\t * Otherwise, just leave the data in the queue and let\n\t * the EOF/EOC interrupt handler send.\n\t */\n\tif (sc->tl_cdata.tl_tx_head == NULL) {\n\t\tsc->tl_cdata.tl_tx_head = start_tx;\n\t\tsc->tl_cdata.tl_tx_tail = cur_tx;\n\n\t\tif (sc->tl_txeoc) {\n\t\t\tsc->tl_txeoc = 0;\n\t\t\tCSR_WRITE_4(sc, TL_CH_PARM, vtophys(start_tx->tl_ptr));\n\t\t\tcmd = CSR_READ_4(sc, TL_HOSTCMD);\n\t\t\tcmd &= ~TL_CMD_RT;\n\t\t\tcmd |= TL_CMD_GO|TL_CMD_INTSON;\n\t\t\tCMD_PUT(sc, cmd);\n\t\t}\n\t} else {\n\t\tsc->tl_cdata.tl_tx_tail->tl_next = start_tx;\n\t\tsc->tl_cdata.tl_tx_tail = cur_tx;\n\t}\n\n\t/*\n\t * Set a timeout in case the chip goes out to lunch.\n\t */\n\tifp->if_timer = 10;\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/if_tlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int tl_encap",
      "void tl_start",
      "void tl_autoneg"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CMD_PUT",
          "args": [
            "sc",
            "cmd"
          ],
          "line": 2037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "TL_HOSTCMD"
          ],
          "line": 2034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TL_CH_PARM",
            "vtophys(start_tx->tl_ptr)"
          ],
          "line": 2033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "start_tx->tl_ptr"
          ],
          "line": 2033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_mtap",
          "args": [
            "ifp->if_bpf",
            "cur_tx->tl_mbuf"
          ],
          "line": 2010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "cur_tx->tl_ptr"
          ],
          "line": 2000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tl_encap",
          "args": [
            "sc",
            "cur_tx",
            "m_head"
          ],
          "line": 1995
        },
        "resolved": true,
        "details": {
          "function_name": "tl_encap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "1866-1949",
          "snippet": "int tl_encap(sc, c, m_head)\n\tstruct tl_softc\t\t*sc;\n\tstruct tl_chain\t\t*c;\n\tstruct mbuf\t\t*m_head;\n{\n\tint\t\t\tfrag = 0;\n\tstruct tl_frag\t\t*f = NULL;\n\tint\t\t\ttotal_len;\n\tstruct mbuf\t\t*m;\n\n\t/*\n \t * Start packing the mbufs in this chain into\n\t * the fragment pointers. Stop when we run out\n \t * of fragments or hit the end of the mbuf chain.\n\t */\n\tm = m_head;\n\ttotal_len = 0;\n\n\tfor (m = m_head, frag = 0; m != NULL; m = m->m_next) {\n\t\tif (m->m_len != 0) {\n\t\t\tif (frag == TL_MAXFRAGS)\n\t\t\t\tbreak;\n\t\t\ttotal_len+= m->m_len;\n\t\t\tc->tl_ptr->tl_frag[frag].tlist_dadr =\n\t\t\t\tvtophys(mtod(m, vm_offset_t));\n\t\t\tc->tl_ptr->tl_frag[frag].tlist_dcnt = m->m_len;\n\t\t\tfrag++;\n\t\t}\n\t}\n\n\t/*\n\t * Handle special cases.\n\t * Special case #1: we used up all 10 fragments, but\n\t * we have more mbufs left in the chain. Copy the\n\t * data into an mbuf cluster. Note that we don't\n\t * bother clearing the values in the other fragment\n\t * pointers/counters; it wouldn't gain us anything,\n\t * and would waste cycles.\n\t */\n\tif (m != NULL) {\n\t\tstruct mbuf\t\t*m_new = NULL;\n\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\treturn(1);\n\t\t}\n\t\tif (m_head->m_pkthdr.len > MHLEN) {\n\t\t\tMCLGET(m_new, M_DONTWAIT);\n\t\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\t\tm_freem(m_new);\n\t\t\t\treturn(1);\n\t\t\t}\n\t\t}\n\t\tm_copydata(m_head, 0, m_head->m_pkthdr.len,\t\n\t\t\t\t\tmtod(m_new, caddr_t));\n\t\tm_new->m_pkthdr.len = m_new->m_len = m_head->m_pkthdr.len;\n\t\tm_freem(m_head);\n\t\tm_head = m_new;\n\t\tf = &c->tl_ptr->tl_frag[0];\n\t\tf->tlist_dadr = vtophys(mtod(m_new, caddr_t));\n\t\tf->tlist_dcnt = total_len = m_new->m_len;\n\t\tfrag = 1;\n\t}\n\n\t/*\n\t * Special case #2: the frame is smaller than the minimum\n\t * frame size. We have to pad it to make the chip happy.\n\t */\n\tif (total_len < TL_MIN_FRAMELEN) {\n\t\tf = &c->tl_ptr->tl_frag[frag];\n\t\tf->tlist_dcnt = TL_MIN_FRAMELEN - total_len;\n\t\tf->tlist_dadr = vtophys(&sc->tl_ldata->tl_pad);\n\t\ttotal_len += f->tlist_dcnt;\n\t\tfrag++;\n\t}\n\n\tc->tl_mbuf = m_head;\n\tc->tl_ptr->tl_frag[frag - 1].tlist_dcnt |= TL_LAST_FRAG;\n\tc->tl_ptr->tlist_frsize = total_len;\n\tc->tl_ptr->tlist_cstat = TL_CSTAT_READY;\n\tc->tl_ptr->tlist_fptr = 0;\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int tl_encap"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint tl_encap;\n\nint tl_encap(sc, c, m_head)\n\tstruct tl_softc\t\t*sc;\n\tstruct tl_chain\t\t*c;\n\tstruct mbuf\t\t*m_head;\n{\n\tint\t\t\tfrag = 0;\n\tstruct tl_frag\t\t*f = NULL;\n\tint\t\t\ttotal_len;\n\tstruct mbuf\t\t*m;\n\n\t/*\n \t * Start packing the mbufs in this chain into\n\t * the fragment pointers. Stop when we run out\n \t * of fragments or hit the end of the mbuf chain.\n\t */\n\tm = m_head;\n\ttotal_len = 0;\n\n\tfor (m = m_head, frag = 0; m != NULL; m = m->m_next) {\n\t\tif (m->m_len != 0) {\n\t\t\tif (frag == TL_MAXFRAGS)\n\t\t\t\tbreak;\n\t\t\ttotal_len+= m->m_len;\n\t\t\tc->tl_ptr->tl_frag[frag].tlist_dadr =\n\t\t\t\tvtophys(mtod(m, vm_offset_t));\n\t\t\tc->tl_ptr->tl_frag[frag].tlist_dcnt = m->m_len;\n\t\t\tfrag++;\n\t\t}\n\t}\n\n\t/*\n\t * Handle special cases.\n\t * Special case #1: we used up all 10 fragments, but\n\t * we have more mbufs left in the chain. Copy the\n\t * data into an mbuf cluster. Note that we don't\n\t * bother clearing the values in the other fragment\n\t * pointers/counters; it wouldn't gain us anything,\n\t * and would waste cycles.\n\t */\n\tif (m != NULL) {\n\t\tstruct mbuf\t\t*m_new = NULL;\n\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\treturn(1);\n\t\t}\n\t\tif (m_head->m_pkthdr.len > MHLEN) {\n\t\t\tMCLGET(m_new, M_DONTWAIT);\n\t\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\t\tm_freem(m_new);\n\t\t\t\treturn(1);\n\t\t\t}\n\t\t}\n\t\tm_copydata(m_head, 0, m_head->m_pkthdr.len,\t\n\t\t\t\t\tmtod(m_new, caddr_t));\n\t\tm_new->m_pkthdr.len = m_new->m_len = m_head->m_pkthdr.len;\n\t\tm_freem(m_head);\n\t\tm_head = m_new;\n\t\tf = &c->tl_ptr->tl_frag[0];\n\t\tf->tlist_dadr = vtophys(mtod(m_new, caddr_t));\n\t\tf->tlist_dcnt = total_len = m_new->m_len;\n\t\tfrag = 1;\n\t}\n\n\t/*\n\t * Special case #2: the frame is smaller than the minimum\n\t * frame size. We have to pad it to make the chip happy.\n\t */\n\tif (total_len < TL_MIN_FRAMELEN) {\n\t\tf = &c->tl_ptr->tl_frag[frag];\n\t\tf->tlist_dcnt = TL_MIN_FRAMELEN - total_len;\n\t\tf->tlist_dadr = vtophys(&sc->tl_ldata->tl_pad);\n\t\ttotal_len += f->tlist_dcnt;\n\t\tfrag++;\n\t}\n\n\tc->tl_mbuf = m_head;\n\tc->tl_ptr->tl_frag[frag - 1].tlist_dcnt |= TL_LAST_FRAG;\n\tc->tl_ptr->tlist_frsize = total_len;\n\tc->tl_ptr->tlist_cstat = TL_CSTAT_READY;\n\tc->tl_ptr->tlist_fptr = 0;\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IF_DEQUEUE",
          "args": [
            "&ifp->if_snd",
            "m_head"
          ],
          "line": 1984
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint tl_encap;\nvoid tl_start;\nvoid tl_autoneg;\n\nvoid tl_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct tl_softc\t\t*sc;\n\tstruct mbuf\t\t*m_head = NULL;\n\tu_int32_t\t\tcmd;\n\tstruct tl_chain\t\t*prev = NULL, *cur_tx = NULL, *start_tx;\n\n\tsc = ifp->if_softc;\n\n\tif (sc->tl_autoneg) {\n\t\tsc->tl_tx_pend = 1;\n\t\treturn;\n\t}\n\n\t/*\n\t * Check for an available queue slot. If there are none,\n\t * punt.\n\t */\n\tif (sc->tl_cdata.tl_tx_free == NULL) {\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t\treturn;\n\t}\n\n\tstart_tx = sc->tl_cdata.tl_tx_free;\n\n\twhile(sc->tl_cdata.tl_tx_free != NULL) {\n\t\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\t\tif (m_head == NULL)\n\t\t\tbreak;\n\n\t\t/* Pick a chain member off the free list. */\n\t\tcur_tx = sc->tl_cdata.tl_tx_free;\n\t\tsc->tl_cdata.tl_tx_free = cur_tx->tl_next;\n\n\t\tcur_tx->tl_next = NULL;\n\n\t\t/* Pack the data into the list. */\n\t\ttl_encap(sc, cur_tx, m_head);\n\n\t\t/* Chain it together */\n\t\tif (prev != NULL) {\n\t\t\tprev->tl_next = cur_tx;\n\t\t\tprev->tl_ptr->tlist_fptr = vtophys(cur_tx->tl_ptr);\n\t\t}\n\t\tprev = cur_tx;\n\n\t\t/*\n\t\t * If there's a BPF listener, bounce a copy of this frame\n\t\t * to him.\n\t\t */\n#if NBPFILTER > 0\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, cur_tx->tl_mbuf);\n#endif\n\t}\n\n\t/*\n\t * If there are no packets queued, bail.\n\t */\n\tif (cur_tx == NULL)\n\t\treturn;\n\n\t/*\n\t * That's all we can stands, we can't stands no more.\n\t * If there are no other transfers pending, then issue the\n\t * TX GO command to the adapter to start things moving.\n\t * Otherwise, just leave the data in the queue and let\n\t * the EOF/EOC interrupt handler send.\n\t */\n\tif (sc->tl_cdata.tl_tx_head == NULL) {\n\t\tsc->tl_cdata.tl_tx_head = start_tx;\n\t\tsc->tl_cdata.tl_tx_tail = cur_tx;\n\n\t\tif (sc->tl_txeoc) {\n\t\t\tsc->tl_txeoc = 0;\n\t\t\tCSR_WRITE_4(sc, TL_CH_PARM, vtophys(start_tx->tl_ptr));\n\t\t\tcmd = CSR_READ_4(sc, TL_HOSTCMD);\n\t\t\tcmd &= ~TL_CMD_RT;\n\t\t\tcmd |= TL_CMD_GO|TL_CMD_INTSON;\n\t\t\tCMD_PUT(sc, cmd);\n\t\t}\n\t} else {\n\t\tsc->tl_cdata.tl_tx_tail->tl_next = start_tx;\n\t\tsc->tl_cdata.tl_tx_tail = cur_tx;\n\t}\n\n\t/*\n\t * Set a timeout in case the chip goes out to lunch.\n\t */\n\tifp->if_timer = 10;\n\n\treturn;\n}"
  },
  {
    "function_name": "tl_encap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
    "lines": "1866-1949",
    "snippet": "int tl_encap(sc, c, m_head)\n\tstruct tl_softc\t\t*sc;\n\tstruct tl_chain\t\t*c;\n\tstruct mbuf\t\t*m_head;\n{\n\tint\t\t\tfrag = 0;\n\tstruct tl_frag\t\t*f = NULL;\n\tint\t\t\ttotal_len;\n\tstruct mbuf\t\t*m;\n\n\t/*\n \t * Start packing the mbufs in this chain into\n\t * the fragment pointers. Stop when we run out\n \t * of fragments or hit the end of the mbuf chain.\n\t */\n\tm = m_head;\n\ttotal_len = 0;\n\n\tfor (m = m_head, frag = 0; m != NULL; m = m->m_next) {\n\t\tif (m->m_len != 0) {\n\t\t\tif (frag == TL_MAXFRAGS)\n\t\t\t\tbreak;\n\t\t\ttotal_len+= m->m_len;\n\t\t\tc->tl_ptr->tl_frag[frag].tlist_dadr =\n\t\t\t\tvtophys(mtod(m, vm_offset_t));\n\t\t\tc->tl_ptr->tl_frag[frag].tlist_dcnt = m->m_len;\n\t\t\tfrag++;\n\t\t}\n\t}\n\n\t/*\n\t * Handle special cases.\n\t * Special case #1: we used up all 10 fragments, but\n\t * we have more mbufs left in the chain. Copy the\n\t * data into an mbuf cluster. Note that we don't\n\t * bother clearing the values in the other fragment\n\t * pointers/counters; it wouldn't gain us anything,\n\t * and would waste cycles.\n\t */\n\tif (m != NULL) {\n\t\tstruct mbuf\t\t*m_new = NULL;\n\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\treturn(1);\n\t\t}\n\t\tif (m_head->m_pkthdr.len > MHLEN) {\n\t\t\tMCLGET(m_new, M_DONTWAIT);\n\t\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\t\tm_freem(m_new);\n\t\t\t\treturn(1);\n\t\t\t}\n\t\t}\n\t\tm_copydata(m_head, 0, m_head->m_pkthdr.len,\t\n\t\t\t\t\tmtod(m_new, caddr_t));\n\t\tm_new->m_pkthdr.len = m_new->m_len = m_head->m_pkthdr.len;\n\t\tm_freem(m_head);\n\t\tm_head = m_new;\n\t\tf = &c->tl_ptr->tl_frag[0];\n\t\tf->tlist_dadr = vtophys(mtod(m_new, caddr_t));\n\t\tf->tlist_dcnt = total_len = m_new->m_len;\n\t\tfrag = 1;\n\t}\n\n\t/*\n\t * Special case #2: the frame is smaller than the minimum\n\t * frame size. We have to pad it to make the chip happy.\n\t */\n\tif (total_len < TL_MIN_FRAMELEN) {\n\t\tf = &c->tl_ptr->tl_frag[frag];\n\t\tf->tlist_dcnt = TL_MIN_FRAMELEN - total_len;\n\t\tf->tlist_dadr = vtophys(&sc->tl_ldata->tl_pad);\n\t\ttotal_len += f->tlist_dcnt;\n\t\tfrag++;\n\t}\n\n\tc->tl_mbuf = m_head;\n\tc->tl_ptr->tl_frag[frag - 1].tlist_dcnt |= TL_LAST_FRAG;\n\tc->tl_ptr->tlist_frsize = total_len;\n\tc->tl_ptr->tlist_cstat = TL_CSTAT_READY;\n\tc->tl_ptr->tlist_fptr = 0;\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/pci/if_tlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int tl_encap"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "&sc->tl_ldata->tl_pad"
          ],
          "line": 1937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "mtod(m_new, caddr_t)"
          ],
          "line": 1925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m_new",
            "caddr_t"
          ],
          "line": 1925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m_head"
          ],
          "line": 1922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_copydata",
          "args": [
            "m_head",
            "0",
            "m_head->m_pkthdr.len",
            "mtod(m_new, caddr_t)"
          ],
          "line": 1919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m_new",
            "caddr_t"
          ],
          "line": 1920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m_new"
          ],
          "line": 1915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MCLGET",
          "args": [
            "m_new",
            "M_DONTWAIT"
          ],
          "line": 1913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MGETHDR",
          "args": [
            "m_new",
            "M_DONTWAIT",
            "MT_DATA"
          ],
          "line": 1908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "mtod(m, vm_offset_t)"
          ],
          "line": 1890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "vm_offset_t"
          ],
          "line": 1890
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint tl_encap;\n\nint tl_encap(sc, c, m_head)\n\tstruct tl_softc\t\t*sc;\n\tstruct tl_chain\t\t*c;\n\tstruct mbuf\t\t*m_head;\n{\n\tint\t\t\tfrag = 0;\n\tstruct tl_frag\t\t*f = NULL;\n\tint\t\t\ttotal_len;\n\tstruct mbuf\t\t*m;\n\n\t/*\n \t * Start packing the mbufs in this chain into\n\t * the fragment pointers. Stop when we run out\n \t * of fragments or hit the end of the mbuf chain.\n\t */\n\tm = m_head;\n\ttotal_len = 0;\n\n\tfor (m = m_head, frag = 0; m != NULL; m = m->m_next) {\n\t\tif (m->m_len != 0) {\n\t\t\tif (frag == TL_MAXFRAGS)\n\t\t\t\tbreak;\n\t\t\ttotal_len+= m->m_len;\n\t\t\tc->tl_ptr->tl_frag[frag].tlist_dadr =\n\t\t\t\tvtophys(mtod(m, vm_offset_t));\n\t\t\tc->tl_ptr->tl_frag[frag].tlist_dcnt = m->m_len;\n\t\t\tfrag++;\n\t\t}\n\t}\n\n\t/*\n\t * Handle special cases.\n\t * Special case #1: we used up all 10 fragments, but\n\t * we have more mbufs left in the chain. Copy the\n\t * data into an mbuf cluster. Note that we don't\n\t * bother clearing the values in the other fragment\n\t * pointers/counters; it wouldn't gain us anything,\n\t * and would waste cycles.\n\t */\n\tif (m != NULL) {\n\t\tstruct mbuf\t\t*m_new = NULL;\n\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\treturn(1);\n\t\t}\n\t\tif (m_head->m_pkthdr.len > MHLEN) {\n\t\t\tMCLGET(m_new, M_DONTWAIT);\n\t\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\t\tm_freem(m_new);\n\t\t\t\treturn(1);\n\t\t\t}\n\t\t}\n\t\tm_copydata(m_head, 0, m_head->m_pkthdr.len,\t\n\t\t\t\t\tmtod(m_new, caddr_t));\n\t\tm_new->m_pkthdr.len = m_new->m_len = m_head->m_pkthdr.len;\n\t\tm_freem(m_head);\n\t\tm_head = m_new;\n\t\tf = &c->tl_ptr->tl_frag[0];\n\t\tf->tlist_dadr = vtophys(mtod(m_new, caddr_t));\n\t\tf->tlist_dcnt = total_len = m_new->m_len;\n\t\tfrag = 1;\n\t}\n\n\t/*\n\t * Special case #2: the frame is smaller than the minimum\n\t * frame size. We have to pad it to make the chip happy.\n\t */\n\tif (total_len < TL_MIN_FRAMELEN) {\n\t\tf = &c->tl_ptr->tl_frag[frag];\n\t\tf->tlist_dcnt = TL_MIN_FRAMELEN - total_len;\n\t\tf->tlist_dadr = vtophys(&sc->tl_ldata->tl_pad);\n\t\ttotal_len += f->tlist_dcnt;\n\t\tfrag++;\n\t}\n\n\tc->tl_mbuf = m_head;\n\tc->tl_ptr->tl_frag[frag - 1].tlist_dcnt |= TL_LAST_FRAG;\n\tc->tl_ptr->tlist_frsize = total_len;\n\tc->tl_ptr->tlist_cstat = TL_CSTAT_READY;\n\tc->tl_ptr->tlist_fptr = 0;\n\n\treturn(0);\n}"
  },
  {
    "function_name": "tl_stats_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
    "lines": "1827-1860",
    "snippet": "void tl_stats_update(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct tl_softc\t\t*sc;\n\tstruct ifnet\t\t*ifp;\n\tstruct tl_stats\t\ttl_stats;\n\tu_int32_t\t\t*p;\n\n\tbzero((char *)&tl_stats, sizeof(struct tl_stats));\n\n\tsc = xsc;\n\tifp = &sc->arpcom.ac_if;\n\n\tp = (u_int32_t *)&tl_stats;\n\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, TL_TXGOODFRAMES|TL_DIO_ADDR_INC);\n\t*p++ = CSR_READ_4(sc, TL_DIO_DATA);\n\t*p++ = CSR_READ_4(sc, TL_DIO_DATA);\n\t*p++ = CSR_READ_4(sc, TL_DIO_DATA);\n\t*p++ = CSR_READ_4(sc, TL_DIO_DATA);\n\t*p++ = CSR_READ_4(sc, TL_DIO_DATA);\n\n\tifp->if_opackets += tl_tx_goodframes(tl_stats);\n\tifp->if_collisions += tl_stats.tl_tx_single_collision +\n\t\t\t\ttl_stats.tl_tx_multi_collision;\n\tifp->if_ipackets += tl_rx_goodframes(tl_stats);\n\tifp->if_ierrors += tl_stats.tl_crc_errors + tl_stats.tl_code_errors +\n\t\t\t    tl_rx_overrun(tl_stats);\n\tifp->if_oerrors += tl_tx_underrun(tl_stats);\n\n\ttimeout(tl_stats_update, sc, hz);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/if_tlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void tl_stats_update"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "tl_stats_update",
            "sc",
            "hz"
          ],
          "line": 1857
        },
        "resolved": true,
        "details": {
          "function_name": "midi_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/midi.c",
          "lines": "478-486",
          "snippet": "void\nmidi_timeout(arg)\n\tvoid *arg;\n{\n\tstruct midi_softc *sc = arg;\n\n\tDPRINTFN(3,(\"midi_timeout: %p\\n\", sc));\n\tmidi_start_output(sc, 1);\n}",
          "includes": [
            "#include <dev/midivar.h>",
            "#include <dev/midi_if.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/midiio.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"sequencer.h\"",
            "#include \"midi.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n#include \"midi.h\"\n\nvoid\nmidi_timeout(arg)\n\tvoid *arg;\n{\n\tstruct midi_softc *sc = arg;\n\n\tDPRINTFN(3,(\"midi_timeout: %p\\n\", sc));\n\tmidi_start_output(sc, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tl_tx_underrun",
          "args": [
            "tl_stats"
          ],
          "line": 1855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tl_rx_overrun",
          "args": [
            "tl_stats"
          ],
          "line": 1854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tl_rx_goodframes",
          "args": [
            "tl_stats"
          ],
          "line": 1852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tl_tx_goodframes",
          "args": [
            "tl_stats"
          ],
          "line": 1849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "TL_DIO_DATA"
          ],
          "line": 1847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "TL_DIO_DATA"
          ],
          "line": 1846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "TL_DIO_DATA"
          ],
          "line": 1845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "TL_DIO_DATA"
          ],
          "line": 1844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "TL_DIO_DATA"
          ],
          "line": 1843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "TL_DIO_ADDR",
            "TL_TXGOODFRAMES|TL_DIO_ADDR_INC"
          ],
          "line": 1842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char *)&tl_stats",
            "sizeof(struct tl_stats)"
          ],
          "line": 1835
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_stats_update;\n\nvoid tl_stats_update(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct tl_softc\t\t*sc;\n\tstruct ifnet\t\t*ifp;\n\tstruct tl_stats\t\ttl_stats;\n\tu_int32_t\t\t*p;\n\n\tbzero((char *)&tl_stats, sizeof(struct tl_stats));\n\n\tsc = xsc;\n\tifp = &sc->arpcom.ac_if;\n\n\tp = (u_int32_t *)&tl_stats;\n\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, TL_TXGOODFRAMES|TL_DIO_ADDR_INC);\n\t*p++ = CSR_READ_4(sc, TL_DIO_DATA);\n\t*p++ = CSR_READ_4(sc, TL_DIO_DATA);\n\t*p++ = CSR_READ_4(sc, TL_DIO_DATA);\n\t*p++ = CSR_READ_4(sc, TL_DIO_DATA);\n\t*p++ = CSR_READ_4(sc, TL_DIO_DATA);\n\n\tifp->if_opackets += tl_tx_goodframes(tl_stats);\n\tifp->if_collisions += tl_stats.tl_tx_single_collision +\n\t\t\t\ttl_stats.tl_tx_multi_collision;\n\tifp->if_ipackets += tl_rx_goodframes(tl_stats);\n\tifp->if_ierrors += tl_stats.tl_crc_errors + tl_stats.tl_code_errors +\n\t\t\t    tl_rx_overrun(tl_stats);\n\tifp->if_oerrors += tl_tx_underrun(tl_stats);\n\n\ttimeout(tl_stats_update, sc, hz);\n\n\treturn;\n}"
  },
  {
    "function_name": "tl_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
    "lines": "1754-1825",
    "snippet": "int tl_intr(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct tl_softc\t\t*sc;\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\tr = 0;\n\tu_int32_t\t\ttype = 0;\n\tu_int16_t\t\tints = 0;\n\tu_int8_t\t\tivec = 0;\n\n\tsc = xsc;\n\n\t/* Disable interrupts */\n\tints = CSR_READ_2(sc, TL_HOST_INT);\n\tCSR_WRITE_2(sc, TL_HOST_INT, ints);\n\ttype = (ints << 16) & 0xFFFF0000;\n\tivec = (ints & TL_VEC_MASK) >> 5;\n\tints = (ints & TL_INT_MASK) >> 2;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tswitch(ints) {\n\tcase (TL_INTR_INVALID):\n#ifdef DIAGNOSTIC\n\t\tif (sc->tl_empty_intr == 0)\n\t\t\tprintf(\"tl%d: got an invalid interrupt!\\n\", sc->tl_unit);\n#endif\n\t\t/* Re-enable interrupts but don't ack this one. */\n\t\tCMD_PUT(sc, type);\n\t\tr = 0;\n\t\tbreak;\n\tcase (TL_INTR_TXEOF):\n\t\tr = tl_intvec_txeof((void *)sc, type);\n\t\tbreak;\n\tcase (TL_INTR_TXEOC):\n\t\tr = tl_intvec_txeoc((void *)sc, type);\n\t\tbreak;\n\tcase (TL_INTR_STATOFLOW):\n\t\ttl_stats_update(sc);\n\t\tr = 1;\n\t\tbreak;\n\tcase (TL_INTR_RXEOF):\n\t\tr = tl_intvec_rxeof((void *)sc, type);\n\t\tbreak;\n\tcase (TL_INTR_DUMMY):\n\t\tprintf(\"tl%d: got a dummy interrupt\\n\", sc->tl_unit);\n\t\tr = 1;\n\t\tbreak;\n\tcase (TL_INTR_ADCHK):\n\t\tif (ivec)\n\t\t\tr = tl_intvec_adchk((void *)sc, type);\n\t\telse\n\t\t\tr = tl_intvec_netsts((void *)sc, type);\n\t\tbreak;\n\tcase (TL_INTR_RXEOC):\n\t\tr = tl_intvec_rxeoc((void *)sc, type);\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"tl%d: bogus interrupt type\\n\", sc->tl_unit);\n\t\tbreak;\n\t}\n\n\t/* Re-enable interrupts */\n\tif (r) {\n\t\tCMD_PUT(sc, TL_CMD_ACK | r | type);\n\t}\n\n\tif (ifp->if_snd.ifq_head != NULL)\n\t\ttl_start(ifp);\n\n\treturn r;\n}",
    "includes": [
      "#include <dev/pci/if_tlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int tl_intvec_rxeoc",
      "int tl_intvec_txeoc",
      "int tl_intvec_txeof",
      "int tl_intvec_rxeof",
      "int tl_intvec_adchk",
      "int tl_intvec_netsts",
      "void tl_stats_update",
      "int tl_intr",
      "void tl_start"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tl_start",
          "args": [
            "ifp"
          ],
          "line": 1822
        },
        "resolved": true,
        "details": {
          "function_name": "tl_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "1957-2050",
          "snippet": "void tl_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct tl_softc\t\t*sc;\n\tstruct mbuf\t\t*m_head = NULL;\n\tu_int32_t\t\tcmd;\n\tstruct tl_chain\t\t*prev = NULL, *cur_tx = NULL, *start_tx;\n\n\tsc = ifp->if_softc;\n\n\tif (sc->tl_autoneg) {\n\t\tsc->tl_tx_pend = 1;\n\t\treturn;\n\t}\n\n\t/*\n\t * Check for an available queue slot. If there are none,\n\t * punt.\n\t */\n\tif (sc->tl_cdata.tl_tx_free == NULL) {\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t\treturn;\n\t}\n\n\tstart_tx = sc->tl_cdata.tl_tx_free;\n\n\twhile(sc->tl_cdata.tl_tx_free != NULL) {\n\t\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\t\tif (m_head == NULL)\n\t\t\tbreak;\n\n\t\t/* Pick a chain member off the free list. */\n\t\tcur_tx = sc->tl_cdata.tl_tx_free;\n\t\tsc->tl_cdata.tl_tx_free = cur_tx->tl_next;\n\n\t\tcur_tx->tl_next = NULL;\n\n\t\t/* Pack the data into the list. */\n\t\ttl_encap(sc, cur_tx, m_head);\n\n\t\t/* Chain it together */\n\t\tif (prev != NULL) {\n\t\t\tprev->tl_next = cur_tx;\n\t\t\tprev->tl_ptr->tlist_fptr = vtophys(cur_tx->tl_ptr);\n\t\t}\n\t\tprev = cur_tx;\n\n\t\t/*\n\t\t * If there's a BPF listener, bounce a copy of this frame\n\t\t * to him.\n\t\t */\n#if NBPFILTER > 0\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, cur_tx->tl_mbuf);\n#endif\n\t}\n\n\t/*\n\t * If there are no packets queued, bail.\n\t */\n\tif (cur_tx == NULL)\n\t\treturn;\n\n\t/*\n\t * That's all we can stands, we can't stands no more.\n\t * If there are no other transfers pending, then issue the\n\t * TX GO command to the adapter to start things moving.\n\t * Otherwise, just leave the data in the queue and let\n\t * the EOF/EOC interrupt handler send.\n\t */\n\tif (sc->tl_cdata.tl_tx_head == NULL) {\n\t\tsc->tl_cdata.tl_tx_head = start_tx;\n\t\tsc->tl_cdata.tl_tx_tail = cur_tx;\n\n\t\tif (sc->tl_txeoc) {\n\t\t\tsc->tl_txeoc = 0;\n\t\t\tCSR_WRITE_4(sc, TL_CH_PARM, vtophys(start_tx->tl_ptr));\n\t\t\tcmd = CSR_READ_4(sc, TL_HOSTCMD);\n\t\t\tcmd &= ~TL_CMD_RT;\n\t\t\tcmd |= TL_CMD_GO|TL_CMD_INTSON;\n\t\t\tCMD_PUT(sc, cmd);\n\t\t}\n\t} else {\n\t\tsc->tl_cdata.tl_tx_tail->tl_next = start_tx;\n\t\tsc->tl_cdata.tl_tx_tail = cur_tx;\n\t}\n\n\t/*\n\t * Set a timeout in case the chip goes out to lunch.\n\t */\n\tifp->if_timer = 10;\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int tl_encap",
            "void tl_start",
            "void tl_autoneg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint tl_encap;\nvoid tl_start;\nvoid tl_autoneg;\n\nvoid tl_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct tl_softc\t\t*sc;\n\tstruct mbuf\t\t*m_head = NULL;\n\tu_int32_t\t\tcmd;\n\tstruct tl_chain\t\t*prev = NULL, *cur_tx = NULL, *start_tx;\n\n\tsc = ifp->if_softc;\n\n\tif (sc->tl_autoneg) {\n\t\tsc->tl_tx_pend = 1;\n\t\treturn;\n\t}\n\n\t/*\n\t * Check for an available queue slot. If there are none,\n\t * punt.\n\t */\n\tif (sc->tl_cdata.tl_tx_free == NULL) {\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t\treturn;\n\t}\n\n\tstart_tx = sc->tl_cdata.tl_tx_free;\n\n\twhile(sc->tl_cdata.tl_tx_free != NULL) {\n\t\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\t\tif (m_head == NULL)\n\t\t\tbreak;\n\n\t\t/* Pick a chain member off the free list. */\n\t\tcur_tx = sc->tl_cdata.tl_tx_free;\n\t\tsc->tl_cdata.tl_tx_free = cur_tx->tl_next;\n\n\t\tcur_tx->tl_next = NULL;\n\n\t\t/* Pack the data into the list. */\n\t\ttl_encap(sc, cur_tx, m_head);\n\n\t\t/* Chain it together */\n\t\tif (prev != NULL) {\n\t\t\tprev->tl_next = cur_tx;\n\t\t\tprev->tl_ptr->tlist_fptr = vtophys(cur_tx->tl_ptr);\n\t\t}\n\t\tprev = cur_tx;\n\n\t\t/*\n\t\t * If there's a BPF listener, bounce a copy of this frame\n\t\t * to him.\n\t\t */\n#if NBPFILTER > 0\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, cur_tx->tl_mbuf);\n#endif\n\t}\n\n\t/*\n\t * If there are no packets queued, bail.\n\t */\n\tif (cur_tx == NULL)\n\t\treturn;\n\n\t/*\n\t * That's all we can stands, we can't stands no more.\n\t * If there are no other transfers pending, then issue the\n\t * TX GO command to the adapter to start things moving.\n\t * Otherwise, just leave the data in the queue and let\n\t * the EOF/EOC interrupt handler send.\n\t */\n\tif (sc->tl_cdata.tl_tx_head == NULL) {\n\t\tsc->tl_cdata.tl_tx_head = start_tx;\n\t\tsc->tl_cdata.tl_tx_tail = cur_tx;\n\n\t\tif (sc->tl_txeoc) {\n\t\t\tsc->tl_txeoc = 0;\n\t\t\tCSR_WRITE_4(sc, TL_CH_PARM, vtophys(start_tx->tl_ptr));\n\t\t\tcmd = CSR_READ_4(sc, TL_HOSTCMD);\n\t\t\tcmd &= ~TL_CMD_RT;\n\t\t\tcmd |= TL_CMD_GO|TL_CMD_INTSON;\n\t\t\tCMD_PUT(sc, cmd);\n\t\t}\n\t} else {\n\t\tsc->tl_cdata.tl_tx_tail->tl_next = start_tx;\n\t\tsc->tl_cdata.tl_tx_tail = cur_tx;\n\t}\n\n\t/*\n\t * Set a timeout in case the chip goes out to lunch.\n\t */\n\tifp->if_timer = 10;\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CMD_PUT",
          "args": [
            "sc",
            "TL_CMD_ACK | r | type"
          ],
          "line": 1818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"tl%d: bogus interrupt type\\n\"",
            "sc->tl_unit"
          ],
          "line": 1812
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tl_intvec_rxeoc",
          "args": [
            "(void *)sc",
            "type"
          ],
          "line": 1809
        },
        "resolved": true,
        "details": {
          "function_name": "tl_intvec_rxeoc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "1583-1599",
          "snippet": "int tl_intvec_rxeoc(xsc, type)\n\tvoid\t\t\t*xsc;\n\tu_int32_t\t\ttype;\n{\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\tr;\n\n\tsc = xsc;\n\n\t/* Flush out the receive queue and ack RXEOF interrupts. */\n\tr = tl_intvec_rxeof(xsc, type);\n\tCMD_PUT(sc, TL_CMD_ACK | r | (type & ~(0x00100000)));\n\tr = 1;\n\tCSR_WRITE_4(sc, TL_CH_PARM, vtophys(sc->tl_cdata.tl_rx_head->tl_ptr));\n\tr |= (TL_CMD_GO|TL_CMD_RT);\n\treturn(r);\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int tl_intvec_rxeoc",
            "int tl_intvec_rxeof"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint tl_intvec_rxeoc;\nint tl_intvec_rxeof;\n\nint tl_intvec_rxeoc(xsc, type)\n\tvoid\t\t\t*xsc;\n\tu_int32_t\t\ttype;\n{\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\tr;\n\n\tsc = xsc;\n\n\t/* Flush out the receive queue and ack RXEOF interrupts. */\n\tr = tl_intvec_rxeof(xsc, type);\n\tCMD_PUT(sc, TL_CMD_ACK | r | (type & ~(0x00100000)));\n\tr = 1;\n\tCSR_WRITE_4(sc, TL_CH_PARM, vtophys(sc->tl_cdata.tl_rx_head->tl_ptr));\n\tr |= (TL_CMD_GO|TL_CMD_RT);\n\treturn(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tl_intvec_netsts",
          "args": [
            "(void *)sc",
            "type"
          ],
          "line": 1806
        },
        "resolved": true,
        "details": {
          "function_name": "tl_intvec_netsts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "1737-1752",
          "snippet": "int tl_intvec_netsts(xsc, type)\n\tvoid\t\t\t*xsc;\n\tu_int32_t\t\ttype;\n{\n\tstruct tl_softc\t\t*sc;\n\tu_int16_t\t\tnetsts;\n\n\tsc = xsc;\n\n\tnetsts = tl_dio_read16(sc, TL_NETSTS);\n\ttl_dio_write16(sc, TL_NETSTS, netsts);\n\n\tprintf(\"tl%d: network status: %x\\n\", sc->tl_unit, netsts);\n\n\treturn(1);\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int tl_intvec_netsts",
            "u_int16_t tl_dio_read16",
            "void tl_dio_write16"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint tl_intvec_netsts;\nu_int16_t tl_dio_read16;\nvoid tl_dio_write16;\n\nint tl_intvec_netsts(xsc, type)\n\tvoid\t\t\t*xsc;\n\tu_int32_t\t\ttype;\n{\n\tstruct tl_softc\t\t*sc;\n\tu_int16_t\t\tnetsts;\n\n\tsc = xsc;\n\n\tnetsts = tl_dio_read16(sc, TL_NETSTS);\n\ttl_dio_write16(sc, TL_NETSTS, netsts);\n\n\tprintf(\"tl%d: network status: %x\\n\", sc->tl_unit, netsts);\n\n\treturn(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tl_intvec_adchk",
          "args": [
            "(void *)sc",
            "type"
          ],
          "line": 1804
        },
        "resolved": true,
        "details": {
          "function_name": "tl_intvec_adchk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "1699-1735",
          "snippet": "int tl_intvec_adchk(xsc, type)\n\tvoid\t\t\t*xsc;\n\tu_int32_t\t\ttype;\n{\n\tstruct tl_softc\t\t*sc;\n\tu_int16_t\t\tbmcr, ctl;\n\n\tsc = xsc;\n\n\tif (type)\n\t\tprintf(\"tl%d: adapter check: %x\\n\", sc->tl_unit,\n\t\t\t(unsigned int)CSR_READ_4(sc, TL_CH_PARM));\n\n\t/*\n\t * Before resetting the adapter, try reading the PHY\n\t * settings so we can put them back later. This is\n\t * necessary to keep the chip operating at the same\n\t * speed and duplex settings after the reset completes.\n\t */\n\tif (!sc->tl_bitrate) {\n\t\tbmcr = tl_phy_readreg(sc, PHY_BMCR);\n\t\tctl = tl_phy_readreg(sc, TL_PHY_CTL);\n\t\ttl_softreset(sc, 1);\n\t\ttl_phy_writereg(sc, PHY_BMCR, bmcr);\n\t\ttl_phy_writereg(sc, TL_PHY_CTL, ctl);\n\t\tif (bmcr & PHY_BMCR_DUPLEX) {\n\t\t\ttl_dio_setbit(sc, TL_NETCMD, TL_CMD_DUPLEX);\n\t\t} else {\n\t\t\ttl_dio_clrbit(sc, TL_NETCMD, TL_CMD_DUPLEX);\n\t\t}\n\t}\n\ttl_stop(sc);\n\ttl_init(sc);\n\tCMD_SET(sc, TL_CMD_INTSON);\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int tl_intvec_adchk",
            "void tl_init",
            "void tl_stop",
            "u_int16_t tl_phy_readreg",
            "void tl_phy_writereg",
            "void tl_softreset",
            "void tl_dio_setbit",
            "void tl_dio_clrbit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint tl_intvec_adchk;\nvoid tl_init;\nvoid tl_stop;\nu_int16_t tl_phy_readreg;\nvoid tl_phy_writereg;\nvoid tl_softreset;\nvoid tl_dio_setbit;\nvoid tl_dio_clrbit;\n\nint tl_intvec_adchk(xsc, type)\n\tvoid\t\t\t*xsc;\n\tu_int32_t\t\ttype;\n{\n\tstruct tl_softc\t\t*sc;\n\tu_int16_t\t\tbmcr, ctl;\n\n\tsc = xsc;\n\n\tif (type)\n\t\tprintf(\"tl%d: adapter check: %x\\n\", sc->tl_unit,\n\t\t\t(unsigned int)CSR_READ_4(sc, TL_CH_PARM));\n\n\t/*\n\t * Before resetting the adapter, try reading the PHY\n\t * settings so we can put them back later. This is\n\t * necessary to keep the chip operating at the same\n\t * speed and duplex settings after the reset completes.\n\t */\n\tif (!sc->tl_bitrate) {\n\t\tbmcr = tl_phy_readreg(sc, PHY_BMCR);\n\t\tctl = tl_phy_readreg(sc, TL_PHY_CTL);\n\t\ttl_softreset(sc, 1);\n\t\ttl_phy_writereg(sc, PHY_BMCR, bmcr);\n\t\ttl_phy_writereg(sc, TL_PHY_CTL, ctl);\n\t\tif (bmcr & PHY_BMCR_DUPLEX) {\n\t\t\ttl_dio_setbit(sc, TL_NETCMD, TL_CMD_DUPLEX);\n\t\t} else {\n\t\t\ttl_dio_clrbit(sc, TL_NETCMD, TL_CMD_DUPLEX);\n\t\t}\n\t}\n\ttl_stop(sc);\n\ttl_init(sc);\n\tCMD_SET(sc, TL_CMD_INTSON);\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tl_intvec_rxeof",
          "args": [
            "(void *)sc",
            "type"
          ],
          "line": 1796
        },
        "resolved": true,
        "details": {
          "function_name": "tl_intvec_rxeof",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "1495-1574",
          "snippet": "int tl_intvec_rxeof(xsc, type)\n\tvoid\t\t\t*xsc;\n\tu_int32_t\t\ttype;\n{\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\tr = 0, total_len = 0;\n\tstruct ether_header\t*eh;\n\tstruct mbuf\t\t*m;\n\tstruct ifnet\t\t*ifp;\n\tstruct tl_chain_onefrag\t*cur_rx;\n\n\tsc = xsc;\n\tifp = &sc->arpcom.ac_if;\n\n\twhile(sc->tl_cdata.tl_rx_head->tl_ptr->tlist_cstat & TL_CSTAT_FRAMECMP){\n\t\tr++;\n\t\tcur_rx = sc->tl_cdata.tl_rx_head;\n\t\tsc->tl_cdata.tl_rx_head = cur_rx->tl_next;\n\t\tm = cur_rx->tl_mbuf;\n\t\ttotal_len = cur_rx->tl_ptr->tlist_frsize;\n\n\t\tif (tl_newbuf(sc, cur_rx) == ENOBUFS) {\n\t\t\tifp->if_ierrors++;\n\t\t\tcur_rx->tl_ptr->tlist_frsize = MCLBYTES;\n\t\t\tcur_rx->tl_ptr->tlist_cstat = TL_CSTAT_READY;\n\t\t\tcur_rx->tl_ptr->tl_frag.tlist_dcnt = MCLBYTES;\n\t\t\tcontinue;\n\t\t}\n\n\t\tsc->tl_cdata.tl_rx_tail->tl_ptr->tlist_fptr =\n\t\t\t\t\t\tvtophys(cur_rx->tl_ptr);\n\t\tsc->tl_cdata.tl_rx_tail->tl_next = cur_rx;\n\t\tsc->tl_cdata.tl_rx_tail = cur_rx;\n\n\t\teh = mtod(m, struct ether_header *);\n\t\tm->m_pkthdr.rcvif = ifp;\n\n\t\t/*\n\t\t * Note: when the ThunderLAN chip is in 'capture all\n\t\t * frames' mode, it will receive its own transmissions.\n\t\t * We drop don't need to process our own transmissions,\n\t\t * so we drop them here and continue.\n\t\t */\n\t\t/*if (ifp->if_flags & IFF_PROMISC && */\n\t\tif (!bcmp(eh->ether_shost, sc->arpcom.ac_enaddr,\n\t\t \t\t\t\t\tETHER_ADDR_LEN)) {\n\t\t\t\tm_freem(m);\n\t\t\t\tcontinue;\n\t\t}\n\n#if NBPFILTER > 0\n\t\t/*\n\t \t * Handle BPF listeners. Let the BPF user see the packet, but\n\t \t * don't pass it up to the ether_input() layer unless it's\n\t \t * a broadcast packet, multicast packet, matches our ethernet\n\t \t * address or the interface is in promiscuous mode. If we don't\n\t \t * want the packet, just forget it. We leave the mbuf in place\n\t \t * since it can be used again later.\n\t \t */\n\t\tif (ifp->if_bpf) {\n\t\t\tm->m_pkthdr.len = m->m_len = total_len;\n\t\t\tbpf_mtap(ifp->if_bpf, m);\n\t\t\tif (ifp->if_flags & IFF_PROMISC &&\n\t\t\t\t(bcmp(eh->ether_dhost, sc->arpcom.ac_enaddr,\n\t\t \t\t\t\tETHER_ADDR_LEN) &&\n\t\t\t\t\t(eh->ether_dhost[0] & 1) == 0)) {\n\t\t\t\tm_freem(m);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n#endif\n\t\t/* Remove header from mbuf and pass it on. */\n\t\tm->m_pkthdr.len = m->m_len =\n\t\t\t\ttotal_len - sizeof(struct ether_header);\n\t\tm->m_data += sizeof(struct ether_header);\n\t\tether_input(ifp, eh, m);\n\t}\n\n\treturn(r);\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int tl_intvec_rxeof",
            "int tl_newbuf"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint tl_intvec_rxeof;\nint tl_newbuf;\n\nint tl_intvec_rxeof(xsc, type)\n\tvoid\t\t\t*xsc;\n\tu_int32_t\t\ttype;\n{\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\tr = 0, total_len = 0;\n\tstruct ether_header\t*eh;\n\tstruct mbuf\t\t*m;\n\tstruct ifnet\t\t*ifp;\n\tstruct tl_chain_onefrag\t*cur_rx;\n\n\tsc = xsc;\n\tifp = &sc->arpcom.ac_if;\n\n\twhile(sc->tl_cdata.tl_rx_head->tl_ptr->tlist_cstat & TL_CSTAT_FRAMECMP){\n\t\tr++;\n\t\tcur_rx = sc->tl_cdata.tl_rx_head;\n\t\tsc->tl_cdata.tl_rx_head = cur_rx->tl_next;\n\t\tm = cur_rx->tl_mbuf;\n\t\ttotal_len = cur_rx->tl_ptr->tlist_frsize;\n\n\t\tif (tl_newbuf(sc, cur_rx) == ENOBUFS) {\n\t\t\tifp->if_ierrors++;\n\t\t\tcur_rx->tl_ptr->tlist_frsize = MCLBYTES;\n\t\t\tcur_rx->tl_ptr->tlist_cstat = TL_CSTAT_READY;\n\t\t\tcur_rx->tl_ptr->tl_frag.tlist_dcnt = MCLBYTES;\n\t\t\tcontinue;\n\t\t}\n\n\t\tsc->tl_cdata.tl_rx_tail->tl_ptr->tlist_fptr =\n\t\t\t\t\t\tvtophys(cur_rx->tl_ptr);\n\t\tsc->tl_cdata.tl_rx_tail->tl_next = cur_rx;\n\t\tsc->tl_cdata.tl_rx_tail = cur_rx;\n\n\t\teh = mtod(m, struct ether_header *);\n\t\tm->m_pkthdr.rcvif = ifp;\n\n\t\t/*\n\t\t * Note: when the ThunderLAN chip is in 'capture all\n\t\t * frames' mode, it will receive its own transmissions.\n\t\t * We drop don't need to process our own transmissions,\n\t\t * so we drop them here and continue.\n\t\t */\n\t\t/*if (ifp->if_flags & IFF_PROMISC && */\n\t\tif (!bcmp(eh->ether_shost, sc->arpcom.ac_enaddr,\n\t\t \t\t\t\t\tETHER_ADDR_LEN)) {\n\t\t\t\tm_freem(m);\n\t\t\t\tcontinue;\n\t\t}\n\n#if NBPFILTER > 0\n\t\t/*\n\t \t * Handle BPF listeners. Let the BPF user see the packet, but\n\t \t * don't pass it up to the ether_input() layer unless it's\n\t \t * a broadcast packet, multicast packet, matches our ethernet\n\t \t * address or the interface is in promiscuous mode. If we don't\n\t \t * want the packet, just forget it. We leave the mbuf in place\n\t \t * since it can be used again later.\n\t \t */\n\t\tif (ifp->if_bpf) {\n\t\t\tm->m_pkthdr.len = m->m_len = total_len;\n\t\t\tbpf_mtap(ifp->if_bpf, m);\n\t\t\tif (ifp->if_flags & IFF_PROMISC &&\n\t\t\t\t(bcmp(eh->ether_dhost, sc->arpcom.ac_enaddr,\n\t\t \t\t\t\tETHER_ADDR_LEN) &&\n\t\t\t\t\t(eh->ether_dhost[0] & 1) == 0)) {\n\t\t\t\tm_freem(m);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n#endif\n\t\t/* Remove header from mbuf and pass it on. */\n\t\tm->m_pkthdr.len = m->m_len =\n\t\t\t\ttotal_len - sizeof(struct ether_header);\n\t\tm->m_data += sizeof(struct ether_header);\n\t\tether_input(ifp, eh, m);\n\t}\n\n\treturn(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tl_stats_update",
          "args": [
            "sc"
          ],
          "line": 1792
        },
        "resolved": true,
        "details": {
          "function_name": "tl_stats_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "1827-1860",
          "snippet": "void tl_stats_update(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct tl_softc\t\t*sc;\n\tstruct ifnet\t\t*ifp;\n\tstruct tl_stats\t\ttl_stats;\n\tu_int32_t\t\t*p;\n\n\tbzero((char *)&tl_stats, sizeof(struct tl_stats));\n\n\tsc = xsc;\n\tifp = &sc->arpcom.ac_if;\n\n\tp = (u_int32_t *)&tl_stats;\n\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, TL_TXGOODFRAMES|TL_DIO_ADDR_INC);\n\t*p++ = CSR_READ_4(sc, TL_DIO_DATA);\n\t*p++ = CSR_READ_4(sc, TL_DIO_DATA);\n\t*p++ = CSR_READ_4(sc, TL_DIO_DATA);\n\t*p++ = CSR_READ_4(sc, TL_DIO_DATA);\n\t*p++ = CSR_READ_4(sc, TL_DIO_DATA);\n\n\tifp->if_opackets += tl_tx_goodframes(tl_stats);\n\tifp->if_collisions += tl_stats.tl_tx_single_collision +\n\t\t\t\ttl_stats.tl_tx_multi_collision;\n\tifp->if_ipackets += tl_rx_goodframes(tl_stats);\n\tifp->if_ierrors += tl_stats.tl_crc_errors + tl_stats.tl_code_errors +\n\t\t\t    tl_rx_overrun(tl_stats);\n\tifp->if_oerrors += tl_tx_underrun(tl_stats);\n\n\ttimeout(tl_stats_update, sc, hz);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void tl_stats_update"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_stats_update;\n\nvoid tl_stats_update(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct tl_softc\t\t*sc;\n\tstruct ifnet\t\t*ifp;\n\tstruct tl_stats\t\ttl_stats;\n\tu_int32_t\t\t*p;\n\n\tbzero((char *)&tl_stats, sizeof(struct tl_stats));\n\n\tsc = xsc;\n\tifp = &sc->arpcom.ac_if;\n\n\tp = (u_int32_t *)&tl_stats;\n\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, TL_TXGOODFRAMES|TL_DIO_ADDR_INC);\n\t*p++ = CSR_READ_4(sc, TL_DIO_DATA);\n\t*p++ = CSR_READ_4(sc, TL_DIO_DATA);\n\t*p++ = CSR_READ_4(sc, TL_DIO_DATA);\n\t*p++ = CSR_READ_4(sc, TL_DIO_DATA);\n\t*p++ = CSR_READ_4(sc, TL_DIO_DATA);\n\n\tifp->if_opackets += tl_tx_goodframes(tl_stats);\n\tifp->if_collisions += tl_stats.tl_tx_single_collision +\n\t\t\t\ttl_stats.tl_tx_multi_collision;\n\tifp->if_ipackets += tl_rx_goodframes(tl_stats);\n\tifp->if_ierrors += tl_stats.tl_crc_errors + tl_stats.tl_code_errors +\n\t\t\t    tl_rx_overrun(tl_stats);\n\tifp->if_oerrors += tl_tx_underrun(tl_stats);\n\n\ttimeout(tl_stats_update, sc, hz);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tl_intvec_txeoc",
          "args": [
            "(void *)sc",
            "type"
          ],
          "line": 1789
        },
        "resolved": true,
        "details": {
          "function_name": "tl_intvec_txeoc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "1653-1697",
          "snippet": "int tl_intvec_txeoc(xsc, type)\n\tvoid\t\t\t*xsc;\n\tu_int32_t\t\ttype;\n{\n\tstruct tl_softc\t\t*sc;\n\tstruct ifnet\t\t*ifp;\n\tu_int32_t\t\tcmd;\n\n\tsc = xsc;\n\tifp = &sc->arpcom.ac_if;\n\n\t/* Clear the timeout timer. */\n\tifp->if_timer = 0;\n\n\tif (sc->tl_cdata.tl_tx_head == NULL) {\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\t\tsc->tl_cdata.tl_tx_tail = NULL;\n\t\tsc->tl_txeoc = 1;\n\t\t/*\n\t\t * If we just drained the TX queue and\n\t\t * there's an autoneg request waiting, set\n\t\t * it in motion. This will block the transmitter\n\t\t * until the autoneg session completes which will\n\t\t * no doubt piss off any processes waiting to\n\t\t * transmit, but that's the way the ball bounces.\n\t\t */\n\t\tif (sc->tl_want_auto)\n\t\t\ttl_autoneg(sc, TL_FLAG_SCHEDDELAY, 1);\n\t} else {\n\t\tsc->tl_txeoc = 0;\n\t\t/* First we have to ack the EOC interrupt. */\n\t\tCMD_PUT(sc, TL_CMD_ACK | 0x00000001 | type);\n\t\t/* Then load the address of the next TX list. */\n\t\tCSR_WRITE_4(sc, TL_CH_PARM,\n\t\t\t\tvtophys(sc->tl_cdata.tl_tx_head->tl_ptr));\n\t\t/* Restart TX channel. */\n\t\tcmd = CSR_READ_4(sc, TL_HOSTCMD);\n\t\tcmd &= ~TL_CMD_RT;\n\t\tcmd |= TL_CMD_GO|TL_CMD_INTSON;\n\t\tCMD_PUT(sc, cmd);\n\t\treturn(0);\n\t}\n\n\treturn(1);\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int tl_intvec_txeoc",
            "void tl_autoneg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint tl_intvec_txeoc;\nvoid tl_autoneg;\n\nint tl_intvec_txeoc(xsc, type)\n\tvoid\t\t\t*xsc;\n\tu_int32_t\t\ttype;\n{\n\tstruct tl_softc\t\t*sc;\n\tstruct ifnet\t\t*ifp;\n\tu_int32_t\t\tcmd;\n\n\tsc = xsc;\n\tifp = &sc->arpcom.ac_if;\n\n\t/* Clear the timeout timer. */\n\tifp->if_timer = 0;\n\n\tif (sc->tl_cdata.tl_tx_head == NULL) {\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\t\tsc->tl_cdata.tl_tx_tail = NULL;\n\t\tsc->tl_txeoc = 1;\n\t\t/*\n\t\t * If we just drained the TX queue and\n\t\t * there's an autoneg request waiting, set\n\t\t * it in motion. This will block the transmitter\n\t\t * until the autoneg session completes which will\n\t\t * no doubt piss off any processes waiting to\n\t\t * transmit, but that's the way the ball bounces.\n\t\t */\n\t\tif (sc->tl_want_auto)\n\t\t\ttl_autoneg(sc, TL_FLAG_SCHEDDELAY, 1);\n\t} else {\n\t\tsc->tl_txeoc = 0;\n\t\t/* First we have to ack the EOC interrupt. */\n\t\tCMD_PUT(sc, TL_CMD_ACK | 0x00000001 | type);\n\t\t/* Then load the address of the next TX list. */\n\t\tCSR_WRITE_4(sc, TL_CH_PARM,\n\t\t\t\tvtophys(sc->tl_cdata.tl_tx_head->tl_ptr));\n\t\t/* Restart TX channel. */\n\t\tcmd = CSR_READ_4(sc, TL_HOSTCMD);\n\t\tcmd &= ~TL_CMD_RT;\n\t\tcmd |= TL_CMD_GO|TL_CMD_INTSON;\n\t\tCMD_PUT(sc, cmd);\n\t\treturn(0);\n\t}\n\n\treturn(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tl_intvec_txeof",
          "args": [
            "(void *)sc",
            "type"
          ],
          "line": 1786
        },
        "resolved": true,
        "details": {
          "function_name": "tl_intvec_txeof",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "1601-1632",
          "snippet": "int tl_intvec_txeof(xsc, type)\n\tvoid\t\t\t*xsc;\n\tu_int32_t\t\ttype;\n{\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\tr = 0;\n\tstruct tl_chain\t\t*cur_tx;\n\n\tsc = xsc;\n\n\t/*\n\t * Go through our tx list and free mbufs for those\n\t * frames that have been sent.\n\t */\n\twhile (sc->tl_cdata.tl_tx_head != NULL) {\n\t\tcur_tx = sc->tl_cdata.tl_tx_head;\n\t\tif (!(cur_tx->tl_ptr->tlist_cstat & TL_CSTAT_FRAMECMP))\n\t\t\tbreak;\n\t\tsc->tl_cdata.tl_tx_head = cur_tx->tl_next;\n\n\t\tr++;\n\t\tm_freem(cur_tx->tl_mbuf);\n\t\tcur_tx->tl_mbuf = NULL;\n\n\t\tcur_tx->tl_next = sc->tl_cdata.tl_tx_free;\n\t\tsc->tl_cdata.tl_tx_free = cur_tx;\n\t\tif (!cur_tx->tl_ptr->tlist_fptr)\n\t\t\tbreak;\n\t}\n\n\treturn(r);\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int tl_intvec_txeof"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint tl_intvec_txeof;\n\nint tl_intvec_txeof(xsc, type)\n\tvoid\t\t\t*xsc;\n\tu_int32_t\t\ttype;\n{\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\tr = 0;\n\tstruct tl_chain\t\t*cur_tx;\n\n\tsc = xsc;\n\n\t/*\n\t * Go through our tx list and free mbufs for those\n\t * frames that have been sent.\n\t */\n\twhile (sc->tl_cdata.tl_tx_head != NULL) {\n\t\tcur_tx = sc->tl_cdata.tl_tx_head;\n\t\tif (!(cur_tx->tl_ptr->tlist_cstat & TL_CSTAT_FRAMECMP))\n\t\t\tbreak;\n\t\tsc->tl_cdata.tl_tx_head = cur_tx->tl_next;\n\n\t\tr++;\n\t\tm_freem(cur_tx->tl_mbuf);\n\t\tcur_tx->tl_mbuf = NULL;\n\n\t\tcur_tx->tl_next = sc->tl_cdata.tl_tx_free;\n\t\tsc->tl_cdata.tl_tx_free = cur_tx;\n\t\tif (!cur_tx->tl_ptr->tlist_fptr)\n\t\t\tbreak;\n\t}\n\n\treturn(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CMD_PUT",
          "args": [
            "sc",
            "type"
          ],
          "line": 1782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "TL_HOST_INT",
            "ints"
          ],
          "line": 1768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_2",
          "args": [
            "sc",
            "TL_HOST_INT"
          ],
          "line": 1767
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint tl_intvec_rxeoc;\nint tl_intvec_txeoc;\nint tl_intvec_txeof;\nint tl_intvec_rxeof;\nint tl_intvec_adchk;\nint tl_intvec_netsts;\nvoid tl_stats_update;\nint tl_intr;\nvoid tl_start;\n\nint tl_intr(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct tl_softc\t\t*sc;\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\tr = 0;\n\tu_int32_t\t\ttype = 0;\n\tu_int16_t\t\tints = 0;\n\tu_int8_t\t\tivec = 0;\n\n\tsc = xsc;\n\n\t/* Disable interrupts */\n\tints = CSR_READ_2(sc, TL_HOST_INT);\n\tCSR_WRITE_2(sc, TL_HOST_INT, ints);\n\ttype = (ints << 16) & 0xFFFF0000;\n\tivec = (ints & TL_VEC_MASK) >> 5;\n\tints = (ints & TL_INT_MASK) >> 2;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tswitch(ints) {\n\tcase (TL_INTR_INVALID):\n#ifdef DIAGNOSTIC\n\t\tif (sc->tl_empty_intr == 0)\n\t\t\tprintf(\"tl%d: got an invalid interrupt!\\n\", sc->tl_unit);\n#endif\n\t\t/* Re-enable interrupts but don't ack this one. */\n\t\tCMD_PUT(sc, type);\n\t\tr = 0;\n\t\tbreak;\n\tcase (TL_INTR_TXEOF):\n\t\tr = tl_intvec_txeof((void *)sc, type);\n\t\tbreak;\n\tcase (TL_INTR_TXEOC):\n\t\tr = tl_intvec_txeoc((void *)sc, type);\n\t\tbreak;\n\tcase (TL_INTR_STATOFLOW):\n\t\ttl_stats_update(sc);\n\t\tr = 1;\n\t\tbreak;\n\tcase (TL_INTR_RXEOF):\n\t\tr = tl_intvec_rxeof((void *)sc, type);\n\t\tbreak;\n\tcase (TL_INTR_DUMMY):\n\t\tprintf(\"tl%d: got a dummy interrupt\\n\", sc->tl_unit);\n\t\tr = 1;\n\t\tbreak;\n\tcase (TL_INTR_ADCHK):\n\t\tif (ivec)\n\t\t\tr = tl_intvec_adchk((void *)sc, type);\n\t\telse\n\t\t\tr = tl_intvec_netsts((void *)sc, type);\n\t\tbreak;\n\tcase (TL_INTR_RXEOC):\n\t\tr = tl_intvec_rxeoc((void *)sc, type);\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"tl%d: bogus interrupt type\\n\", sc->tl_unit);\n\t\tbreak;\n\t}\n\n\t/* Re-enable interrupts */\n\tif (r) {\n\t\tCMD_PUT(sc, TL_CMD_ACK | r | type);\n\t}\n\n\tif (ifp->if_snd.ifq_head != NULL)\n\t\ttl_start(ifp);\n\n\treturn r;\n}"
  },
  {
    "function_name": "tl_intvec_netsts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
    "lines": "1737-1752",
    "snippet": "int tl_intvec_netsts(xsc, type)\n\tvoid\t\t\t*xsc;\n\tu_int32_t\t\ttype;\n{\n\tstruct tl_softc\t\t*sc;\n\tu_int16_t\t\tnetsts;\n\n\tsc = xsc;\n\n\tnetsts = tl_dio_read16(sc, TL_NETSTS);\n\ttl_dio_write16(sc, TL_NETSTS, netsts);\n\n\tprintf(\"tl%d: network status: %x\\n\", sc->tl_unit, netsts);\n\n\treturn(1);\n}",
    "includes": [
      "#include <dev/pci/if_tlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int tl_intvec_netsts",
      "u_int16_t tl_dio_read16",
      "void tl_dio_write16"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"tl%d: network status: %x\\n\"",
            "sc->tl_unit",
            "netsts"
          ],
          "line": 1749
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tl_dio_write16",
          "args": [
            "sc",
            "TL_NETSTS",
            "netsts"
          ],
          "line": 1747
        },
        "resolved": true,
        "details": {
          "function_name": "tl_dio_write16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "324-332",
          "snippet": "void tl_dio_write16(sc, reg, val)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tval;\n{\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tCSR_WRITE_2(sc, TL_DIO_DATA + (reg & 3), val);\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void tl_dio_write16"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_dio_write16;\n\nvoid tl_dio_write16(sc, reg, val)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tval;\n{\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tCSR_WRITE_2(sc, TL_DIO_DATA + (reg & 3), val);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tl_dio_read16",
          "args": [
            "sc",
            "TL_NETSTS"
          ],
          "line": 1746
        },
        "resolved": true,
        "details": {
          "function_name": "tl_dio_read16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "298-304",
          "snippet": "u_int16_t tl_dio_read16(sc, reg)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\treturn(CSR_READ_2(sc, TL_DIO_DATA + (reg & 3)));\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "u_int16_t tl_dio_read16"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int16_t tl_dio_read16;\n\nu_int16_t tl_dio_read16(sc, reg)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\treturn(CSR_READ_2(sc, TL_DIO_DATA + (reg & 3)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint tl_intvec_netsts;\nu_int16_t tl_dio_read16;\nvoid tl_dio_write16;\n\nint tl_intvec_netsts(xsc, type)\n\tvoid\t\t\t*xsc;\n\tu_int32_t\t\ttype;\n{\n\tstruct tl_softc\t\t*sc;\n\tu_int16_t\t\tnetsts;\n\n\tsc = xsc;\n\n\tnetsts = tl_dio_read16(sc, TL_NETSTS);\n\ttl_dio_write16(sc, TL_NETSTS, netsts);\n\n\tprintf(\"tl%d: network status: %x\\n\", sc->tl_unit, netsts);\n\n\treturn(1);\n}"
  },
  {
    "function_name": "tl_intvec_adchk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
    "lines": "1699-1735",
    "snippet": "int tl_intvec_adchk(xsc, type)\n\tvoid\t\t\t*xsc;\n\tu_int32_t\t\ttype;\n{\n\tstruct tl_softc\t\t*sc;\n\tu_int16_t\t\tbmcr, ctl;\n\n\tsc = xsc;\n\n\tif (type)\n\t\tprintf(\"tl%d: adapter check: %x\\n\", sc->tl_unit,\n\t\t\t(unsigned int)CSR_READ_4(sc, TL_CH_PARM));\n\n\t/*\n\t * Before resetting the adapter, try reading the PHY\n\t * settings so we can put them back later. This is\n\t * necessary to keep the chip operating at the same\n\t * speed and duplex settings after the reset completes.\n\t */\n\tif (!sc->tl_bitrate) {\n\t\tbmcr = tl_phy_readreg(sc, PHY_BMCR);\n\t\tctl = tl_phy_readreg(sc, TL_PHY_CTL);\n\t\ttl_softreset(sc, 1);\n\t\ttl_phy_writereg(sc, PHY_BMCR, bmcr);\n\t\ttl_phy_writereg(sc, TL_PHY_CTL, ctl);\n\t\tif (bmcr & PHY_BMCR_DUPLEX) {\n\t\t\ttl_dio_setbit(sc, TL_NETCMD, TL_CMD_DUPLEX);\n\t\t} else {\n\t\t\ttl_dio_clrbit(sc, TL_NETCMD, TL_CMD_DUPLEX);\n\t\t}\n\t}\n\ttl_stop(sc);\n\ttl_init(sc);\n\tCMD_SET(sc, TL_CMD_INTSON);\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/pci/if_tlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int tl_intvec_adchk",
      "void tl_init",
      "void tl_stop",
      "u_int16_t tl_phy_readreg",
      "void tl_phy_writereg",
      "void tl_softreset",
      "void tl_dio_setbit",
      "void tl_dio_clrbit"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CMD_SET",
          "args": [
            "sc",
            "TL_CMD_INTSON"
          ],
          "line": 1732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tl_init",
          "args": [
            "sc"
          ],
          "line": 1731
        },
        "resolved": true,
        "details": {
          "function_name": "tl_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "2052-2156",
          "snippet": "void tl_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct tl_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n        int\t\t\ts;\n\tu_int16_t\t\tphy_sts;\n\n\tif (sc->tl_autoneg)\n\t\treturn;\n\n\ts = splimp();\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/*\n\t * Cancel pending I/O.\n\t */\n\ttl_stop(sc);\n\n\t/*\n\t * Set 'capture all frames' bit for promiscuous mode.\n\t */\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\ttl_dio_setbit(sc, TL_NETCMD, TL_CMD_CAF);\n\telse\n\t\ttl_dio_clrbit(sc, TL_NETCMD, TL_CMD_CAF);\n\n\t/*\n\t * Set capture broadcast bit to capture broadcast frames.\n\t */\n\tif (ifp->if_flags & IFF_BROADCAST)\n\t\ttl_dio_clrbit(sc, TL_NETCMD, TL_CMD_NOBRX);\n\telse\n\t\ttl_dio_setbit(sc, TL_NETCMD, TL_CMD_NOBRX);\n\n\t/* Init our MAC address */\n\ttl_setfilt(sc, (caddr_t)&sc->arpcom.ac_enaddr, 0);\n\n\t/* Init multicast filter, if needed. */\n\ttl_setmulti(sc);\n\n\t/* Init circular RX list. */\n\tif (tl_list_rx_init(sc) == ENOBUFS) {\n\t\tprintf(\"tl%d: initialization failed: no \"\n\t\t\t\"memory for rx buffers\\n\", sc->tl_unit);\n\t\ttl_stop(sc);\n\t\treturn;\n\t}\n\n\t/* Init TX pointers. */\n\ttl_list_tx_init(sc);\n\n\t/*\n\t * Enable PHY interrupts.\n\t */\n\tphy_sts = tl_phy_readreg(sc, TL_PHY_CTL);\n\tphy_sts |= PHY_CTL_INTEN;\n\ttl_phy_writereg(sc, TL_PHY_CTL, phy_sts);\n\n\t/* Enable MII interrupts. */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\n\t/* Enable PCI interrupts. */\n\tCMD_SET(sc, TL_CMD_INTSON);\n\n\t/* Load the address of the rx list */\n\tCMD_SET(sc, TL_CMD_RT);\n\tCSR_WRITE_4(sc, TL_CH_PARM, vtophys(&sc->tl_ldata->tl_rx_list[0]));\n\n\t/*\n\t * XXX This is a kludge to handle adapters with the Micro Linear\n\t * ML6692 100BaseTX PHY, which only supports 100Mbps modes and\n\t * relies on the controller's internal 10Mbps PHY to provide\n\t * 10Mbps modes. The ML6692 always shows up with a vendor/device ID\n\t * of 0 (it doesn't actually have vendor/device ID registers)\n\t * so we use that property to detect it. In theory there ought to\n\t * be a better way to 'spot the looney' but I can't find one.\n         */\n        if (!sc->tl_phy_vid) {\n                u_int8_t                        addr = 0;\n                u_int16_t                       bmcr;\n\n                bmcr = tl_phy_readreg(sc, PHY_BMCR);\n                addr = sc->tl_phy_addr;\n                sc->tl_phy_addr = TL_PHYADDR_MAX;\n                tl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_RESET);\n                if (bmcr & PHY_BMCR_SPEEDSEL)\n                        tl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_ISOLATE);\n                else\n                        tl_phy_writereg(sc, PHY_BMCR, bmcr);\n                sc->tl_phy_addr = addr;\n        }\n\n\t/* Send the RX go command */\n\tCMD_SET(sc, TL_CMD_GO|TL_CMD_RT);\n\n\t(void)splx(s);\n\n\t/* Start the stats update counter */\n\ttimeout(tl_stats_update, sc, hz);\n\ttimeout(tl_wait_up, sc, 2 * hz);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void tl_wait_up",
            "void tl_stats_update",
            "void tl_init",
            "void tl_stop",
            "u_int16_t tl_phy_readreg",
            "void tl_phy_writereg",
            "void tl_autoneg",
            "void tl_setmulti",
            "void tl_setfilt",
            "int tl_list_rx_init",
            "int tl_list_tx_init",
            "void tl_dio_setbit",
            "void tl_dio_clrbit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_wait_up;\nvoid tl_stats_update;\nvoid tl_init;\nvoid tl_stop;\nu_int16_t tl_phy_readreg;\nvoid tl_phy_writereg;\nvoid tl_autoneg;\nvoid tl_setmulti;\nvoid tl_setfilt;\nint tl_list_rx_init;\nint tl_list_tx_init;\nvoid tl_dio_setbit;\nvoid tl_dio_clrbit;\n\nvoid tl_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct tl_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n        int\t\t\ts;\n\tu_int16_t\t\tphy_sts;\n\n\tif (sc->tl_autoneg)\n\t\treturn;\n\n\ts = splimp();\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/*\n\t * Cancel pending I/O.\n\t */\n\ttl_stop(sc);\n\n\t/*\n\t * Set 'capture all frames' bit for promiscuous mode.\n\t */\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\ttl_dio_setbit(sc, TL_NETCMD, TL_CMD_CAF);\n\telse\n\t\ttl_dio_clrbit(sc, TL_NETCMD, TL_CMD_CAF);\n\n\t/*\n\t * Set capture broadcast bit to capture broadcast frames.\n\t */\n\tif (ifp->if_flags & IFF_BROADCAST)\n\t\ttl_dio_clrbit(sc, TL_NETCMD, TL_CMD_NOBRX);\n\telse\n\t\ttl_dio_setbit(sc, TL_NETCMD, TL_CMD_NOBRX);\n\n\t/* Init our MAC address */\n\ttl_setfilt(sc, (caddr_t)&sc->arpcom.ac_enaddr, 0);\n\n\t/* Init multicast filter, if needed. */\n\ttl_setmulti(sc);\n\n\t/* Init circular RX list. */\n\tif (tl_list_rx_init(sc) == ENOBUFS) {\n\t\tprintf(\"tl%d: initialization failed: no \"\n\t\t\t\"memory for rx buffers\\n\", sc->tl_unit);\n\t\ttl_stop(sc);\n\t\treturn;\n\t}\n\n\t/* Init TX pointers. */\n\ttl_list_tx_init(sc);\n\n\t/*\n\t * Enable PHY interrupts.\n\t */\n\tphy_sts = tl_phy_readreg(sc, TL_PHY_CTL);\n\tphy_sts |= PHY_CTL_INTEN;\n\ttl_phy_writereg(sc, TL_PHY_CTL, phy_sts);\n\n\t/* Enable MII interrupts. */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\n\t/* Enable PCI interrupts. */\n\tCMD_SET(sc, TL_CMD_INTSON);\n\n\t/* Load the address of the rx list */\n\tCMD_SET(sc, TL_CMD_RT);\n\tCSR_WRITE_4(sc, TL_CH_PARM, vtophys(&sc->tl_ldata->tl_rx_list[0]));\n\n\t/*\n\t * XXX This is a kludge to handle adapters with the Micro Linear\n\t * ML6692 100BaseTX PHY, which only supports 100Mbps modes and\n\t * relies on the controller's internal 10Mbps PHY to provide\n\t * 10Mbps modes. The ML6692 always shows up with a vendor/device ID\n\t * of 0 (it doesn't actually have vendor/device ID registers)\n\t * so we use that property to detect it. In theory there ought to\n\t * be a better way to 'spot the looney' but I can't find one.\n         */\n        if (!sc->tl_phy_vid) {\n                u_int8_t                        addr = 0;\n                u_int16_t                       bmcr;\n\n                bmcr = tl_phy_readreg(sc, PHY_BMCR);\n                addr = sc->tl_phy_addr;\n                sc->tl_phy_addr = TL_PHYADDR_MAX;\n                tl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_RESET);\n                if (bmcr & PHY_BMCR_SPEEDSEL)\n                        tl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_ISOLATE);\n                else\n                        tl_phy_writereg(sc, PHY_BMCR, bmcr);\n                sc->tl_phy_addr = addr;\n        }\n\n\t/* Send the RX go command */\n\tCMD_SET(sc, TL_CMD_GO|TL_CMD_RT);\n\n\t(void)splx(s);\n\n\t/* Start the stats update counter */\n\ttimeout(tl_stats_update, sc, hz);\n\ttimeout(tl_wait_up, sc, 2 * hz);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tl_stop",
          "args": [
            "sc"
          ],
          "line": 1730
        },
        "resolved": true,
        "details": {
          "function_name": "tl_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "2335-2399",
          "snippet": "void tl_stop(sc)\n\tstruct tl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/* Stop the stats updater. */\n\tuntimeout(tl_stats_update, sc);\n\tuntimeout(tl_wait_up, sc);\n\n\t/* Stop the transmitter */\n\tCMD_CLR(sc, TL_CMD_RT);\n\tCMD_SET(sc, TL_CMD_STOP);\n\tCSR_WRITE_4(sc, TL_CH_PARM, 0);\n\n\t/* Stop the receiver */\n\tCMD_SET(sc, TL_CMD_RT);\n\tCMD_SET(sc, TL_CMD_STOP);\n\tCSR_WRITE_4(sc, TL_CH_PARM, 0);\n\n\t/*\n\t * Disable host interrupts.\n\t */\n\tCMD_SET(sc, TL_CMD_INTSOFF);\n\n\t/*\n\t * Disable MII interrupts.\n\t */\n\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\n\t/*\n\t * Clear list pointer.\n\t */\n\tCSR_WRITE_4(sc, TL_CH_PARM, 0);\n\n\t/*\n\t * Free the RX lists.\n\t */\n\tfor (i = 0; i < TL_RX_LIST_CNT; i++) {\n\t\tif (sc->tl_cdata.tl_rx_chain[i].tl_mbuf != NULL) {\n\t\t\tm_freem(sc->tl_cdata.tl_rx_chain[i].tl_mbuf);\n\t\t\tsc->tl_cdata.tl_rx_chain[i].tl_mbuf = NULL;\n\t\t}\n\t}\n\tbzero((char *)&sc->tl_ldata->tl_rx_list,\n\t\tsizeof(sc->tl_ldata->tl_rx_list));\n\n\t/*\n\t * Free the TX list buffers.\n\t */\n\tfor (i = 0; i < TL_TX_LIST_CNT; i++) {\n\t\tif (sc->tl_cdata.tl_tx_chain[i].tl_mbuf != NULL) {\n\t\t\tm_freem(sc->tl_cdata.tl_tx_chain[i].tl_mbuf);\n\t\t\tsc->tl_cdata.tl_tx_chain[i].tl_mbuf = NULL;\n\t\t}\n\t}\n\tbzero((char *)&sc->tl_ldata->tl_tx_list,\n\t\tsizeof(sc->tl_ldata->tl_tx_list));\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void tl_wait_up",
            "void tl_stats_update",
            "void tl_stop",
            "void tl_dio_clrbit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_wait_up;\nvoid tl_stats_update;\nvoid tl_stop;\nvoid tl_dio_clrbit;\n\nvoid tl_stop(sc)\n\tstruct tl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/* Stop the stats updater. */\n\tuntimeout(tl_stats_update, sc);\n\tuntimeout(tl_wait_up, sc);\n\n\t/* Stop the transmitter */\n\tCMD_CLR(sc, TL_CMD_RT);\n\tCMD_SET(sc, TL_CMD_STOP);\n\tCSR_WRITE_4(sc, TL_CH_PARM, 0);\n\n\t/* Stop the receiver */\n\tCMD_SET(sc, TL_CMD_RT);\n\tCMD_SET(sc, TL_CMD_STOP);\n\tCSR_WRITE_4(sc, TL_CH_PARM, 0);\n\n\t/*\n\t * Disable host interrupts.\n\t */\n\tCMD_SET(sc, TL_CMD_INTSOFF);\n\n\t/*\n\t * Disable MII interrupts.\n\t */\n\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\n\t/*\n\t * Clear list pointer.\n\t */\n\tCSR_WRITE_4(sc, TL_CH_PARM, 0);\n\n\t/*\n\t * Free the RX lists.\n\t */\n\tfor (i = 0; i < TL_RX_LIST_CNT; i++) {\n\t\tif (sc->tl_cdata.tl_rx_chain[i].tl_mbuf != NULL) {\n\t\t\tm_freem(sc->tl_cdata.tl_rx_chain[i].tl_mbuf);\n\t\t\tsc->tl_cdata.tl_rx_chain[i].tl_mbuf = NULL;\n\t\t}\n\t}\n\tbzero((char *)&sc->tl_ldata->tl_rx_list,\n\t\tsizeof(sc->tl_ldata->tl_rx_list));\n\n\t/*\n\t * Free the TX list buffers.\n\t */\n\tfor (i = 0; i < TL_TX_LIST_CNT; i++) {\n\t\tif (sc->tl_cdata.tl_tx_chain[i].tl_mbuf != NULL) {\n\t\t\tm_freem(sc->tl_cdata.tl_tx_chain[i].tl_mbuf);\n\t\t\tsc->tl_cdata.tl_tx_chain[i].tl_mbuf = NULL;\n\t\t}\n\t}\n\tbzero((char *)&sc->tl_ldata->tl_tx_list,\n\t\tsizeof(sc->tl_ldata->tl_tx_list));\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tl_dio_clrbit",
          "args": [
            "sc",
            "TL_NETCMD",
            "TL_CMD_DUPLEX"
          ],
          "line": 1727
        },
        "resolved": true,
        "details": {
          "function_name": "tl_dio_clrbit16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "389-402",
          "snippet": "void tl_dio_clrbit16(sc, reg, bit)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tbit;\n{\n\tu_int16_t\t\t\tf;\n\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tf = CSR_READ_2(sc, TL_DIO_DATA + (reg & 3));\n\tf &= ~bit;\n\tCSR_WRITE_2(sc, TL_DIO_DATA + (reg & 3), f);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void tl_dio_clrbit16"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_dio_clrbit16;\n\nvoid tl_dio_clrbit16(sc, reg, bit)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tbit;\n{\n\tu_int16_t\t\t\tf;\n\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tf = CSR_READ_2(sc, TL_DIO_DATA + (reg & 3));\n\tf &= ~bit;\n\tCSR_WRITE_2(sc, TL_DIO_DATA + (reg & 3), f);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tl_dio_setbit",
          "args": [
            "sc",
            "TL_NETCMD",
            "TL_CMD_DUPLEX"
          ],
          "line": 1725
        },
        "resolved": true,
        "details": {
          "function_name": "tl_dio_setbit16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "374-387",
          "snippet": "void tl_dio_setbit16(sc, reg, bit)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tbit;\n{\n\tu_int16_t\t\t\tf;\n\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tf = CSR_READ_2(sc, TL_DIO_DATA + (reg & 3));\n\tf |= bit;\n\tCSR_WRITE_2(sc, TL_DIO_DATA + (reg & 3), f);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void tl_dio_setbit16"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_dio_setbit16;\n\nvoid tl_dio_setbit16(sc, reg, bit)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tbit;\n{\n\tu_int16_t\t\t\tf;\n\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tf = CSR_READ_2(sc, TL_DIO_DATA + (reg & 3));\n\tf |= bit;\n\tCSR_WRITE_2(sc, TL_DIO_DATA + (reg & 3), f);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tl_phy_writereg",
          "args": [
            "sc",
            "TL_PHY_CTL",
            "ctl"
          ],
          "line": 1723
        },
        "resolved": true,
        "details": {
          "function_name": "tl_phy_writereg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "740-759",
          "snippet": "void tl_phy_writereg(sc, reg, data)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tdata;\n{\n\tstruct tl_mii_frame\tframe;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = sc->tl_phy_addr;\n\tframe.mii_regaddr = reg;\n\tframe.mii_data = data;\n\n\ttl_mii_writereg(sc, &frame);\n\n\t/* Reenable MII interrupts, just in case. */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int tl_mii_writereg",
            "void tl_phy_writereg",
            "void tl_dio_setbit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint tl_mii_writereg;\nvoid tl_phy_writereg;\nvoid tl_dio_setbit;\n\nvoid tl_phy_writereg(sc, reg, data)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tdata;\n{\n\tstruct tl_mii_frame\tframe;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = sc->tl_phy_addr;\n\tframe.mii_regaddr = reg;\n\tframe.mii_data = data;\n\n\ttl_mii_writereg(sc, &frame);\n\n\t/* Reenable MII interrupts, just in case. */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tl_softreset",
          "args": [
            "sc",
            "1"
          ],
          "line": 1721
        },
        "resolved": true,
        "details": {
          "function_name": "tl_softreset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "1208-1276",
          "snippet": "void tl_softreset(sc, internal)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\tinternal;\n{\n        u_int32_t               cmd, dummy, i;\n\n        /* Assert the adapter reset bit. */\n\tCMD_SET(sc, TL_CMD_ADRST);\n        /* Turn off interrupts */\n\tCMD_SET(sc, TL_CMD_INTSOFF);\n\n\t/* First, clear the stats registers. */\n\tfor (i = 0; i < 5; i++)\n\t\tdummy = tl_dio_read32(sc, TL_TXGOODFRAMES);\n\n        /* Clear Areg and Hash registers */\n\tfor (i = 0; i < 8; i++)\n\t\ttl_dio_write32(sc, TL_AREG0_B5, 0x00000000);\n\n        /*\n\t * Set up Netconfig register. Enable one channel and\n\t * one fragment mode.\n\t */\n\ttl_dio_setbit16(sc, TL_NETCONFIG, TL_CFG_ONECHAN|TL_CFG_ONEFRAG);\n\tif (internal && !sc->tl_bitrate) {\n\t\ttl_dio_setbit16(sc, TL_NETCONFIG, TL_CFG_PHYEN);\n\t} else {\n\t\ttl_dio_clrbit16(sc, TL_NETCONFIG, TL_CFG_PHYEN);\n\t}\n\n\t/* Handle cards with bitrate devices. */\n\tif (sc->tl_bitrate)\n\t\ttl_dio_setbit16(sc, TL_NETCONFIG, TL_CFG_BITRATE);\n\n        /* Set PCI burst size */\n\ttl_dio_write8(sc, TL_BSIZEREG, 0x33);\n\n\t/*\n\t * Load adapter irq pacing timer and tx threshold.\n\t * We make the transmit threshold 1 initially but we may\n\t * change that later.\n\t */\n\tcmd = CSR_READ_4(sc, TL_HOSTCMD);\n\tcmd |= TL_CMD_NES;\n\tcmd &= ~(TL_CMD_RT|TL_CMD_EOC|TL_CMD_ACK_MASK|TL_CMD_CHSEL_MASK);\n\tCMD_PUT(sc, cmd | (TL_CMD_LDTHR | TX_THR));\n\tCMD_PUT(sc, cmd | (TL_CMD_LDTMR | 0x00000003));\n\n        /* Unreset the MII */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_NMRST);\n\n\t/* Clear status register */\n        tl_dio_setbit16(sc, TL_NETSTS, TL_STS_MIRQ);\n        tl_dio_setbit16(sc, TL_NETSTS, TL_STS_HBEAT);\n        tl_dio_setbit16(sc, TL_NETSTS, TL_STS_TXSTOP);\n        tl_dio_setbit16(sc, TL_NETSTS, TL_STS_RXSTOP);\n\n\t/* Enable network status interrupts for everything. */\n\ttl_dio_setbit(sc, TL_NETMASK, TL_MASK_MASK7|TL_MASK_MASK6|\n\t\t\tTL_MASK_MASK5|TL_MASK_MASK4);\n\n\t/* Take the adapter out of reset */\n\ttl_dio_setbit(sc, TL_NETCMD, TL_CMD_NRESET|TL_CMD_NWRAP);\n\n\t/* Wait for things to settle down a little. */\n\tDELAY(500);\n\n        return;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void tl_softreset",
            "u_int32_t tl_dio_read32",
            "void tl_dio_write8",
            "void tl_dio_write32",
            "void tl_dio_setbit",
            "void tl_dio_setbit16",
            "void tl_dio_clrbit16"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_softreset;\nu_int32_t tl_dio_read32;\nvoid tl_dio_write8;\nvoid tl_dio_write32;\nvoid tl_dio_setbit;\nvoid tl_dio_setbit16;\nvoid tl_dio_clrbit16;\n\nvoid tl_softreset(sc, internal)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\tinternal;\n{\n        u_int32_t               cmd, dummy, i;\n\n        /* Assert the adapter reset bit. */\n\tCMD_SET(sc, TL_CMD_ADRST);\n        /* Turn off interrupts */\n\tCMD_SET(sc, TL_CMD_INTSOFF);\n\n\t/* First, clear the stats registers. */\n\tfor (i = 0; i < 5; i++)\n\t\tdummy = tl_dio_read32(sc, TL_TXGOODFRAMES);\n\n        /* Clear Areg and Hash registers */\n\tfor (i = 0; i < 8; i++)\n\t\ttl_dio_write32(sc, TL_AREG0_B5, 0x00000000);\n\n        /*\n\t * Set up Netconfig register. Enable one channel and\n\t * one fragment mode.\n\t */\n\ttl_dio_setbit16(sc, TL_NETCONFIG, TL_CFG_ONECHAN|TL_CFG_ONEFRAG);\n\tif (internal && !sc->tl_bitrate) {\n\t\ttl_dio_setbit16(sc, TL_NETCONFIG, TL_CFG_PHYEN);\n\t} else {\n\t\ttl_dio_clrbit16(sc, TL_NETCONFIG, TL_CFG_PHYEN);\n\t}\n\n\t/* Handle cards with bitrate devices. */\n\tif (sc->tl_bitrate)\n\t\ttl_dio_setbit16(sc, TL_NETCONFIG, TL_CFG_BITRATE);\n\n        /* Set PCI burst size */\n\ttl_dio_write8(sc, TL_BSIZEREG, 0x33);\n\n\t/*\n\t * Load adapter irq pacing timer and tx threshold.\n\t * We make the transmit threshold 1 initially but we may\n\t * change that later.\n\t */\n\tcmd = CSR_READ_4(sc, TL_HOSTCMD);\n\tcmd |= TL_CMD_NES;\n\tcmd &= ~(TL_CMD_RT|TL_CMD_EOC|TL_CMD_ACK_MASK|TL_CMD_CHSEL_MASK);\n\tCMD_PUT(sc, cmd | (TL_CMD_LDTHR | TX_THR));\n\tCMD_PUT(sc, cmd | (TL_CMD_LDTMR | 0x00000003));\n\n        /* Unreset the MII */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_NMRST);\n\n\t/* Clear status register */\n        tl_dio_setbit16(sc, TL_NETSTS, TL_STS_MIRQ);\n        tl_dio_setbit16(sc, TL_NETSTS, TL_STS_HBEAT);\n        tl_dio_setbit16(sc, TL_NETSTS, TL_STS_TXSTOP);\n        tl_dio_setbit16(sc, TL_NETSTS, TL_STS_RXSTOP);\n\n\t/* Enable network status interrupts for everything. */\n\ttl_dio_setbit(sc, TL_NETMASK, TL_MASK_MASK7|TL_MASK_MASK6|\n\t\t\tTL_MASK_MASK5|TL_MASK_MASK4);\n\n\t/* Take the adapter out of reset */\n\ttl_dio_setbit(sc, TL_NETCMD, TL_CMD_NRESET|TL_CMD_NWRAP);\n\n\t/* Wait for things to settle down a little. */\n\tDELAY(500);\n\n        return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tl_phy_readreg",
          "args": [
            "sc",
            "TL_PHY_CTL"
          ],
          "line": 1720
        },
        "resolved": true,
        "details": {
          "function_name": "tl_phy_readreg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "722-738",
          "snippet": "u_int16_t tl_phy_readreg(sc, reg)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tstruct tl_mii_frame\tframe;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = sc->tl_phy_addr;\n\tframe.mii_regaddr = reg;\n\ttl_mii_readreg(sc, &frame);\n\n\t/* Reenable MII interrupts, just in case. */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\n\treturn(frame.mii_data);\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int tl_mii_readreg",
            "u_int16_t tl_phy_readreg",
            "void tl_dio_setbit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint tl_mii_readreg;\nu_int16_t tl_phy_readreg;\nvoid tl_dio_setbit;\n\nu_int16_t tl_phy_readreg(sc, reg)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tstruct tl_mii_frame\tframe;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = sc->tl_phy_addr;\n\tframe.mii_regaddr = reg;\n\ttl_mii_readreg(sc, &frame);\n\n\t/* Reenable MII interrupts, just in case. */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\n\treturn(frame.mii_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"tl%d: adapter check: %x\\n\"",
            "sc->tl_unit",
            "(unsigned int)CSR_READ_4(sc, TL_CH_PARM)"
          ],
          "line": 1709
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "TL_CH_PARM"
          ],
          "line": 1710
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint tl_intvec_adchk;\nvoid tl_init;\nvoid tl_stop;\nu_int16_t tl_phy_readreg;\nvoid tl_phy_writereg;\nvoid tl_softreset;\nvoid tl_dio_setbit;\nvoid tl_dio_clrbit;\n\nint tl_intvec_adchk(xsc, type)\n\tvoid\t\t\t*xsc;\n\tu_int32_t\t\ttype;\n{\n\tstruct tl_softc\t\t*sc;\n\tu_int16_t\t\tbmcr, ctl;\n\n\tsc = xsc;\n\n\tif (type)\n\t\tprintf(\"tl%d: adapter check: %x\\n\", sc->tl_unit,\n\t\t\t(unsigned int)CSR_READ_4(sc, TL_CH_PARM));\n\n\t/*\n\t * Before resetting the adapter, try reading the PHY\n\t * settings so we can put them back later. This is\n\t * necessary to keep the chip operating at the same\n\t * speed and duplex settings after the reset completes.\n\t */\n\tif (!sc->tl_bitrate) {\n\t\tbmcr = tl_phy_readreg(sc, PHY_BMCR);\n\t\tctl = tl_phy_readreg(sc, TL_PHY_CTL);\n\t\ttl_softreset(sc, 1);\n\t\ttl_phy_writereg(sc, PHY_BMCR, bmcr);\n\t\ttl_phy_writereg(sc, TL_PHY_CTL, ctl);\n\t\tif (bmcr & PHY_BMCR_DUPLEX) {\n\t\t\ttl_dio_setbit(sc, TL_NETCMD, TL_CMD_DUPLEX);\n\t\t} else {\n\t\t\ttl_dio_clrbit(sc, TL_NETCMD, TL_CMD_DUPLEX);\n\t\t}\n\t}\n\ttl_stop(sc);\n\ttl_init(sc);\n\tCMD_SET(sc, TL_CMD_INTSON);\n\n\treturn(0);\n}"
  },
  {
    "function_name": "tl_intvec_txeoc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
    "lines": "1653-1697",
    "snippet": "int tl_intvec_txeoc(xsc, type)\n\tvoid\t\t\t*xsc;\n\tu_int32_t\t\ttype;\n{\n\tstruct tl_softc\t\t*sc;\n\tstruct ifnet\t\t*ifp;\n\tu_int32_t\t\tcmd;\n\n\tsc = xsc;\n\tifp = &sc->arpcom.ac_if;\n\n\t/* Clear the timeout timer. */\n\tifp->if_timer = 0;\n\n\tif (sc->tl_cdata.tl_tx_head == NULL) {\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\t\tsc->tl_cdata.tl_tx_tail = NULL;\n\t\tsc->tl_txeoc = 1;\n\t\t/*\n\t\t * If we just drained the TX queue and\n\t\t * there's an autoneg request waiting, set\n\t\t * it in motion. This will block the transmitter\n\t\t * until the autoneg session completes which will\n\t\t * no doubt piss off any processes waiting to\n\t\t * transmit, but that's the way the ball bounces.\n\t\t */\n\t\tif (sc->tl_want_auto)\n\t\t\ttl_autoneg(sc, TL_FLAG_SCHEDDELAY, 1);\n\t} else {\n\t\tsc->tl_txeoc = 0;\n\t\t/* First we have to ack the EOC interrupt. */\n\t\tCMD_PUT(sc, TL_CMD_ACK | 0x00000001 | type);\n\t\t/* Then load the address of the next TX list. */\n\t\tCSR_WRITE_4(sc, TL_CH_PARM,\n\t\t\t\tvtophys(sc->tl_cdata.tl_tx_head->tl_ptr));\n\t\t/* Restart TX channel. */\n\t\tcmd = CSR_READ_4(sc, TL_HOSTCMD);\n\t\tcmd &= ~TL_CMD_RT;\n\t\tcmd |= TL_CMD_GO|TL_CMD_INTSON;\n\t\tCMD_PUT(sc, cmd);\n\t\treturn(0);\n\t}\n\n\treturn(1);\n}",
    "includes": [
      "#include <dev/pci/if_tlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int tl_intvec_txeoc",
      "void tl_autoneg"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CMD_PUT",
          "args": [
            "sc",
            "cmd"
          ],
          "line": 1692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "TL_HOSTCMD"
          ],
          "line": 1689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TL_CH_PARM",
            "vtophys(sc->tl_cdata.tl_tx_head->tl_ptr)"
          ],
          "line": 1686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "sc->tl_cdata.tl_tx_head->tl_ptr"
          ],
          "line": 1687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CMD_PUT",
          "args": [
            "sc",
            "TL_CMD_ACK | 0x00000001 | type"
          ],
          "line": 1684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tl_autoneg",
          "args": [
            "sc",
            "TL_FLAG_SCHEDDELAY",
            "1"
          ],
          "line": 1680
        },
        "resolved": true,
        "details": {
          "function_name": "tl_autoneg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "808-963",
          "snippet": "void tl_autoneg(sc, flag, verbose)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\tflag;\n\tint\t\t\tverbose;\n{\n\tu_int16_t\t\tphy_sts = 0, media = 0, advert, ability;\n\tstruct ifnet\t\t*ifp;\n\tstruct ifmedia\t\t*ifm;\n\n\tifm = &sc->ifmedia;\n\tifp = &sc->arpcom.ac_if;\n\n\t/*\n\t * First, see if autoneg is supported. If not, there's\n\t * no point in continuing.\n\t */\n\tphy_sts = tl_phy_readreg(sc, PHY_BMSR);\n\tif (!(phy_sts & PHY_BMSR_CANAUTONEG)) {\n\t\tif (verbose)\n\t\t\tprintf(\"tl%d: autonegotiation not supported\\n\",\n\t\t\t\t\t\t\tsc->tl_unit);\n\t\treturn;\n\t}\n\n\tswitch (flag) {\n\tcase TL_FLAG_FORCEDELAY:\n\t\t/*\n\t \t * XXX Never use this option anywhere but in the probe\n\t \t * routine: making the kernel stop dead in its tracks\n \t\t * for three whole seconds after we've gone multi-user\n\t\t * is really bad manners.\n\t \t */\n\t\ttl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_RESET);\n\t\tDELAY(500);\n\t\tphy_sts = tl_phy_readreg(sc, PHY_BMCR);\n\t\tphy_sts |= PHY_BMCR_AUTONEGENBL|PHY_BMCR_AUTONEGRSTR;\n\t\ttl_phy_writereg(sc, PHY_BMCR, phy_sts);\n\t\tDELAY(5000000);\n\t\tbreak;\n\tcase TL_FLAG_SCHEDDELAY:\n\t\t/*\n\t\t * Wait for the transmitter to go idle before starting\n\t\t * an autoneg session, otherwise tl_start() may clobber\n\t \t * our timeout, and we don't want to allow transmission\n\t\t * during an autoneg session since that can screw it up.\n\t \t */\n\t\tif (!sc->tl_txeoc) {\n\t\t\tsc->tl_want_auto = 1;\n\t\t\treturn;\n\t\t}\n\t\ttl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_RESET);\n\t\tDELAY(500);\n\t\tphy_sts = tl_phy_readreg(sc, PHY_BMCR);\n\t\tphy_sts |= PHY_BMCR_AUTONEGENBL|PHY_BMCR_AUTONEGRSTR;\n\t\ttl_phy_writereg(sc, PHY_BMCR, phy_sts);\n\t\tifp->if_timer = 10;\n\t\tsc->tl_autoneg = 1;\n\t\tsc->tl_want_auto = 0;\n\t\treturn;\n\tcase TL_FLAG_DELAYTIMEO:\n\t\tifp->if_timer = 0;\n\t\tsc->tl_autoneg = 0;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"tl%d: invalid autoneg flag: %d\\n\", sc->tl_unit, flag);\n\t\treturn;\n\t}\n\n\t/*\n \t * Read the BMSR register twice: the LINKSTAT bit is a\n\t * latching bit.\n\t */\n\ttl_phy_readreg(sc, PHY_BMSR);\n\tphy_sts = tl_phy_readreg(sc, PHY_BMSR);\n\tif (phy_sts & PHY_BMSR_AUTONEGCOMP) {\n\t\tif (verbose)\n\t\t\tprintf(\"tl%d: autoneg complete, \", sc->tl_unit);\n\t\tphy_sts = tl_phy_readreg(sc, PHY_BMSR);\n\t} else {\n\t\tif (verbose)\n\t\t\tprintf(\"tl%d: autoneg not complete, \", sc->tl_unit);\n\t}\n\n\t/* Link is good. Report modes and set duplex mode. */\n\tif (phy_sts & PHY_BMSR_LINKSTAT) {\n\t\tif (verbose)\n\t\t\tprintf(\"link status good \");\n\n\t\tadvert = tl_phy_readreg(sc, TL_PHY_ANAR);\n\t\tability = tl_phy_readreg(sc, TL_PHY_LPAR);\n\t\tmedia = tl_phy_readreg(sc, PHY_BMCR);\n\n\t\t/*\n\t \t * Be sure to turn off the ISOLATE and\n\t\t * LOOPBACK bits in the control register,\n\t\t * otherwise we may not be able to communicate.\n\t\t */\n\t\tmedia &= ~(PHY_BMCR_LOOPBK|PHY_BMCR_ISOLATE);\n\t\t/* Set the DUPLEX bit in the NetCmd register accordingly. */\n\t\tif (advert & PHY_ANAR_100BT4 && ability & PHY_ANAR_100BT4) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_100_T4;\n\t\t\tmedia |= PHY_BMCR_SPEEDSEL;\n\t\t\tmedia &= ~PHY_BMCR_DUPLEX;\n\t\t\tif (verbose)\n\t\t\t\tprintf(\"(100baseT4)\\n\");\n\t\t} else if (advert & PHY_ANAR_100BTXFULL &&\n\t\t\tability & PHY_ANAR_100BTXFULL) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_100_TX|IFM_FDX;\n\t\t\tmedia |= PHY_BMCR_SPEEDSEL;\n\t\t\tmedia |= PHY_BMCR_DUPLEX;\n\t\t\tif (verbose)\n\t\t\t\tprintf(\"(full-duplex, 100Mbps)\\n\");\n\t\t} else if (advert & PHY_ANAR_100BTXHALF &&\n\t\t\tability & PHY_ANAR_100BTXHALF) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_100_TX|IFM_HDX;\n\t\t\tmedia |= PHY_BMCR_SPEEDSEL;\n\t\t\tmedia &= ~PHY_BMCR_DUPLEX;\n\t\t\tif (verbose)\n\t\t\t\tprintf(\"(half-duplex, 100Mbps)\\n\");\n\t\t} else if (advert & PHY_ANAR_10BTFULL &&\n\t\t\tability & PHY_ANAR_10BTFULL) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_10_T|IFM_FDX;\n\t\t\tmedia &= ~PHY_BMCR_SPEEDSEL;\n\t\t\tmedia |= PHY_BMCR_DUPLEX;\n\t\t\tif (verbose)\n\t\t\t\tprintf(\"(full-duplex, 10Mbps)\\n\");\n\t\t} else {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_10_T|IFM_HDX;\n\t\t\tmedia &= ~PHY_BMCR_SPEEDSEL;\n\t\t\tmedia &= ~PHY_BMCR_DUPLEX;\n\t\t\tif (verbose)\n\t\t\t\tprintf(\"(half-duplex, 10Mbps)\\n\");\n\t\t}\n\n\t\tif (media & PHY_BMCR_DUPLEX)\n\t\t\ttl_dio_setbit(sc, TL_NETCMD, TL_CMD_DUPLEX);\n\t\telse\n\t\t\ttl_dio_clrbit(sc, TL_NETCMD, TL_CMD_DUPLEX);\n\n\t\tmedia &= ~PHY_BMCR_AUTONEGENBL;\n\t\ttl_phy_writereg(sc, PHY_BMCR, media);\n\t} else {\n\t\tif (verbose)\n\t\t\tprintf(\"no carrier\\n\");\n\t}\n\n\ttl_init(sc);\n\n\tif (sc->tl_tx_pend) {\n\t\tsc->tl_autoneg = 0;\n\t\tsc->tl_tx_pend = 0;\n\t\ttl_start(ifp);\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void tl_start",
            "void tl_init",
            "u_int16_t tl_phy_readreg",
            "void tl_phy_writereg",
            "void tl_autoneg",
            "void tl_dio_setbit",
            "void tl_dio_clrbit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_start;\nvoid tl_init;\nu_int16_t tl_phy_readreg;\nvoid tl_phy_writereg;\nvoid tl_autoneg;\nvoid tl_dio_setbit;\nvoid tl_dio_clrbit;\n\nvoid tl_autoneg(sc, flag, verbose)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\tflag;\n\tint\t\t\tverbose;\n{\n\tu_int16_t\t\tphy_sts = 0, media = 0, advert, ability;\n\tstruct ifnet\t\t*ifp;\n\tstruct ifmedia\t\t*ifm;\n\n\tifm = &sc->ifmedia;\n\tifp = &sc->arpcom.ac_if;\n\n\t/*\n\t * First, see if autoneg is supported. If not, there's\n\t * no point in continuing.\n\t */\n\tphy_sts = tl_phy_readreg(sc, PHY_BMSR);\n\tif (!(phy_sts & PHY_BMSR_CANAUTONEG)) {\n\t\tif (verbose)\n\t\t\tprintf(\"tl%d: autonegotiation not supported\\n\",\n\t\t\t\t\t\t\tsc->tl_unit);\n\t\treturn;\n\t}\n\n\tswitch (flag) {\n\tcase TL_FLAG_FORCEDELAY:\n\t\t/*\n\t \t * XXX Never use this option anywhere but in the probe\n\t \t * routine: making the kernel stop dead in its tracks\n \t\t * for three whole seconds after we've gone multi-user\n\t\t * is really bad manners.\n\t \t */\n\t\ttl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_RESET);\n\t\tDELAY(500);\n\t\tphy_sts = tl_phy_readreg(sc, PHY_BMCR);\n\t\tphy_sts |= PHY_BMCR_AUTONEGENBL|PHY_BMCR_AUTONEGRSTR;\n\t\ttl_phy_writereg(sc, PHY_BMCR, phy_sts);\n\t\tDELAY(5000000);\n\t\tbreak;\n\tcase TL_FLAG_SCHEDDELAY:\n\t\t/*\n\t\t * Wait for the transmitter to go idle before starting\n\t\t * an autoneg session, otherwise tl_start() may clobber\n\t \t * our timeout, and we don't want to allow transmission\n\t\t * during an autoneg session since that can screw it up.\n\t \t */\n\t\tif (!sc->tl_txeoc) {\n\t\t\tsc->tl_want_auto = 1;\n\t\t\treturn;\n\t\t}\n\t\ttl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_RESET);\n\t\tDELAY(500);\n\t\tphy_sts = tl_phy_readreg(sc, PHY_BMCR);\n\t\tphy_sts |= PHY_BMCR_AUTONEGENBL|PHY_BMCR_AUTONEGRSTR;\n\t\ttl_phy_writereg(sc, PHY_BMCR, phy_sts);\n\t\tifp->if_timer = 10;\n\t\tsc->tl_autoneg = 1;\n\t\tsc->tl_want_auto = 0;\n\t\treturn;\n\tcase TL_FLAG_DELAYTIMEO:\n\t\tifp->if_timer = 0;\n\t\tsc->tl_autoneg = 0;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"tl%d: invalid autoneg flag: %d\\n\", sc->tl_unit, flag);\n\t\treturn;\n\t}\n\n\t/*\n \t * Read the BMSR register twice: the LINKSTAT bit is a\n\t * latching bit.\n\t */\n\ttl_phy_readreg(sc, PHY_BMSR);\n\tphy_sts = tl_phy_readreg(sc, PHY_BMSR);\n\tif (phy_sts & PHY_BMSR_AUTONEGCOMP) {\n\t\tif (verbose)\n\t\t\tprintf(\"tl%d: autoneg complete, \", sc->tl_unit);\n\t\tphy_sts = tl_phy_readreg(sc, PHY_BMSR);\n\t} else {\n\t\tif (verbose)\n\t\t\tprintf(\"tl%d: autoneg not complete, \", sc->tl_unit);\n\t}\n\n\t/* Link is good. Report modes and set duplex mode. */\n\tif (phy_sts & PHY_BMSR_LINKSTAT) {\n\t\tif (verbose)\n\t\t\tprintf(\"link status good \");\n\n\t\tadvert = tl_phy_readreg(sc, TL_PHY_ANAR);\n\t\tability = tl_phy_readreg(sc, TL_PHY_LPAR);\n\t\tmedia = tl_phy_readreg(sc, PHY_BMCR);\n\n\t\t/*\n\t \t * Be sure to turn off the ISOLATE and\n\t\t * LOOPBACK bits in the control register,\n\t\t * otherwise we may not be able to communicate.\n\t\t */\n\t\tmedia &= ~(PHY_BMCR_LOOPBK|PHY_BMCR_ISOLATE);\n\t\t/* Set the DUPLEX bit in the NetCmd register accordingly. */\n\t\tif (advert & PHY_ANAR_100BT4 && ability & PHY_ANAR_100BT4) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_100_T4;\n\t\t\tmedia |= PHY_BMCR_SPEEDSEL;\n\t\t\tmedia &= ~PHY_BMCR_DUPLEX;\n\t\t\tif (verbose)\n\t\t\t\tprintf(\"(100baseT4)\\n\");\n\t\t} else if (advert & PHY_ANAR_100BTXFULL &&\n\t\t\tability & PHY_ANAR_100BTXFULL) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_100_TX|IFM_FDX;\n\t\t\tmedia |= PHY_BMCR_SPEEDSEL;\n\t\t\tmedia |= PHY_BMCR_DUPLEX;\n\t\t\tif (verbose)\n\t\t\t\tprintf(\"(full-duplex, 100Mbps)\\n\");\n\t\t} else if (advert & PHY_ANAR_100BTXHALF &&\n\t\t\tability & PHY_ANAR_100BTXHALF) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_100_TX|IFM_HDX;\n\t\t\tmedia |= PHY_BMCR_SPEEDSEL;\n\t\t\tmedia &= ~PHY_BMCR_DUPLEX;\n\t\t\tif (verbose)\n\t\t\t\tprintf(\"(half-duplex, 100Mbps)\\n\");\n\t\t} else if (advert & PHY_ANAR_10BTFULL &&\n\t\t\tability & PHY_ANAR_10BTFULL) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_10_T|IFM_FDX;\n\t\t\tmedia &= ~PHY_BMCR_SPEEDSEL;\n\t\t\tmedia |= PHY_BMCR_DUPLEX;\n\t\t\tif (verbose)\n\t\t\t\tprintf(\"(full-duplex, 10Mbps)\\n\");\n\t\t} else {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_10_T|IFM_HDX;\n\t\t\tmedia &= ~PHY_BMCR_SPEEDSEL;\n\t\t\tmedia &= ~PHY_BMCR_DUPLEX;\n\t\t\tif (verbose)\n\t\t\t\tprintf(\"(half-duplex, 10Mbps)\\n\");\n\t\t}\n\n\t\tif (media & PHY_BMCR_DUPLEX)\n\t\t\ttl_dio_setbit(sc, TL_NETCMD, TL_CMD_DUPLEX);\n\t\telse\n\t\t\ttl_dio_clrbit(sc, TL_NETCMD, TL_CMD_DUPLEX);\n\n\t\tmedia &= ~PHY_BMCR_AUTONEGENBL;\n\t\ttl_phy_writereg(sc, PHY_BMCR, media);\n\t} else {\n\t\tif (verbose)\n\t\t\tprintf(\"no carrier\\n\");\n\t}\n\n\ttl_init(sc);\n\n\tif (sc->tl_tx_pend) {\n\t\tsc->tl_autoneg = 0;\n\t\tsc->tl_tx_pend = 0;\n\t\ttl_start(ifp);\n\t}\n\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint tl_intvec_txeoc;\nvoid tl_autoneg;\n\nint tl_intvec_txeoc(xsc, type)\n\tvoid\t\t\t*xsc;\n\tu_int32_t\t\ttype;\n{\n\tstruct tl_softc\t\t*sc;\n\tstruct ifnet\t\t*ifp;\n\tu_int32_t\t\tcmd;\n\n\tsc = xsc;\n\tifp = &sc->arpcom.ac_if;\n\n\t/* Clear the timeout timer. */\n\tifp->if_timer = 0;\n\n\tif (sc->tl_cdata.tl_tx_head == NULL) {\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\t\tsc->tl_cdata.tl_tx_tail = NULL;\n\t\tsc->tl_txeoc = 1;\n\t\t/*\n\t\t * If we just drained the TX queue and\n\t\t * there's an autoneg request waiting, set\n\t\t * it in motion. This will block the transmitter\n\t\t * until the autoneg session completes which will\n\t\t * no doubt piss off any processes waiting to\n\t\t * transmit, but that's the way the ball bounces.\n\t\t */\n\t\tif (sc->tl_want_auto)\n\t\t\ttl_autoneg(sc, TL_FLAG_SCHEDDELAY, 1);\n\t} else {\n\t\tsc->tl_txeoc = 0;\n\t\t/* First we have to ack the EOC interrupt. */\n\t\tCMD_PUT(sc, TL_CMD_ACK | 0x00000001 | type);\n\t\t/* Then load the address of the next TX list. */\n\t\tCSR_WRITE_4(sc, TL_CH_PARM,\n\t\t\t\tvtophys(sc->tl_cdata.tl_tx_head->tl_ptr));\n\t\t/* Restart TX channel. */\n\t\tcmd = CSR_READ_4(sc, TL_HOSTCMD);\n\t\tcmd &= ~TL_CMD_RT;\n\t\tcmd |= TL_CMD_GO|TL_CMD_INTSON;\n\t\tCMD_PUT(sc, cmd);\n\t\treturn(0);\n\t}\n\n\treturn(1);\n}"
  },
  {
    "function_name": "tl_intvec_txeof",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
    "lines": "1601-1632",
    "snippet": "int tl_intvec_txeof(xsc, type)\n\tvoid\t\t\t*xsc;\n\tu_int32_t\t\ttype;\n{\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\tr = 0;\n\tstruct tl_chain\t\t*cur_tx;\n\n\tsc = xsc;\n\n\t/*\n\t * Go through our tx list and free mbufs for those\n\t * frames that have been sent.\n\t */\n\twhile (sc->tl_cdata.tl_tx_head != NULL) {\n\t\tcur_tx = sc->tl_cdata.tl_tx_head;\n\t\tif (!(cur_tx->tl_ptr->tlist_cstat & TL_CSTAT_FRAMECMP))\n\t\t\tbreak;\n\t\tsc->tl_cdata.tl_tx_head = cur_tx->tl_next;\n\n\t\tr++;\n\t\tm_freem(cur_tx->tl_mbuf);\n\t\tcur_tx->tl_mbuf = NULL;\n\n\t\tcur_tx->tl_next = sc->tl_cdata.tl_tx_free;\n\t\tsc->tl_cdata.tl_tx_free = cur_tx;\n\t\tif (!cur_tx->tl_ptr->tlist_fptr)\n\t\t\tbreak;\n\t}\n\n\treturn(r);\n}",
    "includes": [
      "#include <dev/pci/if_tlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int tl_intvec_txeof"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "cur_tx->tl_mbuf"
          ],
          "line": 1622
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint tl_intvec_txeof;\n\nint tl_intvec_txeof(xsc, type)\n\tvoid\t\t\t*xsc;\n\tu_int32_t\t\ttype;\n{\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\tr = 0;\n\tstruct tl_chain\t\t*cur_tx;\n\n\tsc = xsc;\n\n\t/*\n\t * Go through our tx list and free mbufs for those\n\t * frames that have been sent.\n\t */\n\twhile (sc->tl_cdata.tl_tx_head != NULL) {\n\t\tcur_tx = sc->tl_cdata.tl_tx_head;\n\t\tif (!(cur_tx->tl_ptr->tlist_cstat & TL_CSTAT_FRAMECMP))\n\t\t\tbreak;\n\t\tsc->tl_cdata.tl_tx_head = cur_tx->tl_next;\n\n\t\tr++;\n\t\tm_freem(cur_tx->tl_mbuf);\n\t\tcur_tx->tl_mbuf = NULL;\n\n\t\tcur_tx->tl_next = sc->tl_cdata.tl_tx_free;\n\t\tsc->tl_cdata.tl_tx_free = cur_tx;\n\t\tif (!cur_tx->tl_ptr->tlist_fptr)\n\t\t\tbreak;\n\t}\n\n\treturn(r);\n}"
  },
  {
    "function_name": "tl_intvec_rxeoc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
    "lines": "1583-1599",
    "snippet": "int tl_intvec_rxeoc(xsc, type)\n\tvoid\t\t\t*xsc;\n\tu_int32_t\t\ttype;\n{\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\tr;\n\n\tsc = xsc;\n\n\t/* Flush out the receive queue and ack RXEOF interrupts. */\n\tr = tl_intvec_rxeof(xsc, type);\n\tCMD_PUT(sc, TL_CMD_ACK | r | (type & ~(0x00100000)));\n\tr = 1;\n\tCSR_WRITE_4(sc, TL_CH_PARM, vtophys(sc->tl_cdata.tl_rx_head->tl_ptr));\n\tr |= (TL_CMD_GO|TL_CMD_RT);\n\treturn(r);\n}",
    "includes": [
      "#include <dev/pci/if_tlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int tl_intvec_rxeoc",
      "int tl_intvec_rxeof"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TL_CH_PARM",
            "vtophys(sc->tl_cdata.tl_rx_head->tl_ptr)"
          ],
          "line": 1596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "sc->tl_cdata.tl_rx_head->tl_ptr"
          ],
          "line": 1596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CMD_PUT",
          "args": [
            "sc",
            "TL_CMD_ACK | r | (type & ~(0x00100000))"
          ],
          "line": 1594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tl_intvec_rxeof",
          "args": [
            "xsc",
            "type"
          ],
          "line": 1593
        },
        "resolved": true,
        "details": {
          "function_name": "tl_intvec_rxeof",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "1495-1574",
          "snippet": "int tl_intvec_rxeof(xsc, type)\n\tvoid\t\t\t*xsc;\n\tu_int32_t\t\ttype;\n{\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\tr = 0, total_len = 0;\n\tstruct ether_header\t*eh;\n\tstruct mbuf\t\t*m;\n\tstruct ifnet\t\t*ifp;\n\tstruct tl_chain_onefrag\t*cur_rx;\n\n\tsc = xsc;\n\tifp = &sc->arpcom.ac_if;\n\n\twhile(sc->tl_cdata.tl_rx_head->tl_ptr->tlist_cstat & TL_CSTAT_FRAMECMP){\n\t\tr++;\n\t\tcur_rx = sc->tl_cdata.tl_rx_head;\n\t\tsc->tl_cdata.tl_rx_head = cur_rx->tl_next;\n\t\tm = cur_rx->tl_mbuf;\n\t\ttotal_len = cur_rx->tl_ptr->tlist_frsize;\n\n\t\tif (tl_newbuf(sc, cur_rx) == ENOBUFS) {\n\t\t\tifp->if_ierrors++;\n\t\t\tcur_rx->tl_ptr->tlist_frsize = MCLBYTES;\n\t\t\tcur_rx->tl_ptr->tlist_cstat = TL_CSTAT_READY;\n\t\t\tcur_rx->tl_ptr->tl_frag.tlist_dcnt = MCLBYTES;\n\t\t\tcontinue;\n\t\t}\n\n\t\tsc->tl_cdata.tl_rx_tail->tl_ptr->tlist_fptr =\n\t\t\t\t\t\tvtophys(cur_rx->tl_ptr);\n\t\tsc->tl_cdata.tl_rx_tail->tl_next = cur_rx;\n\t\tsc->tl_cdata.tl_rx_tail = cur_rx;\n\n\t\teh = mtod(m, struct ether_header *);\n\t\tm->m_pkthdr.rcvif = ifp;\n\n\t\t/*\n\t\t * Note: when the ThunderLAN chip is in 'capture all\n\t\t * frames' mode, it will receive its own transmissions.\n\t\t * We drop don't need to process our own transmissions,\n\t\t * so we drop them here and continue.\n\t\t */\n\t\t/*if (ifp->if_flags & IFF_PROMISC && */\n\t\tif (!bcmp(eh->ether_shost, sc->arpcom.ac_enaddr,\n\t\t \t\t\t\t\tETHER_ADDR_LEN)) {\n\t\t\t\tm_freem(m);\n\t\t\t\tcontinue;\n\t\t}\n\n#if NBPFILTER > 0\n\t\t/*\n\t \t * Handle BPF listeners. Let the BPF user see the packet, but\n\t \t * don't pass it up to the ether_input() layer unless it's\n\t \t * a broadcast packet, multicast packet, matches our ethernet\n\t \t * address or the interface is in promiscuous mode. If we don't\n\t \t * want the packet, just forget it. We leave the mbuf in place\n\t \t * since it can be used again later.\n\t \t */\n\t\tif (ifp->if_bpf) {\n\t\t\tm->m_pkthdr.len = m->m_len = total_len;\n\t\t\tbpf_mtap(ifp->if_bpf, m);\n\t\t\tif (ifp->if_flags & IFF_PROMISC &&\n\t\t\t\t(bcmp(eh->ether_dhost, sc->arpcom.ac_enaddr,\n\t\t \t\t\t\tETHER_ADDR_LEN) &&\n\t\t\t\t\t(eh->ether_dhost[0] & 1) == 0)) {\n\t\t\t\tm_freem(m);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n#endif\n\t\t/* Remove header from mbuf and pass it on. */\n\t\tm->m_pkthdr.len = m->m_len =\n\t\t\t\ttotal_len - sizeof(struct ether_header);\n\t\tm->m_data += sizeof(struct ether_header);\n\t\tether_input(ifp, eh, m);\n\t}\n\n\treturn(r);\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int tl_intvec_rxeof",
            "int tl_newbuf"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint tl_intvec_rxeof;\nint tl_newbuf;\n\nint tl_intvec_rxeof(xsc, type)\n\tvoid\t\t\t*xsc;\n\tu_int32_t\t\ttype;\n{\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\tr = 0, total_len = 0;\n\tstruct ether_header\t*eh;\n\tstruct mbuf\t\t*m;\n\tstruct ifnet\t\t*ifp;\n\tstruct tl_chain_onefrag\t*cur_rx;\n\n\tsc = xsc;\n\tifp = &sc->arpcom.ac_if;\n\n\twhile(sc->tl_cdata.tl_rx_head->tl_ptr->tlist_cstat & TL_CSTAT_FRAMECMP){\n\t\tr++;\n\t\tcur_rx = sc->tl_cdata.tl_rx_head;\n\t\tsc->tl_cdata.tl_rx_head = cur_rx->tl_next;\n\t\tm = cur_rx->tl_mbuf;\n\t\ttotal_len = cur_rx->tl_ptr->tlist_frsize;\n\n\t\tif (tl_newbuf(sc, cur_rx) == ENOBUFS) {\n\t\t\tifp->if_ierrors++;\n\t\t\tcur_rx->tl_ptr->tlist_frsize = MCLBYTES;\n\t\t\tcur_rx->tl_ptr->tlist_cstat = TL_CSTAT_READY;\n\t\t\tcur_rx->tl_ptr->tl_frag.tlist_dcnt = MCLBYTES;\n\t\t\tcontinue;\n\t\t}\n\n\t\tsc->tl_cdata.tl_rx_tail->tl_ptr->tlist_fptr =\n\t\t\t\t\t\tvtophys(cur_rx->tl_ptr);\n\t\tsc->tl_cdata.tl_rx_tail->tl_next = cur_rx;\n\t\tsc->tl_cdata.tl_rx_tail = cur_rx;\n\n\t\teh = mtod(m, struct ether_header *);\n\t\tm->m_pkthdr.rcvif = ifp;\n\n\t\t/*\n\t\t * Note: when the ThunderLAN chip is in 'capture all\n\t\t * frames' mode, it will receive its own transmissions.\n\t\t * We drop don't need to process our own transmissions,\n\t\t * so we drop them here and continue.\n\t\t */\n\t\t/*if (ifp->if_flags & IFF_PROMISC && */\n\t\tif (!bcmp(eh->ether_shost, sc->arpcom.ac_enaddr,\n\t\t \t\t\t\t\tETHER_ADDR_LEN)) {\n\t\t\t\tm_freem(m);\n\t\t\t\tcontinue;\n\t\t}\n\n#if NBPFILTER > 0\n\t\t/*\n\t \t * Handle BPF listeners. Let the BPF user see the packet, but\n\t \t * don't pass it up to the ether_input() layer unless it's\n\t \t * a broadcast packet, multicast packet, matches our ethernet\n\t \t * address or the interface is in promiscuous mode. If we don't\n\t \t * want the packet, just forget it. We leave the mbuf in place\n\t \t * since it can be used again later.\n\t \t */\n\t\tif (ifp->if_bpf) {\n\t\t\tm->m_pkthdr.len = m->m_len = total_len;\n\t\t\tbpf_mtap(ifp->if_bpf, m);\n\t\t\tif (ifp->if_flags & IFF_PROMISC &&\n\t\t\t\t(bcmp(eh->ether_dhost, sc->arpcom.ac_enaddr,\n\t\t \t\t\t\tETHER_ADDR_LEN) &&\n\t\t\t\t\t(eh->ether_dhost[0] & 1) == 0)) {\n\t\t\t\tm_freem(m);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n#endif\n\t\t/* Remove header from mbuf and pass it on. */\n\t\tm->m_pkthdr.len = m->m_len =\n\t\t\t\ttotal_len - sizeof(struct ether_header);\n\t\tm->m_data += sizeof(struct ether_header);\n\t\tether_input(ifp, eh, m);\n\t}\n\n\treturn(r);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint tl_intvec_rxeoc;\nint tl_intvec_rxeof;\n\nint tl_intvec_rxeoc(xsc, type)\n\tvoid\t\t\t*xsc;\n\tu_int32_t\t\ttype;\n{\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\tr;\n\n\tsc = xsc;\n\n\t/* Flush out the receive queue and ack RXEOF interrupts. */\n\tr = tl_intvec_rxeof(xsc, type);\n\tCMD_PUT(sc, TL_CMD_ACK | r | (type & ~(0x00100000)));\n\tr = 1;\n\tCSR_WRITE_4(sc, TL_CH_PARM, vtophys(sc->tl_cdata.tl_rx_head->tl_ptr));\n\tr |= (TL_CMD_GO|TL_CMD_RT);\n\treturn(r);\n}"
  },
  {
    "function_name": "tl_intvec_rxeof",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
    "lines": "1495-1574",
    "snippet": "int tl_intvec_rxeof(xsc, type)\n\tvoid\t\t\t*xsc;\n\tu_int32_t\t\ttype;\n{\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\tr = 0, total_len = 0;\n\tstruct ether_header\t*eh;\n\tstruct mbuf\t\t*m;\n\tstruct ifnet\t\t*ifp;\n\tstruct tl_chain_onefrag\t*cur_rx;\n\n\tsc = xsc;\n\tifp = &sc->arpcom.ac_if;\n\n\twhile(sc->tl_cdata.tl_rx_head->tl_ptr->tlist_cstat & TL_CSTAT_FRAMECMP){\n\t\tr++;\n\t\tcur_rx = sc->tl_cdata.tl_rx_head;\n\t\tsc->tl_cdata.tl_rx_head = cur_rx->tl_next;\n\t\tm = cur_rx->tl_mbuf;\n\t\ttotal_len = cur_rx->tl_ptr->tlist_frsize;\n\n\t\tif (tl_newbuf(sc, cur_rx) == ENOBUFS) {\n\t\t\tifp->if_ierrors++;\n\t\t\tcur_rx->tl_ptr->tlist_frsize = MCLBYTES;\n\t\t\tcur_rx->tl_ptr->tlist_cstat = TL_CSTAT_READY;\n\t\t\tcur_rx->tl_ptr->tl_frag.tlist_dcnt = MCLBYTES;\n\t\t\tcontinue;\n\t\t}\n\n\t\tsc->tl_cdata.tl_rx_tail->tl_ptr->tlist_fptr =\n\t\t\t\t\t\tvtophys(cur_rx->tl_ptr);\n\t\tsc->tl_cdata.tl_rx_tail->tl_next = cur_rx;\n\t\tsc->tl_cdata.tl_rx_tail = cur_rx;\n\n\t\teh = mtod(m, struct ether_header *);\n\t\tm->m_pkthdr.rcvif = ifp;\n\n\t\t/*\n\t\t * Note: when the ThunderLAN chip is in 'capture all\n\t\t * frames' mode, it will receive its own transmissions.\n\t\t * We drop don't need to process our own transmissions,\n\t\t * so we drop them here and continue.\n\t\t */\n\t\t/*if (ifp->if_flags & IFF_PROMISC && */\n\t\tif (!bcmp(eh->ether_shost, sc->arpcom.ac_enaddr,\n\t\t \t\t\t\t\tETHER_ADDR_LEN)) {\n\t\t\t\tm_freem(m);\n\t\t\t\tcontinue;\n\t\t}\n\n#if NBPFILTER > 0\n\t\t/*\n\t \t * Handle BPF listeners. Let the BPF user see the packet, but\n\t \t * don't pass it up to the ether_input() layer unless it's\n\t \t * a broadcast packet, multicast packet, matches our ethernet\n\t \t * address or the interface is in promiscuous mode. If we don't\n\t \t * want the packet, just forget it. We leave the mbuf in place\n\t \t * since it can be used again later.\n\t \t */\n\t\tif (ifp->if_bpf) {\n\t\t\tm->m_pkthdr.len = m->m_len = total_len;\n\t\t\tbpf_mtap(ifp->if_bpf, m);\n\t\t\tif (ifp->if_flags & IFF_PROMISC &&\n\t\t\t\t(bcmp(eh->ether_dhost, sc->arpcom.ac_enaddr,\n\t\t \t\t\t\tETHER_ADDR_LEN) &&\n\t\t\t\t\t(eh->ether_dhost[0] & 1) == 0)) {\n\t\t\t\tm_freem(m);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n#endif\n\t\t/* Remove header from mbuf and pass it on. */\n\t\tm->m_pkthdr.len = m->m_len =\n\t\t\t\ttotal_len - sizeof(struct ether_header);\n\t\tm->m_data += sizeof(struct ether_header);\n\t\tether_input(ifp, eh, m);\n\t}\n\n\treturn(r);\n}",
    "includes": [
      "#include <dev/pci/if_tlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int tl_intvec_rxeof",
      "int tl_newbuf"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ether_input",
          "args": [
            "ifp",
            "eh",
            "m"
          ],
          "line": 1570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m"
          ],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcmp",
          "args": [
            "eh->ether_dhost",
            "sc->arpcom.ac_enaddr",
            "ETHER_ADDR_LEN"
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_mtap",
          "args": [
            "ifp->if_bpf",
            "m"
          ],
          "line": 1556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m"
          ],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcmp",
          "args": [
            "eh->ether_shost",
            "sc->arpcom.ac_enaddr",
            "ETHER_ADDR_LEN"
          ],
          "line": 1539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "structether_header*"
          ],
          "line": 1529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "cur_rx->tl_ptr"
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tl_newbuf",
          "args": [
            "sc",
            "cur_rx"
          ],
          "line": 1516
        },
        "resolved": true,
        "details": {
          "function_name": "tl_newbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "1441-1471",
          "snippet": "int tl_newbuf(sc, c)\n\tstruct tl_softc\t\t*sc;\n\tstruct tl_chain_onefrag\t*c;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\n\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\tif (m_new == NULL) {\n\t\treturn(ENOBUFS);\n\t}\n\n\tMCLGET(m_new, M_DONTWAIT);\n\tif (!(m_new->m_flags & M_EXT)) {\n\t\tm_freem(m_new);\n\t\treturn(ENOBUFS);\n\t}\n\n#ifdef __alpha__\n\tm_new->m_data += 2;\n#endif\n\n\tc->tl_mbuf = m_new;\n\tc->tl_next = NULL;\n\tc->tl_ptr->tlist_frsize = MCLBYTES;\n\tc->tl_ptr->tlist_cstat = TL_CSTAT_READY;\n\tc->tl_ptr->tlist_fptr = 0;\n\tc->tl_ptr->tl_frag.tlist_dadr = vtophys(mtod(m_new, caddr_t));\n\tc->tl_ptr->tl_frag.tlist_dcnt = MCLBYTES;\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int tl_newbuf"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint tl_newbuf;\n\nint tl_newbuf(sc, c)\n\tstruct tl_softc\t\t*sc;\n\tstruct tl_chain_onefrag\t*c;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\n\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\tif (m_new == NULL) {\n\t\treturn(ENOBUFS);\n\t}\n\n\tMCLGET(m_new, M_DONTWAIT);\n\tif (!(m_new->m_flags & M_EXT)) {\n\t\tm_freem(m_new);\n\t\treturn(ENOBUFS);\n\t}\n\n#ifdef __alpha__\n\tm_new->m_data += 2;\n#endif\n\n\tc->tl_mbuf = m_new;\n\tc->tl_next = NULL;\n\tc->tl_ptr->tlist_frsize = MCLBYTES;\n\tc->tl_ptr->tlist_cstat = TL_CSTAT_READY;\n\tc->tl_ptr->tlist_fptr = 0;\n\tc->tl_ptr->tl_frag.tlist_dadr = vtophys(mtod(m_new, caddr_t));\n\tc->tl_ptr->tl_frag.tlist_dcnt = MCLBYTES;\n\n\treturn(0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint tl_intvec_rxeof;\nint tl_newbuf;\n\nint tl_intvec_rxeof(xsc, type)\n\tvoid\t\t\t*xsc;\n\tu_int32_t\t\ttype;\n{\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\tr = 0, total_len = 0;\n\tstruct ether_header\t*eh;\n\tstruct mbuf\t\t*m;\n\tstruct ifnet\t\t*ifp;\n\tstruct tl_chain_onefrag\t*cur_rx;\n\n\tsc = xsc;\n\tifp = &sc->arpcom.ac_if;\n\n\twhile(sc->tl_cdata.tl_rx_head->tl_ptr->tlist_cstat & TL_CSTAT_FRAMECMP){\n\t\tr++;\n\t\tcur_rx = sc->tl_cdata.tl_rx_head;\n\t\tsc->tl_cdata.tl_rx_head = cur_rx->tl_next;\n\t\tm = cur_rx->tl_mbuf;\n\t\ttotal_len = cur_rx->tl_ptr->tlist_frsize;\n\n\t\tif (tl_newbuf(sc, cur_rx) == ENOBUFS) {\n\t\t\tifp->if_ierrors++;\n\t\t\tcur_rx->tl_ptr->tlist_frsize = MCLBYTES;\n\t\t\tcur_rx->tl_ptr->tlist_cstat = TL_CSTAT_READY;\n\t\t\tcur_rx->tl_ptr->tl_frag.tlist_dcnt = MCLBYTES;\n\t\t\tcontinue;\n\t\t}\n\n\t\tsc->tl_cdata.tl_rx_tail->tl_ptr->tlist_fptr =\n\t\t\t\t\t\tvtophys(cur_rx->tl_ptr);\n\t\tsc->tl_cdata.tl_rx_tail->tl_next = cur_rx;\n\t\tsc->tl_cdata.tl_rx_tail = cur_rx;\n\n\t\teh = mtod(m, struct ether_header *);\n\t\tm->m_pkthdr.rcvif = ifp;\n\n\t\t/*\n\t\t * Note: when the ThunderLAN chip is in 'capture all\n\t\t * frames' mode, it will receive its own transmissions.\n\t\t * We drop don't need to process our own transmissions,\n\t\t * so we drop them here and continue.\n\t\t */\n\t\t/*if (ifp->if_flags & IFF_PROMISC && */\n\t\tif (!bcmp(eh->ether_shost, sc->arpcom.ac_enaddr,\n\t\t \t\t\t\t\tETHER_ADDR_LEN)) {\n\t\t\t\tm_freem(m);\n\t\t\t\tcontinue;\n\t\t}\n\n#if NBPFILTER > 0\n\t\t/*\n\t \t * Handle BPF listeners. Let the BPF user see the packet, but\n\t \t * don't pass it up to the ether_input() layer unless it's\n\t \t * a broadcast packet, multicast packet, matches our ethernet\n\t \t * address or the interface is in promiscuous mode. If we don't\n\t \t * want the packet, just forget it. We leave the mbuf in place\n\t \t * since it can be used again later.\n\t \t */\n\t\tif (ifp->if_bpf) {\n\t\t\tm->m_pkthdr.len = m->m_len = total_len;\n\t\t\tbpf_mtap(ifp->if_bpf, m);\n\t\t\tif (ifp->if_flags & IFF_PROMISC &&\n\t\t\t\t(bcmp(eh->ether_dhost, sc->arpcom.ac_enaddr,\n\t\t \t\t\t\tETHER_ADDR_LEN) &&\n\t\t\t\t\t(eh->ether_dhost[0] & 1) == 0)) {\n\t\t\t\tm_freem(m);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n#endif\n\t\t/* Remove header from mbuf and pass it on. */\n\t\tm->m_pkthdr.len = m->m_len =\n\t\t\t\ttotal_len - sizeof(struct ether_header);\n\t\tm->m_data += sizeof(struct ether_header);\n\t\tether_input(ifp, eh, m);\n\t}\n\n\treturn(r);\n}"
  },
  {
    "function_name": "tl_newbuf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
    "lines": "1441-1471",
    "snippet": "int tl_newbuf(sc, c)\n\tstruct tl_softc\t\t*sc;\n\tstruct tl_chain_onefrag\t*c;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\n\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\tif (m_new == NULL) {\n\t\treturn(ENOBUFS);\n\t}\n\n\tMCLGET(m_new, M_DONTWAIT);\n\tif (!(m_new->m_flags & M_EXT)) {\n\t\tm_freem(m_new);\n\t\treturn(ENOBUFS);\n\t}\n\n#ifdef __alpha__\n\tm_new->m_data += 2;\n#endif\n\n\tc->tl_mbuf = m_new;\n\tc->tl_next = NULL;\n\tc->tl_ptr->tlist_frsize = MCLBYTES;\n\tc->tl_ptr->tlist_cstat = TL_CSTAT_READY;\n\tc->tl_ptr->tlist_fptr = 0;\n\tc->tl_ptr->tl_frag.tlist_dadr = vtophys(mtod(m_new, caddr_t));\n\tc->tl_ptr->tl_frag.tlist_dcnt = MCLBYTES;\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/pci/if_tlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int tl_newbuf"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "mtod(m_new, caddr_t)"
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m_new",
            "caddr_t"
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m_new"
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MCLGET",
          "args": [
            "m_new",
            "M_DONTWAIT"
          ],
          "line": 1452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MGETHDR",
          "args": [
            "m_new",
            "M_DONTWAIT",
            "MT_DATA"
          ],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint tl_newbuf;\n\nint tl_newbuf(sc, c)\n\tstruct tl_softc\t\t*sc;\n\tstruct tl_chain_onefrag\t*c;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\n\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\tif (m_new == NULL) {\n\t\treturn(ENOBUFS);\n\t}\n\n\tMCLGET(m_new, M_DONTWAIT);\n\tif (!(m_new->m_flags & M_EXT)) {\n\t\tm_freem(m_new);\n\t\treturn(ENOBUFS);\n\t}\n\n#ifdef __alpha__\n\tm_new->m_data += 2;\n#endif\n\n\tc->tl_mbuf = m_new;\n\tc->tl_next = NULL;\n\tc->tl_ptr->tlist_frsize = MCLBYTES;\n\tc->tl_ptr->tlist_cstat = TL_CSTAT_READY;\n\tc->tl_ptr->tlist_fptr = 0;\n\tc->tl_ptr->tl_frag.tlist_dadr = vtophys(mtod(m_new, caddr_t));\n\tc->tl_ptr->tl_frag.tlist_dcnt = MCLBYTES;\n\n\treturn(0);\n}"
  },
  {
    "function_name": "tl_list_rx_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
    "lines": "1410-1439",
    "snippet": "int tl_list_rx_init(sc)\n\tstruct tl_softc\t\t*sc;\n{\n\tstruct tl_chain_data\t*cd;\n\tstruct tl_list_data\t*ld;\n\tint\t\t\ti;\n\n\tcd = &sc->tl_cdata;\n\tld = sc->tl_ldata;\n\n\tfor (i = 0; i < TL_RX_LIST_CNT; i++) {\n\t\tcd->tl_rx_chain[i].tl_ptr =\n\t\t\t(struct tl_list_onefrag *)&ld->tl_rx_list[i];\n\t\tif (tl_newbuf(sc, &cd->tl_rx_chain[i]) == ENOBUFS)\n\t\t\treturn(ENOBUFS);\n\t\tif (i == (TL_RX_LIST_CNT - 1)) {\n\t\t\tcd->tl_rx_chain[i].tl_next = NULL;\n\t\t\tld->tl_rx_list[i].tlist_fptr = 0;\n\t\t} else {\n\t\t\tcd->tl_rx_chain[i].tl_next = &cd->tl_rx_chain[i + 1];\n\t\t\tld->tl_rx_list[i].tlist_fptr =\n\t\t\t\t\tvtophys(&ld->tl_rx_list[i + 1]);\n\t\t}\n\t}\n\n\tcd->tl_rx_head = &cd->tl_rx_chain[0];\n\tcd->tl_rx_tail = &cd->tl_rx_chain[TL_RX_LIST_CNT - 1];\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/pci/if_tlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int tl_newbuf",
      "int tl_list_rx_init"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "&ld->tl_rx_list[i + 1]"
          ],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tl_newbuf",
          "args": [
            "sc",
            "&cd->tl_rx_chain[i]"
          ],
          "line": 1423
        },
        "resolved": true,
        "details": {
          "function_name": "tl_newbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "1441-1471",
          "snippet": "int tl_newbuf(sc, c)\n\tstruct tl_softc\t\t*sc;\n\tstruct tl_chain_onefrag\t*c;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\n\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\tif (m_new == NULL) {\n\t\treturn(ENOBUFS);\n\t}\n\n\tMCLGET(m_new, M_DONTWAIT);\n\tif (!(m_new->m_flags & M_EXT)) {\n\t\tm_freem(m_new);\n\t\treturn(ENOBUFS);\n\t}\n\n#ifdef __alpha__\n\tm_new->m_data += 2;\n#endif\n\n\tc->tl_mbuf = m_new;\n\tc->tl_next = NULL;\n\tc->tl_ptr->tlist_frsize = MCLBYTES;\n\tc->tl_ptr->tlist_cstat = TL_CSTAT_READY;\n\tc->tl_ptr->tlist_fptr = 0;\n\tc->tl_ptr->tl_frag.tlist_dadr = vtophys(mtod(m_new, caddr_t));\n\tc->tl_ptr->tl_frag.tlist_dcnt = MCLBYTES;\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int tl_newbuf"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint tl_newbuf;\n\nint tl_newbuf(sc, c)\n\tstruct tl_softc\t\t*sc;\n\tstruct tl_chain_onefrag\t*c;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\n\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\tif (m_new == NULL) {\n\t\treturn(ENOBUFS);\n\t}\n\n\tMCLGET(m_new, M_DONTWAIT);\n\tif (!(m_new->m_flags & M_EXT)) {\n\t\tm_freem(m_new);\n\t\treturn(ENOBUFS);\n\t}\n\n#ifdef __alpha__\n\tm_new->m_data += 2;\n#endif\n\n\tc->tl_mbuf = m_new;\n\tc->tl_next = NULL;\n\tc->tl_ptr->tlist_frsize = MCLBYTES;\n\tc->tl_ptr->tlist_cstat = TL_CSTAT_READY;\n\tc->tl_ptr->tlist_fptr = 0;\n\tc->tl_ptr->tl_frag.tlist_dadr = vtophys(mtod(m_new, caddr_t));\n\tc->tl_ptr->tl_frag.tlist_dcnt = MCLBYTES;\n\n\treturn(0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint tl_newbuf;\nint tl_list_rx_init;\n\nint tl_list_rx_init(sc)\n\tstruct tl_softc\t\t*sc;\n{\n\tstruct tl_chain_data\t*cd;\n\tstruct tl_list_data\t*ld;\n\tint\t\t\ti;\n\n\tcd = &sc->tl_cdata;\n\tld = sc->tl_ldata;\n\n\tfor (i = 0; i < TL_RX_LIST_CNT; i++) {\n\t\tcd->tl_rx_chain[i].tl_ptr =\n\t\t\t(struct tl_list_onefrag *)&ld->tl_rx_list[i];\n\t\tif (tl_newbuf(sc, &cd->tl_rx_chain[i]) == ENOBUFS)\n\t\t\treturn(ENOBUFS);\n\t\tif (i == (TL_RX_LIST_CNT - 1)) {\n\t\t\tcd->tl_rx_chain[i].tl_next = NULL;\n\t\t\tld->tl_rx_list[i].tlist_fptr = 0;\n\t\t} else {\n\t\t\tcd->tl_rx_chain[i].tl_next = &cd->tl_rx_chain[i + 1];\n\t\t\tld->tl_rx_list[i].tlist_fptr =\n\t\t\t\t\tvtophys(&ld->tl_rx_list[i + 1]);\n\t\t}\n\t}\n\n\tcd->tl_rx_head = &cd->tl_rx_chain[0];\n\tcd->tl_rx_tail = &cd->tl_rx_chain[TL_RX_LIST_CNT - 1];\n\n\treturn(0);\n}"
  },
  {
    "function_name": "tl_list_tx_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
    "lines": "1383-1405",
    "snippet": "int tl_list_tx_init(sc)\n\tstruct tl_softc\t\t*sc;\n{\n\tstruct tl_chain_data\t*cd;\n\tstruct tl_list_data\t*ld;\n\tint\t\t\ti;\n\n\tcd = &sc->tl_cdata;\n\tld = sc->tl_ldata;\n\tfor (i = 0; i < TL_TX_LIST_CNT; i++) {\n\t\tcd->tl_tx_chain[i].tl_ptr = &ld->tl_tx_list[i];\n\t\tif (i == (TL_TX_LIST_CNT - 1))\n\t\t\tcd->tl_tx_chain[i].tl_next = NULL;\n\t\telse\n\t\t\tcd->tl_tx_chain[i].tl_next = &cd->tl_tx_chain[i + 1];\n\t}\n\n\tcd->tl_tx_free = &cd->tl_tx_chain[0];\n\tcd->tl_tx_tail = cd->tl_tx_head = NULL;\n\tsc->tl_txeoc = 1;\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/pci/if_tlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int tl_list_tx_init"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint tl_list_tx_init;\n\nint tl_list_tx_init(sc)\n\tstruct tl_softc\t\t*sc;\n{\n\tstruct tl_chain_data\t*cd;\n\tstruct tl_list_data\t*ld;\n\tint\t\t\ti;\n\n\tcd = &sc->tl_cdata;\n\tld = sc->tl_ldata;\n\tfor (i = 0; i < TL_TX_LIST_CNT; i++) {\n\t\tcd->tl_tx_chain[i].tl_ptr = &ld->tl_tx_list[i];\n\t\tif (i == (TL_TX_LIST_CNT - 1))\n\t\t\tcd->tl_tx_chain[i].tl_next = NULL;\n\t\telse\n\t\t\tcd->tl_tx_chain[i].tl_next = &cd->tl_tx_chain[i + 1];\n\t}\n\n\tcd->tl_tx_free = &cd->tl_tx_chain[0];\n\tcd->tl_tx_tail = cd->tl_tx_head = NULL;\n\tsc->tl_txeoc = 1;\n\n\treturn(0);\n}"
  },
  {
    "function_name": "tl_attach_phy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
    "lines": "1282-1378",
    "snippet": "int tl_attach_phy(sc)\n\tstruct tl_softc\t\t*sc;\n{\n\tint\t\t\tphy_ctl;\n\tint\t\t\tmedia = IFM_ETHER|IFM_100_TX|IFM_FDX;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tsc->tl_phy_did = tl_phy_readreg(sc, TL_PHY_DEVID);\n\tsc->tl_phy_vid = tl_phy_readreg(sc, TL_PHY_VENID);\n\tsc->tl_phy_sts = tl_phy_readreg(sc, TL_PHY_GENSTS);\n\tphy_ctl = tl_phy_readreg(sc, TL_PHY_GENCTL);\n\n\tif (sc->tl_phy_sts & PHY_BMSR_100BT4 ||\n\t\tsc->tl_phy_sts & PHY_BMSR_100BTXFULL ||\n\t\tsc->tl_phy_sts & PHY_BMSR_100BTXHALF) \n\t\tifp->if_baudrate = 100000000;\n\telse\n\t\tifp->if_baudrate = 10000000;\n\n\tif (sc->tl_phy_sts & PHY_BMSR_100BT4 ||\n\t\tsc->tl_phy_sts & PHY_BMSR_100BTXHALF ||\n\t\tsc->tl_phy_sts & PHY_BMSR_100BTXHALF) {\n\t} else {\n\t\tmedia &= ~IFM_100_TX;\n\t\tmedia |= IFM_10_T;\n\t}\n\n\tif (sc->tl_phy_sts & PHY_BMSR_100BTXFULL ||\n\t\tsc->tl_phy_sts & PHY_BMSR_10BTFULL) {\n\t} else {\n\t\tmedia &= ~IFM_FDX;\n\t}\n\n\tif (sc->tl_phy_sts & PHY_BMSR_CANAUTONEG) {\n\t\tmedia = IFM_ETHER|IFM_AUTO;\n\t}\n\n\t/* Set up ifmedia data and callbacks. */\n\tifmedia_init(&sc->ifmedia, 0, tl_ifmedia_upd, tl_ifmedia_sts);\n\n\t/*\n\t * All ThunderLANs support at least 10baseT half duplex.\n\t * They also support AUI selection if used in 10Mb/s modes.\n\t */\n\tifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_10_T|IFM_HDX, 0, NULL);\n\tifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_10_T, 0, NULL);\n\tifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_10_5, 0, NULL);\n\n\t/* Some ThunderLAN PHYs support autonegotiation. */\n\tif (sc->tl_phy_sts & PHY_BMSR_CANAUTONEG)\n\t\tifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_AUTO, 0, NULL);\n\n\t/* Some support 10baseT full duplex. */\n\tif (sc->tl_phy_sts & PHY_BMSR_10BTFULL)\n\t\tifmedia_add(&sc->ifmedia,\n\t\t\tIFM_ETHER|IFM_10_T|IFM_FDX, 0, NULL);\n\n\t/* Some support 100BaseTX half duplex. */\n\tif (sc->tl_phy_sts & PHY_BMSR_100BTXHALF)\n\t\tifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_100_TX, 0, NULL);\n\tif (sc->tl_phy_sts & PHY_BMSR_100BTXHALF)\n\t\tifmedia_add(&sc->ifmedia,\n\t\t\tIFM_ETHER|IFM_100_TX|IFM_HDX, 0, NULL);\n\n\t/* Some support 100BaseTX full duplex. */\n\tif (sc->tl_phy_sts & PHY_BMSR_100BTXFULL)\n\t\tifmedia_add(&sc->ifmedia,\n\t\t\tIFM_ETHER|IFM_100_TX|IFM_FDX, 0, NULL);\n\n\t/* Some also support 100BaseT4. */\n\tif (sc->tl_phy_sts & PHY_BMSR_100BT4)\n\t\tifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_100_T4, 0, NULL);\n\n\t/* Set default media. */\n\tifmedia_set(&sc->ifmedia, media);\n\n\t/*\n\t * Kick off an autonegotiation session if this PHY supports it.\n\t * This is necessary to make sure the chip's duplex mode matches\n\t * the PHY's duplex mode. It may not: once enabled, the PHY may\n\t * autonegotiate full-duplex mode with its link partner, but the\n\t * ThunderLAN chip defaults to half-duplex and stays there unless\n\t * told otherwise.\n\t */\n\tif (sc->tl_phy_sts & PHY_BMSR_CANAUTONEG) {\n\t\ttl_init(sc);\n#ifdef TL_BACKGROUND_AUTONEG\n\t\ttl_autoneg(sc, TL_FLAG_SCHEDDELAY, 1);\n#else\n\t\ttl_autoneg(sc, TL_FLAG_FORCEDELAY, 1);\n#endif\n\t}\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/pci/if_tlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int tl_attach_phy",
      "void tl_init",
      "int tl_ifmedia_upd",
      "void tl_ifmedia_sts",
      "u_int16_t tl_phy_readreg",
      "void tl_autoneg"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tl_autoneg",
          "args": [
            "sc",
            "TL_FLAG_FORCEDELAY",
            "1"
          ],
          "line": 1373
        },
        "resolved": true,
        "details": {
          "function_name": "tl_autoneg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "808-963",
          "snippet": "void tl_autoneg(sc, flag, verbose)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\tflag;\n\tint\t\t\tverbose;\n{\n\tu_int16_t\t\tphy_sts = 0, media = 0, advert, ability;\n\tstruct ifnet\t\t*ifp;\n\tstruct ifmedia\t\t*ifm;\n\n\tifm = &sc->ifmedia;\n\tifp = &sc->arpcom.ac_if;\n\n\t/*\n\t * First, see if autoneg is supported. If not, there's\n\t * no point in continuing.\n\t */\n\tphy_sts = tl_phy_readreg(sc, PHY_BMSR);\n\tif (!(phy_sts & PHY_BMSR_CANAUTONEG)) {\n\t\tif (verbose)\n\t\t\tprintf(\"tl%d: autonegotiation not supported\\n\",\n\t\t\t\t\t\t\tsc->tl_unit);\n\t\treturn;\n\t}\n\n\tswitch (flag) {\n\tcase TL_FLAG_FORCEDELAY:\n\t\t/*\n\t \t * XXX Never use this option anywhere but in the probe\n\t \t * routine: making the kernel stop dead in its tracks\n \t\t * for three whole seconds after we've gone multi-user\n\t\t * is really bad manners.\n\t \t */\n\t\ttl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_RESET);\n\t\tDELAY(500);\n\t\tphy_sts = tl_phy_readreg(sc, PHY_BMCR);\n\t\tphy_sts |= PHY_BMCR_AUTONEGENBL|PHY_BMCR_AUTONEGRSTR;\n\t\ttl_phy_writereg(sc, PHY_BMCR, phy_sts);\n\t\tDELAY(5000000);\n\t\tbreak;\n\tcase TL_FLAG_SCHEDDELAY:\n\t\t/*\n\t\t * Wait for the transmitter to go idle before starting\n\t\t * an autoneg session, otherwise tl_start() may clobber\n\t \t * our timeout, and we don't want to allow transmission\n\t\t * during an autoneg session since that can screw it up.\n\t \t */\n\t\tif (!sc->tl_txeoc) {\n\t\t\tsc->tl_want_auto = 1;\n\t\t\treturn;\n\t\t}\n\t\ttl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_RESET);\n\t\tDELAY(500);\n\t\tphy_sts = tl_phy_readreg(sc, PHY_BMCR);\n\t\tphy_sts |= PHY_BMCR_AUTONEGENBL|PHY_BMCR_AUTONEGRSTR;\n\t\ttl_phy_writereg(sc, PHY_BMCR, phy_sts);\n\t\tifp->if_timer = 10;\n\t\tsc->tl_autoneg = 1;\n\t\tsc->tl_want_auto = 0;\n\t\treturn;\n\tcase TL_FLAG_DELAYTIMEO:\n\t\tifp->if_timer = 0;\n\t\tsc->tl_autoneg = 0;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"tl%d: invalid autoneg flag: %d\\n\", sc->tl_unit, flag);\n\t\treturn;\n\t}\n\n\t/*\n \t * Read the BMSR register twice: the LINKSTAT bit is a\n\t * latching bit.\n\t */\n\ttl_phy_readreg(sc, PHY_BMSR);\n\tphy_sts = tl_phy_readreg(sc, PHY_BMSR);\n\tif (phy_sts & PHY_BMSR_AUTONEGCOMP) {\n\t\tif (verbose)\n\t\t\tprintf(\"tl%d: autoneg complete, \", sc->tl_unit);\n\t\tphy_sts = tl_phy_readreg(sc, PHY_BMSR);\n\t} else {\n\t\tif (verbose)\n\t\t\tprintf(\"tl%d: autoneg not complete, \", sc->tl_unit);\n\t}\n\n\t/* Link is good. Report modes and set duplex mode. */\n\tif (phy_sts & PHY_BMSR_LINKSTAT) {\n\t\tif (verbose)\n\t\t\tprintf(\"link status good \");\n\n\t\tadvert = tl_phy_readreg(sc, TL_PHY_ANAR);\n\t\tability = tl_phy_readreg(sc, TL_PHY_LPAR);\n\t\tmedia = tl_phy_readreg(sc, PHY_BMCR);\n\n\t\t/*\n\t \t * Be sure to turn off the ISOLATE and\n\t\t * LOOPBACK bits in the control register,\n\t\t * otherwise we may not be able to communicate.\n\t\t */\n\t\tmedia &= ~(PHY_BMCR_LOOPBK|PHY_BMCR_ISOLATE);\n\t\t/* Set the DUPLEX bit in the NetCmd register accordingly. */\n\t\tif (advert & PHY_ANAR_100BT4 && ability & PHY_ANAR_100BT4) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_100_T4;\n\t\t\tmedia |= PHY_BMCR_SPEEDSEL;\n\t\t\tmedia &= ~PHY_BMCR_DUPLEX;\n\t\t\tif (verbose)\n\t\t\t\tprintf(\"(100baseT4)\\n\");\n\t\t} else if (advert & PHY_ANAR_100BTXFULL &&\n\t\t\tability & PHY_ANAR_100BTXFULL) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_100_TX|IFM_FDX;\n\t\t\tmedia |= PHY_BMCR_SPEEDSEL;\n\t\t\tmedia |= PHY_BMCR_DUPLEX;\n\t\t\tif (verbose)\n\t\t\t\tprintf(\"(full-duplex, 100Mbps)\\n\");\n\t\t} else if (advert & PHY_ANAR_100BTXHALF &&\n\t\t\tability & PHY_ANAR_100BTXHALF) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_100_TX|IFM_HDX;\n\t\t\tmedia |= PHY_BMCR_SPEEDSEL;\n\t\t\tmedia &= ~PHY_BMCR_DUPLEX;\n\t\t\tif (verbose)\n\t\t\t\tprintf(\"(half-duplex, 100Mbps)\\n\");\n\t\t} else if (advert & PHY_ANAR_10BTFULL &&\n\t\t\tability & PHY_ANAR_10BTFULL) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_10_T|IFM_FDX;\n\t\t\tmedia &= ~PHY_BMCR_SPEEDSEL;\n\t\t\tmedia |= PHY_BMCR_DUPLEX;\n\t\t\tif (verbose)\n\t\t\t\tprintf(\"(full-duplex, 10Mbps)\\n\");\n\t\t} else {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_10_T|IFM_HDX;\n\t\t\tmedia &= ~PHY_BMCR_SPEEDSEL;\n\t\t\tmedia &= ~PHY_BMCR_DUPLEX;\n\t\t\tif (verbose)\n\t\t\t\tprintf(\"(half-duplex, 10Mbps)\\n\");\n\t\t}\n\n\t\tif (media & PHY_BMCR_DUPLEX)\n\t\t\ttl_dio_setbit(sc, TL_NETCMD, TL_CMD_DUPLEX);\n\t\telse\n\t\t\ttl_dio_clrbit(sc, TL_NETCMD, TL_CMD_DUPLEX);\n\n\t\tmedia &= ~PHY_BMCR_AUTONEGENBL;\n\t\ttl_phy_writereg(sc, PHY_BMCR, media);\n\t} else {\n\t\tif (verbose)\n\t\t\tprintf(\"no carrier\\n\");\n\t}\n\n\ttl_init(sc);\n\n\tif (sc->tl_tx_pend) {\n\t\tsc->tl_autoneg = 0;\n\t\tsc->tl_tx_pend = 0;\n\t\ttl_start(ifp);\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void tl_start",
            "void tl_init",
            "u_int16_t tl_phy_readreg",
            "void tl_phy_writereg",
            "void tl_autoneg",
            "void tl_dio_setbit",
            "void tl_dio_clrbit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_start;\nvoid tl_init;\nu_int16_t tl_phy_readreg;\nvoid tl_phy_writereg;\nvoid tl_autoneg;\nvoid tl_dio_setbit;\nvoid tl_dio_clrbit;\n\nvoid tl_autoneg(sc, flag, verbose)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\tflag;\n\tint\t\t\tverbose;\n{\n\tu_int16_t\t\tphy_sts = 0, media = 0, advert, ability;\n\tstruct ifnet\t\t*ifp;\n\tstruct ifmedia\t\t*ifm;\n\n\tifm = &sc->ifmedia;\n\tifp = &sc->arpcom.ac_if;\n\n\t/*\n\t * First, see if autoneg is supported. If not, there's\n\t * no point in continuing.\n\t */\n\tphy_sts = tl_phy_readreg(sc, PHY_BMSR);\n\tif (!(phy_sts & PHY_BMSR_CANAUTONEG)) {\n\t\tif (verbose)\n\t\t\tprintf(\"tl%d: autonegotiation not supported\\n\",\n\t\t\t\t\t\t\tsc->tl_unit);\n\t\treturn;\n\t}\n\n\tswitch (flag) {\n\tcase TL_FLAG_FORCEDELAY:\n\t\t/*\n\t \t * XXX Never use this option anywhere but in the probe\n\t \t * routine: making the kernel stop dead in its tracks\n \t\t * for three whole seconds after we've gone multi-user\n\t\t * is really bad manners.\n\t \t */\n\t\ttl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_RESET);\n\t\tDELAY(500);\n\t\tphy_sts = tl_phy_readreg(sc, PHY_BMCR);\n\t\tphy_sts |= PHY_BMCR_AUTONEGENBL|PHY_BMCR_AUTONEGRSTR;\n\t\ttl_phy_writereg(sc, PHY_BMCR, phy_sts);\n\t\tDELAY(5000000);\n\t\tbreak;\n\tcase TL_FLAG_SCHEDDELAY:\n\t\t/*\n\t\t * Wait for the transmitter to go idle before starting\n\t\t * an autoneg session, otherwise tl_start() may clobber\n\t \t * our timeout, and we don't want to allow transmission\n\t\t * during an autoneg session since that can screw it up.\n\t \t */\n\t\tif (!sc->tl_txeoc) {\n\t\t\tsc->tl_want_auto = 1;\n\t\t\treturn;\n\t\t}\n\t\ttl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_RESET);\n\t\tDELAY(500);\n\t\tphy_sts = tl_phy_readreg(sc, PHY_BMCR);\n\t\tphy_sts |= PHY_BMCR_AUTONEGENBL|PHY_BMCR_AUTONEGRSTR;\n\t\ttl_phy_writereg(sc, PHY_BMCR, phy_sts);\n\t\tifp->if_timer = 10;\n\t\tsc->tl_autoneg = 1;\n\t\tsc->tl_want_auto = 0;\n\t\treturn;\n\tcase TL_FLAG_DELAYTIMEO:\n\t\tifp->if_timer = 0;\n\t\tsc->tl_autoneg = 0;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"tl%d: invalid autoneg flag: %d\\n\", sc->tl_unit, flag);\n\t\treturn;\n\t}\n\n\t/*\n \t * Read the BMSR register twice: the LINKSTAT bit is a\n\t * latching bit.\n\t */\n\ttl_phy_readreg(sc, PHY_BMSR);\n\tphy_sts = tl_phy_readreg(sc, PHY_BMSR);\n\tif (phy_sts & PHY_BMSR_AUTONEGCOMP) {\n\t\tif (verbose)\n\t\t\tprintf(\"tl%d: autoneg complete, \", sc->tl_unit);\n\t\tphy_sts = tl_phy_readreg(sc, PHY_BMSR);\n\t} else {\n\t\tif (verbose)\n\t\t\tprintf(\"tl%d: autoneg not complete, \", sc->tl_unit);\n\t}\n\n\t/* Link is good. Report modes and set duplex mode. */\n\tif (phy_sts & PHY_BMSR_LINKSTAT) {\n\t\tif (verbose)\n\t\t\tprintf(\"link status good \");\n\n\t\tadvert = tl_phy_readreg(sc, TL_PHY_ANAR);\n\t\tability = tl_phy_readreg(sc, TL_PHY_LPAR);\n\t\tmedia = tl_phy_readreg(sc, PHY_BMCR);\n\n\t\t/*\n\t \t * Be sure to turn off the ISOLATE and\n\t\t * LOOPBACK bits in the control register,\n\t\t * otherwise we may not be able to communicate.\n\t\t */\n\t\tmedia &= ~(PHY_BMCR_LOOPBK|PHY_BMCR_ISOLATE);\n\t\t/* Set the DUPLEX bit in the NetCmd register accordingly. */\n\t\tif (advert & PHY_ANAR_100BT4 && ability & PHY_ANAR_100BT4) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_100_T4;\n\t\t\tmedia |= PHY_BMCR_SPEEDSEL;\n\t\t\tmedia &= ~PHY_BMCR_DUPLEX;\n\t\t\tif (verbose)\n\t\t\t\tprintf(\"(100baseT4)\\n\");\n\t\t} else if (advert & PHY_ANAR_100BTXFULL &&\n\t\t\tability & PHY_ANAR_100BTXFULL) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_100_TX|IFM_FDX;\n\t\t\tmedia |= PHY_BMCR_SPEEDSEL;\n\t\t\tmedia |= PHY_BMCR_DUPLEX;\n\t\t\tif (verbose)\n\t\t\t\tprintf(\"(full-duplex, 100Mbps)\\n\");\n\t\t} else if (advert & PHY_ANAR_100BTXHALF &&\n\t\t\tability & PHY_ANAR_100BTXHALF) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_100_TX|IFM_HDX;\n\t\t\tmedia |= PHY_BMCR_SPEEDSEL;\n\t\t\tmedia &= ~PHY_BMCR_DUPLEX;\n\t\t\tif (verbose)\n\t\t\t\tprintf(\"(half-duplex, 100Mbps)\\n\");\n\t\t} else if (advert & PHY_ANAR_10BTFULL &&\n\t\t\tability & PHY_ANAR_10BTFULL) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_10_T|IFM_FDX;\n\t\t\tmedia &= ~PHY_BMCR_SPEEDSEL;\n\t\t\tmedia |= PHY_BMCR_DUPLEX;\n\t\t\tif (verbose)\n\t\t\t\tprintf(\"(full-duplex, 10Mbps)\\n\");\n\t\t} else {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_10_T|IFM_HDX;\n\t\t\tmedia &= ~PHY_BMCR_SPEEDSEL;\n\t\t\tmedia &= ~PHY_BMCR_DUPLEX;\n\t\t\tif (verbose)\n\t\t\t\tprintf(\"(half-duplex, 10Mbps)\\n\");\n\t\t}\n\n\t\tif (media & PHY_BMCR_DUPLEX)\n\t\t\ttl_dio_setbit(sc, TL_NETCMD, TL_CMD_DUPLEX);\n\t\telse\n\t\t\ttl_dio_clrbit(sc, TL_NETCMD, TL_CMD_DUPLEX);\n\n\t\tmedia &= ~PHY_BMCR_AUTONEGENBL;\n\t\ttl_phy_writereg(sc, PHY_BMCR, media);\n\t} else {\n\t\tif (verbose)\n\t\t\tprintf(\"no carrier\\n\");\n\t}\n\n\ttl_init(sc);\n\n\tif (sc->tl_tx_pend) {\n\t\tsc->tl_autoneg = 0;\n\t\tsc->tl_tx_pend = 0;\n\t\ttl_start(ifp);\n\t}\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tl_init",
          "args": [
            "sc"
          ],
          "line": 1369
        },
        "resolved": true,
        "details": {
          "function_name": "tl_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "2052-2156",
          "snippet": "void tl_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct tl_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n        int\t\t\ts;\n\tu_int16_t\t\tphy_sts;\n\n\tif (sc->tl_autoneg)\n\t\treturn;\n\n\ts = splimp();\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/*\n\t * Cancel pending I/O.\n\t */\n\ttl_stop(sc);\n\n\t/*\n\t * Set 'capture all frames' bit for promiscuous mode.\n\t */\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\ttl_dio_setbit(sc, TL_NETCMD, TL_CMD_CAF);\n\telse\n\t\ttl_dio_clrbit(sc, TL_NETCMD, TL_CMD_CAF);\n\n\t/*\n\t * Set capture broadcast bit to capture broadcast frames.\n\t */\n\tif (ifp->if_flags & IFF_BROADCAST)\n\t\ttl_dio_clrbit(sc, TL_NETCMD, TL_CMD_NOBRX);\n\telse\n\t\ttl_dio_setbit(sc, TL_NETCMD, TL_CMD_NOBRX);\n\n\t/* Init our MAC address */\n\ttl_setfilt(sc, (caddr_t)&sc->arpcom.ac_enaddr, 0);\n\n\t/* Init multicast filter, if needed. */\n\ttl_setmulti(sc);\n\n\t/* Init circular RX list. */\n\tif (tl_list_rx_init(sc) == ENOBUFS) {\n\t\tprintf(\"tl%d: initialization failed: no \"\n\t\t\t\"memory for rx buffers\\n\", sc->tl_unit);\n\t\ttl_stop(sc);\n\t\treturn;\n\t}\n\n\t/* Init TX pointers. */\n\ttl_list_tx_init(sc);\n\n\t/*\n\t * Enable PHY interrupts.\n\t */\n\tphy_sts = tl_phy_readreg(sc, TL_PHY_CTL);\n\tphy_sts |= PHY_CTL_INTEN;\n\ttl_phy_writereg(sc, TL_PHY_CTL, phy_sts);\n\n\t/* Enable MII interrupts. */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\n\t/* Enable PCI interrupts. */\n\tCMD_SET(sc, TL_CMD_INTSON);\n\n\t/* Load the address of the rx list */\n\tCMD_SET(sc, TL_CMD_RT);\n\tCSR_WRITE_4(sc, TL_CH_PARM, vtophys(&sc->tl_ldata->tl_rx_list[0]));\n\n\t/*\n\t * XXX This is a kludge to handle adapters with the Micro Linear\n\t * ML6692 100BaseTX PHY, which only supports 100Mbps modes and\n\t * relies on the controller's internal 10Mbps PHY to provide\n\t * 10Mbps modes. The ML6692 always shows up with a vendor/device ID\n\t * of 0 (it doesn't actually have vendor/device ID registers)\n\t * so we use that property to detect it. In theory there ought to\n\t * be a better way to 'spot the looney' but I can't find one.\n         */\n        if (!sc->tl_phy_vid) {\n                u_int8_t                        addr = 0;\n                u_int16_t                       bmcr;\n\n                bmcr = tl_phy_readreg(sc, PHY_BMCR);\n                addr = sc->tl_phy_addr;\n                sc->tl_phy_addr = TL_PHYADDR_MAX;\n                tl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_RESET);\n                if (bmcr & PHY_BMCR_SPEEDSEL)\n                        tl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_ISOLATE);\n                else\n                        tl_phy_writereg(sc, PHY_BMCR, bmcr);\n                sc->tl_phy_addr = addr;\n        }\n\n\t/* Send the RX go command */\n\tCMD_SET(sc, TL_CMD_GO|TL_CMD_RT);\n\n\t(void)splx(s);\n\n\t/* Start the stats update counter */\n\ttimeout(tl_stats_update, sc, hz);\n\ttimeout(tl_wait_up, sc, 2 * hz);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void tl_wait_up",
            "void tl_stats_update",
            "void tl_init",
            "void tl_stop",
            "u_int16_t tl_phy_readreg",
            "void tl_phy_writereg",
            "void tl_autoneg",
            "void tl_setmulti",
            "void tl_setfilt",
            "int tl_list_rx_init",
            "int tl_list_tx_init",
            "void tl_dio_setbit",
            "void tl_dio_clrbit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_wait_up;\nvoid tl_stats_update;\nvoid tl_init;\nvoid tl_stop;\nu_int16_t tl_phy_readreg;\nvoid tl_phy_writereg;\nvoid tl_autoneg;\nvoid tl_setmulti;\nvoid tl_setfilt;\nint tl_list_rx_init;\nint tl_list_tx_init;\nvoid tl_dio_setbit;\nvoid tl_dio_clrbit;\n\nvoid tl_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct tl_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n        int\t\t\ts;\n\tu_int16_t\t\tphy_sts;\n\n\tif (sc->tl_autoneg)\n\t\treturn;\n\n\ts = splimp();\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/*\n\t * Cancel pending I/O.\n\t */\n\ttl_stop(sc);\n\n\t/*\n\t * Set 'capture all frames' bit for promiscuous mode.\n\t */\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\ttl_dio_setbit(sc, TL_NETCMD, TL_CMD_CAF);\n\telse\n\t\ttl_dio_clrbit(sc, TL_NETCMD, TL_CMD_CAF);\n\n\t/*\n\t * Set capture broadcast bit to capture broadcast frames.\n\t */\n\tif (ifp->if_flags & IFF_BROADCAST)\n\t\ttl_dio_clrbit(sc, TL_NETCMD, TL_CMD_NOBRX);\n\telse\n\t\ttl_dio_setbit(sc, TL_NETCMD, TL_CMD_NOBRX);\n\n\t/* Init our MAC address */\n\ttl_setfilt(sc, (caddr_t)&sc->arpcom.ac_enaddr, 0);\n\n\t/* Init multicast filter, if needed. */\n\ttl_setmulti(sc);\n\n\t/* Init circular RX list. */\n\tif (tl_list_rx_init(sc) == ENOBUFS) {\n\t\tprintf(\"tl%d: initialization failed: no \"\n\t\t\t\"memory for rx buffers\\n\", sc->tl_unit);\n\t\ttl_stop(sc);\n\t\treturn;\n\t}\n\n\t/* Init TX pointers. */\n\ttl_list_tx_init(sc);\n\n\t/*\n\t * Enable PHY interrupts.\n\t */\n\tphy_sts = tl_phy_readreg(sc, TL_PHY_CTL);\n\tphy_sts |= PHY_CTL_INTEN;\n\ttl_phy_writereg(sc, TL_PHY_CTL, phy_sts);\n\n\t/* Enable MII interrupts. */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\n\t/* Enable PCI interrupts. */\n\tCMD_SET(sc, TL_CMD_INTSON);\n\n\t/* Load the address of the rx list */\n\tCMD_SET(sc, TL_CMD_RT);\n\tCSR_WRITE_4(sc, TL_CH_PARM, vtophys(&sc->tl_ldata->tl_rx_list[0]));\n\n\t/*\n\t * XXX This is a kludge to handle adapters with the Micro Linear\n\t * ML6692 100BaseTX PHY, which only supports 100Mbps modes and\n\t * relies on the controller's internal 10Mbps PHY to provide\n\t * 10Mbps modes. The ML6692 always shows up with a vendor/device ID\n\t * of 0 (it doesn't actually have vendor/device ID registers)\n\t * so we use that property to detect it. In theory there ought to\n\t * be a better way to 'spot the looney' but I can't find one.\n         */\n        if (!sc->tl_phy_vid) {\n                u_int8_t                        addr = 0;\n                u_int16_t                       bmcr;\n\n                bmcr = tl_phy_readreg(sc, PHY_BMCR);\n                addr = sc->tl_phy_addr;\n                sc->tl_phy_addr = TL_PHYADDR_MAX;\n                tl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_RESET);\n                if (bmcr & PHY_BMCR_SPEEDSEL)\n                        tl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_ISOLATE);\n                else\n                        tl_phy_writereg(sc, PHY_BMCR, bmcr);\n                sc->tl_phy_addr = addr;\n        }\n\n\t/* Send the RX go command */\n\tCMD_SET(sc, TL_CMD_GO|TL_CMD_RT);\n\n\t(void)splx(s);\n\n\t/* Start the stats update counter */\n\ttimeout(tl_stats_update, sc, hz);\n\ttimeout(tl_wait_up, sc, 2 * hz);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ifmedia_set",
          "args": [
            "&sc->ifmedia",
            "media"
          ],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "&sc->ifmedia",
            "IFM_ETHER|IFM_100_T4",
            "0",
            "NULL"
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "&sc->ifmedia",
            "IFM_ETHER|IFM_100_TX|IFM_FDX",
            "0",
            "NULL"
          ],
          "line": 1350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "&sc->ifmedia",
            "IFM_ETHER|IFM_100_TX|IFM_HDX",
            "0",
            "NULL"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "&sc->ifmedia",
            "IFM_ETHER|IFM_100_TX",
            "0",
            "NULL"
          ],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "&sc->ifmedia",
            "IFM_ETHER|IFM_10_T|IFM_FDX",
            "0",
            "NULL"
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "&sc->ifmedia",
            "IFM_ETHER|IFM_AUTO",
            "0",
            "NULL"
          ],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "&sc->ifmedia",
            "IFM_ETHER|IFM_10_5",
            "0",
            "NULL"
          ],
          "line": 1330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "&sc->ifmedia",
            "IFM_ETHER|IFM_10_T",
            "0",
            "NULL"
          ],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "&sc->ifmedia",
            "IFM_ETHER|IFM_10_T|IFM_HDX",
            "0",
            "NULL"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_init",
          "args": [
            "&sc->ifmedia",
            "0",
            "tl_ifmedia_upd",
            "tl_ifmedia_sts"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tl_phy_readreg",
          "args": [
            "sc",
            "TL_PHY_GENCTL"
          ],
          "line": 1294
        },
        "resolved": true,
        "details": {
          "function_name": "tl_phy_readreg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "722-738",
          "snippet": "u_int16_t tl_phy_readreg(sc, reg)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tstruct tl_mii_frame\tframe;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = sc->tl_phy_addr;\n\tframe.mii_regaddr = reg;\n\ttl_mii_readreg(sc, &frame);\n\n\t/* Reenable MII interrupts, just in case. */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\n\treturn(frame.mii_data);\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int tl_mii_readreg",
            "u_int16_t tl_phy_readreg",
            "void tl_dio_setbit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint tl_mii_readreg;\nu_int16_t tl_phy_readreg;\nvoid tl_dio_setbit;\n\nu_int16_t tl_phy_readreg(sc, reg)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tstruct tl_mii_frame\tframe;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = sc->tl_phy_addr;\n\tframe.mii_regaddr = reg;\n\ttl_mii_readreg(sc, &frame);\n\n\t/* Reenable MII interrupts, just in case. */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\n\treturn(frame.mii_data);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint tl_attach_phy;\nvoid tl_init;\nint tl_ifmedia_upd;\nvoid tl_ifmedia_sts;\nu_int16_t tl_phy_readreg;\nvoid tl_autoneg;\n\nint tl_attach_phy(sc)\n\tstruct tl_softc\t\t*sc;\n{\n\tint\t\t\tphy_ctl;\n\tint\t\t\tmedia = IFM_ETHER|IFM_100_TX|IFM_FDX;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tsc->tl_phy_did = tl_phy_readreg(sc, TL_PHY_DEVID);\n\tsc->tl_phy_vid = tl_phy_readreg(sc, TL_PHY_VENID);\n\tsc->tl_phy_sts = tl_phy_readreg(sc, TL_PHY_GENSTS);\n\tphy_ctl = tl_phy_readreg(sc, TL_PHY_GENCTL);\n\n\tif (sc->tl_phy_sts & PHY_BMSR_100BT4 ||\n\t\tsc->tl_phy_sts & PHY_BMSR_100BTXFULL ||\n\t\tsc->tl_phy_sts & PHY_BMSR_100BTXHALF) \n\t\tifp->if_baudrate = 100000000;\n\telse\n\t\tifp->if_baudrate = 10000000;\n\n\tif (sc->tl_phy_sts & PHY_BMSR_100BT4 ||\n\t\tsc->tl_phy_sts & PHY_BMSR_100BTXHALF ||\n\t\tsc->tl_phy_sts & PHY_BMSR_100BTXHALF) {\n\t} else {\n\t\tmedia &= ~IFM_100_TX;\n\t\tmedia |= IFM_10_T;\n\t}\n\n\tif (sc->tl_phy_sts & PHY_BMSR_100BTXFULL ||\n\t\tsc->tl_phy_sts & PHY_BMSR_10BTFULL) {\n\t} else {\n\t\tmedia &= ~IFM_FDX;\n\t}\n\n\tif (sc->tl_phy_sts & PHY_BMSR_CANAUTONEG) {\n\t\tmedia = IFM_ETHER|IFM_AUTO;\n\t}\n\n\t/* Set up ifmedia data and callbacks. */\n\tifmedia_init(&sc->ifmedia, 0, tl_ifmedia_upd, tl_ifmedia_sts);\n\n\t/*\n\t * All ThunderLANs support at least 10baseT half duplex.\n\t * They also support AUI selection if used in 10Mb/s modes.\n\t */\n\tifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_10_T|IFM_HDX, 0, NULL);\n\tifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_10_T, 0, NULL);\n\tifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_10_5, 0, NULL);\n\n\t/* Some ThunderLAN PHYs support autonegotiation. */\n\tif (sc->tl_phy_sts & PHY_BMSR_CANAUTONEG)\n\t\tifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_AUTO, 0, NULL);\n\n\t/* Some support 10baseT full duplex. */\n\tif (sc->tl_phy_sts & PHY_BMSR_10BTFULL)\n\t\tifmedia_add(&sc->ifmedia,\n\t\t\tIFM_ETHER|IFM_10_T|IFM_FDX, 0, NULL);\n\n\t/* Some support 100BaseTX half duplex. */\n\tif (sc->tl_phy_sts & PHY_BMSR_100BTXHALF)\n\t\tifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_100_TX, 0, NULL);\n\tif (sc->tl_phy_sts & PHY_BMSR_100BTXHALF)\n\t\tifmedia_add(&sc->ifmedia,\n\t\t\tIFM_ETHER|IFM_100_TX|IFM_HDX, 0, NULL);\n\n\t/* Some support 100BaseTX full duplex. */\n\tif (sc->tl_phy_sts & PHY_BMSR_100BTXFULL)\n\t\tifmedia_add(&sc->ifmedia,\n\t\t\tIFM_ETHER|IFM_100_TX|IFM_FDX, 0, NULL);\n\n\t/* Some also support 100BaseT4. */\n\tif (sc->tl_phy_sts & PHY_BMSR_100BT4)\n\t\tifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_100_T4, 0, NULL);\n\n\t/* Set default media. */\n\tifmedia_set(&sc->ifmedia, media);\n\n\t/*\n\t * Kick off an autonegotiation session if this PHY supports it.\n\t * This is necessary to make sure the chip's duplex mode matches\n\t * the PHY's duplex mode. It may not: once enabled, the PHY may\n\t * autonegotiate full-duplex mode with its link partner, but the\n\t * ThunderLAN chip defaults to half-duplex and stays there unless\n\t * told otherwise.\n\t */\n\tif (sc->tl_phy_sts & PHY_BMSR_CANAUTONEG) {\n\t\ttl_init(sc);\n#ifdef TL_BACKGROUND_AUTONEG\n\t\ttl_autoneg(sc, TL_FLAG_SCHEDDELAY, 1);\n#else\n\t\ttl_autoneg(sc, TL_FLAG_FORCEDELAY, 1);\n#endif\n\t}\n\n\treturn(0);\n}"
  },
  {
    "function_name": "tl_softreset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
    "lines": "1208-1276",
    "snippet": "void tl_softreset(sc, internal)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\tinternal;\n{\n        u_int32_t               cmd, dummy, i;\n\n        /* Assert the adapter reset bit. */\n\tCMD_SET(sc, TL_CMD_ADRST);\n        /* Turn off interrupts */\n\tCMD_SET(sc, TL_CMD_INTSOFF);\n\n\t/* First, clear the stats registers. */\n\tfor (i = 0; i < 5; i++)\n\t\tdummy = tl_dio_read32(sc, TL_TXGOODFRAMES);\n\n        /* Clear Areg and Hash registers */\n\tfor (i = 0; i < 8; i++)\n\t\ttl_dio_write32(sc, TL_AREG0_B5, 0x00000000);\n\n        /*\n\t * Set up Netconfig register. Enable one channel and\n\t * one fragment mode.\n\t */\n\ttl_dio_setbit16(sc, TL_NETCONFIG, TL_CFG_ONECHAN|TL_CFG_ONEFRAG);\n\tif (internal && !sc->tl_bitrate) {\n\t\ttl_dio_setbit16(sc, TL_NETCONFIG, TL_CFG_PHYEN);\n\t} else {\n\t\ttl_dio_clrbit16(sc, TL_NETCONFIG, TL_CFG_PHYEN);\n\t}\n\n\t/* Handle cards with bitrate devices. */\n\tif (sc->tl_bitrate)\n\t\ttl_dio_setbit16(sc, TL_NETCONFIG, TL_CFG_BITRATE);\n\n        /* Set PCI burst size */\n\ttl_dio_write8(sc, TL_BSIZEREG, 0x33);\n\n\t/*\n\t * Load adapter irq pacing timer and tx threshold.\n\t * We make the transmit threshold 1 initially but we may\n\t * change that later.\n\t */\n\tcmd = CSR_READ_4(sc, TL_HOSTCMD);\n\tcmd |= TL_CMD_NES;\n\tcmd &= ~(TL_CMD_RT|TL_CMD_EOC|TL_CMD_ACK_MASK|TL_CMD_CHSEL_MASK);\n\tCMD_PUT(sc, cmd | (TL_CMD_LDTHR | TX_THR));\n\tCMD_PUT(sc, cmd | (TL_CMD_LDTMR | 0x00000003));\n\n        /* Unreset the MII */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_NMRST);\n\n\t/* Clear status register */\n        tl_dio_setbit16(sc, TL_NETSTS, TL_STS_MIRQ);\n        tl_dio_setbit16(sc, TL_NETSTS, TL_STS_HBEAT);\n        tl_dio_setbit16(sc, TL_NETSTS, TL_STS_TXSTOP);\n        tl_dio_setbit16(sc, TL_NETSTS, TL_STS_RXSTOP);\n\n\t/* Enable network status interrupts for everything. */\n\ttl_dio_setbit(sc, TL_NETMASK, TL_MASK_MASK7|TL_MASK_MASK6|\n\t\t\tTL_MASK_MASK5|TL_MASK_MASK4);\n\n\t/* Take the adapter out of reset */\n\ttl_dio_setbit(sc, TL_NETCMD, TL_CMD_NRESET|TL_CMD_NWRAP);\n\n\t/* Wait for things to settle down a little. */\n\tDELAY(500);\n\n        return;\n}",
    "includes": [
      "#include <dev/pci/if_tlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void tl_softreset",
      "u_int32_t tl_dio_read32",
      "void tl_dio_write8",
      "void tl_dio_write32",
      "void tl_dio_setbit",
      "void tl_dio_setbit16",
      "void tl_dio_clrbit16"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "500"
          ],
          "line": 1273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tl_dio_setbit",
          "args": [
            "sc",
            "TL_NETCMD",
            "TL_CMD_NRESET|TL_CMD_NWRAP"
          ],
          "line": 1270
        },
        "resolved": true,
        "details": {
          "function_name": "tl_dio_setbit16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "374-387",
          "snippet": "void tl_dio_setbit16(sc, reg, bit)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tbit;\n{\n\tu_int16_t\t\t\tf;\n\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tf = CSR_READ_2(sc, TL_DIO_DATA + (reg & 3));\n\tf |= bit;\n\tCSR_WRITE_2(sc, TL_DIO_DATA + (reg & 3), f);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void tl_dio_setbit16"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_dio_setbit16;\n\nvoid tl_dio_setbit16(sc, reg, bit)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tbit;\n{\n\tu_int16_t\t\t\tf;\n\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tf = CSR_READ_2(sc, TL_DIO_DATA + (reg & 3));\n\tf |= bit;\n\tCSR_WRITE_2(sc, TL_DIO_DATA + (reg & 3), f);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CMD_PUT",
          "args": [
            "sc",
            "cmd | (TL_CMD_LDTMR | 0x00000003)"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CMD_PUT",
          "args": [
            "sc",
            "cmd | (TL_CMD_LDTHR | TX_THR)"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "TL_HOSTCMD"
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tl_dio_write8",
          "args": [
            "sc",
            "TL_BSIZEREG",
            "0x33"
          ],
          "line": 1243
        },
        "resolved": true,
        "details": {
          "function_name": "tl_dio_write8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "314-322",
          "snippet": "void tl_dio_write8(sc, reg, val)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tval;\n{\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tCSR_WRITE_1(sc, TL_DIO_DATA + (reg & 3), val);\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void tl_dio_write8"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_dio_write8;\n\nvoid tl_dio_write8(sc, reg, val)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tval;\n{\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tCSR_WRITE_1(sc, TL_DIO_DATA + (reg & 3), val);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tl_dio_clrbit16",
          "args": [
            "sc",
            "TL_NETCONFIG",
            "TL_CFG_PHYEN"
          ],
          "line": 1235
        },
        "resolved": true,
        "details": {
          "function_name": "tl_dio_clrbit16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "389-402",
          "snippet": "void tl_dio_clrbit16(sc, reg, bit)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tbit;\n{\n\tu_int16_t\t\t\tf;\n\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tf = CSR_READ_2(sc, TL_DIO_DATA + (reg & 3));\n\tf &= ~bit;\n\tCSR_WRITE_2(sc, TL_DIO_DATA + (reg & 3), f);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void tl_dio_clrbit16"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_dio_clrbit16;\n\nvoid tl_dio_clrbit16(sc, reg, bit)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tbit;\n{\n\tu_int16_t\t\t\tf;\n\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tf = CSR_READ_2(sc, TL_DIO_DATA + (reg & 3));\n\tf &= ~bit;\n\tCSR_WRITE_2(sc, TL_DIO_DATA + (reg & 3), f);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tl_dio_write32",
          "args": [
            "sc",
            "TL_AREG0_B5",
            "0x00000000"
          ],
          "line": 1225
        },
        "resolved": true,
        "details": {
          "function_name": "tl_dio_write32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "334-342",
          "snippet": "void tl_dio_write32(sc, reg, val)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tval;\n{\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tCSR_WRITE_4(sc, TL_DIO_DATA + (reg & 3), val);\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void tl_dio_write32"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_dio_write32;\n\nvoid tl_dio_write32(sc, reg, val)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tval;\n{\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tCSR_WRITE_4(sc, TL_DIO_DATA + (reg & 3), val);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tl_dio_read32",
          "args": [
            "sc",
            "TL_TXGOODFRAMES"
          ],
          "line": 1221
        },
        "resolved": true,
        "details": {
          "function_name": "tl_dio_read32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "306-312",
          "snippet": "u_int32_t tl_dio_read32(sc, reg)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\treturn(CSR_READ_4(sc, TL_DIO_DATA + (reg & 3)));\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "u_int32_t tl_dio_read32"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int32_t tl_dio_read32;\n\nu_int32_t tl_dio_read32(sc, reg)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\treturn(CSR_READ_4(sc, TL_DIO_DATA + (reg & 3)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "CMD_SET",
          "args": [
            "sc",
            "TL_CMD_INTSOFF"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CMD_SET",
          "args": [
            "sc",
            "TL_CMD_ADRST"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_softreset;\nu_int32_t tl_dio_read32;\nvoid tl_dio_write8;\nvoid tl_dio_write32;\nvoid tl_dio_setbit;\nvoid tl_dio_setbit16;\nvoid tl_dio_clrbit16;\n\nvoid tl_softreset(sc, internal)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\tinternal;\n{\n        u_int32_t               cmd, dummy, i;\n\n        /* Assert the adapter reset bit. */\n\tCMD_SET(sc, TL_CMD_ADRST);\n        /* Turn off interrupts */\n\tCMD_SET(sc, TL_CMD_INTSOFF);\n\n\t/* First, clear the stats registers. */\n\tfor (i = 0; i < 5; i++)\n\t\tdummy = tl_dio_read32(sc, TL_TXGOODFRAMES);\n\n        /* Clear Areg and Hash registers */\n\tfor (i = 0; i < 8; i++)\n\t\ttl_dio_write32(sc, TL_AREG0_B5, 0x00000000);\n\n        /*\n\t * Set up Netconfig register. Enable one channel and\n\t * one fragment mode.\n\t */\n\ttl_dio_setbit16(sc, TL_NETCONFIG, TL_CFG_ONECHAN|TL_CFG_ONEFRAG);\n\tif (internal && !sc->tl_bitrate) {\n\t\ttl_dio_setbit16(sc, TL_NETCONFIG, TL_CFG_PHYEN);\n\t} else {\n\t\ttl_dio_clrbit16(sc, TL_NETCONFIG, TL_CFG_PHYEN);\n\t}\n\n\t/* Handle cards with bitrate devices. */\n\tif (sc->tl_bitrate)\n\t\ttl_dio_setbit16(sc, TL_NETCONFIG, TL_CFG_BITRATE);\n\n        /* Set PCI burst size */\n\ttl_dio_write8(sc, TL_BSIZEREG, 0x33);\n\n\t/*\n\t * Load adapter irq pacing timer and tx threshold.\n\t * We make the transmit threshold 1 initially but we may\n\t * change that later.\n\t */\n\tcmd = CSR_READ_4(sc, TL_HOSTCMD);\n\tcmd |= TL_CMD_NES;\n\tcmd &= ~(TL_CMD_RT|TL_CMD_EOC|TL_CMD_ACK_MASK|TL_CMD_CHSEL_MASK);\n\tCMD_PUT(sc, cmd | (TL_CMD_LDTHR | TX_THR));\n\tCMD_PUT(sc, cmd | (TL_CMD_LDTMR | 0x00000003));\n\n        /* Unreset the MII */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_NMRST);\n\n\t/* Clear status register */\n        tl_dio_setbit16(sc, TL_NETSTS, TL_STS_MIRQ);\n        tl_dio_setbit16(sc, TL_NETSTS, TL_STS_HBEAT);\n        tl_dio_setbit16(sc, TL_NETSTS, TL_STS_TXSTOP);\n        tl_dio_setbit16(sc, TL_NETSTS, TL_STS_RXSTOP);\n\n\t/* Enable network status interrupts for everything. */\n\ttl_dio_setbit(sc, TL_NETMASK, TL_MASK_MASK7|TL_MASK_MASK6|\n\t\t\tTL_MASK_MASK5|TL_MASK_MASK4);\n\n\t/* Take the adapter out of reset */\n\ttl_dio_setbit(sc, TL_NETCMD, TL_CMD_NRESET|TL_CMD_NWRAP);\n\n\t/* Wait for things to settle down a little. */\n\tDELAY(500);\n\n        return;\n}"
  },
  {
    "function_name": "tl_hardreset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
    "lines": "1172-1206",
    "snippet": "void tl_hardreset(sc)\n\tstruct tl_softc\t\t*sc;\n{\n\tint\t\t\ti;\n\tu_int16_t\t\told_addr, flags;\n\n\told_addr = sc->tl_phy_addr;\n\n\tfor (i = 0; i < TL_PHYADDR_MAX + 1; i++) {\n\t\tsc->tl_phy_addr = i;\n\t\ttl_mii_sync(sc);\n\t}\n\n\tflags = PHY_BMCR_LOOPBK|PHY_BMCR_ISOLATE|PHY_BMCR_PWRDOWN;\n\n\tfor (i = 0; i < TL_PHYADDR_MAX + 1; i++) {\n\t\tsc->tl_phy_addr = i;\n\t\ttl_phy_writereg(sc, PHY_BMCR, flags);\n\t}\n\n\tsc->tl_phy_addr = TL_PHYADDR_MAX;\n\ttl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_ISOLATE);\n\n\tDELAY(50000);\n\n\ttl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_LOOPBK|PHY_BMCR_ISOLATE);\n\n\ttl_mii_sync(sc);\n\n\twhile(tl_phy_readreg(sc, PHY_BMCR) & PHY_BMCR_RESET);\n\n\tsc->tl_phy_addr = old_addr;\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/if_tlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void tl_mii_sync",
      "u_int16_t tl_phy_readreg",
      "void tl_phy_writereg",
      "void tl_hardreset"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tl_phy_readreg",
          "args": [
            "sc",
            "PHY_BMCR"
          ],
          "line": 1201
        },
        "resolved": true,
        "details": {
          "function_name": "tl_phy_readreg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "722-738",
          "snippet": "u_int16_t tl_phy_readreg(sc, reg)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tstruct tl_mii_frame\tframe;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = sc->tl_phy_addr;\n\tframe.mii_regaddr = reg;\n\ttl_mii_readreg(sc, &frame);\n\n\t/* Reenable MII interrupts, just in case. */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\n\treturn(frame.mii_data);\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int tl_mii_readreg",
            "u_int16_t tl_phy_readreg",
            "void tl_dio_setbit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint tl_mii_readreg;\nu_int16_t tl_phy_readreg;\nvoid tl_dio_setbit;\n\nu_int16_t tl_phy_readreg(sc, reg)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tstruct tl_mii_frame\tframe;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = sc->tl_phy_addr;\n\tframe.mii_regaddr = reg;\n\ttl_mii_readreg(sc, &frame);\n\n\t/* Reenable MII interrupts, just in case. */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\n\treturn(frame.mii_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tl_mii_sync",
          "args": [
            "sc"
          ],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "tl_mii_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "538-551",
          "snippet": "void tl_mii_sync(sc)\n\tstruct tl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MTXEN);\n\n\tfor (i = 0; i < 32; i++) {\n\t\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\t\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void tl_mii_sync",
            "void tl_dio_setbit",
            "void tl_dio_clrbit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_mii_sync;\nvoid tl_dio_setbit;\nvoid tl_dio_clrbit;\n\nvoid tl_mii_sync(sc)\n\tstruct tl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MTXEN);\n\n\tfor (i = 0; i < 32; i++) {\n\t\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\t\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\t}\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tl_phy_writereg",
          "args": [
            "sc",
            "PHY_BMCR",
            "PHY_BMCR_LOOPBK|PHY_BMCR_ISOLATE"
          ],
          "line": 1197
        },
        "resolved": true,
        "details": {
          "function_name": "tl_phy_writereg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "740-759",
          "snippet": "void tl_phy_writereg(sc, reg, data)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tdata;\n{\n\tstruct tl_mii_frame\tframe;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = sc->tl_phy_addr;\n\tframe.mii_regaddr = reg;\n\tframe.mii_data = data;\n\n\ttl_mii_writereg(sc, &frame);\n\n\t/* Reenable MII interrupts, just in case. */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int tl_mii_writereg",
            "void tl_phy_writereg",
            "void tl_dio_setbit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint tl_mii_writereg;\nvoid tl_phy_writereg;\nvoid tl_dio_setbit;\n\nvoid tl_phy_writereg(sc, reg, data)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tdata;\n{\n\tstruct tl_mii_frame\tframe;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = sc->tl_phy_addr;\n\tframe.mii_regaddr = reg;\n\tframe.mii_data = data;\n\n\ttl_mii_writereg(sc, &frame);\n\n\t/* Reenable MII interrupts, just in case. */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "50000"
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_mii_sync;\nu_int16_t tl_phy_readreg;\nvoid tl_phy_writereg;\nvoid tl_hardreset;\n\nvoid tl_hardreset(sc)\n\tstruct tl_softc\t\t*sc;\n{\n\tint\t\t\ti;\n\tu_int16_t\t\told_addr, flags;\n\n\told_addr = sc->tl_phy_addr;\n\n\tfor (i = 0; i < TL_PHYADDR_MAX + 1; i++) {\n\t\tsc->tl_phy_addr = i;\n\t\ttl_mii_sync(sc);\n\t}\n\n\tflags = PHY_BMCR_LOOPBK|PHY_BMCR_ISOLATE|PHY_BMCR_PWRDOWN;\n\n\tfor (i = 0; i < TL_PHYADDR_MAX + 1; i++) {\n\t\tsc->tl_phy_addr = i;\n\t\ttl_phy_writereg(sc, PHY_BMCR, flags);\n\t}\n\n\tsc->tl_phy_addr = TL_PHYADDR_MAX;\n\ttl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_ISOLATE);\n\n\tDELAY(50000);\n\n\ttl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_LOOPBK|PHY_BMCR_ISOLATE);\n\n\ttl_mii_sync(sc);\n\n\twhile(tl_phy_readreg(sc, PHY_BMCR) & PHY_BMCR_RESET);\n\n\tsc->tl_phy_addr = old_addr;\n\n\treturn;\n}"
  },
  {
    "function_name": "tl_setmulti",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
    "lines": "1118-1164",
    "snippet": "void tl_setmulti(sc)\n\tstruct tl_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tu_int32_t\t\thashes[2] = { 0, 0 };\n\tint\t\t\th, i;\n\tstruct arpcom *ac = &sc->arpcom;\n\tstruct ether_multistep step;\n\tstruct ether_multi *enm;\n\tu_int8_t\t\tdummy[] = { 0, 0, 0, 0, 0 ,0 };\n\tifp = &sc->arpcom.ac_if;\n\n\t/* First, zot all the existing filters. */\n\tfor (i = 1; i < 4; i++)\n\t\ttl_setfilt(sc, (caddr_t)&dummy, i);\n\ttl_dio_write32(sc, TL_HASH1, 0);\n\ttl_dio_write32(sc, TL_HASH2, 0);\n\n\t/* Now program new ones. */\n\tif (ifp->if_flags & IFF_ALLMULTI) {\n\t\thashes[0] = 0xFFFFFFFF;\n\t\thashes[1] = 0xFFFFFFFF;\n\t} else {\n\t\ti = 1;\n\t\tETHER_FIRST_MULTI(step, ac, enm);\n\t\twhile (enm != NULL) {\n\t\t\tif (i < 4) {\n\t\t\t\ttl_setfilt(sc, enm->enm_addrlo, i);\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\th = tl_calchash(enm->enm_addrlo);\n\t\t\tif (h < 32)\n\t\t\t\thashes[0] |= (1 << h);\n\t\t\telse\n\t\t\t\thashes[1] |= (1 << (h - 32));\n\t\t\t\t\n\t\t\tETHER_NEXT_MULTI(step, enm);\n\t\t}\n\t}\n\n\ttl_dio_write32(sc, TL_HASH1, hashes[0]);\n\ttl_dio_write32(sc, TL_HASH2, hashes[1]);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/if_tlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int tl_calchash",
      "void tl_setmulti",
      "void tl_setfilt",
      "void tl_dio_write32"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tl_dio_write32",
          "args": [
            "sc",
            "TL_HASH2",
            "hashes[1]"
          ],
          "line": 1161
        },
        "resolved": true,
        "details": {
          "function_name": "tl_dio_write32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "334-342",
          "snippet": "void tl_dio_write32(sc, reg, val)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tval;\n{\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tCSR_WRITE_4(sc, TL_DIO_DATA + (reg & 3), val);\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void tl_dio_write32"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_dio_write32;\n\nvoid tl_dio_write32(sc, reg, val)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tval;\n{\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tCSR_WRITE_4(sc, TL_DIO_DATA + (reg & 3), val);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ETHER_NEXT_MULTI",
          "args": [
            "step",
            "enm"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tl_calchash",
          "args": [
            "enm->enm_addrlo"
          ],
          "line": 1150
        },
        "resolved": true,
        "details": {
          "function_name": "tl_calchash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "1069-1077",
          "snippet": "int tl_calchash(addr)\n\tcaddr_t\t\t\taddr;\n{\n\tint\t\t\tt;\n\n\tt = (addr[0] ^ addr[3]) << 16 | (addr[1] ^ addr[4]) << 8 |\n\t\t(addr[2] ^ addr[5]);\n\treturn ((t >> 18) ^ (t >> 12) ^ (t >> 6) ^ t) & 0x3f;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int tl_calchash"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint tl_calchash;\n\nint tl_calchash(addr)\n\tcaddr_t\t\t\taddr;\n{\n\tint\t\t\tt;\n\n\tt = (addr[0] ^ addr[3]) << 16 | (addr[1] ^ addr[4]) << 8 |\n\t\t(addr[2] ^ addr[5]);\n\treturn ((t >> 18) ^ (t >> 12) ^ (t >> 6) ^ t) & 0x3f;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tl_setfilt",
          "args": [
            "sc",
            "enm->enm_addrlo",
            "i"
          ],
          "line": 1145
        },
        "resolved": true,
        "details": {
          "function_name": "tl_setfilt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "1086-1100",
          "snippet": "void tl_setfilt(sc, addr, slot)\n\tstruct tl_softc\t\t*sc;\n\tcaddr_t\t\t\taddr;\n\tint\t\t\tslot;\n{\n\tint\t\t\ti;\n\tu_int16_t\t\tregaddr;\n\n\tregaddr = TL_AREG0_B5 + (slot * ETHER_ADDR_LEN);\n\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++)\n\t\ttl_dio_write8(sc, regaddr + i, *(addr + i));\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void tl_setfilt",
            "void tl_dio_write8"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_setfilt;\nvoid tl_dio_write8;\n\nvoid tl_setfilt(sc, addr, slot)\n\tstruct tl_softc\t\t*sc;\n\tcaddr_t\t\t\taddr;\n\tint\t\t\tslot;\n{\n\tint\t\t\ti;\n\tu_int16_t\t\tregaddr;\n\n\tregaddr = TL_AREG0_B5 + (slot * ETHER_ADDR_LEN);\n\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++)\n\t\ttl_dio_write8(sc, regaddr + i, *(addr + i));\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ETHER_FIRST_MULTI",
          "args": [
            "step",
            "ac",
            "enm"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint tl_calchash;\nvoid tl_setmulti;\nvoid tl_setfilt;\nvoid tl_dio_write32;\n\nvoid tl_setmulti(sc)\n\tstruct tl_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tu_int32_t\t\thashes[2] = { 0, 0 };\n\tint\t\t\th, i;\n\tstruct arpcom *ac = &sc->arpcom;\n\tstruct ether_multistep step;\n\tstruct ether_multi *enm;\n\tu_int8_t\t\tdummy[] = { 0, 0, 0, 0, 0 ,0 };\n\tifp = &sc->arpcom.ac_if;\n\n\t/* First, zot all the existing filters. */\n\tfor (i = 1; i < 4; i++)\n\t\ttl_setfilt(sc, (caddr_t)&dummy, i);\n\ttl_dio_write32(sc, TL_HASH1, 0);\n\ttl_dio_write32(sc, TL_HASH2, 0);\n\n\t/* Now program new ones. */\n\tif (ifp->if_flags & IFF_ALLMULTI) {\n\t\thashes[0] = 0xFFFFFFFF;\n\t\thashes[1] = 0xFFFFFFFF;\n\t} else {\n\t\ti = 1;\n\t\tETHER_FIRST_MULTI(step, ac, enm);\n\t\twhile (enm != NULL) {\n\t\t\tif (i < 4) {\n\t\t\t\ttl_setfilt(sc, enm->enm_addrlo, i);\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\th = tl_calchash(enm->enm_addrlo);\n\t\t\tif (h < 32)\n\t\t\t\thashes[0] |= (1 << h);\n\t\t\telse\n\t\t\t\thashes[1] |= (1 << (h - 32));\n\t\t\t\t\n\t\t\tETHER_NEXT_MULTI(step, enm);\n\t\t}\n\t}\n\n\ttl_dio_write32(sc, TL_HASH1, hashes[0]);\n\ttl_dio_write32(sc, TL_HASH2, hashes[1]);\n\n\treturn;\n}"
  },
  {
    "function_name": "tl_setfilt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
    "lines": "1086-1100",
    "snippet": "void tl_setfilt(sc, addr, slot)\n\tstruct tl_softc\t\t*sc;\n\tcaddr_t\t\t\taddr;\n\tint\t\t\tslot;\n{\n\tint\t\t\ti;\n\tu_int16_t\t\tregaddr;\n\n\tregaddr = TL_AREG0_B5 + (slot * ETHER_ADDR_LEN);\n\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++)\n\t\ttl_dio_write8(sc, regaddr + i, *(addr + i));\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/if_tlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void tl_setfilt",
      "void tl_dio_write8"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tl_dio_write8",
          "args": [
            "sc",
            "regaddr + i",
            "*(addr + i)"
          ],
          "line": 1097
        },
        "resolved": true,
        "details": {
          "function_name": "tl_dio_write8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "314-322",
          "snippet": "void tl_dio_write8(sc, reg, val)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tval;\n{\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tCSR_WRITE_1(sc, TL_DIO_DATA + (reg & 3), val);\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void tl_dio_write8"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_dio_write8;\n\nvoid tl_dio_write8(sc, reg, val)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tval;\n{\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tCSR_WRITE_1(sc, TL_DIO_DATA + (reg & 3), val);\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_setfilt;\nvoid tl_dio_write8;\n\nvoid tl_setfilt(sc, addr, slot)\n\tstruct tl_softc\t\t*sc;\n\tcaddr_t\t\t\taddr;\n\tint\t\t\tslot;\n{\n\tint\t\t\ti;\n\tu_int16_t\t\tregaddr;\n\n\tregaddr = TL_AREG0_B5 + (slot * ETHER_ADDR_LEN);\n\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++)\n\t\ttl_dio_write8(sc, regaddr + i, *(addr + i));\n\n\treturn;\n}"
  },
  {
    "function_name": "tl_calchash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
    "lines": "1069-1077",
    "snippet": "int tl_calchash(addr)\n\tcaddr_t\t\t\taddr;\n{\n\tint\t\t\tt;\n\n\tt = (addr[0] ^ addr[3]) << 16 | (addr[1] ^ addr[4]) << 8 |\n\t\t(addr[2] ^ addr[5]);\n\treturn ((t >> 18) ^ (t >> 12) ^ (t >> 6) ^ t) & 0x3f;\n}",
    "includes": [
      "#include <dev/pci/if_tlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int tl_calchash"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint tl_calchash;\n\nint tl_calchash(addr)\n\tcaddr_t\t\t\taddr;\n{\n\tint\t\t\tt;\n\n\tt = (addr[0] ^ addr[3]) << 16 | (addr[1] ^ addr[4]) << 8 |\n\t\t(addr[2] ^ addr[5]);\n\treturn ((t >> 18) ^ (t >> 12) ^ (t >> 6) ^ t) & 0x3f;\n}"
  },
  {
    "function_name": "tl_setmode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
    "lines": "969-1058",
    "snippet": "void tl_setmode(sc, media)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\tmedia;\n{\n\tu_int16_t\t\tbmcr;\n\n\tif (sc->tl_bitrate) {\n\t\tif (IFM_SUBTYPE(media) == IFM_10_5)\n\t\t\ttl_dio_setbit(sc, TL_ACOMMIT, TL_AC_MTXD1);\n\t\tif (IFM_SUBTYPE(media) == IFM_10_T) {\n\t\t\ttl_dio_clrbit(sc, TL_ACOMMIT, TL_AC_MTXD1);\n\t\t\tif ((media & IFM_GMASK) == IFM_FDX) {\n\t\t\t\ttl_dio_clrbit(sc, TL_ACOMMIT, TL_AC_MTXD3);\n\t\t\t\ttl_dio_setbit(sc, TL_NETCMD, TL_CMD_DUPLEX);\n\t\t\t} else {\n\t\t\t\ttl_dio_setbit(sc, TL_ACOMMIT, TL_AC_MTXD3);\n\t\t\t\ttl_dio_clrbit(sc, TL_NETCMD, TL_CMD_DUPLEX);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\tbmcr = tl_phy_readreg(sc, PHY_BMCR);\n\n\tbmcr &= ~(PHY_BMCR_SPEEDSEL|PHY_BMCR_DUPLEX|PHY_BMCR_AUTONEGENBL|\n\t\t  PHY_BMCR_LOOPBK|PHY_BMCR_ISOLATE);\n\n\tif (IFM_SUBTYPE(media) == IFM_LOOP)\n\t\tbmcr |= PHY_BMCR_LOOPBK;\n\n\tif (IFM_SUBTYPE(media) == IFM_AUTO)\n\t\tbmcr |= PHY_BMCR_AUTONEGENBL;\n\n\t/*\n\t * The ThunderLAN's internal PHY has an AUI transceiver\n\t * that can be selected. This is usually attached to a\n\t * 10base2/BNC port. In order to activate this port, we\n\t * have to set the AUISEL bit in the internal PHY's\n\t * special control register.\n\t */\n\tif (IFM_SUBTYPE(media) == IFM_10_5) {\n\t\tu_int16_t\t\taddr, ctl;\n\t\taddr = sc->tl_phy_addr;\n\t\tsc->tl_phy_addr = TL_PHYADDR_MAX;\n\t\tctl = tl_phy_readreg(sc, TL_PHY_CTL);\n\t\tctl |= PHY_CTL_AUISEL;\n\t\ttl_phy_writereg(sc, TL_PHY_CTL, ctl);\n\t\ttl_phy_writereg(sc, PHY_BMCR, bmcr);\n\t\tsc->tl_phy_addr = addr;\n\t\tbmcr |= PHY_BMCR_ISOLATE;\n\t} else {\n\t\tu_int16_t\t\taddr, ctl;\n\t\taddr = sc->tl_phy_addr;\n\t\tsc->tl_phy_addr = TL_PHYADDR_MAX;\n\t\tctl = tl_phy_readreg(sc, TL_PHY_CTL);\n\t\tctl &= ~PHY_CTL_AUISEL;\n\t\ttl_phy_writereg(sc, TL_PHY_CTL, ctl);\n\t\ttl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_ISOLATE);\n\t\tsc->tl_phy_addr = addr;\n\t\tbmcr &= ~PHY_BMCR_ISOLATE;\n\t}\n\n\tif (IFM_SUBTYPE(media) == IFM_100_TX) {\n\t\tbmcr |= PHY_BMCR_SPEEDSEL;\n\t\tif ((media & IFM_GMASK) == IFM_FDX) {\n\t\t\tbmcr |= PHY_BMCR_DUPLEX;\n\t\t\ttl_dio_setbit(sc, TL_NETCMD, TL_CMD_DUPLEX);\n\t\t} else {\n\t\t\tbmcr &= ~PHY_BMCR_DUPLEX;\n\t\t\ttl_dio_clrbit(sc, TL_NETCMD, TL_CMD_DUPLEX);\n\t\t}\n\t}\n\n\tif (IFM_SUBTYPE(media) == IFM_10_T) {\n\t\tbmcr &= ~PHY_BMCR_SPEEDSEL;\n\t\tif ((media & IFM_GMASK) == IFM_FDX) {\n\t\t\tbmcr |= PHY_BMCR_DUPLEX;\n\t\t\ttl_dio_setbit(sc, TL_NETCMD, TL_CMD_DUPLEX);\n\t\t} else {\n\t\t\tbmcr &= ~PHY_BMCR_DUPLEX;\n\t\t\ttl_dio_clrbit(sc, TL_NETCMD, TL_CMD_DUPLEX);\n\t\t}\n\t}\n\n\ttl_phy_writereg(sc, PHY_BMCR, bmcr);\n\n\ttl_init(sc);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/if_tlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void tl_init",
      "u_int16_t tl_phy_readreg",
      "void tl_phy_writereg",
      "void tl_setmode",
      "void tl_dio_setbit",
      "void tl_dio_clrbit"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tl_init",
          "args": [
            "sc"
          ],
          "line": 1055
        },
        "resolved": true,
        "details": {
          "function_name": "tl_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "2052-2156",
          "snippet": "void tl_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct tl_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n        int\t\t\ts;\n\tu_int16_t\t\tphy_sts;\n\n\tif (sc->tl_autoneg)\n\t\treturn;\n\n\ts = splimp();\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/*\n\t * Cancel pending I/O.\n\t */\n\ttl_stop(sc);\n\n\t/*\n\t * Set 'capture all frames' bit for promiscuous mode.\n\t */\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\ttl_dio_setbit(sc, TL_NETCMD, TL_CMD_CAF);\n\telse\n\t\ttl_dio_clrbit(sc, TL_NETCMD, TL_CMD_CAF);\n\n\t/*\n\t * Set capture broadcast bit to capture broadcast frames.\n\t */\n\tif (ifp->if_flags & IFF_BROADCAST)\n\t\ttl_dio_clrbit(sc, TL_NETCMD, TL_CMD_NOBRX);\n\telse\n\t\ttl_dio_setbit(sc, TL_NETCMD, TL_CMD_NOBRX);\n\n\t/* Init our MAC address */\n\ttl_setfilt(sc, (caddr_t)&sc->arpcom.ac_enaddr, 0);\n\n\t/* Init multicast filter, if needed. */\n\ttl_setmulti(sc);\n\n\t/* Init circular RX list. */\n\tif (tl_list_rx_init(sc) == ENOBUFS) {\n\t\tprintf(\"tl%d: initialization failed: no \"\n\t\t\t\"memory for rx buffers\\n\", sc->tl_unit);\n\t\ttl_stop(sc);\n\t\treturn;\n\t}\n\n\t/* Init TX pointers. */\n\ttl_list_tx_init(sc);\n\n\t/*\n\t * Enable PHY interrupts.\n\t */\n\tphy_sts = tl_phy_readreg(sc, TL_PHY_CTL);\n\tphy_sts |= PHY_CTL_INTEN;\n\ttl_phy_writereg(sc, TL_PHY_CTL, phy_sts);\n\n\t/* Enable MII interrupts. */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\n\t/* Enable PCI interrupts. */\n\tCMD_SET(sc, TL_CMD_INTSON);\n\n\t/* Load the address of the rx list */\n\tCMD_SET(sc, TL_CMD_RT);\n\tCSR_WRITE_4(sc, TL_CH_PARM, vtophys(&sc->tl_ldata->tl_rx_list[0]));\n\n\t/*\n\t * XXX This is a kludge to handle adapters with the Micro Linear\n\t * ML6692 100BaseTX PHY, which only supports 100Mbps modes and\n\t * relies on the controller's internal 10Mbps PHY to provide\n\t * 10Mbps modes. The ML6692 always shows up with a vendor/device ID\n\t * of 0 (it doesn't actually have vendor/device ID registers)\n\t * so we use that property to detect it. In theory there ought to\n\t * be a better way to 'spot the looney' but I can't find one.\n         */\n        if (!sc->tl_phy_vid) {\n                u_int8_t                        addr = 0;\n                u_int16_t                       bmcr;\n\n                bmcr = tl_phy_readreg(sc, PHY_BMCR);\n                addr = sc->tl_phy_addr;\n                sc->tl_phy_addr = TL_PHYADDR_MAX;\n                tl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_RESET);\n                if (bmcr & PHY_BMCR_SPEEDSEL)\n                        tl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_ISOLATE);\n                else\n                        tl_phy_writereg(sc, PHY_BMCR, bmcr);\n                sc->tl_phy_addr = addr;\n        }\n\n\t/* Send the RX go command */\n\tCMD_SET(sc, TL_CMD_GO|TL_CMD_RT);\n\n\t(void)splx(s);\n\n\t/* Start the stats update counter */\n\ttimeout(tl_stats_update, sc, hz);\n\ttimeout(tl_wait_up, sc, 2 * hz);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void tl_wait_up",
            "void tl_stats_update",
            "void tl_init",
            "void tl_stop",
            "u_int16_t tl_phy_readreg",
            "void tl_phy_writereg",
            "void tl_autoneg",
            "void tl_setmulti",
            "void tl_setfilt",
            "int tl_list_rx_init",
            "int tl_list_tx_init",
            "void tl_dio_setbit",
            "void tl_dio_clrbit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_wait_up;\nvoid tl_stats_update;\nvoid tl_init;\nvoid tl_stop;\nu_int16_t tl_phy_readreg;\nvoid tl_phy_writereg;\nvoid tl_autoneg;\nvoid tl_setmulti;\nvoid tl_setfilt;\nint tl_list_rx_init;\nint tl_list_tx_init;\nvoid tl_dio_setbit;\nvoid tl_dio_clrbit;\n\nvoid tl_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct tl_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n        int\t\t\ts;\n\tu_int16_t\t\tphy_sts;\n\n\tif (sc->tl_autoneg)\n\t\treturn;\n\n\ts = splimp();\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/*\n\t * Cancel pending I/O.\n\t */\n\ttl_stop(sc);\n\n\t/*\n\t * Set 'capture all frames' bit for promiscuous mode.\n\t */\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\ttl_dio_setbit(sc, TL_NETCMD, TL_CMD_CAF);\n\telse\n\t\ttl_dio_clrbit(sc, TL_NETCMD, TL_CMD_CAF);\n\n\t/*\n\t * Set capture broadcast bit to capture broadcast frames.\n\t */\n\tif (ifp->if_flags & IFF_BROADCAST)\n\t\ttl_dio_clrbit(sc, TL_NETCMD, TL_CMD_NOBRX);\n\telse\n\t\ttl_dio_setbit(sc, TL_NETCMD, TL_CMD_NOBRX);\n\n\t/* Init our MAC address */\n\ttl_setfilt(sc, (caddr_t)&sc->arpcom.ac_enaddr, 0);\n\n\t/* Init multicast filter, if needed. */\n\ttl_setmulti(sc);\n\n\t/* Init circular RX list. */\n\tif (tl_list_rx_init(sc) == ENOBUFS) {\n\t\tprintf(\"tl%d: initialization failed: no \"\n\t\t\t\"memory for rx buffers\\n\", sc->tl_unit);\n\t\ttl_stop(sc);\n\t\treturn;\n\t}\n\n\t/* Init TX pointers. */\n\ttl_list_tx_init(sc);\n\n\t/*\n\t * Enable PHY interrupts.\n\t */\n\tphy_sts = tl_phy_readreg(sc, TL_PHY_CTL);\n\tphy_sts |= PHY_CTL_INTEN;\n\ttl_phy_writereg(sc, TL_PHY_CTL, phy_sts);\n\n\t/* Enable MII interrupts. */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\n\t/* Enable PCI interrupts. */\n\tCMD_SET(sc, TL_CMD_INTSON);\n\n\t/* Load the address of the rx list */\n\tCMD_SET(sc, TL_CMD_RT);\n\tCSR_WRITE_4(sc, TL_CH_PARM, vtophys(&sc->tl_ldata->tl_rx_list[0]));\n\n\t/*\n\t * XXX This is a kludge to handle adapters with the Micro Linear\n\t * ML6692 100BaseTX PHY, which only supports 100Mbps modes and\n\t * relies on the controller's internal 10Mbps PHY to provide\n\t * 10Mbps modes. The ML6692 always shows up with a vendor/device ID\n\t * of 0 (it doesn't actually have vendor/device ID registers)\n\t * so we use that property to detect it. In theory there ought to\n\t * be a better way to 'spot the looney' but I can't find one.\n         */\n        if (!sc->tl_phy_vid) {\n                u_int8_t                        addr = 0;\n                u_int16_t                       bmcr;\n\n                bmcr = tl_phy_readreg(sc, PHY_BMCR);\n                addr = sc->tl_phy_addr;\n                sc->tl_phy_addr = TL_PHYADDR_MAX;\n                tl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_RESET);\n                if (bmcr & PHY_BMCR_SPEEDSEL)\n                        tl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_ISOLATE);\n                else\n                        tl_phy_writereg(sc, PHY_BMCR, bmcr);\n                sc->tl_phy_addr = addr;\n        }\n\n\t/* Send the RX go command */\n\tCMD_SET(sc, TL_CMD_GO|TL_CMD_RT);\n\n\t(void)splx(s);\n\n\t/* Start the stats update counter */\n\ttimeout(tl_stats_update, sc, hz);\n\ttimeout(tl_wait_up, sc, 2 * hz);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tl_phy_writereg",
          "args": [
            "sc",
            "PHY_BMCR",
            "bmcr"
          ],
          "line": 1053
        },
        "resolved": true,
        "details": {
          "function_name": "tl_phy_writereg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "740-759",
          "snippet": "void tl_phy_writereg(sc, reg, data)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tdata;\n{\n\tstruct tl_mii_frame\tframe;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = sc->tl_phy_addr;\n\tframe.mii_regaddr = reg;\n\tframe.mii_data = data;\n\n\ttl_mii_writereg(sc, &frame);\n\n\t/* Reenable MII interrupts, just in case. */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int tl_mii_writereg",
            "void tl_phy_writereg",
            "void tl_dio_setbit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint tl_mii_writereg;\nvoid tl_phy_writereg;\nvoid tl_dio_setbit;\n\nvoid tl_phy_writereg(sc, reg, data)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tdata;\n{\n\tstruct tl_mii_frame\tframe;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = sc->tl_phy_addr;\n\tframe.mii_regaddr = reg;\n\tframe.mii_data = data;\n\n\ttl_mii_writereg(sc, &frame);\n\n\t/* Reenable MII interrupts, just in case. */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tl_dio_clrbit",
          "args": [
            "sc",
            "TL_NETCMD",
            "TL_CMD_DUPLEX"
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "tl_dio_clrbit16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "389-402",
          "snippet": "void tl_dio_clrbit16(sc, reg, bit)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tbit;\n{\n\tu_int16_t\t\t\tf;\n\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tf = CSR_READ_2(sc, TL_DIO_DATA + (reg & 3));\n\tf &= ~bit;\n\tCSR_WRITE_2(sc, TL_DIO_DATA + (reg & 3), f);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void tl_dio_clrbit16"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_dio_clrbit16;\n\nvoid tl_dio_clrbit16(sc, reg, bit)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tbit;\n{\n\tu_int16_t\t\t\tf;\n\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tf = CSR_READ_2(sc, TL_DIO_DATA + (reg & 3));\n\tf &= ~bit;\n\tCSR_WRITE_2(sc, TL_DIO_DATA + (reg & 3), f);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tl_dio_setbit",
          "args": [
            "sc",
            "TL_NETCMD",
            "TL_CMD_DUPLEX"
          ],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "tl_dio_setbit16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "374-387",
          "snippet": "void tl_dio_setbit16(sc, reg, bit)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tbit;\n{\n\tu_int16_t\t\t\tf;\n\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tf = CSR_READ_2(sc, TL_DIO_DATA + (reg & 3));\n\tf |= bit;\n\tCSR_WRITE_2(sc, TL_DIO_DATA + (reg & 3), f);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void tl_dio_setbit16"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_dio_setbit16;\n\nvoid tl_dio_setbit16(sc, reg, bit)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tbit;\n{\n\tu_int16_t\t\t\tf;\n\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tf = CSR_READ_2(sc, TL_DIO_DATA + (reg & 3));\n\tf |= bit;\n\tCSR_WRITE_2(sc, TL_DIO_DATA + (reg & 3), f);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IFM_SUBTYPE",
          "args": [
            "media"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFM_SUBTYPE",
          "args": [
            "media"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tl_phy_readreg",
          "args": [
            "sc",
            "TL_PHY_CTL"
          ],
          "line": 1023
        },
        "resolved": true,
        "details": {
          "function_name": "tl_phy_readreg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "722-738",
          "snippet": "u_int16_t tl_phy_readreg(sc, reg)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tstruct tl_mii_frame\tframe;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = sc->tl_phy_addr;\n\tframe.mii_regaddr = reg;\n\ttl_mii_readreg(sc, &frame);\n\n\t/* Reenable MII interrupts, just in case. */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\n\treturn(frame.mii_data);\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int tl_mii_readreg",
            "u_int16_t tl_phy_readreg",
            "void tl_dio_setbit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint tl_mii_readreg;\nu_int16_t tl_phy_readreg;\nvoid tl_dio_setbit;\n\nu_int16_t tl_phy_readreg(sc, reg)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tstruct tl_mii_frame\tframe;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = sc->tl_phy_addr;\n\tframe.mii_regaddr = reg;\n\ttl_mii_readreg(sc, &frame);\n\n\t/* Reenable MII interrupts, just in case. */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\n\treturn(frame.mii_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IFM_SUBTYPE",
          "args": [
            "media"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFM_SUBTYPE",
          "args": [
            "media"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFM_SUBTYPE",
          "args": [
            "media"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFM_SUBTYPE",
          "args": [
            "media"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFM_SUBTYPE",
          "args": [
            "media"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_init;\nu_int16_t tl_phy_readreg;\nvoid tl_phy_writereg;\nvoid tl_setmode;\nvoid tl_dio_setbit;\nvoid tl_dio_clrbit;\n\nvoid tl_setmode(sc, media)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\tmedia;\n{\n\tu_int16_t\t\tbmcr;\n\n\tif (sc->tl_bitrate) {\n\t\tif (IFM_SUBTYPE(media) == IFM_10_5)\n\t\t\ttl_dio_setbit(sc, TL_ACOMMIT, TL_AC_MTXD1);\n\t\tif (IFM_SUBTYPE(media) == IFM_10_T) {\n\t\t\ttl_dio_clrbit(sc, TL_ACOMMIT, TL_AC_MTXD1);\n\t\t\tif ((media & IFM_GMASK) == IFM_FDX) {\n\t\t\t\ttl_dio_clrbit(sc, TL_ACOMMIT, TL_AC_MTXD3);\n\t\t\t\ttl_dio_setbit(sc, TL_NETCMD, TL_CMD_DUPLEX);\n\t\t\t} else {\n\t\t\t\ttl_dio_setbit(sc, TL_ACOMMIT, TL_AC_MTXD3);\n\t\t\t\ttl_dio_clrbit(sc, TL_NETCMD, TL_CMD_DUPLEX);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\tbmcr = tl_phy_readreg(sc, PHY_BMCR);\n\n\tbmcr &= ~(PHY_BMCR_SPEEDSEL|PHY_BMCR_DUPLEX|PHY_BMCR_AUTONEGENBL|\n\t\t  PHY_BMCR_LOOPBK|PHY_BMCR_ISOLATE);\n\n\tif (IFM_SUBTYPE(media) == IFM_LOOP)\n\t\tbmcr |= PHY_BMCR_LOOPBK;\n\n\tif (IFM_SUBTYPE(media) == IFM_AUTO)\n\t\tbmcr |= PHY_BMCR_AUTONEGENBL;\n\n\t/*\n\t * The ThunderLAN's internal PHY has an AUI transceiver\n\t * that can be selected. This is usually attached to a\n\t * 10base2/BNC port. In order to activate this port, we\n\t * have to set the AUISEL bit in the internal PHY's\n\t * special control register.\n\t */\n\tif (IFM_SUBTYPE(media) == IFM_10_5) {\n\t\tu_int16_t\t\taddr, ctl;\n\t\taddr = sc->tl_phy_addr;\n\t\tsc->tl_phy_addr = TL_PHYADDR_MAX;\n\t\tctl = tl_phy_readreg(sc, TL_PHY_CTL);\n\t\tctl |= PHY_CTL_AUISEL;\n\t\ttl_phy_writereg(sc, TL_PHY_CTL, ctl);\n\t\ttl_phy_writereg(sc, PHY_BMCR, bmcr);\n\t\tsc->tl_phy_addr = addr;\n\t\tbmcr |= PHY_BMCR_ISOLATE;\n\t} else {\n\t\tu_int16_t\t\taddr, ctl;\n\t\taddr = sc->tl_phy_addr;\n\t\tsc->tl_phy_addr = TL_PHYADDR_MAX;\n\t\tctl = tl_phy_readreg(sc, TL_PHY_CTL);\n\t\tctl &= ~PHY_CTL_AUISEL;\n\t\ttl_phy_writereg(sc, TL_PHY_CTL, ctl);\n\t\ttl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_ISOLATE);\n\t\tsc->tl_phy_addr = addr;\n\t\tbmcr &= ~PHY_BMCR_ISOLATE;\n\t}\n\n\tif (IFM_SUBTYPE(media) == IFM_100_TX) {\n\t\tbmcr |= PHY_BMCR_SPEEDSEL;\n\t\tif ((media & IFM_GMASK) == IFM_FDX) {\n\t\t\tbmcr |= PHY_BMCR_DUPLEX;\n\t\t\ttl_dio_setbit(sc, TL_NETCMD, TL_CMD_DUPLEX);\n\t\t} else {\n\t\t\tbmcr &= ~PHY_BMCR_DUPLEX;\n\t\t\ttl_dio_clrbit(sc, TL_NETCMD, TL_CMD_DUPLEX);\n\t\t}\n\t}\n\n\tif (IFM_SUBTYPE(media) == IFM_10_T) {\n\t\tbmcr &= ~PHY_BMCR_SPEEDSEL;\n\t\tif ((media & IFM_GMASK) == IFM_FDX) {\n\t\t\tbmcr |= PHY_BMCR_DUPLEX;\n\t\t\ttl_dio_setbit(sc, TL_NETCMD, TL_CMD_DUPLEX);\n\t\t} else {\n\t\t\tbmcr &= ~PHY_BMCR_DUPLEX;\n\t\t\ttl_dio_clrbit(sc, TL_NETCMD, TL_CMD_DUPLEX);\n\t\t}\n\t}\n\n\ttl_phy_writereg(sc, PHY_BMCR, bmcr);\n\n\ttl_init(sc);\n\n\treturn;\n}"
  },
  {
    "function_name": "tl_autoneg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
    "lines": "808-963",
    "snippet": "void tl_autoneg(sc, flag, verbose)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\tflag;\n\tint\t\t\tverbose;\n{\n\tu_int16_t\t\tphy_sts = 0, media = 0, advert, ability;\n\tstruct ifnet\t\t*ifp;\n\tstruct ifmedia\t\t*ifm;\n\n\tifm = &sc->ifmedia;\n\tifp = &sc->arpcom.ac_if;\n\n\t/*\n\t * First, see if autoneg is supported. If not, there's\n\t * no point in continuing.\n\t */\n\tphy_sts = tl_phy_readreg(sc, PHY_BMSR);\n\tif (!(phy_sts & PHY_BMSR_CANAUTONEG)) {\n\t\tif (verbose)\n\t\t\tprintf(\"tl%d: autonegotiation not supported\\n\",\n\t\t\t\t\t\t\tsc->tl_unit);\n\t\treturn;\n\t}\n\n\tswitch (flag) {\n\tcase TL_FLAG_FORCEDELAY:\n\t\t/*\n\t \t * XXX Never use this option anywhere but in the probe\n\t \t * routine: making the kernel stop dead in its tracks\n \t\t * for three whole seconds after we've gone multi-user\n\t\t * is really bad manners.\n\t \t */\n\t\ttl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_RESET);\n\t\tDELAY(500);\n\t\tphy_sts = tl_phy_readreg(sc, PHY_BMCR);\n\t\tphy_sts |= PHY_BMCR_AUTONEGENBL|PHY_BMCR_AUTONEGRSTR;\n\t\ttl_phy_writereg(sc, PHY_BMCR, phy_sts);\n\t\tDELAY(5000000);\n\t\tbreak;\n\tcase TL_FLAG_SCHEDDELAY:\n\t\t/*\n\t\t * Wait for the transmitter to go idle before starting\n\t\t * an autoneg session, otherwise tl_start() may clobber\n\t \t * our timeout, and we don't want to allow transmission\n\t\t * during an autoneg session since that can screw it up.\n\t \t */\n\t\tif (!sc->tl_txeoc) {\n\t\t\tsc->tl_want_auto = 1;\n\t\t\treturn;\n\t\t}\n\t\ttl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_RESET);\n\t\tDELAY(500);\n\t\tphy_sts = tl_phy_readreg(sc, PHY_BMCR);\n\t\tphy_sts |= PHY_BMCR_AUTONEGENBL|PHY_BMCR_AUTONEGRSTR;\n\t\ttl_phy_writereg(sc, PHY_BMCR, phy_sts);\n\t\tifp->if_timer = 10;\n\t\tsc->tl_autoneg = 1;\n\t\tsc->tl_want_auto = 0;\n\t\treturn;\n\tcase TL_FLAG_DELAYTIMEO:\n\t\tifp->if_timer = 0;\n\t\tsc->tl_autoneg = 0;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"tl%d: invalid autoneg flag: %d\\n\", sc->tl_unit, flag);\n\t\treturn;\n\t}\n\n\t/*\n \t * Read the BMSR register twice: the LINKSTAT bit is a\n\t * latching bit.\n\t */\n\ttl_phy_readreg(sc, PHY_BMSR);\n\tphy_sts = tl_phy_readreg(sc, PHY_BMSR);\n\tif (phy_sts & PHY_BMSR_AUTONEGCOMP) {\n\t\tif (verbose)\n\t\t\tprintf(\"tl%d: autoneg complete, \", sc->tl_unit);\n\t\tphy_sts = tl_phy_readreg(sc, PHY_BMSR);\n\t} else {\n\t\tif (verbose)\n\t\t\tprintf(\"tl%d: autoneg not complete, \", sc->tl_unit);\n\t}\n\n\t/* Link is good. Report modes and set duplex mode. */\n\tif (phy_sts & PHY_BMSR_LINKSTAT) {\n\t\tif (verbose)\n\t\t\tprintf(\"link status good \");\n\n\t\tadvert = tl_phy_readreg(sc, TL_PHY_ANAR);\n\t\tability = tl_phy_readreg(sc, TL_PHY_LPAR);\n\t\tmedia = tl_phy_readreg(sc, PHY_BMCR);\n\n\t\t/*\n\t \t * Be sure to turn off the ISOLATE and\n\t\t * LOOPBACK bits in the control register,\n\t\t * otherwise we may not be able to communicate.\n\t\t */\n\t\tmedia &= ~(PHY_BMCR_LOOPBK|PHY_BMCR_ISOLATE);\n\t\t/* Set the DUPLEX bit in the NetCmd register accordingly. */\n\t\tif (advert & PHY_ANAR_100BT4 && ability & PHY_ANAR_100BT4) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_100_T4;\n\t\t\tmedia |= PHY_BMCR_SPEEDSEL;\n\t\t\tmedia &= ~PHY_BMCR_DUPLEX;\n\t\t\tif (verbose)\n\t\t\t\tprintf(\"(100baseT4)\\n\");\n\t\t} else if (advert & PHY_ANAR_100BTXFULL &&\n\t\t\tability & PHY_ANAR_100BTXFULL) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_100_TX|IFM_FDX;\n\t\t\tmedia |= PHY_BMCR_SPEEDSEL;\n\t\t\tmedia |= PHY_BMCR_DUPLEX;\n\t\t\tif (verbose)\n\t\t\t\tprintf(\"(full-duplex, 100Mbps)\\n\");\n\t\t} else if (advert & PHY_ANAR_100BTXHALF &&\n\t\t\tability & PHY_ANAR_100BTXHALF) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_100_TX|IFM_HDX;\n\t\t\tmedia |= PHY_BMCR_SPEEDSEL;\n\t\t\tmedia &= ~PHY_BMCR_DUPLEX;\n\t\t\tif (verbose)\n\t\t\t\tprintf(\"(half-duplex, 100Mbps)\\n\");\n\t\t} else if (advert & PHY_ANAR_10BTFULL &&\n\t\t\tability & PHY_ANAR_10BTFULL) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_10_T|IFM_FDX;\n\t\t\tmedia &= ~PHY_BMCR_SPEEDSEL;\n\t\t\tmedia |= PHY_BMCR_DUPLEX;\n\t\t\tif (verbose)\n\t\t\t\tprintf(\"(full-duplex, 10Mbps)\\n\");\n\t\t} else {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_10_T|IFM_HDX;\n\t\t\tmedia &= ~PHY_BMCR_SPEEDSEL;\n\t\t\tmedia &= ~PHY_BMCR_DUPLEX;\n\t\t\tif (verbose)\n\t\t\t\tprintf(\"(half-duplex, 10Mbps)\\n\");\n\t\t}\n\n\t\tif (media & PHY_BMCR_DUPLEX)\n\t\t\ttl_dio_setbit(sc, TL_NETCMD, TL_CMD_DUPLEX);\n\t\telse\n\t\t\ttl_dio_clrbit(sc, TL_NETCMD, TL_CMD_DUPLEX);\n\n\t\tmedia &= ~PHY_BMCR_AUTONEGENBL;\n\t\ttl_phy_writereg(sc, PHY_BMCR, media);\n\t} else {\n\t\tif (verbose)\n\t\t\tprintf(\"no carrier\\n\");\n\t}\n\n\ttl_init(sc);\n\n\tif (sc->tl_tx_pend) {\n\t\tsc->tl_autoneg = 0;\n\t\tsc->tl_tx_pend = 0;\n\t\ttl_start(ifp);\n\t}\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/if_tlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void tl_start",
      "void tl_init",
      "u_int16_t tl_phy_readreg",
      "void tl_phy_writereg",
      "void tl_autoneg",
      "void tl_dio_setbit",
      "void tl_dio_clrbit"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tl_start",
          "args": [
            "ifp"
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "tl_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "1957-2050",
          "snippet": "void tl_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct tl_softc\t\t*sc;\n\tstruct mbuf\t\t*m_head = NULL;\n\tu_int32_t\t\tcmd;\n\tstruct tl_chain\t\t*prev = NULL, *cur_tx = NULL, *start_tx;\n\n\tsc = ifp->if_softc;\n\n\tif (sc->tl_autoneg) {\n\t\tsc->tl_tx_pend = 1;\n\t\treturn;\n\t}\n\n\t/*\n\t * Check for an available queue slot. If there are none,\n\t * punt.\n\t */\n\tif (sc->tl_cdata.tl_tx_free == NULL) {\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t\treturn;\n\t}\n\n\tstart_tx = sc->tl_cdata.tl_tx_free;\n\n\twhile(sc->tl_cdata.tl_tx_free != NULL) {\n\t\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\t\tif (m_head == NULL)\n\t\t\tbreak;\n\n\t\t/* Pick a chain member off the free list. */\n\t\tcur_tx = sc->tl_cdata.tl_tx_free;\n\t\tsc->tl_cdata.tl_tx_free = cur_tx->tl_next;\n\n\t\tcur_tx->tl_next = NULL;\n\n\t\t/* Pack the data into the list. */\n\t\ttl_encap(sc, cur_tx, m_head);\n\n\t\t/* Chain it together */\n\t\tif (prev != NULL) {\n\t\t\tprev->tl_next = cur_tx;\n\t\t\tprev->tl_ptr->tlist_fptr = vtophys(cur_tx->tl_ptr);\n\t\t}\n\t\tprev = cur_tx;\n\n\t\t/*\n\t\t * If there's a BPF listener, bounce a copy of this frame\n\t\t * to him.\n\t\t */\n#if NBPFILTER > 0\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, cur_tx->tl_mbuf);\n#endif\n\t}\n\n\t/*\n\t * If there are no packets queued, bail.\n\t */\n\tif (cur_tx == NULL)\n\t\treturn;\n\n\t/*\n\t * That's all we can stands, we can't stands no more.\n\t * If there are no other transfers pending, then issue the\n\t * TX GO command to the adapter to start things moving.\n\t * Otherwise, just leave the data in the queue and let\n\t * the EOF/EOC interrupt handler send.\n\t */\n\tif (sc->tl_cdata.tl_tx_head == NULL) {\n\t\tsc->tl_cdata.tl_tx_head = start_tx;\n\t\tsc->tl_cdata.tl_tx_tail = cur_tx;\n\n\t\tif (sc->tl_txeoc) {\n\t\t\tsc->tl_txeoc = 0;\n\t\t\tCSR_WRITE_4(sc, TL_CH_PARM, vtophys(start_tx->tl_ptr));\n\t\t\tcmd = CSR_READ_4(sc, TL_HOSTCMD);\n\t\t\tcmd &= ~TL_CMD_RT;\n\t\t\tcmd |= TL_CMD_GO|TL_CMD_INTSON;\n\t\t\tCMD_PUT(sc, cmd);\n\t\t}\n\t} else {\n\t\tsc->tl_cdata.tl_tx_tail->tl_next = start_tx;\n\t\tsc->tl_cdata.tl_tx_tail = cur_tx;\n\t}\n\n\t/*\n\t * Set a timeout in case the chip goes out to lunch.\n\t */\n\tifp->if_timer = 10;\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int tl_encap",
            "void tl_start",
            "void tl_autoneg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint tl_encap;\nvoid tl_start;\nvoid tl_autoneg;\n\nvoid tl_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct tl_softc\t\t*sc;\n\tstruct mbuf\t\t*m_head = NULL;\n\tu_int32_t\t\tcmd;\n\tstruct tl_chain\t\t*prev = NULL, *cur_tx = NULL, *start_tx;\n\n\tsc = ifp->if_softc;\n\n\tif (sc->tl_autoneg) {\n\t\tsc->tl_tx_pend = 1;\n\t\treturn;\n\t}\n\n\t/*\n\t * Check for an available queue slot. If there are none,\n\t * punt.\n\t */\n\tif (sc->tl_cdata.tl_tx_free == NULL) {\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t\treturn;\n\t}\n\n\tstart_tx = sc->tl_cdata.tl_tx_free;\n\n\twhile(sc->tl_cdata.tl_tx_free != NULL) {\n\t\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\t\tif (m_head == NULL)\n\t\t\tbreak;\n\n\t\t/* Pick a chain member off the free list. */\n\t\tcur_tx = sc->tl_cdata.tl_tx_free;\n\t\tsc->tl_cdata.tl_tx_free = cur_tx->tl_next;\n\n\t\tcur_tx->tl_next = NULL;\n\n\t\t/* Pack the data into the list. */\n\t\ttl_encap(sc, cur_tx, m_head);\n\n\t\t/* Chain it together */\n\t\tif (prev != NULL) {\n\t\t\tprev->tl_next = cur_tx;\n\t\t\tprev->tl_ptr->tlist_fptr = vtophys(cur_tx->tl_ptr);\n\t\t}\n\t\tprev = cur_tx;\n\n\t\t/*\n\t\t * If there's a BPF listener, bounce a copy of this frame\n\t\t * to him.\n\t\t */\n#if NBPFILTER > 0\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, cur_tx->tl_mbuf);\n#endif\n\t}\n\n\t/*\n\t * If there are no packets queued, bail.\n\t */\n\tif (cur_tx == NULL)\n\t\treturn;\n\n\t/*\n\t * That's all we can stands, we can't stands no more.\n\t * If there are no other transfers pending, then issue the\n\t * TX GO command to the adapter to start things moving.\n\t * Otherwise, just leave the data in the queue and let\n\t * the EOF/EOC interrupt handler send.\n\t */\n\tif (sc->tl_cdata.tl_tx_head == NULL) {\n\t\tsc->tl_cdata.tl_tx_head = start_tx;\n\t\tsc->tl_cdata.tl_tx_tail = cur_tx;\n\n\t\tif (sc->tl_txeoc) {\n\t\t\tsc->tl_txeoc = 0;\n\t\t\tCSR_WRITE_4(sc, TL_CH_PARM, vtophys(start_tx->tl_ptr));\n\t\t\tcmd = CSR_READ_4(sc, TL_HOSTCMD);\n\t\t\tcmd &= ~TL_CMD_RT;\n\t\t\tcmd |= TL_CMD_GO|TL_CMD_INTSON;\n\t\t\tCMD_PUT(sc, cmd);\n\t\t}\n\t} else {\n\t\tsc->tl_cdata.tl_tx_tail->tl_next = start_tx;\n\t\tsc->tl_cdata.tl_tx_tail = cur_tx;\n\t}\n\n\t/*\n\t * Set a timeout in case the chip goes out to lunch.\n\t */\n\tifp->if_timer = 10;\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tl_init",
          "args": [
            "sc"
          ],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "tl_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "2052-2156",
          "snippet": "void tl_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct tl_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n        int\t\t\ts;\n\tu_int16_t\t\tphy_sts;\n\n\tif (sc->tl_autoneg)\n\t\treturn;\n\n\ts = splimp();\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/*\n\t * Cancel pending I/O.\n\t */\n\ttl_stop(sc);\n\n\t/*\n\t * Set 'capture all frames' bit for promiscuous mode.\n\t */\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\ttl_dio_setbit(sc, TL_NETCMD, TL_CMD_CAF);\n\telse\n\t\ttl_dio_clrbit(sc, TL_NETCMD, TL_CMD_CAF);\n\n\t/*\n\t * Set capture broadcast bit to capture broadcast frames.\n\t */\n\tif (ifp->if_flags & IFF_BROADCAST)\n\t\ttl_dio_clrbit(sc, TL_NETCMD, TL_CMD_NOBRX);\n\telse\n\t\ttl_dio_setbit(sc, TL_NETCMD, TL_CMD_NOBRX);\n\n\t/* Init our MAC address */\n\ttl_setfilt(sc, (caddr_t)&sc->arpcom.ac_enaddr, 0);\n\n\t/* Init multicast filter, if needed. */\n\ttl_setmulti(sc);\n\n\t/* Init circular RX list. */\n\tif (tl_list_rx_init(sc) == ENOBUFS) {\n\t\tprintf(\"tl%d: initialization failed: no \"\n\t\t\t\"memory for rx buffers\\n\", sc->tl_unit);\n\t\ttl_stop(sc);\n\t\treturn;\n\t}\n\n\t/* Init TX pointers. */\n\ttl_list_tx_init(sc);\n\n\t/*\n\t * Enable PHY interrupts.\n\t */\n\tphy_sts = tl_phy_readreg(sc, TL_PHY_CTL);\n\tphy_sts |= PHY_CTL_INTEN;\n\ttl_phy_writereg(sc, TL_PHY_CTL, phy_sts);\n\n\t/* Enable MII interrupts. */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\n\t/* Enable PCI interrupts. */\n\tCMD_SET(sc, TL_CMD_INTSON);\n\n\t/* Load the address of the rx list */\n\tCMD_SET(sc, TL_CMD_RT);\n\tCSR_WRITE_4(sc, TL_CH_PARM, vtophys(&sc->tl_ldata->tl_rx_list[0]));\n\n\t/*\n\t * XXX This is a kludge to handle adapters with the Micro Linear\n\t * ML6692 100BaseTX PHY, which only supports 100Mbps modes and\n\t * relies on the controller's internal 10Mbps PHY to provide\n\t * 10Mbps modes. The ML6692 always shows up with a vendor/device ID\n\t * of 0 (it doesn't actually have vendor/device ID registers)\n\t * so we use that property to detect it. In theory there ought to\n\t * be a better way to 'spot the looney' but I can't find one.\n         */\n        if (!sc->tl_phy_vid) {\n                u_int8_t                        addr = 0;\n                u_int16_t                       bmcr;\n\n                bmcr = tl_phy_readreg(sc, PHY_BMCR);\n                addr = sc->tl_phy_addr;\n                sc->tl_phy_addr = TL_PHYADDR_MAX;\n                tl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_RESET);\n                if (bmcr & PHY_BMCR_SPEEDSEL)\n                        tl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_ISOLATE);\n                else\n                        tl_phy_writereg(sc, PHY_BMCR, bmcr);\n                sc->tl_phy_addr = addr;\n        }\n\n\t/* Send the RX go command */\n\tCMD_SET(sc, TL_CMD_GO|TL_CMD_RT);\n\n\t(void)splx(s);\n\n\t/* Start the stats update counter */\n\ttimeout(tl_stats_update, sc, hz);\n\ttimeout(tl_wait_up, sc, 2 * hz);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void tl_wait_up",
            "void tl_stats_update",
            "void tl_init",
            "void tl_stop",
            "u_int16_t tl_phy_readreg",
            "void tl_phy_writereg",
            "void tl_autoneg",
            "void tl_setmulti",
            "void tl_setfilt",
            "int tl_list_rx_init",
            "int tl_list_tx_init",
            "void tl_dio_setbit",
            "void tl_dio_clrbit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_wait_up;\nvoid tl_stats_update;\nvoid tl_init;\nvoid tl_stop;\nu_int16_t tl_phy_readreg;\nvoid tl_phy_writereg;\nvoid tl_autoneg;\nvoid tl_setmulti;\nvoid tl_setfilt;\nint tl_list_rx_init;\nint tl_list_tx_init;\nvoid tl_dio_setbit;\nvoid tl_dio_clrbit;\n\nvoid tl_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct tl_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n        int\t\t\ts;\n\tu_int16_t\t\tphy_sts;\n\n\tif (sc->tl_autoneg)\n\t\treturn;\n\n\ts = splimp();\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/*\n\t * Cancel pending I/O.\n\t */\n\ttl_stop(sc);\n\n\t/*\n\t * Set 'capture all frames' bit for promiscuous mode.\n\t */\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\ttl_dio_setbit(sc, TL_NETCMD, TL_CMD_CAF);\n\telse\n\t\ttl_dio_clrbit(sc, TL_NETCMD, TL_CMD_CAF);\n\n\t/*\n\t * Set capture broadcast bit to capture broadcast frames.\n\t */\n\tif (ifp->if_flags & IFF_BROADCAST)\n\t\ttl_dio_clrbit(sc, TL_NETCMD, TL_CMD_NOBRX);\n\telse\n\t\ttl_dio_setbit(sc, TL_NETCMD, TL_CMD_NOBRX);\n\n\t/* Init our MAC address */\n\ttl_setfilt(sc, (caddr_t)&sc->arpcom.ac_enaddr, 0);\n\n\t/* Init multicast filter, if needed. */\n\ttl_setmulti(sc);\n\n\t/* Init circular RX list. */\n\tif (tl_list_rx_init(sc) == ENOBUFS) {\n\t\tprintf(\"tl%d: initialization failed: no \"\n\t\t\t\"memory for rx buffers\\n\", sc->tl_unit);\n\t\ttl_stop(sc);\n\t\treturn;\n\t}\n\n\t/* Init TX pointers. */\n\ttl_list_tx_init(sc);\n\n\t/*\n\t * Enable PHY interrupts.\n\t */\n\tphy_sts = tl_phy_readreg(sc, TL_PHY_CTL);\n\tphy_sts |= PHY_CTL_INTEN;\n\ttl_phy_writereg(sc, TL_PHY_CTL, phy_sts);\n\n\t/* Enable MII interrupts. */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\n\t/* Enable PCI interrupts. */\n\tCMD_SET(sc, TL_CMD_INTSON);\n\n\t/* Load the address of the rx list */\n\tCMD_SET(sc, TL_CMD_RT);\n\tCSR_WRITE_4(sc, TL_CH_PARM, vtophys(&sc->tl_ldata->tl_rx_list[0]));\n\n\t/*\n\t * XXX This is a kludge to handle adapters with the Micro Linear\n\t * ML6692 100BaseTX PHY, which only supports 100Mbps modes and\n\t * relies on the controller's internal 10Mbps PHY to provide\n\t * 10Mbps modes. The ML6692 always shows up with a vendor/device ID\n\t * of 0 (it doesn't actually have vendor/device ID registers)\n\t * so we use that property to detect it. In theory there ought to\n\t * be a better way to 'spot the looney' but I can't find one.\n         */\n        if (!sc->tl_phy_vid) {\n                u_int8_t                        addr = 0;\n                u_int16_t                       bmcr;\n\n                bmcr = tl_phy_readreg(sc, PHY_BMCR);\n                addr = sc->tl_phy_addr;\n                sc->tl_phy_addr = TL_PHYADDR_MAX;\n                tl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_RESET);\n                if (bmcr & PHY_BMCR_SPEEDSEL)\n                        tl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_ISOLATE);\n                else\n                        tl_phy_writereg(sc, PHY_BMCR, bmcr);\n                sc->tl_phy_addr = addr;\n        }\n\n\t/* Send the RX go command */\n\tCMD_SET(sc, TL_CMD_GO|TL_CMD_RT);\n\n\t(void)splx(s);\n\n\t/* Start the stats update counter */\n\ttimeout(tl_stats_update, sc, hz);\n\ttimeout(tl_wait_up, sc, 2 * hz);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"no carrier\\n\""
          ],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tl_phy_writereg",
          "args": [
            "sc",
            "PHY_BMCR",
            "media"
          ],
          "line": 948
        },
        "resolved": true,
        "details": {
          "function_name": "tl_phy_writereg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "740-759",
          "snippet": "void tl_phy_writereg(sc, reg, data)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tdata;\n{\n\tstruct tl_mii_frame\tframe;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = sc->tl_phy_addr;\n\tframe.mii_regaddr = reg;\n\tframe.mii_data = data;\n\n\ttl_mii_writereg(sc, &frame);\n\n\t/* Reenable MII interrupts, just in case. */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int tl_mii_writereg",
            "void tl_phy_writereg",
            "void tl_dio_setbit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint tl_mii_writereg;\nvoid tl_phy_writereg;\nvoid tl_dio_setbit;\n\nvoid tl_phy_writereg(sc, reg, data)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tdata;\n{\n\tstruct tl_mii_frame\tframe;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = sc->tl_phy_addr;\n\tframe.mii_regaddr = reg;\n\tframe.mii_data = data;\n\n\ttl_mii_writereg(sc, &frame);\n\n\t/* Reenable MII interrupts, just in case. */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tl_dio_clrbit",
          "args": [
            "sc",
            "TL_NETCMD",
            "TL_CMD_DUPLEX"
          ],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "tl_dio_clrbit16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "389-402",
          "snippet": "void tl_dio_clrbit16(sc, reg, bit)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tbit;\n{\n\tu_int16_t\t\t\tf;\n\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tf = CSR_READ_2(sc, TL_DIO_DATA + (reg & 3));\n\tf &= ~bit;\n\tCSR_WRITE_2(sc, TL_DIO_DATA + (reg & 3), f);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void tl_dio_clrbit16"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_dio_clrbit16;\n\nvoid tl_dio_clrbit16(sc, reg, bit)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tbit;\n{\n\tu_int16_t\t\t\tf;\n\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tf = CSR_READ_2(sc, TL_DIO_DATA + (reg & 3));\n\tf &= ~bit;\n\tCSR_WRITE_2(sc, TL_DIO_DATA + (reg & 3), f);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tl_dio_setbit",
          "args": [
            "sc",
            "TL_NETCMD",
            "TL_CMD_DUPLEX"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "tl_dio_setbit16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "374-387",
          "snippet": "void tl_dio_setbit16(sc, reg, bit)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tbit;\n{\n\tu_int16_t\t\t\tf;\n\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tf = CSR_READ_2(sc, TL_DIO_DATA + (reg & 3));\n\tf |= bit;\n\tCSR_WRITE_2(sc, TL_DIO_DATA + (reg & 3), f);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void tl_dio_setbit16"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_dio_setbit16;\n\nvoid tl_dio_setbit16(sc, reg, bit)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tbit;\n{\n\tu_int16_t\t\t\tf;\n\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tf = CSR_READ_2(sc, TL_DIO_DATA + (reg & 3));\n\tf |= bit;\n\tCSR_WRITE_2(sc, TL_DIO_DATA + (reg & 3), f);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tl_phy_readreg",
          "args": [
            "sc",
            "PHY_BMCR"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "tl_phy_readreg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "722-738",
          "snippet": "u_int16_t tl_phy_readreg(sc, reg)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tstruct tl_mii_frame\tframe;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = sc->tl_phy_addr;\n\tframe.mii_regaddr = reg;\n\ttl_mii_readreg(sc, &frame);\n\n\t/* Reenable MII interrupts, just in case. */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\n\treturn(frame.mii_data);\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int tl_mii_readreg",
            "u_int16_t tl_phy_readreg",
            "void tl_dio_setbit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint tl_mii_readreg;\nu_int16_t tl_phy_readreg;\nvoid tl_dio_setbit;\n\nu_int16_t tl_phy_readreg(sc, reg)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tstruct tl_mii_frame\tframe;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = sc->tl_phy_addr;\n\tframe.mii_regaddr = reg;\n\ttl_mii_readreg(sc, &frame);\n\n\t/* Reenable MII interrupts, just in case. */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\n\treturn(frame.mii_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "500"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "5000000"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "500"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_start;\nvoid tl_init;\nu_int16_t tl_phy_readreg;\nvoid tl_phy_writereg;\nvoid tl_autoneg;\nvoid tl_dio_setbit;\nvoid tl_dio_clrbit;\n\nvoid tl_autoneg(sc, flag, verbose)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\tflag;\n\tint\t\t\tverbose;\n{\n\tu_int16_t\t\tphy_sts = 0, media = 0, advert, ability;\n\tstruct ifnet\t\t*ifp;\n\tstruct ifmedia\t\t*ifm;\n\n\tifm = &sc->ifmedia;\n\tifp = &sc->arpcom.ac_if;\n\n\t/*\n\t * First, see if autoneg is supported. If not, there's\n\t * no point in continuing.\n\t */\n\tphy_sts = tl_phy_readreg(sc, PHY_BMSR);\n\tif (!(phy_sts & PHY_BMSR_CANAUTONEG)) {\n\t\tif (verbose)\n\t\t\tprintf(\"tl%d: autonegotiation not supported\\n\",\n\t\t\t\t\t\t\tsc->tl_unit);\n\t\treturn;\n\t}\n\n\tswitch (flag) {\n\tcase TL_FLAG_FORCEDELAY:\n\t\t/*\n\t \t * XXX Never use this option anywhere but in the probe\n\t \t * routine: making the kernel stop dead in its tracks\n \t\t * for three whole seconds after we've gone multi-user\n\t\t * is really bad manners.\n\t \t */\n\t\ttl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_RESET);\n\t\tDELAY(500);\n\t\tphy_sts = tl_phy_readreg(sc, PHY_BMCR);\n\t\tphy_sts |= PHY_BMCR_AUTONEGENBL|PHY_BMCR_AUTONEGRSTR;\n\t\ttl_phy_writereg(sc, PHY_BMCR, phy_sts);\n\t\tDELAY(5000000);\n\t\tbreak;\n\tcase TL_FLAG_SCHEDDELAY:\n\t\t/*\n\t\t * Wait for the transmitter to go idle before starting\n\t\t * an autoneg session, otherwise tl_start() may clobber\n\t \t * our timeout, and we don't want to allow transmission\n\t\t * during an autoneg session since that can screw it up.\n\t \t */\n\t\tif (!sc->tl_txeoc) {\n\t\t\tsc->tl_want_auto = 1;\n\t\t\treturn;\n\t\t}\n\t\ttl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_RESET);\n\t\tDELAY(500);\n\t\tphy_sts = tl_phy_readreg(sc, PHY_BMCR);\n\t\tphy_sts |= PHY_BMCR_AUTONEGENBL|PHY_BMCR_AUTONEGRSTR;\n\t\ttl_phy_writereg(sc, PHY_BMCR, phy_sts);\n\t\tifp->if_timer = 10;\n\t\tsc->tl_autoneg = 1;\n\t\tsc->tl_want_auto = 0;\n\t\treturn;\n\tcase TL_FLAG_DELAYTIMEO:\n\t\tifp->if_timer = 0;\n\t\tsc->tl_autoneg = 0;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"tl%d: invalid autoneg flag: %d\\n\", sc->tl_unit, flag);\n\t\treturn;\n\t}\n\n\t/*\n \t * Read the BMSR register twice: the LINKSTAT bit is a\n\t * latching bit.\n\t */\n\ttl_phy_readreg(sc, PHY_BMSR);\n\tphy_sts = tl_phy_readreg(sc, PHY_BMSR);\n\tif (phy_sts & PHY_BMSR_AUTONEGCOMP) {\n\t\tif (verbose)\n\t\t\tprintf(\"tl%d: autoneg complete, \", sc->tl_unit);\n\t\tphy_sts = tl_phy_readreg(sc, PHY_BMSR);\n\t} else {\n\t\tif (verbose)\n\t\t\tprintf(\"tl%d: autoneg not complete, \", sc->tl_unit);\n\t}\n\n\t/* Link is good. Report modes and set duplex mode. */\n\tif (phy_sts & PHY_BMSR_LINKSTAT) {\n\t\tif (verbose)\n\t\t\tprintf(\"link status good \");\n\n\t\tadvert = tl_phy_readreg(sc, TL_PHY_ANAR);\n\t\tability = tl_phy_readreg(sc, TL_PHY_LPAR);\n\t\tmedia = tl_phy_readreg(sc, PHY_BMCR);\n\n\t\t/*\n\t \t * Be sure to turn off the ISOLATE and\n\t\t * LOOPBACK bits in the control register,\n\t\t * otherwise we may not be able to communicate.\n\t\t */\n\t\tmedia &= ~(PHY_BMCR_LOOPBK|PHY_BMCR_ISOLATE);\n\t\t/* Set the DUPLEX bit in the NetCmd register accordingly. */\n\t\tif (advert & PHY_ANAR_100BT4 && ability & PHY_ANAR_100BT4) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_100_T4;\n\t\t\tmedia |= PHY_BMCR_SPEEDSEL;\n\t\t\tmedia &= ~PHY_BMCR_DUPLEX;\n\t\t\tif (verbose)\n\t\t\t\tprintf(\"(100baseT4)\\n\");\n\t\t} else if (advert & PHY_ANAR_100BTXFULL &&\n\t\t\tability & PHY_ANAR_100BTXFULL) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_100_TX|IFM_FDX;\n\t\t\tmedia |= PHY_BMCR_SPEEDSEL;\n\t\t\tmedia |= PHY_BMCR_DUPLEX;\n\t\t\tif (verbose)\n\t\t\t\tprintf(\"(full-duplex, 100Mbps)\\n\");\n\t\t} else if (advert & PHY_ANAR_100BTXHALF &&\n\t\t\tability & PHY_ANAR_100BTXHALF) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_100_TX|IFM_HDX;\n\t\t\tmedia |= PHY_BMCR_SPEEDSEL;\n\t\t\tmedia &= ~PHY_BMCR_DUPLEX;\n\t\t\tif (verbose)\n\t\t\t\tprintf(\"(half-duplex, 100Mbps)\\n\");\n\t\t} else if (advert & PHY_ANAR_10BTFULL &&\n\t\t\tability & PHY_ANAR_10BTFULL) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_10_T|IFM_FDX;\n\t\t\tmedia &= ~PHY_BMCR_SPEEDSEL;\n\t\t\tmedia |= PHY_BMCR_DUPLEX;\n\t\t\tif (verbose)\n\t\t\t\tprintf(\"(full-duplex, 10Mbps)\\n\");\n\t\t} else {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_10_T|IFM_HDX;\n\t\t\tmedia &= ~PHY_BMCR_SPEEDSEL;\n\t\t\tmedia &= ~PHY_BMCR_DUPLEX;\n\t\t\tif (verbose)\n\t\t\t\tprintf(\"(half-duplex, 10Mbps)\\n\");\n\t\t}\n\n\t\tif (media & PHY_BMCR_DUPLEX)\n\t\t\ttl_dio_setbit(sc, TL_NETCMD, TL_CMD_DUPLEX);\n\t\telse\n\t\t\ttl_dio_clrbit(sc, TL_NETCMD, TL_CMD_DUPLEX);\n\n\t\tmedia &= ~PHY_BMCR_AUTONEGENBL;\n\t\ttl_phy_writereg(sc, PHY_BMCR, media);\n\t} else {\n\t\tif (verbose)\n\t\t\tprintf(\"no carrier\\n\");\n\t}\n\n\ttl_init(sc);\n\n\tif (sc->tl_tx_pend) {\n\t\tsc->tl_autoneg = 0;\n\t\tsc->tl_tx_pend = 0;\n\t\ttl_start(ifp);\n\t}\n\n\treturn;\n}"
  },
  {
    "function_name": "tl_phy_writereg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
    "lines": "740-759",
    "snippet": "void tl_phy_writereg(sc, reg, data)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tdata;\n{\n\tstruct tl_mii_frame\tframe;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = sc->tl_phy_addr;\n\tframe.mii_regaddr = reg;\n\tframe.mii_data = data;\n\n\ttl_mii_writereg(sc, &frame);\n\n\t/* Reenable MII interrupts, just in case. */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/if_tlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int tl_mii_writereg",
      "void tl_phy_writereg",
      "void tl_dio_setbit"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tl_dio_setbit",
          "args": [
            "sc",
            "TL_NETSIO",
            "TL_SIO_MINTEN"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "tl_dio_setbit16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "374-387",
          "snippet": "void tl_dio_setbit16(sc, reg, bit)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tbit;\n{\n\tu_int16_t\t\t\tf;\n\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tf = CSR_READ_2(sc, TL_DIO_DATA + (reg & 3));\n\tf |= bit;\n\tCSR_WRITE_2(sc, TL_DIO_DATA + (reg & 3), f);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void tl_dio_setbit16"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_dio_setbit16;\n\nvoid tl_dio_setbit16(sc, reg, bit)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tbit;\n{\n\tu_int16_t\t\t\tf;\n\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tf = CSR_READ_2(sc, TL_DIO_DATA + (reg & 3));\n\tf |= bit;\n\tCSR_WRITE_2(sc, TL_DIO_DATA + (reg & 3), f);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tl_mii_writereg",
          "args": [
            "sc",
            "&frame"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "tl_mii_writereg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "666-720",
          "snippet": "int tl_mii_writereg(sc, frame)\n\tstruct tl_softc\t\t*sc;\n\tstruct tl_mii_frame\t*frame;\n\t\n{\n\tint\t\t\ts;\n\tint\t\t\tminten;\n\n\ttl_mii_sync(sc);\n\n\ts = splimp();\n\t/*\n\t * Set up frame for TX.\n\t */\n\n\tframe->mii_stdelim = TL_MII_STARTDELIM;\n\tframe->mii_opcode = TL_MII_WRITEOP;\n\tframe->mii_turnaround = TL_MII_TURNAROUND;\n\t\n\t/*\n\t * Turn off MII interrupt by forcing MINTEN low.\n\t */\n\tminten = tl_dio_read8(sc, TL_NETSIO) & TL_SIO_MINTEN;\n\tif (minten) {\n\t\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\t}\n\n\t/*\n \t * Turn on data output.\n\t */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MTXEN);\n\n\ttl_mii_send(sc, frame->mii_stdelim, 2);\n\ttl_mii_send(sc, frame->mii_opcode, 2);\n\ttl_mii_send(sc, frame->mii_phyaddr, 5);\n\ttl_mii_send(sc, frame->mii_regaddr, 5);\n\ttl_mii_send(sc, frame->mii_turnaround, 2);\n\ttl_mii_send(sc, frame->mii_data, 16);\n\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\n\t/*\n\t * Turn off xmit.\n\t */\n\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MTXEN);\n\n\t/* Reenable interrupts */\n\tif (minten)\n\t\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\n\tsplx(s);\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void tl_mii_sync",
            "void tl_mii_send",
            "int tl_mii_writereg",
            "u_int8_t tl_dio_read8",
            "void tl_dio_setbit",
            "void tl_dio_clrbit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_mii_sync;\nvoid tl_mii_send;\nint tl_mii_writereg;\nu_int8_t tl_dio_read8;\nvoid tl_dio_setbit;\nvoid tl_dio_clrbit;\n\nint tl_mii_writereg(sc, frame)\n\tstruct tl_softc\t\t*sc;\n\tstruct tl_mii_frame\t*frame;\n\t\n{\n\tint\t\t\ts;\n\tint\t\t\tminten;\n\n\ttl_mii_sync(sc);\n\n\ts = splimp();\n\t/*\n\t * Set up frame for TX.\n\t */\n\n\tframe->mii_stdelim = TL_MII_STARTDELIM;\n\tframe->mii_opcode = TL_MII_WRITEOP;\n\tframe->mii_turnaround = TL_MII_TURNAROUND;\n\t\n\t/*\n\t * Turn off MII interrupt by forcing MINTEN low.\n\t */\n\tminten = tl_dio_read8(sc, TL_NETSIO) & TL_SIO_MINTEN;\n\tif (minten) {\n\t\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\t}\n\n\t/*\n \t * Turn on data output.\n\t */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MTXEN);\n\n\ttl_mii_send(sc, frame->mii_stdelim, 2);\n\ttl_mii_send(sc, frame->mii_opcode, 2);\n\ttl_mii_send(sc, frame->mii_phyaddr, 5);\n\ttl_mii_send(sc, frame->mii_regaddr, 5);\n\ttl_mii_send(sc, frame->mii_turnaround, 2);\n\ttl_mii_send(sc, frame->mii_data, 16);\n\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\n\t/*\n\t * Turn off xmit.\n\t */\n\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MTXEN);\n\n\t/* Reenable interrupts */\n\tif (minten)\n\t\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\n\tsplx(s);\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char *)&frame",
            "sizeof(frame)"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint tl_mii_writereg;\nvoid tl_phy_writereg;\nvoid tl_dio_setbit;\n\nvoid tl_phy_writereg(sc, reg, data)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tdata;\n{\n\tstruct tl_mii_frame\tframe;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = sc->tl_phy_addr;\n\tframe.mii_regaddr = reg;\n\tframe.mii_data = data;\n\n\ttl_mii_writereg(sc, &frame);\n\n\t/* Reenable MII interrupts, just in case. */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\n\treturn;\n}"
  },
  {
    "function_name": "tl_phy_readreg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
    "lines": "722-738",
    "snippet": "u_int16_t tl_phy_readreg(sc, reg)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tstruct tl_mii_frame\tframe;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = sc->tl_phy_addr;\n\tframe.mii_regaddr = reg;\n\ttl_mii_readreg(sc, &frame);\n\n\t/* Reenable MII interrupts, just in case. */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\n\treturn(frame.mii_data);\n}",
    "includes": [
      "#include <dev/pci/if_tlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int tl_mii_readreg",
      "u_int16_t tl_phy_readreg",
      "void tl_dio_setbit"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tl_dio_setbit",
          "args": [
            "sc",
            "TL_NETSIO",
            "TL_SIO_MINTEN"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "tl_dio_setbit16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "374-387",
          "snippet": "void tl_dio_setbit16(sc, reg, bit)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tbit;\n{\n\tu_int16_t\t\t\tf;\n\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tf = CSR_READ_2(sc, TL_DIO_DATA + (reg & 3));\n\tf |= bit;\n\tCSR_WRITE_2(sc, TL_DIO_DATA + (reg & 3), f);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void tl_dio_setbit16"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_dio_setbit16;\n\nvoid tl_dio_setbit16(sc, reg, bit)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tbit;\n{\n\tu_int16_t\t\t\tf;\n\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tf = CSR_READ_2(sc, TL_DIO_DATA + (reg & 3));\n\tf |= bit;\n\tCSR_WRITE_2(sc, TL_DIO_DATA + (reg & 3), f);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tl_mii_readreg",
          "args": [
            "sc",
            "&frame"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "tl_mii_readreg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "571-664",
          "snippet": "int tl_mii_readreg(sc, frame)\n\tstruct tl_softc\t\t*sc;\n\tstruct tl_mii_frame\t*frame;\n\t\n{\n\tint\t\t\ti, ack, s;\n\tint\t\t\tminten = 0;\n\n\ts = splimp();\n\n\ttl_mii_sync(sc);\n\n\t/*\n\t * Set up frame for RX.\n\t */\n\tframe->mii_stdelim = TL_MII_STARTDELIM;\n\tframe->mii_opcode = TL_MII_READOP;\n\tframe->mii_turnaround = 0;\n\tframe->mii_data = 0;\n\t\n\t/*\n\t * Turn off MII interrupt by forcing MINTEN low.\n\t */\n\tminten = tl_dio_read8(sc, TL_NETSIO) & TL_SIO_MINTEN;\n\tif (minten) {\n\t\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\t}\n\n\t/*\n \t * Turn on data xmit.\n\t */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MTXEN);\n\n\t/*\n\t * Send command/address info.\n\t */\n\ttl_mii_send(sc, frame->mii_stdelim, 2);\n\ttl_mii_send(sc, frame->mii_opcode, 2);\n\ttl_mii_send(sc, frame->mii_phyaddr, 5);\n\ttl_mii_send(sc, frame->mii_regaddr, 5);\n\n\t/*\n\t * Turn off xmit.\n\t */\n\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MTXEN);\n\n\t/* Idle bit */\n\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\n\t/* Check for ack */\n\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\tack = tl_dio_read8(sc, TL_NETSIO) & TL_SIO_MDATA;\n\n\t/* Complete the cycle */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\n\t/*\n\t * Now try reading data bits. If the ack failed, we still\n\t * need to clock through 16 cycles to keep the PHYs in sync.\n\t */\n\tif (ack) {\n\t\tfor(i = 0; i < 16; i++) {\n\t\t\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\t\t\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\t\t}\n\t\tgoto fail;\n\t}\n\n\tfor (i = 0x8000; i; i >>= 1) {\n\t\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\t\tif (!ack) {\n\t\t\tif (tl_dio_read8(sc, TL_NETSIO) & TL_SIO_MDATA)\n\t\t\t\tframe->mii_data |= i;\n\t\t}\n\t\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\t}\n\nfail:\n\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\n\t/* Reenable interrupts */\n\tif (minten) {\n\t\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\t}\n\n\tsplx(s);\n\n\tif (ack)\n\t\treturn(1);\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void tl_mii_sync",
            "void tl_mii_send",
            "int tl_mii_readreg",
            "u_int8_t tl_dio_read8",
            "void tl_dio_setbit",
            "void tl_dio_clrbit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_mii_sync;\nvoid tl_mii_send;\nint tl_mii_readreg;\nu_int8_t tl_dio_read8;\nvoid tl_dio_setbit;\nvoid tl_dio_clrbit;\n\nint tl_mii_readreg(sc, frame)\n\tstruct tl_softc\t\t*sc;\n\tstruct tl_mii_frame\t*frame;\n\t\n{\n\tint\t\t\ti, ack, s;\n\tint\t\t\tminten = 0;\n\n\ts = splimp();\n\n\ttl_mii_sync(sc);\n\n\t/*\n\t * Set up frame for RX.\n\t */\n\tframe->mii_stdelim = TL_MII_STARTDELIM;\n\tframe->mii_opcode = TL_MII_READOP;\n\tframe->mii_turnaround = 0;\n\tframe->mii_data = 0;\n\t\n\t/*\n\t * Turn off MII interrupt by forcing MINTEN low.\n\t */\n\tminten = tl_dio_read8(sc, TL_NETSIO) & TL_SIO_MINTEN;\n\tif (minten) {\n\t\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\t}\n\n\t/*\n \t * Turn on data xmit.\n\t */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MTXEN);\n\n\t/*\n\t * Send command/address info.\n\t */\n\ttl_mii_send(sc, frame->mii_stdelim, 2);\n\ttl_mii_send(sc, frame->mii_opcode, 2);\n\ttl_mii_send(sc, frame->mii_phyaddr, 5);\n\ttl_mii_send(sc, frame->mii_regaddr, 5);\n\n\t/*\n\t * Turn off xmit.\n\t */\n\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MTXEN);\n\n\t/* Idle bit */\n\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\n\t/* Check for ack */\n\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\tack = tl_dio_read8(sc, TL_NETSIO) & TL_SIO_MDATA;\n\n\t/* Complete the cycle */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\n\t/*\n\t * Now try reading data bits. If the ack failed, we still\n\t * need to clock through 16 cycles to keep the PHYs in sync.\n\t */\n\tif (ack) {\n\t\tfor(i = 0; i < 16; i++) {\n\t\t\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\t\t\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\t\t}\n\t\tgoto fail;\n\t}\n\n\tfor (i = 0x8000; i; i >>= 1) {\n\t\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\t\tif (!ack) {\n\t\t\tif (tl_dio_read8(sc, TL_NETSIO) & TL_SIO_MDATA)\n\t\t\t\tframe->mii_data |= i;\n\t\t}\n\t\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\t}\n\nfail:\n\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\n\t/* Reenable interrupts */\n\tif (minten) {\n\t\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\t}\n\n\tsplx(s);\n\n\tif (ack)\n\t\treturn(1);\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char *)&frame",
            "sizeof(frame)"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint tl_mii_readreg;\nu_int16_t tl_phy_readreg;\nvoid tl_dio_setbit;\n\nu_int16_t tl_phy_readreg(sc, reg)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tstruct tl_mii_frame\tframe;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = sc->tl_phy_addr;\n\tframe.mii_regaddr = reg;\n\ttl_mii_readreg(sc, &frame);\n\n\t/* Reenable MII interrupts, just in case. */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\n\treturn(frame.mii_data);\n}"
  },
  {
    "function_name": "tl_mii_writereg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
    "lines": "666-720",
    "snippet": "int tl_mii_writereg(sc, frame)\n\tstruct tl_softc\t\t*sc;\n\tstruct tl_mii_frame\t*frame;\n\t\n{\n\tint\t\t\ts;\n\tint\t\t\tminten;\n\n\ttl_mii_sync(sc);\n\n\ts = splimp();\n\t/*\n\t * Set up frame for TX.\n\t */\n\n\tframe->mii_stdelim = TL_MII_STARTDELIM;\n\tframe->mii_opcode = TL_MII_WRITEOP;\n\tframe->mii_turnaround = TL_MII_TURNAROUND;\n\t\n\t/*\n\t * Turn off MII interrupt by forcing MINTEN low.\n\t */\n\tminten = tl_dio_read8(sc, TL_NETSIO) & TL_SIO_MINTEN;\n\tif (minten) {\n\t\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\t}\n\n\t/*\n \t * Turn on data output.\n\t */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MTXEN);\n\n\ttl_mii_send(sc, frame->mii_stdelim, 2);\n\ttl_mii_send(sc, frame->mii_opcode, 2);\n\ttl_mii_send(sc, frame->mii_phyaddr, 5);\n\ttl_mii_send(sc, frame->mii_regaddr, 5);\n\ttl_mii_send(sc, frame->mii_turnaround, 2);\n\ttl_mii_send(sc, frame->mii_data, 16);\n\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\n\t/*\n\t * Turn off xmit.\n\t */\n\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MTXEN);\n\n\t/* Reenable interrupts */\n\tif (minten)\n\t\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\n\tsplx(s);\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/pci/if_tlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void tl_mii_sync",
      "void tl_mii_send",
      "int tl_mii_writereg",
      "u_int8_t tl_dio_read8",
      "void tl_dio_setbit",
      "void tl_dio_clrbit"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tl_dio_setbit",
          "args": [
            "sc",
            "TL_NETSIO",
            "TL_SIO_MINTEN"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "tl_dio_setbit16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "374-387",
          "snippet": "void tl_dio_setbit16(sc, reg, bit)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tbit;\n{\n\tu_int16_t\t\t\tf;\n\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tf = CSR_READ_2(sc, TL_DIO_DATA + (reg & 3));\n\tf |= bit;\n\tCSR_WRITE_2(sc, TL_DIO_DATA + (reg & 3), f);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void tl_dio_setbit16"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_dio_setbit16;\n\nvoid tl_dio_setbit16(sc, reg, bit)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tbit;\n{\n\tu_int16_t\t\t\tf;\n\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tf = CSR_READ_2(sc, TL_DIO_DATA + (reg & 3));\n\tf |= bit;\n\tCSR_WRITE_2(sc, TL_DIO_DATA + (reg & 3), f);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tl_dio_clrbit",
          "args": [
            "sc",
            "TL_NETSIO",
            "TL_SIO_MTXEN"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "tl_dio_clrbit16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "389-402",
          "snippet": "void tl_dio_clrbit16(sc, reg, bit)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tbit;\n{\n\tu_int16_t\t\t\tf;\n\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tf = CSR_READ_2(sc, TL_DIO_DATA + (reg & 3));\n\tf &= ~bit;\n\tCSR_WRITE_2(sc, TL_DIO_DATA + (reg & 3), f);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void tl_dio_clrbit16"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_dio_clrbit16;\n\nvoid tl_dio_clrbit16(sc, reg, bit)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tbit;\n{\n\tu_int16_t\t\t\tf;\n\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tf = CSR_READ_2(sc, TL_DIO_DATA + (reg & 3));\n\tf &= ~bit;\n\tCSR_WRITE_2(sc, TL_DIO_DATA + (reg & 3), f);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tl_mii_send",
          "args": [
            "sc",
            "frame->mii_data",
            "16"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "tl_mii_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "553-569",
          "snippet": "void tl_mii_send(sc, bits, cnt)\n\tstruct tl_softc\t\t*sc;\n\tu_int32_t\t\tbits;\n\tint\t\t\tcnt;\n{\n\tint\t\t\ti;\n\n\tfor (i = (0x1 << (cnt - 1)); i; i >>= 1) {\n\t\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\t\tif (bits & i) {\n\t\t\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MDATA);\n\t\t} else {\n\t\t\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MDATA);\n\t\t}\n\t\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\t}\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void tl_mii_send",
            "void tl_dio_setbit",
            "void tl_dio_clrbit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_mii_send;\nvoid tl_dio_setbit;\nvoid tl_dio_clrbit;\n\nvoid tl_mii_send(sc, bits, cnt)\n\tstruct tl_softc\t\t*sc;\n\tu_int32_t\t\tbits;\n\tint\t\t\tcnt;\n{\n\tint\t\t\ti;\n\n\tfor (i = (0x1 << (cnt - 1)); i; i >>= 1) {\n\t\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\t\tif (bits & i) {\n\t\t\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MDATA);\n\t\t} else {\n\t\t\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MDATA);\n\t\t}\n\t\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tl_dio_read8",
          "args": [
            "sc",
            "TL_NETSIO"
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "tl_dio_read8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "290-296",
          "snippet": "u_int8_t tl_dio_read8(sc, reg)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\treturn(CSR_READ_1(sc, TL_DIO_DATA + (reg & 3)));\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "u_int8_t tl_dio_read8"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int8_t tl_dio_read8;\n\nu_int8_t tl_dio_read8(sc, reg)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\treturn(CSR_READ_1(sc, TL_DIO_DATA + (reg & 3)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tl_mii_sync",
          "args": [
            "sc"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "tl_mii_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "538-551",
          "snippet": "void tl_mii_sync(sc)\n\tstruct tl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MTXEN);\n\n\tfor (i = 0; i < 32; i++) {\n\t\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\t\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void tl_mii_sync",
            "void tl_dio_setbit",
            "void tl_dio_clrbit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_mii_sync;\nvoid tl_dio_setbit;\nvoid tl_dio_clrbit;\n\nvoid tl_mii_sync(sc)\n\tstruct tl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MTXEN);\n\n\tfor (i = 0; i < 32; i++) {\n\t\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\t\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\t}\n\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_mii_sync;\nvoid tl_mii_send;\nint tl_mii_writereg;\nu_int8_t tl_dio_read8;\nvoid tl_dio_setbit;\nvoid tl_dio_clrbit;\n\nint tl_mii_writereg(sc, frame)\n\tstruct tl_softc\t\t*sc;\n\tstruct tl_mii_frame\t*frame;\n\t\n{\n\tint\t\t\ts;\n\tint\t\t\tminten;\n\n\ttl_mii_sync(sc);\n\n\ts = splimp();\n\t/*\n\t * Set up frame for TX.\n\t */\n\n\tframe->mii_stdelim = TL_MII_STARTDELIM;\n\tframe->mii_opcode = TL_MII_WRITEOP;\n\tframe->mii_turnaround = TL_MII_TURNAROUND;\n\t\n\t/*\n\t * Turn off MII interrupt by forcing MINTEN low.\n\t */\n\tminten = tl_dio_read8(sc, TL_NETSIO) & TL_SIO_MINTEN;\n\tif (minten) {\n\t\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\t}\n\n\t/*\n \t * Turn on data output.\n\t */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MTXEN);\n\n\ttl_mii_send(sc, frame->mii_stdelim, 2);\n\ttl_mii_send(sc, frame->mii_opcode, 2);\n\ttl_mii_send(sc, frame->mii_phyaddr, 5);\n\ttl_mii_send(sc, frame->mii_regaddr, 5);\n\ttl_mii_send(sc, frame->mii_turnaround, 2);\n\ttl_mii_send(sc, frame->mii_data, 16);\n\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\n\t/*\n\t * Turn off xmit.\n\t */\n\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MTXEN);\n\n\t/* Reenable interrupts */\n\tif (minten)\n\t\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\n\tsplx(s);\n\n\treturn(0);\n}"
  },
  {
    "function_name": "tl_mii_readreg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
    "lines": "571-664",
    "snippet": "int tl_mii_readreg(sc, frame)\n\tstruct tl_softc\t\t*sc;\n\tstruct tl_mii_frame\t*frame;\n\t\n{\n\tint\t\t\ti, ack, s;\n\tint\t\t\tminten = 0;\n\n\ts = splimp();\n\n\ttl_mii_sync(sc);\n\n\t/*\n\t * Set up frame for RX.\n\t */\n\tframe->mii_stdelim = TL_MII_STARTDELIM;\n\tframe->mii_opcode = TL_MII_READOP;\n\tframe->mii_turnaround = 0;\n\tframe->mii_data = 0;\n\t\n\t/*\n\t * Turn off MII interrupt by forcing MINTEN low.\n\t */\n\tminten = tl_dio_read8(sc, TL_NETSIO) & TL_SIO_MINTEN;\n\tif (minten) {\n\t\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\t}\n\n\t/*\n \t * Turn on data xmit.\n\t */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MTXEN);\n\n\t/*\n\t * Send command/address info.\n\t */\n\ttl_mii_send(sc, frame->mii_stdelim, 2);\n\ttl_mii_send(sc, frame->mii_opcode, 2);\n\ttl_mii_send(sc, frame->mii_phyaddr, 5);\n\ttl_mii_send(sc, frame->mii_regaddr, 5);\n\n\t/*\n\t * Turn off xmit.\n\t */\n\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MTXEN);\n\n\t/* Idle bit */\n\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\n\t/* Check for ack */\n\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\tack = tl_dio_read8(sc, TL_NETSIO) & TL_SIO_MDATA;\n\n\t/* Complete the cycle */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\n\t/*\n\t * Now try reading data bits. If the ack failed, we still\n\t * need to clock through 16 cycles to keep the PHYs in sync.\n\t */\n\tif (ack) {\n\t\tfor(i = 0; i < 16; i++) {\n\t\t\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\t\t\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\t\t}\n\t\tgoto fail;\n\t}\n\n\tfor (i = 0x8000; i; i >>= 1) {\n\t\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\t\tif (!ack) {\n\t\t\tif (tl_dio_read8(sc, TL_NETSIO) & TL_SIO_MDATA)\n\t\t\t\tframe->mii_data |= i;\n\t\t}\n\t\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\t}\n\nfail:\n\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\n\t/* Reenable interrupts */\n\tif (minten) {\n\t\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\t}\n\n\tsplx(s);\n\n\tif (ack)\n\t\treturn(1);\n\treturn(0);\n}",
    "includes": [
      "#include <dev/pci/if_tlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void tl_mii_sync",
      "void tl_mii_send",
      "int tl_mii_readreg",
      "u_int8_t tl_dio_read8",
      "void tl_dio_setbit",
      "void tl_dio_clrbit"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tl_dio_setbit",
          "args": [
            "sc",
            "TL_NETSIO",
            "TL_SIO_MINTEN"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "tl_dio_setbit16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "374-387",
          "snippet": "void tl_dio_setbit16(sc, reg, bit)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tbit;\n{\n\tu_int16_t\t\t\tf;\n\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tf = CSR_READ_2(sc, TL_DIO_DATA + (reg & 3));\n\tf |= bit;\n\tCSR_WRITE_2(sc, TL_DIO_DATA + (reg & 3), f);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void tl_dio_setbit16"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_dio_setbit16;\n\nvoid tl_dio_setbit16(sc, reg, bit)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tbit;\n{\n\tu_int16_t\t\t\tf;\n\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tf = CSR_READ_2(sc, TL_DIO_DATA + (reg & 3));\n\tf |= bit;\n\tCSR_WRITE_2(sc, TL_DIO_DATA + (reg & 3), f);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tl_dio_clrbit",
          "args": [
            "sc",
            "TL_NETSIO",
            "TL_SIO_MCLK"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "tl_dio_clrbit16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "389-402",
          "snippet": "void tl_dio_clrbit16(sc, reg, bit)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tbit;\n{\n\tu_int16_t\t\t\tf;\n\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tf = CSR_READ_2(sc, TL_DIO_DATA + (reg & 3));\n\tf &= ~bit;\n\tCSR_WRITE_2(sc, TL_DIO_DATA + (reg & 3), f);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void tl_dio_clrbit16"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_dio_clrbit16;\n\nvoid tl_dio_clrbit16(sc, reg, bit)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tbit;\n{\n\tu_int16_t\t\t\tf;\n\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tf = CSR_READ_2(sc, TL_DIO_DATA + (reg & 3));\n\tf &= ~bit;\n\tCSR_WRITE_2(sc, TL_DIO_DATA + (reg & 3), f);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tl_dio_read8",
          "args": [
            "sc",
            "TL_NETSIO"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "tl_dio_read8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "290-296",
          "snippet": "u_int8_t tl_dio_read8(sc, reg)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\treturn(CSR_READ_1(sc, TL_DIO_DATA + (reg & 3)));\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "u_int8_t tl_dio_read8"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int8_t tl_dio_read8;\n\nu_int8_t tl_dio_read8(sc, reg)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\treturn(CSR_READ_1(sc, TL_DIO_DATA + (reg & 3)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "tl_mii_send",
          "args": [
            "sc",
            "frame->mii_regaddr",
            "5"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "tl_mii_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "553-569",
          "snippet": "void tl_mii_send(sc, bits, cnt)\n\tstruct tl_softc\t\t*sc;\n\tu_int32_t\t\tbits;\n\tint\t\t\tcnt;\n{\n\tint\t\t\ti;\n\n\tfor (i = (0x1 << (cnt - 1)); i; i >>= 1) {\n\t\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\t\tif (bits & i) {\n\t\t\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MDATA);\n\t\t} else {\n\t\t\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MDATA);\n\t\t}\n\t\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\t}\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void tl_mii_send",
            "void tl_dio_setbit",
            "void tl_dio_clrbit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_mii_send;\nvoid tl_dio_setbit;\nvoid tl_dio_clrbit;\n\nvoid tl_mii_send(sc, bits, cnt)\n\tstruct tl_softc\t\t*sc;\n\tu_int32_t\t\tbits;\n\tint\t\t\tcnt;\n{\n\tint\t\t\ti;\n\n\tfor (i = (0x1 << (cnt - 1)); i; i >>= 1) {\n\t\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\t\tif (bits & i) {\n\t\t\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MDATA);\n\t\t} else {\n\t\t\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MDATA);\n\t\t}\n\t\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tl_mii_sync",
          "args": [
            "sc"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "tl_mii_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "538-551",
          "snippet": "void tl_mii_sync(sc)\n\tstruct tl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MTXEN);\n\n\tfor (i = 0; i < 32; i++) {\n\t\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\t\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void tl_mii_sync",
            "void tl_dio_setbit",
            "void tl_dio_clrbit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_mii_sync;\nvoid tl_dio_setbit;\nvoid tl_dio_clrbit;\n\nvoid tl_mii_sync(sc)\n\tstruct tl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MTXEN);\n\n\tfor (i = 0; i < 32; i++) {\n\t\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\t\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\t}\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_mii_sync;\nvoid tl_mii_send;\nint tl_mii_readreg;\nu_int8_t tl_dio_read8;\nvoid tl_dio_setbit;\nvoid tl_dio_clrbit;\n\nint tl_mii_readreg(sc, frame)\n\tstruct tl_softc\t\t*sc;\n\tstruct tl_mii_frame\t*frame;\n\t\n{\n\tint\t\t\ti, ack, s;\n\tint\t\t\tminten = 0;\n\n\ts = splimp();\n\n\ttl_mii_sync(sc);\n\n\t/*\n\t * Set up frame for RX.\n\t */\n\tframe->mii_stdelim = TL_MII_STARTDELIM;\n\tframe->mii_opcode = TL_MII_READOP;\n\tframe->mii_turnaround = 0;\n\tframe->mii_data = 0;\n\t\n\t/*\n\t * Turn off MII interrupt by forcing MINTEN low.\n\t */\n\tminten = tl_dio_read8(sc, TL_NETSIO) & TL_SIO_MINTEN;\n\tif (minten) {\n\t\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\t}\n\n\t/*\n \t * Turn on data xmit.\n\t */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MTXEN);\n\n\t/*\n\t * Send command/address info.\n\t */\n\ttl_mii_send(sc, frame->mii_stdelim, 2);\n\ttl_mii_send(sc, frame->mii_opcode, 2);\n\ttl_mii_send(sc, frame->mii_phyaddr, 5);\n\ttl_mii_send(sc, frame->mii_regaddr, 5);\n\n\t/*\n\t * Turn off xmit.\n\t */\n\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MTXEN);\n\n\t/* Idle bit */\n\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\n\t/* Check for ack */\n\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\tack = tl_dio_read8(sc, TL_NETSIO) & TL_SIO_MDATA;\n\n\t/* Complete the cycle */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\n\t/*\n\t * Now try reading data bits. If the ack failed, we still\n\t * need to clock through 16 cycles to keep the PHYs in sync.\n\t */\n\tif (ack) {\n\t\tfor(i = 0; i < 16; i++) {\n\t\t\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\t\t\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\t\t}\n\t\tgoto fail;\n\t}\n\n\tfor (i = 0x8000; i; i >>= 1) {\n\t\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\t\tif (!ack) {\n\t\t\tif (tl_dio_read8(sc, TL_NETSIO) & TL_SIO_MDATA)\n\t\t\t\tframe->mii_data |= i;\n\t\t}\n\t\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\t}\n\nfail:\n\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\n\t/* Reenable interrupts */\n\tif (minten) {\n\t\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MINTEN);\n\t}\n\n\tsplx(s);\n\n\tif (ack)\n\t\treturn(1);\n\treturn(0);\n}"
  },
  {
    "function_name": "tl_mii_send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
    "lines": "553-569",
    "snippet": "void tl_mii_send(sc, bits, cnt)\n\tstruct tl_softc\t\t*sc;\n\tu_int32_t\t\tbits;\n\tint\t\t\tcnt;\n{\n\tint\t\t\ti;\n\n\tfor (i = (0x1 << (cnt - 1)); i; i >>= 1) {\n\t\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\t\tif (bits & i) {\n\t\t\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MDATA);\n\t\t} else {\n\t\t\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MDATA);\n\t\t}\n\t\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\t}\n}",
    "includes": [
      "#include <dev/pci/if_tlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void tl_mii_send",
      "void tl_dio_setbit",
      "void tl_dio_clrbit"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tl_dio_setbit",
          "args": [
            "sc",
            "TL_NETSIO",
            "TL_SIO_MCLK"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "tl_dio_setbit16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "374-387",
          "snippet": "void tl_dio_setbit16(sc, reg, bit)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tbit;\n{\n\tu_int16_t\t\t\tf;\n\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tf = CSR_READ_2(sc, TL_DIO_DATA + (reg & 3));\n\tf |= bit;\n\tCSR_WRITE_2(sc, TL_DIO_DATA + (reg & 3), f);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void tl_dio_setbit16"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_dio_setbit16;\n\nvoid tl_dio_setbit16(sc, reg, bit)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tbit;\n{\n\tu_int16_t\t\t\tf;\n\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tf = CSR_READ_2(sc, TL_DIO_DATA + (reg & 3));\n\tf |= bit;\n\tCSR_WRITE_2(sc, TL_DIO_DATA + (reg & 3), f);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tl_dio_clrbit",
          "args": [
            "sc",
            "TL_NETSIO",
            "TL_SIO_MDATA"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "tl_dio_clrbit16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "389-402",
          "snippet": "void tl_dio_clrbit16(sc, reg, bit)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tbit;\n{\n\tu_int16_t\t\t\tf;\n\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tf = CSR_READ_2(sc, TL_DIO_DATA + (reg & 3));\n\tf &= ~bit;\n\tCSR_WRITE_2(sc, TL_DIO_DATA + (reg & 3), f);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void tl_dio_clrbit16"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_dio_clrbit16;\n\nvoid tl_dio_clrbit16(sc, reg, bit)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tbit;\n{\n\tu_int16_t\t\t\tf;\n\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tf = CSR_READ_2(sc, TL_DIO_DATA + (reg & 3));\n\tf &= ~bit;\n\tCSR_WRITE_2(sc, TL_DIO_DATA + (reg & 3), f);\n\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_mii_send;\nvoid tl_dio_setbit;\nvoid tl_dio_clrbit;\n\nvoid tl_mii_send(sc, bits, cnt)\n\tstruct tl_softc\t\t*sc;\n\tu_int32_t\t\tbits;\n\tint\t\t\tcnt;\n{\n\tint\t\t\ti;\n\n\tfor (i = (0x1 << (cnt - 1)); i; i >>= 1) {\n\t\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\t\tif (bits & i) {\n\t\t\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MDATA);\n\t\t} else {\n\t\t\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MDATA);\n\t\t}\n\t\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\t}\n}"
  },
  {
    "function_name": "tl_mii_sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
    "lines": "538-551",
    "snippet": "void tl_mii_sync(sc)\n\tstruct tl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MTXEN);\n\n\tfor (i = 0; i < 32; i++) {\n\t\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\t\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\t}\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/if_tlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void tl_mii_sync",
      "void tl_dio_setbit",
      "void tl_dio_clrbit"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tl_dio_clrbit",
          "args": [
            "sc",
            "TL_NETSIO",
            "TL_SIO_MCLK"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "tl_dio_clrbit16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "389-402",
          "snippet": "void tl_dio_clrbit16(sc, reg, bit)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tbit;\n{\n\tu_int16_t\t\t\tf;\n\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tf = CSR_READ_2(sc, TL_DIO_DATA + (reg & 3));\n\tf &= ~bit;\n\tCSR_WRITE_2(sc, TL_DIO_DATA + (reg & 3), f);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void tl_dio_clrbit16"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_dio_clrbit16;\n\nvoid tl_dio_clrbit16(sc, reg, bit)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tbit;\n{\n\tu_int16_t\t\t\tf;\n\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tf = CSR_READ_2(sc, TL_DIO_DATA + (reg & 3));\n\tf &= ~bit;\n\tCSR_WRITE_2(sc, TL_DIO_DATA + (reg & 3), f);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tl_dio_setbit",
          "args": [
            "sc",
            "TL_NETSIO",
            "TL_SIO_MCLK"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "tl_dio_setbit16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "374-387",
          "snippet": "void tl_dio_setbit16(sc, reg, bit)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tbit;\n{\n\tu_int16_t\t\t\tf;\n\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tf = CSR_READ_2(sc, TL_DIO_DATA + (reg & 3));\n\tf |= bit;\n\tCSR_WRITE_2(sc, TL_DIO_DATA + (reg & 3), f);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void tl_dio_setbit16"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_dio_setbit16;\n\nvoid tl_dio_setbit16(sc, reg, bit)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tbit;\n{\n\tu_int16_t\t\t\tf;\n\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tf = CSR_READ_2(sc, TL_DIO_DATA + (reg & 3));\n\tf |= bit;\n\tCSR_WRITE_2(sc, TL_DIO_DATA + (reg & 3), f);\n\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_mii_sync;\nvoid tl_dio_setbit;\nvoid tl_dio_clrbit;\n\nvoid tl_mii_sync(sc)\n\tstruct tl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MTXEN);\n\n\tfor (i = 0; i < 32; i++) {\n\t\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\t\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MCLK);\n\t}\n\n\treturn;\n}"
  },
  {
    "function_name": "tl_read_eeprom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
    "lines": "519-536",
    "snippet": "int tl_read_eeprom(sc, dest, off, cnt)\n\tstruct tl_softc\t\t*sc;\n\tcaddr_t\t\t\tdest;\n\tint\t\t\toff;\n\tint\t\t\tcnt;\n{\n\tint\t\t\terr = 0, i;\n\tu_int8_t\t\tbyte = 0;\n\n\tfor (i = 0; i < cnt; i++) {\n\t\terr = tl_eeprom_getbyte(sc, off + i, &byte);\n\t\tif (err)\n\t\t\tbreak;\n\t\t*(dest + i) = byte;\n\t}\n\n\treturn(err ? 1 : 0);\n}",
    "includes": [
      "#include <dev/pci/if_tlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "u_int8_t\ttl_eeprom_getbyte",
      "int tl_read_eeprom"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tl_eeprom_getbyte",
          "args": [
            "sc",
            "off + i",
            "&byte"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "tl_eeprom_getbyte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "451-514",
          "snippet": "u_int8_t tl_eeprom_getbyte(sc, addr, dest)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\taddr;\n\tu_int8_t\t\t*dest;\n{\n\tregister int\t\ti;\n\tu_int8_t\t\tbyte = 0;\n\n\ttl_dio_write8(sc, TL_NETSIO, 0);\n\n\tEEPROM_START;\n\n\t/*\n\t * Send write control code to EEPROM.\n\t */\n\tif (tl_eeprom_putbyte(sc, EEPROM_CTL_WRITE)) {\n\t\tprintf(\"tl%d: failed to send write command, status: %x\\n\",\n\t\t\t\tsc->tl_unit, tl_dio_read8(sc, TL_NETSIO));\n\t\treturn(1);\n\t}\n\n\t/*\n\t * Send address of byte we want to read.\n\t */\n\tif (tl_eeprom_putbyte(sc, addr)) {\n\t\tprintf(\"tl%d: failed to send address, status: %x\\n\",\n\t\t\t\tsc->tl_unit, tl_dio_read8(sc, TL_NETSIO));\n\t\treturn(1);\n\t}\n\n\tEEPROM_STOP;\n\tEEPROM_START;\n\t/*\n\t * Send read control code to EEPROM.\n\t */\n\tif (tl_eeprom_putbyte(sc, EEPROM_CTL_READ)) {\n\t\tprintf(\"tl%d: failed to send write command, status: %x\\n\",\n\t\t\t\tsc->tl_unit, tl_dio_read8(sc, TL_NETSIO));\n\t\treturn(1);\n\t}\n\n\t/*\n\t * Start reading bits from EEPROM.\n\t */\n\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_ETXEN);\n\tfor (i = 0x80; i; i >>= 1) {\n\t\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_ECLOK);\n\t\tDELAY(1);\n\t\tif (tl_dio_read8(sc, TL_NETSIO) & TL_SIO_EDATA)\n\t\t\tbyte |= i;\n\t\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_ECLOK);\n\t\tDELAY(1);\n\t}\n\n\tEEPROM_STOP;\n\n\t/*\n\t * No ACK generated for read, so just return byte.\n\t */\n\n\t*dest = byte;\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "u_int8_t tl_eeprom_putbyte",
            "u_int8_t\ttl_eeprom_getbyte",
            "u_int8_t tl_dio_read8",
            "void tl_dio_write8",
            "void tl_dio_setbit",
            "void tl_dio_clrbit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int8_t tl_eeprom_putbyte;\nu_int8_t\ttl_eeprom_getbyte;\nu_int8_t tl_dio_read8;\nvoid tl_dio_write8;\nvoid tl_dio_setbit;\nvoid tl_dio_clrbit;\n\nu_int8_t tl_eeprom_getbyte(sc, addr, dest)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\taddr;\n\tu_int8_t\t\t*dest;\n{\n\tregister int\t\ti;\n\tu_int8_t\t\tbyte = 0;\n\n\ttl_dio_write8(sc, TL_NETSIO, 0);\n\n\tEEPROM_START;\n\n\t/*\n\t * Send write control code to EEPROM.\n\t */\n\tif (tl_eeprom_putbyte(sc, EEPROM_CTL_WRITE)) {\n\t\tprintf(\"tl%d: failed to send write command, status: %x\\n\",\n\t\t\t\tsc->tl_unit, tl_dio_read8(sc, TL_NETSIO));\n\t\treturn(1);\n\t}\n\n\t/*\n\t * Send address of byte we want to read.\n\t */\n\tif (tl_eeprom_putbyte(sc, addr)) {\n\t\tprintf(\"tl%d: failed to send address, status: %x\\n\",\n\t\t\t\tsc->tl_unit, tl_dio_read8(sc, TL_NETSIO));\n\t\treturn(1);\n\t}\n\n\tEEPROM_STOP;\n\tEEPROM_START;\n\t/*\n\t * Send read control code to EEPROM.\n\t */\n\tif (tl_eeprom_putbyte(sc, EEPROM_CTL_READ)) {\n\t\tprintf(\"tl%d: failed to send write command, status: %x\\n\",\n\t\t\t\tsc->tl_unit, tl_dio_read8(sc, TL_NETSIO));\n\t\treturn(1);\n\t}\n\n\t/*\n\t * Start reading bits from EEPROM.\n\t */\n\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_ETXEN);\n\tfor (i = 0x80; i; i >>= 1) {\n\t\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_ECLOK);\n\t\tDELAY(1);\n\t\tif (tl_dio_read8(sc, TL_NETSIO) & TL_SIO_EDATA)\n\t\t\tbyte |= i;\n\t\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_ECLOK);\n\t\tDELAY(1);\n\t}\n\n\tEEPROM_STOP;\n\n\t/*\n\t * No ACK generated for read, so just return byte.\n\t */\n\n\t*dest = byte;\n\n\treturn(0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int8_t\ttl_eeprom_getbyte;\nint tl_read_eeprom;\n\nint tl_read_eeprom(sc, dest, off, cnt)\n\tstruct tl_softc\t\t*sc;\n\tcaddr_t\t\t\tdest;\n\tint\t\t\toff;\n\tint\t\t\tcnt;\n{\n\tint\t\t\terr = 0, i;\n\tu_int8_t\t\tbyte = 0;\n\n\tfor (i = 0; i < cnt; i++) {\n\t\terr = tl_eeprom_getbyte(sc, off + i, &byte);\n\t\tif (err)\n\t\t\tbreak;\n\t\t*(dest + i) = byte;\n\t}\n\n\treturn(err ? 1 : 0);\n}"
  },
  {
    "function_name": "tl_eeprom_getbyte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
    "lines": "451-514",
    "snippet": "u_int8_t tl_eeprom_getbyte(sc, addr, dest)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\taddr;\n\tu_int8_t\t\t*dest;\n{\n\tregister int\t\ti;\n\tu_int8_t\t\tbyte = 0;\n\n\ttl_dio_write8(sc, TL_NETSIO, 0);\n\n\tEEPROM_START;\n\n\t/*\n\t * Send write control code to EEPROM.\n\t */\n\tif (tl_eeprom_putbyte(sc, EEPROM_CTL_WRITE)) {\n\t\tprintf(\"tl%d: failed to send write command, status: %x\\n\",\n\t\t\t\tsc->tl_unit, tl_dio_read8(sc, TL_NETSIO));\n\t\treturn(1);\n\t}\n\n\t/*\n\t * Send address of byte we want to read.\n\t */\n\tif (tl_eeprom_putbyte(sc, addr)) {\n\t\tprintf(\"tl%d: failed to send address, status: %x\\n\",\n\t\t\t\tsc->tl_unit, tl_dio_read8(sc, TL_NETSIO));\n\t\treturn(1);\n\t}\n\n\tEEPROM_STOP;\n\tEEPROM_START;\n\t/*\n\t * Send read control code to EEPROM.\n\t */\n\tif (tl_eeprom_putbyte(sc, EEPROM_CTL_READ)) {\n\t\tprintf(\"tl%d: failed to send write command, status: %x\\n\",\n\t\t\t\tsc->tl_unit, tl_dio_read8(sc, TL_NETSIO));\n\t\treturn(1);\n\t}\n\n\t/*\n\t * Start reading bits from EEPROM.\n\t */\n\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_ETXEN);\n\tfor (i = 0x80; i; i >>= 1) {\n\t\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_ECLOK);\n\t\tDELAY(1);\n\t\tif (tl_dio_read8(sc, TL_NETSIO) & TL_SIO_EDATA)\n\t\t\tbyte |= i;\n\t\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_ECLOK);\n\t\tDELAY(1);\n\t}\n\n\tEEPROM_STOP;\n\n\t/*\n\t * No ACK generated for read, so just return byte.\n\t */\n\n\t*dest = byte;\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/pci/if_tlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "u_int8_t tl_eeprom_putbyte",
      "u_int8_t\ttl_eeprom_getbyte",
      "u_int8_t tl_dio_read8",
      "void tl_dio_write8",
      "void tl_dio_setbit",
      "void tl_dio_clrbit"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tl_dio_clrbit",
          "args": [
            "sc",
            "TL_NETSIO",
            "TL_SIO_ECLOK"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "tl_dio_clrbit16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "389-402",
          "snippet": "void tl_dio_clrbit16(sc, reg, bit)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tbit;\n{\n\tu_int16_t\t\t\tf;\n\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tf = CSR_READ_2(sc, TL_DIO_DATA + (reg & 3));\n\tf &= ~bit;\n\tCSR_WRITE_2(sc, TL_DIO_DATA + (reg & 3), f);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void tl_dio_clrbit16"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_dio_clrbit16;\n\nvoid tl_dio_clrbit16(sc, reg, bit)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tbit;\n{\n\tu_int16_t\t\t\tf;\n\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tf = CSR_READ_2(sc, TL_DIO_DATA + (reg & 3));\n\tf &= ~bit;\n\tCSR_WRITE_2(sc, TL_DIO_DATA + (reg & 3), f);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tl_dio_read8",
          "args": [
            "sc",
            "TL_NETSIO"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "tl_dio_read8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "290-296",
          "snippet": "u_int8_t tl_dio_read8(sc, reg)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\treturn(CSR_READ_1(sc, TL_DIO_DATA + (reg & 3)));\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "u_int8_t tl_dio_read8"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int8_t tl_dio_read8;\n\nu_int8_t tl_dio_read8(sc, reg)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\treturn(CSR_READ_1(sc, TL_DIO_DATA + (reg & 3)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tl_dio_setbit",
          "args": [
            "sc",
            "TL_NETSIO",
            "TL_SIO_ECLOK"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "tl_dio_setbit16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "374-387",
          "snippet": "void tl_dio_setbit16(sc, reg, bit)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tbit;\n{\n\tu_int16_t\t\t\tf;\n\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tf = CSR_READ_2(sc, TL_DIO_DATA + (reg & 3));\n\tf |= bit;\n\tCSR_WRITE_2(sc, TL_DIO_DATA + (reg & 3), f);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void tl_dio_setbit16"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_dio_setbit16;\n\nvoid tl_dio_setbit16(sc, reg, bit)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tbit;\n{\n\tu_int16_t\t\t\tf;\n\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tf = CSR_READ_2(sc, TL_DIO_DATA + (reg & 3));\n\tf |= bit;\n\tCSR_WRITE_2(sc, TL_DIO_DATA + (reg & 3), f);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"tl%d: failed to send write command, status: %x\\n\"",
            "sc->tl_unit",
            "tl_dio_read8(sc, TL_NETSIO)"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tl_eeprom_putbyte",
          "args": [
            "sc",
            "EEPROM_CTL_READ"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "tl_eeprom_putbyte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "407-446",
          "snippet": "u_int8_t tl_eeprom_putbyte(sc, byte)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\tbyte;\n{\n\tregister int\t\ti, ack = 0;\n\n\t/*\n\t * Make sure we're in TX mode.\n\t */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_ETXEN);\n\n\t/*\n\t * Feed in each bit and stobe the clock.\n\t */\n\tfor (i = 0x80; i; i >>= 1) {\n\t\tif (byte & i) {\n\t\t\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_EDATA);\n\t\t} else {\n\t\t\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_EDATA);\n\t\t}\n\t\tDELAY(1);\n\t\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_ECLOK);\n\t\tDELAY(1);\n\t\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_ECLOK);\n\t}\n\n\t/*\n\t * Turn off TX mode.\n\t */\n\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_ETXEN);\n\n\t/*\n\t * Check for ack.\n\t */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_ECLOK);\n\tack = tl_dio_read8(sc, TL_NETSIO) & TL_SIO_EDATA;\n\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_ECLOK);\n\n\treturn(ack);\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "u_int8_t tl_eeprom_putbyte",
            "u_int8_t tl_dio_read8",
            "void tl_dio_setbit",
            "void tl_dio_clrbit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int8_t tl_eeprom_putbyte;\nu_int8_t tl_dio_read8;\nvoid tl_dio_setbit;\nvoid tl_dio_clrbit;\n\nu_int8_t tl_eeprom_putbyte(sc, byte)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\tbyte;\n{\n\tregister int\t\ti, ack = 0;\n\n\t/*\n\t * Make sure we're in TX mode.\n\t */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_ETXEN);\n\n\t/*\n\t * Feed in each bit and stobe the clock.\n\t */\n\tfor (i = 0x80; i; i >>= 1) {\n\t\tif (byte & i) {\n\t\t\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_EDATA);\n\t\t} else {\n\t\t\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_EDATA);\n\t\t}\n\t\tDELAY(1);\n\t\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_ECLOK);\n\t\tDELAY(1);\n\t\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_ECLOK);\n\t}\n\n\t/*\n\t * Turn off TX mode.\n\t */\n\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_ETXEN);\n\n\t/*\n\t * Check for ack.\n\t */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_ECLOK);\n\tack = tl_dio_read8(sc, TL_NETSIO) & TL_SIO_EDATA;\n\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_ECLOK);\n\n\treturn(ack);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tl_dio_write8",
          "args": [
            "sc",
            "TL_NETSIO",
            "0"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "tl_dio_write8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "314-322",
          "snippet": "void tl_dio_write8(sc, reg, val)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tval;\n{\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tCSR_WRITE_1(sc, TL_DIO_DATA + (reg & 3), val);\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void tl_dio_write8"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_dio_write8;\n\nvoid tl_dio_write8(sc, reg, val)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tval;\n{\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tCSR_WRITE_1(sc, TL_DIO_DATA + (reg & 3), val);\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int8_t tl_eeprom_putbyte;\nu_int8_t\ttl_eeprom_getbyte;\nu_int8_t tl_dio_read8;\nvoid tl_dio_write8;\nvoid tl_dio_setbit;\nvoid tl_dio_clrbit;\n\nu_int8_t tl_eeprom_getbyte(sc, addr, dest)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\taddr;\n\tu_int8_t\t\t*dest;\n{\n\tregister int\t\ti;\n\tu_int8_t\t\tbyte = 0;\n\n\ttl_dio_write8(sc, TL_NETSIO, 0);\n\n\tEEPROM_START;\n\n\t/*\n\t * Send write control code to EEPROM.\n\t */\n\tif (tl_eeprom_putbyte(sc, EEPROM_CTL_WRITE)) {\n\t\tprintf(\"tl%d: failed to send write command, status: %x\\n\",\n\t\t\t\tsc->tl_unit, tl_dio_read8(sc, TL_NETSIO));\n\t\treturn(1);\n\t}\n\n\t/*\n\t * Send address of byte we want to read.\n\t */\n\tif (tl_eeprom_putbyte(sc, addr)) {\n\t\tprintf(\"tl%d: failed to send address, status: %x\\n\",\n\t\t\t\tsc->tl_unit, tl_dio_read8(sc, TL_NETSIO));\n\t\treturn(1);\n\t}\n\n\tEEPROM_STOP;\n\tEEPROM_START;\n\t/*\n\t * Send read control code to EEPROM.\n\t */\n\tif (tl_eeprom_putbyte(sc, EEPROM_CTL_READ)) {\n\t\tprintf(\"tl%d: failed to send write command, status: %x\\n\",\n\t\t\t\tsc->tl_unit, tl_dio_read8(sc, TL_NETSIO));\n\t\treturn(1);\n\t}\n\n\t/*\n\t * Start reading bits from EEPROM.\n\t */\n\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_ETXEN);\n\tfor (i = 0x80; i; i >>= 1) {\n\t\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_ECLOK);\n\t\tDELAY(1);\n\t\tif (tl_dio_read8(sc, TL_NETSIO) & TL_SIO_EDATA)\n\t\t\tbyte |= i;\n\t\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_ECLOK);\n\t\tDELAY(1);\n\t}\n\n\tEEPROM_STOP;\n\n\t/*\n\t * No ACK generated for read, so just return byte.\n\t */\n\n\t*dest = byte;\n\n\treturn(0);\n}"
  },
  {
    "function_name": "tl_eeprom_putbyte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
    "lines": "407-446",
    "snippet": "u_int8_t tl_eeprom_putbyte(sc, byte)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\tbyte;\n{\n\tregister int\t\ti, ack = 0;\n\n\t/*\n\t * Make sure we're in TX mode.\n\t */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_ETXEN);\n\n\t/*\n\t * Feed in each bit and stobe the clock.\n\t */\n\tfor (i = 0x80; i; i >>= 1) {\n\t\tif (byte & i) {\n\t\t\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_EDATA);\n\t\t} else {\n\t\t\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_EDATA);\n\t\t}\n\t\tDELAY(1);\n\t\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_ECLOK);\n\t\tDELAY(1);\n\t\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_ECLOK);\n\t}\n\n\t/*\n\t * Turn off TX mode.\n\t */\n\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_ETXEN);\n\n\t/*\n\t * Check for ack.\n\t */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_ECLOK);\n\tack = tl_dio_read8(sc, TL_NETSIO) & TL_SIO_EDATA;\n\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_ECLOK);\n\n\treturn(ack);\n}",
    "includes": [
      "#include <dev/pci/if_tlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "u_int8_t tl_eeprom_putbyte",
      "u_int8_t tl_dio_read8",
      "void tl_dio_setbit",
      "void tl_dio_clrbit"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tl_dio_clrbit",
          "args": [
            "sc",
            "TL_NETSIO",
            "TL_SIO_ECLOK"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "tl_dio_clrbit16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "389-402",
          "snippet": "void tl_dio_clrbit16(sc, reg, bit)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tbit;\n{\n\tu_int16_t\t\t\tf;\n\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tf = CSR_READ_2(sc, TL_DIO_DATA + (reg & 3));\n\tf &= ~bit;\n\tCSR_WRITE_2(sc, TL_DIO_DATA + (reg & 3), f);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void tl_dio_clrbit16"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_dio_clrbit16;\n\nvoid tl_dio_clrbit16(sc, reg, bit)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tbit;\n{\n\tu_int16_t\t\t\tf;\n\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tf = CSR_READ_2(sc, TL_DIO_DATA + (reg & 3));\n\tf &= ~bit;\n\tCSR_WRITE_2(sc, TL_DIO_DATA + (reg & 3), f);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tl_dio_read8",
          "args": [
            "sc",
            "TL_NETSIO"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "tl_dio_read8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "290-296",
          "snippet": "u_int8_t tl_dio_read8(sc, reg)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\treturn(CSR_READ_1(sc, TL_DIO_DATA + (reg & 3)));\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "u_int8_t tl_dio_read8"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int8_t tl_dio_read8;\n\nu_int8_t tl_dio_read8(sc, reg)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\treturn(CSR_READ_1(sc, TL_DIO_DATA + (reg & 3)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "tl_dio_setbit",
          "args": [
            "sc",
            "TL_NETSIO",
            "TL_SIO_ECLOK"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "tl_dio_setbit16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
          "lines": "374-387",
          "snippet": "void tl_dio_setbit16(sc, reg, bit)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tbit;\n{\n\tu_int16_t\t\t\tf;\n\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tf = CSR_READ_2(sc, TL_DIO_DATA + (reg & 3));\n\tf |= bit;\n\tCSR_WRITE_2(sc, TL_DIO_DATA + (reg & 3), f);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_tlreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void tl_dio_setbit16"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_dio_setbit16;\n\nvoid tl_dio_setbit16(sc, reg, bit)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tbit;\n{\n\tu_int16_t\t\t\tf;\n\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tf = CSR_READ_2(sc, TL_DIO_DATA + (reg & 3));\n\tf |= bit;\n\tCSR_WRITE_2(sc, TL_DIO_DATA + (reg & 3), f);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int8_t tl_eeprom_putbyte;\nu_int8_t tl_dio_read8;\nvoid tl_dio_setbit;\nvoid tl_dio_clrbit;\n\nu_int8_t tl_eeprom_putbyte(sc, byte)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\tbyte;\n{\n\tregister int\t\ti, ack = 0;\n\n\t/*\n\t * Make sure we're in TX mode.\n\t */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_ETXEN);\n\n\t/*\n\t * Feed in each bit and stobe the clock.\n\t */\n\tfor (i = 0x80; i; i >>= 1) {\n\t\tif (byte & i) {\n\t\t\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_EDATA);\n\t\t} else {\n\t\t\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_EDATA);\n\t\t}\n\t\tDELAY(1);\n\t\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_ECLOK);\n\t\tDELAY(1);\n\t\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_ECLOK);\n\t}\n\n\t/*\n\t * Turn off TX mode.\n\t */\n\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_ETXEN);\n\n\t/*\n\t * Check for ack.\n\t */\n\ttl_dio_setbit(sc, TL_NETSIO, TL_SIO_ECLOK);\n\tack = tl_dio_read8(sc, TL_NETSIO) & TL_SIO_EDATA;\n\ttl_dio_clrbit(sc, TL_NETSIO, TL_SIO_ECLOK);\n\n\treturn(ack);\n}"
  },
  {
    "function_name": "tl_dio_clrbit16",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
    "lines": "389-402",
    "snippet": "void tl_dio_clrbit16(sc, reg, bit)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tbit;\n{\n\tu_int16_t\t\t\tf;\n\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tf = CSR_READ_2(sc, TL_DIO_DATA + (reg & 3));\n\tf &= ~bit;\n\tCSR_WRITE_2(sc, TL_DIO_DATA + (reg & 3), f);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/if_tlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void tl_dio_clrbit16"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "TL_DIO_DATA + (reg & 3)",
            "f"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_2",
          "args": [
            "sc",
            "TL_DIO_DATA + (reg & 3)"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "TL_DIO_ADDR",
            "reg"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_dio_clrbit16;\n\nvoid tl_dio_clrbit16(sc, reg, bit)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tbit;\n{\n\tu_int16_t\t\t\tf;\n\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tf = CSR_READ_2(sc, TL_DIO_DATA + (reg & 3));\n\tf &= ~bit;\n\tCSR_WRITE_2(sc, TL_DIO_DATA + (reg & 3), f);\n\n\treturn;\n}"
  },
  {
    "function_name": "tl_dio_setbit16",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
    "lines": "374-387",
    "snippet": "void tl_dio_setbit16(sc, reg, bit)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tbit;\n{\n\tu_int16_t\t\t\tf;\n\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tf = CSR_READ_2(sc, TL_DIO_DATA + (reg & 3));\n\tf |= bit;\n\tCSR_WRITE_2(sc, TL_DIO_DATA + (reg & 3), f);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/if_tlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void tl_dio_setbit16"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "TL_DIO_DATA + (reg & 3)",
            "f"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_2",
          "args": [
            "sc",
            "TL_DIO_DATA + (reg & 3)"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "TL_DIO_ADDR",
            "reg"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_dio_setbit16;\n\nvoid tl_dio_setbit16(sc, reg, bit)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tbit;\n{\n\tu_int16_t\t\t\tf;\n\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tf = CSR_READ_2(sc, TL_DIO_DATA + (reg & 3));\n\tf |= bit;\n\tCSR_WRITE_2(sc, TL_DIO_DATA + (reg & 3), f);\n\n\treturn;\n}"
  },
  {
    "function_name": "tl_dio_clrbit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
    "lines": "359-372",
    "snippet": "void tl_dio_clrbit(sc, reg, bit)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tbit;\n{\n\tu_int8_t\t\t\tf;\n\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tf = CSR_READ_1(sc, TL_DIO_DATA + (reg & 3));\n\tf &= ~bit;\n\tCSR_WRITE_1(sc, TL_DIO_DATA + (reg & 3), f);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/if_tlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void tl_dio_clrbit"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_WRITE_1",
          "args": [
            "sc",
            "TL_DIO_DATA + (reg & 3)",
            "f"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_1",
          "args": [
            "sc",
            "TL_DIO_DATA + (reg & 3)"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "TL_DIO_ADDR",
            "reg"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_dio_clrbit;\n\nvoid tl_dio_clrbit(sc, reg, bit)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tbit;\n{\n\tu_int8_t\t\t\tf;\n\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tf = CSR_READ_1(sc, TL_DIO_DATA + (reg & 3));\n\tf &= ~bit;\n\tCSR_WRITE_1(sc, TL_DIO_DATA + (reg & 3), f);\n\n\treturn;\n}"
  },
  {
    "function_name": "tl_dio_setbit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
    "lines": "344-357",
    "snippet": "void tl_dio_setbit(sc, reg, bit)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tbit;\n{\n\tu_int8_t\t\t\tf;\n\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tf = CSR_READ_1(sc, TL_DIO_DATA + (reg & 3));\n\tf |= bit;\n\tCSR_WRITE_1(sc, TL_DIO_DATA + (reg & 3), f);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/if_tlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void tl_dio_setbit"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_WRITE_1",
          "args": [
            "sc",
            "TL_DIO_DATA + (reg & 3)",
            "f"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_1",
          "args": [
            "sc",
            "TL_DIO_DATA + (reg & 3)"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "TL_DIO_ADDR",
            "reg"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_dio_setbit;\n\nvoid tl_dio_setbit(sc, reg, bit)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tbit;\n{\n\tu_int8_t\t\t\tf;\n\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tf = CSR_READ_1(sc, TL_DIO_DATA + (reg & 3));\n\tf |= bit;\n\tCSR_WRITE_1(sc, TL_DIO_DATA + (reg & 3), f);\n\n\treturn;\n}"
  },
  {
    "function_name": "tl_dio_write32",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
    "lines": "334-342",
    "snippet": "void tl_dio_write32(sc, reg, val)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tval;\n{\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tCSR_WRITE_4(sc, TL_DIO_DATA + (reg & 3), val);\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/if_tlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void tl_dio_write32"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TL_DIO_DATA + (reg & 3)",
            "val"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "TL_DIO_ADDR",
            "reg"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_dio_write32;\n\nvoid tl_dio_write32(sc, reg, val)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tval;\n{\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tCSR_WRITE_4(sc, TL_DIO_DATA + (reg & 3), val);\n\treturn;\n}"
  },
  {
    "function_name": "tl_dio_write16",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
    "lines": "324-332",
    "snippet": "void tl_dio_write16(sc, reg, val)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tval;\n{\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tCSR_WRITE_2(sc, TL_DIO_DATA + (reg & 3), val);\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/if_tlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void tl_dio_write16"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "TL_DIO_DATA + (reg & 3)",
            "val"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "TL_DIO_ADDR",
            "reg"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_dio_write16;\n\nvoid tl_dio_write16(sc, reg, val)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tval;\n{\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tCSR_WRITE_2(sc, TL_DIO_DATA + (reg & 3), val);\n\treturn;\n}"
  },
  {
    "function_name": "tl_dio_write8",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
    "lines": "314-322",
    "snippet": "void tl_dio_write8(sc, reg, val)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tval;\n{\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tCSR_WRITE_1(sc, TL_DIO_DATA + (reg & 3), val);\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/if_tlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void tl_dio_write8"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_WRITE_1",
          "args": [
            "sc",
            "TL_DIO_DATA + (reg & 3)",
            "val"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "TL_DIO_ADDR",
            "reg"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid tl_dio_write8;\n\nvoid tl_dio_write8(sc, reg, val)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n\tint\t\t\tval;\n{\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\tCSR_WRITE_1(sc, TL_DIO_DATA + (reg & 3), val);\n\treturn;\n}"
  },
  {
    "function_name": "tl_dio_read32",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
    "lines": "306-312",
    "snippet": "u_int32_t tl_dio_read32(sc, reg)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\treturn(CSR_READ_4(sc, TL_DIO_DATA + (reg & 3)));\n}",
    "includes": [
      "#include <dev/pci/if_tlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "u_int32_t tl_dio_read32"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "TL_DIO_DATA + (reg & 3)"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "TL_DIO_ADDR",
            "reg"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int32_t tl_dio_read32;\n\nu_int32_t tl_dio_read32(sc, reg)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\treturn(CSR_READ_4(sc, TL_DIO_DATA + (reg & 3)));\n}"
  },
  {
    "function_name": "tl_dio_read16",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
    "lines": "298-304",
    "snippet": "u_int16_t tl_dio_read16(sc, reg)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\treturn(CSR_READ_2(sc, TL_DIO_DATA + (reg & 3)));\n}",
    "includes": [
      "#include <dev/pci/if_tlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "u_int16_t tl_dio_read16"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_READ_2",
          "args": [
            "sc",
            "TL_DIO_DATA + (reg & 3)"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "TL_DIO_ADDR",
            "reg"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int16_t tl_dio_read16;\n\nu_int16_t tl_dio_read16(sc, reg)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\treturn(CSR_READ_2(sc, TL_DIO_DATA + (reg & 3)));\n}"
  },
  {
    "function_name": "tl_dio_read8",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tl.c",
    "lines": "290-296",
    "snippet": "u_int8_t tl_dio_read8(sc, reg)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\treturn(CSR_READ_1(sc, TL_DIO_DATA + (reg & 3)));\n}",
    "includes": [
      "#include <dev/pci/if_tlreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "u_int8_t tl_dio_read8"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_READ_1",
          "args": [
            "sc",
            "TL_DIO_DATA + (reg & 3)"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "TL_DIO_ADDR",
            "reg"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_tlreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int8_t tl_dio_read8;\n\nu_int8_t tl_dio_read8(sc, reg)\n\tstruct tl_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tCSR_WRITE_2(sc, TL_DIO_ADDR, reg);\n\treturn(CSR_READ_1(sc, TL_DIO_DATA + (reg & 3)));\n}"
  }
]