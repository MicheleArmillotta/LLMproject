[
  {
    "function_name": "gus_isa_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus_isa.c",
    "lines": "203-237",
    "snippet": "void\ngus_isa_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct gus_softc *sc = (void *) self;\n\tstruct isa_attach_args *ia = aux;\n\n\tsc->sc_iot = ia->ia_iot;\n\tsc->sc_iobase = ia->ia_iobase;\n\n\t/* Map i/o space */\n\tif (bus_space_map(sc->sc_iot, sc->sc_iobase, GUS_NPORT1, 0, &sc->sc_ioh1))\n\t\tpanic(\"%s: can't map io port range 1\", self->dv_xname);\n\tif (bus_space_map(sc->sc_iot, sc->sc_iobase+GUS_IOH2_OFFSET, GUS_NPORT2, 0,\n\t    &sc->sc_ioh2))\n\t\tpanic(\"%s: can't map io port range 2\", self->dv_xname);\n\n\t/* XXX Maybe we shouldn't fail on mapping this, but just assume\n\t * the card is of revision 0? */\n\tif (bus_space_map(sc->sc_iot, sc->sc_iobase+GUS_IOH3_OFFSET, GUS_NPORT3, 0,\n\t    &sc->sc_ioh3))\n\t\tpanic(\"%s: can't map io port range 3\", self->dv_xname);\n\n\tif (bus_space_map(sc->sc_iot, sc->sc_iobase+GUS_IOH4_OFFSET, GUS_NPORT4, 0,\n\t    &sc->sc_ioh4))\n\t\tpanic(\"%s: can't map io port range 4\", self->dv_xname);\n\n\tsc->sc_irq = ia->ia_irq;\n\tsc->sc_drq = ia->ia_drq;\n\tsc->sc_recdrq = ia->ia_drq2;\n\tsc->sc_isa = parent;\n\n\tgus_subattach(sc, aux);\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tgus_isa_attach"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gus_subattach",
          "args": [
            "sc",
            "aux"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "gus_subattach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "3388-3590",
          "snippet": "void\ngus_subattach(sc, ia)\n\tstruct gus_softc *sc;\n\tstruct isa_attach_args *ia;\n{\n \tint\t\ti;\n\tbus_space_tag_t iot;\n\tunsigned char\tc,d,m;\n\n\tiot = sc->sc_iot;\n\n\t/*\n\t * Figure out our board rev, and see if we need to initialize the\n\t * mixer\n\t */\n\n \tc = bus_space_read_1(iot, sc->sc_ioh3, GUS_BOARD_REV);\n\tif (c != 0xff)\n\t\tsc->sc_revision = c;\n\telse\n\t\tsc->sc_revision = 0;\n\n \tSELECT_GUS_REG(iot, sc->sc_ioh2, GUSREG_RESET);\n \tbus_space_write_1(iot, sc->sc_ioh2, GUS_DATA_HIGH, 0x00);\n\n\tgusreset(sc, GUS_MAX_VOICES); /* initialize all voices */\n\tgusreset(sc, GUS_MIN_VOICES); /* then set to just the ones we use */\n\n\t/*\n\t * Setup the IRQ and DRQ lines in software, using values from\n\t * config file\n\t */\n\n\tm = GUSMASK_LINE_IN|GUSMASK_LINE_OUT;\t\t/* disable all */\n\n\tc = ((unsigned char) gus_irq_map[ia->ia_irq]) | GUSMASK_BOTH_RQ;\n\n\tif (sc->sc_recdrq == sc->sc_drq)\n\t\td = (unsigned char) (gus_drq_map[sc->sc_drq] |\n\t\t\t\tGUSMASK_BOTH_RQ);\n\telse\n\t\td = (unsigned char) (gus_drq_map[sc->sc_drq] |\n\t\t\t\tgus_drq_map[sc->sc_recdrq] << 3);\n\n\t/*\n\t * Program the IRQ and DMA channels on the GUS.  Note that we hardwire\n\t * the GUS to only use one IRQ channel, but we give the user the\n\t * option of using two DMA channels (the other one given by the flags\n\t * option in the config file).  Two DMA channels are needed for full-\n\t * duplex operation.\n\t *\n\t * The order of these operations is very magical.\n\t */\n\n\tdisable_intr();\t\t/* XXX needed? */\n\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_REG_CONTROL, GUS_REG_IRQCTL);\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_MIX_CONTROL, m);\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_IRQCTL_CONTROL, 0x00);\n\tbus_space_write_1(iot, sc->sc_ioh1, 0x0f, 0x00);\n\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_MIX_CONTROL, m);\n\n\t/* magic reset? */\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_DMA_CONTROL, d | 0x80);\n\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_MIX_CONTROL,\n\t    m | GUSMASK_CONTROL_SEL);\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_IRQ_CONTROL, c);\n\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_MIX_CONTROL, m);\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_DMA_CONTROL, d);\n\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_MIX_CONTROL,\n\t    m | GUSMASK_CONTROL_SEL);\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_IRQ_CONTROL, c);\n\n\tbus_space_write_1(iot, sc->sc_ioh2, GUS_VOICE_SELECT, 0x00);\n\n\t/* enable line in, line out.  leave mic disabled. */\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_MIX_CONTROL,\n\t     (m | GUSMASK_LATCHES) & ~(GUSMASK_LINE_OUT|GUSMASK_LINE_IN));\n\tbus_space_write_1(iot, sc->sc_ioh2, GUS_VOICE_SELECT, 0x00);\n\n\tenable_intr();\n\n\tsc->sc_mixcontrol =\n\t\t(m | GUSMASK_LATCHES) & ~(GUSMASK_LINE_OUT|GUSMASK_LINE_IN);\n\n\tsc->sc_codec.sc_isa = sc->sc_isa;\n\n \tif (sc->sc_revision >= 5 && sc->sc_revision <= 9) {\n \t\tsc->sc_flags |= GUS_MIXER_INSTALLED;\n \t\tgus_init_ics2101(sc);\n\t}\n\tif (sc->sc_revision < 0xa || !gus_init_cs4231(sc)) {\n\t\t/* Not using the CS4231, so create our DMA maps. */\n\t\tif (sc->sc_drq != -1) {\n\t\t\tif (isa_dmamap_create(sc->sc_isa, sc->sc_drq,\n\t\t\t    MAX_ISADMA, BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW)) {\n\t\t\t\tprintf(\"%s: can't create map for drq %d\\n\",\n\t\t\t\t       sc->sc_dev.dv_xname, sc->sc_drq);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (sc->sc_recdrq != -1 && sc->sc_recdrq != sc->sc_drq) {\n\t\t\tif (isa_dmamap_create(sc->sc_isa, sc->sc_recdrq,\n\t\t\t    MAX_ISADMA, BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW)) {\n\t\t\t\tprintf(\"%s: can't create map for drq %d\\n\",\n\t\t\t\t       sc->sc_dev.dv_xname, sc->sc_recdrq);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n \tSELECT_GUS_REG(iot, sc->sc_ioh2, GUSREG_RESET);\n \t/*\n \t * Check to see how much memory we have on this card; see if any\n \t * \"mirroring\" occurs.  We're assuming at least 256K already exists\n \t * on the card; otherwise the initial probe would have failed\n \t */\n\n\tguspoke(iot, sc->sc_ioh2, 0L, 0x00);\n\tfor(i = 1; i < 1024; i++) {\n\t\tu_long loc;\n\n\t\t/*\n\t\t * See if we've run into mirroring yet\n\t\t */\n\n\t\tif (guspeek(iot, sc->sc_ioh2, 0L) != 0)\n\t\t\tbreak;\n\n\t\tloc = i << 10;\n\n\t\tguspoke(iot, sc->sc_ioh2, loc, 0xaa);\n\t\tif (guspeek(iot, sc->sc_ioh2, loc) != 0xaa)\n\t\t\tbreak;\n\t}\n\n\tsc->sc_dsize = i;\n\tsprintf(gus_device.version, \"3.%d\", sc->sc_revision);\n\n\tprintf(\": ver 3.%d, %dKB DRAM, \",\n\t       sc->sc_revision, sc->sc_dsize);\n\tif (HAS_MIXER(sc))\n\t\tprintf(\"ICS2101 mixer, \");\n\tif (HAS_CODEC(sc))\n\t\tprintf(\"%s codec/mixer, \", sc->sc_codec.chip_name);\n\tif (sc->sc_recdrq == sc->sc_drq) {\n\t\tprintf(\"half-duplex\");\n\t} else {\n\t\tprintf(\"full-duplex, record drq %d\", sc->sc_recdrq);\n\t}\n\n\tprintf(\"\\n\");\n\n\t/*\n\t * Setup a default interrupt handler\n\t */\n\n\t/* XXX we shouldn't have to use splgus == splclock, nor should\n\t * we use IPL_CLOCK.\n\t */\n\tsc->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq, IST_EDGE,\n\t    IPL_AUDIO, gusintr, sc /* sc->sc_gusdsp */, sc->sc_dev.dv_xname);\n\n\t/*\n\t * Set some default values\n\t * XXX others start with 8kHz mono mulaw\n\t */\n\n\tsc->sc_irate = sc->sc_orate = 44100;\n\tsc->sc_encoding = AUDIO_ENCODING_SLINEAR_LE;\n\tsc->sc_precision = 16;\n\tsc->sc_voc[GUS_VOICE_LEFT].voccntl |= GUSMASK_DATA_SIZE16;\n\tsc->sc_voc[GUS_VOICE_RIGHT].voccntl |= GUSMASK_DATA_SIZE16;\n\tsc->sc_channels = 1;\n\tsc->sc_ogain = 340;\n\tgus_commit_settings(sc);\n\n\t/*\n\t * We always put the left channel full left & right channel\n\t * full right.\n\t * For mono playback, we set up both voices playing the same buffer.\n\t */\n\tbus_space_write_1(iot, sc->sc_ioh2, GUS_VOICE_SELECT,\n\t    (u_char)GUS_VOICE_LEFT);\n\tSELECT_GUS_REG(iot, sc->sc_ioh2, GUSREG_PAN_POS);\n\tbus_space_write_1(iot, sc->sc_ioh2, GUS_DATA_HIGH, GUS_PAN_FULL_LEFT);\n\n\tbus_space_write_1(iot, sc->sc_ioh2, GUS_VOICE_SELECT,\n\t    (u_char)GUS_VOICE_RIGHT);\n\tSELECT_GUS_REG(iot, sc->sc_ioh2, GUSREG_PAN_POS);\n\tbus_space_write_1(iot, sc->sc_ioh2, GUS_DATA_HIGH, GUS_PAN_FULL_RIGHT);\n\n\t/*\n\t * Attach to the generic audio layer\n\t */\n\n\taudio_attach_mi(&gus_hw_if, HAS_CODEC(sc) ? (void *)&sc->sc_codec :\n\t    (void *)sc, &sc->sc_dev);\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int gus_irq_map[] = {\n\tIRQUNK, IRQUNK, 1, 3, IRQUNK, 2, IRQUNK, 4, IRQUNK, 1, IRQUNK, 5, 6,\n\tIRQUNK, IRQUNK, 7\n};",
            "int gus_drq_map[] = {\n\tDRQUNK, 1, DRQUNK, 2, DRQUNK, 3, 4, 5\n};",
            "struct audio_hw_if gus_hw_if = {\n\tgusopen,\n\tgusclose,\n\tNULL,\t\t\t\t/* drain */\n\n\tgus_query_encoding,\n\n\tgus_set_params,\n\n\tgus_round_blocksize,\n\n\tgus_commit_settings,\n\n\tNULL,\n\tNULL,\n\n\tgus_dma_output,\n\tgus_dma_input,\n\tgus_halt_out_dma,\n\tgus_halt_in_dma,\n\tgus_speaker_ctl,\n\n\tgus_getdev,\n\tNULL,\n\tgus_mixer_set_port,\n\tgus_mixer_get_port,\n\tgus_mixer_query_devinfo,\n\tad1848_malloc,\n\tad1848_free,\n\tad1848_round,\n\tad1848_mappage,\n\tgus_get_props,\n\n\tNULL,\n\tNULL\n};",
            "struct audio_device gus_device = {\n\t\"UltraSound\",\n\t\"\",\n\t\"gus\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint gus_irq_map[] = {\n\tIRQUNK, IRQUNK, 1, 3, IRQUNK, 2, IRQUNK, 4, IRQUNK, 1, IRQUNK, 5, 6,\n\tIRQUNK, IRQUNK, 7\n};\nint gus_drq_map[] = {\n\tDRQUNK, 1, DRQUNK, 2, DRQUNK, 3, 4, 5\n};\nstruct audio_hw_if gus_hw_if = {\n\tgusopen,\n\tgusclose,\n\tNULL,\t\t\t\t/* drain */\n\n\tgus_query_encoding,\n\n\tgus_set_params,\n\n\tgus_round_blocksize,\n\n\tgus_commit_settings,\n\n\tNULL,\n\tNULL,\n\n\tgus_dma_output,\n\tgus_dma_input,\n\tgus_halt_out_dma,\n\tgus_halt_in_dma,\n\tgus_speaker_ctl,\n\n\tgus_getdev,\n\tNULL,\n\tgus_mixer_set_port,\n\tgus_mixer_get_port,\n\tgus_mixer_query_devinfo,\n\tad1848_malloc,\n\tad1848_free,\n\tad1848_round,\n\tad1848_mappage,\n\tgus_get_props,\n\n\tNULL,\n\tNULL\n};\nstruct audio_device gus_device = {\n\t\"UltraSound\",\n\t\"\",\n\t\"gus\",\n};\n\nvoid\ngus_subattach(sc, ia)\n\tstruct gus_softc *sc;\n\tstruct isa_attach_args *ia;\n{\n \tint\t\ti;\n\tbus_space_tag_t iot;\n\tunsigned char\tc,d,m;\n\n\tiot = sc->sc_iot;\n\n\t/*\n\t * Figure out our board rev, and see if we need to initialize the\n\t * mixer\n\t */\n\n \tc = bus_space_read_1(iot, sc->sc_ioh3, GUS_BOARD_REV);\n\tif (c != 0xff)\n\t\tsc->sc_revision = c;\n\telse\n\t\tsc->sc_revision = 0;\n\n \tSELECT_GUS_REG(iot, sc->sc_ioh2, GUSREG_RESET);\n \tbus_space_write_1(iot, sc->sc_ioh2, GUS_DATA_HIGH, 0x00);\n\n\tgusreset(sc, GUS_MAX_VOICES); /* initialize all voices */\n\tgusreset(sc, GUS_MIN_VOICES); /* then set to just the ones we use */\n\n\t/*\n\t * Setup the IRQ and DRQ lines in software, using values from\n\t * config file\n\t */\n\n\tm = GUSMASK_LINE_IN|GUSMASK_LINE_OUT;\t\t/* disable all */\n\n\tc = ((unsigned char) gus_irq_map[ia->ia_irq]) | GUSMASK_BOTH_RQ;\n\n\tif (sc->sc_recdrq == sc->sc_drq)\n\t\td = (unsigned char) (gus_drq_map[sc->sc_drq] |\n\t\t\t\tGUSMASK_BOTH_RQ);\n\telse\n\t\td = (unsigned char) (gus_drq_map[sc->sc_drq] |\n\t\t\t\tgus_drq_map[sc->sc_recdrq] << 3);\n\n\t/*\n\t * Program the IRQ and DMA channels on the GUS.  Note that we hardwire\n\t * the GUS to only use one IRQ channel, but we give the user the\n\t * option of using two DMA channels (the other one given by the flags\n\t * option in the config file).  Two DMA channels are needed for full-\n\t * duplex operation.\n\t *\n\t * The order of these operations is very magical.\n\t */\n\n\tdisable_intr();\t\t/* XXX needed? */\n\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_REG_CONTROL, GUS_REG_IRQCTL);\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_MIX_CONTROL, m);\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_IRQCTL_CONTROL, 0x00);\n\tbus_space_write_1(iot, sc->sc_ioh1, 0x0f, 0x00);\n\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_MIX_CONTROL, m);\n\n\t/* magic reset? */\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_DMA_CONTROL, d | 0x80);\n\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_MIX_CONTROL,\n\t    m | GUSMASK_CONTROL_SEL);\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_IRQ_CONTROL, c);\n\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_MIX_CONTROL, m);\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_DMA_CONTROL, d);\n\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_MIX_CONTROL,\n\t    m | GUSMASK_CONTROL_SEL);\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_IRQ_CONTROL, c);\n\n\tbus_space_write_1(iot, sc->sc_ioh2, GUS_VOICE_SELECT, 0x00);\n\n\t/* enable line in, line out.  leave mic disabled. */\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_MIX_CONTROL,\n\t     (m | GUSMASK_LATCHES) & ~(GUSMASK_LINE_OUT|GUSMASK_LINE_IN));\n\tbus_space_write_1(iot, sc->sc_ioh2, GUS_VOICE_SELECT, 0x00);\n\n\tenable_intr();\n\n\tsc->sc_mixcontrol =\n\t\t(m | GUSMASK_LATCHES) & ~(GUSMASK_LINE_OUT|GUSMASK_LINE_IN);\n\n\tsc->sc_codec.sc_isa = sc->sc_isa;\n\n \tif (sc->sc_revision >= 5 && sc->sc_revision <= 9) {\n \t\tsc->sc_flags |= GUS_MIXER_INSTALLED;\n \t\tgus_init_ics2101(sc);\n\t}\n\tif (sc->sc_revision < 0xa || !gus_init_cs4231(sc)) {\n\t\t/* Not using the CS4231, so create our DMA maps. */\n\t\tif (sc->sc_drq != -1) {\n\t\t\tif (isa_dmamap_create(sc->sc_isa, sc->sc_drq,\n\t\t\t    MAX_ISADMA, BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW)) {\n\t\t\t\tprintf(\"%s: can't create map for drq %d\\n\",\n\t\t\t\t       sc->sc_dev.dv_xname, sc->sc_drq);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (sc->sc_recdrq != -1 && sc->sc_recdrq != sc->sc_drq) {\n\t\t\tif (isa_dmamap_create(sc->sc_isa, sc->sc_recdrq,\n\t\t\t    MAX_ISADMA, BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW)) {\n\t\t\t\tprintf(\"%s: can't create map for drq %d\\n\",\n\t\t\t\t       sc->sc_dev.dv_xname, sc->sc_recdrq);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n \tSELECT_GUS_REG(iot, sc->sc_ioh2, GUSREG_RESET);\n \t/*\n \t * Check to see how much memory we have on this card; see if any\n \t * \"mirroring\" occurs.  We're assuming at least 256K already exists\n \t * on the card; otherwise the initial probe would have failed\n \t */\n\n\tguspoke(iot, sc->sc_ioh2, 0L, 0x00);\n\tfor(i = 1; i < 1024; i++) {\n\t\tu_long loc;\n\n\t\t/*\n\t\t * See if we've run into mirroring yet\n\t\t */\n\n\t\tif (guspeek(iot, sc->sc_ioh2, 0L) != 0)\n\t\t\tbreak;\n\n\t\tloc = i << 10;\n\n\t\tguspoke(iot, sc->sc_ioh2, loc, 0xaa);\n\t\tif (guspeek(iot, sc->sc_ioh2, loc) != 0xaa)\n\t\t\tbreak;\n\t}\n\n\tsc->sc_dsize = i;\n\tsprintf(gus_device.version, \"3.%d\", sc->sc_revision);\n\n\tprintf(\": ver 3.%d, %dKB DRAM, \",\n\t       sc->sc_revision, sc->sc_dsize);\n\tif (HAS_MIXER(sc))\n\t\tprintf(\"ICS2101 mixer, \");\n\tif (HAS_CODEC(sc))\n\t\tprintf(\"%s codec/mixer, \", sc->sc_codec.chip_name);\n\tif (sc->sc_recdrq == sc->sc_drq) {\n\t\tprintf(\"half-duplex\");\n\t} else {\n\t\tprintf(\"full-duplex, record drq %d\", sc->sc_recdrq);\n\t}\n\n\tprintf(\"\\n\");\n\n\t/*\n\t * Setup a default interrupt handler\n\t */\n\n\t/* XXX we shouldn't have to use splgus == splclock, nor should\n\t * we use IPL_CLOCK.\n\t */\n\tsc->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq, IST_EDGE,\n\t    IPL_AUDIO, gusintr, sc /* sc->sc_gusdsp */, sc->sc_dev.dv_xname);\n\n\t/*\n\t * Set some default values\n\t * XXX others start with 8kHz mono mulaw\n\t */\n\n\tsc->sc_irate = sc->sc_orate = 44100;\n\tsc->sc_encoding = AUDIO_ENCODING_SLINEAR_LE;\n\tsc->sc_precision = 16;\n\tsc->sc_voc[GUS_VOICE_LEFT].voccntl |= GUSMASK_DATA_SIZE16;\n\tsc->sc_voc[GUS_VOICE_RIGHT].voccntl |= GUSMASK_DATA_SIZE16;\n\tsc->sc_channels = 1;\n\tsc->sc_ogain = 340;\n\tgus_commit_settings(sc);\n\n\t/*\n\t * We always put the left channel full left & right channel\n\t * full right.\n\t * For mono playback, we set up both voices playing the same buffer.\n\t */\n\tbus_space_write_1(iot, sc->sc_ioh2, GUS_VOICE_SELECT,\n\t    (u_char)GUS_VOICE_LEFT);\n\tSELECT_GUS_REG(iot, sc->sc_ioh2, GUSREG_PAN_POS);\n\tbus_space_write_1(iot, sc->sc_ioh2, GUS_DATA_HIGH, GUS_PAN_FULL_LEFT);\n\n\tbus_space_write_1(iot, sc->sc_ioh2, GUS_VOICE_SELECT,\n\t    (u_char)GUS_VOICE_RIGHT);\n\tSELECT_GUS_REG(iot, sc->sc_ioh2, GUSREG_PAN_POS);\n\tbus_space_write_1(iot, sc->sc_ioh2, GUS_DATA_HIGH, GUS_PAN_FULL_RIGHT);\n\n\t/*\n\t * Attach to the generic audio layer\n\t */\n\n\taudio_attach_mi(&gus_hw_if, HAS_CODEC(sc) ? (void *)&sc->sc_codec :\n\t    (void *)sc, &sc->sc_dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"%s: can't map io port range 4\"",
            "self->dv_xname"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "sc->sc_iot",
            "sc->sc_iobase+GUS_IOH4_OFFSET",
            "GUS_NPORT4",
            "0",
            "&sc->sc_ioh4"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"%s: can't map io port range 3\"",
            "self->dv_xname"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "sc->sc_iot",
            "sc->sc_iobase+GUS_IOH3_OFFSET",
            "GUS_NPORT3",
            "0",
            "&sc->sc_ioh3"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"%s: can't map io port range 2\"",
            "self->dv_xname"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "sc->sc_iot",
            "sc->sc_iobase+GUS_IOH2_OFFSET",
            "GUS_NPORT2",
            "0",
            "&sc->sc_ioh2"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"%s: can't map io port range 1\"",
            "self->dv_xname"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "sc->sc_iot",
            "sc->sc_iobase",
            "GUS_NPORT1",
            "0",
            "&sc->sc_ioh1"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tgus_isa_attach;\n\nvoid\ngus_isa_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct gus_softc *sc = (void *) self;\n\tstruct isa_attach_args *ia = aux;\n\n\tsc->sc_iot = ia->ia_iot;\n\tsc->sc_iobase = ia->ia_iobase;\n\n\t/* Map i/o space */\n\tif (bus_space_map(sc->sc_iot, sc->sc_iobase, GUS_NPORT1, 0, &sc->sc_ioh1))\n\t\tpanic(\"%s: can't map io port range 1\", self->dv_xname);\n\tif (bus_space_map(sc->sc_iot, sc->sc_iobase+GUS_IOH2_OFFSET, GUS_NPORT2, 0,\n\t    &sc->sc_ioh2))\n\t\tpanic(\"%s: can't map io port range 2\", self->dv_xname);\n\n\t/* XXX Maybe we shouldn't fail on mapping this, but just assume\n\t * the card is of revision 0? */\n\tif (bus_space_map(sc->sc_iot, sc->sc_iobase+GUS_IOH3_OFFSET, GUS_NPORT3, 0,\n\t    &sc->sc_ioh3))\n\t\tpanic(\"%s: can't map io port range 3\", self->dv_xname);\n\n\tif (bus_space_map(sc->sc_iot, sc->sc_iobase+GUS_IOH4_OFFSET, GUS_NPORT4, 0,\n\t    &sc->sc_ioh4))\n\t\tpanic(\"%s: can't map io port range 4\", self->dv_xname);\n\n\tsc->sc_irq = ia->ia_irq;\n\tsc->sc_drq = ia->ia_drq;\n\tsc->sc_recdrq = ia->ia_drq2;\n\tsc->sc_isa = parent;\n\n\tgus_subattach(sc, aux);\n}"
  },
  {
    "function_name": "gus_isa_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus_isa.c",
    "lines": "143-196",
    "snippet": "int\ngus_isa_match(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match;\n\tvoid *aux;\n{\n\tstruct isa_attach_args *ia = aux;\n\tint iobase = ia->ia_iobase;\n\tint recdrq = ia->ia_drq2;\n\n\t/*\n\t * Before we do anything else, make sure requested IRQ and DRQ are\n\t * valid for this card.\n\t */\n\n\t/* XXX range check before indexing!! */\n\tif (ia->ia_irq == IRQUNK || gus_irq_map[ia->ia_irq] == IRQUNK) {\n\t\tDPRINTF((\"gus: invalid irq %d, card not probed\\n\", ia->ia_irq));\n\t\treturn 0;\n\t}\n\n\tif (ia->ia_drq == DRQUNK || gus_drq_map[ia->ia_drq] == DRQUNK) {\n\t\tDPRINTF((\"gus: invalid drq %d, card not probed\\n\", ia->ia_drq));\n\t\treturn 0;\n\t}\n\n\tif (recdrq != DRQUNK) {\n\t\tif (recdrq > 7 || gus_drq_map[recdrq] == DRQUNK) {\n\t\t   DPRINTF((\"gus: invalid second DMA channel (%d), card not probed\\n\", recdrq));\n\t\t   return 0;\n\t        }\n\t} else\n\t\trecdrq = ia->ia_drq;\n\n\tif (iobase == IOBASEUNK) {\n\t\tint i;\n\t\tfor(i = 0; i < gus_addrs; i++)\n\t\t\tif (gus_test_iobase(ia->ia_iot, gus_base_addrs[i])) {\n\t\t\t\tiobase = gus_base_addrs[i];\n\t\t\t\tgoto done;\n\t\t\t}\n\t\treturn 0;\n\t} else if (!gus_test_iobase(ia->ia_iot, iobase))\n\t\t\treturn 0;\n\ndone:\n\tif ((ia->ia_drq    != -1 && !isa_drq_isfree(parent, ia->ia_drq)) ||\n\t    (recdrq != -1 && !isa_drq_isfree(parent, recdrq)))\n\t\treturn 0;\n\n\tia->ia_iobase = iobase;\n\tia->ia_iosize = GUS_NPORT1;\n\treturn 1;\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tgus_isa_match"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "isa_drq_isfree",
          "args": [
            "parent",
            "recdrq"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "isa_drq_isfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/isadma.c",
          "lines": "658-669",
          "snippet": "int\nisa_drq_isfree(isadev, chan)\n\tstruct device *isadev;\n\tint chan;\n{\n\tstruct isa_softc *sc = (struct isa_softc *)isadev;\n\tif (chan < 0 || chan > 7) {\n\t\tpanic(\"isa_drq_isfree: %s: bogus drq %d\", sc->sc_dev.dv_xname,\n\t\t    chan);\n\t}\n\treturn ISA_DRQ_ISFREE(sc, chan);\n}",
          "includes": [
            "#include <sys/malloc.h>",
            "#include <dev/isa/isadmareg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\nisa_malloc(isadev, chan, size, pool, flags)\n\tstruct device *isadev;",
            "int chan;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/malloc.h>\n#include <dev/isa/isadmareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid *\nisa_malloc(isadev, chan, size, pool, flags)\n\tstruct device *isadev;\nint chan;\n\nint\nisa_drq_isfree(isadev, chan)\n\tstruct device *isadev;\n\tint chan;\n{\n\tstruct isa_softc *sc = (struct isa_softc *)isadev;\n\tif (chan < 0 || chan > 7) {\n\t\tpanic(\"isa_drq_isfree: %s: bogus drq %d\", sc->sc_dev.dv_xname,\n\t\t    chan);\n\t}\n\treturn ISA_DRQ_ISFREE(sc, chan);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gus_test_iobase",
          "args": [
            "ia->ia_iot",
            "iobase"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "gus_test_iobase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "3597-3666",
          "snippet": "int\ngus_test_iobase (iot, iobase)\n\tbus_space_tag_t iot;\n\tint iobase;\n{\n\tbus_space_handle_t ioh1, ioh2, ioh3, ioh4;\n\tu_char s1, s2;\n\tint s, rv = 0;\n\n\t/* Map i/o space */\n\tif (bus_space_map(iot, iobase, GUS_NPORT1, 0, &ioh1))\n\t\treturn 0;\n\tif (bus_space_map(iot, iobase+GUS_IOH2_OFFSET, GUS_NPORT2, 0, &ioh2))\n\t\tgoto bad1;\n\n\t/* XXX Maybe we shouldn't fail on mapping this, but just assume\n\t * the card is of revision 0? */\n\tif (bus_space_map(iot, iobase+GUS_IOH3_OFFSET, GUS_NPORT3, 0, &ioh3))\n\t\tgoto bad2;\n\n\tif (bus_space_map(iot, iobase+GUS_IOH4_OFFSET, GUS_NPORT4, 0, &ioh4))\n\t\tgoto bad3;\n\n\t/*\n\t * Reset GUS to an initial state before we do anything.\n\t */\n\n\ts = splgus();\n\tdelay(500);\n\n \tSELECT_GUS_REG(iot, ioh2, GUSREG_RESET);\n \tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0x00);\n\n \tdelay(500);\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_RESET);\n \tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, GUSMASK_MASTER_RESET);\n\n \tdelay(500);\n\n\tsplx(s);\n\n\t/*\n\t * See if we can write to the board's memory\n\t */\n\n \ts1 = guspeek(iot, ioh2, 0L);\n \ts2 = guspeek(iot, ioh2, 1L);\n\n \tguspoke(iot, ioh2, 0L, 0xaa);\n \tguspoke(iot, ioh2, 1L, 0x55);\n\n \tif (guspeek(iot, ioh2, 0L) != 0xaa)\n\t\tgoto bad;\n\n\tguspoke(iot, ioh2, 0L, s1);\n\tguspoke(iot, ioh2, 1L, s2);\n\n\trv = 1;\n\nbad:\n\tbus_space_unmap(iot, ioh4, GUS_NPORT4);\nbad3:\n\tbus_space_unmap(iot, ioh3, GUS_NPORT3);\nbad2:\n\tbus_space_unmap(iot, ioh2, GUS_NPORT2);\nbad1:\n\tbus_space_unmap(iot, ioh1, GUS_NPORT1);\n\treturn rv;\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ngus_test_iobase (iot, iobase)\n\tbus_space_tag_t iot;\n\tint iobase;\n{\n\tbus_space_handle_t ioh1, ioh2, ioh3, ioh4;\n\tu_char s1, s2;\n\tint s, rv = 0;\n\n\t/* Map i/o space */\n\tif (bus_space_map(iot, iobase, GUS_NPORT1, 0, &ioh1))\n\t\treturn 0;\n\tif (bus_space_map(iot, iobase+GUS_IOH2_OFFSET, GUS_NPORT2, 0, &ioh2))\n\t\tgoto bad1;\n\n\t/* XXX Maybe we shouldn't fail on mapping this, but just assume\n\t * the card is of revision 0? */\n\tif (bus_space_map(iot, iobase+GUS_IOH3_OFFSET, GUS_NPORT3, 0, &ioh3))\n\t\tgoto bad2;\n\n\tif (bus_space_map(iot, iobase+GUS_IOH4_OFFSET, GUS_NPORT4, 0, &ioh4))\n\t\tgoto bad3;\n\n\t/*\n\t * Reset GUS to an initial state before we do anything.\n\t */\n\n\ts = splgus();\n\tdelay(500);\n\n \tSELECT_GUS_REG(iot, ioh2, GUSREG_RESET);\n \tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0x00);\n\n \tdelay(500);\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_RESET);\n \tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, GUSMASK_MASTER_RESET);\n\n \tdelay(500);\n\n\tsplx(s);\n\n\t/*\n\t * See if we can write to the board's memory\n\t */\n\n \ts1 = guspeek(iot, ioh2, 0L);\n \ts2 = guspeek(iot, ioh2, 1L);\n\n \tguspoke(iot, ioh2, 0L, 0xaa);\n \tguspoke(iot, ioh2, 1L, 0x55);\n\n \tif (guspeek(iot, ioh2, 0L) != 0xaa)\n\t\tgoto bad;\n\n\tguspoke(iot, ioh2, 0L, s1);\n\tguspoke(iot, ioh2, 1L, s2);\n\n\trv = 1;\n\nbad:\n\tbus_space_unmap(iot, ioh4, GUS_NPORT4);\nbad3:\n\tbus_space_unmap(iot, ioh3, GUS_NPORT3);\nbad2:\n\tbus_space_unmap(iot, ioh2, GUS_NPORT2);\nbad1:\n\tbus_space_unmap(iot, ioh1, GUS_NPORT1);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"gus: invalid second DMA channel (%d), card not probed\\n\", recdrq)"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"gus: invalid drq %d, card not probed\\n\", ia->ia_drq)"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"gus: invalid irq %d, card not probed\\n\", ia->ia_irq)"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tgus_isa_match;\n\nint\ngus_isa_match(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match;\n\tvoid *aux;\n{\n\tstruct isa_attach_args *ia = aux;\n\tint iobase = ia->ia_iobase;\n\tint recdrq = ia->ia_drq2;\n\n\t/*\n\t * Before we do anything else, make sure requested IRQ and DRQ are\n\t * valid for this card.\n\t */\n\n\t/* XXX range check before indexing!! */\n\tif (ia->ia_irq == IRQUNK || gus_irq_map[ia->ia_irq] == IRQUNK) {\n\t\tDPRINTF((\"gus: invalid irq %d, card not probed\\n\", ia->ia_irq));\n\t\treturn 0;\n\t}\n\n\tif (ia->ia_drq == DRQUNK || gus_drq_map[ia->ia_drq] == DRQUNK) {\n\t\tDPRINTF((\"gus: invalid drq %d, card not probed\\n\", ia->ia_drq));\n\t\treturn 0;\n\t}\n\n\tif (recdrq != DRQUNK) {\n\t\tif (recdrq > 7 || gus_drq_map[recdrq] == DRQUNK) {\n\t\t   DPRINTF((\"gus: invalid second DMA channel (%d), card not probed\\n\", recdrq));\n\t\t   return 0;\n\t        }\n\t} else\n\t\trecdrq = ia->ia_drq;\n\n\tif (iobase == IOBASEUNK) {\n\t\tint i;\n\t\tfor(i = 0; i < gus_addrs; i++)\n\t\t\tif (gus_test_iobase(ia->ia_iot, gus_base_addrs[i])) {\n\t\t\t\tiobase = gus_base_addrs[i];\n\t\t\t\tgoto done;\n\t\t\t}\n\t\treturn 0;\n\t} else if (!gus_test_iobase(ia->ia_iot, iobase))\n\t\t\treturn 0;\n\ndone:\n\tif ((ia->ia_drq    != -1 && !isa_drq_isfree(parent, ia->ia_drq)) ||\n\t    (recdrq != -1 && !isa_drq_isfree(parent, recdrq)))\n\t\treturn 0;\n\n\tia->ia_iobase = iobase;\n\tia->ia_iosize = GUS_NPORT1;\n\treturn 1;\n}"
  }
]