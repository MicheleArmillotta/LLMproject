[
  {
    "function_name": "cue_shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_cue.c",
    "lines": "1608-1618",
    "snippet": "Static void\ncue_shutdown(dev)\n\tdevice_t\t\tdev;\n{\n\tstruct cue_softc\t*sc;\n\n\tsc = device_get_softc(dev);\n\n\tcue_reset(sc);\n\tcue_stop(sc);\n}",
    "includes": [
      "#include <dev/usb/if_cuereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "cue_open_pipes\t__P((struct cue_softc *));",
      "Static int",
      "cue_tx_list_init\t__P((struct cue_softc *));",
      "Static int",
      "cue_rx_list_init\t__P((struct cue_softc *));",
      "Static int",
      "Static int",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "cue_stop\t\t__P((struct cue_softc *));",
      "Static void",
      "Static void",
      "cue_setmulti\t__P((struct cue_softc *));",
      "Static void",
      "cue_reset\t\t__P((struct cue_softc *));",
      "Static int",
      "cue_csr_read_1\t__P((struct cue_softc *, int));",
      "Static int",
      "cue_csr_write_1\t__P((struct cue_softc *, int, int));",
      "Static int",
      "cue_csr_read_2\t__P((struct cue_softc *, int));",
      "Static int",
      "cue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));",
      "Static int",
      "cue_getmac\t\t__P((struct cue_softc *, void *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cue_stop",
          "args": [
            "sc"
          ],
          "line": 1617
        },
        "resolved": true,
        "details": {
          "function_name": "cue_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_cue.c",
          "lines": "1516-1601",
          "snippet": "Static void\ncue_stop(sc)\n\tstruct cue_softc\t*sc;\n{\n\tusbd_status\t\terr;\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\ti;\n\n\tDPRINTFN(10,(\"%s: %s: enter\\n\", USBDEVNAME(sc->cue_dev),__FUNCTION__));\n\n\tifp = GET_IFP(sc);\n\tifp->if_timer = 0;\n\n\tcue_csr_write_1(sc, CUE_ETHCTL, 0);\n\tcue_reset(sc);\n\tusb_uncallout(sc->cue_stat_ch, cue_tick, sc);\n\n\t/* Stop transfers. */\n\tif (sc->cue_ep[CUE_ENDPT_RX] != NULL) {\n\t\terr = usbd_abort_pipe(sc->cue_ep[CUE_ENDPT_RX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort rx pipe failed: %s\\n\",\n\t\t\tUSBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->cue_ep[CUE_ENDPT_RX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close rx pipe failed: %s\\n\",\n\t\t\tUSBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->cue_ep[CUE_ENDPT_RX] = NULL;\n\t}\n\n\tif (sc->cue_ep[CUE_ENDPT_TX] != NULL) {\n\t\terr = usbd_abort_pipe(sc->cue_ep[CUE_ENDPT_TX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort tx pipe failed: %s\\n\",\n\t\t\tUSBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->cue_ep[CUE_ENDPT_TX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close tx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->cue_ep[CUE_ENDPT_TX] = NULL;\n\t}\n\n\tif (sc->cue_ep[CUE_ENDPT_INTR] != NULL) {\n\t\terr = usbd_abort_pipe(sc->cue_ep[CUE_ENDPT_INTR]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort intr pipe failed: %s\\n\",\n\t\t\tUSBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->cue_ep[CUE_ENDPT_INTR]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close intr pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->cue_ep[CUE_ENDPT_INTR] = NULL;\n\t}\n\n\t/* Free RX resources. */\n\tfor (i = 0; i < CUE_RX_LIST_CNT; i++) {\n\t\tif (sc->cue_cdata.cue_rx_chain[i].cue_mbuf != NULL) {\n\t\t\tm_freem(sc->cue_cdata.cue_rx_chain[i].cue_mbuf);\n\t\t\tsc->cue_cdata.cue_rx_chain[i].cue_mbuf = NULL;\n\t\t}\n\t\tif (sc->cue_cdata.cue_rx_chain[i].cue_xfer != NULL) {\n\t\t\tusbd_free_xfer(sc->cue_cdata.cue_rx_chain[i].cue_xfer);\n\t\t\tsc->cue_cdata.cue_rx_chain[i].cue_xfer = NULL;\n\t\t}\n\t}\n\n\t/* Free TX resources. */\n\tfor (i = 0; i < CUE_TX_LIST_CNT; i++) {\n\t\tif (sc->cue_cdata.cue_tx_chain[i].cue_mbuf != NULL) {\n\t\t\tm_freem(sc->cue_cdata.cue_tx_chain[i].cue_mbuf);\n\t\t\tsc->cue_cdata.cue_tx_chain[i].cue_mbuf = NULL;\n\t\t}\n\t\tif (sc->cue_cdata.cue_tx_chain[i].cue_xfer != NULL) {\n\t\t\tusbd_free_xfer(sc->cue_cdata.cue_tx_chain[i].cue_xfer);\n\t\t\tsc->cue_cdata.cue_tx_chain[i].cue_xfer = NULL;\n\t\t}\n\t}\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n}",
          "includes": [
            "#include <dev/usb/if_cuereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "cue_open_pipes\t__P((struct cue_softc *));",
            "Static int",
            "cue_tx_list_init\t__P((struct cue_softc *));",
            "Static int",
            "cue_rx_list_init\t__P((struct cue_softc *));",
            "Static int",
            "Static int",
            "Static void",
            "cue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "cue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "Static void",
            "cue_start\t\t__P((struct ifnet *));",
            "Static int",
            "Static void",
            "Static void",
            "cue_stop\t\t__P((struct cue_softc *));",
            "Static void",
            "cue_watchdog\t\t__P((struct ifnet *));",
            "Static void",
            "cue_setmulti\t__P((struct cue_softc *));",
            "Static void",
            "cue_reset\t\t__P((struct cue_softc *));",
            "Static int",
            "cue_csr_read_1\t__P((struct cue_softc *, int));",
            "Static int",
            "cue_csr_write_1\t__P((struct cue_softc *, int, int));",
            "Static int",
            "cue_csr_read_2\t__P((struct cue_softc *, int));",
            "Static int",
            "cue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));",
            "Static int",
            "cue_getmac\t\t__P((struct cue_softc *, void *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/if_cuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\ncue_open_pipes\t__P((struct cue_softc *));\nStatic int;\ncue_tx_list_init\t__P((struct cue_softc *));\nStatic int;\ncue_rx_list_init\t__P((struct cue_softc *));\nStatic int;\nStatic int;\nStatic void;\ncue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\ncue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic void;\ncue_start\t\t__P((struct ifnet *));\nStatic int;\nStatic void;\nStatic void;\ncue_stop\t\t__P((struct cue_softc *));\nStatic void;\ncue_watchdog\t\t__P((struct ifnet *));\nStatic void;\ncue_setmulti\t__P((struct cue_softc *));\nStatic void;\ncue_reset\t\t__P((struct cue_softc *));\nStatic int;\ncue_csr_read_1\t__P((struct cue_softc *, int));\nStatic int;\ncue_csr_write_1\t__P((struct cue_softc *, int, int));\nStatic int;\ncue_csr_read_2\t__P((struct cue_softc *, int));\nStatic int;\ncue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));\nStatic int;\ncue_getmac\t\t__P((struct cue_softc *, void *));\n\nStatic void\ncue_stop(sc)\n\tstruct cue_softc\t*sc;\n{\n\tusbd_status\t\terr;\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\ti;\n\n\tDPRINTFN(10,(\"%s: %s: enter\\n\", USBDEVNAME(sc->cue_dev),__FUNCTION__));\n\n\tifp = GET_IFP(sc);\n\tifp->if_timer = 0;\n\n\tcue_csr_write_1(sc, CUE_ETHCTL, 0);\n\tcue_reset(sc);\n\tusb_uncallout(sc->cue_stat_ch, cue_tick, sc);\n\n\t/* Stop transfers. */\n\tif (sc->cue_ep[CUE_ENDPT_RX] != NULL) {\n\t\terr = usbd_abort_pipe(sc->cue_ep[CUE_ENDPT_RX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort rx pipe failed: %s\\n\",\n\t\t\tUSBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->cue_ep[CUE_ENDPT_RX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close rx pipe failed: %s\\n\",\n\t\t\tUSBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->cue_ep[CUE_ENDPT_RX] = NULL;\n\t}\n\n\tif (sc->cue_ep[CUE_ENDPT_TX] != NULL) {\n\t\terr = usbd_abort_pipe(sc->cue_ep[CUE_ENDPT_TX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort tx pipe failed: %s\\n\",\n\t\t\tUSBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->cue_ep[CUE_ENDPT_TX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close tx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->cue_ep[CUE_ENDPT_TX] = NULL;\n\t}\n\n\tif (sc->cue_ep[CUE_ENDPT_INTR] != NULL) {\n\t\terr = usbd_abort_pipe(sc->cue_ep[CUE_ENDPT_INTR]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort intr pipe failed: %s\\n\",\n\t\t\tUSBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->cue_ep[CUE_ENDPT_INTR]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close intr pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->cue_ep[CUE_ENDPT_INTR] = NULL;\n\t}\n\n\t/* Free RX resources. */\n\tfor (i = 0; i < CUE_RX_LIST_CNT; i++) {\n\t\tif (sc->cue_cdata.cue_rx_chain[i].cue_mbuf != NULL) {\n\t\t\tm_freem(sc->cue_cdata.cue_rx_chain[i].cue_mbuf);\n\t\t\tsc->cue_cdata.cue_rx_chain[i].cue_mbuf = NULL;\n\t\t}\n\t\tif (sc->cue_cdata.cue_rx_chain[i].cue_xfer != NULL) {\n\t\t\tusbd_free_xfer(sc->cue_cdata.cue_rx_chain[i].cue_xfer);\n\t\t\tsc->cue_cdata.cue_rx_chain[i].cue_xfer = NULL;\n\t\t}\n\t}\n\n\t/* Free TX resources. */\n\tfor (i = 0; i < CUE_TX_LIST_CNT; i++) {\n\t\tif (sc->cue_cdata.cue_tx_chain[i].cue_mbuf != NULL) {\n\t\t\tm_freem(sc->cue_cdata.cue_tx_chain[i].cue_mbuf);\n\t\t\tsc->cue_cdata.cue_tx_chain[i].cue_mbuf = NULL;\n\t\t}\n\t\tif (sc->cue_cdata.cue_tx_chain[i].cue_xfer != NULL) {\n\t\t\tusbd_free_xfer(sc->cue_cdata.cue_tx_chain[i].cue_xfer);\n\t\t\tsc->cue_cdata.cue_tx_chain[i].cue_xfer = NULL;\n\t\t}\n\t}\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cue_reset",
          "args": [
            "sc"
          ],
          "line": 1616
        },
        "resolved": true,
        "details": {
          "function_name": "cue_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_cue.c",
          "lines": "548-576",
          "snippet": "Static void\ncue_reset(sc)\n\tstruct cue_softc\t*sc;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tint\t\t\ts;\n\n\tDPRINTFN(2,(\"%s: cue_reset\\n\", USBDEVNAME(sc->cue_dev)));\n\n\tif (sc->cue_dying)\n\t\treturn;\n\n\treq.bmRequestType = UT_WRITE_VENDOR_DEVICE;\n\treq.bRequest = CUE_CMD_RESET;\n\tUSETW(req.wValue, 0);\n\tUSETW(req.wIndex, 0);\n\tUSETW(req.wLength, 0);\n\n\ts = splusb();\n\terr = CUE_DO_REQUEST(sc->cue_udev, &req, NULL);\n\tsplx(s);\n\n\tif (err)\n\t\tprintf(\"%s: reset failed\\n\", USBDEVNAME(sc->cue_dev));\n\n\t/* Wait a little while for the chip to get its brains in order. */\n\tdelay(1000);\t\t/* XXX */\n}",
          "includes": [
            "#include <dev/usb/if_cuereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "cue_open_pipes\t__P((struct cue_softc *));",
            "Static int",
            "cue_tx_list_init\t__P((struct cue_softc *));",
            "Static int",
            "cue_rx_list_init\t__P((struct cue_softc *));",
            "Static int",
            "Static int",
            "Static void",
            "cue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "cue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "cue_stop\t\t__P((struct cue_softc *));",
            "Static void",
            "Static void",
            "cue_setmulti\t__P((struct cue_softc *));",
            "Static void",
            "cue_reset\t\t__P((struct cue_softc *));",
            "Static int",
            "cue_csr_read_1\t__P((struct cue_softc *, int));",
            "Static int",
            "cue_csr_write_1\t__P((struct cue_softc *, int, int));",
            "Static int",
            "cue_csr_read_2\t__P((struct cue_softc *, int));",
            "Static int",
            "cue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));",
            "Static int",
            "cue_getmac\t\t__P((struct cue_softc *, void *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/if_cuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\ncue_open_pipes\t__P((struct cue_softc *));\nStatic int;\ncue_tx_list_init\t__P((struct cue_softc *));\nStatic int;\ncue_rx_list_init\t__P((struct cue_softc *));\nStatic int;\nStatic int;\nStatic void;\ncue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\ncue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\ncue_stop\t\t__P((struct cue_softc *));\nStatic void;\nStatic void;\ncue_setmulti\t__P((struct cue_softc *));\nStatic void;\ncue_reset\t\t__P((struct cue_softc *));\nStatic int;\ncue_csr_read_1\t__P((struct cue_softc *, int));\nStatic int;\ncue_csr_write_1\t__P((struct cue_softc *, int, int));\nStatic int;\ncue_csr_read_2\t__P((struct cue_softc *, int));\nStatic int;\ncue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));\nStatic int;\ncue_getmac\t\t__P((struct cue_softc *, void *));\n\nStatic void\ncue_reset(sc)\n\tstruct cue_softc\t*sc;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tint\t\t\ts;\n\n\tDPRINTFN(2,(\"%s: cue_reset\\n\", USBDEVNAME(sc->cue_dev)));\n\n\tif (sc->cue_dying)\n\t\treturn;\n\n\treq.bmRequestType = UT_WRITE_VENDOR_DEVICE;\n\treq.bRequest = CUE_CMD_RESET;\n\tUSETW(req.wValue, 0);\n\tUSETW(req.wIndex, 0);\n\tUSETW(req.wLength, 0);\n\n\ts = splusb();\n\terr = CUE_DO_REQUEST(sc->cue_udev, &req, NULL);\n\tsplx(s);\n\n\tif (err)\n\t\tprintf(\"%s: reset failed\\n\", USBDEVNAME(sc->cue_dev));\n\n\t/* Wait a little while for the chip to get its brains in order. */\n\tdelay(1000);\t\t/* XXX */\n}"
        }
      },
      {
        "call_info": {
          "callee": "device_get_softc",
          "args": [
            "dev"
          ],
          "line": 1614
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/if_cuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\ncue_open_pipes\t__P((struct cue_softc *));\nStatic int;\ncue_tx_list_init\t__P((struct cue_softc *));\nStatic int;\ncue_rx_list_init\t__P((struct cue_softc *));\nStatic int;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\ncue_stop\t\t__P((struct cue_softc *));\nStatic void;\nStatic void;\ncue_setmulti\t__P((struct cue_softc *));\nStatic void;\ncue_reset\t\t__P((struct cue_softc *));\nStatic int;\ncue_csr_read_1\t__P((struct cue_softc *, int));\nStatic int;\ncue_csr_write_1\t__P((struct cue_softc *, int, int));\nStatic int;\ncue_csr_read_2\t__P((struct cue_softc *, int));\nStatic int;\ncue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));\nStatic int;\ncue_getmac\t\t__P((struct cue_softc *, void *));\n\nStatic void\ncue_shutdown(dev)\n\tdevice_t\t\tdev;\n{\n\tstruct cue_softc\t*sc;\n\n\tsc = device_get_softc(dev);\n\n\tcue_reset(sc);\n\tcue_stop(sc);\n}"
  },
  {
    "function_name": "cue_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_cue.c",
    "lines": "1516-1601",
    "snippet": "Static void\ncue_stop(sc)\n\tstruct cue_softc\t*sc;\n{\n\tusbd_status\t\terr;\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\ti;\n\n\tDPRINTFN(10,(\"%s: %s: enter\\n\", USBDEVNAME(sc->cue_dev),__FUNCTION__));\n\n\tifp = GET_IFP(sc);\n\tifp->if_timer = 0;\n\n\tcue_csr_write_1(sc, CUE_ETHCTL, 0);\n\tcue_reset(sc);\n\tusb_uncallout(sc->cue_stat_ch, cue_tick, sc);\n\n\t/* Stop transfers. */\n\tif (sc->cue_ep[CUE_ENDPT_RX] != NULL) {\n\t\terr = usbd_abort_pipe(sc->cue_ep[CUE_ENDPT_RX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort rx pipe failed: %s\\n\",\n\t\t\tUSBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->cue_ep[CUE_ENDPT_RX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close rx pipe failed: %s\\n\",\n\t\t\tUSBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->cue_ep[CUE_ENDPT_RX] = NULL;\n\t}\n\n\tif (sc->cue_ep[CUE_ENDPT_TX] != NULL) {\n\t\terr = usbd_abort_pipe(sc->cue_ep[CUE_ENDPT_TX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort tx pipe failed: %s\\n\",\n\t\t\tUSBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->cue_ep[CUE_ENDPT_TX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close tx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->cue_ep[CUE_ENDPT_TX] = NULL;\n\t}\n\n\tif (sc->cue_ep[CUE_ENDPT_INTR] != NULL) {\n\t\terr = usbd_abort_pipe(sc->cue_ep[CUE_ENDPT_INTR]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort intr pipe failed: %s\\n\",\n\t\t\tUSBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->cue_ep[CUE_ENDPT_INTR]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close intr pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->cue_ep[CUE_ENDPT_INTR] = NULL;\n\t}\n\n\t/* Free RX resources. */\n\tfor (i = 0; i < CUE_RX_LIST_CNT; i++) {\n\t\tif (sc->cue_cdata.cue_rx_chain[i].cue_mbuf != NULL) {\n\t\t\tm_freem(sc->cue_cdata.cue_rx_chain[i].cue_mbuf);\n\t\t\tsc->cue_cdata.cue_rx_chain[i].cue_mbuf = NULL;\n\t\t}\n\t\tif (sc->cue_cdata.cue_rx_chain[i].cue_xfer != NULL) {\n\t\t\tusbd_free_xfer(sc->cue_cdata.cue_rx_chain[i].cue_xfer);\n\t\t\tsc->cue_cdata.cue_rx_chain[i].cue_xfer = NULL;\n\t\t}\n\t}\n\n\t/* Free TX resources. */\n\tfor (i = 0; i < CUE_TX_LIST_CNT; i++) {\n\t\tif (sc->cue_cdata.cue_tx_chain[i].cue_mbuf != NULL) {\n\t\t\tm_freem(sc->cue_cdata.cue_tx_chain[i].cue_mbuf);\n\t\t\tsc->cue_cdata.cue_tx_chain[i].cue_mbuf = NULL;\n\t\t}\n\t\tif (sc->cue_cdata.cue_tx_chain[i].cue_xfer != NULL) {\n\t\t\tusbd_free_xfer(sc->cue_cdata.cue_tx_chain[i].cue_xfer);\n\t\t\tsc->cue_cdata.cue_tx_chain[i].cue_xfer = NULL;\n\t\t}\n\t}\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n}",
    "includes": [
      "#include <dev/usb/if_cuereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "cue_open_pipes\t__P((struct cue_softc *));",
      "Static int",
      "cue_tx_list_init\t__P((struct cue_softc *));",
      "Static int",
      "cue_rx_list_init\t__P((struct cue_softc *));",
      "Static int",
      "Static int",
      "Static void",
      "cue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "cue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "Static void",
      "cue_start\t\t__P((struct ifnet *));",
      "Static int",
      "Static void",
      "Static void",
      "cue_stop\t\t__P((struct cue_softc *));",
      "Static void",
      "cue_watchdog\t\t__P((struct ifnet *));",
      "Static void",
      "cue_setmulti\t__P((struct cue_softc *));",
      "Static void",
      "cue_reset\t\t__P((struct cue_softc *));",
      "Static int",
      "cue_csr_read_1\t__P((struct cue_softc *, int));",
      "Static int",
      "cue_csr_write_1\t__P((struct cue_softc *, int, int));",
      "Static int",
      "cue_csr_read_2\t__P((struct cue_softc *, int));",
      "Static int",
      "cue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));",
      "Static int",
      "cue_getmac\t\t__P((struct cue_softc *, void *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usbd_free_xfer",
          "args": [
            "sc->cue_cdata.cue_tx_chain[i].cue_xfer"
          ],
          "line": 1595
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_free_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "403-418",
          "snippet": "usbd_status \nusbd_free_xfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tDPRINTFN(5,(\"usbd_free_xfer: %p\\n\", xfer));\n\tif (xfer->rqflags & (URQ_DEV_DMABUF | URQ_AUTO_DMABUF))\n\t\tusbd_free_buffer(xfer);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&xfer->timeout_handle)) {\n\t\tcallout_stop(&xfer->timeout_handle);\n\t\tprintf(\"usbd_free_xfer: timout_handle pending\");\n\t}\n#endif\n\txfer->device->bus->methods->freex(xfer->device->bus, xfer);\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static usbd_status",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\n\nusbd_status \nusbd_free_xfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tDPRINTFN(5,(\"usbd_free_xfer: %p\\n\", xfer));\n\tif (xfer->rqflags & (URQ_DEV_DMABUF | URQ_AUTO_DMABUF))\n\t\tusbd_free_buffer(xfer);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&xfer->timeout_handle)) {\n\t\tcallout_stop(&xfer->timeout_handle);\n\t\tprintf(\"usbd_free_xfer: timout_handle pending\");\n\t}\n#endif\n\txfer->device->bus->methods->freex(xfer->device->bus, xfer);\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "sc->cue_cdata.cue_tx_chain[i].cue_mbuf"
          ],
          "line": 1591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "sc->cue_cdata.cue_rx_chain[i].cue_mbuf"
          ],
          "line": 1579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: close intr pipe failed: %s\\n\"",
            "USBDEVNAME(sc->cue_dev)",
            "usbd_errstr(err)"
          ],
          "line": 1570
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 1571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->cue_dev"
          ],
          "line": 1571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_close_pipe",
          "args": [
            "sc->cue_ep[CUE_ENDPT_INTR]"
          ],
          "line": 1568
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_close_pipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "224-252",
          "snippet": "usbd_status\nusbd_close_pipe(pipe)\n\tusbd_pipe_handle pipe;\n{\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_close_pipe: pipe==NULL\\n\");\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n#endif\n\n\tif (--pipe->refcnt != 0)\n\t\treturn (USBD_NORMAL_COMPLETION);\n\tif (SIMPLEQ_FIRST(&pipe->queue) != 0)\n\t\treturn (USBD_PENDING_REQUESTS);\n\tLIST_REMOVE(pipe, next);\n\tpipe->endpoint->refcnt--;\n\tpipe->methods->close(pipe);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&pipe->abort_handle)) {\n\t\tcallout_stop(&pipe->abort_handle);\n\t\tprintf(\"usbd_close_pipe: abort_handle pending\");\n\t}\n#endif\n\tif (pipe->intrxfer != NULL)\n\t\tusbd_free_xfer(pipe->intrxfer);\n\tfree(pipe, M_USB);\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nusbd_status\nusbd_close_pipe(pipe)\n\tusbd_pipe_handle pipe;\n{\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_close_pipe: pipe==NULL\\n\");\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n#endif\n\n\tif (--pipe->refcnt != 0)\n\t\treturn (USBD_NORMAL_COMPLETION);\n\tif (SIMPLEQ_FIRST(&pipe->queue) != 0)\n\t\treturn (USBD_PENDING_REQUESTS);\n\tLIST_REMOVE(pipe, next);\n\tpipe->endpoint->refcnt--;\n\tpipe->methods->close(pipe);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&pipe->abort_handle)) {\n\t\tcallout_stop(&pipe->abort_handle);\n\t\tprintf(\"usbd_close_pipe: abort_handle pending\");\n\t}\n#endif\n\tif (pipe->intrxfer != NULL)\n\t\tusbd_free_xfer(pipe->intrxfer);\n\tfree(pipe, M_USB);\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 1566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->cue_dev"
          ],
          "line": 1566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_abort_pipe",
          "args": [
            "sc->cue_ep[CUE_ENDPT_INTR]"
          ],
          "line": 1563
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_abort_pipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "560-577",
          "snippet": "usbd_status \nusbd_abort_pipe(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tusbd_status err;\n\tint s;\n\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_close_pipe: pipe==NULL\\n\");\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n#endif\n\ts = splusb();\n\terr = usbd_ar_pipe(pipe);\n\tsplx(s);\n\treturn (err);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nusbd_status \nusbd_abort_pipe(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tusbd_status err;\n\tint s;\n\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_close_pipe: pipe==NULL\\n\");\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n#endif\n\ts = splusb();\n\terr = usbd_ar_pipe(pipe);\n\tsplx(s);\n\treturn (err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 1557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->cue_dev"
          ],
          "line": 1557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 1552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->cue_dev"
          ],
          "line": 1552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 1543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->cue_dev"
          ],
          "line": 1543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->cue_dev"
          ],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_uncallout",
          "args": [
            "sc->cue_stat_ch",
            "cue_tick",
            "sc"
          ],
          "line": 1531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cue_reset",
          "args": [
            "sc"
          ],
          "line": 1530
        },
        "resolved": true,
        "details": {
          "function_name": "cue_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_cue.c",
          "lines": "548-576",
          "snippet": "Static void\ncue_reset(sc)\n\tstruct cue_softc\t*sc;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tint\t\t\ts;\n\n\tDPRINTFN(2,(\"%s: cue_reset\\n\", USBDEVNAME(sc->cue_dev)));\n\n\tif (sc->cue_dying)\n\t\treturn;\n\n\treq.bmRequestType = UT_WRITE_VENDOR_DEVICE;\n\treq.bRequest = CUE_CMD_RESET;\n\tUSETW(req.wValue, 0);\n\tUSETW(req.wIndex, 0);\n\tUSETW(req.wLength, 0);\n\n\ts = splusb();\n\terr = CUE_DO_REQUEST(sc->cue_udev, &req, NULL);\n\tsplx(s);\n\n\tif (err)\n\t\tprintf(\"%s: reset failed\\n\", USBDEVNAME(sc->cue_dev));\n\n\t/* Wait a little while for the chip to get its brains in order. */\n\tdelay(1000);\t\t/* XXX */\n}",
          "includes": [
            "#include <dev/usb/if_cuereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "cue_open_pipes\t__P((struct cue_softc *));",
            "Static int",
            "cue_tx_list_init\t__P((struct cue_softc *));",
            "Static int",
            "cue_rx_list_init\t__P((struct cue_softc *));",
            "Static int",
            "Static int",
            "Static void",
            "cue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "cue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "cue_stop\t\t__P((struct cue_softc *));",
            "Static void",
            "Static void",
            "cue_setmulti\t__P((struct cue_softc *));",
            "Static void",
            "cue_reset\t\t__P((struct cue_softc *));",
            "Static int",
            "cue_csr_read_1\t__P((struct cue_softc *, int));",
            "Static int",
            "cue_csr_write_1\t__P((struct cue_softc *, int, int));",
            "Static int",
            "cue_csr_read_2\t__P((struct cue_softc *, int));",
            "Static int",
            "cue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));",
            "Static int",
            "cue_getmac\t\t__P((struct cue_softc *, void *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/if_cuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\ncue_open_pipes\t__P((struct cue_softc *));\nStatic int;\ncue_tx_list_init\t__P((struct cue_softc *));\nStatic int;\ncue_rx_list_init\t__P((struct cue_softc *));\nStatic int;\nStatic int;\nStatic void;\ncue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\ncue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\ncue_stop\t\t__P((struct cue_softc *));\nStatic void;\nStatic void;\ncue_setmulti\t__P((struct cue_softc *));\nStatic void;\ncue_reset\t\t__P((struct cue_softc *));\nStatic int;\ncue_csr_read_1\t__P((struct cue_softc *, int));\nStatic int;\ncue_csr_write_1\t__P((struct cue_softc *, int, int));\nStatic int;\ncue_csr_read_2\t__P((struct cue_softc *, int));\nStatic int;\ncue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));\nStatic int;\ncue_getmac\t\t__P((struct cue_softc *, void *));\n\nStatic void\ncue_reset(sc)\n\tstruct cue_softc\t*sc;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tint\t\t\ts;\n\n\tDPRINTFN(2,(\"%s: cue_reset\\n\", USBDEVNAME(sc->cue_dev)));\n\n\tif (sc->cue_dying)\n\t\treturn;\n\n\treq.bmRequestType = UT_WRITE_VENDOR_DEVICE;\n\treq.bRequest = CUE_CMD_RESET;\n\tUSETW(req.wValue, 0);\n\tUSETW(req.wIndex, 0);\n\tUSETW(req.wLength, 0);\n\n\ts = splusb();\n\terr = CUE_DO_REQUEST(sc->cue_udev, &req, NULL);\n\tsplx(s);\n\n\tif (err)\n\t\tprintf(\"%s: reset failed\\n\", USBDEVNAME(sc->cue_dev));\n\n\t/* Wait a little while for the chip to get its brains in order. */\n\tdelay(1000);\t\t/* XXX */\n}"
        }
      },
      {
        "call_info": {
          "callee": "cue_csr_write_1",
          "args": [
            "sc",
            "CUE_ETHCTL",
            "0"
          ],
          "line": 1529
        },
        "resolved": true,
        "details": {
          "function_name": "cue_csr_write_1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_cue.c",
          "lines": "314-349",
          "snippet": "Static int\ncue_csr_write_1(sc, reg, val)\n\tstruct cue_softc\t*sc;\n\tint\t\t\treg, val;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tint\t\t\ts;\n\n\tif (sc->cue_dying)\n\t\treturn (0);\n\n\tDPRINTFN(10,(\"%s: cue_csr_write_1 reg=0x%x val=0x%x\\n\", \n\t\t     USBDEVNAME(sc->cue_dev), reg, val));\n\n\treq.bmRequestType = UT_WRITE_VENDOR_DEVICE;\n\treq.bRequest = CUE_CMD_WRITEREG;\n\tUSETW(req.wValue, val);\n\tUSETW(req.wIndex, reg);\n\tUSETW(req.wLength, 0);\n\n\ts = splusb();\n\terr = CUE_DO_REQUEST(sc->cue_udev, &req, NULL);\n\tsplx(s);\n\n\tif (err) {\n\t\tDPRINTF((\"%s: cue_csr_write_1: reg=0x%x err=%s\\n\",\n\t\t\t USBDEVNAME(sc->cue_dev), reg, usbd_errstr(err)));\n\t\treturn (-1);\n\t}\n\n\tDPRINTFN(20,(\"%s: cue_csr_write_1, after reg=0x%x val=0x%x\\n\", \n\t\t     USBDEVNAME(sc->cue_dev), reg, cue_csr_read_1(sc, reg)));\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/usb/if_cuereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "cue_open_pipes\t__P((struct cue_softc *));",
            "Static int",
            "cue_tx_list_init\t__P((struct cue_softc *));",
            "Static int",
            "cue_rx_list_init\t__P((struct cue_softc *));",
            "Static int",
            "Static int",
            "Static void",
            "cue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "cue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "cue_stop\t\t__P((struct cue_softc *));",
            "Static void",
            "Static void",
            "cue_setmulti\t__P((struct cue_softc *));",
            "Static void",
            "cue_reset\t\t__P((struct cue_softc *));",
            "Static int",
            "cue_csr_read_1\t__P((struct cue_softc *, int));",
            "Static int",
            "cue_csr_write_1\t__P((struct cue_softc *, int, int));",
            "Static int",
            "cue_csr_read_2\t__P((struct cue_softc *, int));",
            "Static int",
            "cue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));",
            "Static int",
            "cue_getmac\t\t__P((struct cue_softc *, void *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/if_cuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\ncue_open_pipes\t__P((struct cue_softc *));\nStatic int;\ncue_tx_list_init\t__P((struct cue_softc *));\nStatic int;\ncue_rx_list_init\t__P((struct cue_softc *));\nStatic int;\nStatic int;\nStatic void;\ncue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\ncue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\ncue_stop\t\t__P((struct cue_softc *));\nStatic void;\nStatic void;\ncue_setmulti\t__P((struct cue_softc *));\nStatic void;\ncue_reset\t\t__P((struct cue_softc *));\nStatic int;\ncue_csr_read_1\t__P((struct cue_softc *, int));\nStatic int;\ncue_csr_write_1\t__P((struct cue_softc *, int, int));\nStatic int;\ncue_csr_read_2\t__P((struct cue_softc *, int));\nStatic int;\ncue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));\nStatic int;\ncue_getmac\t\t__P((struct cue_softc *, void *));\n\nStatic int\ncue_csr_write_1(sc, reg, val)\n\tstruct cue_softc\t*sc;\n\tint\t\t\treg, val;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tint\t\t\ts;\n\n\tif (sc->cue_dying)\n\t\treturn (0);\n\n\tDPRINTFN(10,(\"%s: cue_csr_write_1 reg=0x%x val=0x%x\\n\", \n\t\t     USBDEVNAME(sc->cue_dev), reg, val));\n\n\treq.bmRequestType = UT_WRITE_VENDOR_DEVICE;\n\treq.bRequest = CUE_CMD_WRITEREG;\n\tUSETW(req.wValue, val);\n\tUSETW(req.wIndex, reg);\n\tUSETW(req.wLength, 0);\n\n\ts = splusb();\n\terr = CUE_DO_REQUEST(sc->cue_udev, &req, NULL);\n\tsplx(s);\n\n\tif (err) {\n\t\tDPRINTF((\"%s: cue_csr_write_1: reg=0x%x err=%s\\n\",\n\t\t\t USBDEVNAME(sc->cue_dev), reg, usbd_errstr(err)));\n\t\treturn (-1);\n\t}\n\n\tDPRINTFN(20,(\"%s: cue_csr_write_1, after reg=0x%x val=0x%x\\n\", \n\t\t     USBDEVNAME(sc->cue_dev), reg, cue_csr_read_1(sc, reg)));\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GET_IFP",
          "args": [
            "sc"
          ],
          "line": 1526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "10",
            "(\"%s: %s: enter\\n\", USBDEVNAME(sc->cue_dev),__FUNCTION__)"
          ],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->cue_dev"
          ],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/if_cuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\ncue_open_pipes\t__P((struct cue_softc *));\nStatic int;\ncue_tx_list_init\t__P((struct cue_softc *));\nStatic int;\ncue_rx_list_init\t__P((struct cue_softc *));\nStatic int;\nStatic int;\nStatic void;\ncue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\ncue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic void;\ncue_start\t\t__P((struct ifnet *));\nStatic int;\nStatic void;\nStatic void;\ncue_stop\t\t__P((struct cue_softc *));\nStatic void;\ncue_watchdog\t\t__P((struct ifnet *));\nStatic void;\ncue_setmulti\t__P((struct cue_softc *));\nStatic void;\ncue_reset\t\t__P((struct cue_softc *));\nStatic int;\ncue_csr_read_1\t__P((struct cue_softc *, int));\nStatic int;\ncue_csr_write_1\t__P((struct cue_softc *, int, int));\nStatic int;\ncue_csr_read_2\t__P((struct cue_softc *, int));\nStatic int;\ncue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));\nStatic int;\ncue_getmac\t\t__P((struct cue_softc *, void *));\n\nStatic void\ncue_stop(sc)\n\tstruct cue_softc\t*sc;\n{\n\tusbd_status\t\terr;\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\ti;\n\n\tDPRINTFN(10,(\"%s: %s: enter\\n\", USBDEVNAME(sc->cue_dev),__FUNCTION__));\n\n\tifp = GET_IFP(sc);\n\tifp->if_timer = 0;\n\n\tcue_csr_write_1(sc, CUE_ETHCTL, 0);\n\tcue_reset(sc);\n\tusb_uncallout(sc->cue_stat_ch, cue_tick, sc);\n\n\t/* Stop transfers. */\n\tif (sc->cue_ep[CUE_ENDPT_RX] != NULL) {\n\t\terr = usbd_abort_pipe(sc->cue_ep[CUE_ENDPT_RX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort rx pipe failed: %s\\n\",\n\t\t\tUSBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->cue_ep[CUE_ENDPT_RX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close rx pipe failed: %s\\n\",\n\t\t\tUSBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->cue_ep[CUE_ENDPT_RX] = NULL;\n\t}\n\n\tif (sc->cue_ep[CUE_ENDPT_TX] != NULL) {\n\t\terr = usbd_abort_pipe(sc->cue_ep[CUE_ENDPT_TX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort tx pipe failed: %s\\n\",\n\t\t\tUSBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->cue_ep[CUE_ENDPT_TX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close tx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->cue_ep[CUE_ENDPT_TX] = NULL;\n\t}\n\n\tif (sc->cue_ep[CUE_ENDPT_INTR] != NULL) {\n\t\terr = usbd_abort_pipe(sc->cue_ep[CUE_ENDPT_INTR]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort intr pipe failed: %s\\n\",\n\t\t\tUSBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->cue_ep[CUE_ENDPT_INTR]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close intr pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->cue_ep[CUE_ENDPT_INTR] = NULL;\n\t}\n\n\t/* Free RX resources. */\n\tfor (i = 0; i < CUE_RX_LIST_CNT; i++) {\n\t\tif (sc->cue_cdata.cue_rx_chain[i].cue_mbuf != NULL) {\n\t\t\tm_freem(sc->cue_cdata.cue_rx_chain[i].cue_mbuf);\n\t\t\tsc->cue_cdata.cue_rx_chain[i].cue_mbuf = NULL;\n\t\t}\n\t\tif (sc->cue_cdata.cue_rx_chain[i].cue_xfer != NULL) {\n\t\t\tusbd_free_xfer(sc->cue_cdata.cue_rx_chain[i].cue_xfer);\n\t\t\tsc->cue_cdata.cue_rx_chain[i].cue_xfer = NULL;\n\t\t}\n\t}\n\n\t/* Free TX resources. */\n\tfor (i = 0; i < CUE_TX_LIST_CNT; i++) {\n\t\tif (sc->cue_cdata.cue_tx_chain[i].cue_mbuf != NULL) {\n\t\t\tm_freem(sc->cue_cdata.cue_tx_chain[i].cue_mbuf);\n\t\t\tsc->cue_cdata.cue_tx_chain[i].cue_mbuf = NULL;\n\t\t}\n\t\tif (sc->cue_cdata.cue_tx_chain[i].cue_xfer != NULL) {\n\t\t\tusbd_free_xfer(sc->cue_cdata.cue_tx_chain[i].cue_xfer);\n\t\t\tsc->cue_cdata.cue_tx_chain[i].cue_xfer = NULL;\n\t\t}\n\t}\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n}"
  },
  {
    "function_name": "cue_watchdog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_cue.c",
    "lines": "1483-1510",
    "snippet": "Static void\ncue_watchdog(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct cue_softc\t*sc = ifp->if_softc;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->cue_dev),__FUNCTION__));\n\n\tif (sc->cue_dying)\n\t\treturn;\n\n\tifp->if_oerrors++;\n\tprintf(\"%s: watchdog timeout\\n\", USBDEVNAME(sc->cue_dev));\n\n\t/*\n\t * The polling business is a kludge to avoid allowing the\n\t * USB code to call tsleep() in usbd_delay_ms(), which will\n\t * kill us since the watchdog routine is invoked from\n\t * interrupt context.\n\t */\n\tusbd_set_polling(sc->cue_udev, 1);\n\tcue_stop(sc);\n\tcue_init(sc);\n\tusbd_set_polling(sc->cue_udev, 0);\n\n\tif (ifp->if_snd.ifq_head != NULL)\n\t\tcue_start(ifp);\n}",
    "includes": [
      "#include <dev/usb/if_cuereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "cue_open_pipes\t__P((struct cue_softc *));",
      "Static int",
      "cue_tx_list_init\t__P((struct cue_softc *));",
      "Static int",
      "cue_rx_list_init\t__P((struct cue_softc *));",
      "Static int",
      "Static int",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "cue_start\t\t__P((struct ifnet *));",
      "Static int",
      "Static void",
      "Static void",
      "cue_stop\t\t__P((struct cue_softc *));",
      "Static void",
      "cue_watchdog\t\t__P((struct ifnet *));",
      "Static void",
      "cue_setmulti\t__P((struct cue_softc *));",
      "Static void",
      "cue_reset\t\t__P((struct cue_softc *));",
      "Static int",
      "cue_csr_read_1\t__P((struct cue_softc *, int));",
      "Static int",
      "cue_csr_write_1\t__P((struct cue_softc *, int, int));",
      "Static int",
      "cue_csr_read_2\t__P((struct cue_softc *, int));",
      "Static int",
      "cue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));",
      "Static int",
      "cue_getmac\t\t__P((struct cue_softc *, void *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cue_start",
          "args": [
            "ifp"
          ],
          "line": 1509
        },
        "resolved": true,
        "details": {
          "function_name": "cue_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_cue.c",
          "lines": "1210-1250",
          "snippet": "Static void\ncue_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct cue_softc\t*sc = ifp->if_softc;\n\tstruct mbuf\t\t*m_head = NULL;\n\n\tif (sc->cue_dying)\n\t\treturn;\n\n\tDPRINTFN(10,(\"%s: %s: enter\\n\", USBDEVNAME(sc->cue_dev),__FUNCTION__));\n\n\tif (ifp->if_flags & IFF_OACTIVE)\n\t\treturn;\n\n\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\tif (m_head == NULL)\n\t\treturn;\n\n\tif (cue_send(sc, m_head, 0)) {\n\t\tIF_PREPEND(&ifp->if_snd, m_head);\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t\treturn;\n\t}\n\n#if NBPFILTER > 0\n\t/*\n\t * If there's a BPF listener, bounce a copy of this frame\n\t * to him.\n\t */\n\tif (ifp->if_bpf)\n\t\tBPF_MTAP(ifp, m_head);\n#endif\n\n\tifp->if_flags |= IFF_OACTIVE;\n\n\t/*\n\t * Set a timeout in case the chip goes out to lunch.\n\t */\n\tifp->if_timer = 5;\n}",
          "includes": [
            "#include <dev/usb/if_cuereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "cue_open_pipes\t__P((struct cue_softc *));",
            "Static int",
            "cue_tx_list_init\t__P((struct cue_softc *));",
            "Static int",
            "cue_rx_list_init\t__P((struct cue_softc *));",
            "Static int",
            "cue_newbuf\t\t__P((struct cue_softc *, struct cue_chain *,\n\t\t\t\t    struct mbuf *));",
            "Static int",
            "cue_send\t\t__P((struct cue_softc *, struct mbuf *, int));",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "cue_start\t\t__P((struct ifnet *));",
            "Static int",
            "Static void",
            "Static void",
            "cue_stop\t\t__P((struct cue_softc *));",
            "Static void",
            "cue_watchdog\t\t__P((struct ifnet *));",
            "Static void",
            "cue_setmulti\t__P((struct cue_softc *));",
            "Static void",
            "cue_reset\t\t__P((struct cue_softc *));",
            "Static int",
            "cue_csr_read_1\t__P((struct cue_softc *, int));",
            "Static int",
            "cue_csr_write_1\t__P((struct cue_softc *, int, int));",
            "Static int",
            "cue_csr_read_2\t__P((struct cue_softc *, int));",
            "Static int",
            "cue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));",
            "Static int",
            "cue_getmac\t\t__P((struct cue_softc *, void *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/if_cuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\ncue_open_pipes\t__P((struct cue_softc *));\nStatic int;\ncue_tx_list_init\t__P((struct cue_softc *));\nStatic int;\ncue_rx_list_init\t__P((struct cue_softc *));\nStatic int;\ncue_newbuf\t\t__P((struct cue_softc *, struct cue_chain *,\n\t\t\t\t    struct mbuf *));\nStatic int;\ncue_send\t\t__P((struct cue_softc *, struct mbuf *, int));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\ncue_start\t\t__P((struct ifnet *));\nStatic int;\nStatic void;\nStatic void;\ncue_stop\t\t__P((struct cue_softc *));\nStatic void;\ncue_watchdog\t\t__P((struct ifnet *));\nStatic void;\ncue_setmulti\t__P((struct cue_softc *));\nStatic void;\ncue_reset\t\t__P((struct cue_softc *));\nStatic int;\ncue_csr_read_1\t__P((struct cue_softc *, int));\nStatic int;\ncue_csr_write_1\t__P((struct cue_softc *, int, int));\nStatic int;\ncue_csr_read_2\t__P((struct cue_softc *, int));\nStatic int;\ncue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));\nStatic int;\ncue_getmac\t\t__P((struct cue_softc *, void *));\n\nStatic void\ncue_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct cue_softc\t*sc = ifp->if_softc;\n\tstruct mbuf\t\t*m_head = NULL;\n\n\tif (sc->cue_dying)\n\t\treturn;\n\n\tDPRINTFN(10,(\"%s: %s: enter\\n\", USBDEVNAME(sc->cue_dev),__FUNCTION__));\n\n\tif (ifp->if_flags & IFF_OACTIVE)\n\t\treturn;\n\n\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\tif (m_head == NULL)\n\t\treturn;\n\n\tif (cue_send(sc, m_head, 0)) {\n\t\tIF_PREPEND(&ifp->if_snd, m_head);\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t\treturn;\n\t}\n\n#if NBPFILTER > 0\n\t/*\n\t * If there's a BPF listener, bounce a copy of this frame\n\t * to him.\n\t */\n\tif (ifp->if_bpf)\n\t\tBPF_MTAP(ifp, m_head);\n#endif\n\n\tifp->if_flags |= IFF_OACTIVE;\n\n\t/*\n\t * Set a timeout in case the chip goes out to lunch.\n\t */\n\tifp->if_timer = 5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_set_polling",
          "args": [
            "sc->cue_udev",
            "0"
          ],
          "line": 1506
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_set_polling",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "1100-1109",
          "snippet": "void\nusbd_set_polling(dev, on)\n\tusbd_device_handle dev;\n\tint on;\n{\n\tif (on)\n\t\tdev->bus->use_polling++;\n\telse\n\t\tdev->bus->use_polling--;\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
            "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\n\nvoid\nusbd_set_polling(dev, on)\n\tusbd_device_handle dev;\n\tint on;\n{\n\tif (on)\n\t\tdev->bus->use_polling++;\n\telse\n\t\tdev->bus->use_polling--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cue_init",
          "args": [
            "sc"
          ],
          "line": 1505
        },
        "resolved": true,
        "details": {
          "function_name": "cue_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_cue.c",
          "lines": "1252-1341",
          "snippet": "Static void\ncue_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct cue_softc\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = GET_IFP(sc);\n\tint\t\t\ti, s, ctl;\n\tu_char\t\t\t*eaddr;\n\n\tif (sc->cue_dying)\n\t\treturn;\n\n\tDPRINTFN(10,(\"%s: %s: enter\\n\", USBDEVNAME(sc->cue_dev),__FUNCTION__));\n\n\tif (ifp->if_flags & IFF_RUNNING)\n\t\treturn;\n\n\ts = splimp();\n\n\t/*\n\t * Cancel pending I/O and free all RX/TX buffers.\n\t */\n#if 1\n\tcue_reset(sc);\n#endif\n\n\t/* Set advanced operation modes. */\n\tcue_csr_write_1(sc, CUE_ADVANCED_OPMODES,\n\t    CUE_AOP_EMBED_RXLEN | 0x03); /* 1 wait state */\n\n#if defined(__FreeBSD__) || defined(__OpenBSD__)\n\teaddr = sc->arpcom.ac_enaddr;\n#elif defined(__NetBSD__)\n\teaddr = LLADDR(ifp->if_sadl);\n#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */\n\t/* Set MAC address */\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++)\n\t\tcue_csr_write_1(sc, CUE_PAR0 - i, eaddr[i]);\n\n\t/* Enable RX logic. */\n\tctl = CUE_ETHCTL_RX_ON | CUE_ETHCTL_MCAST_ON;\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tctl |= CUE_ETHCTL_PROMISC;\n\tcue_csr_write_1(sc, CUE_ETHCTL, ctl);\n\n\t/* Init TX ring. */\n\tif (cue_tx_list_init(sc) == ENOBUFS) {\n\t\tprintf(\"%s: tx list init failed\\n\", USBDEVNAME(sc->cue_dev));\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Init RX ring. */\n\tif (cue_rx_list_init(sc) == ENOBUFS) {\n\t\tprintf(\"%s: rx list init failed\\n\", USBDEVNAME(sc->cue_dev));\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Load the multicast filter. */\n\tcue_setmulti(sc);\n\n\t/*\n\t * Set the number of RX and TX buffers that we want\n\t * to reserve inside the ASIC.\n\t */\n\tcue_csr_write_1(sc, CUE_RX_BUFPKTS, CUE_RX_FRAMES);\n\tcue_csr_write_1(sc, CUE_TX_BUFPKTS, CUE_TX_FRAMES);\n\n\t/* Set advanced operation modes. */\n\tcue_csr_write_1(sc, CUE_ADVANCED_OPMODES,\n\t    CUE_AOP_EMBED_RXLEN | 0x01); /* 1 wait state */\n\n\t/* Program the LED operation. */\n\tcue_csr_write_1(sc, CUE_LEDCTL, CUE_LEDCTL_FOLLOW_LINK);\n\n\tif (sc->cue_ep[CUE_ENDPT_RX] == NULL) {\n\t\tif (cue_open_pipes(sc)) {\n\t\t\tsplx(s);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tsplx(s);\n\n\tusb_callout(sc->cue_stat_ch, hz, cue_tick, sc);\n}",
          "includes": [
            "#include <dev/usb/if_cuereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "cue_open_pipes\t__P((struct cue_softc *));",
            "Static int",
            "cue_tx_list_init\t__P((struct cue_softc *));",
            "Static int",
            "cue_rx_list_init\t__P((struct cue_softc *));",
            "Static int",
            "Static int",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "cue_start\t\t__P((struct ifnet *));",
            "Static int",
            "Static void",
            "Static void",
            "cue_stop\t\t__P((struct cue_softc *));",
            "Static void",
            "cue_watchdog\t\t__P((struct ifnet *));",
            "Static void",
            "cue_setmulti\t__P((struct cue_softc *));",
            "Static void",
            "cue_reset\t\t__P((struct cue_softc *));",
            "Static int",
            "cue_csr_read_1\t__P((struct cue_softc *, int));",
            "Static int",
            "cue_csr_write_1\t__P((struct cue_softc *, int, int));",
            "Static int",
            "cue_csr_read_2\t__P((struct cue_softc *, int));",
            "Static int",
            "cue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));",
            "Static int",
            "cue_getmac\t\t__P((struct cue_softc *, void *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/if_cuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\ncue_open_pipes\t__P((struct cue_softc *));\nStatic int;\ncue_tx_list_init\t__P((struct cue_softc *));\nStatic int;\ncue_rx_list_init\t__P((struct cue_softc *));\nStatic int;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\ncue_start\t\t__P((struct ifnet *));\nStatic int;\nStatic void;\nStatic void;\ncue_stop\t\t__P((struct cue_softc *));\nStatic void;\ncue_watchdog\t\t__P((struct ifnet *));\nStatic void;\ncue_setmulti\t__P((struct cue_softc *));\nStatic void;\ncue_reset\t\t__P((struct cue_softc *));\nStatic int;\ncue_csr_read_1\t__P((struct cue_softc *, int));\nStatic int;\ncue_csr_write_1\t__P((struct cue_softc *, int, int));\nStatic int;\ncue_csr_read_2\t__P((struct cue_softc *, int));\nStatic int;\ncue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));\nStatic int;\ncue_getmac\t\t__P((struct cue_softc *, void *));\n\nStatic void\ncue_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct cue_softc\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = GET_IFP(sc);\n\tint\t\t\ti, s, ctl;\n\tu_char\t\t\t*eaddr;\n\n\tif (sc->cue_dying)\n\t\treturn;\n\n\tDPRINTFN(10,(\"%s: %s: enter\\n\", USBDEVNAME(sc->cue_dev),__FUNCTION__));\n\n\tif (ifp->if_flags & IFF_RUNNING)\n\t\treturn;\n\n\ts = splimp();\n\n\t/*\n\t * Cancel pending I/O and free all RX/TX buffers.\n\t */\n#if 1\n\tcue_reset(sc);\n#endif\n\n\t/* Set advanced operation modes. */\n\tcue_csr_write_1(sc, CUE_ADVANCED_OPMODES,\n\t    CUE_AOP_EMBED_RXLEN | 0x03); /* 1 wait state */\n\n#if defined(__FreeBSD__) || defined(__OpenBSD__)\n\teaddr = sc->arpcom.ac_enaddr;\n#elif defined(__NetBSD__)\n\teaddr = LLADDR(ifp->if_sadl);\n#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */\n\t/* Set MAC address */\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++)\n\t\tcue_csr_write_1(sc, CUE_PAR0 - i, eaddr[i]);\n\n\t/* Enable RX logic. */\n\tctl = CUE_ETHCTL_RX_ON | CUE_ETHCTL_MCAST_ON;\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tctl |= CUE_ETHCTL_PROMISC;\n\tcue_csr_write_1(sc, CUE_ETHCTL, ctl);\n\n\t/* Init TX ring. */\n\tif (cue_tx_list_init(sc) == ENOBUFS) {\n\t\tprintf(\"%s: tx list init failed\\n\", USBDEVNAME(sc->cue_dev));\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Init RX ring. */\n\tif (cue_rx_list_init(sc) == ENOBUFS) {\n\t\tprintf(\"%s: rx list init failed\\n\", USBDEVNAME(sc->cue_dev));\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Load the multicast filter. */\n\tcue_setmulti(sc);\n\n\t/*\n\t * Set the number of RX and TX buffers that we want\n\t * to reserve inside the ASIC.\n\t */\n\tcue_csr_write_1(sc, CUE_RX_BUFPKTS, CUE_RX_FRAMES);\n\tcue_csr_write_1(sc, CUE_TX_BUFPKTS, CUE_TX_FRAMES);\n\n\t/* Set advanced operation modes. */\n\tcue_csr_write_1(sc, CUE_ADVANCED_OPMODES,\n\t    CUE_AOP_EMBED_RXLEN | 0x01); /* 1 wait state */\n\n\t/* Program the LED operation. */\n\tcue_csr_write_1(sc, CUE_LEDCTL, CUE_LEDCTL_FOLLOW_LINK);\n\n\tif (sc->cue_ep[CUE_ENDPT_RX] == NULL) {\n\t\tif (cue_open_pipes(sc)) {\n\t\t\tsplx(s);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tsplx(s);\n\n\tusb_callout(sc->cue_stat_ch, hz, cue_tick, sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cue_stop",
          "args": [
            "sc"
          ],
          "line": 1504
        },
        "resolved": true,
        "details": {
          "function_name": "cue_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_cue.c",
          "lines": "1516-1601",
          "snippet": "Static void\ncue_stop(sc)\n\tstruct cue_softc\t*sc;\n{\n\tusbd_status\t\terr;\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\ti;\n\n\tDPRINTFN(10,(\"%s: %s: enter\\n\", USBDEVNAME(sc->cue_dev),__FUNCTION__));\n\n\tifp = GET_IFP(sc);\n\tifp->if_timer = 0;\n\n\tcue_csr_write_1(sc, CUE_ETHCTL, 0);\n\tcue_reset(sc);\n\tusb_uncallout(sc->cue_stat_ch, cue_tick, sc);\n\n\t/* Stop transfers. */\n\tif (sc->cue_ep[CUE_ENDPT_RX] != NULL) {\n\t\terr = usbd_abort_pipe(sc->cue_ep[CUE_ENDPT_RX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort rx pipe failed: %s\\n\",\n\t\t\tUSBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->cue_ep[CUE_ENDPT_RX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close rx pipe failed: %s\\n\",\n\t\t\tUSBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->cue_ep[CUE_ENDPT_RX] = NULL;\n\t}\n\n\tif (sc->cue_ep[CUE_ENDPT_TX] != NULL) {\n\t\terr = usbd_abort_pipe(sc->cue_ep[CUE_ENDPT_TX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort tx pipe failed: %s\\n\",\n\t\t\tUSBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->cue_ep[CUE_ENDPT_TX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close tx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->cue_ep[CUE_ENDPT_TX] = NULL;\n\t}\n\n\tif (sc->cue_ep[CUE_ENDPT_INTR] != NULL) {\n\t\terr = usbd_abort_pipe(sc->cue_ep[CUE_ENDPT_INTR]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort intr pipe failed: %s\\n\",\n\t\t\tUSBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->cue_ep[CUE_ENDPT_INTR]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close intr pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->cue_ep[CUE_ENDPT_INTR] = NULL;\n\t}\n\n\t/* Free RX resources. */\n\tfor (i = 0; i < CUE_RX_LIST_CNT; i++) {\n\t\tif (sc->cue_cdata.cue_rx_chain[i].cue_mbuf != NULL) {\n\t\t\tm_freem(sc->cue_cdata.cue_rx_chain[i].cue_mbuf);\n\t\t\tsc->cue_cdata.cue_rx_chain[i].cue_mbuf = NULL;\n\t\t}\n\t\tif (sc->cue_cdata.cue_rx_chain[i].cue_xfer != NULL) {\n\t\t\tusbd_free_xfer(sc->cue_cdata.cue_rx_chain[i].cue_xfer);\n\t\t\tsc->cue_cdata.cue_rx_chain[i].cue_xfer = NULL;\n\t\t}\n\t}\n\n\t/* Free TX resources. */\n\tfor (i = 0; i < CUE_TX_LIST_CNT; i++) {\n\t\tif (sc->cue_cdata.cue_tx_chain[i].cue_mbuf != NULL) {\n\t\t\tm_freem(sc->cue_cdata.cue_tx_chain[i].cue_mbuf);\n\t\t\tsc->cue_cdata.cue_tx_chain[i].cue_mbuf = NULL;\n\t\t}\n\t\tif (sc->cue_cdata.cue_tx_chain[i].cue_xfer != NULL) {\n\t\t\tusbd_free_xfer(sc->cue_cdata.cue_tx_chain[i].cue_xfer);\n\t\t\tsc->cue_cdata.cue_tx_chain[i].cue_xfer = NULL;\n\t\t}\n\t}\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n}",
          "includes": [
            "#include <dev/usb/if_cuereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "cue_open_pipes\t__P((struct cue_softc *));",
            "Static int",
            "cue_tx_list_init\t__P((struct cue_softc *));",
            "Static int",
            "cue_rx_list_init\t__P((struct cue_softc *));",
            "Static int",
            "Static int",
            "Static void",
            "cue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "cue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "Static void",
            "cue_start\t\t__P((struct ifnet *));",
            "Static int",
            "Static void",
            "Static void",
            "cue_stop\t\t__P((struct cue_softc *));",
            "Static void",
            "cue_watchdog\t\t__P((struct ifnet *));",
            "Static void",
            "cue_setmulti\t__P((struct cue_softc *));",
            "Static void",
            "cue_reset\t\t__P((struct cue_softc *));",
            "Static int",
            "cue_csr_read_1\t__P((struct cue_softc *, int));",
            "Static int",
            "cue_csr_write_1\t__P((struct cue_softc *, int, int));",
            "Static int",
            "cue_csr_read_2\t__P((struct cue_softc *, int));",
            "Static int",
            "cue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));",
            "Static int",
            "cue_getmac\t\t__P((struct cue_softc *, void *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/if_cuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\ncue_open_pipes\t__P((struct cue_softc *));\nStatic int;\ncue_tx_list_init\t__P((struct cue_softc *));\nStatic int;\ncue_rx_list_init\t__P((struct cue_softc *));\nStatic int;\nStatic int;\nStatic void;\ncue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\ncue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic void;\ncue_start\t\t__P((struct ifnet *));\nStatic int;\nStatic void;\nStatic void;\ncue_stop\t\t__P((struct cue_softc *));\nStatic void;\ncue_watchdog\t\t__P((struct ifnet *));\nStatic void;\ncue_setmulti\t__P((struct cue_softc *));\nStatic void;\ncue_reset\t\t__P((struct cue_softc *));\nStatic int;\ncue_csr_read_1\t__P((struct cue_softc *, int));\nStatic int;\ncue_csr_write_1\t__P((struct cue_softc *, int, int));\nStatic int;\ncue_csr_read_2\t__P((struct cue_softc *, int));\nStatic int;\ncue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));\nStatic int;\ncue_getmac\t\t__P((struct cue_softc *, void *));\n\nStatic void\ncue_stop(sc)\n\tstruct cue_softc\t*sc;\n{\n\tusbd_status\t\terr;\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\ti;\n\n\tDPRINTFN(10,(\"%s: %s: enter\\n\", USBDEVNAME(sc->cue_dev),__FUNCTION__));\n\n\tifp = GET_IFP(sc);\n\tifp->if_timer = 0;\n\n\tcue_csr_write_1(sc, CUE_ETHCTL, 0);\n\tcue_reset(sc);\n\tusb_uncallout(sc->cue_stat_ch, cue_tick, sc);\n\n\t/* Stop transfers. */\n\tif (sc->cue_ep[CUE_ENDPT_RX] != NULL) {\n\t\terr = usbd_abort_pipe(sc->cue_ep[CUE_ENDPT_RX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort rx pipe failed: %s\\n\",\n\t\t\tUSBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->cue_ep[CUE_ENDPT_RX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close rx pipe failed: %s\\n\",\n\t\t\tUSBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->cue_ep[CUE_ENDPT_RX] = NULL;\n\t}\n\n\tif (sc->cue_ep[CUE_ENDPT_TX] != NULL) {\n\t\terr = usbd_abort_pipe(sc->cue_ep[CUE_ENDPT_TX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort tx pipe failed: %s\\n\",\n\t\t\tUSBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->cue_ep[CUE_ENDPT_TX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close tx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->cue_ep[CUE_ENDPT_TX] = NULL;\n\t}\n\n\tif (sc->cue_ep[CUE_ENDPT_INTR] != NULL) {\n\t\terr = usbd_abort_pipe(sc->cue_ep[CUE_ENDPT_INTR]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort intr pipe failed: %s\\n\",\n\t\t\tUSBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->cue_ep[CUE_ENDPT_INTR]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close intr pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->cue_ep[CUE_ENDPT_INTR] = NULL;\n\t}\n\n\t/* Free RX resources. */\n\tfor (i = 0; i < CUE_RX_LIST_CNT; i++) {\n\t\tif (sc->cue_cdata.cue_rx_chain[i].cue_mbuf != NULL) {\n\t\t\tm_freem(sc->cue_cdata.cue_rx_chain[i].cue_mbuf);\n\t\t\tsc->cue_cdata.cue_rx_chain[i].cue_mbuf = NULL;\n\t\t}\n\t\tif (sc->cue_cdata.cue_rx_chain[i].cue_xfer != NULL) {\n\t\t\tusbd_free_xfer(sc->cue_cdata.cue_rx_chain[i].cue_xfer);\n\t\t\tsc->cue_cdata.cue_rx_chain[i].cue_xfer = NULL;\n\t\t}\n\t}\n\n\t/* Free TX resources. */\n\tfor (i = 0; i < CUE_TX_LIST_CNT; i++) {\n\t\tif (sc->cue_cdata.cue_tx_chain[i].cue_mbuf != NULL) {\n\t\t\tm_freem(sc->cue_cdata.cue_tx_chain[i].cue_mbuf);\n\t\t\tsc->cue_cdata.cue_tx_chain[i].cue_mbuf = NULL;\n\t\t}\n\t\tif (sc->cue_cdata.cue_tx_chain[i].cue_xfer != NULL) {\n\t\t\tusbd_free_xfer(sc->cue_cdata.cue_tx_chain[i].cue_xfer);\n\t\t\tsc->cue_cdata.cue_tx_chain[i].cue_xfer = NULL;\n\t\t}\n\t}\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: watchdog timeout\\n\"",
            "USBDEVNAME(sc->cue_dev)"
          ],
          "line": 1495
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->cue_dev"
          ],
          "line": 1495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"%s: %s: enter\\n\", USBDEVNAME(sc->cue_dev),__FUNCTION__)"
          ],
          "line": 1489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->cue_dev"
          ],
          "line": 1489
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/if_cuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\ncue_open_pipes\t__P((struct cue_softc *));\nStatic int;\ncue_tx_list_init\t__P((struct cue_softc *));\nStatic int;\ncue_rx_list_init\t__P((struct cue_softc *));\nStatic int;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\ncue_start\t\t__P((struct ifnet *));\nStatic int;\nStatic void;\nStatic void;\ncue_stop\t\t__P((struct cue_softc *));\nStatic void;\ncue_watchdog\t\t__P((struct ifnet *));\nStatic void;\ncue_setmulti\t__P((struct cue_softc *));\nStatic void;\ncue_reset\t\t__P((struct cue_softc *));\nStatic int;\ncue_csr_read_1\t__P((struct cue_softc *, int));\nStatic int;\ncue_csr_write_1\t__P((struct cue_softc *, int, int));\nStatic int;\ncue_csr_read_2\t__P((struct cue_softc *, int));\nStatic int;\ncue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));\nStatic int;\ncue_getmac\t\t__P((struct cue_softc *, void *));\n\nStatic void\ncue_watchdog(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct cue_softc\t*sc = ifp->if_softc;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->cue_dev),__FUNCTION__));\n\n\tif (sc->cue_dying)\n\t\treturn;\n\n\tifp->if_oerrors++;\n\tprintf(\"%s: watchdog timeout\\n\", USBDEVNAME(sc->cue_dev));\n\n\t/*\n\t * The polling business is a kludge to avoid allowing the\n\t * USB code to call tsleep() in usbd_delay_ms(), which will\n\t * kill us since the watchdog routine is invoked from\n\t * interrupt context.\n\t */\n\tusbd_set_polling(sc->cue_udev, 1);\n\tcue_stop(sc);\n\tcue_init(sc);\n\tusbd_set_polling(sc->cue_udev, 0);\n\n\tif (ifp->if_snd.ifq_head != NULL)\n\t\tcue_start(ifp);\n}"
  },
  {
    "function_name": "cue_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_cue.c",
    "lines": "1380-1481",
    "snippet": "Static int\ncue_ioctl(ifp, command, data)\n\tstruct ifnet\t\t*ifp;\n\tu_long\t\t\tcommand;\n\tcaddr_t\t\t\tdata;\n{\n\tstruct cue_softc\t*sc = ifp->if_softc;\n#if defined(__NetBSD__) || defined(__OpenBSD__)\n\tstruct ifaddr \t\t*ifa = (struct ifaddr *)data;\n\tstruct ifreq\t\t*ifr = (struct ifreq *)data;\n#endif\n\tint\t\t\ts, error = 0;\n\n\tif (sc->cue_dying)\n\t\treturn (EIO);\n\n\ts = splimp();\n\n\tswitch(command) {\n#if defined(__FreeBSD__)\n\tcase SIOCSIFADDR:\n\tcase SIOCGIFADDR:\n\tcase SIOCSIFMTU:\n\t\terror = ether_ioctl(ifp, command, data);\n\t\tbreak;\n#elif defined(__NetBSD__) || defined(__OpenBSD__)\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\t\tcue_init(sc);\n\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n#if defined(__NetBSD__)\n\t\t\tarp_ifinit(ifp, ifa);\n#else\n\t\t\tarp_ifinit(&sc->arpcom, ifa);\n#endif\n\t\t\tbreak;\n#endif /* INET */\n#ifdef NS\n\t\tcase AF_NS:\n\t\t    {\n\t\t\tstruct ns_addr *ina = &IA_SNS(ifa)->sns_addr;\n\n\t\t\tif (ns_nullhost(*ina))\n\t\t\t\tina->x_host = *(union ns_host *)\n\t\t\t\t\tLLADDR(ifp->if_sadl);\n\t\t\telse\n\t\t\t\tmemcpy(LLADDR(ifp->if_sadl),\n\t\t\t\t       ina->x_host.c_host,\n\t\t\t\t       ifp->if_addrlen);\n\t\t\tbreak;\n\t\t    }\n#endif /* NS */\n\t\t}\n\t\tbreak;\n\n\tcase SIOCSIFMTU:\n\t\tif (ifr->ifr_mtu > ETHERMTU)\n\t\t\terror = EINVAL;\n\t\telse\n\t\t\tifp->if_mtu = ifr->ifr_mtu;\n\t\tbreak;\n\n#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */\n\n\tcase SIOCSIFFLAGS:\n\t\tif (ifp->if_flags & IFF_UP) {\n\t\t\tif (ifp->if_flags & IFF_RUNNING &&\n\t\t\t    ifp->if_flags & IFF_PROMISC &&\n\t\t\t    !(sc->cue_if_flags & IFF_PROMISC)) {\n\t\t\t\tCUE_SETBIT(sc, CUE_ETHCTL, CUE_ETHCTL_PROMISC);\n\t\t\t\tcue_setmulti(sc);\n\t\t\t} else if (ifp->if_flags & IFF_RUNNING &&\n\t\t\t    !(ifp->if_flags & IFF_PROMISC) &&\n\t\t\t    sc->cue_if_flags & IFF_PROMISC) {\n\t\t\t\tCUE_CLRBIT(sc, CUE_ETHCTL, CUE_ETHCTL_PROMISC);\n\t\t\t\tcue_setmulti(sc);\n\t\t\t} else if (!(ifp->if_flags & IFF_RUNNING))\n\t\t\t\tcue_init(sc);\n\t\t} else {\n\t\t\tif (ifp->if_flags & IFF_RUNNING)\n\t\t\t\tcue_stop(sc);\n\t\t}\n\t\tsc->cue_if_flags = ifp->if_flags;\n\t\terror = 0;\n\t\tbreak;\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\t\tcue_setmulti(sc);\n\t\terror = 0;\n\t\tbreak;\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\tsplx(s);\n\n\treturn (error);\n}",
    "includes": [
      "#include <dev/usb/if_cuereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "cue_open_pipes\t__P((struct cue_softc *));",
      "Static int",
      "cue_tx_list_init\t__P((struct cue_softc *));",
      "Static int",
      "cue_rx_list_init\t__P((struct cue_softc *));",
      "Static int",
      "Static int",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "cue_start\t\t__P((struct ifnet *));",
      "Static int",
      "cue_ioctl\t\t__P((struct ifnet *, u_long, caddr_t));",
      "Static void",
      "Static void",
      "cue_stop\t\t__P((struct cue_softc *));",
      "Static void",
      "cue_watchdog\t\t__P((struct ifnet *));",
      "Static void",
      "cue_setmulti\t__P((struct cue_softc *));",
      "cue_crc\t__P((caddr_t));",
      "Static void",
      "cue_reset\t\t__P((struct cue_softc *));",
      "Static int",
      "cue_csr_read_1\t__P((struct cue_softc *, int));",
      "Static int",
      "cue_csr_write_1\t__P((struct cue_softc *, int, int));",
      "Static int",
      "cue_csr_read_2\t__P((struct cue_softc *, int));",
      "Static int",
      "cue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));",
      "Static int",
      "cue_getmac\t\t__P((struct cue_softc *, void *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cue_setmulti",
          "args": [
            "sc"
          ],
          "line": 1470
        },
        "resolved": true,
        "details": {
          "function_name": "cue_setmulti",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_cue.c",
          "lines": "475-546",
          "snippet": "Static void\ncue_setmulti(sc)\n\tstruct cue_softc\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n#if defined(__FreeBSD__)\n\tstruct ifmultiaddr\t*ifma;\n#elif defined(__NetBSD__) || defined(__OpenBSD__)\n\tstruct ether_multi\t*enm;\n\tstruct ether_multistep\tstep;\n#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */\n\tu_int32_t\t\th, i;\n\n\tifp = GET_IFP(sc);\n\n\tDPRINTFN(2,(\"%s: cue_setmulti if_flags=0x%x\\n\", \n\t\t    USBDEVNAME(sc->cue_dev), ifp->if_flags));\n\n\tif (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {\n\t\tfor (i = 0; i < CUE_MCAST_TABLE_LEN; i++)\n\t\t\tsc->cue_mctab[i] = 0xFF;\n\t\tcue_mem(sc, CUE_CMD_WRITESRAM, CUE_MCAST_TABLE_ADDR,\n\t\t    &sc->cue_mctab, CUE_MCAST_TABLE_LEN);\n\t\treturn;\n\t}\n\n\t/* first, zot all the existing hash bits */\n\tfor (i = 0; i < CUE_MCAST_TABLE_LEN; i++)\n\t\tsc->cue_mctab[i] = 0;\n\n\t/* now program new ones */\n#if defined(__FreeBSD__)\n\tfor (ifma = ifp->if_multiaddrs.lh_first; ifma != NULL;\n\t    ifma = ifma->ifma_link.le_next) {\n\t\tif (ifma->ifma_addr->sa_family != AF_LINK)\n\t\t\tcontinue;\n\t\th = cue_crc(LLADDR((struct sockaddr_dl *)ifma->ifma_addr));\n\t\tsc->cue_mctab[h >> 3] |= 1 << (h & 0x7);\t\t\n\t}\n#elif defined(__NetBSD__) || defined(__OpenBSD__)\n#if defined(__NetBSD__)\n\tETHER_FIRST_MULTI(step, &sc->cue_ec, enm);\n#else\n\tETHER_FIRST_MULTI(step, &sc->arpcom, enm);\n#endif\n\twhile (enm != NULL) {\n#if 0\n\t\tif (memcmp(enm->enm_addrlo,\n\t\t\t   enm->enm_addrhi, ETHER_ADDR_LEN) != 0) {\n\t\t\tifp->if_flags |= IFF_ALLMULTI;\n\t\t\t/* XXX what now? */\n\t\t\treturn;\n\t\t}\n#endif\n\t\th = cue_crc(enm->enm_addrlo);\n\t\tsc->cue_mctab[h >> 3] |= 1 << (h & 0x7);\t\t\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */\n\n\t/*\n\t * Also include the broadcast address in the filter\n\t * so we can receive broadcast frames.\n\t */\n\tif (ifp->if_flags & IFF_BROADCAST) {\n\t\th = cue_crc(etherbroadcastaddr);\n\t\tsc->cue_mctab[h >> 3] |= 1 << (h & 0x7);\t\t\n\t}\n\n\tcue_mem(sc, CUE_CMD_WRITESRAM, CUE_MCAST_TABLE_ADDR,\n\t    &sc->cue_mctab, CUE_MCAST_TABLE_LEN);\n}",
          "includes": [
            "#include <dev/usb/if_cuereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "cue_open_pipes\t__P((struct cue_softc *));",
            "Static int",
            "cue_tx_list_init\t__P((struct cue_softc *));",
            "Static int",
            "cue_rx_list_init\t__P((struct cue_softc *));",
            "Static int",
            "Static int",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "cue_start\t\t__P((struct ifnet *));",
            "Static int",
            "Static void",
            "Static void",
            "cue_stop\t\t__P((struct cue_softc *));",
            "Static void",
            "cue_watchdog\t\t__P((struct ifnet *));",
            "Static void",
            "cue_setmulti\t__P((struct cue_softc *));",
            "Static u_int32_t",
            "Static void",
            "cue_reset\t\t__P((struct cue_softc *));",
            "Static int",
            "cue_csr_read_1\t__P((struct cue_softc *, int));",
            "Static int",
            "cue_csr_write_1\t__P((struct cue_softc *, int, int));",
            "Static int",
            "cue_csr_read_2\t__P((struct cue_softc *, int));",
            "Static int",
            "cue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));",
            "Static int",
            "cue_getmac\t\t__P((struct cue_softc *, void *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/if_cuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\ncue_open_pipes\t__P((struct cue_softc *));\nStatic int;\ncue_tx_list_init\t__P((struct cue_softc *));\nStatic int;\ncue_rx_list_init\t__P((struct cue_softc *));\nStatic int;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\ncue_start\t\t__P((struct ifnet *));\nStatic int;\nStatic void;\nStatic void;\ncue_stop\t\t__P((struct cue_softc *));\nStatic void;\ncue_watchdog\t\t__P((struct ifnet *));\nStatic void;\ncue_setmulti\t__P((struct cue_softc *));\nStatic u_int32_t;\nStatic void;\ncue_reset\t\t__P((struct cue_softc *));\nStatic int;\ncue_csr_read_1\t__P((struct cue_softc *, int));\nStatic int;\ncue_csr_write_1\t__P((struct cue_softc *, int, int));\nStatic int;\ncue_csr_read_2\t__P((struct cue_softc *, int));\nStatic int;\ncue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));\nStatic int;\ncue_getmac\t\t__P((struct cue_softc *, void *));\n\nStatic void\ncue_setmulti(sc)\n\tstruct cue_softc\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n#if defined(__FreeBSD__)\n\tstruct ifmultiaddr\t*ifma;\n#elif defined(__NetBSD__) || defined(__OpenBSD__)\n\tstruct ether_multi\t*enm;\n\tstruct ether_multistep\tstep;\n#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */\n\tu_int32_t\t\th, i;\n\n\tifp = GET_IFP(sc);\n\n\tDPRINTFN(2,(\"%s: cue_setmulti if_flags=0x%x\\n\", \n\t\t    USBDEVNAME(sc->cue_dev), ifp->if_flags));\n\n\tif (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {\n\t\tfor (i = 0; i < CUE_MCAST_TABLE_LEN; i++)\n\t\t\tsc->cue_mctab[i] = 0xFF;\n\t\tcue_mem(sc, CUE_CMD_WRITESRAM, CUE_MCAST_TABLE_ADDR,\n\t\t    &sc->cue_mctab, CUE_MCAST_TABLE_LEN);\n\t\treturn;\n\t}\n\n\t/* first, zot all the existing hash bits */\n\tfor (i = 0; i < CUE_MCAST_TABLE_LEN; i++)\n\t\tsc->cue_mctab[i] = 0;\n\n\t/* now program new ones */\n#if defined(__FreeBSD__)\n\tfor (ifma = ifp->if_multiaddrs.lh_first; ifma != NULL;\n\t    ifma = ifma->ifma_link.le_next) {\n\t\tif (ifma->ifma_addr->sa_family != AF_LINK)\n\t\t\tcontinue;\n\t\th = cue_crc(LLADDR((struct sockaddr_dl *)ifma->ifma_addr));\n\t\tsc->cue_mctab[h >> 3] |= 1 << (h & 0x7);\t\t\n\t}\n#elif defined(__NetBSD__) || defined(__OpenBSD__)\n#if defined(__NetBSD__)\n\tETHER_FIRST_MULTI(step, &sc->cue_ec, enm);\n#else\n\tETHER_FIRST_MULTI(step, &sc->arpcom, enm);\n#endif\n\twhile (enm != NULL) {\n#if 0\n\t\tif (memcmp(enm->enm_addrlo,\n\t\t\t   enm->enm_addrhi, ETHER_ADDR_LEN) != 0) {\n\t\t\tifp->if_flags |= IFF_ALLMULTI;\n\t\t\t/* XXX what now? */\n\t\t\treturn;\n\t\t}\n#endif\n\t\th = cue_crc(enm->enm_addrlo);\n\t\tsc->cue_mctab[h >> 3] |= 1 << (h & 0x7);\t\t\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */\n\n\t/*\n\t * Also include the broadcast address in the filter\n\t * so we can receive broadcast frames.\n\t */\n\tif (ifp->if_flags & IFF_BROADCAST) {\n\t\th = cue_crc(etherbroadcastaddr);\n\t\tsc->cue_mctab[h >> 3] |= 1 << (h & 0x7);\t\t\n\t}\n\n\tcue_mem(sc, CUE_CMD_WRITESRAM, CUE_MCAST_TABLE_ADDR,\n\t    &sc->cue_mctab, CUE_MCAST_TABLE_LEN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cue_stop",
          "args": [
            "sc"
          ],
          "line": 1463
        },
        "resolved": true,
        "details": {
          "function_name": "cue_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_cue.c",
          "lines": "1516-1601",
          "snippet": "Static void\ncue_stop(sc)\n\tstruct cue_softc\t*sc;\n{\n\tusbd_status\t\terr;\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\ti;\n\n\tDPRINTFN(10,(\"%s: %s: enter\\n\", USBDEVNAME(sc->cue_dev),__FUNCTION__));\n\n\tifp = GET_IFP(sc);\n\tifp->if_timer = 0;\n\n\tcue_csr_write_1(sc, CUE_ETHCTL, 0);\n\tcue_reset(sc);\n\tusb_uncallout(sc->cue_stat_ch, cue_tick, sc);\n\n\t/* Stop transfers. */\n\tif (sc->cue_ep[CUE_ENDPT_RX] != NULL) {\n\t\terr = usbd_abort_pipe(sc->cue_ep[CUE_ENDPT_RX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort rx pipe failed: %s\\n\",\n\t\t\tUSBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->cue_ep[CUE_ENDPT_RX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close rx pipe failed: %s\\n\",\n\t\t\tUSBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->cue_ep[CUE_ENDPT_RX] = NULL;\n\t}\n\n\tif (sc->cue_ep[CUE_ENDPT_TX] != NULL) {\n\t\terr = usbd_abort_pipe(sc->cue_ep[CUE_ENDPT_TX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort tx pipe failed: %s\\n\",\n\t\t\tUSBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->cue_ep[CUE_ENDPT_TX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close tx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->cue_ep[CUE_ENDPT_TX] = NULL;\n\t}\n\n\tif (sc->cue_ep[CUE_ENDPT_INTR] != NULL) {\n\t\terr = usbd_abort_pipe(sc->cue_ep[CUE_ENDPT_INTR]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort intr pipe failed: %s\\n\",\n\t\t\tUSBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->cue_ep[CUE_ENDPT_INTR]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close intr pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->cue_ep[CUE_ENDPT_INTR] = NULL;\n\t}\n\n\t/* Free RX resources. */\n\tfor (i = 0; i < CUE_RX_LIST_CNT; i++) {\n\t\tif (sc->cue_cdata.cue_rx_chain[i].cue_mbuf != NULL) {\n\t\t\tm_freem(sc->cue_cdata.cue_rx_chain[i].cue_mbuf);\n\t\t\tsc->cue_cdata.cue_rx_chain[i].cue_mbuf = NULL;\n\t\t}\n\t\tif (sc->cue_cdata.cue_rx_chain[i].cue_xfer != NULL) {\n\t\t\tusbd_free_xfer(sc->cue_cdata.cue_rx_chain[i].cue_xfer);\n\t\t\tsc->cue_cdata.cue_rx_chain[i].cue_xfer = NULL;\n\t\t}\n\t}\n\n\t/* Free TX resources. */\n\tfor (i = 0; i < CUE_TX_LIST_CNT; i++) {\n\t\tif (sc->cue_cdata.cue_tx_chain[i].cue_mbuf != NULL) {\n\t\t\tm_freem(sc->cue_cdata.cue_tx_chain[i].cue_mbuf);\n\t\t\tsc->cue_cdata.cue_tx_chain[i].cue_mbuf = NULL;\n\t\t}\n\t\tif (sc->cue_cdata.cue_tx_chain[i].cue_xfer != NULL) {\n\t\t\tusbd_free_xfer(sc->cue_cdata.cue_tx_chain[i].cue_xfer);\n\t\t\tsc->cue_cdata.cue_tx_chain[i].cue_xfer = NULL;\n\t\t}\n\t}\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n}",
          "includes": [
            "#include <dev/usb/if_cuereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "cue_open_pipes\t__P((struct cue_softc *));",
            "Static int",
            "cue_tx_list_init\t__P((struct cue_softc *));",
            "Static int",
            "cue_rx_list_init\t__P((struct cue_softc *));",
            "Static int",
            "Static int",
            "Static void",
            "cue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "cue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "Static void",
            "cue_start\t\t__P((struct ifnet *));",
            "Static int",
            "Static void",
            "Static void",
            "cue_stop\t\t__P((struct cue_softc *));",
            "Static void",
            "cue_watchdog\t\t__P((struct ifnet *));",
            "Static void",
            "cue_setmulti\t__P((struct cue_softc *));",
            "Static void",
            "cue_reset\t\t__P((struct cue_softc *));",
            "Static int",
            "cue_csr_read_1\t__P((struct cue_softc *, int));",
            "Static int",
            "cue_csr_write_1\t__P((struct cue_softc *, int, int));",
            "Static int",
            "cue_csr_read_2\t__P((struct cue_softc *, int));",
            "Static int",
            "cue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));",
            "Static int",
            "cue_getmac\t\t__P((struct cue_softc *, void *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/if_cuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\ncue_open_pipes\t__P((struct cue_softc *));\nStatic int;\ncue_tx_list_init\t__P((struct cue_softc *));\nStatic int;\ncue_rx_list_init\t__P((struct cue_softc *));\nStatic int;\nStatic int;\nStatic void;\ncue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\ncue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic void;\ncue_start\t\t__P((struct ifnet *));\nStatic int;\nStatic void;\nStatic void;\ncue_stop\t\t__P((struct cue_softc *));\nStatic void;\ncue_watchdog\t\t__P((struct ifnet *));\nStatic void;\ncue_setmulti\t__P((struct cue_softc *));\nStatic void;\ncue_reset\t\t__P((struct cue_softc *));\nStatic int;\ncue_csr_read_1\t__P((struct cue_softc *, int));\nStatic int;\ncue_csr_write_1\t__P((struct cue_softc *, int, int));\nStatic int;\ncue_csr_read_2\t__P((struct cue_softc *, int));\nStatic int;\ncue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));\nStatic int;\ncue_getmac\t\t__P((struct cue_softc *, void *));\n\nStatic void\ncue_stop(sc)\n\tstruct cue_softc\t*sc;\n{\n\tusbd_status\t\terr;\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\ti;\n\n\tDPRINTFN(10,(\"%s: %s: enter\\n\", USBDEVNAME(sc->cue_dev),__FUNCTION__));\n\n\tifp = GET_IFP(sc);\n\tifp->if_timer = 0;\n\n\tcue_csr_write_1(sc, CUE_ETHCTL, 0);\n\tcue_reset(sc);\n\tusb_uncallout(sc->cue_stat_ch, cue_tick, sc);\n\n\t/* Stop transfers. */\n\tif (sc->cue_ep[CUE_ENDPT_RX] != NULL) {\n\t\terr = usbd_abort_pipe(sc->cue_ep[CUE_ENDPT_RX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort rx pipe failed: %s\\n\",\n\t\t\tUSBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->cue_ep[CUE_ENDPT_RX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close rx pipe failed: %s\\n\",\n\t\t\tUSBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->cue_ep[CUE_ENDPT_RX] = NULL;\n\t}\n\n\tif (sc->cue_ep[CUE_ENDPT_TX] != NULL) {\n\t\terr = usbd_abort_pipe(sc->cue_ep[CUE_ENDPT_TX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort tx pipe failed: %s\\n\",\n\t\t\tUSBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->cue_ep[CUE_ENDPT_TX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close tx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->cue_ep[CUE_ENDPT_TX] = NULL;\n\t}\n\n\tif (sc->cue_ep[CUE_ENDPT_INTR] != NULL) {\n\t\terr = usbd_abort_pipe(sc->cue_ep[CUE_ENDPT_INTR]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort intr pipe failed: %s\\n\",\n\t\t\tUSBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->cue_ep[CUE_ENDPT_INTR]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close intr pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->cue_ep[CUE_ENDPT_INTR] = NULL;\n\t}\n\n\t/* Free RX resources. */\n\tfor (i = 0; i < CUE_RX_LIST_CNT; i++) {\n\t\tif (sc->cue_cdata.cue_rx_chain[i].cue_mbuf != NULL) {\n\t\t\tm_freem(sc->cue_cdata.cue_rx_chain[i].cue_mbuf);\n\t\t\tsc->cue_cdata.cue_rx_chain[i].cue_mbuf = NULL;\n\t\t}\n\t\tif (sc->cue_cdata.cue_rx_chain[i].cue_xfer != NULL) {\n\t\t\tusbd_free_xfer(sc->cue_cdata.cue_rx_chain[i].cue_xfer);\n\t\t\tsc->cue_cdata.cue_rx_chain[i].cue_xfer = NULL;\n\t\t}\n\t}\n\n\t/* Free TX resources. */\n\tfor (i = 0; i < CUE_TX_LIST_CNT; i++) {\n\t\tif (sc->cue_cdata.cue_tx_chain[i].cue_mbuf != NULL) {\n\t\t\tm_freem(sc->cue_cdata.cue_tx_chain[i].cue_mbuf);\n\t\t\tsc->cue_cdata.cue_tx_chain[i].cue_mbuf = NULL;\n\t\t}\n\t\tif (sc->cue_cdata.cue_tx_chain[i].cue_xfer != NULL) {\n\t\t\tusbd_free_xfer(sc->cue_cdata.cue_tx_chain[i].cue_xfer);\n\t\t\tsc->cue_cdata.cue_tx_chain[i].cue_xfer = NULL;\n\t\t}\n\t}\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cue_init",
          "args": [
            "sc"
          ],
          "line": 1460
        },
        "resolved": true,
        "details": {
          "function_name": "cue_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_cue.c",
          "lines": "1252-1341",
          "snippet": "Static void\ncue_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct cue_softc\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = GET_IFP(sc);\n\tint\t\t\ti, s, ctl;\n\tu_char\t\t\t*eaddr;\n\n\tif (sc->cue_dying)\n\t\treturn;\n\n\tDPRINTFN(10,(\"%s: %s: enter\\n\", USBDEVNAME(sc->cue_dev),__FUNCTION__));\n\n\tif (ifp->if_flags & IFF_RUNNING)\n\t\treturn;\n\n\ts = splimp();\n\n\t/*\n\t * Cancel pending I/O and free all RX/TX buffers.\n\t */\n#if 1\n\tcue_reset(sc);\n#endif\n\n\t/* Set advanced operation modes. */\n\tcue_csr_write_1(sc, CUE_ADVANCED_OPMODES,\n\t    CUE_AOP_EMBED_RXLEN | 0x03); /* 1 wait state */\n\n#if defined(__FreeBSD__) || defined(__OpenBSD__)\n\teaddr = sc->arpcom.ac_enaddr;\n#elif defined(__NetBSD__)\n\teaddr = LLADDR(ifp->if_sadl);\n#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */\n\t/* Set MAC address */\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++)\n\t\tcue_csr_write_1(sc, CUE_PAR0 - i, eaddr[i]);\n\n\t/* Enable RX logic. */\n\tctl = CUE_ETHCTL_RX_ON | CUE_ETHCTL_MCAST_ON;\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tctl |= CUE_ETHCTL_PROMISC;\n\tcue_csr_write_1(sc, CUE_ETHCTL, ctl);\n\n\t/* Init TX ring. */\n\tif (cue_tx_list_init(sc) == ENOBUFS) {\n\t\tprintf(\"%s: tx list init failed\\n\", USBDEVNAME(sc->cue_dev));\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Init RX ring. */\n\tif (cue_rx_list_init(sc) == ENOBUFS) {\n\t\tprintf(\"%s: rx list init failed\\n\", USBDEVNAME(sc->cue_dev));\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Load the multicast filter. */\n\tcue_setmulti(sc);\n\n\t/*\n\t * Set the number of RX and TX buffers that we want\n\t * to reserve inside the ASIC.\n\t */\n\tcue_csr_write_1(sc, CUE_RX_BUFPKTS, CUE_RX_FRAMES);\n\tcue_csr_write_1(sc, CUE_TX_BUFPKTS, CUE_TX_FRAMES);\n\n\t/* Set advanced operation modes. */\n\tcue_csr_write_1(sc, CUE_ADVANCED_OPMODES,\n\t    CUE_AOP_EMBED_RXLEN | 0x01); /* 1 wait state */\n\n\t/* Program the LED operation. */\n\tcue_csr_write_1(sc, CUE_LEDCTL, CUE_LEDCTL_FOLLOW_LINK);\n\n\tif (sc->cue_ep[CUE_ENDPT_RX] == NULL) {\n\t\tif (cue_open_pipes(sc)) {\n\t\t\tsplx(s);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tsplx(s);\n\n\tusb_callout(sc->cue_stat_ch, hz, cue_tick, sc);\n}",
          "includes": [
            "#include <dev/usb/if_cuereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "cue_open_pipes\t__P((struct cue_softc *));",
            "Static int",
            "cue_tx_list_init\t__P((struct cue_softc *));",
            "Static int",
            "cue_rx_list_init\t__P((struct cue_softc *));",
            "Static int",
            "Static int",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "cue_start\t\t__P((struct ifnet *));",
            "Static int",
            "Static void",
            "Static void",
            "cue_stop\t\t__P((struct cue_softc *));",
            "Static void",
            "cue_watchdog\t\t__P((struct ifnet *));",
            "Static void",
            "cue_setmulti\t__P((struct cue_softc *));",
            "Static void",
            "cue_reset\t\t__P((struct cue_softc *));",
            "Static int",
            "cue_csr_read_1\t__P((struct cue_softc *, int));",
            "Static int",
            "cue_csr_write_1\t__P((struct cue_softc *, int, int));",
            "Static int",
            "cue_csr_read_2\t__P((struct cue_softc *, int));",
            "Static int",
            "cue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));",
            "Static int",
            "cue_getmac\t\t__P((struct cue_softc *, void *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/if_cuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\ncue_open_pipes\t__P((struct cue_softc *));\nStatic int;\ncue_tx_list_init\t__P((struct cue_softc *));\nStatic int;\ncue_rx_list_init\t__P((struct cue_softc *));\nStatic int;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\ncue_start\t\t__P((struct ifnet *));\nStatic int;\nStatic void;\nStatic void;\ncue_stop\t\t__P((struct cue_softc *));\nStatic void;\ncue_watchdog\t\t__P((struct ifnet *));\nStatic void;\ncue_setmulti\t__P((struct cue_softc *));\nStatic void;\ncue_reset\t\t__P((struct cue_softc *));\nStatic int;\ncue_csr_read_1\t__P((struct cue_softc *, int));\nStatic int;\ncue_csr_write_1\t__P((struct cue_softc *, int, int));\nStatic int;\ncue_csr_read_2\t__P((struct cue_softc *, int));\nStatic int;\ncue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));\nStatic int;\ncue_getmac\t\t__P((struct cue_softc *, void *));\n\nStatic void\ncue_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct cue_softc\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = GET_IFP(sc);\n\tint\t\t\ti, s, ctl;\n\tu_char\t\t\t*eaddr;\n\n\tif (sc->cue_dying)\n\t\treturn;\n\n\tDPRINTFN(10,(\"%s: %s: enter\\n\", USBDEVNAME(sc->cue_dev),__FUNCTION__));\n\n\tif (ifp->if_flags & IFF_RUNNING)\n\t\treturn;\n\n\ts = splimp();\n\n\t/*\n\t * Cancel pending I/O and free all RX/TX buffers.\n\t */\n#if 1\n\tcue_reset(sc);\n#endif\n\n\t/* Set advanced operation modes. */\n\tcue_csr_write_1(sc, CUE_ADVANCED_OPMODES,\n\t    CUE_AOP_EMBED_RXLEN | 0x03); /* 1 wait state */\n\n#if defined(__FreeBSD__) || defined(__OpenBSD__)\n\teaddr = sc->arpcom.ac_enaddr;\n#elif defined(__NetBSD__)\n\teaddr = LLADDR(ifp->if_sadl);\n#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */\n\t/* Set MAC address */\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++)\n\t\tcue_csr_write_1(sc, CUE_PAR0 - i, eaddr[i]);\n\n\t/* Enable RX logic. */\n\tctl = CUE_ETHCTL_RX_ON | CUE_ETHCTL_MCAST_ON;\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tctl |= CUE_ETHCTL_PROMISC;\n\tcue_csr_write_1(sc, CUE_ETHCTL, ctl);\n\n\t/* Init TX ring. */\n\tif (cue_tx_list_init(sc) == ENOBUFS) {\n\t\tprintf(\"%s: tx list init failed\\n\", USBDEVNAME(sc->cue_dev));\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Init RX ring. */\n\tif (cue_rx_list_init(sc) == ENOBUFS) {\n\t\tprintf(\"%s: rx list init failed\\n\", USBDEVNAME(sc->cue_dev));\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Load the multicast filter. */\n\tcue_setmulti(sc);\n\n\t/*\n\t * Set the number of RX and TX buffers that we want\n\t * to reserve inside the ASIC.\n\t */\n\tcue_csr_write_1(sc, CUE_RX_BUFPKTS, CUE_RX_FRAMES);\n\tcue_csr_write_1(sc, CUE_TX_BUFPKTS, CUE_TX_FRAMES);\n\n\t/* Set advanced operation modes. */\n\tcue_csr_write_1(sc, CUE_ADVANCED_OPMODES,\n\t    CUE_AOP_EMBED_RXLEN | 0x01); /* 1 wait state */\n\n\t/* Program the LED operation. */\n\tcue_csr_write_1(sc, CUE_LEDCTL, CUE_LEDCTL_FOLLOW_LINK);\n\n\tif (sc->cue_ep[CUE_ENDPT_RX] == NULL) {\n\t\tif (cue_open_pipes(sc)) {\n\t\t\tsplx(s);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tsplx(s);\n\n\tusb_callout(sc->cue_stat_ch, hz, cue_tick, sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CUE_CLRBIT",
          "args": [
            "sc",
            "CUE_ETHCTL",
            "CUE_ETHCTL_PROMISC"
          ],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CUE_SETBIT",
          "args": [
            "sc",
            "CUE_ETHCTL",
            "CUE_ETHCTL_PROMISC"
          ],
          "line": 1452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "LLADDR(ifp->if_sadl)",
            "ina->x_host.c_host",
            "ifp->if_addrlen"
          ],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LLADDR",
          "args": [
            "ifp->if_sadl"
          ],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LLADDR",
          "args": [
            "ifp->if_sadl"
          ],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_nullhost",
          "args": [
            "*ina"
          ],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IA_SNS",
          "args": [
            "ifa"
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arp_ifinit",
          "args": [
            "&sc->arpcom",
            "ifa"
          ],
          "line": 1416
        },
        "resolved": true,
        "details": {
          "function_name": "arp_ifinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_devar.h",
          "lines": "929-936",
          "snippet": "static void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}",
          "includes": [
            "#include <sys/devconf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/devconf.h>\n\nstatic void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ether_ioctl",
          "args": [
            "ifp",
            "command",
            "data"
          ],
          "line": 1403
        },
        "resolved": true,
        "details": {
          "function_name": "wx_ether_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
          "lines": "303-356",
          "snippet": "static int\nwx_ether_ioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tIOCTL_CMD_TYPE cmd;\n\tcaddr_t data;\n{\n\tstruct ifaddr *ifa = (struct ifaddr *) data;\n\tint error = 0;\n\twx_softc_t *sc = SOFTC_IFP(ifp);\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\t\terror = wx_init(sc);\n\t\tif (error) {\n\t\t\tifp->if_flags &= ~IFF_UP;\n\t\t\tbreak;\n\t\t}\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n#ifdef __OpenBSD__\n\t\t\tarp_ifinit(&sc->w.arpcom, ifa);\n#else\n\t\t\tarp_ifinit(ifp, ifa);\n#endif\n\t\t\tbreak;\n#endif\n#ifdef NS\n\t\tcase AF_NS:\n\t\t{\n\t\t\t register struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;\n\t\t\t if (ns_nullhost(*ina))\n\t\t\t\tina->x_host = *(union ns_host *)\n\t\t\t\t    LLADDR(ifp->if_sadl);\n\t\t\t else\n\t\t\t\tbcopy(ina->x_host.c_host, LLADDR(ifp->if_sadl),\n\t\t\t\t    ifp->if_addrlen);\n\t\t\t break;\n\t\t}\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <pci/if_wxvar.h>",
            "#include <dev/pci/if_wxvar.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int wx_init",
            "wx_eeprom_sibits __P((wx_softc_t *));",
            "wx_eeprom_cleanup __P((wx_softc_t *));",
            "wx_read_eeprom_word __P((wx_softc_t *, int));",
            "wx_mwi_whackon\t__P((wx_softc_t *));",
            "wx_mwi_unwhack\t__P((wx_softc_t *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic int wx_init;\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic int\nwx_ether_ioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tIOCTL_CMD_TYPE cmd;\n\tcaddr_t data;\n{\n\tstruct ifaddr *ifa = (struct ifaddr *) data;\n\tint error = 0;\n\twx_softc_t *sc = SOFTC_IFP(ifp);\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\t\terror = wx_init(sc);\n\t\tif (error) {\n\t\t\tifp->if_flags &= ~IFF_UP;\n\t\t\tbreak;\n\t\t}\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n#ifdef __OpenBSD__\n\t\t\tarp_ifinit(&sc->w.arpcom, ifa);\n#else\n\t\t\tarp_ifinit(ifp, ifa);\n#endif\n\t\t\tbreak;\n#endif\n#ifdef NS\n\t\tcase AF_NS:\n\t\t{\n\t\t\t register struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;\n\t\t\t if (ns_nullhost(*ina))\n\t\t\t\tina->x_host = *(union ns_host *)\n\t\t\t\t    LLADDR(ifp->if_sadl);\n\t\t\t else\n\t\t\t\tbcopy(ina->x_host.c_host, LLADDR(ifp->if_sadl),\n\t\t\t\t    ifp->if_addrlen);\n\t\t\t break;\n\t\t}\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/if_cuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\ncue_open_pipes\t__P((struct cue_softc *));\nStatic int;\ncue_tx_list_init\t__P((struct cue_softc *));\nStatic int;\ncue_rx_list_init\t__P((struct cue_softc *));\nStatic int;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\ncue_start\t\t__P((struct ifnet *));\nStatic int;\ncue_ioctl\t\t__P((struct ifnet *, u_long, caddr_t));\nStatic void;\nStatic void;\ncue_stop\t\t__P((struct cue_softc *));\nStatic void;\ncue_watchdog\t\t__P((struct ifnet *));\nStatic void;\ncue_setmulti\t__P((struct cue_softc *));\ncue_crc\t__P((caddr_t));\nStatic void;\ncue_reset\t\t__P((struct cue_softc *));\nStatic int;\ncue_csr_read_1\t__P((struct cue_softc *, int));\nStatic int;\ncue_csr_write_1\t__P((struct cue_softc *, int, int));\nStatic int;\ncue_csr_read_2\t__P((struct cue_softc *, int));\nStatic int;\ncue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));\nStatic int;\ncue_getmac\t\t__P((struct cue_softc *, void *));\n\nStatic int\ncue_ioctl(ifp, command, data)\n\tstruct ifnet\t\t*ifp;\n\tu_long\t\t\tcommand;\n\tcaddr_t\t\t\tdata;\n{\n\tstruct cue_softc\t*sc = ifp->if_softc;\n#if defined(__NetBSD__) || defined(__OpenBSD__)\n\tstruct ifaddr \t\t*ifa = (struct ifaddr *)data;\n\tstruct ifreq\t\t*ifr = (struct ifreq *)data;\n#endif\n\tint\t\t\ts, error = 0;\n\n\tif (sc->cue_dying)\n\t\treturn (EIO);\n\n\ts = splimp();\n\n\tswitch(command) {\n#if defined(__FreeBSD__)\n\tcase SIOCSIFADDR:\n\tcase SIOCGIFADDR:\n\tcase SIOCSIFMTU:\n\t\terror = ether_ioctl(ifp, command, data);\n\t\tbreak;\n#elif defined(__NetBSD__) || defined(__OpenBSD__)\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\t\tcue_init(sc);\n\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n#if defined(__NetBSD__)\n\t\t\tarp_ifinit(ifp, ifa);\n#else\n\t\t\tarp_ifinit(&sc->arpcom, ifa);\n#endif\n\t\t\tbreak;\n#endif /* INET */\n#ifdef NS\n\t\tcase AF_NS:\n\t\t    {\n\t\t\tstruct ns_addr *ina = &IA_SNS(ifa)->sns_addr;\n\n\t\t\tif (ns_nullhost(*ina))\n\t\t\t\tina->x_host = *(union ns_host *)\n\t\t\t\t\tLLADDR(ifp->if_sadl);\n\t\t\telse\n\t\t\t\tmemcpy(LLADDR(ifp->if_sadl),\n\t\t\t\t       ina->x_host.c_host,\n\t\t\t\t       ifp->if_addrlen);\n\t\t\tbreak;\n\t\t    }\n#endif /* NS */\n\t\t}\n\t\tbreak;\n\n\tcase SIOCSIFMTU:\n\t\tif (ifr->ifr_mtu > ETHERMTU)\n\t\t\terror = EINVAL;\n\t\telse\n\t\t\tifp->if_mtu = ifr->ifr_mtu;\n\t\tbreak;\n\n#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */\n\n\tcase SIOCSIFFLAGS:\n\t\tif (ifp->if_flags & IFF_UP) {\n\t\t\tif (ifp->if_flags & IFF_RUNNING &&\n\t\t\t    ifp->if_flags & IFF_PROMISC &&\n\t\t\t    !(sc->cue_if_flags & IFF_PROMISC)) {\n\t\t\t\tCUE_SETBIT(sc, CUE_ETHCTL, CUE_ETHCTL_PROMISC);\n\t\t\t\tcue_setmulti(sc);\n\t\t\t} else if (ifp->if_flags & IFF_RUNNING &&\n\t\t\t    !(ifp->if_flags & IFF_PROMISC) &&\n\t\t\t    sc->cue_if_flags & IFF_PROMISC) {\n\t\t\t\tCUE_CLRBIT(sc, CUE_ETHCTL, CUE_ETHCTL_PROMISC);\n\t\t\t\tcue_setmulti(sc);\n\t\t\t} else if (!(ifp->if_flags & IFF_RUNNING))\n\t\t\t\tcue_init(sc);\n\t\t} else {\n\t\t\tif (ifp->if_flags & IFF_RUNNING)\n\t\t\t\tcue_stop(sc);\n\t\t}\n\t\tsc->cue_if_flags = ifp->if_flags;\n\t\terror = 0;\n\t\tbreak;\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\t\tcue_setmulti(sc);\n\t\terror = 0;\n\t\tbreak;\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\tsplx(s);\n\n\treturn (error);\n}"
  },
  {
    "function_name": "cue_open_pipes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_cue.c",
    "lines": "1343-1378",
    "snippet": "Static int\ncue_open_pipes(sc)\n\tstruct cue_softc\t*sc;\n{\n\tstruct cue_chain\t*c;\n\tusbd_status\t\terr;\n\tint\t\t\ti;\n\n\t/* Open RX and TX pipes. */\n\terr = usbd_open_pipe(sc->cue_iface, sc->cue_ed[CUE_ENDPT_RX],\n\t    USBD_EXCLUSIVE_USE, &sc->cue_ep[CUE_ENDPT_RX]);\n\tif (err) {\n\t\tprintf(\"%s: open rx pipe failed: %s\\n\",\n\t\t    USBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\treturn (EIO);\n\t}\n\terr = usbd_open_pipe(sc->cue_iface, sc->cue_ed[CUE_ENDPT_TX],\n\t    USBD_EXCLUSIVE_USE, &sc->cue_ep[CUE_ENDPT_TX]);\n\tif (err) {\n\t\tprintf(\"%s: open tx pipe failed: %s\\n\",\n\t\t    USBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\treturn (EIO);\n\t}\n\n\t/* Start up the receive pipe. */\n\tfor (i = 0; i < CUE_RX_LIST_CNT; i++) {\n\t\tc = &sc->cue_cdata.cue_rx_chain[i];\n\t\tusbd_setup_xfer(c->cue_xfer, sc->cue_ep[CUE_ENDPT_RX],\n\t\t    c, c->cue_buf, CUE_BUFSZ,\n\t\t    USBD_SHORT_XFER_OK | USBD_NO_COPY, USBD_NO_TIMEOUT,\n\t\t    cue_rxeof);\n\t\tusbd_transfer(c->cue_xfer);\n\t}\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/usb/if_cuereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "cue_open_pipes\t__P((struct cue_softc *));",
      "Static int",
      "cue_tx_list_init\t__P((struct cue_softc *));",
      "Static int",
      "cue_rx_list_init\t__P((struct cue_softc *));",
      "Static int",
      "Static int",
      "Static void",
      "cue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "cue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "cue_stop\t\t__P((struct cue_softc *));",
      "Static void",
      "Static void",
      "cue_setmulti\t__P((struct cue_softc *));",
      "Static void",
      "cue_reset\t\t__P((struct cue_softc *));",
      "Static int",
      "cue_csr_read_1\t__P((struct cue_softc *, int));",
      "Static int",
      "cue_csr_write_1\t__P((struct cue_softc *, int, int));",
      "Static int",
      "cue_csr_read_2\t__P((struct cue_softc *, int));",
      "Static int",
      "cue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));",
      "Static int",
      "cue_getmac\t\t__P((struct cue_softc *, void *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usbd_transfer",
          "args": [
            "c->cue_xfer"
          ],
          "line": 1374
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_transfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "254-339",
          "snippet": "usbd_status\nusbd_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tusbd_status err;\n\tu_int size;\n\tint s;\n\n\tDPRINTFN(5,(\"usbd_transfer: xfer=%p, flags=%d, pipe=%p, running=%d\\n\",\n\t\t    xfer, xfer->flags, pipe, pipe->running));\n#ifdef USB_DEBUG\n\tif (usbdebug > 5)\n\t\tusbd_dump_queue(pipe);\n#endif\n\txfer->done = 0;\n\n\tif (pipe->aborting)\n\t\treturn (USBD_CANCELLED);\n\n\tsize = xfer->length;\n\t/* If there is no buffer, allocate one. */\n\tif (!(xfer->rqflags & URQ_DEV_DMABUF) && size != 0) {\n\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n#ifdef DIAGNOSTIC\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF)\n\t\t\tprintf(\"usbd_transfer: has old buffer!\\n\");\n#endif\n\t\terr = bus->methods->allocm(bus, dmap, size);\n\t\tif (err)\n\t\t\treturn (err);\n\t\txfer->rqflags |= URQ_AUTO_DMABUF;\n\t}\n\n\t/* Copy data if going out. */\n\tif (!(xfer->flags & USBD_NO_COPY) && size != 0 && \n\t    !usbd_xfer_isread(xfer))\n\t\tmemcpy(KERNADDR(dmap), xfer->buffer, size);\n\n\terr = pipe->methods->transfer(xfer);\n\n\tif (err != USBD_IN_PROGRESS && err) {\n\t\t/* The transfer has not been queued, so free buffer. */\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n\t\t\tbus->methods->freem(bus, &xfer->dmabuf);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!(xfer->flags & USBD_SYNCHRONOUS))\n\t\treturn (err);\n\n\t/* Sync transfer, wait for completion. */\n\tif (err != USBD_IN_PROGRESS)\n\t\treturn (err);\n\ts = splusb();\n\tif (!xfer->done) {\n\t\tif (pipe->device->bus->use_polling)\n\t\t\tpanic(\"usbd_transfer: not done\\n\");\n\t\t/* XXX Temporary hack XXX */\n\t\tif (xfer->flags & USBD_NO_TSLEEP) {\n\t\t\tint i;\n\t\t\tusbd_bus_handle bus = pipe->device->bus;\n\t\t\tint to = xfer->timeout * 1000;\n\t\t\tfor (i = 0; i < to; i += 10) {\n\t\t\t\tdelay(10);\n\t\t\t\tbus->methods->do_poll(bus);\n\t\t\t\tif (xfer->done)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* XXX Is this right, what about the HC timeout? */\n\t\t\tif (!xfer->done) {\n\t\t\t\tpipe->methods->abort(xfer);\n\t\t\t\txfer->status = USBD_TIMEOUT;\n\t\t\t}\n\t\t} else\n\t\t/* XXX End hack XXX */\n\t\t\ttsleep(xfer, PRIBIO, \"usbsyn\", 0);\n\t}\n\tsplx(s);\n\treturn (xfer->status);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "u_int32_t size;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nu_int32_t size;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nusbd_status\nusbd_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tusbd_status err;\n\tu_int size;\n\tint s;\n\n\tDPRINTFN(5,(\"usbd_transfer: xfer=%p, flags=%d, pipe=%p, running=%d\\n\",\n\t\t    xfer, xfer->flags, pipe, pipe->running));\n#ifdef USB_DEBUG\n\tif (usbdebug > 5)\n\t\tusbd_dump_queue(pipe);\n#endif\n\txfer->done = 0;\n\n\tif (pipe->aborting)\n\t\treturn (USBD_CANCELLED);\n\n\tsize = xfer->length;\n\t/* If there is no buffer, allocate one. */\n\tif (!(xfer->rqflags & URQ_DEV_DMABUF) && size != 0) {\n\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n#ifdef DIAGNOSTIC\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF)\n\t\t\tprintf(\"usbd_transfer: has old buffer!\\n\");\n#endif\n\t\terr = bus->methods->allocm(bus, dmap, size);\n\t\tif (err)\n\t\t\treturn (err);\n\t\txfer->rqflags |= URQ_AUTO_DMABUF;\n\t}\n\n\t/* Copy data if going out. */\n\tif (!(xfer->flags & USBD_NO_COPY) && size != 0 && \n\t    !usbd_xfer_isread(xfer))\n\t\tmemcpy(KERNADDR(dmap), xfer->buffer, size);\n\n\terr = pipe->methods->transfer(xfer);\n\n\tif (err != USBD_IN_PROGRESS && err) {\n\t\t/* The transfer has not been queued, so free buffer. */\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n\t\t\tbus->methods->freem(bus, &xfer->dmabuf);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!(xfer->flags & USBD_SYNCHRONOUS))\n\t\treturn (err);\n\n\t/* Sync transfer, wait for completion. */\n\tif (err != USBD_IN_PROGRESS)\n\t\treturn (err);\n\ts = splusb();\n\tif (!xfer->done) {\n\t\tif (pipe->device->bus->use_polling)\n\t\t\tpanic(\"usbd_transfer: not done\\n\");\n\t\t/* XXX Temporary hack XXX */\n\t\tif (xfer->flags & USBD_NO_TSLEEP) {\n\t\t\tint i;\n\t\t\tusbd_bus_handle bus = pipe->device->bus;\n\t\t\tint to = xfer->timeout * 1000;\n\t\t\tfor (i = 0; i < to; i += 10) {\n\t\t\t\tdelay(10);\n\t\t\t\tbus->methods->do_poll(bus);\n\t\t\t\tif (xfer->done)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* XXX Is this right, what about the HC timeout? */\n\t\t\tif (!xfer->done) {\n\t\t\t\tpipe->methods->abort(xfer);\n\t\t\t\txfer->status = USBD_TIMEOUT;\n\t\t\t}\n\t\t} else\n\t\t/* XXX End hack XXX */\n\t\t\ttsleep(xfer, PRIBIO, \"usbsyn\", 0);\n\t}\n\tsplx(s);\n\treturn (xfer->status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_setup_xfer",
          "args": [
            "c->cue_xfer",
            "sc->cue_ep[CUE_ENDPT_RX]",
            "c",
            "c->cue_buf",
            "CUE_BUFSZ",
            "USBD_SHORT_XFER_OK | USBD_NO_COPY",
            "USBD_NO_TIMEOUT",
            "cue_rxeof"
          ],
          "line": 1370
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_setup_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "420-444",
          "snippet": "void\nusbd_setup_xfer(xfer, pipe, priv, buffer, length, flags, timeout, callback)\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle pipe;\n\tusbd_private_handle priv;\n\tvoid *buffer;\n\tu_int32_t length;\n\tu_int16_t flags;\n\tu_int32_t timeout;\n\tvoid (*callback) __P((usbd_xfer_handle,\n\t\t\t      usbd_private_handle,\n\t\t\t      usbd_status));\n{\n\txfer->pipe = pipe;\n\txfer->priv = priv;\n\txfer->buffer = buffer;\n\txfer->length = length;\n\txfer->actlen = 0;\n\txfer->flags = flags;\n\txfer->timeout = timeout;\n\txfer->status = USBD_NOT_STARTED;\n\txfer->callback = callback;\n\txfer->rqflags &= ~URQ_REQUEST;\n\txfer->nframes = 0;\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nvoid\nusbd_setup_xfer(xfer, pipe, priv, buffer, length, flags, timeout, callback)\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle pipe;\n\tusbd_private_handle priv;\n\tvoid *buffer;\n\tu_int32_t length;\n\tu_int16_t flags;\n\tu_int32_t timeout;\n\tvoid (*callback) __P((usbd_xfer_handle,\n\t\t\t      usbd_private_handle,\n\t\t\t      usbd_status));\n{\n\txfer->pipe = pipe;\n\txfer->priv = priv;\n\txfer->buffer = buffer;\n\txfer->length = length;\n\txfer->actlen = 0;\n\txfer->flags = flags;\n\txfer->timeout = timeout;\n\txfer->status = USBD_NOT_STARTED;\n\txfer->callback = callback;\n\txfer->rqflags &= ~URQ_REQUEST;\n\txfer->nframes = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: open tx pipe failed: %s\\n\"",
            "USBDEVNAME(sc->cue_dev)",
            "usbd_errstr(err)"
          ],
          "line": 1362
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->cue_dev"
          ],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_open_pipe",
          "args": [
            "sc->cue_iface",
            "sc->cue_ed[CUE_ENDPT_TX]",
            "USBD_EXCLUSIVE_USE",
            "&sc->cue_ep[CUE_ENDPT_TX]"
          ],
          "line": 1359
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_open_pipe_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "177-222",
          "snippet": "usbd_status \nusbd_open_pipe_intr(iface, address, flags, pipe, priv, buffer, len, cb, ival)\n\tusbd_interface_handle iface;\n\tu_int8_t address;\n\tu_int8_t flags;\n\tusbd_pipe_handle *pipe;\n\tusbd_private_handle priv;\n\tvoid *buffer;\n\tu_int32_t len;\n\tusbd_callback cb;\n\tint ival;\n{\n\tusbd_status err;\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle ipipe;\n\n\tDPRINTFN(3,(\"usbd_open_pipe_intr: address=0x%x flags=0x%x len=%d\\n\",\n\t\t    address, flags, len));\n\n\terr = usbd_open_pipe_ival(iface, address, USBD_EXCLUSIVE_USE, \n\t\t\t\t  &ipipe, ival);\n\tif (err)\n\t\treturn (err);\n\txfer = usbd_alloc_xfer(iface->device);\n\tif (xfer == NULL) {\n\t\terr = USBD_NOMEM;\n\t\tgoto bad1;\n\t}\n\tusbd_setup_xfer(xfer, ipipe, priv, buffer, len, flags,\n\t    USBD_NO_TIMEOUT, cb);\n\tipipe->intrxfer = xfer;\n\tipipe->repeat = 1;\n\terr = usbd_transfer(xfer);\n\t*pipe = ipipe;\n\tif (err != USBD_IN_PROGRESS)\n\t\tgoto bad2;\n\treturn (USBD_NORMAL_COMPLETION);\n\n bad2:\n\tipipe->intrxfer = NULL;\n\tipipe->repeat = 0;\n\tusbd_free_xfer(xfer);\n bad1:\n\tusbd_close_pipe(ipipe);\n\treturn (err);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "usb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;",
            "usb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);",
            "usb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;",
            "u_int8_t address;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nusb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;\nusb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\nusb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;\nu_int8_t address;\n\nusbd_status \nusbd_open_pipe_intr(iface, address, flags, pipe, priv, buffer, len, cb, ival)\n\tusbd_interface_handle iface;\n\tu_int8_t address;\n\tu_int8_t flags;\n\tusbd_pipe_handle *pipe;\n\tusbd_private_handle priv;\n\tvoid *buffer;\n\tu_int32_t len;\n\tusbd_callback cb;\n\tint ival;\n{\n\tusbd_status err;\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle ipipe;\n\n\tDPRINTFN(3,(\"usbd_open_pipe_intr: address=0x%x flags=0x%x len=%d\\n\",\n\t\t    address, flags, len));\n\n\terr = usbd_open_pipe_ival(iface, address, USBD_EXCLUSIVE_USE, \n\t\t\t\t  &ipipe, ival);\n\tif (err)\n\t\treturn (err);\n\txfer = usbd_alloc_xfer(iface->device);\n\tif (xfer == NULL) {\n\t\terr = USBD_NOMEM;\n\t\tgoto bad1;\n\t}\n\tusbd_setup_xfer(xfer, ipipe, priv, buffer, len, flags,\n\t    USBD_NO_TIMEOUT, cb);\n\tipipe->intrxfer = xfer;\n\tipipe->repeat = 1;\n\terr = usbd_transfer(xfer);\n\t*pipe = ipipe;\n\tif (err != USBD_IN_PROGRESS)\n\t\tgoto bad2;\n\treturn (USBD_NORMAL_COMPLETION);\n\n bad2:\n\tipipe->intrxfer = NULL;\n\tipipe->repeat = 0;\n\tusbd_free_xfer(xfer);\n bad1:\n\tusbd_close_pipe(ipipe);\n\treturn (err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->cue_dev"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/if_cuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\ncue_open_pipes\t__P((struct cue_softc *));\nStatic int;\ncue_tx_list_init\t__P((struct cue_softc *));\nStatic int;\ncue_rx_list_init\t__P((struct cue_softc *));\nStatic int;\nStatic int;\nStatic void;\ncue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\ncue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\ncue_stop\t\t__P((struct cue_softc *));\nStatic void;\nStatic void;\ncue_setmulti\t__P((struct cue_softc *));\nStatic void;\ncue_reset\t\t__P((struct cue_softc *));\nStatic int;\ncue_csr_read_1\t__P((struct cue_softc *, int));\nStatic int;\ncue_csr_write_1\t__P((struct cue_softc *, int, int));\nStatic int;\ncue_csr_read_2\t__P((struct cue_softc *, int));\nStatic int;\ncue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));\nStatic int;\ncue_getmac\t\t__P((struct cue_softc *, void *));\n\nStatic int\ncue_open_pipes(sc)\n\tstruct cue_softc\t*sc;\n{\n\tstruct cue_chain\t*c;\n\tusbd_status\t\terr;\n\tint\t\t\ti;\n\n\t/* Open RX and TX pipes. */\n\terr = usbd_open_pipe(sc->cue_iface, sc->cue_ed[CUE_ENDPT_RX],\n\t    USBD_EXCLUSIVE_USE, &sc->cue_ep[CUE_ENDPT_RX]);\n\tif (err) {\n\t\tprintf(\"%s: open rx pipe failed: %s\\n\",\n\t\t    USBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\treturn (EIO);\n\t}\n\terr = usbd_open_pipe(sc->cue_iface, sc->cue_ed[CUE_ENDPT_TX],\n\t    USBD_EXCLUSIVE_USE, &sc->cue_ep[CUE_ENDPT_TX]);\n\tif (err) {\n\t\tprintf(\"%s: open tx pipe failed: %s\\n\",\n\t\t    USBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\treturn (EIO);\n\t}\n\n\t/* Start up the receive pipe. */\n\tfor (i = 0; i < CUE_RX_LIST_CNT; i++) {\n\t\tc = &sc->cue_cdata.cue_rx_chain[i];\n\t\tusbd_setup_xfer(c->cue_xfer, sc->cue_ep[CUE_ENDPT_RX],\n\t\t    c, c->cue_buf, CUE_BUFSZ,\n\t\t    USBD_SHORT_XFER_OK | USBD_NO_COPY, USBD_NO_TIMEOUT,\n\t\t    cue_rxeof);\n\t\tusbd_transfer(c->cue_xfer);\n\t}\n\n\treturn (0);\n}"
  },
  {
    "function_name": "cue_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_cue.c",
    "lines": "1252-1341",
    "snippet": "Static void\ncue_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct cue_softc\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = GET_IFP(sc);\n\tint\t\t\ti, s, ctl;\n\tu_char\t\t\t*eaddr;\n\n\tif (sc->cue_dying)\n\t\treturn;\n\n\tDPRINTFN(10,(\"%s: %s: enter\\n\", USBDEVNAME(sc->cue_dev),__FUNCTION__));\n\n\tif (ifp->if_flags & IFF_RUNNING)\n\t\treturn;\n\n\ts = splimp();\n\n\t/*\n\t * Cancel pending I/O and free all RX/TX buffers.\n\t */\n#if 1\n\tcue_reset(sc);\n#endif\n\n\t/* Set advanced operation modes. */\n\tcue_csr_write_1(sc, CUE_ADVANCED_OPMODES,\n\t    CUE_AOP_EMBED_RXLEN | 0x03); /* 1 wait state */\n\n#if defined(__FreeBSD__) || defined(__OpenBSD__)\n\teaddr = sc->arpcom.ac_enaddr;\n#elif defined(__NetBSD__)\n\teaddr = LLADDR(ifp->if_sadl);\n#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */\n\t/* Set MAC address */\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++)\n\t\tcue_csr_write_1(sc, CUE_PAR0 - i, eaddr[i]);\n\n\t/* Enable RX logic. */\n\tctl = CUE_ETHCTL_RX_ON | CUE_ETHCTL_MCAST_ON;\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tctl |= CUE_ETHCTL_PROMISC;\n\tcue_csr_write_1(sc, CUE_ETHCTL, ctl);\n\n\t/* Init TX ring. */\n\tif (cue_tx_list_init(sc) == ENOBUFS) {\n\t\tprintf(\"%s: tx list init failed\\n\", USBDEVNAME(sc->cue_dev));\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Init RX ring. */\n\tif (cue_rx_list_init(sc) == ENOBUFS) {\n\t\tprintf(\"%s: rx list init failed\\n\", USBDEVNAME(sc->cue_dev));\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Load the multicast filter. */\n\tcue_setmulti(sc);\n\n\t/*\n\t * Set the number of RX and TX buffers that we want\n\t * to reserve inside the ASIC.\n\t */\n\tcue_csr_write_1(sc, CUE_RX_BUFPKTS, CUE_RX_FRAMES);\n\tcue_csr_write_1(sc, CUE_TX_BUFPKTS, CUE_TX_FRAMES);\n\n\t/* Set advanced operation modes. */\n\tcue_csr_write_1(sc, CUE_ADVANCED_OPMODES,\n\t    CUE_AOP_EMBED_RXLEN | 0x01); /* 1 wait state */\n\n\t/* Program the LED operation. */\n\tcue_csr_write_1(sc, CUE_LEDCTL, CUE_LEDCTL_FOLLOW_LINK);\n\n\tif (sc->cue_ep[CUE_ENDPT_RX] == NULL) {\n\t\tif (cue_open_pipes(sc)) {\n\t\t\tsplx(s);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tsplx(s);\n\n\tusb_callout(sc->cue_stat_ch, hz, cue_tick, sc);\n}",
    "includes": [
      "#include <dev/usb/if_cuereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "cue_open_pipes\t__P((struct cue_softc *));",
      "Static int",
      "cue_tx_list_init\t__P((struct cue_softc *));",
      "Static int",
      "cue_rx_list_init\t__P((struct cue_softc *));",
      "Static int",
      "Static int",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "cue_start\t\t__P((struct ifnet *));",
      "Static int",
      "Static void",
      "Static void",
      "cue_stop\t\t__P((struct cue_softc *));",
      "Static void",
      "cue_watchdog\t\t__P((struct ifnet *));",
      "Static void",
      "cue_setmulti\t__P((struct cue_softc *));",
      "Static void",
      "cue_reset\t\t__P((struct cue_softc *));",
      "Static int",
      "cue_csr_read_1\t__P((struct cue_softc *, int));",
      "Static int",
      "cue_csr_write_1\t__P((struct cue_softc *, int, int));",
      "Static int",
      "cue_csr_read_2\t__P((struct cue_softc *, int));",
      "Static int",
      "cue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));",
      "Static int",
      "cue_getmac\t\t__P((struct cue_softc *, void *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usb_callout",
          "args": [
            "sc->cue_stat_ch",
            "hz",
            "cue_tick",
            "sc"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cue_open_pipes",
          "args": [
            "sc"
          ],
          "line": 1329
        },
        "resolved": true,
        "details": {
          "function_name": "cue_open_pipes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_cue.c",
          "lines": "1343-1378",
          "snippet": "Static int\ncue_open_pipes(sc)\n\tstruct cue_softc\t*sc;\n{\n\tstruct cue_chain\t*c;\n\tusbd_status\t\terr;\n\tint\t\t\ti;\n\n\t/* Open RX and TX pipes. */\n\terr = usbd_open_pipe(sc->cue_iface, sc->cue_ed[CUE_ENDPT_RX],\n\t    USBD_EXCLUSIVE_USE, &sc->cue_ep[CUE_ENDPT_RX]);\n\tif (err) {\n\t\tprintf(\"%s: open rx pipe failed: %s\\n\",\n\t\t    USBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\treturn (EIO);\n\t}\n\terr = usbd_open_pipe(sc->cue_iface, sc->cue_ed[CUE_ENDPT_TX],\n\t    USBD_EXCLUSIVE_USE, &sc->cue_ep[CUE_ENDPT_TX]);\n\tif (err) {\n\t\tprintf(\"%s: open tx pipe failed: %s\\n\",\n\t\t    USBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\treturn (EIO);\n\t}\n\n\t/* Start up the receive pipe. */\n\tfor (i = 0; i < CUE_RX_LIST_CNT; i++) {\n\t\tc = &sc->cue_cdata.cue_rx_chain[i];\n\t\tusbd_setup_xfer(c->cue_xfer, sc->cue_ep[CUE_ENDPT_RX],\n\t\t    c, c->cue_buf, CUE_BUFSZ,\n\t\t    USBD_SHORT_XFER_OK | USBD_NO_COPY, USBD_NO_TIMEOUT,\n\t\t    cue_rxeof);\n\t\tusbd_transfer(c->cue_xfer);\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/usb/if_cuereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "cue_open_pipes\t__P((struct cue_softc *));",
            "Static int",
            "cue_tx_list_init\t__P((struct cue_softc *));",
            "Static int",
            "cue_rx_list_init\t__P((struct cue_softc *));",
            "Static int",
            "Static int",
            "Static void",
            "cue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "cue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "cue_stop\t\t__P((struct cue_softc *));",
            "Static void",
            "Static void",
            "cue_setmulti\t__P((struct cue_softc *));",
            "Static void",
            "cue_reset\t\t__P((struct cue_softc *));",
            "Static int",
            "cue_csr_read_1\t__P((struct cue_softc *, int));",
            "Static int",
            "cue_csr_write_1\t__P((struct cue_softc *, int, int));",
            "Static int",
            "cue_csr_read_2\t__P((struct cue_softc *, int));",
            "Static int",
            "cue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));",
            "Static int",
            "cue_getmac\t\t__P((struct cue_softc *, void *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/if_cuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\ncue_open_pipes\t__P((struct cue_softc *));\nStatic int;\ncue_tx_list_init\t__P((struct cue_softc *));\nStatic int;\ncue_rx_list_init\t__P((struct cue_softc *));\nStatic int;\nStatic int;\nStatic void;\ncue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\ncue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\ncue_stop\t\t__P((struct cue_softc *));\nStatic void;\nStatic void;\ncue_setmulti\t__P((struct cue_softc *));\nStatic void;\ncue_reset\t\t__P((struct cue_softc *));\nStatic int;\ncue_csr_read_1\t__P((struct cue_softc *, int));\nStatic int;\ncue_csr_write_1\t__P((struct cue_softc *, int, int));\nStatic int;\ncue_csr_read_2\t__P((struct cue_softc *, int));\nStatic int;\ncue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));\nStatic int;\ncue_getmac\t\t__P((struct cue_softc *, void *));\n\nStatic int\ncue_open_pipes(sc)\n\tstruct cue_softc\t*sc;\n{\n\tstruct cue_chain\t*c;\n\tusbd_status\t\terr;\n\tint\t\t\ti;\n\n\t/* Open RX and TX pipes. */\n\terr = usbd_open_pipe(sc->cue_iface, sc->cue_ed[CUE_ENDPT_RX],\n\t    USBD_EXCLUSIVE_USE, &sc->cue_ep[CUE_ENDPT_RX]);\n\tif (err) {\n\t\tprintf(\"%s: open rx pipe failed: %s\\n\",\n\t\t    USBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\treturn (EIO);\n\t}\n\terr = usbd_open_pipe(sc->cue_iface, sc->cue_ed[CUE_ENDPT_TX],\n\t    USBD_EXCLUSIVE_USE, &sc->cue_ep[CUE_ENDPT_TX]);\n\tif (err) {\n\t\tprintf(\"%s: open tx pipe failed: %s\\n\",\n\t\t    USBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\treturn (EIO);\n\t}\n\n\t/* Start up the receive pipe. */\n\tfor (i = 0; i < CUE_RX_LIST_CNT; i++) {\n\t\tc = &sc->cue_cdata.cue_rx_chain[i];\n\t\tusbd_setup_xfer(c->cue_xfer, sc->cue_ep[CUE_ENDPT_RX],\n\t\t    c, c->cue_buf, CUE_BUFSZ,\n\t\t    USBD_SHORT_XFER_OK | USBD_NO_COPY, USBD_NO_TIMEOUT,\n\t\t    cue_rxeof);\n\t\tusbd_transfer(c->cue_xfer);\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cue_csr_write_1",
          "args": [
            "sc",
            "CUE_LEDCTL",
            "CUE_LEDCTL_FOLLOW_LINK"
          ],
          "line": 1326
        },
        "resolved": true,
        "details": {
          "function_name": "cue_csr_write_1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_cue.c",
          "lines": "314-349",
          "snippet": "Static int\ncue_csr_write_1(sc, reg, val)\n\tstruct cue_softc\t*sc;\n\tint\t\t\treg, val;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tint\t\t\ts;\n\n\tif (sc->cue_dying)\n\t\treturn (0);\n\n\tDPRINTFN(10,(\"%s: cue_csr_write_1 reg=0x%x val=0x%x\\n\", \n\t\t     USBDEVNAME(sc->cue_dev), reg, val));\n\n\treq.bmRequestType = UT_WRITE_VENDOR_DEVICE;\n\treq.bRequest = CUE_CMD_WRITEREG;\n\tUSETW(req.wValue, val);\n\tUSETW(req.wIndex, reg);\n\tUSETW(req.wLength, 0);\n\n\ts = splusb();\n\terr = CUE_DO_REQUEST(sc->cue_udev, &req, NULL);\n\tsplx(s);\n\n\tif (err) {\n\t\tDPRINTF((\"%s: cue_csr_write_1: reg=0x%x err=%s\\n\",\n\t\t\t USBDEVNAME(sc->cue_dev), reg, usbd_errstr(err)));\n\t\treturn (-1);\n\t}\n\n\tDPRINTFN(20,(\"%s: cue_csr_write_1, after reg=0x%x val=0x%x\\n\", \n\t\t     USBDEVNAME(sc->cue_dev), reg, cue_csr_read_1(sc, reg)));\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/usb/if_cuereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "cue_open_pipes\t__P((struct cue_softc *));",
            "Static int",
            "cue_tx_list_init\t__P((struct cue_softc *));",
            "Static int",
            "cue_rx_list_init\t__P((struct cue_softc *));",
            "Static int",
            "Static int",
            "Static void",
            "cue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "cue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "cue_stop\t\t__P((struct cue_softc *));",
            "Static void",
            "Static void",
            "cue_setmulti\t__P((struct cue_softc *));",
            "Static void",
            "cue_reset\t\t__P((struct cue_softc *));",
            "Static int",
            "cue_csr_read_1\t__P((struct cue_softc *, int));",
            "Static int",
            "cue_csr_write_1\t__P((struct cue_softc *, int, int));",
            "Static int",
            "cue_csr_read_2\t__P((struct cue_softc *, int));",
            "Static int",
            "cue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));",
            "Static int",
            "cue_getmac\t\t__P((struct cue_softc *, void *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/if_cuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\ncue_open_pipes\t__P((struct cue_softc *));\nStatic int;\ncue_tx_list_init\t__P((struct cue_softc *));\nStatic int;\ncue_rx_list_init\t__P((struct cue_softc *));\nStatic int;\nStatic int;\nStatic void;\ncue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\ncue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\ncue_stop\t\t__P((struct cue_softc *));\nStatic void;\nStatic void;\ncue_setmulti\t__P((struct cue_softc *));\nStatic void;\ncue_reset\t\t__P((struct cue_softc *));\nStatic int;\ncue_csr_read_1\t__P((struct cue_softc *, int));\nStatic int;\ncue_csr_write_1\t__P((struct cue_softc *, int, int));\nStatic int;\ncue_csr_read_2\t__P((struct cue_softc *, int));\nStatic int;\ncue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));\nStatic int;\ncue_getmac\t\t__P((struct cue_softc *, void *));\n\nStatic int\ncue_csr_write_1(sc, reg, val)\n\tstruct cue_softc\t*sc;\n\tint\t\t\treg, val;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tint\t\t\ts;\n\n\tif (sc->cue_dying)\n\t\treturn (0);\n\n\tDPRINTFN(10,(\"%s: cue_csr_write_1 reg=0x%x val=0x%x\\n\", \n\t\t     USBDEVNAME(sc->cue_dev), reg, val));\n\n\treq.bmRequestType = UT_WRITE_VENDOR_DEVICE;\n\treq.bRequest = CUE_CMD_WRITEREG;\n\tUSETW(req.wValue, val);\n\tUSETW(req.wIndex, reg);\n\tUSETW(req.wLength, 0);\n\n\ts = splusb();\n\terr = CUE_DO_REQUEST(sc->cue_udev, &req, NULL);\n\tsplx(s);\n\n\tif (err) {\n\t\tDPRINTF((\"%s: cue_csr_write_1: reg=0x%x err=%s\\n\",\n\t\t\t USBDEVNAME(sc->cue_dev), reg, usbd_errstr(err)));\n\t\treturn (-1);\n\t}\n\n\tDPRINTFN(20,(\"%s: cue_csr_write_1, after reg=0x%x val=0x%x\\n\", \n\t\t     USBDEVNAME(sc->cue_dev), reg, cue_csr_read_1(sc, reg)));\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cue_setmulti",
          "args": [
            "sc"
          ],
          "line": 1312
        },
        "resolved": true,
        "details": {
          "function_name": "cue_setmulti",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_cue.c",
          "lines": "475-546",
          "snippet": "Static void\ncue_setmulti(sc)\n\tstruct cue_softc\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n#if defined(__FreeBSD__)\n\tstruct ifmultiaddr\t*ifma;\n#elif defined(__NetBSD__) || defined(__OpenBSD__)\n\tstruct ether_multi\t*enm;\n\tstruct ether_multistep\tstep;\n#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */\n\tu_int32_t\t\th, i;\n\n\tifp = GET_IFP(sc);\n\n\tDPRINTFN(2,(\"%s: cue_setmulti if_flags=0x%x\\n\", \n\t\t    USBDEVNAME(sc->cue_dev), ifp->if_flags));\n\n\tif (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {\n\t\tfor (i = 0; i < CUE_MCAST_TABLE_LEN; i++)\n\t\t\tsc->cue_mctab[i] = 0xFF;\n\t\tcue_mem(sc, CUE_CMD_WRITESRAM, CUE_MCAST_TABLE_ADDR,\n\t\t    &sc->cue_mctab, CUE_MCAST_TABLE_LEN);\n\t\treturn;\n\t}\n\n\t/* first, zot all the existing hash bits */\n\tfor (i = 0; i < CUE_MCAST_TABLE_LEN; i++)\n\t\tsc->cue_mctab[i] = 0;\n\n\t/* now program new ones */\n#if defined(__FreeBSD__)\n\tfor (ifma = ifp->if_multiaddrs.lh_first; ifma != NULL;\n\t    ifma = ifma->ifma_link.le_next) {\n\t\tif (ifma->ifma_addr->sa_family != AF_LINK)\n\t\t\tcontinue;\n\t\th = cue_crc(LLADDR((struct sockaddr_dl *)ifma->ifma_addr));\n\t\tsc->cue_mctab[h >> 3] |= 1 << (h & 0x7);\t\t\n\t}\n#elif defined(__NetBSD__) || defined(__OpenBSD__)\n#if defined(__NetBSD__)\n\tETHER_FIRST_MULTI(step, &sc->cue_ec, enm);\n#else\n\tETHER_FIRST_MULTI(step, &sc->arpcom, enm);\n#endif\n\twhile (enm != NULL) {\n#if 0\n\t\tif (memcmp(enm->enm_addrlo,\n\t\t\t   enm->enm_addrhi, ETHER_ADDR_LEN) != 0) {\n\t\t\tifp->if_flags |= IFF_ALLMULTI;\n\t\t\t/* XXX what now? */\n\t\t\treturn;\n\t\t}\n#endif\n\t\th = cue_crc(enm->enm_addrlo);\n\t\tsc->cue_mctab[h >> 3] |= 1 << (h & 0x7);\t\t\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */\n\n\t/*\n\t * Also include the broadcast address in the filter\n\t * so we can receive broadcast frames.\n\t */\n\tif (ifp->if_flags & IFF_BROADCAST) {\n\t\th = cue_crc(etherbroadcastaddr);\n\t\tsc->cue_mctab[h >> 3] |= 1 << (h & 0x7);\t\t\n\t}\n\n\tcue_mem(sc, CUE_CMD_WRITESRAM, CUE_MCAST_TABLE_ADDR,\n\t    &sc->cue_mctab, CUE_MCAST_TABLE_LEN);\n}",
          "includes": [
            "#include <dev/usb/if_cuereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "cue_open_pipes\t__P((struct cue_softc *));",
            "Static int",
            "cue_tx_list_init\t__P((struct cue_softc *));",
            "Static int",
            "cue_rx_list_init\t__P((struct cue_softc *));",
            "Static int",
            "Static int",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "cue_start\t\t__P((struct ifnet *));",
            "Static int",
            "Static void",
            "Static void",
            "cue_stop\t\t__P((struct cue_softc *));",
            "Static void",
            "cue_watchdog\t\t__P((struct ifnet *));",
            "Static void",
            "cue_setmulti\t__P((struct cue_softc *));",
            "Static u_int32_t",
            "Static void",
            "cue_reset\t\t__P((struct cue_softc *));",
            "Static int",
            "cue_csr_read_1\t__P((struct cue_softc *, int));",
            "Static int",
            "cue_csr_write_1\t__P((struct cue_softc *, int, int));",
            "Static int",
            "cue_csr_read_2\t__P((struct cue_softc *, int));",
            "Static int",
            "cue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));",
            "Static int",
            "cue_getmac\t\t__P((struct cue_softc *, void *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/if_cuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\ncue_open_pipes\t__P((struct cue_softc *));\nStatic int;\ncue_tx_list_init\t__P((struct cue_softc *));\nStatic int;\ncue_rx_list_init\t__P((struct cue_softc *));\nStatic int;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\ncue_start\t\t__P((struct ifnet *));\nStatic int;\nStatic void;\nStatic void;\ncue_stop\t\t__P((struct cue_softc *));\nStatic void;\ncue_watchdog\t\t__P((struct ifnet *));\nStatic void;\ncue_setmulti\t__P((struct cue_softc *));\nStatic u_int32_t;\nStatic void;\ncue_reset\t\t__P((struct cue_softc *));\nStatic int;\ncue_csr_read_1\t__P((struct cue_softc *, int));\nStatic int;\ncue_csr_write_1\t__P((struct cue_softc *, int, int));\nStatic int;\ncue_csr_read_2\t__P((struct cue_softc *, int));\nStatic int;\ncue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));\nStatic int;\ncue_getmac\t\t__P((struct cue_softc *, void *));\n\nStatic void\ncue_setmulti(sc)\n\tstruct cue_softc\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n#if defined(__FreeBSD__)\n\tstruct ifmultiaddr\t*ifma;\n#elif defined(__NetBSD__) || defined(__OpenBSD__)\n\tstruct ether_multi\t*enm;\n\tstruct ether_multistep\tstep;\n#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */\n\tu_int32_t\t\th, i;\n\n\tifp = GET_IFP(sc);\n\n\tDPRINTFN(2,(\"%s: cue_setmulti if_flags=0x%x\\n\", \n\t\t    USBDEVNAME(sc->cue_dev), ifp->if_flags));\n\n\tif (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {\n\t\tfor (i = 0; i < CUE_MCAST_TABLE_LEN; i++)\n\t\t\tsc->cue_mctab[i] = 0xFF;\n\t\tcue_mem(sc, CUE_CMD_WRITESRAM, CUE_MCAST_TABLE_ADDR,\n\t\t    &sc->cue_mctab, CUE_MCAST_TABLE_LEN);\n\t\treturn;\n\t}\n\n\t/* first, zot all the existing hash bits */\n\tfor (i = 0; i < CUE_MCAST_TABLE_LEN; i++)\n\t\tsc->cue_mctab[i] = 0;\n\n\t/* now program new ones */\n#if defined(__FreeBSD__)\n\tfor (ifma = ifp->if_multiaddrs.lh_first; ifma != NULL;\n\t    ifma = ifma->ifma_link.le_next) {\n\t\tif (ifma->ifma_addr->sa_family != AF_LINK)\n\t\t\tcontinue;\n\t\th = cue_crc(LLADDR((struct sockaddr_dl *)ifma->ifma_addr));\n\t\tsc->cue_mctab[h >> 3] |= 1 << (h & 0x7);\t\t\n\t}\n#elif defined(__NetBSD__) || defined(__OpenBSD__)\n#if defined(__NetBSD__)\n\tETHER_FIRST_MULTI(step, &sc->cue_ec, enm);\n#else\n\tETHER_FIRST_MULTI(step, &sc->arpcom, enm);\n#endif\n\twhile (enm != NULL) {\n#if 0\n\t\tif (memcmp(enm->enm_addrlo,\n\t\t\t   enm->enm_addrhi, ETHER_ADDR_LEN) != 0) {\n\t\t\tifp->if_flags |= IFF_ALLMULTI;\n\t\t\t/* XXX what now? */\n\t\t\treturn;\n\t\t}\n#endif\n\t\th = cue_crc(enm->enm_addrlo);\n\t\tsc->cue_mctab[h >> 3] |= 1 << (h & 0x7);\t\t\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */\n\n\t/*\n\t * Also include the broadcast address in the filter\n\t * so we can receive broadcast frames.\n\t */\n\tif (ifp->if_flags & IFF_BROADCAST) {\n\t\th = cue_crc(etherbroadcastaddr);\n\t\tsc->cue_mctab[h >> 3] |= 1 << (h & 0x7);\t\t\n\t}\n\n\tcue_mem(sc, CUE_CMD_WRITESRAM, CUE_MCAST_TABLE_ADDR,\n\t    &sc->cue_mctab, CUE_MCAST_TABLE_LEN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: rx list init failed\\n\"",
            "USBDEVNAME(sc->cue_dev)"
          ],
          "line": 1306
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->cue_dev"
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cue_rx_list_init",
          "args": [
            "sc"
          ],
          "line": 1305
        },
        "resolved": true,
        "details": {
          "function_name": "cue_rx_list_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_cue.c",
          "lines": "870-898",
          "snippet": "Static int\ncue_rx_list_init(sc)\n\tstruct cue_softc\t*sc;\n{\n\tstruct cue_cdata\t*cd;\n\tstruct cue_chain\t*c;\n\tint\t\t\ti;\n\n\tcd = &sc->cue_cdata;\n\tfor (i = 0; i < CUE_RX_LIST_CNT; i++) {\n\t\tc = &cd->cue_rx_chain[i];\n\t\tc->cue_sc = sc;\n\t\tc->cue_idx = i;\n\t\tif (cue_newbuf(sc, c, NULL) == ENOBUFS)\n\t\t\treturn (ENOBUFS);\n\t\tif (c->cue_xfer == NULL) {\n\t\t\tc->cue_xfer = usbd_alloc_xfer(sc->cue_udev);\n\t\t\tif (c->cue_xfer == NULL)\n\t\t\t\treturn (ENOBUFS);\n\t\t\tc->cue_buf = usbd_alloc_buffer(c->cue_xfer, CUE_BUFSZ);\n\t\t\tif (c->cue_buf == NULL) {\n\t\t\t\tusbd_free_xfer(c->cue_xfer);\n\t\t\t\treturn (ENOBUFS);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/usb/if_cuereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "cue_open_pipes\t__P((struct cue_softc *));",
            "Static int",
            "cue_tx_list_init\t__P((struct cue_softc *));",
            "Static int",
            "cue_rx_list_init\t__P((struct cue_softc *));",
            "Static int",
            "Static int",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "cue_stop\t\t__P((struct cue_softc *));",
            "Static void",
            "Static void",
            "cue_setmulti\t__P((struct cue_softc *));",
            "Static void",
            "cue_reset\t\t__P((struct cue_softc *));",
            "Static int",
            "cue_csr_read_1\t__P((struct cue_softc *, int));",
            "Static int",
            "cue_csr_write_1\t__P((struct cue_softc *, int, int));",
            "Static int",
            "cue_csr_read_2\t__P((struct cue_softc *, int));",
            "Static int",
            "cue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));",
            "Static int",
            "cue_getmac\t\t__P((struct cue_softc *, void *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/if_cuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\ncue_open_pipes\t__P((struct cue_softc *));\nStatic int;\ncue_tx_list_init\t__P((struct cue_softc *));\nStatic int;\ncue_rx_list_init\t__P((struct cue_softc *));\nStatic int;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\ncue_stop\t\t__P((struct cue_softc *));\nStatic void;\nStatic void;\ncue_setmulti\t__P((struct cue_softc *));\nStatic void;\ncue_reset\t\t__P((struct cue_softc *));\nStatic int;\ncue_csr_read_1\t__P((struct cue_softc *, int));\nStatic int;\ncue_csr_write_1\t__P((struct cue_softc *, int, int));\nStatic int;\ncue_csr_read_2\t__P((struct cue_softc *, int));\nStatic int;\ncue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));\nStatic int;\ncue_getmac\t\t__P((struct cue_softc *, void *));\n\nStatic int\ncue_rx_list_init(sc)\n\tstruct cue_softc\t*sc;\n{\n\tstruct cue_cdata\t*cd;\n\tstruct cue_chain\t*c;\n\tint\t\t\ti;\n\n\tcd = &sc->cue_cdata;\n\tfor (i = 0; i < CUE_RX_LIST_CNT; i++) {\n\t\tc = &cd->cue_rx_chain[i];\n\t\tc->cue_sc = sc;\n\t\tc->cue_idx = i;\n\t\tif (cue_newbuf(sc, c, NULL) == ENOBUFS)\n\t\t\treturn (ENOBUFS);\n\t\tif (c->cue_xfer == NULL) {\n\t\t\tc->cue_xfer = usbd_alloc_xfer(sc->cue_udev);\n\t\t\tif (c->cue_xfer == NULL)\n\t\t\t\treturn (ENOBUFS);\n\t\t\tc->cue_buf = usbd_alloc_buffer(c->cue_xfer, CUE_BUFSZ);\n\t\t\tif (c->cue_buf == NULL) {\n\t\t\t\tusbd_free_xfer(c->cue_xfer);\n\t\t\t\treturn (ENOBUFS);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->cue_dev"
          ],
          "line": 1299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cue_tx_list_init",
          "args": [
            "sc"
          ],
          "line": 1298
        },
        "resolved": true,
        "details": {
          "function_name": "cue_tx_list_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_cue.c",
          "lines": "900-927",
          "snippet": "Static int\ncue_tx_list_init(sc)\n\tstruct cue_softc\t*sc;\n{\n\tstruct cue_cdata\t*cd;\n\tstruct cue_chain\t*c;\n\tint\t\t\ti;\n\n\tcd = &sc->cue_cdata;\n\tfor (i = 0; i < CUE_TX_LIST_CNT; i++) {\n\t\tc = &cd->cue_tx_chain[i];\n\t\tc->cue_sc = sc;\n\t\tc->cue_idx = i;\n\t\tc->cue_mbuf = NULL;\n\t\tif (c->cue_xfer == NULL) {\n\t\t\tc->cue_xfer = usbd_alloc_xfer(sc->cue_udev);\n\t\t\tif (c->cue_xfer == NULL)\n\t\t\t\treturn (ENOBUFS);\n\t\t\tc->cue_buf = usbd_alloc_buffer(c->cue_xfer, CUE_BUFSZ);\n\t\t\tif (c->cue_buf == NULL) {\n\t\t\t\tusbd_free_xfer(c->cue_xfer);\n\t\t\t\treturn (ENOBUFS);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/usb/if_cuereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "cue_open_pipes\t__P((struct cue_softc *));",
            "Static int",
            "cue_tx_list_init\t__P((struct cue_softc *));",
            "Static int",
            "cue_rx_list_init\t__P((struct cue_softc *));",
            "Static int",
            "Static int",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "cue_stop\t\t__P((struct cue_softc *));",
            "Static void",
            "Static void",
            "cue_setmulti\t__P((struct cue_softc *));",
            "Static void",
            "cue_reset\t\t__P((struct cue_softc *));",
            "Static int",
            "cue_csr_read_1\t__P((struct cue_softc *, int));",
            "Static int",
            "cue_csr_write_1\t__P((struct cue_softc *, int, int));",
            "Static int",
            "cue_csr_read_2\t__P((struct cue_softc *, int));",
            "Static int",
            "cue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));",
            "Static int",
            "cue_getmac\t\t__P((struct cue_softc *, void *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/if_cuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\ncue_open_pipes\t__P((struct cue_softc *));\nStatic int;\ncue_tx_list_init\t__P((struct cue_softc *));\nStatic int;\ncue_rx_list_init\t__P((struct cue_softc *));\nStatic int;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\ncue_stop\t\t__P((struct cue_softc *));\nStatic void;\nStatic void;\ncue_setmulti\t__P((struct cue_softc *));\nStatic void;\ncue_reset\t\t__P((struct cue_softc *));\nStatic int;\ncue_csr_read_1\t__P((struct cue_softc *, int));\nStatic int;\ncue_csr_write_1\t__P((struct cue_softc *, int, int));\nStatic int;\ncue_csr_read_2\t__P((struct cue_softc *, int));\nStatic int;\ncue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));\nStatic int;\ncue_getmac\t\t__P((struct cue_softc *, void *));\n\nStatic int\ncue_tx_list_init(sc)\n\tstruct cue_softc\t*sc;\n{\n\tstruct cue_cdata\t*cd;\n\tstruct cue_chain\t*c;\n\tint\t\t\ti;\n\n\tcd = &sc->cue_cdata;\n\tfor (i = 0; i < CUE_TX_LIST_CNT; i++) {\n\t\tc = &cd->cue_tx_chain[i];\n\t\tc->cue_sc = sc;\n\t\tc->cue_idx = i;\n\t\tc->cue_mbuf = NULL;\n\t\tif (c->cue_xfer == NULL) {\n\t\t\tc->cue_xfer = usbd_alloc_xfer(sc->cue_udev);\n\t\t\tif (c->cue_xfer == NULL)\n\t\t\t\treturn (ENOBUFS);\n\t\t\tc->cue_buf = usbd_alloc_buffer(c->cue_xfer, CUE_BUFSZ);\n\t\t\tif (c->cue_buf == NULL) {\n\t\t\t\tusbd_free_xfer(c->cue_xfer);\n\t\t\t\treturn (ENOBUFS);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "LLADDR",
          "args": [
            "ifp->if_sadl"
          ],
          "line": 1285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cue_reset",
          "args": [
            "sc"
          ],
          "line": 1275
        },
        "resolved": true,
        "details": {
          "function_name": "cue_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_cue.c",
          "lines": "548-576",
          "snippet": "Static void\ncue_reset(sc)\n\tstruct cue_softc\t*sc;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tint\t\t\ts;\n\n\tDPRINTFN(2,(\"%s: cue_reset\\n\", USBDEVNAME(sc->cue_dev)));\n\n\tif (sc->cue_dying)\n\t\treturn;\n\n\treq.bmRequestType = UT_WRITE_VENDOR_DEVICE;\n\treq.bRequest = CUE_CMD_RESET;\n\tUSETW(req.wValue, 0);\n\tUSETW(req.wIndex, 0);\n\tUSETW(req.wLength, 0);\n\n\ts = splusb();\n\terr = CUE_DO_REQUEST(sc->cue_udev, &req, NULL);\n\tsplx(s);\n\n\tif (err)\n\t\tprintf(\"%s: reset failed\\n\", USBDEVNAME(sc->cue_dev));\n\n\t/* Wait a little while for the chip to get its brains in order. */\n\tdelay(1000);\t\t/* XXX */\n}",
          "includes": [
            "#include <dev/usb/if_cuereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "cue_open_pipes\t__P((struct cue_softc *));",
            "Static int",
            "cue_tx_list_init\t__P((struct cue_softc *));",
            "Static int",
            "cue_rx_list_init\t__P((struct cue_softc *));",
            "Static int",
            "Static int",
            "Static void",
            "cue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "cue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "cue_stop\t\t__P((struct cue_softc *));",
            "Static void",
            "Static void",
            "cue_setmulti\t__P((struct cue_softc *));",
            "Static void",
            "cue_reset\t\t__P((struct cue_softc *));",
            "Static int",
            "cue_csr_read_1\t__P((struct cue_softc *, int));",
            "Static int",
            "cue_csr_write_1\t__P((struct cue_softc *, int, int));",
            "Static int",
            "cue_csr_read_2\t__P((struct cue_softc *, int));",
            "Static int",
            "cue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));",
            "Static int",
            "cue_getmac\t\t__P((struct cue_softc *, void *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/if_cuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\ncue_open_pipes\t__P((struct cue_softc *));\nStatic int;\ncue_tx_list_init\t__P((struct cue_softc *));\nStatic int;\ncue_rx_list_init\t__P((struct cue_softc *));\nStatic int;\nStatic int;\nStatic void;\ncue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\ncue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\ncue_stop\t\t__P((struct cue_softc *));\nStatic void;\nStatic void;\ncue_setmulti\t__P((struct cue_softc *));\nStatic void;\ncue_reset\t\t__P((struct cue_softc *));\nStatic int;\ncue_csr_read_1\t__P((struct cue_softc *, int));\nStatic int;\ncue_csr_write_1\t__P((struct cue_softc *, int, int));\nStatic int;\ncue_csr_read_2\t__P((struct cue_softc *, int));\nStatic int;\ncue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));\nStatic int;\ncue_getmac\t\t__P((struct cue_softc *, void *));\n\nStatic void\ncue_reset(sc)\n\tstruct cue_softc\t*sc;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tint\t\t\ts;\n\n\tDPRINTFN(2,(\"%s: cue_reset\\n\", USBDEVNAME(sc->cue_dev)));\n\n\tif (sc->cue_dying)\n\t\treturn;\n\n\treq.bmRequestType = UT_WRITE_VENDOR_DEVICE;\n\treq.bRequest = CUE_CMD_RESET;\n\tUSETW(req.wValue, 0);\n\tUSETW(req.wIndex, 0);\n\tUSETW(req.wLength, 0);\n\n\ts = splusb();\n\terr = CUE_DO_REQUEST(sc->cue_udev, &req, NULL);\n\tsplx(s);\n\n\tif (err)\n\t\tprintf(\"%s: reset failed\\n\", USBDEVNAME(sc->cue_dev));\n\n\t/* Wait a little while for the chip to get its brains in order. */\n\tdelay(1000);\t\t/* XXX */\n}"
        }
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "10",
            "(\"%s: %s: enter\\n\", USBDEVNAME(sc->cue_dev),__FUNCTION__)"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->cue_dev"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_IFP",
          "args": [
            "sc"
          ],
          "line": 1257
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/if_cuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\ncue_open_pipes\t__P((struct cue_softc *));\nStatic int;\ncue_tx_list_init\t__P((struct cue_softc *));\nStatic int;\ncue_rx_list_init\t__P((struct cue_softc *));\nStatic int;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\ncue_start\t\t__P((struct ifnet *));\nStatic int;\nStatic void;\nStatic void;\ncue_stop\t\t__P((struct cue_softc *));\nStatic void;\ncue_watchdog\t\t__P((struct ifnet *));\nStatic void;\ncue_setmulti\t__P((struct cue_softc *));\nStatic void;\ncue_reset\t\t__P((struct cue_softc *));\nStatic int;\ncue_csr_read_1\t__P((struct cue_softc *, int));\nStatic int;\ncue_csr_write_1\t__P((struct cue_softc *, int, int));\nStatic int;\ncue_csr_read_2\t__P((struct cue_softc *, int));\nStatic int;\ncue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));\nStatic int;\ncue_getmac\t\t__P((struct cue_softc *, void *));\n\nStatic void\ncue_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct cue_softc\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = GET_IFP(sc);\n\tint\t\t\ti, s, ctl;\n\tu_char\t\t\t*eaddr;\n\n\tif (sc->cue_dying)\n\t\treturn;\n\n\tDPRINTFN(10,(\"%s: %s: enter\\n\", USBDEVNAME(sc->cue_dev),__FUNCTION__));\n\n\tif (ifp->if_flags & IFF_RUNNING)\n\t\treturn;\n\n\ts = splimp();\n\n\t/*\n\t * Cancel pending I/O and free all RX/TX buffers.\n\t */\n#if 1\n\tcue_reset(sc);\n#endif\n\n\t/* Set advanced operation modes. */\n\tcue_csr_write_1(sc, CUE_ADVANCED_OPMODES,\n\t    CUE_AOP_EMBED_RXLEN | 0x03); /* 1 wait state */\n\n#if defined(__FreeBSD__) || defined(__OpenBSD__)\n\teaddr = sc->arpcom.ac_enaddr;\n#elif defined(__NetBSD__)\n\teaddr = LLADDR(ifp->if_sadl);\n#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */\n\t/* Set MAC address */\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++)\n\t\tcue_csr_write_1(sc, CUE_PAR0 - i, eaddr[i]);\n\n\t/* Enable RX logic. */\n\tctl = CUE_ETHCTL_RX_ON | CUE_ETHCTL_MCAST_ON;\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tctl |= CUE_ETHCTL_PROMISC;\n\tcue_csr_write_1(sc, CUE_ETHCTL, ctl);\n\n\t/* Init TX ring. */\n\tif (cue_tx_list_init(sc) == ENOBUFS) {\n\t\tprintf(\"%s: tx list init failed\\n\", USBDEVNAME(sc->cue_dev));\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Init RX ring. */\n\tif (cue_rx_list_init(sc) == ENOBUFS) {\n\t\tprintf(\"%s: rx list init failed\\n\", USBDEVNAME(sc->cue_dev));\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Load the multicast filter. */\n\tcue_setmulti(sc);\n\n\t/*\n\t * Set the number of RX and TX buffers that we want\n\t * to reserve inside the ASIC.\n\t */\n\tcue_csr_write_1(sc, CUE_RX_BUFPKTS, CUE_RX_FRAMES);\n\tcue_csr_write_1(sc, CUE_TX_BUFPKTS, CUE_TX_FRAMES);\n\n\t/* Set advanced operation modes. */\n\tcue_csr_write_1(sc, CUE_ADVANCED_OPMODES,\n\t    CUE_AOP_EMBED_RXLEN | 0x01); /* 1 wait state */\n\n\t/* Program the LED operation. */\n\tcue_csr_write_1(sc, CUE_LEDCTL, CUE_LEDCTL_FOLLOW_LINK);\n\n\tif (sc->cue_ep[CUE_ENDPT_RX] == NULL) {\n\t\tif (cue_open_pipes(sc)) {\n\t\t\tsplx(s);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tsplx(s);\n\n\tusb_callout(sc->cue_stat_ch, hz, cue_tick, sc);\n}"
  },
  {
    "function_name": "cue_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_cue.c",
    "lines": "1210-1250",
    "snippet": "Static void\ncue_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct cue_softc\t*sc = ifp->if_softc;\n\tstruct mbuf\t\t*m_head = NULL;\n\n\tif (sc->cue_dying)\n\t\treturn;\n\n\tDPRINTFN(10,(\"%s: %s: enter\\n\", USBDEVNAME(sc->cue_dev),__FUNCTION__));\n\n\tif (ifp->if_flags & IFF_OACTIVE)\n\t\treturn;\n\n\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\tif (m_head == NULL)\n\t\treturn;\n\n\tif (cue_send(sc, m_head, 0)) {\n\t\tIF_PREPEND(&ifp->if_snd, m_head);\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t\treturn;\n\t}\n\n#if NBPFILTER > 0\n\t/*\n\t * If there's a BPF listener, bounce a copy of this frame\n\t * to him.\n\t */\n\tif (ifp->if_bpf)\n\t\tBPF_MTAP(ifp, m_head);\n#endif\n\n\tifp->if_flags |= IFF_OACTIVE;\n\n\t/*\n\t * Set a timeout in case the chip goes out to lunch.\n\t */\n\tifp->if_timer = 5;\n}",
    "includes": [
      "#include <dev/usb/if_cuereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "cue_open_pipes\t__P((struct cue_softc *));",
      "Static int",
      "cue_tx_list_init\t__P((struct cue_softc *));",
      "Static int",
      "cue_rx_list_init\t__P((struct cue_softc *));",
      "Static int",
      "cue_newbuf\t\t__P((struct cue_softc *, struct cue_chain *,\n\t\t\t\t    struct mbuf *));",
      "Static int",
      "cue_send\t\t__P((struct cue_softc *, struct mbuf *, int));",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "cue_start\t\t__P((struct ifnet *));",
      "Static int",
      "Static void",
      "Static void",
      "cue_stop\t\t__P((struct cue_softc *));",
      "Static void",
      "cue_watchdog\t\t__P((struct ifnet *));",
      "Static void",
      "cue_setmulti\t__P((struct cue_softc *));",
      "Static void",
      "cue_reset\t\t__P((struct cue_softc *));",
      "Static int",
      "cue_csr_read_1\t__P((struct cue_softc *, int));",
      "Static int",
      "cue_csr_write_1\t__P((struct cue_softc *, int, int));",
      "Static int",
      "cue_csr_read_2\t__P((struct cue_softc *, int));",
      "Static int",
      "cue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));",
      "Static int",
      "cue_getmac\t\t__P((struct cue_softc *, void *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BPF_MTAP",
          "args": [
            "ifp",
            "m_head"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_PREPEND",
          "args": [
            "&ifp->if_snd",
            "m_head"
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cue_send",
          "args": [
            "sc",
            "m_head",
            "0"
          ],
          "line": 1229
        },
        "resolved": true,
        "details": {
          "function_name": "cue_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_cue.c",
          "lines": "1164-1208",
          "snippet": "Static int\ncue_send(sc, m, idx)\n\tstruct cue_softc\t*sc;\n\tstruct mbuf\t\t*m;\n\tint\t\t\tidx;\n{\n\tint\t\t\ttotal_len;\n\tstruct cue_chain\t*c;\n\tusbd_status\t\terr;\n\n\tc = &sc->cue_cdata.cue_tx_chain[idx];\n\n\t/*\n\t * Copy the mbuf data into a contiguous buffer, leaving two\n\t * bytes at the beginning to hold the frame length.\n\t */\n\tm_copydata(m, 0, m->m_pkthdr.len, c->cue_buf + 2);\n\tc->cue_mbuf = m;\n\n\ttotal_len = m->m_pkthdr.len + 2;\n\n\tDPRINTFN(10,(\"%s: %s: total_len=%d\\n\",\n\t\t     USBDEVNAME(sc->cue_dev), __FUNCTION__, total_len));\n\n\t/* The first two bytes are the frame length */\n\tc->cue_buf[0] = (u_int8_t)m->m_pkthdr.len;\n\tc->cue_buf[1] = (u_int8_t)(m->m_pkthdr.len >> 8);\n\n\t/* XXX 10000 */\n\tusbd_setup_xfer(c->cue_xfer, sc->cue_ep[CUE_ENDPT_TX],\n\t    c, c->cue_buf, total_len, USBD_NO_COPY, 10000, cue_txeof);\n\n\t/* Transmit */\n\terr = usbd_transfer(c->cue_xfer);\n\tif (err != USBD_IN_PROGRESS) {\n\t\tprintf(\"%s: cue_send error=%s\\n\", USBDEVNAME(sc->cue_dev),\n\t\t       usbd_errstr(err));\n\t\tcue_stop(sc);\n\t\treturn (EIO);\n\t}\n\n\tsc->cue_cdata.cue_tx_cnt++;\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/usb/if_cuereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "cue_open_pipes\t__P((struct cue_softc *));",
            "Static int",
            "cue_tx_list_init\t__P((struct cue_softc *));",
            "Static int",
            "cue_rx_list_init\t__P((struct cue_softc *));",
            "Static int",
            "cue_newbuf\t\t__P((struct cue_softc *, struct cue_chain *,\n\t\t\t\t    struct mbuf *));",
            "Static int",
            "cue_send\t\t__P((struct cue_softc *, struct mbuf *, int));",
            "Static void",
            "cue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "cue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "cue_stop\t\t__P((struct cue_softc *));",
            "Static void",
            "Static void",
            "cue_setmulti\t__P((struct cue_softc *));",
            "Static void",
            "cue_reset\t\t__P((struct cue_softc *));",
            "Static int",
            "cue_csr_read_1\t__P((struct cue_softc *, int));",
            "Static int",
            "cue_csr_write_1\t__P((struct cue_softc *, int, int));",
            "Static int",
            "cue_csr_read_2\t__P((struct cue_softc *, int));",
            "Static int",
            "cue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));",
            "Static int",
            "cue_getmac\t\t__P((struct cue_softc *, void *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/if_cuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\ncue_open_pipes\t__P((struct cue_softc *));\nStatic int;\ncue_tx_list_init\t__P((struct cue_softc *));\nStatic int;\ncue_rx_list_init\t__P((struct cue_softc *));\nStatic int;\ncue_newbuf\t\t__P((struct cue_softc *, struct cue_chain *,\n\t\t\t\t    struct mbuf *));\nStatic int;\ncue_send\t\t__P((struct cue_softc *, struct mbuf *, int));\nStatic void;\ncue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\ncue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\ncue_stop\t\t__P((struct cue_softc *));\nStatic void;\nStatic void;\ncue_setmulti\t__P((struct cue_softc *));\nStatic void;\ncue_reset\t\t__P((struct cue_softc *));\nStatic int;\ncue_csr_read_1\t__P((struct cue_softc *, int));\nStatic int;\ncue_csr_write_1\t__P((struct cue_softc *, int, int));\nStatic int;\ncue_csr_read_2\t__P((struct cue_softc *, int));\nStatic int;\ncue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));\nStatic int;\ncue_getmac\t\t__P((struct cue_softc *, void *));\n\nStatic int\ncue_send(sc, m, idx)\n\tstruct cue_softc\t*sc;\n\tstruct mbuf\t\t*m;\n\tint\t\t\tidx;\n{\n\tint\t\t\ttotal_len;\n\tstruct cue_chain\t*c;\n\tusbd_status\t\terr;\n\n\tc = &sc->cue_cdata.cue_tx_chain[idx];\n\n\t/*\n\t * Copy the mbuf data into a contiguous buffer, leaving two\n\t * bytes at the beginning to hold the frame length.\n\t */\n\tm_copydata(m, 0, m->m_pkthdr.len, c->cue_buf + 2);\n\tc->cue_mbuf = m;\n\n\ttotal_len = m->m_pkthdr.len + 2;\n\n\tDPRINTFN(10,(\"%s: %s: total_len=%d\\n\",\n\t\t     USBDEVNAME(sc->cue_dev), __FUNCTION__, total_len));\n\n\t/* The first two bytes are the frame length */\n\tc->cue_buf[0] = (u_int8_t)m->m_pkthdr.len;\n\tc->cue_buf[1] = (u_int8_t)(m->m_pkthdr.len >> 8);\n\n\t/* XXX 10000 */\n\tusbd_setup_xfer(c->cue_xfer, sc->cue_ep[CUE_ENDPT_TX],\n\t    c, c->cue_buf, total_len, USBD_NO_COPY, 10000, cue_txeof);\n\n\t/* Transmit */\n\terr = usbd_transfer(c->cue_xfer);\n\tif (err != USBD_IN_PROGRESS) {\n\t\tprintf(\"%s: cue_send error=%s\\n\", USBDEVNAME(sc->cue_dev),\n\t\t       usbd_errstr(err));\n\t\tcue_stop(sc);\n\t\treturn (EIO);\n\t}\n\n\tsc->cue_cdata.cue_tx_cnt++;\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IF_DEQUEUE",
          "args": [
            "&ifp->if_snd",
            "m_head"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "10",
            "(\"%s: %s: enter\\n\", USBDEVNAME(sc->cue_dev),__FUNCTION__)"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->cue_dev"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/if_cuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\ncue_open_pipes\t__P((struct cue_softc *));\nStatic int;\ncue_tx_list_init\t__P((struct cue_softc *));\nStatic int;\ncue_rx_list_init\t__P((struct cue_softc *));\nStatic int;\ncue_newbuf\t\t__P((struct cue_softc *, struct cue_chain *,\n\t\t\t\t    struct mbuf *));\nStatic int;\ncue_send\t\t__P((struct cue_softc *, struct mbuf *, int));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\ncue_start\t\t__P((struct ifnet *));\nStatic int;\nStatic void;\nStatic void;\ncue_stop\t\t__P((struct cue_softc *));\nStatic void;\ncue_watchdog\t\t__P((struct ifnet *));\nStatic void;\ncue_setmulti\t__P((struct cue_softc *));\nStatic void;\ncue_reset\t\t__P((struct cue_softc *));\nStatic int;\ncue_csr_read_1\t__P((struct cue_softc *, int));\nStatic int;\ncue_csr_write_1\t__P((struct cue_softc *, int, int));\nStatic int;\ncue_csr_read_2\t__P((struct cue_softc *, int));\nStatic int;\ncue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));\nStatic int;\ncue_getmac\t\t__P((struct cue_softc *, void *));\n\nStatic void\ncue_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct cue_softc\t*sc = ifp->if_softc;\n\tstruct mbuf\t\t*m_head = NULL;\n\n\tif (sc->cue_dying)\n\t\treturn;\n\n\tDPRINTFN(10,(\"%s: %s: enter\\n\", USBDEVNAME(sc->cue_dev),__FUNCTION__));\n\n\tif (ifp->if_flags & IFF_OACTIVE)\n\t\treturn;\n\n\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\tif (m_head == NULL)\n\t\treturn;\n\n\tif (cue_send(sc, m_head, 0)) {\n\t\tIF_PREPEND(&ifp->if_snd, m_head);\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t\treturn;\n\t}\n\n#if NBPFILTER > 0\n\t/*\n\t * If there's a BPF listener, bounce a copy of this frame\n\t * to him.\n\t */\n\tif (ifp->if_bpf)\n\t\tBPF_MTAP(ifp, m_head);\n#endif\n\n\tifp->if_flags |= IFF_OACTIVE;\n\n\t/*\n\t * Set a timeout in case the chip goes out to lunch.\n\t */\n\tifp->if_timer = 5;\n}"
  },
  {
    "function_name": "cue_send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_cue.c",
    "lines": "1164-1208",
    "snippet": "Static int\ncue_send(sc, m, idx)\n\tstruct cue_softc\t*sc;\n\tstruct mbuf\t\t*m;\n\tint\t\t\tidx;\n{\n\tint\t\t\ttotal_len;\n\tstruct cue_chain\t*c;\n\tusbd_status\t\terr;\n\n\tc = &sc->cue_cdata.cue_tx_chain[idx];\n\n\t/*\n\t * Copy the mbuf data into a contiguous buffer, leaving two\n\t * bytes at the beginning to hold the frame length.\n\t */\n\tm_copydata(m, 0, m->m_pkthdr.len, c->cue_buf + 2);\n\tc->cue_mbuf = m;\n\n\ttotal_len = m->m_pkthdr.len + 2;\n\n\tDPRINTFN(10,(\"%s: %s: total_len=%d\\n\",\n\t\t     USBDEVNAME(sc->cue_dev), __FUNCTION__, total_len));\n\n\t/* The first two bytes are the frame length */\n\tc->cue_buf[0] = (u_int8_t)m->m_pkthdr.len;\n\tc->cue_buf[1] = (u_int8_t)(m->m_pkthdr.len >> 8);\n\n\t/* XXX 10000 */\n\tusbd_setup_xfer(c->cue_xfer, sc->cue_ep[CUE_ENDPT_TX],\n\t    c, c->cue_buf, total_len, USBD_NO_COPY, 10000, cue_txeof);\n\n\t/* Transmit */\n\terr = usbd_transfer(c->cue_xfer);\n\tif (err != USBD_IN_PROGRESS) {\n\t\tprintf(\"%s: cue_send error=%s\\n\", USBDEVNAME(sc->cue_dev),\n\t\t       usbd_errstr(err));\n\t\tcue_stop(sc);\n\t\treturn (EIO);\n\t}\n\n\tsc->cue_cdata.cue_tx_cnt++;\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/usb/if_cuereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "cue_open_pipes\t__P((struct cue_softc *));",
      "Static int",
      "cue_tx_list_init\t__P((struct cue_softc *));",
      "Static int",
      "cue_rx_list_init\t__P((struct cue_softc *));",
      "Static int",
      "cue_newbuf\t\t__P((struct cue_softc *, struct cue_chain *,\n\t\t\t\t    struct mbuf *));",
      "Static int",
      "cue_send\t\t__P((struct cue_softc *, struct mbuf *, int));",
      "Static void",
      "cue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "cue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "cue_stop\t\t__P((struct cue_softc *));",
      "Static void",
      "Static void",
      "cue_setmulti\t__P((struct cue_softc *));",
      "Static void",
      "cue_reset\t\t__P((struct cue_softc *));",
      "Static int",
      "cue_csr_read_1\t__P((struct cue_softc *, int));",
      "Static int",
      "cue_csr_write_1\t__P((struct cue_softc *, int, int));",
      "Static int",
      "cue_csr_read_2\t__P((struct cue_softc *, int));",
      "Static int",
      "cue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));",
      "Static int",
      "cue_getmac\t\t__P((struct cue_softc *, void *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cue_stop",
          "args": [
            "sc"
          ],
          "line": 1201
        },
        "resolved": true,
        "details": {
          "function_name": "cue_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_cue.c",
          "lines": "1516-1601",
          "snippet": "Static void\ncue_stop(sc)\n\tstruct cue_softc\t*sc;\n{\n\tusbd_status\t\terr;\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\ti;\n\n\tDPRINTFN(10,(\"%s: %s: enter\\n\", USBDEVNAME(sc->cue_dev),__FUNCTION__));\n\n\tifp = GET_IFP(sc);\n\tifp->if_timer = 0;\n\n\tcue_csr_write_1(sc, CUE_ETHCTL, 0);\n\tcue_reset(sc);\n\tusb_uncallout(sc->cue_stat_ch, cue_tick, sc);\n\n\t/* Stop transfers. */\n\tif (sc->cue_ep[CUE_ENDPT_RX] != NULL) {\n\t\terr = usbd_abort_pipe(sc->cue_ep[CUE_ENDPT_RX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort rx pipe failed: %s\\n\",\n\t\t\tUSBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->cue_ep[CUE_ENDPT_RX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close rx pipe failed: %s\\n\",\n\t\t\tUSBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->cue_ep[CUE_ENDPT_RX] = NULL;\n\t}\n\n\tif (sc->cue_ep[CUE_ENDPT_TX] != NULL) {\n\t\terr = usbd_abort_pipe(sc->cue_ep[CUE_ENDPT_TX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort tx pipe failed: %s\\n\",\n\t\t\tUSBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->cue_ep[CUE_ENDPT_TX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close tx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->cue_ep[CUE_ENDPT_TX] = NULL;\n\t}\n\n\tif (sc->cue_ep[CUE_ENDPT_INTR] != NULL) {\n\t\terr = usbd_abort_pipe(sc->cue_ep[CUE_ENDPT_INTR]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort intr pipe failed: %s\\n\",\n\t\t\tUSBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->cue_ep[CUE_ENDPT_INTR]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close intr pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->cue_ep[CUE_ENDPT_INTR] = NULL;\n\t}\n\n\t/* Free RX resources. */\n\tfor (i = 0; i < CUE_RX_LIST_CNT; i++) {\n\t\tif (sc->cue_cdata.cue_rx_chain[i].cue_mbuf != NULL) {\n\t\t\tm_freem(sc->cue_cdata.cue_rx_chain[i].cue_mbuf);\n\t\t\tsc->cue_cdata.cue_rx_chain[i].cue_mbuf = NULL;\n\t\t}\n\t\tif (sc->cue_cdata.cue_rx_chain[i].cue_xfer != NULL) {\n\t\t\tusbd_free_xfer(sc->cue_cdata.cue_rx_chain[i].cue_xfer);\n\t\t\tsc->cue_cdata.cue_rx_chain[i].cue_xfer = NULL;\n\t\t}\n\t}\n\n\t/* Free TX resources. */\n\tfor (i = 0; i < CUE_TX_LIST_CNT; i++) {\n\t\tif (sc->cue_cdata.cue_tx_chain[i].cue_mbuf != NULL) {\n\t\t\tm_freem(sc->cue_cdata.cue_tx_chain[i].cue_mbuf);\n\t\t\tsc->cue_cdata.cue_tx_chain[i].cue_mbuf = NULL;\n\t\t}\n\t\tif (sc->cue_cdata.cue_tx_chain[i].cue_xfer != NULL) {\n\t\t\tusbd_free_xfer(sc->cue_cdata.cue_tx_chain[i].cue_xfer);\n\t\t\tsc->cue_cdata.cue_tx_chain[i].cue_xfer = NULL;\n\t\t}\n\t}\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n}",
          "includes": [
            "#include <dev/usb/if_cuereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "cue_open_pipes\t__P((struct cue_softc *));",
            "Static int",
            "cue_tx_list_init\t__P((struct cue_softc *));",
            "Static int",
            "cue_rx_list_init\t__P((struct cue_softc *));",
            "Static int",
            "Static int",
            "Static void",
            "cue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "cue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "Static void",
            "cue_start\t\t__P((struct ifnet *));",
            "Static int",
            "Static void",
            "Static void",
            "cue_stop\t\t__P((struct cue_softc *));",
            "Static void",
            "cue_watchdog\t\t__P((struct ifnet *));",
            "Static void",
            "cue_setmulti\t__P((struct cue_softc *));",
            "Static void",
            "cue_reset\t\t__P((struct cue_softc *));",
            "Static int",
            "cue_csr_read_1\t__P((struct cue_softc *, int));",
            "Static int",
            "cue_csr_write_1\t__P((struct cue_softc *, int, int));",
            "Static int",
            "cue_csr_read_2\t__P((struct cue_softc *, int));",
            "Static int",
            "cue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));",
            "Static int",
            "cue_getmac\t\t__P((struct cue_softc *, void *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/if_cuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\ncue_open_pipes\t__P((struct cue_softc *));\nStatic int;\ncue_tx_list_init\t__P((struct cue_softc *));\nStatic int;\ncue_rx_list_init\t__P((struct cue_softc *));\nStatic int;\nStatic int;\nStatic void;\ncue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\ncue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic void;\ncue_start\t\t__P((struct ifnet *));\nStatic int;\nStatic void;\nStatic void;\ncue_stop\t\t__P((struct cue_softc *));\nStatic void;\ncue_watchdog\t\t__P((struct ifnet *));\nStatic void;\ncue_setmulti\t__P((struct cue_softc *));\nStatic void;\ncue_reset\t\t__P((struct cue_softc *));\nStatic int;\ncue_csr_read_1\t__P((struct cue_softc *, int));\nStatic int;\ncue_csr_write_1\t__P((struct cue_softc *, int, int));\nStatic int;\ncue_csr_read_2\t__P((struct cue_softc *, int));\nStatic int;\ncue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));\nStatic int;\ncue_getmac\t\t__P((struct cue_softc *, void *));\n\nStatic void\ncue_stop(sc)\n\tstruct cue_softc\t*sc;\n{\n\tusbd_status\t\terr;\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\ti;\n\n\tDPRINTFN(10,(\"%s: %s: enter\\n\", USBDEVNAME(sc->cue_dev),__FUNCTION__));\n\n\tifp = GET_IFP(sc);\n\tifp->if_timer = 0;\n\n\tcue_csr_write_1(sc, CUE_ETHCTL, 0);\n\tcue_reset(sc);\n\tusb_uncallout(sc->cue_stat_ch, cue_tick, sc);\n\n\t/* Stop transfers. */\n\tif (sc->cue_ep[CUE_ENDPT_RX] != NULL) {\n\t\terr = usbd_abort_pipe(sc->cue_ep[CUE_ENDPT_RX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort rx pipe failed: %s\\n\",\n\t\t\tUSBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->cue_ep[CUE_ENDPT_RX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close rx pipe failed: %s\\n\",\n\t\t\tUSBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->cue_ep[CUE_ENDPT_RX] = NULL;\n\t}\n\n\tif (sc->cue_ep[CUE_ENDPT_TX] != NULL) {\n\t\terr = usbd_abort_pipe(sc->cue_ep[CUE_ENDPT_TX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort tx pipe failed: %s\\n\",\n\t\t\tUSBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->cue_ep[CUE_ENDPT_TX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close tx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->cue_ep[CUE_ENDPT_TX] = NULL;\n\t}\n\n\tif (sc->cue_ep[CUE_ENDPT_INTR] != NULL) {\n\t\terr = usbd_abort_pipe(sc->cue_ep[CUE_ENDPT_INTR]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort intr pipe failed: %s\\n\",\n\t\t\tUSBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->cue_ep[CUE_ENDPT_INTR]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close intr pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->cue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->cue_ep[CUE_ENDPT_INTR] = NULL;\n\t}\n\n\t/* Free RX resources. */\n\tfor (i = 0; i < CUE_RX_LIST_CNT; i++) {\n\t\tif (sc->cue_cdata.cue_rx_chain[i].cue_mbuf != NULL) {\n\t\t\tm_freem(sc->cue_cdata.cue_rx_chain[i].cue_mbuf);\n\t\t\tsc->cue_cdata.cue_rx_chain[i].cue_mbuf = NULL;\n\t\t}\n\t\tif (sc->cue_cdata.cue_rx_chain[i].cue_xfer != NULL) {\n\t\t\tusbd_free_xfer(sc->cue_cdata.cue_rx_chain[i].cue_xfer);\n\t\t\tsc->cue_cdata.cue_rx_chain[i].cue_xfer = NULL;\n\t\t}\n\t}\n\n\t/* Free TX resources. */\n\tfor (i = 0; i < CUE_TX_LIST_CNT; i++) {\n\t\tif (sc->cue_cdata.cue_tx_chain[i].cue_mbuf != NULL) {\n\t\t\tm_freem(sc->cue_cdata.cue_tx_chain[i].cue_mbuf);\n\t\t\tsc->cue_cdata.cue_tx_chain[i].cue_mbuf = NULL;\n\t\t}\n\t\tif (sc->cue_cdata.cue_tx_chain[i].cue_xfer != NULL) {\n\t\t\tusbd_free_xfer(sc->cue_cdata.cue_tx_chain[i].cue_xfer);\n\t\t\tsc->cue_cdata.cue_tx_chain[i].cue_xfer = NULL;\n\t\t}\n\t}\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: cue_send error=%s\\n\"",
            "USBDEVNAME(sc->cue_dev)",
            "usbd_errstr(err)"
          ],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->cue_dev"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_transfer",
          "args": [
            "c->cue_xfer"
          ],
          "line": 1197
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_transfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "254-339",
          "snippet": "usbd_status\nusbd_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tusbd_status err;\n\tu_int size;\n\tint s;\n\n\tDPRINTFN(5,(\"usbd_transfer: xfer=%p, flags=%d, pipe=%p, running=%d\\n\",\n\t\t    xfer, xfer->flags, pipe, pipe->running));\n#ifdef USB_DEBUG\n\tif (usbdebug > 5)\n\t\tusbd_dump_queue(pipe);\n#endif\n\txfer->done = 0;\n\n\tif (pipe->aborting)\n\t\treturn (USBD_CANCELLED);\n\n\tsize = xfer->length;\n\t/* If there is no buffer, allocate one. */\n\tif (!(xfer->rqflags & URQ_DEV_DMABUF) && size != 0) {\n\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n#ifdef DIAGNOSTIC\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF)\n\t\t\tprintf(\"usbd_transfer: has old buffer!\\n\");\n#endif\n\t\terr = bus->methods->allocm(bus, dmap, size);\n\t\tif (err)\n\t\t\treturn (err);\n\t\txfer->rqflags |= URQ_AUTO_DMABUF;\n\t}\n\n\t/* Copy data if going out. */\n\tif (!(xfer->flags & USBD_NO_COPY) && size != 0 && \n\t    !usbd_xfer_isread(xfer))\n\t\tmemcpy(KERNADDR(dmap), xfer->buffer, size);\n\n\terr = pipe->methods->transfer(xfer);\n\n\tif (err != USBD_IN_PROGRESS && err) {\n\t\t/* The transfer has not been queued, so free buffer. */\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n\t\t\tbus->methods->freem(bus, &xfer->dmabuf);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!(xfer->flags & USBD_SYNCHRONOUS))\n\t\treturn (err);\n\n\t/* Sync transfer, wait for completion. */\n\tif (err != USBD_IN_PROGRESS)\n\t\treturn (err);\n\ts = splusb();\n\tif (!xfer->done) {\n\t\tif (pipe->device->bus->use_polling)\n\t\t\tpanic(\"usbd_transfer: not done\\n\");\n\t\t/* XXX Temporary hack XXX */\n\t\tif (xfer->flags & USBD_NO_TSLEEP) {\n\t\t\tint i;\n\t\t\tusbd_bus_handle bus = pipe->device->bus;\n\t\t\tint to = xfer->timeout * 1000;\n\t\t\tfor (i = 0; i < to; i += 10) {\n\t\t\t\tdelay(10);\n\t\t\t\tbus->methods->do_poll(bus);\n\t\t\t\tif (xfer->done)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* XXX Is this right, what about the HC timeout? */\n\t\t\tif (!xfer->done) {\n\t\t\t\tpipe->methods->abort(xfer);\n\t\t\t\txfer->status = USBD_TIMEOUT;\n\t\t\t}\n\t\t} else\n\t\t/* XXX End hack XXX */\n\t\t\ttsleep(xfer, PRIBIO, \"usbsyn\", 0);\n\t}\n\tsplx(s);\n\treturn (xfer->status);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "u_int32_t size;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nu_int32_t size;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nusbd_status\nusbd_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tusbd_status err;\n\tu_int size;\n\tint s;\n\n\tDPRINTFN(5,(\"usbd_transfer: xfer=%p, flags=%d, pipe=%p, running=%d\\n\",\n\t\t    xfer, xfer->flags, pipe, pipe->running));\n#ifdef USB_DEBUG\n\tif (usbdebug > 5)\n\t\tusbd_dump_queue(pipe);\n#endif\n\txfer->done = 0;\n\n\tif (pipe->aborting)\n\t\treturn (USBD_CANCELLED);\n\n\tsize = xfer->length;\n\t/* If there is no buffer, allocate one. */\n\tif (!(xfer->rqflags & URQ_DEV_DMABUF) && size != 0) {\n\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n#ifdef DIAGNOSTIC\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF)\n\t\t\tprintf(\"usbd_transfer: has old buffer!\\n\");\n#endif\n\t\terr = bus->methods->allocm(bus, dmap, size);\n\t\tif (err)\n\t\t\treturn (err);\n\t\txfer->rqflags |= URQ_AUTO_DMABUF;\n\t}\n\n\t/* Copy data if going out. */\n\tif (!(xfer->flags & USBD_NO_COPY) && size != 0 && \n\t    !usbd_xfer_isread(xfer))\n\t\tmemcpy(KERNADDR(dmap), xfer->buffer, size);\n\n\terr = pipe->methods->transfer(xfer);\n\n\tif (err != USBD_IN_PROGRESS && err) {\n\t\t/* The transfer has not been queued, so free buffer. */\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n\t\t\tbus->methods->freem(bus, &xfer->dmabuf);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!(xfer->flags & USBD_SYNCHRONOUS))\n\t\treturn (err);\n\n\t/* Sync transfer, wait for completion. */\n\tif (err != USBD_IN_PROGRESS)\n\t\treturn (err);\n\ts = splusb();\n\tif (!xfer->done) {\n\t\tif (pipe->device->bus->use_polling)\n\t\t\tpanic(\"usbd_transfer: not done\\n\");\n\t\t/* XXX Temporary hack XXX */\n\t\tif (xfer->flags & USBD_NO_TSLEEP) {\n\t\t\tint i;\n\t\t\tusbd_bus_handle bus = pipe->device->bus;\n\t\t\tint to = xfer->timeout * 1000;\n\t\t\tfor (i = 0; i < to; i += 10) {\n\t\t\t\tdelay(10);\n\t\t\t\tbus->methods->do_poll(bus);\n\t\t\t\tif (xfer->done)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* XXX Is this right, what about the HC timeout? */\n\t\t\tif (!xfer->done) {\n\t\t\t\tpipe->methods->abort(xfer);\n\t\t\t\txfer->status = USBD_TIMEOUT;\n\t\t\t}\n\t\t} else\n\t\t/* XXX End hack XXX */\n\t\t\ttsleep(xfer, PRIBIO, \"usbsyn\", 0);\n\t}\n\tsplx(s);\n\treturn (xfer->status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_setup_xfer",
          "args": [
            "c->cue_xfer",
            "sc->cue_ep[CUE_ENDPT_TX]",
            "c",
            "c->cue_buf",
            "total_len",
            "USBD_NO_COPY",
            "10000",
            "cue_txeof"
          ],
          "line": 1193
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_setup_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "420-444",
          "snippet": "void\nusbd_setup_xfer(xfer, pipe, priv, buffer, length, flags, timeout, callback)\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle pipe;\n\tusbd_private_handle priv;\n\tvoid *buffer;\n\tu_int32_t length;\n\tu_int16_t flags;\n\tu_int32_t timeout;\n\tvoid (*callback) __P((usbd_xfer_handle,\n\t\t\t      usbd_private_handle,\n\t\t\t      usbd_status));\n{\n\txfer->pipe = pipe;\n\txfer->priv = priv;\n\txfer->buffer = buffer;\n\txfer->length = length;\n\txfer->actlen = 0;\n\txfer->flags = flags;\n\txfer->timeout = timeout;\n\txfer->status = USBD_NOT_STARTED;\n\txfer->callback = callback;\n\txfer->rqflags &= ~URQ_REQUEST;\n\txfer->nframes = 0;\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nvoid\nusbd_setup_xfer(xfer, pipe, priv, buffer, length, flags, timeout, callback)\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle pipe;\n\tusbd_private_handle priv;\n\tvoid *buffer;\n\tu_int32_t length;\n\tu_int16_t flags;\n\tu_int32_t timeout;\n\tvoid (*callback) __P((usbd_xfer_handle,\n\t\t\t      usbd_private_handle,\n\t\t\t      usbd_status));\n{\n\txfer->pipe = pipe;\n\txfer->priv = priv;\n\txfer->buffer = buffer;\n\txfer->length = length;\n\txfer->actlen = 0;\n\txfer->flags = flags;\n\txfer->timeout = timeout;\n\txfer->status = USBD_NOT_STARTED;\n\txfer->callback = callback;\n\txfer->rqflags &= ~URQ_REQUEST;\n\txfer->nframes = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "m->m_pkthdr.len >> 8"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "10",
            "(\"%s: %s: total_len=%d\\n\",\n\t\t     USBDEVNAME(sc->cue_dev), __FUNCTION__, total_len)"
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->cue_dev"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_copydata",
          "args": [
            "m",
            "0",
            "m->m_pkthdr.len",
            "c->cue_buf + 2"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/if_cuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\ncue_open_pipes\t__P((struct cue_softc *));\nStatic int;\ncue_tx_list_init\t__P((struct cue_softc *));\nStatic int;\ncue_rx_list_init\t__P((struct cue_softc *));\nStatic int;\ncue_newbuf\t\t__P((struct cue_softc *, struct cue_chain *,\n\t\t\t\t    struct mbuf *));\nStatic int;\ncue_send\t\t__P((struct cue_softc *, struct mbuf *, int));\nStatic void;\ncue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\ncue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\ncue_stop\t\t__P((struct cue_softc *));\nStatic void;\nStatic void;\ncue_setmulti\t__P((struct cue_softc *));\nStatic void;\ncue_reset\t\t__P((struct cue_softc *));\nStatic int;\ncue_csr_read_1\t__P((struct cue_softc *, int));\nStatic int;\ncue_csr_write_1\t__P((struct cue_softc *, int, int));\nStatic int;\ncue_csr_read_2\t__P((struct cue_softc *, int));\nStatic int;\ncue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));\nStatic int;\ncue_getmac\t\t__P((struct cue_softc *, void *));\n\nStatic int\ncue_send(sc, m, idx)\n\tstruct cue_softc\t*sc;\n\tstruct mbuf\t\t*m;\n\tint\t\t\tidx;\n{\n\tint\t\t\ttotal_len;\n\tstruct cue_chain\t*c;\n\tusbd_status\t\terr;\n\n\tc = &sc->cue_cdata.cue_tx_chain[idx];\n\n\t/*\n\t * Copy the mbuf data into a contiguous buffer, leaving two\n\t * bytes at the beginning to hold the frame length.\n\t */\n\tm_copydata(m, 0, m->m_pkthdr.len, c->cue_buf + 2);\n\tc->cue_mbuf = m;\n\n\ttotal_len = m->m_pkthdr.len + 2;\n\n\tDPRINTFN(10,(\"%s: %s: total_len=%d\\n\",\n\t\t     USBDEVNAME(sc->cue_dev), __FUNCTION__, total_len));\n\n\t/* The first two bytes are the frame length */\n\tc->cue_buf[0] = (u_int8_t)m->m_pkthdr.len;\n\tc->cue_buf[1] = (u_int8_t)(m->m_pkthdr.len >> 8);\n\n\t/* XXX 10000 */\n\tusbd_setup_xfer(c->cue_xfer, sc->cue_ep[CUE_ENDPT_TX],\n\t    c, c->cue_buf, total_len, USBD_NO_COPY, 10000, cue_txeof);\n\n\t/* Transmit */\n\terr = usbd_transfer(c->cue_xfer);\n\tif (err != USBD_IN_PROGRESS) {\n\t\tprintf(\"%s: cue_send error=%s\\n\", USBDEVNAME(sc->cue_dev),\n\t\t       usbd_errstr(err));\n\t\tcue_stop(sc);\n\t\treturn (EIO);\n\t}\n\n\tsc->cue_cdata.cue_tx_cnt++;\n\n\treturn (0);\n}"
  },
  {
    "function_name": "cue_tick",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_cue.c",
    "lines": "1132-1162",
    "snippet": "Static void\ncue_tick(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct cue_softc\t*sc = xsc;\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\ts;\n\n\tif (sc == NULL)\n\t\treturn;\n\n\tif (sc->cue_dying)\n\t\treturn;\n\n\tDPRINTFN(2,(\"%s: %s: enter\\n\", USBDEVNAME(sc->cue_dev), __FUNCTION__));\n\n\ts = splimp();\n\n\tifp = GET_IFP(sc);\n\n\tifp->if_collisions += cue_csr_read_2(sc, CUE_TX_SINGLECOLL);\n\tifp->if_collisions += cue_csr_read_2(sc, CUE_TX_MULTICOLL);\n\tifp->if_collisions += cue_csr_read_2(sc, CUE_TX_EXCESSCOLL);\n\n\tif (cue_csr_read_2(sc, CUE_RX_FRAMEERR))\n\t\tifp->if_ierrors++;\n\n\tusb_callout(sc->cue_stat_ch, hz, cue_tick, sc);\n\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/usb/if_cuereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "cue_open_pipes\t__P((struct cue_softc *));",
      "Static int",
      "cue_tx_list_init\t__P((struct cue_softc *));",
      "Static int",
      "cue_rx_list_init\t__P((struct cue_softc *));",
      "Static int",
      "Static int",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "cue_start\t\t__P((struct ifnet *));",
      "Static int",
      "Static void",
      "Static void",
      "cue_stop\t\t__P((struct cue_softc *));",
      "Static void",
      "cue_watchdog\t\t__P((struct ifnet *));",
      "Static void",
      "cue_setmulti\t__P((struct cue_softc *));",
      "Static void",
      "cue_reset\t\t__P((struct cue_softc *));",
      "Static int",
      "cue_csr_read_1\t__P((struct cue_softc *, int));",
      "Static int",
      "cue_csr_write_1\t__P((struct cue_softc *, int, int));",
      "Static int",
      "cue_csr_read_2\t__P((struct cue_softc *, int));",
      "Static int",
      "cue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));",
      "Static int",
      "cue_getmac\t\t__P((struct cue_softc *, void *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_callout",
          "args": [
            "sc->cue_stat_ch",
            "hz",
            "cue_tick",
            "sc"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cue_csr_read_2",
          "args": [
            "sc",
            "CUE_RX_FRAMEERR"
          ],
          "line": 1156
        },
        "resolved": true,
        "details": {
          "function_name": "cue_csr_read_2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_cue.c",
          "lines": "279-312",
          "snippet": "Static int\ncue_csr_read_2(sc, reg)\n\tstruct cue_softc\t*sc;\n\tint\t\t\treg;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tuWord\t\t\tval;\n\tint\t\t\ts;\n\n\tif (sc->cue_dying)\n\t\treturn (0);\n\n\treq.bmRequestType = UT_READ_VENDOR_DEVICE;\n\treq.bRequest = CUE_CMD_READREG;\n\tUSETW(req.wValue, 0);\n\tUSETW(req.wIndex, reg);\n\tUSETW(req.wLength, 2);\n\n\ts = splusb();\n\terr = CUE_DO_REQUEST(sc->cue_udev, &req, &val);\n\tsplx(s);\n\n\tDPRINTFN(10,(\"%s: cue_csr_read_2 reg=0x%x val=0x%x\\n\", \n\t\t     USBDEVNAME(sc->cue_dev), reg, UGETW(val)));\n\n\tif (err) {\n\t\tDPRINTF((\"%s: cue_csr_read_2: reg=0x%x err=%s\\n\",\n\t\t\t USBDEVNAME(sc->cue_dev), reg, usbd_errstr(err)));\n\t\treturn (0);\n\t}\n\n\treturn (UGETW(val));\n}",
          "includes": [
            "#include <dev/usb/if_cuereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "cue_open_pipes\t__P((struct cue_softc *));",
            "Static int",
            "cue_tx_list_init\t__P((struct cue_softc *));",
            "Static int",
            "cue_rx_list_init\t__P((struct cue_softc *));",
            "Static int",
            "Static int",
            "Static void",
            "cue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "cue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "cue_stop\t\t__P((struct cue_softc *));",
            "Static void",
            "Static void",
            "cue_setmulti\t__P((struct cue_softc *));",
            "Static void",
            "cue_reset\t\t__P((struct cue_softc *));",
            "Static int",
            "cue_csr_read_1\t__P((struct cue_softc *, int));",
            "Static int",
            "cue_csr_write_1\t__P((struct cue_softc *, int, int));",
            "Static int",
            "cue_csr_read_2\t__P((struct cue_softc *, int));",
            "Static int",
            "cue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));",
            "Static int",
            "cue_getmac\t\t__P((struct cue_softc *, void *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/if_cuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\ncue_open_pipes\t__P((struct cue_softc *));\nStatic int;\ncue_tx_list_init\t__P((struct cue_softc *));\nStatic int;\ncue_rx_list_init\t__P((struct cue_softc *));\nStatic int;\nStatic int;\nStatic void;\ncue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\ncue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\ncue_stop\t\t__P((struct cue_softc *));\nStatic void;\nStatic void;\ncue_setmulti\t__P((struct cue_softc *));\nStatic void;\ncue_reset\t\t__P((struct cue_softc *));\nStatic int;\ncue_csr_read_1\t__P((struct cue_softc *, int));\nStatic int;\ncue_csr_write_1\t__P((struct cue_softc *, int, int));\nStatic int;\ncue_csr_read_2\t__P((struct cue_softc *, int));\nStatic int;\ncue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));\nStatic int;\ncue_getmac\t\t__P((struct cue_softc *, void *));\n\nStatic int\ncue_csr_read_2(sc, reg)\n\tstruct cue_softc\t*sc;\n\tint\t\t\treg;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tuWord\t\t\tval;\n\tint\t\t\ts;\n\n\tif (sc->cue_dying)\n\t\treturn (0);\n\n\treq.bmRequestType = UT_READ_VENDOR_DEVICE;\n\treq.bRequest = CUE_CMD_READREG;\n\tUSETW(req.wValue, 0);\n\tUSETW(req.wIndex, reg);\n\tUSETW(req.wLength, 2);\n\n\ts = splusb();\n\terr = CUE_DO_REQUEST(sc->cue_udev, &req, &val);\n\tsplx(s);\n\n\tDPRINTFN(10,(\"%s: cue_csr_read_2 reg=0x%x val=0x%x\\n\", \n\t\t     USBDEVNAME(sc->cue_dev), reg, UGETW(val)));\n\n\tif (err) {\n\t\tDPRINTF((\"%s: cue_csr_read_2: reg=0x%x err=%s\\n\",\n\t\t\t USBDEVNAME(sc->cue_dev), reg, usbd_errstr(err)));\n\t\treturn (0);\n\t}\n\n\treturn (UGETW(val));\n}"
        }
      },
      {
        "call_info": {
          "callee": "GET_IFP",
          "args": [
            "sc"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "2",
            "(\"%s: %s: enter\\n\", USBDEVNAME(sc->cue_dev), __FUNCTION__)"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->cue_dev"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/if_cuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\ncue_open_pipes\t__P((struct cue_softc *));\nStatic int;\ncue_tx_list_init\t__P((struct cue_softc *));\nStatic int;\ncue_rx_list_init\t__P((struct cue_softc *));\nStatic int;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\ncue_start\t\t__P((struct ifnet *));\nStatic int;\nStatic void;\nStatic void;\ncue_stop\t\t__P((struct cue_softc *));\nStatic void;\ncue_watchdog\t\t__P((struct ifnet *));\nStatic void;\ncue_setmulti\t__P((struct cue_softc *));\nStatic void;\ncue_reset\t\t__P((struct cue_softc *));\nStatic int;\ncue_csr_read_1\t__P((struct cue_softc *, int));\nStatic int;\ncue_csr_write_1\t__P((struct cue_softc *, int, int));\nStatic int;\ncue_csr_read_2\t__P((struct cue_softc *, int));\nStatic int;\ncue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));\nStatic int;\ncue_getmac\t\t__P((struct cue_softc *, void *));\n\nStatic void\ncue_tick(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct cue_softc\t*sc = xsc;\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\ts;\n\n\tif (sc == NULL)\n\t\treturn;\n\n\tif (sc->cue_dying)\n\t\treturn;\n\n\tDPRINTFN(2,(\"%s: %s: enter\\n\", USBDEVNAME(sc->cue_dev), __FUNCTION__));\n\n\ts = splimp();\n\n\tifp = GET_IFP(sc);\n\n\tifp->if_collisions += cue_csr_read_2(sc, CUE_TX_SINGLECOLL);\n\tifp->if_collisions += cue_csr_read_2(sc, CUE_TX_MULTICOLL);\n\tifp->if_collisions += cue_csr_read_2(sc, CUE_TX_EXCESSCOLL);\n\n\tif (cue_csr_read_2(sc, CUE_RX_FRAMEERR))\n\t\tifp->if_ierrors++;\n\n\tusb_callout(sc->cue_stat_ch, hz, cue_tick, sc);\n\n\tsplx(s);\n}"
  },
  {
    "function_name": "cue_txeof",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_cue.c",
    "lines": "1079-1130",
    "snippet": "Static void\ncue_txeof(xfer, priv, status)\n\tusbd_xfer_handle\txfer;\n\tusbd_private_handle\tpriv;\n\tusbd_status\t\tstatus;\n{\n\tstruct cue_chain\t*c = priv;\n\tstruct cue_softc\t*sc = c->cue_sc;\n\tstruct ifnet\t\t*ifp = GET_IFP(sc);\n\tint\t\t\ts;\n\n\tif (sc->cue_dying)\n\t\treturn;\n\n\ts = splimp();\n\n\tDPRINTFN(10,(\"%s: %s: enter status=%d\\n\", USBDEVNAME(sc->cue_dev),\n\t\t    __FUNCTION__, status));\n\n\tifp->if_timer = 0;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tif (status != USBD_NORMAL_COMPLETION) {\n\t\tif (status == USBD_NOT_STARTED || status == USBD_CANCELLED) {\n\t\t\tsplx(s);\n\t\t\treturn;\n\t\t}\n\t\tifp->if_oerrors++;\n\t\tprintf(\"%s: usb error on tx: %s\\n\", USBDEVNAME(sc->cue_dev),\n\t\t    usbd_errstr(status));\n\t\tif (status == USBD_STALLED)\n\t\t\tusbd_clear_endpoint_stall(sc->cue_ep[CUE_ENDPT_TX]);\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\tifp->if_opackets++;\n\n#if defined(__FreeBSD__)\n\tc->cue_mbuf->m_pkthdr.rcvif = ifp;\n\tusb_tx_done(c->cue_mbuf);\n\tc->cue_mbuf = NULL;\n#elif defined(__NetBSD__) || defined(__OpenBSD__)\n\tm_freem(c->cue_mbuf);\n\tc->cue_mbuf = NULL;\n\n\tif (ifp->if_snd.ifq_head != NULL)\n\t\tcue_start(ifp);\n#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */\n\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/usb/if_cuereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "cue_open_pipes\t__P((struct cue_softc *));",
      "Static int",
      "cue_tx_list_init\t__P((struct cue_softc *));",
      "Static int",
      "cue_rx_list_init\t__P((struct cue_softc *));",
      "Static int",
      "Static int",
      "Static void",
      "cue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "cue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "Static void",
      "cue_start\t\t__P((struct ifnet *));",
      "Static int",
      "Static void",
      "Static void",
      "cue_stop\t\t__P((struct cue_softc *));",
      "Static void",
      "cue_watchdog\t\t__P((struct ifnet *));",
      "Static void",
      "cue_setmulti\t__P((struct cue_softc *));",
      "Static void",
      "cue_reset\t\t__P((struct cue_softc *));",
      "Static int",
      "cue_csr_read_1\t__P((struct cue_softc *, int));",
      "Static int",
      "cue_csr_write_1\t__P((struct cue_softc *, int, int));",
      "Static int",
      "cue_csr_read_2\t__P((struct cue_softc *, int));",
      "Static int",
      "cue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));",
      "Static int",
      "cue_getmac\t\t__P((struct cue_softc *, void *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cue_start",
          "args": [
            "ifp"
          ],
          "line": 1126
        },
        "resolved": true,
        "details": {
          "function_name": "cue_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_cue.c",
          "lines": "1210-1250",
          "snippet": "Static void\ncue_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct cue_softc\t*sc = ifp->if_softc;\n\tstruct mbuf\t\t*m_head = NULL;\n\n\tif (sc->cue_dying)\n\t\treturn;\n\n\tDPRINTFN(10,(\"%s: %s: enter\\n\", USBDEVNAME(sc->cue_dev),__FUNCTION__));\n\n\tif (ifp->if_flags & IFF_OACTIVE)\n\t\treturn;\n\n\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\tif (m_head == NULL)\n\t\treturn;\n\n\tif (cue_send(sc, m_head, 0)) {\n\t\tIF_PREPEND(&ifp->if_snd, m_head);\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t\treturn;\n\t}\n\n#if NBPFILTER > 0\n\t/*\n\t * If there's a BPF listener, bounce a copy of this frame\n\t * to him.\n\t */\n\tif (ifp->if_bpf)\n\t\tBPF_MTAP(ifp, m_head);\n#endif\n\n\tifp->if_flags |= IFF_OACTIVE;\n\n\t/*\n\t * Set a timeout in case the chip goes out to lunch.\n\t */\n\tifp->if_timer = 5;\n}",
          "includes": [
            "#include <dev/usb/if_cuereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "cue_open_pipes\t__P((struct cue_softc *));",
            "Static int",
            "cue_tx_list_init\t__P((struct cue_softc *));",
            "Static int",
            "cue_rx_list_init\t__P((struct cue_softc *));",
            "Static int",
            "cue_newbuf\t\t__P((struct cue_softc *, struct cue_chain *,\n\t\t\t\t    struct mbuf *));",
            "Static int",
            "cue_send\t\t__P((struct cue_softc *, struct mbuf *, int));",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "cue_start\t\t__P((struct ifnet *));",
            "Static int",
            "Static void",
            "Static void",
            "cue_stop\t\t__P((struct cue_softc *));",
            "Static void",
            "cue_watchdog\t\t__P((struct ifnet *));",
            "Static void",
            "cue_setmulti\t__P((struct cue_softc *));",
            "Static void",
            "cue_reset\t\t__P((struct cue_softc *));",
            "Static int",
            "cue_csr_read_1\t__P((struct cue_softc *, int));",
            "Static int",
            "cue_csr_write_1\t__P((struct cue_softc *, int, int));",
            "Static int",
            "cue_csr_read_2\t__P((struct cue_softc *, int));",
            "Static int",
            "cue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));",
            "Static int",
            "cue_getmac\t\t__P((struct cue_softc *, void *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/if_cuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\ncue_open_pipes\t__P((struct cue_softc *));\nStatic int;\ncue_tx_list_init\t__P((struct cue_softc *));\nStatic int;\ncue_rx_list_init\t__P((struct cue_softc *));\nStatic int;\ncue_newbuf\t\t__P((struct cue_softc *, struct cue_chain *,\n\t\t\t\t    struct mbuf *));\nStatic int;\ncue_send\t\t__P((struct cue_softc *, struct mbuf *, int));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\ncue_start\t\t__P((struct ifnet *));\nStatic int;\nStatic void;\nStatic void;\ncue_stop\t\t__P((struct cue_softc *));\nStatic void;\ncue_watchdog\t\t__P((struct ifnet *));\nStatic void;\ncue_setmulti\t__P((struct cue_softc *));\nStatic void;\ncue_reset\t\t__P((struct cue_softc *));\nStatic int;\ncue_csr_read_1\t__P((struct cue_softc *, int));\nStatic int;\ncue_csr_write_1\t__P((struct cue_softc *, int, int));\nStatic int;\ncue_csr_read_2\t__P((struct cue_softc *, int));\nStatic int;\ncue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));\nStatic int;\ncue_getmac\t\t__P((struct cue_softc *, void *));\n\nStatic void\ncue_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct cue_softc\t*sc = ifp->if_softc;\n\tstruct mbuf\t\t*m_head = NULL;\n\n\tif (sc->cue_dying)\n\t\treturn;\n\n\tDPRINTFN(10,(\"%s: %s: enter\\n\", USBDEVNAME(sc->cue_dev),__FUNCTION__));\n\n\tif (ifp->if_flags & IFF_OACTIVE)\n\t\treturn;\n\n\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\tif (m_head == NULL)\n\t\treturn;\n\n\tif (cue_send(sc, m_head, 0)) {\n\t\tIF_PREPEND(&ifp->if_snd, m_head);\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t\treturn;\n\t}\n\n#if NBPFILTER > 0\n\t/*\n\t * If there's a BPF listener, bounce a copy of this frame\n\t * to him.\n\t */\n\tif (ifp->if_bpf)\n\t\tBPF_MTAP(ifp, m_head);\n#endif\n\n\tifp->if_flags |= IFF_OACTIVE;\n\n\t/*\n\t * Set a timeout in case the chip goes out to lunch.\n\t */\n\tifp->if_timer = 5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "c->cue_mbuf"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_tx_done",
          "args": [
            "c->cue_mbuf"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_clear_endpoint_stall",
          "args": [
            "sc->cue_ep[CUE_ENDPT_TX]"
          ],
          "line": 1110
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_clear_endpoint_stall_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "611-628",
          "snippet": "usbd_status \nusbd_clear_endpoint_stall_async(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tusbd_device_handle dev = pipe->device;\n\tusb_device_request_t req;\n\tusbd_status err;\n\n\tpipe->methods->cleartoggle(pipe);\n\n\treq.bmRequestType = UT_WRITE_ENDPOINT;\n\treq.bRequest = UR_CLEAR_FEATURE;\n\tUSETW(req.wValue, UF_ENDPOINT_HALT);\n\tUSETW(req.wIndex, pipe->endpoint->edesc->bEndpointAddress);\n\tUSETW(req.wLength, 0);\n\terr = usbd_do_request_async(dev, &req, 0);\n\treturn (err);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);",
            "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\n\nusbd_status \nusbd_clear_endpoint_stall_async(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tusbd_device_handle dev = pipe->device;\n\tusb_device_request_t req;\n\tusbd_status err;\n\n\tpipe->methods->cleartoggle(pipe);\n\n\treq.bmRequestType = UT_WRITE_ENDPOINT;\n\treq.bRequest = UR_CLEAR_FEATURE;\n\tUSETW(req.wValue, UF_ENDPOINT_HALT);\n\tUSETW(req.wIndex, pipe->endpoint->edesc->bEndpointAddress);\n\tUSETW(req.wLength, 0);\n\terr = usbd_do_request_async(dev, &req, 0);\n\treturn (err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: usb error on tx: %s\\n\"",
            "USBDEVNAME(sc->cue_dev)",
            "usbd_errstr(status)"
          ],
          "line": 1107
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "status"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->cue_dev"
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "10",
            "(\"%s: %s: enter status=%d\\n\", USBDEVNAME(sc->cue_dev),\n\t\t    __FUNCTION__, status)"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->cue_dev"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_IFP",
          "args": [
            "sc"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/if_cuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\ncue_open_pipes\t__P((struct cue_softc *));\nStatic int;\ncue_tx_list_init\t__P((struct cue_softc *));\nStatic int;\ncue_rx_list_init\t__P((struct cue_softc *));\nStatic int;\nStatic int;\nStatic void;\ncue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\ncue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic void;\ncue_start\t\t__P((struct ifnet *));\nStatic int;\nStatic void;\nStatic void;\ncue_stop\t\t__P((struct cue_softc *));\nStatic void;\ncue_watchdog\t\t__P((struct ifnet *));\nStatic void;\ncue_setmulti\t__P((struct cue_softc *));\nStatic void;\ncue_reset\t\t__P((struct cue_softc *));\nStatic int;\ncue_csr_read_1\t__P((struct cue_softc *, int));\nStatic int;\ncue_csr_write_1\t__P((struct cue_softc *, int, int));\nStatic int;\ncue_csr_read_2\t__P((struct cue_softc *, int));\nStatic int;\ncue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));\nStatic int;\ncue_getmac\t\t__P((struct cue_softc *, void *));\n\nStatic void\ncue_txeof(xfer, priv, status)\n\tusbd_xfer_handle\txfer;\n\tusbd_private_handle\tpriv;\n\tusbd_status\t\tstatus;\n{\n\tstruct cue_chain\t*c = priv;\n\tstruct cue_softc\t*sc = c->cue_sc;\n\tstruct ifnet\t\t*ifp = GET_IFP(sc);\n\tint\t\t\ts;\n\n\tif (sc->cue_dying)\n\t\treturn;\n\n\ts = splimp();\n\n\tDPRINTFN(10,(\"%s: %s: enter status=%d\\n\", USBDEVNAME(sc->cue_dev),\n\t\t    __FUNCTION__, status));\n\n\tifp->if_timer = 0;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tif (status != USBD_NORMAL_COMPLETION) {\n\t\tif (status == USBD_NOT_STARTED || status == USBD_CANCELLED) {\n\t\t\tsplx(s);\n\t\t\treturn;\n\t\t}\n\t\tifp->if_oerrors++;\n\t\tprintf(\"%s: usb error on tx: %s\\n\", USBDEVNAME(sc->cue_dev),\n\t\t    usbd_errstr(status));\n\t\tif (status == USBD_STALLED)\n\t\t\tusbd_clear_endpoint_stall(sc->cue_ep[CUE_ENDPT_TX]);\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\tifp->if_opackets++;\n\n#if defined(__FreeBSD__)\n\tc->cue_mbuf->m_pkthdr.rcvif = ifp;\n\tusb_tx_done(c->cue_mbuf);\n\tc->cue_mbuf = NULL;\n#elif defined(__NetBSD__) || defined(__OpenBSD__)\n\tm_freem(c->cue_mbuf);\n\tc->cue_mbuf = NULL;\n\n\tif (ifp->if_snd.ifq_head != NULL)\n\t\tcue_start(ifp);\n#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */\n\n\tsplx(s);\n}"
  },
  {
    "function_name": "cue_rxeof",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_cue.c",
    "lines": "957-1073",
    "snippet": "Static void\ncue_rxeof(xfer, priv, status)\n\tusbd_xfer_handle\txfer;\n\tusbd_private_handle\tpriv;\n\tusbd_status\t\tstatus;\n{\n\tstruct cue_chain\t*c = priv;\n\tstruct cue_softc\t*sc = c->cue_sc;\n\tstruct ifnet\t\t*ifp = GET_IFP(sc);\n\tstruct mbuf\t\t*m;\n\tint\t\t\ttotal_len = 0;\n\tu_int16_t\t\tlen;\n#if defined(__NetBSD__) || defined(__OpenBSD__)\n\tint\t\t\ts;\n#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */\n\n\tDPRINTFN(10,(\"%s: %s: enter status=%d\\n\", USBDEVNAME(sc->cue_dev),\n\t\t     __FUNCTION__, status));\n\n\tif (sc->cue_dying)\n\t\treturn;\n\n\tif (!(ifp->if_flags & IFF_RUNNING))\n\t\treturn;\n\n\tif (status != USBD_NORMAL_COMPLETION) {\n\t\tif (status == USBD_NOT_STARTED || status == USBD_CANCELLED)\n\t\t\treturn;\n\t\tsc->cue_rx_errs++;\n\t\tif (usbd_ratecheck(&sc->cue_rx_notice)) {\n\t\t\tprintf(\"%s: %u usb errors on rx: %s\\n\",\n\t\t\t    USBDEVNAME(sc->cue_dev), sc->cue_rx_errs,\n\t\t\t    usbd_errstr(status));\n\t\t\tsc->cue_rx_errs = 0;\n\t\t}\n\t\tif (status == USBD_STALLED)\n\t\t\tusbd_clear_endpoint_stall(sc->cue_ep[CUE_ENDPT_RX]);\n\t\tgoto done;\n\t}\n\n\tusbd_get_xfer_status(xfer, NULL, NULL, &total_len, NULL);\n\n\tmemcpy(mtod(c->cue_mbuf, char *), c->cue_buf, total_len);\n\n\tm = c->cue_mbuf;\n\tlen = UGETW(mtod(m, u_int8_t *));\n\n\t/* No errors; receive the packet. */\n\ttotal_len = len;\n\n\tif (len < sizeof(struct ether_header)) {\n\t\tifp->if_ierrors++;\n\t\tgoto done;\n\t}\n\n\tifp->if_ipackets++;\n\tm_adj(m, sizeof(u_int16_t));\n\tm->m_pkthdr.len = m->m_len = total_len;\n\n#if defined(__FreeBSD__)\n\tm->m_pkthdr.rcvif = (struct ifnet *)&cue_qdat;\n\t/* Put the packet on the special USB input queue. */\n\tusb_ether_input(m);\n\n\treturn;\n#elif defined(__NetBSD__) || defined(__OpenBSD__)\n\tm->m_pkthdr.rcvif = ifp;\n\n\ts = splimp();\n\n\t/* XXX ugly */\n\tif (cue_newbuf(sc, c, NULL) == ENOBUFS) {\n\t\tifp->if_ierrors++;\n\t\tgoto done1;\n\t}\n\n#if NBPFILTER > 0\n\t/*\n\t * Handle BPF listeners. Let the BPF user see the packet, but\n\t * don't pass it up to the ether_input() layer unless it's\n\t * a broadcast packet, multicast packet, matches our ethernet\n\t * address or the interface is in promiscuous mode.\n\t */\n\tif (ifp->if_bpf) {\n#if defined(__NetBSD__)\n\t\tstruct ether_header *eh = mtod(m, struct ether_header *);\n\t\tBPF_MTAP(ifp, m);\n\t\tif ((ifp->if_flags & IFF_PROMISC) &&\n\t\t    memcmp(eh->ether_dhost, LLADDR(ifp->if_sadl),\n\t\t\t   ETHER_ADDR_LEN) &&\n\t\t    !(eh->ether_dhost[0] & 1)) {\n\t\t\tm_freem(m);\n\t\t\tgoto done1;\n\t\t}\n#else\n\t\tBPF_MTAP(ifp, m);\n#endif\n\t}\n#endif\n\n\tDPRINTFN(10,(\"%s: %s: deliver %d\\n\", USBDEVNAME(sc->cue_dev),\n\t\t    __FUNCTION__, m->m_len));\n\tIF_INPUT(ifp, m);\n done1:\n\tsplx(s);\n#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */\n\ndone:\n\t/* Setup new transfer. */\n\tusbd_setup_xfer(c->cue_xfer, sc->cue_ep[CUE_ENDPT_RX],\n\t    c, c->cue_buf, CUE_BUFSZ, USBD_SHORT_XFER_OK | USBD_NO_COPY,\n\t    USBD_NO_TIMEOUT, cue_rxeof);\n\tusbd_transfer(c->cue_xfer);\n\n\tDPRINTFN(10,(\"%s: %s: start rx\\n\", USBDEVNAME(sc->cue_dev),\n\t\t    __FUNCTION__));\n}",
    "includes": [
      "#include <dev/usb/if_cuereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "cue_open_pipes\t__P((struct cue_softc *));",
      "Static int",
      "cue_tx_list_init\t__P((struct cue_softc *));",
      "Static int",
      "cue_rx_list_init\t__P((struct cue_softc *));",
      "Static int",
      "cue_newbuf\t\t__P((struct cue_softc *, struct cue_chain *,\n\t\t\t\t    struct mbuf *));",
      "Static int",
      "cue_send\t\t__P((struct cue_softc *, struct mbuf *, int));",
      "Static void",
      "cue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "cue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "Static void",
      "cue_start\t\t__P((struct ifnet *));",
      "Static int",
      "Static void",
      "Static void",
      "cue_stop\t\t__P((struct cue_softc *));",
      "Static void",
      "cue_watchdog\t\t__P((struct ifnet *));",
      "Static void",
      "cue_setmulti\t__P((struct cue_softc *));",
      "Static void",
      "cue_reset\t\t__P((struct cue_softc *));",
      "Static int",
      "cue_csr_read_1\t__P((struct cue_softc *, int));",
      "Static int",
      "cue_csr_write_1\t__P((struct cue_softc *, int, int));",
      "Static int",
      "cue_csr_read_2\t__P((struct cue_softc *, int));",
      "Static int",
      "cue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));",
      "Static int",
      "cue_getmac\t\t__P((struct cue_softc *, void *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "10",
            "(\"%s: %s: start rx\\n\", USBDEVNAME(sc->cue_dev),\n\t\t    __FUNCTION__)"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->cue_dev"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_transfer",
          "args": [
            "c->cue_xfer"
          ],
          "line": 1069
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_transfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "254-339",
          "snippet": "usbd_status\nusbd_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tusbd_status err;\n\tu_int size;\n\tint s;\n\n\tDPRINTFN(5,(\"usbd_transfer: xfer=%p, flags=%d, pipe=%p, running=%d\\n\",\n\t\t    xfer, xfer->flags, pipe, pipe->running));\n#ifdef USB_DEBUG\n\tif (usbdebug > 5)\n\t\tusbd_dump_queue(pipe);\n#endif\n\txfer->done = 0;\n\n\tif (pipe->aborting)\n\t\treturn (USBD_CANCELLED);\n\n\tsize = xfer->length;\n\t/* If there is no buffer, allocate one. */\n\tif (!(xfer->rqflags & URQ_DEV_DMABUF) && size != 0) {\n\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n#ifdef DIAGNOSTIC\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF)\n\t\t\tprintf(\"usbd_transfer: has old buffer!\\n\");\n#endif\n\t\terr = bus->methods->allocm(bus, dmap, size);\n\t\tif (err)\n\t\t\treturn (err);\n\t\txfer->rqflags |= URQ_AUTO_DMABUF;\n\t}\n\n\t/* Copy data if going out. */\n\tif (!(xfer->flags & USBD_NO_COPY) && size != 0 && \n\t    !usbd_xfer_isread(xfer))\n\t\tmemcpy(KERNADDR(dmap), xfer->buffer, size);\n\n\terr = pipe->methods->transfer(xfer);\n\n\tif (err != USBD_IN_PROGRESS && err) {\n\t\t/* The transfer has not been queued, so free buffer. */\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n\t\t\tbus->methods->freem(bus, &xfer->dmabuf);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!(xfer->flags & USBD_SYNCHRONOUS))\n\t\treturn (err);\n\n\t/* Sync transfer, wait for completion. */\n\tif (err != USBD_IN_PROGRESS)\n\t\treturn (err);\n\ts = splusb();\n\tif (!xfer->done) {\n\t\tif (pipe->device->bus->use_polling)\n\t\t\tpanic(\"usbd_transfer: not done\\n\");\n\t\t/* XXX Temporary hack XXX */\n\t\tif (xfer->flags & USBD_NO_TSLEEP) {\n\t\t\tint i;\n\t\t\tusbd_bus_handle bus = pipe->device->bus;\n\t\t\tint to = xfer->timeout * 1000;\n\t\t\tfor (i = 0; i < to; i += 10) {\n\t\t\t\tdelay(10);\n\t\t\t\tbus->methods->do_poll(bus);\n\t\t\t\tif (xfer->done)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* XXX Is this right, what about the HC timeout? */\n\t\t\tif (!xfer->done) {\n\t\t\t\tpipe->methods->abort(xfer);\n\t\t\t\txfer->status = USBD_TIMEOUT;\n\t\t\t}\n\t\t} else\n\t\t/* XXX End hack XXX */\n\t\t\ttsleep(xfer, PRIBIO, \"usbsyn\", 0);\n\t}\n\tsplx(s);\n\treturn (xfer->status);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "u_int32_t size;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nu_int32_t size;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nusbd_status\nusbd_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tusbd_status err;\n\tu_int size;\n\tint s;\n\n\tDPRINTFN(5,(\"usbd_transfer: xfer=%p, flags=%d, pipe=%p, running=%d\\n\",\n\t\t    xfer, xfer->flags, pipe, pipe->running));\n#ifdef USB_DEBUG\n\tif (usbdebug > 5)\n\t\tusbd_dump_queue(pipe);\n#endif\n\txfer->done = 0;\n\n\tif (pipe->aborting)\n\t\treturn (USBD_CANCELLED);\n\n\tsize = xfer->length;\n\t/* If there is no buffer, allocate one. */\n\tif (!(xfer->rqflags & URQ_DEV_DMABUF) && size != 0) {\n\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n#ifdef DIAGNOSTIC\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF)\n\t\t\tprintf(\"usbd_transfer: has old buffer!\\n\");\n#endif\n\t\terr = bus->methods->allocm(bus, dmap, size);\n\t\tif (err)\n\t\t\treturn (err);\n\t\txfer->rqflags |= URQ_AUTO_DMABUF;\n\t}\n\n\t/* Copy data if going out. */\n\tif (!(xfer->flags & USBD_NO_COPY) && size != 0 && \n\t    !usbd_xfer_isread(xfer))\n\t\tmemcpy(KERNADDR(dmap), xfer->buffer, size);\n\n\terr = pipe->methods->transfer(xfer);\n\n\tif (err != USBD_IN_PROGRESS && err) {\n\t\t/* The transfer has not been queued, so free buffer. */\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n\t\t\tbus->methods->freem(bus, &xfer->dmabuf);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!(xfer->flags & USBD_SYNCHRONOUS))\n\t\treturn (err);\n\n\t/* Sync transfer, wait for completion. */\n\tif (err != USBD_IN_PROGRESS)\n\t\treturn (err);\n\ts = splusb();\n\tif (!xfer->done) {\n\t\tif (pipe->device->bus->use_polling)\n\t\t\tpanic(\"usbd_transfer: not done\\n\");\n\t\t/* XXX Temporary hack XXX */\n\t\tif (xfer->flags & USBD_NO_TSLEEP) {\n\t\t\tint i;\n\t\t\tusbd_bus_handle bus = pipe->device->bus;\n\t\t\tint to = xfer->timeout * 1000;\n\t\t\tfor (i = 0; i < to; i += 10) {\n\t\t\t\tdelay(10);\n\t\t\t\tbus->methods->do_poll(bus);\n\t\t\t\tif (xfer->done)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* XXX Is this right, what about the HC timeout? */\n\t\t\tif (!xfer->done) {\n\t\t\t\tpipe->methods->abort(xfer);\n\t\t\t\txfer->status = USBD_TIMEOUT;\n\t\t\t}\n\t\t} else\n\t\t/* XXX End hack XXX */\n\t\t\ttsleep(xfer, PRIBIO, \"usbsyn\", 0);\n\t}\n\tsplx(s);\n\treturn (xfer->status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_setup_xfer",
          "args": [
            "c->cue_xfer",
            "sc->cue_ep[CUE_ENDPT_RX]",
            "c",
            "c->cue_buf",
            "CUE_BUFSZ",
            "USBD_SHORT_XFER_OK | USBD_NO_COPY",
            "USBD_NO_TIMEOUT",
            "cue_rxeof"
          ],
          "line": 1066
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_setup_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "420-444",
          "snippet": "void\nusbd_setup_xfer(xfer, pipe, priv, buffer, length, flags, timeout, callback)\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle pipe;\n\tusbd_private_handle priv;\n\tvoid *buffer;\n\tu_int32_t length;\n\tu_int16_t flags;\n\tu_int32_t timeout;\n\tvoid (*callback) __P((usbd_xfer_handle,\n\t\t\t      usbd_private_handle,\n\t\t\t      usbd_status));\n{\n\txfer->pipe = pipe;\n\txfer->priv = priv;\n\txfer->buffer = buffer;\n\txfer->length = length;\n\txfer->actlen = 0;\n\txfer->flags = flags;\n\txfer->timeout = timeout;\n\txfer->status = USBD_NOT_STARTED;\n\txfer->callback = callback;\n\txfer->rqflags &= ~URQ_REQUEST;\n\txfer->nframes = 0;\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nvoid\nusbd_setup_xfer(xfer, pipe, priv, buffer, length, flags, timeout, callback)\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle pipe;\n\tusbd_private_handle priv;\n\tvoid *buffer;\n\tu_int32_t length;\n\tu_int16_t flags;\n\tu_int32_t timeout;\n\tvoid (*callback) __P((usbd_xfer_handle,\n\t\t\t      usbd_private_handle,\n\t\t\t      usbd_status));\n{\n\txfer->pipe = pipe;\n\txfer->priv = priv;\n\txfer->buffer = buffer;\n\txfer->length = length;\n\txfer->actlen = 0;\n\txfer->flags = flags;\n\txfer->timeout = timeout;\n\txfer->status = USBD_NOT_STARTED;\n\txfer->callback = callback;\n\txfer->rqflags &= ~URQ_REQUEST;\n\txfer->nframes = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_INPUT",
          "args": [
            "ifp",
            "m"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "10",
            "(\"%s: %s: deliver %d\\n\", USBDEVNAME(sc->cue_dev),\n\t\t    __FUNCTION__, m->m_len)"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->cue_dev"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_MTAP",
          "args": [
            "ifp",
            "m"
          ],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "eh->ether_dhost",
            "LLADDR(ifp->if_sadl)",
            "ETHER_ADDR_LEN"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LLADDR",
          "args": [
            "ifp->if_sadl"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_MTAP",
          "args": [
            "ifp",
            "m"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "structether_header*"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cue_newbuf",
          "args": [
            "sc",
            "c",
            "NULL"
          ],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "cue_newbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_cue.c",
          "lines": "834-868",
          "snippet": "Static int\ncue_newbuf(sc, c, m)\n\tstruct cue_softc\t*sc;\n\tstruct cue_chain\t*c;\n\tstruct mbuf\t\t*m;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\n\tif (m == NULL) {\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\tprintf(\"%s: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\", USBDEVNAME(sc->cue_dev));\n\t\t\treturn (ENOBUFS);\n\t\t}\n\n\t\tMCLGET(m_new, M_DONTWAIT);\n\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\tprintf(\"%s: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\", USBDEVNAME(sc->cue_dev));\n\t\t\tm_freem(m_new);\n\t\t\treturn (ENOBUFS);\n\t\t}\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t} else {\n\t\tm_new = m;\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t\tm_new->m_data = m_new->m_ext.ext_buf;\n\t}\n\n\tm_adj(m_new, ETHER_ALIGN);\n\tc->cue_mbuf = m_new;\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/usb/if_cuereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "cue_open_pipes\t__P((struct cue_softc *));",
            "Static int",
            "cue_tx_list_init\t__P((struct cue_softc *));",
            "Static int",
            "cue_rx_list_init\t__P((struct cue_softc *));",
            "Static int",
            "cue_newbuf\t\t__P((struct cue_softc *, struct cue_chain *,\n\t\t\t\t    struct mbuf *));",
            "Static int",
            "cue_send\t\t__P((struct cue_softc *, struct mbuf *, int));",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "cue_stop\t\t__P((struct cue_softc *));",
            "Static void",
            "Static void",
            "cue_setmulti\t__P((struct cue_softc *));",
            "Static void",
            "cue_reset\t\t__P((struct cue_softc *));",
            "Static int",
            "cue_csr_read_1\t__P((struct cue_softc *, int));",
            "Static int",
            "cue_csr_write_1\t__P((struct cue_softc *, int, int));",
            "Static int",
            "cue_csr_read_2\t__P((struct cue_softc *, int));",
            "Static int",
            "cue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));",
            "Static int",
            "cue_getmac\t\t__P((struct cue_softc *, void *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/if_cuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\ncue_open_pipes\t__P((struct cue_softc *));\nStatic int;\ncue_tx_list_init\t__P((struct cue_softc *));\nStatic int;\ncue_rx_list_init\t__P((struct cue_softc *));\nStatic int;\ncue_newbuf\t\t__P((struct cue_softc *, struct cue_chain *,\n\t\t\t\t    struct mbuf *));\nStatic int;\ncue_send\t\t__P((struct cue_softc *, struct mbuf *, int));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\ncue_stop\t\t__P((struct cue_softc *));\nStatic void;\nStatic void;\ncue_setmulti\t__P((struct cue_softc *));\nStatic void;\ncue_reset\t\t__P((struct cue_softc *));\nStatic int;\ncue_csr_read_1\t__P((struct cue_softc *, int));\nStatic int;\ncue_csr_write_1\t__P((struct cue_softc *, int, int));\nStatic int;\ncue_csr_read_2\t__P((struct cue_softc *, int));\nStatic int;\ncue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));\nStatic int;\ncue_getmac\t\t__P((struct cue_softc *, void *));\n\nStatic int\ncue_newbuf(sc, c, m)\n\tstruct cue_softc\t*sc;\n\tstruct cue_chain\t*c;\n\tstruct mbuf\t\t*m;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\n\tif (m == NULL) {\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\tprintf(\"%s: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\", USBDEVNAME(sc->cue_dev));\n\t\t\treturn (ENOBUFS);\n\t\t}\n\n\t\tMCLGET(m_new, M_DONTWAIT);\n\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\tprintf(\"%s: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\", USBDEVNAME(sc->cue_dev));\n\t\t\tm_freem(m_new);\n\t\t\treturn (ENOBUFS);\n\t\t}\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t} else {\n\t\tm_new = m;\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t\tm_new->m_data = m_new->m_ext.ext_buf;\n\t}\n\n\tm_adj(m_new, ETHER_ALIGN);\n\tc->cue_mbuf = m_new;\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_ether_input",
          "args": [
            "m"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_adj",
          "args": [
            "m",
            "sizeof(u_int16_t)"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "mtod(m, u_int8_t *)"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "u_int8_t*"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "mtod(c->cue_mbuf, char *)",
            "c->cue_buf",
            "total_len"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "c->cue_mbuf",
            "char*"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_get_xfer_status",
          "args": [
            "xfer",
            "NULL",
            "NULL",
            "&total_len",
            "NULL"
          ],
          "line": 997
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_get_xfer_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "499-515",
          "snippet": "void\nusbd_get_xfer_status(xfer, priv, buffer, count, status)\n\tusbd_xfer_handle xfer;\n\tusbd_private_handle *priv;\n\tvoid **buffer;\n\tu_int32_t *count;\n\tusbd_status *status;\n{\n\tif (priv != NULL)\n\t\t*priv = xfer->priv;\n\tif (buffer != NULL)\n\t\t*buffer = xfer->buffer;\n\tif (count != NULL)\n\t\t*count = xfer->actlen;\n\tif (status != NULL)\n\t\t*status = xfer->status;\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static usbd_status",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\n\nvoid\nusbd_get_xfer_status(xfer, priv, buffer, count, status)\n\tusbd_xfer_handle xfer;\n\tusbd_private_handle *priv;\n\tvoid **buffer;\n\tu_int32_t *count;\n\tusbd_status *status;\n{\n\tif (priv != NULL)\n\t\t*priv = xfer->priv;\n\tif (buffer != NULL)\n\t\t*buffer = xfer->buffer;\n\tif (count != NULL)\n\t\t*count = xfer->actlen;\n\tif (status != NULL)\n\t\t*status = xfer->status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_clear_endpoint_stall",
          "args": [
            "sc->cue_ep[CUE_ENDPT_RX]"
          ],
          "line": 993
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_clear_endpoint_stall_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "611-628",
          "snippet": "usbd_status \nusbd_clear_endpoint_stall_async(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tusbd_device_handle dev = pipe->device;\n\tusb_device_request_t req;\n\tusbd_status err;\n\n\tpipe->methods->cleartoggle(pipe);\n\n\treq.bmRequestType = UT_WRITE_ENDPOINT;\n\treq.bRequest = UR_CLEAR_FEATURE;\n\tUSETW(req.wValue, UF_ENDPOINT_HALT);\n\tUSETW(req.wIndex, pipe->endpoint->edesc->bEndpointAddress);\n\tUSETW(req.wLength, 0);\n\terr = usbd_do_request_async(dev, &req, 0);\n\treturn (err);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);",
            "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\n\nusbd_status \nusbd_clear_endpoint_stall_async(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tusbd_device_handle dev = pipe->device;\n\tusb_device_request_t req;\n\tusbd_status err;\n\n\tpipe->methods->cleartoggle(pipe);\n\n\treq.bmRequestType = UT_WRITE_ENDPOINT;\n\treq.bRequest = UR_CLEAR_FEATURE;\n\tUSETW(req.wValue, UF_ENDPOINT_HALT);\n\tUSETW(req.wIndex, pipe->endpoint->edesc->bEndpointAddress);\n\tUSETW(req.wLength, 0);\n\terr = usbd_do_request_async(dev, &req, 0);\n\treturn (err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: %u usb errors on rx: %s\\n\"",
            "USBDEVNAME(sc->cue_dev)",
            "sc->cue_rx_errs",
            "usbd_errstr(status)"
          ],
          "line": 987
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "status"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->cue_dev"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_ratecheck",
          "args": [
            "&sc->cue_rx_notice"
          ],
          "line": 986
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_ratecheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "1134-1141",
          "snippet": "int\nusbd_ratecheck(last)\n\tstruct timeval *last;\n{\n\tstatic struct timeval errinterval = { 0, 250000 }; /* 0.25 s*/\n\n\treturn (ratecheck(last, &errinterval));\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nusbd_ratecheck(last)\n\tstruct timeval *last;\n{\n\tstatic struct timeval errinterval = { 0, 250000 }; /* 0.25 s*/\n\n\treturn (ratecheck(last, &errinterval));\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "10",
            "(\"%s: %s: enter status=%d\\n\", USBDEVNAME(sc->cue_dev),\n\t\t     __FUNCTION__, status)"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->cue_dev"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_IFP",
          "args": [
            "sc"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/if_cuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\ncue_open_pipes\t__P((struct cue_softc *));\nStatic int;\ncue_tx_list_init\t__P((struct cue_softc *));\nStatic int;\ncue_rx_list_init\t__P((struct cue_softc *));\nStatic int;\ncue_newbuf\t\t__P((struct cue_softc *, struct cue_chain *,\n\t\t\t\t    struct mbuf *));\nStatic int;\ncue_send\t\t__P((struct cue_softc *, struct mbuf *, int));\nStatic void;\ncue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\ncue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic void;\ncue_start\t\t__P((struct ifnet *));\nStatic int;\nStatic void;\nStatic void;\ncue_stop\t\t__P((struct cue_softc *));\nStatic void;\ncue_watchdog\t\t__P((struct ifnet *));\nStatic void;\ncue_setmulti\t__P((struct cue_softc *));\nStatic void;\ncue_reset\t\t__P((struct cue_softc *));\nStatic int;\ncue_csr_read_1\t__P((struct cue_softc *, int));\nStatic int;\ncue_csr_write_1\t__P((struct cue_softc *, int, int));\nStatic int;\ncue_csr_read_2\t__P((struct cue_softc *, int));\nStatic int;\ncue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));\nStatic int;\ncue_getmac\t\t__P((struct cue_softc *, void *));\n\nStatic void\ncue_rxeof(xfer, priv, status)\n\tusbd_xfer_handle\txfer;\n\tusbd_private_handle\tpriv;\n\tusbd_status\t\tstatus;\n{\n\tstruct cue_chain\t*c = priv;\n\tstruct cue_softc\t*sc = c->cue_sc;\n\tstruct ifnet\t\t*ifp = GET_IFP(sc);\n\tstruct mbuf\t\t*m;\n\tint\t\t\ttotal_len = 0;\n\tu_int16_t\t\tlen;\n#if defined(__NetBSD__) || defined(__OpenBSD__)\n\tint\t\t\ts;\n#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */\n\n\tDPRINTFN(10,(\"%s: %s: enter status=%d\\n\", USBDEVNAME(sc->cue_dev),\n\t\t     __FUNCTION__, status));\n\n\tif (sc->cue_dying)\n\t\treturn;\n\n\tif (!(ifp->if_flags & IFF_RUNNING))\n\t\treturn;\n\n\tif (status != USBD_NORMAL_COMPLETION) {\n\t\tif (status == USBD_NOT_STARTED || status == USBD_CANCELLED)\n\t\t\treturn;\n\t\tsc->cue_rx_errs++;\n\t\tif (usbd_ratecheck(&sc->cue_rx_notice)) {\n\t\t\tprintf(\"%s: %u usb errors on rx: %s\\n\",\n\t\t\t    USBDEVNAME(sc->cue_dev), sc->cue_rx_errs,\n\t\t\t    usbd_errstr(status));\n\t\t\tsc->cue_rx_errs = 0;\n\t\t}\n\t\tif (status == USBD_STALLED)\n\t\t\tusbd_clear_endpoint_stall(sc->cue_ep[CUE_ENDPT_RX]);\n\t\tgoto done;\n\t}\n\n\tusbd_get_xfer_status(xfer, NULL, NULL, &total_len, NULL);\n\n\tmemcpy(mtod(c->cue_mbuf, char *), c->cue_buf, total_len);\n\n\tm = c->cue_mbuf;\n\tlen = UGETW(mtod(m, u_int8_t *));\n\n\t/* No errors; receive the packet. */\n\ttotal_len = len;\n\n\tif (len < sizeof(struct ether_header)) {\n\t\tifp->if_ierrors++;\n\t\tgoto done;\n\t}\n\n\tifp->if_ipackets++;\n\tm_adj(m, sizeof(u_int16_t));\n\tm->m_pkthdr.len = m->m_len = total_len;\n\n#if defined(__FreeBSD__)\n\tm->m_pkthdr.rcvif = (struct ifnet *)&cue_qdat;\n\t/* Put the packet on the special USB input queue. */\n\tusb_ether_input(m);\n\n\treturn;\n#elif defined(__NetBSD__) || defined(__OpenBSD__)\n\tm->m_pkthdr.rcvif = ifp;\n\n\ts = splimp();\n\n\t/* XXX ugly */\n\tif (cue_newbuf(sc, c, NULL) == ENOBUFS) {\n\t\tifp->if_ierrors++;\n\t\tgoto done1;\n\t}\n\n#if NBPFILTER > 0\n\t/*\n\t * Handle BPF listeners. Let the BPF user see the packet, but\n\t * don't pass it up to the ether_input() layer unless it's\n\t * a broadcast packet, multicast packet, matches our ethernet\n\t * address or the interface is in promiscuous mode.\n\t */\n\tif (ifp->if_bpf) {\n#if defined(__NetBSD__)\n\t\tstruct ether_header *eh = mtod(m, struct ether_header *);\n\t\tBPF_MTAP(ifp, m);\n\t\tif ((ifp->if_flags & IFF_PROMISC) &&\n\t\t    memcmp(eh->ether_dhost, LLADDR(ifp->if_sadl),\n\t\t\t   ETHER_ADDR_LEN) &&\n\t\t    !(eh->ether_dhost[0] & 1)) {\n\t\t\tm_freem(m);\n\t\t\tgoto done1;\n\t\t}\n#else\n\t\tBPF_MTAP(ifp, m);\n#endif\n\t}\n#endif\n\n\tDPRINTFN(10,(\"%s: %s: deliver %d\\n\", USBDEVNAME(sc->cue_dev),\n\t\t    __FUNCTION__, m->m_len));\n\tIF_INPUT(ifp, m);\n done1:\n\tsplx(s);\n#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */\n\ndone:\n\t/* Setup new transfer. */\n\tusbd_setup_xfer(c->cue_xfer, sc->cue_ep[CUE_ENDPT_RX],\n\t    c, c->cue_buf, CUE_BUFSZ, USBD_SHORT_XFER_OK | USBD_NO_COPY,\n\t    USBD_NO_TIMEOUT, cue_rxeof);\n\tusbd_transfer(c->cue_xfer);\n\n\tDPRINTFN(10,(\"%s: %s: start rx\\n\", USBDEVNAME(sc->cue_dev),\n\t\t    __FUNCTION__));\n}"
  },
  {
    "function_name": "cue_rxstart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_cue.c",
    "lines": "930-950",
    "snippet": "Static void\ncue_rxstart(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct cue_softc\t*sc;\n\tstruct cue_chain\t*c;\n\n\tsc = ifp->if_softc;\n\tc = &sc->cue_cdata.cue_rx_chain[sc->cue_cdata.cue_rx_prod];\n\n\tif (cue_newbuf(sc, c, NULL) == ENOBUFS) {\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\n\t/* Setup new transfer. */\n\tusbd_setup_xfer(c->cue_xfer, sc->cue_ep[CUE_ENDPT_RX],\n\t    c, c->cue_buf, CUE_BUFSZ, USBD_SHORT_XFER_OK | USBD_NO_COPY,\n\t    USBD_NO_TIMEOUT, cue_rxeof);\n\tusbd_transfer(c->cue_xfer);\n}",
    "includes": [
      "#include <dev/usb/if_cuereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "cue_open_pipes\t__P((struct cue_softc *));",
      "Static int",
      "cue_tx_list_init\t__P((struct cue_softc *));",
      "Static int",
      "cue_rx_list_init\t__P((struct cue_softc *));",
      "Static int",
      "Static int",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "cue_start\t\t__P((struct ifnet *));",
      "Static int",
      "Static void",
      "Static void",
      "cue_stop\t\t__P((struct cue_softc *));",
      "Static void",
      "cue_watchdog\t\t__P((struct ifnet *));",
      "Static void",
      "cue_setmulti\t__P((struct cue_softc *));",
      "Static void",
      "cue_reset\t\t__P((struct cue_softc *));",
      "Static int",
      "cue_csr_read_1\t__P((struct cue_softc *, int));",
      "Static int",
      "cue_csr_write_1\t__P((struct cue_softc *, int, int));",
      "Static int",
      "cue_csr_read_2\t__P((struct cue_softc *, int));",
      "Static int",
      "cue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));",
      "Static int",
      "cue_getmac\t\t__P((struct cue_softc *, void *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usbd_transfer",
          "args": [
            "c->cue_xfer"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_transfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "254-339",
          "snippet": "usbd_status\nusbd_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tusbd_status err;\n\tu_int size;\n\tint s;\n\n\tDPRINTFN(5,(\"usbd_transfer: xfer=%p, flags=%d, pipe=%p, running=%d\\n\",\n\t\t    xfer, xfer->flags, pipe, pipe->running));\n#ifdef USB_DEBUG\n\tif (usbdebug > 5)\n\t\tusbd_dump_queue(pipe);\n#endif\n\txfer->done = 0;\n\n\tif (pipe->aborting)\n\t\treturn (USBD_CANCELLED);\n\n\tsize = xfer->length;\n\t/* If there is no buffer, allocate one. */\n\tif (!(xfer->rqflags & URQ_DEV_DMABUF) && size != 0) {\n\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n#ifdef DIAGNOSTIC\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF)\n\t\t\tprintf(\"usbd_transfer: has old buffer!\\n\");\n#endif\n\t\terr = bus->methods->allocm(bus, dmap, size);\n\t\tif (err)\n\t\t\treturn (err);\n\t\txfer->rqflags |= URQ_AUTO_DMABUF;\n\t}\n\n\t/* Copy data if going out. */\n\tif (!(xfer->flags & USBD_NO_COPY) && size != 0 && \n\t    !usbd_xfer_isread(xfer))\n\t\tmemcpy(KERNADDR(dmap), xfer->buffer, size);\n\n\terr = pipe->methods->transfer(xfer);\n\n\tif (err != USBD_IN_PROGRESS && err) {\n\t\t/* The transfer has not been queued, so free buffer. */\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n\t\t\tbus->methods->freem(bus, &xfer->dmabuf);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!(xfer->flags & USBD_SYNCHRONOUS))\n\t\treturn (err);\n\n\t/* Sync transfer, wait for completion. */\n\tif (err != USBD_IN_PROGRESS)\n\t\treturn (err);\n\ts = splusb();\n\tif (!xfer->done) {\n\t\tif (pipe->device->bus->use_polling)\n\t\t\tpanic(\"usbd_transfer: not done\\n\");\n\t\t/* XXX Temporary hack XXX */\n\t\tif (xfer->flags & USBD_NO_TSLEEP) {\n\t\t\tint i;\n\t\t\tusbd_bus_handle bus = pipe->device->bus;\n\t\t\tint to = xfer->timeout * 1000;\n\t\t\tfor (i = 0; i < to; i += 10) {\n\t\t\t\tdelay(10);\n\t\t\t\tbus->methods->do_poll(bus);\n\t\t\t\tif (xfer->done)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* XXX Is this right, what about the HC timeout? */\n\t\t\tif (!xfer->done) {\n\t\t\t\tpipe->methods->abort(xfer);\n\t\t\t\txfer->status = USBD_TIMEOUT;\n\t\t\t}\n\t\t} else\n\t\t/* XXX End hack XXX */\n\t\t\ttsleep(xfer, PRIBIO, \"usbsyn\", 0);\n\t}\n\tsplx(s);\n\treturn (xfer->status);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "u_int32_t size;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nu_int32_t size;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nusbd_status\nusbd_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tusbd_status err;\n\tu_int size;\n\tint s;\n\n\tDPRINTFN(5,(\"usbd_transfer: xfer=%p, flags=%d, pipe=%p, running=%d\\n\",\n\t\t    xfer, xfer->flags, pipe, pipe->running));\n#ifdef USB_DEBUG\n\tif (usbdebug > 5)\n\t\tusbd_dump_queue(pipe);\n#endif\n\txfer->done = 0;\n\n\tif (pipe->aborting)\n\t\treturn (USBD_CANCELLED);\n\n\tsize = xfer->length;\n\t/* If there is no buffer, allocate one. */\n\tif (!(xfer->rqflags & URQ_DEV_DMABUF) && size != 0) {\n\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n#ifdef DIAGNOSTIC\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF)\n\t\t\tprintf(\"usbd_transfer: has old buffer!\\n\");\n#endif\n\t\terr = bus->methods->allocm(bus, dmap, size);\n\t\tif (err)\n\t\t\treturn (err);\n\t\txfer->rqflags |= URQ_AUTO_DMABUF;\n\t}\n\n\t/* Copy data if going out. */\n\tif (!(xfer->flags & USBD_NO_COPY) && size != 0 && \n\t    !usbd_xfer_isread(xfer))\n\t\tmemcpy(KERNADDR(dmap), xfer->buffer, size);\n\n\terr = pipe->methods->transfer(xfer);\n\n\tif (err != USBD_IN_PROGRESS && err) {\n\t\t/* The transfer has not been queued, so free buffer. */\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n\t\t\tbus->methods->freem(bus, &xfer->dmabuf);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!(xfer->flags & USBD_SYNCHRONOUS))\n\t\treturn (err);\n\n\t/* Sync transfer, wait for completion. */\n\tif (err != USBD_IN_PROGRESS)\n\t\treturn (err);\n\ts = splusb();\n\tif (!xfer->done) {\n\t\tif (pipe->device->bus->use_polling)\n\t\t\tpanic(\"usbd_transfer: not done\\n\");\n\t\t/* XXX Temporary hack XXX */\n\t\tif (xfer->flags & USBD_NO_TSLEEP) {\n\t\t\tint i;\n\t\t\tusbd_bus_handle bus = pipe->device->bus;\n\t\t\tint to = xfer->timeout * 1000;\n\t\t\tfor (i = 0; i < to; i += 10) {\n\t\t\t\tdelay(10);\n\t\t\t\tbus->methods->do_poll(bus);\n\t\t\t\tif (xfer->done)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* XXX Is this right, what about the HC timeout? */\n\t\t\tif (!xfer->done) {\n\t\t\t\tpipe->methods->abort(xfer);\n\t\t\t\txfer->status = USBD_TIMEOUT;\n\t\t\t}\n\t\t} else\n\t\t/* XXX End hack XXX */\n\t\t\ttsleep(xfer, PRIBIO, \"usbsyn\", 0);\n\t}\n\tsplx(s);\n\treturn (xfer->status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_setup_xfer",
          "args": [
            "c->cue_xfer",
            "sc->cue_ep[CUE_ENDPT_RX]",
            "c",
            "c->cue_buf",
            "CUE_BUFSZ",
            "USBD_SHORT_XFER_OK | USBD_NO_COPY",
            "USBD_NO_TIMEOUT",
            "cue_rxeof"
          ],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_setup_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "420-444",
          "snippet": "void\nusbd_setup_xfer(xfer, pipe, priv, buffer, length, flags, timeout, callback)\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle pipe;\n\tusbd_private_handle priv;\n\tvoid *buffer;\n\tu_int32_t length;\n\tu_int16_t flags;\n\tu_int32_t timeout;\n\tvoid (*callback) __P((usbd_xfer_handle,\n\t\t\t      usbd_private_handle,\n\t\t\t      usbd_status));\n{\n\txfer->pipe = pipe;\n\txfer->priv = priv;\n\txfer->buffer = buffer;\n\txfer->length = length;\n\txfer->actlen = 0;\n\txfer->flags = flags;\n\txfer->timeout = timeout;\n\txfer->status = USBD_NOT_STARTED;\n\txfer->callback = callback;\n\txfer->rqflags &= ~URQ_REQUEST;\n\txfer->nframes = 0;\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nvoid\nusbd_setup_xfer(xfer, pipe, priv, buffer, length, flags, timeout, callback)\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle pipe;\n\tusbd_private_handle priv;\n\tvoid *buffer;\n\tu_int32_t length;\n\tu_int16_t flags;\n\tu_int32_t timeout;\n\tvoid (*callback) __P((usbd_xfer_handle,\n\t\t\t      usbd_private_handle,\n\t\t\t      usbd_status));\n{\n\txfer->pipe = pipe;\n\txfer->priv = priv;\n\txfer->buffer = buffer;\n\txfer->length = length;\n\txfer->actlen = 0;\n\txfer->flags = flags;\n\txfer->timeout = timeout;\n\txfer->status = USBD_NOT_STARTED;\n\txfer->callback = callback;\n\txfer->rqflags &= ~URQ_REQUEST;\n\txfer->nframes = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cue_newbuf",
          "args": [
            "sc",
            "c",
            "NULL"
          ],
          "line": 940
        },
        "resolved": true,
        "details": {
          "function_name": "cue_newbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_cue.c",
          "lines": "834-868",
          "snippet": "Static int\ncue_newbuf(sc, c, m)\n\tstruct cue_softc\t*sc;\n\tstruct cue_chain\t*c;\n\tstruct mbuf\t\t*m;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\n\tif (m == NULL) {\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\tprintf(\"%s: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\", USBDEVNAME(sc->cue_dev));\n\t\t\treturn (ENOBUFS);\n\t\t}\n\n\t\tMCLGET(m_new, M_DONTWAIT);\n\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\tprintf(\"%s: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\", USBDEVNAME(sc->cue_dev));\n\t\t\tm_freem(m_new);\n\t\t\treturn (ENOBUFS);\n\t\t}\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t} else {\n\t\tm_new = m;\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t\tm_new->m_data = m_new->m_ext.ext_buf;\n\t}\n\n\tm_adj(m_new, ETHER_ALIGN);\n\tc->cue_mbuf = m_new;\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/usb/if_cuereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "cue_open_pipes\t__P((struct cue_softc *));",
            "Static int",
            "cue_tx_list_init\t__P((struct cue_softc *));",
            "Static int",
            "cue_rx_list_init\t__P((struct cue_softc *));",
            "Static int",
            "cue_newbuf\t\t__P((struct cue_softc *, struct cue_chain *,\n\t\t\t\t    struct mbuf *));",
            "Static int",
            "cue_send\t\t__P((struct cue_softc *, struct mbuf *, int));",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "cue_stop\t\t__P((struct cue_softc *));",
            "Static void",
            "Static void",
            "cue_setmulti\t__P((struct cue_softc *));",
            "Static void",
            "cue_reset\t\t__P((struct cue_softc *));",
            "Static int",
            "cue_csr_read_1\t__P((struct cue_softc *, int));",
            "Static int",
            "cue_csr_write_1\t__P((struct cue_softc *, int, int));",
            "Static int",
            "cue_csr_read_2\t__P((struct cue_softc *, int));",
            "Static int",
            "cue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));",
            "Static int",
            "cue_getmac\t\t__P((struct cue_softc *, void *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/if_cuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\ncue_open_pipes\t__P((struct cue_softc *));\nStatic int;\ncue_tx_list_init\t__P((struct cue_softc *));\nStatic int;\ncue_rx_list_init\t__P((struct cue_softc *));\nStatic int;\ncue_newbuf\t\t__P((struct cue_softc *, struct cue_chain *,\n\t\t\t\t    struct mbuf *));\nStatic int;\ncue_send\t\t__P((struct cue_softc *, struct mbuf *, int));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\ncue_stop\t\t__P((struct cue_softc *));\nStatic void;\nStatic void;\ncue_setmulti\t__P((struct cue_softc *));\nStatic void;\ncue_reset\t\t__P((struct cue_softc *));\nStatic int;\ncue_csr_read_1\t__P((struct cue_softc *, int));\nStatic int;\ncue_csr_write_1\t__P((struct cue_softc *, int, int));\nStatic int;\ncue_csr_read_2\t__P((struct cue_softc *, int));\nStatic int;\ncue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));\nStatic int;\ncue_getmac\t\t__P((struct cue_softc *, void *));\n\nStatic int\ncue_newbuf(sc, c, m)\n\tstruct cue_softc\t*sc;\n\tstruct cue_chain\t*c;\n\tstruct mbuf\t\t*m;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\n\tif (m == NULL) {\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\tprintf(\"%s: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\", USBDEVNAME(sc->cue_dev));\n\t\t\treturn (ENOBUFS);\n\t\t}\n\n\t\tMCLGET(m_new, M_DONTWAIT);\n\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\tprintf(\"%s: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\", USBDEVNAME(sc->cue_dev));\n\t\t\tm_freem(m_new);\n\t\t\treturn (ENOBUFS);\n\t\t}\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t} else {\n\t\tm_new = m;\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t\tm_new->m_data = m_new->m_ext.ext_buf;\n\t}\n\n\tm_adj(m_new, ETHER_ALIGN);\n\tc->cue_mbuf = m_new;\n\n\treturn (0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/usb/if_cuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\ncue_open_pipes\t__P((struct cue_softc *));\nStatic int;\ncue_tx_list_init\t__P((struct cue_softc *));\nStatic int;\ncue_rx_list_init\t__P((struct cue_softc *));\nStatic int;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\ncue_start\t\t__P((struct ifnet *));\nStatic int;\nStatic void;\nStatic void;\ncue_stop\t\t__P((struct cue_softc *));\nStatic void;\ncue_watchdog\t\t__P((struct ifnet *));\nStatic void;\ncue_setmulti\t__P((struct cue_softc *));\nStatic void;\ncue_reset\t\t__P((struct cue_softc *));\nStatic int;\ncue_csr_read_1\t__P((struct cue_softc *, int));\nStatic int;\ncue_csr_write_1\t__P((struct cue_softc *, int, int));\nStatic int;\ncue_csr_read_2\t__P((struct cue_softc *, int));\nStatic int;\ncue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));\nStatic int;\ncue_getmac\t\t__P((struct cue_softc *, void *));\n\nStatic void\ncue_rxstart(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct cue_softc\t*sc;\n\tstruct cue_chain\t*c;\n\n\tsc = ifp->if_softc;\n\tc = &sc->cue_cdata.cue_rx_chain[sc->cue_cdata.cue_rx_prod];\n\n\tif (cue_newbuf(sc, c, NULL) == ENOBUFS) {\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\n\t/* Setup new transfer. */\n\tusbd_setup_xfer(c->cue_xfer, sc->cue_ep[CUE_ENDPT_RX],\n\t    c, c->cue_buf, CUE_BUFSZ, USBD_SHORT_XFER_OK | USBD_NO_COPY,\n\t    USBD_NO_TIMEOUT, cue_rxeof);\n\tusbd_transfer(c->cue_xfer);\n}"
  },
  {
    "function_name": "cue_tx_list_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_cue.c",
    "lines": "900-927",
    "snippet": "Static int\ncue_tx_list_init(sc)\n\tstruct cue_softc\t*sc;\n{\n\tstruct cue_cdata\t*cd;\n\tstruct cue_chain\t*c;\n\tint\t\t\ti;\n\n\tcd = &sc->cue_cdata;\n\tfor (i = 0; i < CUE_TX_LIST_CNT; i++) {\n\t\tc = &cd->cue_tx_chain[i];\n\t\tc->cue_sc = sc;\n\t\tc->cue_idx = i;\n\t\tc->cue_mbuf = NULL;\n\t\tif (c->cue_xfer == NULL) {\n\t\t\tc->cue_xfer = usbd_alloc_xfer(sc->cue_udev);\n\t\t\tif (c->cue_xfer == NULL)\n\t\t\t\treturn (ENOBUFS);\n\t\t\tc->cue_buf = usbd_alloc_buffer(c->cue_xfer, CUE_BUFSZ);\n\t\t\tif (c->cue_buf == NULL) {\n\t\t\t\tusbd_free_xfer(c->cue_xfer);\n\t\t\t\treturn (ENOBUFS);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/usb/if_cuereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "cue_open_pipes\t__P((struct cue_softc *));",
      "Static int",
      "cue_tx_list_init\t__P((struct cue_softc *));",
      "Static int",
      "cue_rx_list_init\t__P((struct cue_softc *));",
      "Static int",
      "Static int",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "cue_stop\t\t__P((struct cue_softc *));",
      "Static void",
      "Static void",
      "cue_setmulti\t__P((struct cue_softc *));",
      "Static void",
      "cue_reset\t\t__P((struct cue_softc *));",
      "Static int",
      "cue_csr_read_1\t__P((struct cue_softc *, int));",
      "Static int",
      "cue_csr_write_1\t__P((struct cue_softc *, int, int));",
      "Static int",
      "cue_csr_read_2\t__P((struct cue_softc *, int));",
      "Static int",
      "cue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));",
      "Static int",
      "cue_getmac\t\t__P((struct cue_softc *, void *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usbd_free_xfer",
          "args": [
            "c->cue_xfer"
          ],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_free_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "403-418",
          "snippet": "usbd_status \nusbd_free_xfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tDPRINTFN(5,(\"usbd_free_xfer: %p\\n\", xfer));\n\tif (xfer->rqflags & (URQ_DEV_DMABUF | URQ_AUTO_DMABUF))\n\t\tusbd_free_buffer(xfer);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&xfer->timeout_handle)) {\n\t\tcallout_stop(&xfer->timeout_handle);\n\t\tprintf(\"usbd_free_xfer: timout_handle pending\");\n\t}\n#endif\n\txfer->device->bus->methods->freex(xfer->device->bus, xfer);\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static usbd_status",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\n\nusbd_status \nusbd_free_xfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tDPRINTFN(5,(\"usbd_free_xfer: %p\\n\", xfer));\n\tif (xfer->rqflags & (URQ_DEV_DMABUF | URQ_AUTO_DMABUF))\n\t\tusbd_free_buffer(xfer);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&xfer->timeout_handle)) {\n\t\tcallout_stop(&xfer->timeout_handle);\n\t\tprintf(\"usbd_free_xfer: timout_handle pending\");\n\t}\n#endif\n\txfer->device->bus->methods->freex(xfer->device->bus, xfer);\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_alloc_buffer",
          "args": [
            "c->cue_xfer",
            "CUE_BUFSZ"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_alloc_xfer",
          "args": [
            "sc->cue_udev"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_alloc_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "388-401",
          "snippet": "usbd_xfer_handle \nusbd_alloc_xfer(dev)\n\tusbd_device_handle dev;\n{\n\tusbd_xfer_handle xfer;\n\n\txfer = dev->bus->methods->allocx(dev->bus);\n\tif (xfer == NULL)\n\t\treturn (NULL);\n\txfer->device = dev;\n\tusb_callout_init(xfer->timeout_handle);\n\tDPRINTFN(5,(\"usbd_alloc_xfer() = %p\\n\", xfer));\n\treturn (xfer);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
            "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\n\nusbd_xfer_handle \nusbd_alloc_xfer(dev)\n\tusbd_device_handle dev;\n{\n\tusbd_xfer_handle xfer;\n\n\txfer = dev->bus->methods->allocx(dev->bus);\n\tif (xfer == NULL)\n\t\treturn (NULL);\n\txfer->device = dev;\n\tusb_callout_init(xfer->timeout_handle);\n\tDPRINTFN(5,(\"usbd_alloc_xfer() = %p\\n\", xfer));\n\treturn (xfer);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/usb/if_cuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\ncue_open_pipes\t__P((struct cue_softc *));\nStatic int;\ncue_tx_list_init\t__P((struct cue_softc *));\nStatic int;\ncue_rx_list_init\t__P((struct cue_softc *));\nStatic int;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\ncue_stop\t\t__P((struct cue_softc *));\nStatic void;\nStatic void;\ncue_setmulti\t__P((struct cue_softc *));\nStatic void;\ncue_reset\t\t__P((struct cue_softc *));\nStatic int;\ncue_csr_read_1\t__P((struct cue_softc *, int));\nStatic int;\ncue_csr_write_1\t__P((struct cue_softc *, int, int));\nStatic int;\ncue_csr_read_2\t__P((struct cue_softc *, int));\nStatic int;\ncue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));\nStatic int;\ncue_getmac\t\t__P((struct cue_softc *, void *));\n\nStatic int\ncue_tx_list_init(sc)\n\tstruct cue_softc\t*sc;\n{\n\tstruct cue_cdata\t*cd;\n\tstruct cue_chain\t*c;\n\tint\t\t\ti;\n\n\tcd = &sc->cue_cdata;\n\tfor (i = 0; i < CUE_TX_LIST_CNT; i++) {\n\t\tc = &cd->cue_tx_chain[i];\n\t\tc->cue_sc = sc;\n\t\tc->cue_idx = i;\n\t\tc->cue_mbuf = NULL;\n\t\tif (c->cue_xfer == NULL) {\n\t\t\tc->cue_xfer = usbd_alloc_xfer(sc->cue_udev);\n\t\t\tif (c->cue_xfer == NULL)\n\t\t\t\treturn (ENOBUFS);\n\t\t\tc->cue_buf = usbd_alloc_buffer(c->cue_xfer, CUE_BUFSZ);\n\t\t\tif (c->cue_buf == NULL) {\n\t\t\t\tusbd_free_xfer(c->cue_xfer);\n\t\t\t\treturn (ENOBUFS);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (0);\n}"
  },
  {
    "function_name": "cue_rx_list_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_cue.c",
    "lines": "870-898",
    "snippet": "Static int\ncue_rx_list_init(sc)\n\tstruct cue_softc\t*sc;\n{\n\tstruct cue_cdata\t*cd;\n\tstruct cue_chain\t*c;\n\tint\t\t\ti;\n\n\tcd = &sc->cue_cdata;\n\tfor (i = 0; i < CUE_RX_LIST_CNT; i++) {\n\t\tc = &cd->cue_rx_chain[i];\n\t\tc->cue_sc = sc;\n\t\tc->cue_idx = i;\n\t\tif (cue_newbuf(sc, c, NULL) == ENOBUFS)\n\t\t\treturn (ENOBUFS);\n\t\tif (c->cue_xfer == NULL) {\n\t\t\tc->cue_xfer = usbd_alloc_xfer(sc->cue_udev);\n\t\t\tif (c->cue_xfer == NULL)\n\t\t\t\treturn (ENOBUFS);\n\t\t\tc->cue_buf = usbd_alloc_buffer(c->cue_xfer, CUE_BUFSZ);\n\t\t\tif (c->cue_buf == NULL) {\n\t\t\t\tusbd_free_xfer(c->cue_xfer);\n\t\t\t\treturn (ENOBUFS);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/usb/if_cuereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "cue_open_pipes\t__P((struct cue_softc *));",
      "Static int",
      "cue_tx_list_init\t__P((struct cue_softc *));",
      "Static int",
      "cue_rx_list_init\t__P((struct cue_softc *));",
      "Static int",
      "Static int",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "cue_stop\t\t__P((struct cue_softc *));",
      "Static void",
      "Static void",
      "cue_setmulti\t__P((struct cue_softc *));",
      "Static void",
      "cue_reset\t\t__P((struct cue_softc *));",
      "Static int",
      "cue_csr_read_1\t__P((struct cue_softc *, int));",
      "Static int",
      "cue_csr_write_1\t__P((struct cue_softc *, int, int));",
      "Static int",
      "cue_csr_read_2\t__P((struct cue_softc *, int));",
      "Static int",
      "cue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));",
      "Static int",
      "cue_getmac\t\t__P((struct cue_softc *, void *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usbd_free_xfer",
          "args": [
            "c->cue_xfer"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_free_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "403-418",
          "snippet": "usbd_status \nusbd_free_xfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tDPRINTFN(5,(\"usbd_free_xfer: %p\\n\", xfer));\n\tif (xfer->rqflags & (URQ_DEV_DMABUF | URQ_AUTO_DMABUF))\n\t\tusbd_free_buffer(xfer);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&xfer->timeout_handle)) {\n\t\tcallout_stop(&xfer->timeout_handle);\n\t\tprintf(\"usbd_free_xfer: timout_handle pending\");\n\t}\n#endif\n\txfer->device->bus->methods->freex(xfer->device->bus, xfer);\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static usbd_status",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\n\nusbd_status \nusbd_free_xfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tDPRINTFN(5,(\"usbd_free_xfer: %p\\n\", xfer));\n\tif (xfer->rqflags & (URQ_DEV_DMABUF | URQ_AUTO_DMABUF))\n\t\tusbd_free_buffer(xfer);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&xfer->timeout_handle)) {\n\t\tcallout_stop(&xfer->timeout_handle);\n\t\tprintf(\"usbd_free_xfer: timout_handle pending\");\n\t}\n#endif\n\txfer->device->bus->methods->freex(xfer->device->bus, xfer);\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_alloc_buffer",
          "args": [
            "c->cue_xfer",
            "CUE_BUFSZ"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_alloc_xfer",
          "args": [
            "sc->cue_udev"
          ],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_alloc_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "388-401",
          "snippet": "usbd_xfer_handle \nusbd_alloc_xfer(dev)\n\tusbd_device_handle dev;\n{\n\tusbd_xfer_handle xfer;\n\n\txfer = dev->bus->methods->allocx(dev->bus);\n\tif (xfer == NULL)\n\t\treturn (NULL);\n\txfer->device = dev;\n\tusb_callout_init(xfer->timeout_handle);\n\tDPRINTFN(5,(\"usbd_alloc_xfer() = %p\\n\", xfer));\n\treturn (xfer);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
            "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\n\nusbd_xfer_handle \nusbd_alloc_xfer(dev)\n\tusbd_device_handle dev;\n{\n\tusbd_xfer_handle xfer;\n\n\txfer = dev->bus->methods->allocx(dev->bus);\n\tif (xfer == NULL)\n\t\treturn (NULL);\n\txfer->device = dev;\n\tusb_callout_init(xfer->timeout_handle);\n\tDPRINTFN(5,(\"usbd_alloc_xfer() = %p\\n\", xfer));\n\treturn (xfer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cue_newbuf",
          "args": [
            "sc",
            "c",
            "NULL"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "cue_newbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_cue.c",
          "lines": "834-868",
          "snippet": "Static int\ncue_newbuf(sc, c, m)\n\tstruct cue_softc\t*sc;\n\tstruct cue_chain\t*c;\n\tstruct mbuf\t\t*m;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\n\tif (m == NULL) {\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\tprintf(\"%s: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\", USBDEVNAME(sc->cue_dev));\n\t\t\treturn (ENOBUFS);\n\t\t}\n\n\t\tMCLGET(m_new, M_DONTWAIT);\n\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\tprintf(\"%s: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\", USBDEVNAME(sc->cue_dev));\n\t\t\tm_freem(m_new);\n\t\t\treturn (ENOBUFS);\n\t\t}\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t} else {\n\t\tm_new = m;\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t\tm_new->m_data = m_new->m_ext.ext_buf;\n\t}\n\n\tm_adj(m_new, ETHER_ALIGN);\n\tc->cue_mbuf = m_new;\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/usb/if_cuereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "cue_open_pipes\t__P((struct cue_softc *));",
            "Static int",
            "cue_tx_list_init\t__P((struct cue_softc *));",
            "Static int",
            "cue_rx_list_init\t__P((struct cue_softc *));",
            "Static int",
            "cue_newbuf\t\t__P((struct cue_softc *, struct cue_chain *,\n\t\t\t\t    struct mbuf *));",
            "Static int",
            "cue_send\t\t__P((struct cue_softc *, struct mbuf *, int));",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "cue_stop\t\t__P((struct cue_softc *));",
            "Static void",
            "Static void",
            "cue_setmulti\t__P((struct cue_softc *));",
            "Static void",
            "cue_reset\t\t__P((struct cue_softc *));",
            "Static int",
            "cue_csr_read_1\t__P((struct cue_softc *, int));",
            "Static int",
            "cue_csr_write_1\t__P((struct cue_softc *, int, int));",
            "Static int",
            "cue_csr_read_2\t__P((struct cue_softc *, int));",
            "Static int",
            "cue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));",
            "Static int",
            "cue_getmac\t\t__P((struct cue_softc *, void *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/if_cuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\ncue_open_pipes\t__P((struct cue_softc *));\nStatic int;\ncue_tx_list_init\t__P((struct cue_softc *));\nStatic int;\ncue_rx_list_init\t__P((struct cue_softc *));\nStatic int;\ncue_newbuf\t\t__P((struct cue_softc *, struct cue_chain *,\n\t\t\t\t    struct mbuf *));\nStatic int;\ncue_send\t\t__P((struct cue_softc *, struct mbuf *, int));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\ncue_stop\t\t__P((struct cue_softc *));\nStatic void;\nStatic void;\ncue_setmulti\t__P((struct cue_softc *));\nStatic void;\ncue_reset\t\t__P((struct cue_softc *));\nStatic int;\ncue_csr_read_1\t__P((struct cue_softc *, int));\nStatic int;\ncue_csr_write_1\t__P((struct cue_softc *, int, int));\nStatic int;\ncue_csr_read_2\t__P((struct cue_softc *, int));\nStatic int;\ncue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));\nStatic int;\ncue_getmac\t\t__P((struct cue_softc *, void *));\n\nStatic int\ncue_newbuf(sc, c, m)\n\tstruct cue_softc\t*sc;\n\tstruct cue_chain\t*c;\n\tstruct mbuf\t\t*m;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\n\tif (m == NULL) {\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\tprintf(\"%s: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\", USBDEVNAME(sc->cue_dev));\n\t\t\treturn (ENOBUFS);\n\t\t}\n\n\t\tMCLGET(m_new, M_DONTWAIT);\n\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\tprintf(\"%s: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\", USBDEVNAME(sc->cue_dev));\n\t\t\tm_freem(m_new);\n\t\t\treturn (ENOBUFS);\n\t\t}\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t} else {\n\t\tm_new = m;\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t\tm_new->m_data = m_new->m_ext.ext_buf;\n\t}\n\n\tm_adj(m_new, ETHER_ALIGN);\n\tc->cue_mbuf = m_new;\n\n\treturn (0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/usb/if_cuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\ncue_open_pipes\t__P((struct cue_softc *));\nStatic int;\ncue_tx_list_init\t__P((struct cue_softc *));\nStatic int;\ncue_rx_list_init\t__P((struct cue_softc *));\nStatic int;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\ncue_stop\t\t__P((struct cue_softc *));\nStatic void;\nStatic void;\ncue_setmulti\t__P((struct cue_softc *));\nStatic void;\ncue_reset\t\t__P((struct cue_softc *));\nStatic int;\ncue_csr_read_1\t__P((struct cue_softc *, int));\nStatic int;\ncue_csr_write_1\t__P((struct cue_softc *, int, int));\nStatic int;\ncue_csr_read_2\t__P((struct cue_softc *, int));\nStatic int;\ncue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));\nStatic int;\ncue_getmac\t\t__P((struct cue_softc *, void *));\n\nStatic int\ncue_rx_list_init(sc)\n\tstruct cue_softc\t*sc;\n{\n\tstruct cue_cdata\t*cd;\n\tstruct cue_chain\t*c;\n\tint\t\t\ti;\n\n\tcd = &sc->cue_cdata;\n\tfor (i = 0; i < CUE_RX_LIST_CNT; i++) {\n\t\tc = &cd->cue_rx_chain[i];\n\t\tc->cue_sc = sc;\n\t\tc->cue_idx = i;\n\t\tif (cue_newbuf(sc, c, NULL) == ENOBUFS)\n\t\t\treturn (ENOBUFS);\n\t\tif (c->cue_xfer == NULL) {\n\t\t\tc->cue_xfer = usbd_alloc_xfer(sc->cue_udev);\n\t\t\tif (c->cue_xfer == NULL)\n\t\t\t\treturn (ENOBUFS);\n\t\t\tc->cue_buf = usbd_alloc_buffer(c->cue_xfer, CUE_BUFSZ);\n\t\t\tif (c->cue_buf == NULL) {\n\t\t\t\tusbd_free_xfer(c->cue_xfer);\n\t\t\t\treturn (ENOBUFS);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (0);\n}"
  },
  {
    "function_name": "cue_newbuf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_cue.c",
    "lines": "834-868",
    "snippet": "Static int\ncue_newbuf(sc, c, m)\n\tstruct cue_softc\t*sc;\n\tstruct cue_chain\t*c;\n\tstruct mbuf\t\t*m;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\n\tif (m == NULL) {\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\tprintf(\"%s: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\", USBDEVNAME(sc->cue_dev));\n\t\t\treturn (ENOBUFS);\n\t\t}\n\n\t\tMCLGET(m_new, M_DONTWAIT);\n\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\tprintf(\"%s: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\", USBDEVNAME(sc->cue_dev));\n\t\t\tm_freem(m_new);\n\t\t\treturn (ENOBUFS);\n\t\t}\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t} else {\n\t\tm_new = m;\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t\tm_new->m_data = m_new->m_ext.ext_buf;\n\t}\n\n\tm_adj(m_new, ETHER_ALIGN);\n\tc->cue_mbuf = m_new;\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/usb/if_cuereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "cue_open_pipes\t__P((struct cue_softc *));",
      "Static int",
      "cue_tx_list_init\t__P((struct cue_softc *));",
      "Static int",
      "cue_rx_list_init\t__P((struct cue_softc *));",
      "Static int",
      "cue_newbuf\t\t__P((struct cue_softc *, struct cue_chain *,\n\t\t\t\t    struct mbuf *));",
      "Static int",
      "cue_send\t\t__P((struct cue_softc *, struct mbuf *, int));",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "cue_stop\t\t__P((struct cue_softc *));",
      "Static void",
      "Static void",
      "cue_setmulti\t__P((struct cue_softc *));",
      "Static void",
      "cue_reset\t\t__P((struct cue_softc *));",
      "Static int",
      "cue_csr_read_1\t__P((struct cue_softc *, int));",
      "Static int",
      "cue_csr_write_1\t__P((struct cue_softc *, int, int));",
      "Static int",
      "cue_csr_read_2\t__P((struct cue_softc *, int));",
      "Static int",
      "cue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));",
      "Static int",
      "cue_getmac\t\t__P((struct cue_softc *, void *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_adj",
          "args": [
            "m_new",
            "ETHER_ALIGN"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m_new"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\"",
            "USBDEVNAME(sc->cue_dev)"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->cue_dev"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MCLGET",
          "args": [
            "m_new",
            "M_DONTWAIT"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->cue_dev"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MGETHDR",
          "args": [
            "m_new",
            "M_DONTWAIT",
            "MT_DATA"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/if_cuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\ncue_open_pipes\t__P((struct cue_softc *));\nStatic int;\ncue_tx_list_init\t__P((struct cue_softc *));\nStatic int;\ncue_rx_list_init\t__P((struct cue_softc *));\nStatic int;\ncue_newbuf\t\t__P((struct cue_softc *, struct cue_chain *,\n\t\t\t\t    struct mbuf *));\nStatic int;\ncue_send\t\t__P((struct cue_softc *, struct mbuf *, int));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\ncue_stop\t\t__P((struct cue_softc *));\nStatic void;\nStatic void;\ncue_setmulti\t__P((struct cue_softc *));\nStatic void;\ncue_reset\t\t__P((struct cue_softc *));\nStatic int;\ncue_csr_read_1\t__P((struct cue_softc *, int));\nStatic int;\ncue_csr_write_1\t__P((struct cue_softc *, int, int));\nStatic int;\ncue_csr_read_2\t__P((struct cue_softc *, int));\nStatic int;\ncue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));\nStatic int;\ncue_getmac\t\t__P((struct cue_softc *, void *));\n\nStatic int\ncue_newbuf(sc, c, m)\n\tstruct cue_softc\t*sc;\n\tstruct cue_chain\t*c;\n\tstruct mbuf\t\t*m;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\n\tif (m == NULL) {\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\tprintf(\"%s: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\", USBDEVNAME(sc->cue_dev));\n\t\t\treturn (ENOBUFS);\n\t\t}\n\n\t\tMCLGET(m_new, M_DONTWAIT);\n\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\tprintf(\"%s: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\", USBDEVNAME(sc->cue_dev));\n\t\t\tm_freem(m_new);\n\t\t\treturn (ENOBUFS);\n\t\t}\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t} else {\n\t\tm_new = m;\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t\tm_new->m_data = m_new->m_ext.ext_buf;\n\t}\n\n\tm_adj(m_new, ETHER_ALIGN);\n\tc->cue_mbuf = m_new;\n\n\treturn (0);\n}"
  },
  {
    "function_name": "cue_activate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_cue.c",
    "lines": "807-828",
    "snippet": "int\ncue_activate(self, act)\n\tdevice_ptr_t self;\n\tenum devact act;\n{\n\tstruct cue_softc *sc = (struct cue_softc *)self;\n\n\tDPRINTFN(2,(\"%s: %s: enter\\n\", USBDEVNAME(sc->cue_dev), __FUNCTION__));\n\n\tswitch (act) {\n\tcase DVACT_ACTIVATE:\n\t\treturn (EOPNOTSUPP);\n\t\tbreak;\n\n\tcase DVACT_DEACTIVATE:\n\t\t/* Deactivate the interface. */\n\t\tif_deactivate(&sc->cue_ec.ec_if);\n\t\tsc->cue_dying = 1;\n\t\tbreak;\n\t}\n\treturn (0);\n}",
    "includes": [
      "#include <dev/usb/if_cuereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "cue_open_pipes\t__P((struct cue_softc *));",
      "cue_tx_list_init\t__P((struct cue_softc *));",
      "cue_rx_list_init\t__P((struct cue_softc *));",
      "cue_stop\t\t__P((struct cue_softc *));",
      "cue_setmulti\t__P((struct cue_softc *));",
      "cue_reset\t\t__P((struct cue_softc *));",
      "cue_csr_read_1\t__P((struct cue_softc *, int));",
      "cue_csr_write_1\t__P((struct cue_softc *, int, int));",
      "cue_csr_read_2\t__P((struct cue_softc *, int));",
      "cue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));",
      "cue_getmac\t\t__P((struct cue_softc *, void *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "if_deactivate",
          "args": [
            "&sc->cue_ec.ec_if"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "2",
            "(\"%s: %s: enter\\n\", USBDEVNAME(sc->cue_dev), __FUNCTION__)"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->cue_dev"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/if_cuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\ncue_open_pipes\t__P((struct cue_softc *));\ncue_tx_list_init\t__P((struct cue_softc *));\ncue_rx_list_init\t__P((struct cue_softc *));\ncue_stop\t\t__P((struct cue_softc *));\ncue_setmulti\t__P((struct cue_softc *));\ncue_reset\t\t__P((struct cue_softc *));\ncue_csr_read_1\t__P((struct cue_softc *, int));\ncue_csr_write_1\t__P((struct cue_softc *, int, int));\ncue_csr_read_2\t__P((struct cue_softc *, int));\ncue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));\ncue_getmac\t\t__P((struct cue_softc *, void *));\n\nint\ncue_activate(self, act)\n\tdevice_ptr_t self;\n\tenum devact act;\n{\n\tstruct cue_softc *sc = (struct cue_softc *)self;\n\n\tDPRINTFN(2,(\"%s: %s: enter\\n\", USBDEVNAME(sc->cue_dev), __FUNCTION__));\n\n\tswitch (act) {\n\tcase DVACT_ACTIVATE:\n\t\treturn (EOPNOTSUPP);\n\t\tbreak;\n\n\tcase DVACT_DEACTIVATE:\n\t\t/* Deactivate the interface. */\n\t\tif_deactivate(&sc->cue_ec.ec_if);\n\t\tsc->cue_dying = 1;\n\t\tbreak;\n\t}\n\treturn (0);\n}"
  },
  {
    "function_name": "cue_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_cue.c",
    "lines": "548-576",
    "snippet": "Static void\ncue_reset(sc)\n\tstruct cue_softc\t*sc;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tint\t\t\ts;\n\n\tDPRINTFN(2,(\"%s: cue_reset\\n\", USBDEVNAME(sc->cue_dev)));\n\n\tif (sc->cue_dying)\n\t\treturn;\n\n\treq.bmRequestType = UT_WRITE_VENDOR_DEVICE;\n\treq.bRequest = CUE_CMD_RESET;\n\tUSETW(req.wValue, 0);\n\tUSETW(req.wIndex, 0);\n\tUSETW(req.wLength, 0);\n\n\ts = splusb();\n\terr = CUE_DO_REQUEST(sc->cue_udev, &req, NULL);\n\tsplx(s);\n\n\tif (err)\n\t\tprintf(\"%s: reset failed\\n\", USBDEVNAME(sc->cue_dev));\n\n\t/* Wait a little while for the chip to get its brains in order. */\n\tdelay(1000);\t\t/* XXX */\n}",
    "includes": [
      "#include <dev/usb/if_cuereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "cue_open_pipes\t__P((struct cue_softc *));",
      "Static int",
      "cue_tx_list_init\t__P((struct cue_softc *));",
      "Static int",
      "cue_rx_list_init\t__P((struct cue_softc *));",
      "Static int",
      "Static int",
      "Static void",
      "cue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "cue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "cue_stop\t\t__P((struct cue_softc *));",
      "Static void",
      "Static void",
      "cue_setmulti\t__P((struct cue_softc *));",
      "Static void",
      "cue_reset\t\t__P((struct cue_softc *));",
      "Static int",
      "cue_csr_read_1\t__P((struct cue_softc *, int));",
      "Static int",
      "cue_csr_write_1\t__P((struct cue_softc *, int, int));",
      "Static int",
      "cue_csr_read_2\t__P((struct cue_softc *, int));",
      "Static int",
      "cue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));",
      "Static int",
      "cue_getmac\t\t__P((struct cue_softc *, void *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "1000"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_delay_ms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "316-322",
          "snippet": "void\nusbd_delay_ms(dev, ms)\n\tusbd_device_handle dev;\n\tu_int ms;\n{\n\tusb_delay_ms(dev->bus, ms);\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_set_config __P((usbd_device_handle, int));",
            "usbd_getnewaddr __P((usbd_bus_handle bus));",
            "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_set_config __P((usbd_device_handle, int));\nusbd_getnewaddr __P((usbd_bus_handle bus));\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\n\nvoid\nusbd_delay_ms(dev, ms)\n\tusbd_device_handle dev;\n\tu_int ms;\n{\n\tusb_delay_ms(dev->bus, ms);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: reset failed\\n\"",
            "USBDEVNAME(sc->cue_dev)"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->cue_dev"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CUE_DO_REQUEST",
          "args": [
            "sc->cue_udev",
            "&req",
            "NULL"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wLength",
            "0"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wIndex",
            "0"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wValue",
            "0"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "2",
            "(\"%s: cue_reset\\n\", USBDEVNAME(sc->cue_dev))"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->cue_dev"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/if_cuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\ncue_open_pipes\t__P((struct cue_softc *));\nStatic int;\ncue_tx_list_init\t__P((struct cue_softc *));\nStatic int;\ncue_rx_list_init\t__P((struct cue_softc *));\nStatic int;\nStatic int;\nStatic void;\ncue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\ncue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\ncue_stop\t\t__P((struct cue_softc *));\nStatic void;\nStatic void;\ncue_setmulti\t__P((struct cue_softc *));\nStatic void;\ncue_reset\t\t__P((struct cue_softc *));\nStatic int;\ncue_csr_read_1\t__P((struct cue_softc *, int));\nStatic int;\ncue_csr_write_1\t__P((struct cue_softc *, int, int));\nStatic int;\ncue_csr_read_2\t__P((struct cue_softc *, int));\nStatic int;\ncue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));\nStatic int;\ncue_getmac\t\t__P((struct cue_softc *, void *));\n\nStatic void\ncue_reset(sc)\n\tstruct cue_softc\t*sc;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tint\t\t\ts;\n\n\tDPRINTFN(2,(\"%s: cue_reset\\n\", USBDEVNAME(sc->cue_dev)));\n\n\tif (sc->cue_dying)\n\t\treturn;\n\n\treq.bmRequestType = UT_WRITE_VENDOR_DEVICE;\n\treq.bRequest = CUE_CMD_RESET;\n\tUSETW(req.wValue, 0);\n\tUSETW(req.wIndex, 0);\n\tUSETW(req.wLength, 0);\n\n\ts = splusb();\n\terr = CUE_DO_REQUEST(sc->cue_udev, &req, NULL);\n\tsplx(s);\n\n\tif (err)\n\t\tprintf(\"%s: reset failed\\n\", USBDEVNAME(sc->cue_dev));\n\n\t/* Wait a little while for the chip to get its brains in order. */\n\tdelay(1000);\t\t/* XXX */\n}"
  },
  {
    "function_name": "cue_setmulti",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_cue.c",
    "lines": "475-546",
    "snippet": "Static void\ncue_setmulti(sc)\n\tstruct cue_softc\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n#if defined(__FreeBSD__)\n\tstruct ifmultiaddr\t*ifma;\n#elif defined(__NetBSD__) || defined(__OpenBSD__)\n\tstruct ether_multi\t*enm;\n\tstruct ether_multistep\tstep;\n#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */\n\tu_int32_t\t\th, i;\n\n\tifp = GET_IFP(sc);\n\n\tDPRINTFN(2,(\"%s: cue_setmulti if_flags=0x%x\\n\", \n\t\t    USBDEVNAME(sc->cue_dev), ifp->if_flags));\n\n\tif (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {\n\t\tfor (i = 0; i < CUE_MCAST_TABLE_LEN; i++)\n\t\t\tsc->cue_mctab[i] = 0xFF;\n\t\tcue_mem(sc, CUE_CMD_WRITESRAM, CUE_MCAST_TABLE_ADDR,\n\t\t    &sc->cue_mctab, CUE_MCAST_TABLE_LEN);\n\t\treturn;\n\t}\n\n\t/* first, zot all the existing hash bits */\n\tfor (i = 0; i < CUE_MCAST_TABLE_LEN; i++)\n\t\tsc->cue_mctab[i] = 0;\n\n\t/* now program new ones */\n#if defined(__FreeBSD__)\n\tfor (ifma = ifp->if_multiaddrs.lh_first; ifma != NULL;\n\t    ifma = ifma->ifma_link.le_next) {\n\t\tif (ifma->ifma_addr->sa_family != AF_LINK)\n\t\t\tcontinue;\n\t\th = cue_crc(LLADDR((struct sockaddr_dl *)ifma->ifma_addr));\n\t\tsc->cue_mctab[h >> 3] |= 1 << (h & 0x7);\t\t\n\t}\n#elif defined(__NetBSD__) || defined(__OpenBSD__)\n#if defined(__NetBSD__)\n\tETHER_FIRST_MULTI(step, &sc->cue_ec, enm);\n#else\n\tETHER_FIRST_MULTI(step, &sc->arpcom, enm);\n#endif\n\twhile (enm != NULL) {\n#if 0\n\t\tif (memcmp(enm->enm_addrlo,\n\t\t\t   enm->enm_addrhi, ETHER_ADDR_LEN) != 0) {\n\t\t\tifp->if_flags |= IFF_ALLMULTI;\n\t\t\t/* XXX what now? */\n\t\t\treturn;\n\t\t}\n#endif\n\t\th = cue_crc(enm->enm_addrlo);\n\t\tsc->cue_mctab[h >> 3] |= 1 << (h & 0x7);\t\t\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */\n\n\t/*\n\t * Also include the broadcast address in the filter\n\t * so we can receive broadcast frames.\n\t */\n\tif (ifp->if_flags & IFF_BROADCAST) {\n\t\th = cue_crc(etherbroadcastaddr);\n\t\tsc->cue_mctab[h >> 3] |= 1 << (h & 0x7);\t\t\n\t}\n\n\tcue_mem(sc, CUE_CMD_WRITESRAM, CUE_MCAST_TABLE_ADDR,\n\t    &sc->cue_mctab, CUE_MCAST_TABLE_LEN);\n}",
    "includes": [
      "#include <dev/usb/if_cuereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "cue_open_pipes\t__P((struct cue_softc *));",
      "Static int",
      "cue_tx_list_init\t__P((struct cue_softc *));",
      "Static int",
      "cue_rx_list_init\t__P((struct cue_softc *));",
      "Static int",
      "Static int",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "cue_start\t\t__P((struct ifnet *));",
      "Static int",
      "Static void",
      "Static void",
      "cue_stop\t\t__P((struct cue_softc *));",
      "Static void",
      "cue_watchdog\t\t__P((struct ifnet *));",
      "Static void",
      "cue_setmulti\t__P((struct cue_softc *));",
      "Static u_int32_t",
      "Static void",
      "cue_reset\t\t__P((struct cue_softc *));",
      "Static int",
      "cue_csr_read_1\t__P((struct cue_softc *, int));",
      "Static int",
      "cue_csr_write_1\t__P((struct cue_softc *, int, int));",
      "Static int",
      "cue_csr_read_2\t__P((struct cue_softc *, int));",
      "Static int",
      "cue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));",
      "Static int",
      "cue_getmac\t\t__P((struct cue_softc *, void *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cue_mem",
          "args": [
            "sc",
            "CUE_CMD_WRITESRAM",
            "CUE_MCAST_TABLE_ADDR",
            "&sc->cue_mctab",
            "CUE_MCAST_TABLE_LEN"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "cue_mem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_cue.c",
          "lines": "389-424",
          "snippet": "Static int\ncue_mem(sc, cmd, addr, buf, len)\n\tstruct cue_softc\t*sc;\n\tint\t\t\tcmd;\n\tint\t\t\taddr;\n\tvoid\t\t\t*buf;\n\tint\t\t\tlen;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tint\t\t\ts;\n\n\tDPRINTFN(10,(\"%s: cue_mem cmd=0x%x addr=0x%x len=%d\\n\",\n\t\t     USBDEVNAME(sc->cue_dev), cmd, addr, len));\n\n\tif (cmd == CUE_CMD_READSRAM)\n\t\treq.bmRequestType = UT_READ_VENDOR_DEVICE;\n\telse\n\t\treq.bmRequestType = UT_WRITE_VENDOR_DEVICE;\n\treq.bRequest = cmd;\n\tUSETW(req.wValue, 0);\n\tUSETW(req.wIndex, addr);\n\tUSETW(req.wLength, len);\n\n\ts = splusb();\n\terr = CUE_DO_REQUEST(sc->cue_udev, &req, buf);\n\tsplx(s);\n\n\tif (err) {\n\t\tDPRINTF((\"%s: cue_csr_mem: addr=0x%x err=%s\\n\",\n\t\t\t USBDEVNAME(sc->cue_dev), addr, usbd_errstr(err)));\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/usb/if_cuereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "cue_open_pipes\t__P((struct cue_softc *));",
            "Static int",
            "cue_tx_list_init\t__P((struct cue_softc *));",
            "Static int",
            "cue_rx_list_init\t__P((struct cue_softc *));",
            "Static int",
            "Static int",
            "Static void",
            "cue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "cue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "cue_stop\t\t__P((struct cue_softc *));",
            "Static void",
            "Static void",
            "cue_setmulti\t__P((struct cue_softc *));",
            "Static void",
            "cue_reset\t\t__P((struct cue_softc *));",
            "Static int",
            "cue_csr_read_1\t__P((struct cue_softc *, int));",
            "Static int",
            "cue_csr_write_1\t__P((struct cue_softc *, int, int));",
            "Static int",
            "cue_csr_read_2\t__P((struct cue_softc *, int));",
            "Static int",
            "cue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));",
            "Static int",
            "cue_getmac\t\t__P((struct cue_softc *, void *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/if_cuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\ncue_open_pipes\t__P((struct cue_softc *));\nStatic int;\ncue_tx_list_init\t__P((struct cue_softc *));\nStatic int;\ncue_rx_list_init\t__P((struct cue_softc *));\nStatic int;\nStatic int;\nStatic void;\ncue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\ncue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\ncue_stop\t\t__P((struct cue_softc *));\nStatic void;\nStatic void;\ncue_setmulti\t__P((struct cue_softc *));\nStatic void;\ncue_reset\t\t__P((struct cue_softc *));\nStatic int;\ncue_csr_read_1\t__P((struct cue_softc *, int));\nStatic int;\ncue_csr_write_1\t__P((struct cue_softc *, int, int));\nStatic int;\ncue_csr_read_2\t__P((struct cue_softc *, int));\nStatic int;\ncue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));\nStatic int;\ncue_getmac\t\t__P((struct cue_softc *, void *));\n\nStatic int\ncue_mem(sc, cmd, addr, buf, len)\n\tstruct cue_softc\t*sc;\n\tint\t\t\tcmd;\n\tint\t\t\taddr;\n\tvoid\t\t\t*buf;\n\tint\t\t\tlen;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tint\t\t\ts;\n\n\tDPRINTFN(10,(\"%s: cue_mem cmd=0x%x addr=0x%x len=%d\\n\",\n\t\t     USBDEVNAME(sc->cue_dev), cmd, addr, len));\n\n\tif (cmd == CUE_CMD_READSRAM)\n\t\treq.bmRequestType = UT_READ_VENDOR_DEVICE;\n\telse\n\t\treq.bmRequestType = UT_WRITE_VENDOR_DEVICE;\n\treq.bRequest = cmd;\n\tUSETW(req.wValue, 0);\n\tUSETW(req.wIndex, addr);\n\tUSETW(req.wLength, len);\n\n\ts = splusb();\n\terr = CUE_DO_REQUEST(sc->cue_udev, &req, buf);\n\tsplx(s);\n\n\tif (err) {\n\t\tDPRINTF((\"%s: cue_csr_mem: addr=0x%x err=%s\\n\",\n\t\t\t USBDEVNAME(sc->cue_dev), addr, usbd_errstr(err)));\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cue_crc",
          "args": [
            "etherbroadcastaddr"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "cue_crc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_cue.c",
          "lines": "458-473",
          "snippet": "Static u_int32_t\ncue_crc(addr)\n\tcaddr_t\t\t\taddr;\n{\n\tu_int32_t\t\tidx, bit, data, crc;\n\n\t/* Compute CRC for the address value. */\n\tcrc = 0xFFFFFFFF; /* initial value */\n\n\tfor (idx = 0; idx < 6; idx++) {\n\t\tfor (data = *addr++, bit = 0; bit < 8; bit++, data >>= 1)\n\t\t\tcrc = (crc >> 1) ^ (((crc ^ data) & 1) ? CUE_POLY : 0);\n\t}\n\n\treturn (crc & ((1 << CUE_BITS) - 1));\n}",
          "includes": [
            "#include <dev/usb/if_cuereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define CUE_BITS\t9",
            "#define CUE_POLY\t0xEDB88320"
          ],
          "globals_used": [
            "Static int",
            "Static int",
            "Static int",
            "Static int",
            "Static int",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static int",
            "cue_ioctl\t\t__P((struct ifnet *, u_long, caddr_t));",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static u_int32_t",
            "cue_crc\t__P((caddr_t));",
            "Static void",
            "Static int",
            "Static int",
            "Static int",
            "Static int",
            "Static int"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/if_cuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\n#define CUE_BITS\t9\n#define CUE_POLY\t0xEDB88320\n\nStatic int;\nStatic int;\nStatic int;\nStatic int;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\ncue_ioctl\t\t__P((struct ifnet *, u_long, caddr_t));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic u_int32_t;\ncue_crc\t__P((caddr_t));\nStatic void;\nStatic int;\nStatic int;\nStatic int;\nStatic int;\nStatic int;\n\nStatic u_int32_t\ncue_crc(addr)\n\tcaddr_t\t\t\taddr;\n{\n\tu_int32_t\t\tidx, bit, data, crc;\n\n\t/* Compute CRC for the address value. */\n\tcrc = 0xFFFFFFFF; /* initial value */\n\n\tfor (idx = 0; idx < 6; idx++) {\n\t\tfor (data = *addr++, bit = 0; bit < 8; bit++, data >>= 1)\n\t\t\tcrc = (crc >> 1) ^ (((crc ^ data) & 1) ? CUE_POLY : 0);\n\t}\n\n\treturn (crc & ((1 << CUE_BITS) - 1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ETHER_NEXT_MULTI",
          "args": [
            "step",
            "enm"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "enm->enm_addrlo",
            "enm->enm_addrhi",
            "ETHER_ADDR_LEN"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ETHER_FIRST_MULTI",
          "args": [
            "step",
            "&sc->arpcom",
            "enm"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ETHER_FIRST_MULTI",
          "args": [
            "step",
            "&sc->cue_ec",
            "enm"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LLADDR",
          "args": [
            "(struct sockaddr_dl *)ifma->ifma_addr"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "2",
            "(\"%s: cue_setmulti if_flags=0x%x\\n\", \n\t\t    USBDEVNAME(sc->cue_dev), ifp->if_flags)"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->cue_dev"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_IFP",
          "args": [
            "sc"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/if_cuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\ncue_open_pipes\t__P((struct cue_softc *));\nStatic int;\ncue_tx_list_init\t__P((struct cue_softc *));\nStatic int;\ncue_rx_list_init\t__P((struct cue_softc *));\nStatic int;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\ncue_start\t\t__P((struct ifnet *));\nStatic int;\nStatic void;\nStatic void;\ncue_stop\t\t__P((struct cue_softc *));\nStatic void;\ncue_watchdog\t\t__P((struct ifnet *));\nStatic void;\ncue_setmulti\t__P((struct cue_softc *));\nStatic u_int32_t;\nStatic void;\ncue_reset\t\t__P((struct cue_softc *));\nStatic int;\ncue_csr_read_1\t__P((struct cue_softc *, int));\nStatic int;\ncue_csr_write_1\t__P((struct cue_softc *, int, int));\nStatic int;\ncue_csr_read_2\t__P((struct cue_softc *, int));\nStatic int;\ncue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));\nStatic int;\ncue_getmac\t\t__P((struct cue_softc *, void *));\n\nStatic void\ncue_setmulti(sc)\n\tstruct cue_softc\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n#if defined(__FreeBSD__)\n\tstruct ifmultiaddr\t*ifma;\n#elif defined(__NetBSD__) || defined(__OpenBSD__)\n\tstruct ether_multi\t*enm;\n\tstruct ether_multistep\tstep;\n#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */\n\tu_int32_t\t\th, i;\n\n\tifp = GET_IFP(sc);\n\n\tDPRINTFN(2,(\"%s: cue_setmulti if_flags=0x%x\\n\", \n\t\t    USBDEVNAME(sc->cue_dev), ifp->if_flags));\n\n\tif (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {\n\t\tfor (i = 0; i < CUE_MCAST_TABLE_LEN; i++)\n\t\t\tsc->cue_mctab[i] = 0xFF;\n\t\tcue_mem(sc, CUE_CMD_WRITESRAM, CUE_MCAST_TABLE_ADDR,\n\t\t    &sc->cue_mctab, CUE_MCAST_TABLE_LEN);\n\t\treturn;\n\t}\n\n\t/* first, zot all the existing hash bits */\n\tfor (i = 0; i < CUE_MCAST_TABLE_LEN; i++)\n\t\tsc->cue_mctab[i] = 0;\n\n\t/* now program new ones */\n#if defined(__FreeBSD__)\n\tfor (ifma = ifp->if_multiaddrs.lh_first; ifma != NULL;\n\t    ifma = ifma->ifma_link.le_next) {\n\t\tif (ifma->ifma_addr->sa_family != AF_LINK)\n\t\t\tcontinue;\n\t\th = cue_crc(LLADDR((struct sockaddr_dl *)ifma->ifma_addr));\n\t\tsc->cue_mctab[h >> 3] |= 1 << (h & 0x7);\t\t\n\t}\n#elif defined(__NetBSD__) || defined(__OpenBSD__)\n#if defined(__NetBSD__)\n\tETHER_FIRST_MULTI(step, &sc->cue_ec, enm);\n#else\n\tETHER_FIRST_MULTI(step, &sc->arpcom, enm);\n#endif\n\twhile (enm != NULL) {\n#if 0\n\t\tif (memcmp(enm->enm_addrlo,\n\t\t\t   enm->enm_addrhi, ETHER_ADDR_LEN) != 0) {\n\t\t\tifp->if_flags |= IFF_ALLMULTI;\n\t\t\t/* XXX what now? */\n\t\t\treturn;\n\t\t}\n#endif\n\t\th = cue_crc(enm->enm_addrlo);\n\t\tsc->cue_mctab[h >> 3] |= 1 << (h & 0x7);\t\t\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */\n\n\t/*\n\t * Also include the broadcast address in the filter\n\t * so we can receive broadcast frames.\n\t */\n\tif (ifp->if_flags & IFF_BROADCAST) {\n\t\th = cue_crc(etherbroadcastaddr);\n\t\tsc->cue_mctab[h >> 3] |= 1 << (h & 0x7);\t\t\n\t}\n\n\tcue_mem(sc, CUE_CMD_WRITESRAM, CUE_MCAST_TABLE_ADDR,\n\t    &sc->cue_mctab, CUE_MCAST_TABLE_LEN);\n}"
  },
  {
    "function_name": "cue_crc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_cue.c",
    "lines": "458-473",
    "snippet": "Static u_int32_t\ncue_crc(addr)\n\tcaddr_t\t\t\taddr;\n{\n\tu_int32_t\t\tidx, bit, data, crc;\n\n\t/* Compute CRC for the address value. */\n\tcrc = 0xFFFFFFFF; /* initial value */\n\n\tfor (idx = 0; idx < 6; idx++) {\n\t\tfor (data = *addr++, bit = 0; bit < 8; bit++, data >>= 1)\n\t\t\tcrc = (crc >> 1) ^ (((crc ^ data) & 1) ? CUE_POLY : 0);\n\t}\n\n\treturn (crc & ((1 << CUE_BITS) - 1));\n}",
    "includes": [
      "#include <dev/usb/if_cuereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [
      "#define CUE_BITS\t9",
      "#define CUE_POLY\t0xEDB88320"
    ],
    "globals_used": [
      "Static int",
      "Static int",
      "Static int",
      "Static int",
      "Static int",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static int",
      "cue_ioctl\t\t__P((struct ifnet *, u_long, caddr_t));",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static u_int32_t",
      "cue_crc\t__P((caddr_t));",
      "Static void",
      "Static int",
      "Static int",
      "Static int",
      "Static int",
      "Static int"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/usb/if_cuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\n#define CUE_BITS\t9\n#define CUE_POLY\t0xEDB88320\n\nStatic int;\nStatic int;\nStatic int;\nStatic int;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\ncue_ioctl\t\t__P((struct ifnet *, u_long, caddr_t));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic u_int32_t;\ncue_crc\t__P((caddr_t));\nStatic void;\nStatic int;\nStatic int;\nStatic int;\nStatic int;\nStatic int;\n\nStatic u_int32_t\ncue_crc(addr)\n\tcaddr_t\t\t\taddr;\n{\n\tu_int32_t\t\tidx, bit, data, crc;\n\n\t/* Compute CRC for the address value. */\n\tcrc = 0xFFFFFFFF; /* initial value */\n\n\tfor (idx = 0; idx < 6; idx++) {\n\t\tfor (data = *addr++, bit = 0; bit < 8; bit++, data >>= 1)\n\t\t\tcrc = (crc >> 1) ^ (((crc ^ data) & 1) ? CUE_POLY : 0);\n\t}\n\n\treturn (crc & ((1 << CUE_BITS) - 1));\n}"
  },
  {
    "function_name": "cue_getmac",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_cue.c",
    "lines": "426-453",
    "snippet": "Static int\ncue_getmac(sc, buf)\n\tstruct cue_softc\t*sc;\n\tvoid\t\t\t*buf;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tint\t\t\ts;\n\n\tDPRINTFN(10,(\"%s: cue_getmac\\n\", USBDEVNAME(sc->cue_dev)));\n\n\treq.bmRequestType = UT_READ_VENDOR_DEVICE;\n\treq.bRequest = CUE_CMD_GET_MACADDR;\n\tUSETW(req.wValue, 0);\n\tUSETW(req.wIndex, 0);\n\tUSETW(req.wLength, ETHER_ADDR_LEN);\n\n\ts = splusb();\n\terr = CUE_DO_REQUEST(sc->cue_udev, &req, buf);\n\tsplx(s);\n\n\tif (err) {\n\t\tprintf(\"%s: read MAC address failed\\n\", USBDEVNAME(sc->cue_dev));\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/usb/if_cuereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "cue_open_pipes\t__P((struct cue_softc *));",
      "Static int",
      "cue_tx_list_init\t__P((struct cue_softc *));",
      "Static int",
      "cue_rx_list_init\t__P((struct cue_softc *));",
      "Static int",
      "Static int",
      "Static void",
      "cue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "cue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "cue_stop\t\t__P((struct cue_softc *));",
      "Static void",
      "Static void",
      "cue_setmulti\t__P((struct cue_softc *));",
      "Static void",
      "cue_reset\t\t__P((struct cue_softc *));",
      "Static int",
      "cue_csr_read_1\t__P((struct cue_softc *, int));",
      "Static int",
      "cue_csr_write_1\t__P((struct cue_softc *, int, int));",
      "Static int",
      "cue_csr_read_2\t__P((struct cue_softc *, int));",
      "Static int",
      "cue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));",
      "Static int",
      "cue_getmac\t\t__P((struct cue_softc *, void *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: read MAC address failed\\n\"",
            "USBDEVNAME(sc->cue_dev)"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->cue_dev"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CUE_DO_REQUEST",
          "args": [
            "sc->cue_udev",
            "&req",
            "buf"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wLength",
            "ETHER_ADDR_LEN"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wIndex",
            "0"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wValue",
            "0"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "10",
            "(\"%s: cue_getmac\\n\", USBDEVNAME(sc->cue_dev))"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->cue_dev"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/if_cuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\ncue_open_pipes\t__P((struct cue_softc *));\nStatic int;\ncue_tx_list_init\t__P((struct cue_softc *));\nStatic int;\ncue_rx_list_init\t__P((struct cue_softc *));\nStatic int;\nStatic int;\nStatic void;\ncue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\ncue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\ncue_stop\t\t__P((struct cue_softc *));\nStatic void;\nStatic void;\ncue_setmulti\t__P((struct cue_softc *));\nStatic void;\ncue_reset\t\t__P((struct cue_softc *));\nStatic int;\ncue_csr_read_1\t__P((struct cue_softc *, int));\nStatic int;\ncue_csr_write_1\t__P((struct cue_softc *, int, int));\nStatic int;\ncue_csr_read_2\t__P((struct cue_softc *, int));\nStatic int;\ncue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));\nStatic int;\ncue_getmac\t\t__P((struct cue_softc *, void *));\n\nStatic int\ncue_getmac(sc, buf)\n\tstruct cue_softc\t*sc;\n\tvoid\t\t\t*buf;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tint\t\t\ts;\n\n\tDPRINTFN(10,(\"%s: cue_getmac\\n\", USBDEVNAME(sc->cue_dev)));\n\n\treq.bmRequestType = UT_READ_VENDOR_DEVICE;\n\treq.bRequest = CUE_CMD_GET_MACADDR;\n\tUSETW(req.wValue, 0);\n\tUSETW(req.wIndex, 0);\n\tUSETW(req.wLength, ETHER_ADDR_LEN);\n\n\ts = splusb();\n\terr = CUE_DO_REQUEST(sc->cue_udev, &req, buf);\n\tsplx(s);\n\n\tif (err) {\n\t\tprintf(\"%s: read MAC address failed\\n\", USBDEVNAME(sc->cue_dev));\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}"
  },
  {
    "function_name": "cue_mem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_cue.c",
    "lines": "389-424",
    "snippet": "Static int\ncue_mem(sc, cmd, addr, buf, len)\n\tstruct cue_softc\t*sc;\n\tint\t\t\tcmd;\n\tint\t\t\taddr;\n\tvoid\t\t\t*buf;\n\tint\t\t\tlen;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tint\t\t\ts;\n\n\tDPRINTFN(10,(\"%s: cue_mem cmd=0x%x addr=0x%x len=%d\\n\",\n\t\t     USBDEVNAME(sc->cue_dev), cmd, addr, len));\n\n\tif (cmd == CUE_CMD_READSRAM)\n\t\treq.bmRequestType = UT_READ_VENDOR_DEVICE;\n\telse\n\t\treq.bmRequestType = UT_WRITE_VENDOR_DEVICE;\n\treq.bRequest = cmd;\n\tUSETW(req.wValue, 0);\n\tUSETW(req.wIndex, addr);\n\tUSETW(req.wLength, len);\n\n\ts = splusb();\n\terr = CUE_DO_REQUEST(sc->cue_udev, &req, buf);\n\tsplx(s);\n\n\tif (err) {\n\t\tDPRINTF((\"%s: cue_csr_mem: addr=0x%x err=%s\\n\",\n\t\t\t USBDEVNAME(sc->cue_dev), addr, usbd_errstr(err)));\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/usb/if_cuereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "cue_open_pipes\t__P((struct cue_softc *));",
      "Static int",
      "cue_tx_list_init\t__P((struct cue_softc *));",
      "Static int",
      "cue_rx_list_init\t__P((struct cue_softc *));",
      "Static int",
      "Static int",
      "Static void",
      "cue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "cue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "cue_stop\t\t__P((struct cue_softc *));",
      "Static void",
      "Static void",
      "cue_setmulti\t__P((struct cue_softc *));",
      "Static void",
      "cue_reset\t\t__P((struct cue_softc *));",
      "Static int",
      "cue_csr_read_1\t__P((struct cue_softc *, int));",
      "Static int",
      "cue_csr_write_1\t__P((struct cue_softc *, int, int));",
      "Static int",
      "cue_csr_read_2\t__P((struct cue_softc *, int));",
      "Static int",
      "cue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));",
      "Static int",
      "cue_getmac\t\t__P((struct cue_softc *, void *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: cue_csr_mem: addr=0x%x err=%s\\n\",\n\t\t\t USBDEVNAME(sc->cue_dev), addr, usbd_errstr(err))"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->cue_dev"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CUE_DO_REQUEST",
          "args": [
            "sc->cue_udev",
            "&req",
            "buf"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wLength",
            "len"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wIndex",
            "addr"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wValue",
            "0"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "10",
            "(\"%s: cue_mem cmd=0x%x addr=0x%x len=%d\\n\",\n\t\t     USBDEVNAME(sc->cue_dev), cmd, addr, len)"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->cue_dev"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/if_cuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\ncue_open_pipes\t__P((struct cue_softc *));\nStatic int;\ncue_tx_list_init\t__P((struct cue_softc *));\nStatic int;\ncue_rx_list_init\t__P((struct cue_softc *));\nStatic int;\nStatic int;\nStatic void;\ncue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\ncue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\ncue_stop\t\t__P((struct cue_softc *));\nStatic void;\nStatic void;\ncue_setmulti\t__P((struct cue_softc *));\nStatic void;\ncue_reset\t\t__P((struct cue_softc *));\nStatic int;\ncue_csr_read_1\t__P((struct cue_softc *, int));\nStatic int;\ncue_csr_write_1\t__P((struct cue_softc *, int, int));\nStatic int;\ncue_csr_read_2\t__P((struct cue_softc *, int));\nStatic int;\ncue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));\nStatic int;\ncue_getmac\t\t__P((struct cue_softc *, void *));\n\nStatic int\ncue_mem(sc, cmd, addr, buf, len)\n\tstruct cue_softc\t*sc;\n\tint\t\t\tcmd;\n\tint\t\t\taddr;\n\tvoid\t\t\t*buf;\n\tint\t\t\tlen;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tint\t\t\ts;\n\n\tDPRINTFN(10,(\"%s: cue_mem cmd=0x%x addr=0x%x len=%d\\n\",\n\t\t     USBDEVNAME(sc->cue_dev), cmd, addr, len));\n\n\tif (cmd == CUE_CMD_READSRAM)\n\t\treq.bmRequestType = UT_READ_VENDOR_DEVICE;\n\telse\n\t\treq.bmRequestType = UT_WRITE_VENDOR_DEVICE;\n\treq.bRequest = cmd;\n\tUSETW(req.wValue, 0);\n\tUSETW(req.wIndex, addr);\n\tUSETW(req.wLength, len);\n\n\ts = splusb();\n\terr = CUE_DO_REQUEST(sc->cue_udev, &req, buf);\n\tsplx(s);\n\n\tif (err) {\n\t\tDPRINTF((\"%s: cue_csr_mem: addr=0x%x err=%s\\n\",\n\t\t\t USBDEVNAME(sc->cue_dev), addr, usbd_errstr(err)));\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}"
  },
  {
    "function_name": "cue_csr_write_2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_cue.c",
    "lines": "352-386",
    "snippet": "Static int\ncue_csr_write_2(sc, reg, val)\n\tstruct cue_softc\t*sc;\n\tint\t\t\treg, aval;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tuWord\t\t\tval;\n\tint\t\t\ts;\n\n\tif (sc->cue_dying)\n\t\treturn (0);\n\n\tDPRINTFN(10,(\"%s: cue_csr_write_2 reg=0x%x val=0x%x\\n\", \n\t\t     USBDEVNAME(sc->cue_dev), reg, aval));\n\n\tUSETW(val, aval);\n\treq.bmRequestType = UT_WRITE_VENDOR_DEVICE;\n\treq.bRequest = CUE_CMD_WRITEREG;\n\tUSETW(req.wValue, val);\n\tUSETW(req.wIndex, reg);\n\tUSETW(req.wLength, 0);\n\n\ts = splusb();\n\terr = CUE_DO_REQUEST(sc->cue_udev, &req, NULL);\n\tsplx(s);\n\n\tif (err) {\n\t\tDPRINTF((\"%s: cue_csr_write_2: reg=0x%x err=%s\\n\",\n\t\t\t USBDEVNAME(sc->cue_dev), reg, usbd_errstr(err)));\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/usb/if_cuereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "cue_open_pipes\t__P((struct cue_softc *));",
      "Static int",
      "cue_tx_list_init\t__P((struct cue_softc *));",
      "Static int",
      "cue_rx_list_init\t__P((struct cue_softc *));",
      "Static int",
      "Static int",
      "Static void",
      "cue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "cue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "cue_stop\t\t__P((struct cue_softc *));",
      "Static void",
      "Static void",
      "cue_setmulti\t__P((struct cue_softc *));",
      "Static void",
      "cue_reset\t\t__P((struct cue_softc *));",
      "Static int",
      "cue_csr_read_1\t__P((struct cue_softc *, int));",
      "Static int",
      "cue_csr_write_1\t__P((struct cue_softc *, int, int));",
      "Static int",
      "cue_csr_read_2\t__P((struct cue_softc *, int));",
      "Static int",
      "cue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));",
      "Static int",
      "cue_getmac\t\t__P((struct cue_softc *, void *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: cue_csr_write_2: reg=0x%x err=%s\\n\",\n\t\t\t USBDEVNAME(sc->cue_dev), reg, usbd_errstr(err))"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->cue_dev"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CUE_DO_REQUEST",
          "args": [
            "sc->cue_udev",
            "&req",
            "NULL"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wLength",
            "0"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wIndex",
            "reg"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wValue",
            "val"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "val",
            "aval"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "10",
            "(\"%s: cue_csr_write_2 reg=0x%x val=0x%x\\n\", \n\t\t     USBDEVNAME(sc->cue_dev), reg, aval)"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->cue_dev"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/if_cuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\ncue_open_pipes\t__P((struct cue_softc *));\nStatic int;\ncue_tx_list_init\t__P((struct cue_softc *));\nStatic int;\ncue_rx_list_init\t__P((struct cue_softc *));\nStatic int;\nStatic int;\nStatic void;\ncue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\ncue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\ncue_stop\t\t__P((struct cue_softc *));\nStatic void;\nStatic void;\ncue_setmulti\t__P((struct cue_softc *));\nStatic void;\ncue_reset\t\t__P((struct cue_softc *));\nStatic int;\ncue_csr_read_1\t__P((struct cue_softc *, int));\nStatic int;\ncue_csr_write_1\t__P((struct cue_softc *, int, int));\nStatic int;\ncue_csr_read_2\t__P((struct cue_softc *, int));\nStatic int;\ncue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));\nStatic int;\ncue_getmac\t\t__P((struct cue_softc *, void *));\n\nStatic int\ncue_csr_write_2(sc, reg, val)\n\tstruct cue_softc\t*sc;\n\tint\t\t\treg, aval;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tuWord\t\t\tval;\n\tint\t\t\ts;\n\n\tif (sc->cue_dying)\n\t\treturn (0);\n\n\tDPRINTFN(10,(\"%s: cue_csr_write_2 reg=0x%x val=0x%x\\n\", \n\t\t     USBDEVNAME(sc->cue_dev), reg, aval));\n\n\tUSETW(val, aval);\n\treq.bmRequestType = UT_WRITE_VENDOR_DEVICE;\n\treq.bRequest = CUE_CMD_WRITEREG;\n\tUSETW(req.wValue, val);\n\tUSETW(req.wIndex, reg);\n\tUSETW(req.wLength, 0);\n\n\ts = splusb();\n\terr = CUE_DO_REQUEST(sc->cue_udev, &req, NULL);\n\tsplx(s);\n\n\tif (err) {\n\t\tDPRINTF((\"%s: cue_csr_write_2: reg=0x%x err=%s\\n\",\n\t\t\t USBDEVNAME(sc->cue_dev), reg, usbd_errstr(err)));\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}"
  },
  {
    "function_name": "cue_csr_write_1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_cue.c",
    "lines": "314-349",
    "snippet": "Static int\ncue_csr_write_1(sc, reg, val)\n\tstruct cue_softc\t*sc;\n\tint\t\t\treg, val;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tint\t\t\ts;\n\n\tif (sc->cue_dying)\n\t\treturn (0);\n\n\tDPRINTFN(10,(\"%s: cue_csr_write_1 reg=0x%x val=0x%x\\n\", \n\t\t     USBDEVNAME(sc->cue_dev), reg, val));\n\n\treq.bmRequestType = UT_WRITE_VENDOR_DEVICE;\n\treq.bRequest = CUE_CMD_WRITEREG;\n\tUSETW(req.wValue, val);\n\tUSETW(req.wIndex, reg);\n\tUSETW(req.wLength, 0);\n\n\ts = splusb();\n\terr = CUE_DO_REQUEST(sc->cue_udev, &req, NULL);\n\tsplx(s);\n\n\tif (err) {\n\t\tDPRINTF((\"%s: cue_csr_write_1: reg=0x%x err=%s\\n\",\n\t\t\t USBDEVNAME(sc->cue_dev), reg, usbd_errstr(err)));\n\t\treturn (-1);\n\t}\n\n\tDPRINTFN(20,(\"%s: cue_csr_write_1, after reg=0x%x val=0x%x\\n\", \n\t\t     USBDEVNAME(sc->cue_dev), reg, cue_csr_read_1(sc, reg)));\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/usb/if_cuereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "cue_open_pipes\t__P((struct cue_softc *));",
      "Static int",
      "cue_tx_list_init\t__P((struct cue_softc *));",
      "Static int",
      "cue_rx_list_init\t__P((struct cue_softc *));",
      "Static int",
      "Static int",
      "Static void",
      "cue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "cue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "cue_stop\t\t__P((struct cue_softc *));",
      "Static void",
      "Static void",
      "cue_setmulti\t__P((struct cue_softc *));",
      "Static void",
      "cue_reset\t\t__P((struct cue_softc *));",
      "Static int",
      "cue_csr_read_1\t__P((struct cue_softc *, int));",
      "Static int",
      "cue_csr_write_1\t__P((struct cue_softc *, int, int));",
      "Static int",
      "cue_csr_read_2\t__P((struct cue_softc *, int));",
      "Static int",
      "cue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));",
      "Static int",
      "cue_getmac\t\t__P((struct cue_softc *, void *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "20",
            "(\"%s: cue_csr_write_1, after reg=0x%x val=0x%x\\n\", \n\t\t     USBDEVNAME(sc->cue_dev), reg, cue_csr_read_1(sc, reg))"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cue_csr_read_1",
          "args": [
            "sc",
            "reg"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "cue_csr_read_1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_cue.c",
          "lines": "244-277",
          "snippet": "Static int\ncue_csr_read_1(sc, reg)\n\tstruct cue_softc\t*sc;\n\tint\t\t\treg;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tu_int8_t\t\tval = 0;\n\tint\t\t\ts;\n\n\tif (sc->cue_dying)\n\t\treturn (0);\n\n\treq.bmRequestType = UT_READ_VENDOR_DEVICE;\n\treq.bRequest = CUE_CMD_READREG;\n\tUSETW(req.wValue, 0);\n\tUSETW(req.wIndex, reg);\n\tUSETW(req.wLength, 1);\n\n\ts = splusb();\n\terr = CUE_DO_REQUEST(sc->cue_udev, &req, &val);\n\tsplx(s);\n\n\tif (err) {\n\t\tDPRINTF((\"%s: cue_csr_read_1: reg=0x%x err=%s\\n\",\n\t\t\t USBDEVNAME(sc->cue_dev), reg, usbd_errstr(err)));\n\t\treturn (0);\n\t}\n\n\tDPRINTFN(10,(\"%s: cue_csr_read_1 reg=0x%x val=0x%x\\n\", \n\t\t     USBDEVNAME(sc->cue_dev), reg, val));\n\n\treturn (val);\n}",
          "includes": [
            "#include <dev/usb/if_cuereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "cue_open_pipes\t__P((struct cue_softc *));",
            "Static int",
            "cue_tx_list_init\t__P((struct cue_softc *));",
            "Static int",
            "cue_rx_list_init\t__P((struct cue_softc *));",
            "Static int",
            "Static int",
            "Static void",
            "cue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "cue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "cue_stop\t\t__P((struct cue_softc *));",
            "Static void",
            "Static void",
            "cue_setmulti\t__P((struct cue_softc *));",
            "Static void",
            "cue_reset\t\t__P((struct cue_softc *));",
            "Static int",
            "cue_csr_read_1\t__P((struct cue_softc *, int));",
            "Static int",
            "cue_csr_write_1\t__P((struct cue_softc *, int, int));",
            "Static int",
            "cue_csr_read_2\t__P((struct cue_softc *, int));",
            "Static int",
            "cue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));",
            "Static int",
            "cue_getmac\t\t__P((struct cue_softc *, void *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/if_cuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\ncue_open_pipes\t__P((struct cue_softc *));\nStatic int;\ncue_tx_list_init\t__P((struct cue_softc *));\nStatic int;\ncue_rx_list_init\t__P((struct cue_softc *));\nStatic int;\nStatic int;\nStatic void;\ncue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\ncue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\ncue_stop\t\t__P((struct cue_softc *));\nStatic void;\nStatic void;\ncue_setmulti\t__P((struct cue_softc *));\nStatic void;\ncue_reset\t\t__P((struct cue_softc *));\nStatic int;\ncue_csr_read_1\t__P((struct cue_softc *, int));\nStatic int;\ncue_csr_write_1\t__P((struct cue_softc *, int, int));\nStatic int;\ncue_csr_read_2\t__P((struct cue_softc *, int));\nStatic int;\ncue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));\nStatic int;\ncue_getmac\t\t__P((struct cue_softc *, void *));\n\nStatic int\ncue_csr_read_1(sc, reg)\n\tstruct cue_softc\t*sc;\n\tint\t\t\treg;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tu_int8_t\t\tval = 0;\n\tint\t\t\ts;\n\n\tif (sc->cue_dying)\n\t\treturn (0);\n\n\treq.bmRequestType = UT_READ_VENDOR_DEVICE;\n\treq.bRequest = CUE_CMD_READREG;\n\tUSETW(req.wValue, 0);\n\tUSETW(req.wIndex, reg);\n\tUSETW(req.wLength, 1);\n\n\ts = splusb();\n\terr = CUE_DO_REQUEST(sc->cue_udev, &req, &val);\n\tsplx(s);\n\n\tif (err) {\n\t\tDPRINTF((\"%s: cue_csr_read_1: reg=0x%x err=%s\\n\",\n\t\t\t USBDEVNAME(sc->cue_dev), reg, usbd_errstr(err)));\n\t\treturn (0);\n\t}\n\n\tDPRINTFN(10,(\"%s: cue_csr_read_1 reg=0x%x val=0x%x\\n\", \n\t\t     USBDEVNAME(sc->cue_dev), reg, val));\n\n\treturn (val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->cue_dev"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: cue_csr_write_1: reg=0x%x err=%s\\n\",\n\t\t\t USBDEVNAME(sc->cue_dev), reg, usbd_errstr(err))"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->cue_dev"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CUE_DO_REQUEST",
          "args": [
            "sc->cue_udev",
            "&req",
            "NULL"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wLength",
            "0"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wIndex",
            "reg"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wValue",
            "val"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "10",
            "(\"%s: cue_csr_write_1 reg=0x%x val=0x%x\\n\", \n\t\t     USBDEVNAME(sc->cue_dev), reg, val)"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->cue_dev"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/if_cuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\ncue_open_pipes\t__P((struct cue_softc *));\nStatic int;\ncue_tx_list_init\t__P((struct cue_softc *));\nStatic int;\ncue_rx_list_init\t__P((struct cue_softc *));\nStatic int;\nStatic int;\nStatic void;\ncue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\ncue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\ncue_stop\t\t__P((struct cue_softc *));\nStatic void;\nStatic void;\ncue_setmulti\t__P((struct cue_softc *));\nStatic void;\ncue_reset\t\t__P((struct cue_softc *));\nStatic int;\ncue_csr_read_1\t__P((struct cue_softc *, int));\nStatic int;\ncue_csr_write_1\t__P((struct cue_softc *, int, int));\nStatic int;\ncue_csr_read_2\t__P((struct cue_softc *, int));\nStatic int;\ncue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));\nStatic int;\ncue_getmac\t\t__P((struct cue_softc *, void *));\n\nStatic int\ncue_csr_write_1(sc, reg, val)\n\tstruct cue_softc\t*sc;\n\tint\t\t\treg, val;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tint\t\t\ts;\n\n\tif (sc->cue_dying)\n\t\treturn (0);\n\n\tDPRINTFN(10,(\"%s: cue_csr_write_1 reg=0x%x val=0x%x\\n\", \n\t\t     USBDEVNAME(sc->cue_dev), reg, val));\n\n\treq.bmRequestType = UT_WRITE_VENDOR_DEVICE;\n\treq.bRequest = CUE_CMD_WRITEREG;\n\tUSETW(req.wValue, val);\n\tUSETW(req.wIndex, reg);\n\tUSETW(req.wLength, 0);\n\n\ts = splusb();\n\terr = CUE_DO_REQUEST(sc->cue_udev, &req, NULL);\n\tsplx(s);\n\n\tif (err) {\n\t\tDPRINTF((\"%s: cue_csr_write_1: reg=0x%x err=%s\\n\",\n\t\t\t USBDEVNAME(sc->cue_dev), reg, usbd_errstr(err)));\n\t\treturn (-1);\n\t}\n\n\tDPRINTFN(20,(\"%s: cue_csr_write_1, after reg=0x%x val=0x%x\\n\", \n\t\t     USBDEVNAME(sc->cue_dev), reg, cue_csr_read_1(sc, reg)));\n\n\treturn (0);\n}"
  },
  {
    "function_name": "cue_csr_read_2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_cue.c",
    "lines": "279-312",
    "snippet": "Static int\ncue_csr_read_2(sc, reg)\n\tstruct cue_softc\t*sc;\n\tint\t\t\treg;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tuWord\t\t\tval;\n\tint\t\t\ts;\n\n\tif (sc->cue_dying)\n\t\treturn (0);\n\n\treq.bmRequestType = UT_READ_VENDOR_DEVICE;\n\treq.bRequest = CUE_CMD_READREG;\n\tUSETW(req.wValue, 0);\n\tUSETW(req.wIndex, reg);\n\tUSETW(req.wLength, 2);\n\n\ts = splusb();\n\terr = CUE_DO_REQUEST(sc->cue_udev, &req, &val);\n\tsplx(s);\n\n\tDPRINTFN(10,(\"%s: cue_csr_read_2 reg=0x%x val=0x%x\\n\", \n\t\t     USBDEVNAME(sc->cue_dev), reg, UGETW(val)));\n\n\tif (err) {\n\t\tDPRINTF((\"%s: cue_csr_read_2: reg=0x%x err=%s\\n\",\n\t\t\t USBDEVNAME(sc->cue_dev), reg, usbd_errstr(err)));\n\t\treturn (0);\n\t}\n\n\treturn (UGETW(val));\n}",
    "includes": [
      "#include <dev/usb/if_cuereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "cue_open_pipes\t__P((struct cue_softc *));",
      "Static int",
      "cue_tx_list_init\t__P((struct cue_softc *));",
      "Static int",
      "cue_rx_list_init\t__P((struct cue_softc *));",
      "Static int",
      "Static int",
      "Static void",
      "cue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "cue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "cue_stop\t\t__P((struct cue_softc *));",
      "Static void",
      "Static void",
      "cue_setmulti\t__P((struct cue_softc *));",
      "Static void",
      "cue_reset\t\t__P((struct cue_softc *));",
      "Static int",
      "cue_csr_read_1\t__P((struct cue_softc *, int));",
      "Static int",
      "cue_csr_write_1\t__P((struct cue_softc *, int, int));",
      "Static int",
      "cue_csr_read_2\t__P((struct cue_softc *, int));",
      "Static int",
      "cue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));",
      "Static int",
      "cue_getmac\t\t__P((struct cue_softc *, void *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "val"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: cue_csr_read_2: reg=0x%x err=%s\\n\",\n\t\t\t USBDEVNAME(sc->cue_dev), reg, usbd_errstr(err))"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->cue_dev"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "10",
            "(\"%s: cue_csr_read_2 reg=0x%x val=0x%x\\n\", \n\t\t     USBDEVNAME(sc->cue_dev), reg, UGETW(val))"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "val"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->cue_dev"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CUE_DO_REQUEST",
          "args": [
            "sc->cue_udev",
            "&req",
            "&val"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wLength",
            "2"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wIndex",
            "reg"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wValue",
            "0"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/if_cuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\ncue_open_pipes\t__P((struct cue_softc *));\nStatic int;\ncue_tx_list_init\t__P((struct cue_softc *));\nStatic int;\ncue_rx_list_init\t__P((struct cue_softc *));\nStatic int;\nStatic int;\nStatic void;\ncue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\ncue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\ncue_stop\t\t__P((struct cue_softc *));\nStatic void;\nStatic void;\ncue_setmulti\t__P((struct cue_softc *));\nStatic void;\ncue_reset\t\t__P((struct cue_softc *));\nStatic int;\ncue_csr_read_1\t__P((struct cue_softc *, int));\nStatic int;\ncue_csr_write_1\t__P((struct cue_softc *, int, int));\nStatic int;\ncue_csr_read_2\t__P((struct cue_softc *, int));\nStatic int;\ncue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));\nStatic int;\ncue_getmac\t\t__P((struct cue_softc *, void *));\n\nStatic int\ncue_csr_read_2(sc, reg)\n\tstruct cue_softc\t*sc;\n\tint\t\t\treg;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tuWord\t\t\tval;\n\tint\t\t\ts;\n\n\tif (sc->cue_dying)\n\t\treturn (0);\n\n\treq.bmRequestType = UT_READ_VENDOR_DEVICE;\n\treq.bRequest = CUE_CMD_READREG;\n\tUSETW(req.wValue, 0);\n\tUSETW(req.wIndex, reg);\n\tUSETW(req.wLength, 2);\n\n\ts = splusb();\n\terr = CUE_DO_REQUEST(sc->cue_udev, &req, &val);\n\tsplx(s);\n\n\tDPRINTFN(10,(\"%s: cue_csr_read_2 reg=0x%x val=0x%x\\n\", \n\t\t     USBDEVNAME(sc->cue_dev), reg, UGETW(val)));\n\n\tif (err) {\n\t\tDPRINTF((\"%s: cue_csr_read_2: reg=0x%x err=%s\\n\",\n\t\t\t USBDEVNAME(sc->cue_dev), reg, usbd_errstr(err)));\n\t\treturn (0);\n\t}\n\n\treturn (UGETW(val));\n}"
  },
  {
    "function_name": "cue_csr_read_1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_cue.c",
    "lines": "244-277",
    "snippet": "Static int\ncue_csr_read_1(sc, reg)\n\tstruct cue_softc\t*sc;\n\tint\t\t\treg;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tu_int8_t\t\tval = 0;\n\tint\t\t\ts;\n\n\tif (sc->cue_dying)\n\t\treturn (0);\n\n\treq.bmRequestType = UT_READ_VENDOR_DEVICE;\n\treq.bRequest = CUE_CMD_READREG;\n\tUSETW(req.wValue, 0);\n\tUSETW(req.wIndex, reg);\n\tUSETW(req.wLength, 1);\n\n\ts = splusb();\n\terr = CUE_DO_REQUEST(sc->cue_udev, &req, &val);\n\tsplx(s);\n\n\tif (err) {\n\t\tDPRINTF((\"%s: cue_csr_read_1: reg=0x%x err=%s\\n\",\n\t\t\t USBDEVNAME(sc->cue_dev), reg, usbd_errstr(err)));\n\t\treturn (0);\n\t}\n\n\tDPRINTFN(10,(\"%s: cue_csr_read_1 reg=0x%x val=0x%x\\n\", \n\t\t     USBDEVNAME(sc->cue_dev), reg, val));\n\n\treturn (val);\n}",
    "includes": [
      "#include <dev/usb/if_cuereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "cue_open_pipes\t__P((struct cue_softc *));",
      "Static int",
      "cue_tx_list_init\t__P((struct cue_softc *));",
      "Static int",
      "cue_rx_list_init\t__P((struct cue_softc *));",
      "Static int",
      "Static int",
      "Static void",
      "cue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "cue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "cue_stop\t\t__P((struct cue_softc *));",
      "Static void",
      "Static void",
      "cue_setmulti\t__P((struct cue_softc *));",
      "Static void",
      "cue_reset\t\t__P((struct cue_softc *));",
      "Static int",
      "cue_csr_read_1\t__P((struct cue_softc *, int));",
      "Static int",
      "cue_csr_write_1\t__P((struct cue_softc *, int, int));",
      "Static int",
      "cue_csr_read_2\t__P((struct cue_softc *, int));",
      "Static int",
      "cue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));",
      "Static int",
      "cue_getmac\t\t__P((struct cue_softc *, void *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "10",
            "(\"%s: cue_csr_read_1 reg=0x%x val=0x%x\\n\", \n\t\t     USBDEVNAME(sc->cue_dev), reg, val)"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->cue_dev"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: cue_csr_read_1: reg=0x%x err=%s\\n\",\n\t\t\t USBDEVNAME(sc->cue_dev), reg, usbd_errstr(err))"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->cue_dev"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CUE_DO_REQUEST",
          "args": [
            "sc->cue_udev",
            "&req",
            "&val"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wLength",
            "1"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wIndex",
            "reg"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wValue",
            "0"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/if_cuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\ncue_open_pipes\t__P((struct cue_softc *));\nStatic int;\ncue_tx_list_init\t__P((struct cue_softc *));\nStatic int;\ncue_rx_list_init\t__P((struct cue_softc *));\nStatic int;\nStatic int;\nStatic void;\ncue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\ncue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\ncue_stop\t\t__P((struct cue_softc *));\nStatic void;\nStatic void;\ncue_setmulti\t__P((struct cue_softc *));\nStatic void;\ncue_reset\t\t__P((struct cue_softc *));\nStatic int;\ncue_csr_read_1\t__P((struct cue_softc *, int));\nStatic int;\ncue_csr_write_1\t__P((struct cue_softc *, int, int));\nStatic int;\ncue_csr_read_2\t__P((struct cue_softc *, int));\nStatic int;\ncue_mem\t\t__P((struct cue_softc *, int,\n\t\t\t\t    int, void *, int));\nStatic int;\ncue_getmac\t\t__P((struct cue_softc *, void *));\n\nStatic int\ncue_csr_read_1(sc, reg)\n\tstruct cue_softc\t*sc;\n\tint\t\t\treg;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tu_int8_t\t\tval = 0;\n\tint\t\t\ts;\n\n\tif (sc->cue_dying)\n\t\treturn (0);\n\n\treq.bmRequestType = UT_READ_VENDOR_DEVICE;\n\treq.bRequest = CUE_CMD_READREG;\n\tUSETW(req.wValue, 0);\n\tUSETW(req.wIndex, reg);\n\tUSETW(req.wLength, 1);\n\n\ts = splusb();\n\terr = CUE_DO_REQUEST(sc->cue_udev, &req, &val);\n\tsplx(s);\n\n\tif (err) {\n\t\tDPRINTF((\"%s: cue_csr_read_1: reg=0x%x err=%s\\n\",\n\t\t\t USBDEVNAME(sc->cue_dev), reg, usbd_errstr(err)));\n\t\treturn (0);\n\t}\n\n\tDPRINTFN(10,(\"%s: cue_csr_read_1 reg=0x%x val=0x%x\\n\", \n\t\t     USBDEVNAME(sc->cue_dev), reg, val));\n\n\treturn (val);\n}"
  }
]