[
  {
    "function_name": "gus_isapnp_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus_isapnp.c",
    "lines": "150-172",
    "snippet": "void\ngus_isapnp_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct gus_softc *sc = (void *) self;\n\tstruct isa_attach_args *ipa = aux;\n\n\tsc->sc_iot = ipa->ia_iot;\n\tsc->sc_iobase = ipa->ia_iobase;\n\n\tsc->sc_ioh1 = ipa->ipa_io[0].h;\t\t/* p2xr */\n\tsc->sc_ioh2 = ipa->ipa_io[1].h;\t\t/* p3xr */\n\tsc->sc_ioh3 = ipa->ipa_io[2].h;\t\t/* codec/mixer */\n\tsc->sc_ioh4 = NULL;\t\t\t/* midi */\n\n\tsc->sc_irq = ipa->ipa_irq[0].num;\n\tsc->sc_drq = ipa->ipa_drq[1].num;\n\tsc->sc_recdrq = ipa->ipa_drq[0].num;\n\tsc->sc_isa = parent->dv_parent;\n\n\tgus_subattach(sc, ipa);\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tgus_isapnp_attach"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gus_subattach",
          "args": [
            "sc",
            "ipa"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "gus_subattach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "3388-3590",
          "snippet": "void\ngus_subattach(sc, ia)\n\tstruct gus_softc *sc;\n\tstruct isa_attach_args *ia;\n{\n \tint\t\ti;\n\tbus_space_tag_t iot;\n\tunsigned char\tc,d,m;\n\n\tiot = sc->sc_iot;\n\n\t/*\n\t * Figure out our board rev, and see if we need to initialize the\n\t * mixer\n\t */\n\n \tc = bus_space_read_1(iot, sc->sc_ioh3, GUS_BOARD_REV);\n\tif (c != 0xff)\n\t\tsc->sc_revision = c;\n\telse\n\t\tsc->sc_revision = 0;\n\n \tSELECT_GUS_REG(iot, sc->sc_ioh2, GUSREG_RESET);\n \tbus_space_write_1(iot, sc->sc_ioh2, GUS_DATA_HIGH, 0x00);\n\n\tgusreset(sc, GUS_MAX_VOICES); /* initialize all voices */\n\tgusreset(sc, GUS_MIN_VOICES); /* then set to just the ones we use */\n\n\t/*\n\t * Setup the IRQ and DRQ lines in software, using values from\n\t * config file\n\t */\n\n\tm = GUSMASK_LINE_IN|GUSMASK_LINE_OUT;\t\t/* disable all */\n\n\tc = ((unsigned char) gus_irq_map[ia->ia_irq]) | GUSMASK_BOTH_RQ;\n\n\tif (sc->sc_recdrq == sc->sc_drq)\n\t\td = (unsigned char) (gus_drq_map[sc->sc_drq] |\n\t\t\t\tGUSMASK_BOTH_RQ);\n\telse\n\t\td = (unsigned char) (gus_drq_map[sc->sc_drq] |\n\t\t\t\tgus_drq_map[sc->sc_recdrq] << 3);\n\n\t/*\n\t * Program the IRQ and DMA channels on the GUS.  Note that we hardwire\n\t * the GUS to only use one IRQ channel, but we give the user the\n\t * option of using two DMA channels (the other one given by the flags\n\t * option in the config file).  Two DMA channels are needed for full-\n\t * duplex operation.\n\t *\n\t * The order of these operations is very magical.\n\t */\n\n\tdisable_intr();\t\t/* XXX needed? */\n\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_REG_CONTROL, GUS_REG_IRQCTL);\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_MIX_CONTROL, m);\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_IRQCTL_CONTROL, 0x00);\n\tbus_space_write_1(iot, sc->sc_ioh1, 0x0f, 0x00);\n\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_MIX_CONTROL, m);\n\n\t/* magic reset? */\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_DMA_CONTROL, d | 0x80);\n\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_MIX_CONTROL,\n\t    m | GUSMASK_CONTROL_SEL);\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_IRQ_CONTROL, c);\n\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_MIX_CONTROL, m);\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_DMA_CONTROL, d);\n\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_MIX_CONTROL,\n\t    m | GUSMASK_CONTROL_SEL);\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_IRQ_CONTROL, c);\n\n\tbus_space_write_1(iot, sc->sc_ioh2, GUS_VOICE_SELECT, 0x00);\n\n\t/* enable line in, line out.  leave mic disabled. */\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_MIX_CONTROL,\n\t     (m | GUSMASK_LATCHES) & ~(GUSMASK_LINE_OUT|GUSMASK_LINE_IN));\n\tbus_space_write_1(iot, sc->sc_ioh2, GUS_VOICE_SELECT, 0x00);\n\n\tenable_intr();\n\n\tsc->sc_mixcontrol =\n\t\t(m | GUSMASK_LATCHES) & ~(GUSMASK_LINE_OUT|GUSMASK_LINE_IN);\n\n\tsc->sc_codec.sc_isa = sc->sc_isa;\n\n \tif (sc->sc_revision >= 5 && sc->sc_revision <= 9) {\n \t\tsc->sc_flags |= GUS_MIXER_INSTALLED;\n \t\tgus_init_ics2101(sc);\n\t}\n\tif (sc->sc_revision < 0xa || !gus_init_cs4231(sc)) {\n\t\t/* Not using the CS4231, so create our DMA maps. */\n\t\tif (sc->sc_drq != -1) {\n\t\t\tif (isa_dmamap_create(sc->sc_isa, sc->sc_drq,\n\t\t\t    MAX_ISADMA, BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW)) {\n\t\t\t\tprintf(\"%s: can't create map for drq %d\\n\",\n\t\t\t\t       sc->sc_dev.dv_xname, sc->sc_drq);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (sc->sc_recdrq != -1 && sc->sc_recdrq != sc->sc_drq) {\n\t\t\tif (isa_dmamap_create(sc->sc_isa, sc->sc_recdrq,\n\t\t\t    MAX_ISADMA, BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW)) {\n\t\t\t\tprintf(\"%s: can't create map for drq %d\\n\",\n\t\t\t\t       sc->sc_dev.dv_xname, sc->sc_recdrq);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n \tSELECT_GUS_REG(iot, sc->sc_ioh2, GUSREG_RESET);\n \t/*\n \t * Check to see how much memory we have on this card; see if any\n \t * \"mirroring\" occurs.  We're assuming at least 256K already exists\n \t * on the card; otherwise the initial probe would have failed\n \t */\n\n\tguspoke(iot, sc->sc_ioh2, 0L, 0x00);\n\tfor(i = 1; i < 1024; i++) {\n\t\tu_long loc;\n\n\t\t/*\n\t\t * See if we've run into mirroring yet\n\t\t */\n\n\t\tif (guspeek(iot, sc->sc_ioh2, 0L) != 0)\n\t\t\tbreak;\n\n\t\tloc = i << 10;\n\n\t\tguspoke(iot, sc->sc_ioh2, loc, 0xaa);\n\t\tif (guspeek(iot, sc->sc_ioh2, loc) != 0xaa)\n\t\t\tbreak;\n\t}\n\n\tsc->sc_dsize = i;\n\tsprintf(gus_device.version, \"3.%d\", sc->sc_revision);\n\n\tprintf(\": ver 3.%d, %dKB DRAM, \",\n\t       sc->sc_revision, sc->sc_dsize);\n\tif (HAS_MIXER(sc))\n\t\tprintf(\"ICS2101 mixer, \");\n\tif (HAS_CODEC(sc))\n\t\tprintf(\"%s codec/mixer, \", sc->sc_codec.chip_name);\n\tif (sc->sc_recdrq == sc->sc_drq) {\n\t\tprintf(\"half-duplex\");\n\t} else {\n\t\tprintf(\"full-duplex, record drq %d\", sc->sc_recdrq);\n\t}\n\n\tprintf(\"\\n\");\n\n\t/*\n\t * Setup a default interrupt handler\n\t */\n\n\t/* XXX we shouldn't have to use splgus == splclock, nor should\n\t * we use IPL_CLOCK.\n\t */\n\tsc->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq, IST_EDGE,\n\t    IPL_AUDIO, gusintr, sc /* sc->sc_gusdsp */, sc->sc_dev.dv_xname);\n\n\t/*\n\t * Set some default values\n\t * XXX others start with 8kHz mono mulaw\n\t */\n\n\tsc->sc_irate = sc->sc_orate = 44100;\n\tsc->sc_encoding = AUDIO_ENCODING_SLINEAR_LE;\n\tsc->sc_precision = 16;\n\tsc->sc_voc[GUS_VOICE_LEFT].voccntl |= GUSMASK_DATA_SIZE16;\n\tsc->sc_voc[GUS_VOICE_RIGHT].voccntl |= GUSMASK_DATA_SIZE16;\n\tsc->sc_channels = 1;\n\tsc->sc_ogain = 340;\n\tgus_commit_settings(sc);\n\n\t/*\n\t * We always put the left channel full left & right channel\n\t * full right.\n\t * For mono playback, we set up both voices playing the same buffer.\n\t */\n\tbus_space_write_1(iot, sc->sc_ioh2, GUS_VOICE_SELECT,\n\t    (u_char)GUS_VOICE_LEFT);\n\tSELECT_GUS_REG(iot, sc->sc_ioh2, GUSREG_PAN_POS);\n\tbus_space_write_1(iot, sc->sc_ioh2, GUS_DATA_HIGH, GUS_PAN_FULL_LEFT);\n\n\tbus_space_write_1(iot, sc->sc_ioh2, GUS_VOICE_SELECT,\n\t    (u_char)GUS_VOICE_RIGHT);\n\tSELECT_GUS_REG(iot, sc->sc_ioh2, GUSREG_PAN_POS);\n\tbus_space_write_1(iot, sc->sc_ioh2, GUS_DATA_HIGH, GUS_PAN_FULL_RIGHT);\n\n\t/*\n\t * Attach to the generic audio layer\n\t */\n\n\taudio_attach_mi(&gus_hw_if, HAS_CODEC(sc) ? (void *)&sc->sc_codec :\n\t    (void *)sc, &sc->sc_dev);\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int gus_irq_map[] = {\n\tIRQUNK, IRQUNK, 1, 3, IRQUNK, 2, IRQUNK, 4, IRQUNK, 1, IRQUNK, 5, 6,\n\tIRQUNK, IRQUNK, 7\n};",
            "int gus_drq_map[] = {\n\tDRQUNK, 1, DRQUNK, 2, DRQUNK, 3, 4, 5\n};",
            "struct audio_hw_if gus_hw_if = {\n\tgusopen,\n\tgusclose,\n\tNULL,\t\t\t\t/* drain */\n\n\tgus_query_encoding,\n\n\tgus_set_params,\n\n\tgus_round_blocksize,\n\n\tgus_commit_settings,\n\n\tNULL,\n\tNULL,\n\n\tgus_dma_output,\n\tgus_dma_input,\n\tgus_halt_out_dma,\n\tgus_halt_in_dma,\n\tgus_speaker_ctl,\n\n\tgus_getdev,\n\tNULL,\n\tgus_mixer_set_port,\n\tgus_mixer_get_port,\n\tgus_mixer_query_devinfo,\n\tad1848_malloc,\n\tad1848_free,\n\tad1848_round,\n\tad1848_mappage,\n\tgus_get_props,\n\n\tNULL,\n\tNULL\n};",
            "struct audio_device gus_device = {\n\t\"UltraSound\",\n\t\"\",\n\t\"gus\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint gus_irq_map[] = {\n\tIRQUNK, IRQUNK, 1, 3, IRQUNK, 2, IRQUNK, 4, IRQUNK, 1, IRQUNK, 5, 6,\n\tIRQUNK, IRQUNK, 7\n};\nint gus_drq_map[] = {\n\tDRQUNK, 1, DRQUNK, 2, DRQUNK, 3, 4, 5\n};\nstruct audio_hw_if gus_hw_if = {\n\tgusopen,\n\tgusclose,\n\tNULL,\t\t\t\t/* drain */\n\n\tgus_query_encoding,\n\n\tgus_set_params,\n\n\tgus_round_blocksize,\n\n\tgus_commit_settings,\n\n\tNULL,\n\tNULL,\n\n\tgus_dma_output,\n\tgus_dma_input,\n\tgus_halt_out_dma,\n\tgus_halt_in_dma,\n\tgus_speaker_ctl,\n\n\tgus_getdev,\n\tNULL,\n\tgus_mixer_set_port,\n\tgus_mixer_get_port,\n\tgus_mixer_query_devinfo,\n\tad1848_malloc,\n\tad1848_free,\n\tad1848_round,\n\tad1848_mappage,\n\tgus_get_props,\n\n\tNULL,\n\tNULL\n};\nstruct audio_device gus_device = {\n\t\"UltraSound\",\n\t\"\",\n\t\"gus\",\n};\n\nvoid\ngus_subattach(sc, ia)\n\tstruct gus_softc *sc;\n\tstruct isa_attach_args *ia;\n{\n \tint\t\ti;\n\tbus_space_tag_t iot;\n\tunsigned char\tc,d,m;\n\n\tiot = sc->sc_iot;\n\n\t/*\n\t * Figure out our board rev, and see if we need to initialize the\n\t * mixer\n\t */\n\n \tc = bus_space_read_1(iot, sc->sc_ioh3, GUS_BOARD_REV);\n\tif (c != 0xff)\n\t\tsc->sc_revision = c;\n\telse\n\t\tsc->sc_revision = 0;\n\n \tSELECT_GUS_REG(iot, sc->sc_ioh2, GUSREG_RESET);\n \tbus_space_write_1(iot, sc->sc_ioh2, GUS_DATA_HIGH, 0x00);\n\n\tgusreset(sc, GUS_MAX_VOICES); /* initialize all voices */\n\tgusreset(sc, GUS_MIN_VOICES); /* then set to just the ones we use */\n\n\t/*\n\t * Setup the IRQ and DRQ lines in software, using values from\n\t * config file\n\t */\n\n\tm = GUSMASK_LINE_IN|GUSMASK_LINE_OUT;\t\t/* disable all */\n\n\tc = ((unsigned char) gus_irq_map[ia->ia_irq]) | GUSMASK_BOTH_RQ;\n\n\tif (sc->sc_recdrq == sc->sc_drq)\n\t\td = (unsigned char) (gus_drq_map[sc->sc_drq] |\n\t\t\t\tGUSMASK_BOTH_RQ);\n\telse\n\t\td = (unsigned char) (gus_drq_map[sc->sc_drq] |\n\t\t\t\tgus_drq_map[sc->sc_recdrq] << 3);\n\n\t/*\n\t * Program the IRQ and DMA channels on the GUS.  Note that we hardwire\n\t * the GUS to only use one IRQ channel, but we give the user the\n\t * option of using two DMA channels (the other one given by the flags\n\t * option in the config file).  Two DMA channels are needed for full-\n\t * duplex operation.\n\t *\n\t * The order of these operations is very magical.\n\t */\n\n\tdisable_intr();\t\t/* XXX needed? */\n\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_REG_CONTROL, GUS_REG_IRQCTL);\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_MIX_CONTROL, m);\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_IRQCTL_CONTROL, 0x00);\n\tbus_space_write_1(iot, sc->sc_ioh1, 0x0f, 0x00);\n\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_MIX_CONTROL, m);\n\n\t/* magic reset? */\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_DMA_CONTROL, d | 0x80);\n\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_MIX_CONTROL,\n\t    m | GUSMASK_CONTROL_SEL);\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_IRQ_CONTROL, c);\n\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_MIX_CONTROL, m);\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_DMA_CONTROL, d);\n\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_MIX_CONTROL,\n\t    m | GUSMASK_CONTROL_SEL);\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_IRQ_CONTROL, c);\n\n\tbus_space_write_1(iot, sc->sc_ioh2, GUS_VOICE_SELECT, 0x00);\n\n\t/* enable line in, line out.  leave mic disabled. */\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_MIX_CONTROL,\n\t     (m | GUSMASK_LATCHES) & ~(GUSMASK_LINE_OUT|GUSMASK_LINE_IN));\n\tbus_space_write_1(iot, sc->sc_ioh2, GUS_VOICE_SELECT, 0x00);\n\n\tenable_intr();\n\n\tsc->sc_mixcontrol =\n\t\t(m | GUSMASK_LATCHES) & ~(GUSMASK_LINE_OUT|GUSMASK_LINE_IN);\n\n\tsc->sc_codec.sc_isa = sc->sc_isa;\n\n \tif (sc->sc_revision >= 5 && sc->sc_revision <= 9) {\n \t\tsc->sc_flags |= GUS_MIXER_INSTALLED;\n \t\tgus_init_ics2101(sc);\n\t}\n\tif (sc->sc_revision < 0xa || !gus_init_cs4231(sc)) {\n\t\t/* Not using the CS4231, so create our DMA maps. */\n\t\tif (sc->sc_drq != -1) {\n\t\t\tif (isa_dmamap_create(sc->sc_isa, sc->sc_drq,\n\t\t\t    MAX_ISADMA, BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW)) {\n\t\t\t\tprintf(\"%s: can't create map for drq %d\\n\",\n\t\t\t\t       sc->sc_dev.dv_xname, sc->sc_drq);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (sc->sc_recdrq != -1 && sc->sc_recdrq != sc->sc_drq) {\n\t\t\tif (isa_dmamap_create(sc->sc_isa, sc->sc_recdrq,\n\t\t\t    MAX_ISADMA, BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW)) {\n\t\t\t\tprintf(\"%s: can't create map for drq %d\\n\",\n\t\t\t\t       sc->sc_dev.dv_xname, sc->sc_recdrq);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n \tSELECT_GUS_REG(iot, sc->sc_ioh2, GUSREG_RESET);\n \t/*\n \t * Check to see how much memory we have on this card; see if any\n \t * \"mirroring\" occurs.  We're assuming at least 256K already exists\n \t * on the card; otherwise the initial probe would have failed\n \t */\n\n\tguspoke(iot, sc->sc_ioh2, 0L, 0x00);\n\tfor(i = 1; i < 1024; i++) {\n\t\tu_long loc;\n\n\t\t/*\n\t\t * See if we've run into mirroring yet\n\t\t */\n\n\t\tif (guspeek(iot, sc->sc_ioh2, 0L) != 0)\n\t\t\tbreak;\n\n\t\tloc = i << 10;\n\n\t\tguspoke(iot, sc->sc_ioh2, loc, 0xaa);\n\t\tif (guspeek(iot, sc->sc_ioh2, loc) != 0xaa)\n\t\t\tbreak;\n\t}\n\n\tsc->sc_dsize = i;\n\tsprintf(gus_device.version, \"3.%d\", sc->sc_revision);\n\n\tprintf(\": ver 3.%d, %dKB DRAM, \",\n\t       sc->sc_revision, sc->sc_dsize);\n\tif (HAS_MIXER(sc))\n\t\tprintf(\"ICS2101 mixer, \");\n\tif (HAS_CODEC(sc))\n\t\tprintf(\"%s codec/mixer, \", sc->sc_codec.chip_name);\n\tif (sc->sc_recdrq == sc->sc_drq) {\n\t\tprintf(\"half-duplex\");\n\t} else {\n\t\tprintf(\"full-duplex, record drq %d\", sc->sc_recdrq);\n\t}\n\n\tprintf(\"\\n\");\n\n\t/*\n\t * Setup a default interrupt handler\n\t */\n\n\t/* XXX we shouldn't have to use splgus == splclock, nor should\n\t * we use IPL_CLOCK.\n\t */\n\tsc->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq, IST_EDGE,\n\t    IPL_AUDIO, gusintr, sc /* sc->sc_gusdsp */, sc->sc_dev.dv_xname);\n\n\t/*\n\t * Set some default values\n\t * XXX others start with 8kHz mono mulaw\n\t */\n\n\tsc->sc_irate = sc->sc_orate = 44100;\n\tsc->sc_encoding = AUDIO_ENCODING_SLINEAR_LE;\n\tsc->sc_precision = 16;\n\tsc->sc_voc[GUS_VOICE_LEFT].voccntl |= GUSMASK_DATA_SIZE16;\n\tsc->sc_voc[GUS_VOICE_RIGHT].voccntl |= GUSMASK_DATA_SIZE16;\n\tsc->sc_channels = 1;\n\tsc->sc_ogain = 340;\n\tgus_commit_settings(sc);\n\n\t/*\n\t * We always put the left channel full left & right channel\n\t * full right.\n\t * For mono playback, we set up both voices playing the same buffer.\n\t */\n\tbus_space_write_1(iot, sc->sc_ioh2, GUS_VOICE_SELECT,\n\t    (u_char)GUS_VOICE_LEFT);\n\tSELECT_GUS_REG(iot, sc->sc_ioh2, GUSREG_PAN_POS);\n\tbus_space_write_1(iot, sc->sc_ioh2, GUS_DATA_HIGH, GUS_PAN_FULL_LEFT);\n\n\tbus_space_write_1(iot, sc->sc_ioh2, GUS_VOICE_SELECT,\n\t    (u_char)GUS_VOICE_RIGHT);\n\tSELECT_GUS_REG(iot, sc->sc_ioh2, GUSREG_PAN_POS);\n\tbus_space_write_1(iot, sc->sc_ioh2, GUS_DATA_HIGH, GUS_PAN_FULL_RIGHT);\n\n\t/*\n\t * Attach to the generic audio layer\n\t */\n\n\taudio_attach_mi(&gus_hw_if, HAS_CODEC(sc) ? (void *)&sc->sc_codec :\n\t    (void *)sc, &sc->sc_dev);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tgus_isapnp_attach;\n\nvoid\ngus_isapnp_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct gus_softc *sc = (void *) self;\n\tstruct isa_attach_args *ipa = aux;\n\n\tsc->sc_iot = ipa->ia_iot;\n\tsc->sc_iobase = ipa->ia_iobase;\n\n\tsc->sc_ioh1 = ipa->ipa_io[0].h;\t\t/* p2xr */\n\tsc->sc_ioh2 = ipa->ipa_io[1].h;\t\t/* p3xr */\n\tsc->sc_ioh3 = ipa->ipa_io[2].h;\t\t/* codec/mixer */\n\tsc->sc_ioh4 = NULL;\t\t\t/* midi */\n\n\tsc->sc_irq = ipa->ipa_irq[0].num;\n\tsc->sc_drq = ipa->ipa_drq[1].num;\n\tsc->sc_recdrq = ipa->ipa_drq[0].num;\n\tsc->sc_isa = parent->dv_parent;\n\n\tgus_subattach(sc, ipa);\n}"
  },
  {
    "function_name": "gus_isapnp_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus_isapnp.c",
    "lines": "142-148",
    "snippet": "int\ngus_isapnp_match(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\treturn 1;\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tgus_isapnp_match"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tgus_isapnp_match;\n\nint\ngus_isapnp_match(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\treturn 1;\n}"
  }
]