[
  {
    "function_name": "midiprint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/midi.c",
    "lines": "769-777",
    "snippet": "int\nmidiprint(aux, pnp)\n\tvoid *aux;\n\tconst char *pnp;\n{\n\tif (pnp)\n\t\tprintf(\"midi at %s\", pnp);\n\treturn (UNCONF);\n}",
    "includes": [
      "#include <dev/midivar.h>",
      "#include <dev/midi_if.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/midiio.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"sequencer.h\"",
      "#include \"midi.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"midi at %s\"",
            "pnp"
          ],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n#include \"midi.h\"\n\nint\nmidiprint(aux, pnp)\n\tvoid *aux;\n\tconst char *pnp;\n{\n\tif (pnp)\n\t\tprintf(\"midi at %s\", pnp);\n\treturn (UNCONF);\n}"
  },
  {
    "function_name": "midi_attach_mi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/midi.c",
    "lines": "749-767",
    "snippet": "void\nmidi_attach_mi(mhwp, hdlp, dev)\n\tstruct midi_hw_if *mhwp;\n\tvoid *hdlp;\n\tstruct device *dev;\n{\n\tstruct audio_attach_args arg;\n\n#ifdef DIAGNOSTIC\n\tif (mhwp == NULL) {\n\t\tprintf(\"midi_attach_mi: NULL\\n\");\n\t\treturn;\n\t}\n#endif\n\targ.type = AUDIODEV_TYPE_MIDI;\n\targ.hwif = mhwp;\n\targ.hdl = hdlp;\n\t(void)config_found(dev, &arg, midiprint);\n}",
    "includes": [
      "#include <dev/midivar.h>",
      "#include <dev/midi_if.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/midiio.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"sequencer.h\"",
      "#include \"midi.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "config_found",
          "args": [
            "dev",
            "&arg",
            "midiprint"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"midi_attach_mi: NULL\\n\""
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n#include \"midi.h\"\n\nvoid\nmidi_attach_mi(mhwp, hdlp, dev)\n\tstruct midi_hw_if *mhwp;\n\tvoid *hdlp;\n\tstruct device *dev;\n{\n\tstruct audio_attach_args arg;\n\n#ifdef DIAGNOSTIC\n\tif (mhwp == NULL) {\n\t\tprintf(\"midi_attach_mi: NULL\\n\");\n\t\treturn;\n\t}\n#endif\n\targ.type = AUDIODEV_TYPE_MIDI;\n\targ.hwif = mhwp;\n\targ.hdl = hdlp;\n\t(void)config_found(dev, &arg, midiprint);\n}"
  },
  {
    "function_name": "midi_getinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/midi.c",
    "lines": "729-741",
    "snippet": "void\nmidi_getinfo(dev, mi)\n\tdev_t dev;\n\tstruct midi_info *mi;\n{\n\tint unit = MIDIUNIT(dev);\n\tstruct midi_softc *sc;\n\n\tif (unit >= midi_cd.cd_ndevs ||\n\t    (sc = midi_cd.cd_devs[unit]) == NULL)\n\t\treturn;\n\tsc->hw_if->getinfo(sc->hw_hdl, mi);\n}",
    "includes": [
      "#include <dev/midivar.h>",
      "#include <dev/midi_if.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/midiio.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"sequencer.h\"",
      "#include \"midi.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sc->hw_if->getinfo",
          "args": [
            "sc->hw_hdl",
            "mi"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIDIUNIT",
          "args": [
            "dev"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n#include \"midi.h\"\n\nvoid\nmidi_getinfo(dev, mi)\n\tdev_t dev;\n\tstruct midi_info *mi;\n{\n\tint unit = MIDIUNIT(dev);\n\tstruct midi_softc *sc;\n\n\tif (unit >= midi_cd.cd_ndevs ||\n\t    (sc = midi_cd.cd_devs[unit]) == NULL)\n\t\treturn;\n\tsc->hw_if->getinfo(sc->hw_hdl, mi);\n}"
  },
  {
    "function_name": "midiselect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/midi.c",
    "lines": "695-727",
    "snippet": "int\nmidiselect(dev, rw, p)\n\tdev_t dev;\n\tint rw;\n\tstruct proc *p;\n{\n\tint unit = MIDIUNIT(dev);\n\tstruct midi_softc *sc = midi_cd.cd_devs[unit];\n\tint s = splaudio();\n\n\tDPRINTF((\"midiselect: %p rw=0x%x\\n\", sc, rw));\n\n\tswitch (rw) {\n\tcase FREAD:\n\t\tif (sc->inbuf.used > 0) {\n\t\t\tsplx(s);\n\t\t\treturn (1);\n\t\t}\n\t\tselrecord(p, &sc->rsel);\n\t\tbreak;\n\n\tcase FWRITE:\n\t\tif (sc->outbuf.used < sc->outbuf.usedhigh) {\n\t\t\tsplx(s);\n\t\t\treturn (1);\n\t\t}\n\t\tselrecord(p, &sc->wsel);\n\t\tbreak;\n\t}\n\n\tsplx(s);\n\treturn (0);\n}",
    "includes": [
      "#include <dev/midivar.h>",
      "#include <dev/midi_if.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/midiio.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"sequencer.h\"",
      "#include \"midi.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "selrecord",
          "args": [
            "p",
            "&sc->wsel"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "selrecord",
          "args": [
            "p",
            "&sc->rsel"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"midiselect: %p rw=0x%x\\n\", sc, rw)"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splaudio",
          "args": [],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIDIUNIT",
          "args": [
            "dev"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n#include \"midi.h\"\n\nint\nmidiselect(dev, rw, p)\n\tdev_t dev;\n\tint rw;\n\tstruct proc *p;\n{\n\tint unit = MIDIUNIT(dev);\n\tstruct midi_softc *sc = midi_cd.cd_devs[unit];\n\tint s = splaudio();\n\n\tDPRINTF((\"midiselect: %p rw=0x%x\\n\", sc, rw));\n\n\tswitch (rw) {\n\tcase FREAD:\n\t\tif (sc->inbuf.used > 0) {\n\t\t\tsplx(s);\n\t\t\treturn (1);\n\t\t}\n\t\tselrecord(p, &sc->rsel);\n\t\tbreak;\n\n\tcase FWRITE:\n\t\tif (sc->outbuf.used < sc->outbuf.usedhigh) {\n\t\t\tsplx(s);\n\t\t\treturn (1);\n\t\t}\n\t\tselrecord(p, &sc->wsel);\n\t\tbreak;\n\t}\n\n\tsplx(s);\n\treturn (0);\n}"
  },
  {
    "function_name": "midiioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/midi.c",
    "lines": "640-693",
    "snippet": "int\nmidiioctl(dev, cmd, addr, flag, p)\n\tdev_t dev;\n\tu_long cmd;\n\tcaddr_t addr;\n\tint flag;\n\tstruct proc *p;\n{\n\tint unit = MIDIUNIT(dev);\n\tstruct midi_softc *sc = midi_cd.cd_devs[unit];\n\tstruct midi_hw_if *hw = sc->hw_if;\n\tint error;\n\n\tDPRINTF((\"midiioctl: %p cmd=0x%08lx\\n\", sc, cmd));\n\terror = 0;\n\tswitch (cmd) {\n\tcase FIONBIO:\n\t\t/* All handled in the upper FS layer. */\n\t\tbreak;\n\n\tcase FIOASYNC:\n\t\tif (*(int *)addr) {\n\t\t\tif (sc->async)\n\t\t\t\treturn (EBUSY);\n\t\t\tsc->async = p;\n\t\t\tDPRINTF((\"midi_ioctl: FIOASYNC %p\\n\", p));\n\t\t} else\n\t\t\tsc->async = 0;\n\t\tbreak;\n\n#if 0\n\tcase MIDI_PRETIME:\n\t\t/* XXX OSS\n\t\t * This should set up a read timeout, but that's\n\t\t * why we have poll(), so there's nothing yet. */\n\t\terror = EINVAL;\n\t\tbreak;\n#endif\n\n#ifdef MIDI_SAVE\n\tcase MIDI_GETSAVE:\n\t\terror = copyout(&midisave, *(void **)addr, sizeof midisave);\n  \t\tbreak;\n#endif\n\n\tdefault:\n\t\tif (hw->ioctl)\n\t\t\terror = hw->ioctl(sc->hw_hdl, cmd, addr, flag, p);\n\t\telse\n\t\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\treturn (error);\n}",
    "includes": [
      "#include <dev/midivar.h>",
      "#include <dev/midi_if.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/midiio.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"sequencer.h\"",
      "#include \"midi.h\""
    ],
    "macros_used": [
      "#define MIDI_GETSAVE\t\t_IOWR('m', 100, int)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hw->ioctl",
          "args": [
            "sc->hw_hdl",
            "cmd",
            "addr",
            "flag",
            "p"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copyout",
          "args": [
            "&midisave",
            "*(void **)addr",
            "sizeof midisave"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "audio_silence_copyout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "1249-1268",
          "snippet": "int\naudio_silence_copyout(sc, n, uio)\n\tstruct audio_softc *sc;\n\tint n;\n\tstruct uio *uio;\n{\n\tint error;\n\tint k;\n\tu_char zerobuf[128];\n\n\taudio_fill_silence(&sc->sc_rparams, zerobuf, sizeof zerobuf);\n\n\terror = 0;\n        while (n > 0 && uio->uio_resid > 0 && !error) {\n\t\tk = min(n, min(uio->uio_resid, sizeof zerobuf));\n\t\terror = uiomove(zerobuf, k, uio);\n\t\tn -= k;\n\t}\n        return (error);\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\naudio_silence_copyout(sc, n, uio)\n\tstruct audio_softc *sc;\n\tint n;\n\tstruct uio *uio;\n{\n\tint error;\n\tint k;\n\tu_char zerobuf[128];\n\n\taudio_fill_silence(&sc->sc_rparams, zerobuf, sizeof zerobuf);\n\n\terror = 0;\n        while (n > 0 && uio->uio_resid > 0 && !error) {\n\t\tk = min(n, min(uio->uio_resid, sizeof zerobuf));\n\t\terror = uiomove(zerobuf, k, uio);\n\t\tn -= k;\n\t}\n        return (error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"midi_ioctl: FIOASYNC %p\\n\", p)"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"midiioctl: %p cmd=0x%08lx\\n\", sc, cmd)"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIDIUNIT",
          "args": [
            "dev"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n#include \"midi.h\"\n\n#define MIDI_GETSAVE\t\t_IOWR('m', 100, int)\n\nint\nmidiioctl(dev, cmd, addr, flag, p)\n\tdev_t dev;\n\tu_long cmd;\n\tcaddr_t addr;\n\tint flag;\n\tstruct proc *p;\n{\n\tint unit = MIDIUNIT(dev);\n\tstruct midi_softc *sc = midi_cd.cd_devs[unit];\n\tstruct midi_hw_if *hw = sc->hw_if;\n\tint error;\n\n\tDPRINTF((\"midiioctl: %p cmd=0x%08lx\\n\", sc, cmd));\n\terror = 0;\n\tswitch (cmd) {\n\tcase FIONBIO:\n\t\t/* All handled in the upper FS layer. */\n\t\tbreak;\n\n\tcase FIOASYNC:\n\t\tif (*(int *)addr) {\n\t\t\tif (sc->async)\n\t\t\t\treturn (EBUSY);\n\t\t\tsc->async = p;\n\t\t\tDPRINTF((\"midi_ioctl: FIOASYNC %p\\n\", p));\n\t\t} else\n\t\t\tsc->async = 0;\n\t\tbreak;\n\n#if 0\n\tcase MIDI_PRETIME:\n\t\t/* XXX OSS\n\t\t * This should set up a read timeout, but that's\n\t\t * why we have poll(), so there's nothing yet. */\n\t\terror = EINVAL;\n\t\tbreak;\n#endif\n\n#ifdef MIDI_SAVE\n\tcase MIDI_GETSAVE:\n\t\terror = copyout(&midisave, *(void **)addr, sizeof midisave);\n  \t\tbreak;\n#endif\n\n\tdefault:\n\t\tif (hw->ioctl)\n\t\t\terror = hw->ioctl(sc->hw_hdl, cmd, addr, flag, p);\n\t\telse\n\t\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\treturn (error);\n}"
  },
  {
    "function_name": "midi_writebytes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/midi.c",
    "lines": "604-638",
    "snippet": "int\nmidi_writebytes(unit, buf, cc)\n\tint unit;\n\tu_char *buf;\n\tint cc;\n{\n\tstruct midi_softc *sc = midi_cd.cd_devs[unit];\n\tstruct midi_buffer *mb = &sc->outbuf;\n\tint n, s;\n\n\tDPRINTFN(2, (\"midi_writebytes: %p, unit=%d, cc=%d\\n\", sc, unit, cc));\n\tDPRINTFN(3, (\"midi_writebytes: %x %x %x\\n\",buf[0],buf[1],buf[2]));\n\n\ts = splaudio();\n\tif (mb->used + cc >= mb->usedhigh) {\n\t\tsplx(s);\n\t\treturn (EWOULDBLOCK);\n\t}\n\tn = mb->end - mb->inp;\n\tif (cc < n)\n\t\tn = cc;\n\tmb->used += cc;\n\tbcopy(buf, mb->inp, n);\n\tmb->inp += n;\n\tif (mb->inp >= mb->end) {\n\t\tmb->inp = mb->start;\n\t\tcc -= n;\n\t\tif (cc > 0) {\n\t\t\tbcopy(buf + n, mb->inp, cc);\n\t\t\tmb->inp += cc;\n\t\t}\n\t}\n\tsplx(s);\n\treturn (midi_start_output(sc, 0));\n}",
    "includes": [
      "#include <dev/midivar.h>",
      "#include <dev/midi_if.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/midiio.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"sequencer.h\"",
      "#include \"midi.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "midi_start_output",
          "args": [
            "sc",
            "0"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "midi_start_output",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/midi.c",
          "lines": "488-535",
          "snippet": "int\nmidi_start_output(sc, intr)\n\tstruct midi_softc *sc;\n\tint intr;\n{\n\tstruct midi_buffer *mb = &sc->outbuf;\n\tu_char *outp;\n\tint error;\n\tint s;\n\tint i, mmax;\n\n\terror = 0;\n\tmmax = sc->props & MIDI_PROP_OUT_INTR ? 1 : MIDI_MAX_WRITE;\n\ts = splaudio();\n\tif (sc->pbus && !intr) {\n\t\tDPRINTFN(4, (\"midi_start_output: busy\\n\"));\n\t\tsplx(s);\n\t\treturn (0);\n\t}\n\tsc->pbus = 1;\n\tfor (i = 0; i < mmax && mb->used > 0 && !error; i++) {\n\t\toutp = mb->outp;\n\t\tsplx(s);\n\t\tDPRINTFN(4, (\"midi_start_output: %p i=%d, data=0x%02x\\n\", \n\t\t\t     sc, i, *outp));\n#ifdef MIDI_SAVE\n\t\tmidisave.buf[midicnt] = *outp;\n\t\tmidicnt = (midicnt + 1) % MIDI_SAVE_SIZE;\n#endif\n\t\terror = sc->hw_if->output(sc->hw_hdl, *outp++);\n\t\tif (outp >= mb->end)\n\t\t\toutp = mb->start;\n\t\ts = splaudio();\n\t\tmb->outp = outp;\n\t\tmb->used--;\n\t}\n\tmidi_wakeup(&sc->wchan);\n\tselwakeup(&sc->wsel);\n\tif (sc->async)\n\t\tpsignal(sc->async, SIGIO);\n\tif (mb->used > 0) {\n\t\tif (!(sc->props & MIDI_PROP_OUT_INTR))\n\t\t\ttimeout(midi_timeout, sc, midi_wait);\n\t} else\n\t\tsc->pbus = 0;\n\tsplx(s);\n\treturn (error);\n}",
          "includes": [
            "#include <dev/midivar.h>",
            "#include <dev/midi_if.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/midiio.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"sequencer.h\"",
            "#include \"midi.h\""
          ],
          "macros_used": [
            "#define MIDI_SAVE_SIZE 100000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n#include \"midi.h\"\n\n#define MIDI_SAVE_SIZE 100000\n\nint\nmidi_start_output(sc, intr)\n\tstruct midi_softc *sc;\n\tint intr;\n{\n\tstruct midi_buffer *mb = &sc->outbuf;\n\tu_char *outp;\n\tint error;\n\tint s;\n\tint i, mmax;\n\n\terror = 0;\n\tmmax = sc->props & MIDI_PROP_OUT_INTR ? 1 : MIDI_MAX_WRITE;\n\ts = splaudio();\n\tif (sc->pbus && !intr) {\n\t\tDPRINTFN(4, (\"midi_start_output: busy\\n\"));\n\t\tsplx(s);\n\t\treturn (0);\n\t}\n\tsc->pbus = 1;\n\tfor (i = 0; i < mmax && mb->used > 0 && !error; i++) {\n\t\toutp = mb->outp;\n\t\tsplx(s);\n\t\tDPRINTFN(4, (\"midi_start_output: %p i=%d, data=0x%02x\\n\", \n\t\t\t     sc, i, *outp));\n#ifdef MIDI_SAVE\n\t\tmidisave.buf[midicnt] = *outp;\n\t\tmidicnt = (midicnt + 1) % MIDI_SAVE_SIZE;\n#endif\n\t\terror = sc->hw_if->output(sc->hw_hdl, *outp++);\n\t\tif (outp >= mb->end)\n\t\t\toutp = mb->start;\n\t\ts = splaudio();\n\t\tmb->outp = outp;\n\t\tmb->used--;\n\t}\n\tmidi_wakeup(&sc->wchan);\n\tselwakeup(&sc->wsel);\n\tif (sc->async)\n\t\tpsignal(sc->async, SIGIO);\n\tif (mb->used > 0) {\n\t\tif (!(sc->props & MIDI_PROP_OUT_INTR))\n\t\t\ttimeout(midi_timeout, sc, midi_wait);\n\t} else\n\t\tsc->pbus = 0;\n\tsplx(s);\n\treturn (error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "buf + n",
            "mb->inp",
            "cc"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splaudio",
          "args": [],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "3",
            "(\"midi_writebytes: %x %x %x\\n\",buf[0],buf[1],buf[2])"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "2",
            "(\"midi_writebytes: %p, unit=%d, cc=%d\\n\", sc, unit, cc)"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n#include \"midi.h\"\n\nint\nmidi_writebytes(unit, buf, cc)\n\tint unit;\n\tu_char *buf;\n\tint cc;\n{\n\tstruct midi_softc *sc = midi_cd.cd_devs[unit];\n\tstruct midi_buffer *mb = &sc->outbuf;\n\tint n, s;\n\n\tDPRINTFN(2, (\"midi_writebytes: %p, unit=%d, cc=%d\\n\", sc, unit, cc));\n\tDPRINTFN(3, (\"midi_writebytes: %x %x %x\\n\",buf[0],buf[1],buf[2]));\n\n\ts = splaudio();\n\tif (mb->used + cc >= mb->usedhigh) {\n\t\tsplx(s);\n\t\treturn (EWOULDBLOCK);\n\t}\n\tn = mb->end - mb->inp;\n\tif (cc < n)\n\t\tn = cc;\n\tmb->used += cc;\n\tbcopy(buf, mb->inp, n);\n\tmb->inp += n;\n\tif (mb->inp >= mb->end) {\n\t\tmb->inp = mb->start;\n\t\tcc -= n;\n\t\tif (cc > 0) {\n\t\t\tbcopy(buf + n, mb->inp, cc);\n\t\t\tmb->inp += cc;\n\t\t}\n\t}\n\tsplx(s);\n\treturn (midi_start_output(sc, 0));\n}"
  },
  {
    "function_name": "midiwrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/midi.c",
    "lines": "537-598",
    "snippet": "int\nmidiwrite(dev, uio, ioflag)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint ioflag;\n{\n\tint unit = MIDIUNIT(dev);\n\tstruct midi_softc *sc = midi_cd.cd_devs[unit];\n\tstruct midi_buffer *mb = &sc->outbuf;\n\tint error;\n\tu_char *inp;\n\tint used, cc, n;\n\tint s;\n\n\tDPRINTFN(2, (\"midiwrite: %p, unit=%d, count=%d\\n\", sc, unit, \n\t\t     uio->uio_resid));\n\n\terror = 0;\n\twhile (uio->uio_resid > 0 && !error) {\n\t\ts = splaudio();\n\t\tif (mb->used >= mb->usedhigh) {\n\t\t\tDPRINTFN(3,(\"midi_write: sleep used=%d hiwat=%d\\n\", \n\t\t\t\t mb->used, mb->usedhigh));\n\t\t\tif (ioflag & IO_NDELAY) {\n\t\t\t\tsplx(s);\n\t\t\t\treturn (EWOULDBLOCK);\n\t\t\t}\n\t\t\terror = midi_sleep(&sc->wchan, \"mid wr\");\n\t\t\tif (error) {\n\t\t\t\tsplx(s);\n\t\t\t\treturn (error);\n\t\t\t}\n\t\t}\t\t\t\n\t\tused = mb->used;\n\t\tinp = mb->inp;\n\t\tsplx(s);\n\t\tcc = mb->usedhigh - used; \t/* maximum to write */\n\t\tn = mb->end - inp;\n\t\tif (n < cc)\n\t\t\tcc = n;\t\t/* don't write beyond end of buffer */\n\t\tif (uio->uio_resid < cc)\n\t\t\tcc = uio->uio_resid; \t/* and no more than we have */\n\t\terror = uiomove(inp, cc, uio);\n#ifdef MIDI_DEBUG\n\t\tif (error)\n\t\t        printf(\"midi_write:(1) uiomove failed %d; \"\n\t\t\t       \"cc=%d inp=%p\\n\",\n\t\t\t       error, cc, inp);\n#endif\n\t\tif (error)\n\t\t\tbreak;\n\t\tinp = mb->inp + cc;\n\t\tif (inp >= mb->end)\n\t\t\tinp = mb->start;\n\t\ts = splaudio();\n\t\tmb->inp = inp;\n\t\tmb->used += cc;\n\t\tsplx(s);\n\t\terror = midi_start_output(sc, 0);\n\t}\n\treturn (error);\n}",
    "includes": [
      "#include <dev/midivar.h>",
      "#include <dev/midi_if.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/midiio.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"sequencer.h\"",
      "#include \"midi.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "midi_start_output",
          "args": [
            "sc",
            "0"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "midi_start_output",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/midi.c",
          "lines": "488-535",
          "snippet": "int\nmidi_start_output(sc, intr)\n\tstruct midi_softc *sc;\n\tint intr;\n{\n\tstruct midi_buffer *mb = &sc->outbuf;\n\tu_char *outp;\n\tint error;\n\tint s;\n\tint i, mmax;\n\n\terror = 0;\n\tmmax = sc->props & MIDI_PROP_OUT_INTR ? 1 : MIDI_MAX_WRITE;\n\ts = splaudio();\n\tif (sc->pbus && !intr) {\n\t\tDPRINTFN(4, (\"midi_start_output: busy\\n\"));\n\t\tsplx(s);\n\t\treturn (0);\n\t}\n\tsc->pbus = 1;\n\tfor (i = 0; i < mmax && mb->used > 0 && !error; i++) {\n\t\toutp = mb->outp;\n\t\tsplx(s);\n\t\tDPRINTFN(4, (\"midi_start_output: %p i=%d, data=0x%02x\\n\", \n\t\t\t     sc, i, *outp));\n#ifdef MIDI_SAVE\n\t\tmidisave.buf[midicnt] = *outp;\n\t\tmidicnt = (midicnt + 1) % MIDI_SAVE_SIZE;\n#endif\n\t\terror = sc->hw_if->output(sc->hw_hdl, *outp++);\n\t\tif (outp >= mb->end)\n\t\t\toutp = mb->start;\n\t\ts = splaudio();\n\t\tmb->outp = outp;\n\t\tmb->used--;\n\t}\n\tmidi_wakeup(&sc->wchan);\n\tselwakeup(&sc->wsel);\n\tif (sc->async)\n\t\tpsignal(sc->async, SIGIO);\n\tif (mb->used > 0) {\n\t\tif (!(sc->props & MIDI_PROP_OUT_INTR))\n\t\t\ttimeout(midi_timeout, sc, midi_wait);\n\t} else\n\t\tsc->pbus = 0;\n\tsplx(s);\n\treturn (error);\n}",
          "includes": [
            "#include <dev/midivar.h>",
            "#include <dev/midi_if.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/midiio.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"sequencer.h\"",
            "#include \"midi.h\""
          ],
          "macros_used": [
            "#define MIDI_SAVE_SIZE 100000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n#include \"midi.h\"\n\n#define MIDI_SAVE_SIZE 100000\n\nint\nmidi_start_output(sc, intr)\n\tstruct midi_softc *sc;\n\tint intr;\n{\n\tstruct midi_buffer *mb = &sc->outbuf;\n\tu_char *outp;\n\tint error;\n\tint s;\n\tint i, mmax;\n\n\terror = 0;\n\tmmax = sc->props & MIDI_PROP_OUT_INTR ? 1 : MIDI_MAX_WRITE;\n\ts = splaudio();\n\tif (sc->pbus && !intr) {\n\t\tDPRINTFN(4, (\"midi_start_output: busy\\n\"));\n\t\tsplx(s);\n\t\treturn (0);\n\t}\n\tsc->pbus = 1;\n\tfor (i = 0; i < mmax && mb->used > 0 && !error; i++) {\n\t\toutp = mb->outp;\n\t\tsplx(s);\n\t\tDPRINTFN(4, (\"midi_start_output: %p i=%d, data=0x%02x\\n\", \n\t\t\t     sc, i, *outp));\n#ifdef MIDI_SAVE\n\t\tmidisave.buf[midicnt] = *outp;\n\t\tmidicnt = (midicnt + 1) % MIDI_SAVE_SIZE;\n#endif\n\t\terror = sc->hw_if->output(sc->hw_hdl, *outp++);\n\t\tif (outp >= mb->end)\n\t\t\toutp = mb->start;\n\t\ts = splaudio();\n\t\tmb->outp = outp;\n\t\tmb->used--;\n\t}\n\tmidi_wakeup(&sc->wchan);\n\tselwakeup(&sc->wsel);\n\tif (sc->async)\n\t\tpsignal(sc->async, SIGIO);\n\tif (mb->used > 0) {\n\t\tif (!(sc->props & MIDI_PROP_OUT_INTR))\n\t\t\ttimeout(midi_timeout, sc, midi_wait);\n\t} else\n\t\tsc->pbus = 0;\n\tsplx(s);\n\treturn (error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splaudio",
          "args": [],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"midi_write:(1) uiomove failed %d; \"\n\t\t\t       \"cc=%d inp=%p\\n\"",
            "error",
            "cc",
            "inp"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "uiomove",
          "args": [
            "inp",
            "cc",
            "uio"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "midi_sleep",
          "args": [
            "&sc->wchan",
            "\"mid wr\""
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "midi_sleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/midi.c",
          "lines": "214-220",
          "snippet": "int\nmidi_sleep(chan, label)\n\tint *chan;\n\tchar *label;\n{\n\treturn (midi_sleep_timo(chan, label, 0));\n}",
          "includes": [
            "#include <dev/midivar.h>",
            "#include <dev/midi_if.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/midiio.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"sequencer.h\"",
            "#include \"midi.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n#include \"midi.h\"\n\nint\nmidi_sleep(chan, label)\n\tint *chan;\n\tchar *label;\n{\n\treturn (midi_sleep_timo(chan, label, 0));\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "3",
            "(\"midi_write: sleep used=%d hiwat=%d\\n\", \n\t\t\t\t mb->used, mb->usedhigh)"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splaudio",
          "args": [],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "2",
            "(\"midiwrite: %p, unit=%d, count=%d\\n\", sc, unit, \n\t\t     uio->uio_resid)"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIDIUNIT",
          "args": [
            "dev"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n#include \"midi.h\"\n\nint\nmidiwrite(dev, uio, ioflag)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint ioflag;\n{\n\tint unit = MIDIUNIT(dev);\n\tstruct midi_softc *sc = midi_cd.cd_devs[unit];\n\tstruct midi_buffer *mb = &sc->outbuf;\n\tint error;\n\tu_char *inp;\n\tint used, cc, n;\n\tint s;\n\n\tDPRINTFN(2, (\"midiwrite: %p, unit=%d, count=%d\\n\", sc, unit, \n\t\t     uio->uio_resid));\n\n\terror = 0;\n\twhile (uio->uio_resid > 0 && !error) {\n\t\ts = splaudio();\n\t\tif (mb->used >= mb->usedhigh) {\n\t\t\tDPRINTFN(3,(\"midi_write: sleep used=%d hiwat=%d\\n\", \n\t\t\t\t mb->used, mb->usedhigh));\n\t\t\tif (ioflag & IO_NDELAY) {\n\t\t\t\tsplx(s);\n\t\t\t\treturn (EWOULDBLOCK);\n\t\t\t}\n\t\t\terror = midi_sleep(&sc->wchan, \"mid wr\");\n\t\t\tif (error) {\n\t\t\t\tsplx(s);\n\t\t\t\treturn (error);\n\t\t\t}\n\t\t}\t\t\t\n\t\tused = mb->used;\n\t\tinp = mb->inp;\n\t\tsplx(s);\n\t\tcc = mb->usedhigh - used; \t/* maximum to write */\n\t\tn = mb->end - inp;\n\t\tif (n < cc)\n\t\t\tcc = n;\t\t/* don't write beyond end of buffer */\n\t\tif (uio->uio_resid < cc)\n\t\t\tcc = uio->uio_resid; \t/* and no more than we have */\n\t\terror = uiomove(inp, cc, uio);\n#ifdef MIDI_DEBUG\n\t\tif (error)\n\t\t        printf(\"midi_write:(1) uiomove failed %d; \"\n\t\t\t       \"cc=%d inp=%p\\n\",\n\t\t\t       error, cc, inp);\n#endif\n\t\tif (error)\n\t\t\tbreak;\n\t\tinp = mb->inp + cc;\n\t\tif (inp >= mb->end)\n\t\t\tinp = mb->start;\n\t\ts = splaudio();\n\t\tmb->inp = inp;\n\t\tmb->used += cc;\n\t\tsplx(s);\n\t\terror = midi_start_output(sc, 0);\n\t}\n\treturn (error);\n}"
  },
  {
    "function_name": "midi_start_output",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/midi.c",
    "lines": "488-535",
    "snippet": "int\nmidi_start_output(sc, intr)\n\tstruct midi_softc *sc;\n\tint intr;\n{\n\tstruct midi_buffer *mb = &sc->outbuf;\n\tu_char *outp;\n\tint error;\n\tint s;\n\tint i, mmax;\n\n\terror = 0;\n\tmmax = sc->props & MIDI_PROP_OUT_INTR ? 1 : MIDI_MAX_WRITE;\n\ts = splaudio();\n\tif (sc->pbus && !intr) {\n\t\tDPRINTFN(4, (\"midi_start_output: busy\\n\"));\n\t\tsplx(s);\n\t\treturn (0);\n\t}\n\tsc->pbus = 1;\n\tfor (i = 0; i < mmax && mb->used > 0 && !error; i++) {\n\t\toutp = mb->outp;\n\t\tsplx(s);\n\t\tDPRINTFN(4, (\"midi_start_output: %p i=%d, data=0x%02x\\n\", \n\t\t\t     sc, i, *outp));\n#ifdef MIDI_SAVE\n\t\tmidisave.buf[midicnt] = *outp;\n\t\tmidicnt = (midicnt + 1) % MIDI_SAVE_SIZE;\n#endif\n\t\terror = sc->hw_if->output(sc->hw_hdl, *outp++);\n\t\tif (outp >= mb->end)\n\t\t\toutp = mb->start;\n\t\ts = splaudio();\n\t\tmb->outp = outp;\n\t\tmb->used--;\n\t}\n\tmidi_wakeup(&sc->wchan);\n\tselwakeup(&sc->wsel);\n\tif (sc->async)\n\t\tpsignal(sc->async, SIGIO);\n\tif (mb->used > 0) {\n\t\tif (!(sc->props & MIDI_PROP_OUT_INTR))\n\t\t\ttimeout(midi_timeout, sc, midi_wait);\n\t} else\n\t\tsc->pbus = 0;\n\tsplx(s);\n\treturn (error);\n}",
    "includes": [
      "#include <dev/midivar.h>",
      "#include <dev/midi_if.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/midiio.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"sequencer.h\"",
      "#include \"midi.h\""
    ],
    "macros_used": [
      "#define MIDI_SAVE_SIZE 100000"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "midi_timeout",
            "sc",
            "midi_wait"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "midi_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/midi.c",
          "lines": "478-486",
          "snippet": "void\nmidi_timeout(arg)\n\tvoid *arg;\n{\n\tstruct midi_softc *sc = arg;\n\n\tDPRINTFN(3,(\"midi_timeout: %p\\n\", sc));\n\tmidi_start_output(sc, 1);\n}",
          "includes": [
            "#include <dev/midivar.h>",
            "#include <dev/midi_if.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/midiio.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"sequencer.h\"",
            "#include \"midi.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n#include \"midi.h\"\n\nvoid\nmidi_timeout(arg)\n\tvoid *arg;\n{\n\tstruct midi_softc *sc = arg;\n\n\tDPRINTFN(3,(\"midi_timeout: %p\\n\", sc));\n\tmidi_start_output(sc, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "psignal",
          "args": [
            "sc->async",
            "SIGIO"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "selwakeup",
          "args": [
            "&sc->wsel"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "midi_wakeup",
          "args": [
            "&sc->wchan"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "midi_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/midi.c",
          "lines": "222-231",
          "snippet": "void\nmidi_wakeup(chan)\n\tint *chan;\n{\n\tif (*chan) {\n\t\tDPRINTFN(5, (\"midi_wakeup: %p\\n\", chan));\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}",
          "includes": [
            "#include <dev/midivar.h>",
            "#include <dev/midi_if.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/midiio.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"sequencer.h\"",
            "#include \"midi.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n#include \"midi.h\"\n\nvoid\nmidi_wakeup(chan)\n\tint *chan;\n{\n\tif (*chan) {\n\t\tDPRINTFN(5, (\"midi_wakeup: %p\\n\", chan));\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "splaudio",
          "args": [],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->hw_if->output",
          "args": [
            "sc->hw_hdl",
            "*outp++"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "4",
            "(\"midi_start_output: %p i=%d, data=0x%02x\\n\", \n\t\t\t     sc, i, *outp)"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "4",
            "(\"midi_start_output: busy\\n\")"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splaudio",
          "args": [],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n#include \"midi.h\"\n\n#define MIDI_SAVE_SIZE 100000\n\nint\nmidi_start_output(sc, intr)\n\tstruct midi_softc *sc;\n\tint intr;\n{\n\tstruct midi_buffer *mb = &sc->outbuf;\n\tu_char *outp;\n\tint error;\n\tint s;\n\tint i, mmax;\n\n\terror = 0;\n\tmmax = sc->props & MIDI_PROP_OUT_INTR ? 1 : MIDI_MAX_WRITE;\n\ts = splaudio();\n\tif (sc->pbus && !intr) {\n\t\tDPRINTFN(4, (\"midi_start_output: busy\\n\"));\n\t\tsplx(s);\n\t\treturn (0);\n\t}\n\tsc->pbus = 1;\n\tfor (i = 0; i < mmax && mb->used > 0 && !error; i++) {\n\t\toutp = mb->outp;\n\t\tsplx(s);\n\t\tDPRINTFN(4, (\"midi_start_output: %p i=%d, data=0x%02x\\n\", \n\t\t\t     sc, i, *outp));\n#ifdef MIDI_SAVE\n\t\tmidisave.buf[midicnt] = *outp;\n\t\tmidicnt = (midicnt + 1) % MIDI_SAVE_SIZE;\n#endif\n\t\terror = sc->hw_if->output(sc->hw_hdl, *outp++);\n\t\tif (outp >= mb->end)\n\t\t\toutp = mb->start;\n\t\ts = splaudio();\n\t\tmb->outp = outp;\n\t\tmb->used--;\n\t}\n\tmidi_wakeup(&sc->wchan);\n\tselwakeup(&sc->wsel);\n\tif (sc->async)\n\t\tpsignal(sc->async, SIGIO);\n\tif (mb->used > 0) {\n\t\tif (!(sc->props & MIDI_PROP_OUT_INTR))\n\t\t\ttimeout(midi_timeout, sc, midi_wait);\n\t} else\n\t\tsc->pbus = 0;\n\tsplx(s);\n\treturn (error);\n}"
  },
  {
    "function_name": "midi_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/midi.c",
    "lines": "478-486",
    "snippet": "void\nmidi_timeout(arg)\n\tvoid *arg;\n{\n\tstruct midi_softc *sc = arg;\n\n\tDPRINTFN(3,(\"midi_timeout: %p\\n\", sc));\n\tmidi_start_output(sc, 1);\n}",
    "includes": [
      "#include <dev/midivar.h>",
      "#include <dev/midi_if.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/midiio.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"sequencer.h\"",
      "#include \"midi.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "midi_start_output",
          "args": [
            "sc",
            "1"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "midi_start_output",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/midi.c",
          "lines": "488-535",
          "snippet": "int\nmidi_start_output(sc, intr)\n\tstruct midi_softc *sc;\n\tint intr;\n{\n\tstruct midi_buffer *mb = &sc->outbuf;\n\tu_char *outp;\n\tint error;\n\tint s;\n\tint i, mmax;\n\n\terror = 0;\n\tmmax = sc->props & MIDI_PROP_OUT_INTR ? 1 : MIDI_MAX_WRITE;\n\ts = splaudio();\n\tif (sc->pbus && !intr) {\n\t\tDPRINTFN(4, (\"midi_start_output: busy\\n\"));\n\t\tsplx(s);\n\t\treturn (0);\n\t}\n\tsc->pbus = 1;\n\tfor (i = 0; i < mmax && mb->used > 0 && !error; i++) {\n\t\toutp = mb->outp;\n\t\tsplx(s);\n\t\tDPRINTFN(4, (\"midi_start_output: %p i=%d, data=0x%02x\\n\", \n\t\t\t     sc, i, *outp));\n#ifdef MIDI_SAVE\n\t\tmidisave.buf[midicnt] = *outp;\n\t\tmidicnt = (midicnt + 1) % MIDI_SAVE_SIZE;\n#endif\n\t\terror = sc->hw_if->output(sc->hw_hdl, *outp++);\n\t\tif (outp >= mb->end)\n\t\t\toutp = mb->start;\n\t\ts = splaudio();\n\t\tmb->outp = outp;\n\t\tmb->used--;\n\t}\n\tmidi_wakeup(&sc->wchan);\n\tselwakeup(&sc->wsel);\n\tif (sc->async)\n\t\tpsignal(sc->async, SIGIO);\n\tif (mb->used > 0) {\n\t\tif (!(sc->props & MIDI_PROP_OUT_INTR))\n\t\t\ttimeout(midi_timeout, sc, midi_wait);\n\t} else\n\t\tsc->pbus = 0;\n\tsplx(s);\n\treturn (error);\n}",
          "includes": [
            "#include <dev/midivar.h>",
            "#include <dev/midi_if.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/midiio.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"sequencer.h\"",
            "#include \"midi.h\""
          ],
          "macros_used": [
            "#define MIDI_SAVE_SIZE 100000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n#include \"midi.h\"\n\n#define MIDI_SAVE_SIZE 100000\n\nint\nmidi_start_output(sc, intr)\n\tstruct midi_softc *sc;\n\tint intr;\n{\n\tstruct midi_buffer *mb = &sc->outbuf;\n\tu_char *outp;\n\tint error;\n\tint s;\n\tint i, mmax;\n\n\terror = 0;\n\tmmax = sc->props & MIDI_PROP_OUT_INTR ? 1 : MIDI_MAX_WRITE;\n\ts = splaudio();\n\tif (sc->pbus && !intr) {\n\t\tDPRINTFN(4, (\"midi_start_output: busy\\n\"));\n\t\tsplx(s);\n\t\treturn (0);\n\t}\n\tsc->pbus = 1;\n\tfor (i = 0; i < mmax && mb->used > 0 && !error; i++) {\n\t\toutp = mb->outp;\n\t\tsplx(s);\n\t\tDPRINTFN(4, (\"midi_start_output: %p i=%d, data=0x%02x\\n\", \n\t\t\t     sc, i, *outp));\n#ifdef MIDI_SAVE\n\t\tmidisave.buf[midicnt] = *outp;\n\t\tmidicnt = (midicnt + 1) % MIDI_SAVE_SIZE;\n#endif\n\t\terror = sc->hw_if->output(sc->hw_hdl, *outp++);\n\t\tif (outp >= mb->end)\n\t\t\toutp = mb->start;\n\t\ts = splaudio();\n\t\tmb->outp = outp;\n\t\tmb->used--;\n\t}\n\tmidi_wakeup(&sc->wchan);\n\tselwakeup(&sc->wsel);\n\tif (sc->async)\n\t\tpsignal(sc->async, SIGIO);\n\tif (mb->used > 0) {\n\t\tif (!(sc->props & MIDI_PROP_OUT_INTR))\n\t\t\ttimeout(midi_timeout, sc, midi_wait);\n\t} else\n\t\tsc->pbus = 0;\n\tsplx(s);\n\treturn (error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "3",
            "(\"midi_timeout: %p\\n\", sc)"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n#include \"midi.h\"\n\nvoid\nmidi_timeout(arg)\n\tvoid *arg;\n{\n\tstruct midi_softc *sc = arg;\n\n\tDPRINTFN(3,(\"midi_timeout: %p\\n\", sc));\n\tmidi_start_output(sc, 1);\n}"
  },
  {
    "function_name": "midiread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/midi.c",
    "lines": "422-476",
    "snippet": "int\nmidiread(dev, uio, ioflag)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint ioflag;\n{\n\tint unit = MIDIUNIT(dev);\n\tstruct midi_softc *sc = midi_cd.cd_devs[unit];\n\tstruct midi_buffer *mb = &sc->inbuf;\n\tint error;\n\tu_char *outp;\n\tint used, cc, n, resid;\n\tint s;\n\n\tDPRINTF((\"midiread: %p, count=%d\\n\", sc, uio->uio_resid));\n\n\terror = 0;\n\tresid = uio->uio_resid;\n\twhile (uio->uio_resid == resid && !error) {\n\t\ts = splaudio();\n\t\twhile (mb->used <= 0) {\n\t\t\tif (ioflag & IO_NDELAY) {\n\t\t\t\tsplx(s);\n\t\t\t\treturn (EWOULDBLOCK);\n\t\t\t}\n\t\t\terror = midi_sleep(&sc->rchan, \"mid rd\");\n\t\t\tif (error) {\n\t\t\t\tsplx(s);\n\t\t\t\treturn (error);\n\t\t\t}\n\t\t}\n\t\tused = mb->used;\n\t\toutp = mb->outp;\n\t\tsplx(s);\n\t\tcc = used;\t/* maximum to read */\n\t\tn = mb->end - outp;\n\t\tif (n < cc)\n\t\t\tcc = n;\t/* don't read beyond end of buffer */\n\t\tif (uio->uio_resid < cc)\n\t\t\tcc = uio->uio_resid; /* and no more than we want */\n\t\tDPRINTFN(3, (\"midiread: uiomove cc=%d\\n\", cc));\n\t\terror = uiomove(outp, cc, uio);\n\t\tif (error)\n\t\t\tbreak;\n\t\tused -= cc;\n\t\toutp += cc;\n\t\tif (outp >= mb->end)\n\t\t\toutp = mb->start;\n\t\ts = splaudio();\n\t\tmb->outp = outp;\n\t\tmb->used = used;\n\t\tsplx(s);\n\t}\n\treturn (error);\n}",
    "includes": [
      "#include <dev/midivar.h>",
      "#include <dev/midi_if.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/midiio.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"sequencer.h\"",
      "#include \"midi.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splaudio",
          "args": [],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uiomove",
          "args": [
            "outp",
            "cc",
            "uio"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "3",
            "(\"midiread: uiomove cc=%d\\n\", cc)"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "midi_sleep",
          "args": [
            "&sc->rchan",
            "\"mid rd\""
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "midi_sleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/midi.c",
          "lines": "214-220",
          "snippet": "int\nmidi_sleep(chan, label)\n\tint *chan;\n\tchar *label;\n{\n\treturn (midi_sleep_timo(chan, label, 0));\n}",
          "includes": [
            "#include <dev/midivar.h>",
            "#include <dev/midi_if.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/midiio.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"sequencer.h\"",
            "#include \"midi.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n#include \"midi.h\"\n\nint\nmidi_sleep(chan, label)\n\tint *chan;\n\tchar *label;\n{\n\treturn (midi_sleep_timo(chan, label, 0));\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splaudio",
          "args": [],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"midiread: %p, count=%d\\n\", sc, uio->uio_resid)"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIDIUNIT",
          "args": [
            "dev"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n#include \"midi.h\"\n\nint\nmidiread(dev, uio, ioflag)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint ioflag;\n{\n\tint unit = MIDIUNIT(dev);\n\tstruct midi_softc *sc = midi_cd.cd_devs[unit];\n\tstruct midi_buffer *mb = &sc->inbuf;\n\tint error;\n\tu_char *outp;\n\tint used, cc, n, resid;\n\tint s;\n\n\tDPRINTF((\"midiread: %p, count=%d\\n\", sc, uio->uio_resid));\n\n\terror = 0;\n\tresid = uio->uio_resid;\n\twhile (uio->uio_resid == resid && !error) {\n\t\ts = splaudio();\n\t\twhile (mb->used <= 0) {\n\t\t\tif (ioflag & IO_NDELAY) {\n\t\t\t\tsplx(s);\n\t\t\t\treturn (EWOULDBLOCK);\n\t\t\t}\n\t\t\terror = midi_sleep(&sc->rchan, \"mid rd\");\n\t\t\tif (error) {\n\t\t\t\tsplx(s);\n\t\t\t\treturn (error);\n\t\t\t}\n\t\t}\n\t\tused = mb->used;\n\t\toutp = mb->outp;\n\t\tsplx(s);\n\t\tcc = used;\t/* maximum to read */\n\t\tn = mb->end - outp;\n\t\tif (n < cc)\n\t\t\tcc = n;\t/* don't read beyond end of buffer */\n\t\tif (uio->uio_resid < cc)\n\t\t\tcc = uio->uio_resid; /* and no more than we want */\n\t\tDPRINTFN(3, (\"midiread: uiomove cc=%d\\n\", cc));\n\t\terror = uiomove(outp, cc, uio);\n\t\tif (error)\n\t\t\tbreak;\n\t\tused -= cc;\n\t\toutp += cc;\n\t\tif (outp >= mb->end)\n\t\t\toutp = mb->start;\n\t\ts = splaudio();\n\t\tmb->outp = outp;\n\t\tmb->used = used;\n\t\tsplx(s);\n\t}\n\treturn (error);\n}"
  },
  {
    "function_name": "midiclose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/midi.c",
    "lines": "392-420",
    "snippet": "int\nmidiclose(dev, flags, ifmt, p)\n\tdev_t dev;\n\tint flags, ifmt;\n\tstruct proc *p;\n{\n\tint unit = MIDIUNIT(dev);\n\tstruct midi_softc *sc = midi_cd.cd_devs[unit];\n\tstruct midi_hw_if *hw = sc->hw_if;\n\tint s, error;\n\n\tDPRINTF((\"midiclose %p\\n\", sc));\n\n\tmidi_start_output(sc, 0);\n\terror = 0;\n\ts = splaudio();\n\twhile (sc->outbuf.used > 0 && !error) {\n\t\tDPRINTFN(2,(\"midiclose sleep used=%d\\n\", sc->outbuf.used));\n\t\terror = midi_sleep_timo(&sc->wchan, \"mid_dr\", 30*hz);\n\t}\n\tsplx(s);\n\tsc->isopen = 0;\n\thw->close(sc->hw_hdl);\n#if NSEQUENCER > 0\n\tsc->seqopen = 0;\n\tsc->seq_md = 0;\n#endif\n\treturn (0);\n}",
    "includes": [
      "#include <dev/midivar.h>",
      "#include <dev/midi_if.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/midiio.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"sequencer.h\"",
      "#include \"midi.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hw->close",
          "args": [
            "sc->hw_hdl"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "midi_sleep_timo",
          "args": [
            "&sc->wchan",
            "\"mid_dr\"",
            "30*hz"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "midi_sleep_timo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/midi.c",
          "lines": "192-212",
          "snippet": "int\nmidi_sleep_timo(chan, label, timo)\n\tint *chan;\n\tchar *label;\n\tint timo;\n{\n\tint st;\n\n\tif (!label)\n\t\tlabel = \"midi\";\n\n\tDPRINTFN(5, (\"midi_sleep_timo: %p %s %d\\n\", chan, label, timo));\n\t*chan = 1;\n\tst = tsleep(chan, PWAIT | PCATCH, label, timo);\n\t*chan = 0;\n#ifdef MIDI_DEBUG\n\tif (st != 0)\n\t\tprintf(\"midi_sleep: %d\\n\", st);\n#endif\n\treturn (st);\n}",
          "includes": [
            "#include <dev/midivar.h>",
            "#include <dev/midi_if.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/midiio.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"sequencer.h\"",
            "#include \"midi.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n#include \"midi.h\"\n\nint\nmidi_sleep_timo(chan, label, timo)\n\tint *chan;\n\tchar *label;\n\tint timo;\n{\n\tint st;\n\n\tif (!label)\n\t\tlabel = \"midi\";\n\n\tDPRINTFN(5, (\"midi_sleep_timo: %p %s %d\\n\", chan, label, timo));\n\t*chan = 1;\n\tst = tsleep(chan, PWAIT | PCATCH, label, timo);\n\t*chan = 0;\n#ifdef MIDI_DEBUG\n\tif (st != 0)\n\t\tprintf(\"midi_sleep: %d\\n\", st);\n#endif\n\treturn (st);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "2",
            "(\"midiclose sleep used=%d\\n\", sc->outbuf.used)"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splaudio",
          "args": [],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "midi_start_output",
          "args": [
            "sc",
            "0"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "midi_start_output",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/midi.c",
          "lines": "488-535",
          "snippet": "int\nmidi_start_output(sc, intr)\n\tstruct midi_softc *sc;\n\tint intr;\n{\n\tstruct midi_buffer *mb = &sc->outbuf;\n\tu_char *outp;\n\tint error;\n\tint s;\n\tint i, mmax;\n\n\terror = 0;\n\tmmax = sc->props & MIDI_PROP_OUT_INTR ? 1 : MIDI_MAX_WRITE;\n\ts = splaudio();\n\tif (sc->pbus && !intr) {\n\t\tDPRINTFN(4, (\"midi_start_output: busy\\n\"));\n\t\tsplx(s);\n\t\treturn (0);\n\t}\n\tsc->pbus = 1;\n\tfor (i = 0; i < mmax && mb->used > 0 && !error; i++) {\n\t\toutp = mb->outp;\n\t\tsplx(s);\n\t\tDPRINTFN(4, (\"midi_start_output: %p i=%d, data=0x%02x\\n\", \n\t\t\t     sc, i, *outp));\n#ifdef MIDI_SAVE\n\t\tmidisave.buf[midicnt] = *outp;\n\t\tmidicnt = (midicnt + 1) % MIDI_SAVE_SIZE;\n#endif\n\t\terror = sc->hw_if->output(sc->hw_hdl, *outp++);\n\t\tif (outp >= mb->end)\n\t\t\toutp = mb->start;\n\t\ts = splaudio();\n\t\tmb->outp = outp;\n\t\tmb->used--;\n\t}\n\tmidi_wakeup(&sc->wchan);\n\tselwakeup(&sc->wsel);\n\tif (sc->async)\n\t\tpsignal(sc->async, SIGIO);\n\tif (mb->used > 0) {\n\t\tif (!(sc->props & MIDI_PROP_OUT_INTR))\n\t\t\ttimeout(midi_timeout, sc, midi_wait);\n\t} else\n\t\tsc->pbus = 0;\n\tsplx(s);\n\treturn (error);\n}",
          "includes": [
            "#include <dev/midivar.h>",
            "#include <dev/midi_if.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/midiio.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"sequencer.h\"",
            "#include \"midi.h\""
          ],
          "macros_used": [
            "#define MIDI_SAVE_SIZE 100000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n#include \"midi.h\"\n\n#define MIDI_SAVE_SIZE 100000\n\nint\nmidi_start_output(sc, intr)\n\tstruct midi_softc *sc;\n\tint intr;\n{\n\tstruct midi_buffer *mb = &sc->outbuf;\n\tu_char *outp;\n\tint error;\n\tint s;\n\tint i, mmax;\n\n\terror = 0;\n\tmmax = sc->props & MIDI_PROP_OUT_INTR ? 1 : MIDI_MAX_WRITE;\n\ts = splaudio();\n\tif (sc->pbus && !intr) {\n\t\tDPRINTFN(4, (\"midi_start_output: busy\\n\"));\n\t\tsplx(s);\n\t\treturn (0);\n\t}\n\tsc->pbus = 1;\n\tfor (i = 0; i < mmax && mb->used > 0 && !error; i++) {\n\t\toutp = mb->outp;\n\t\tsplx(s);\n\t\tDPRINTFN(4, (\"midi_start_output: %p i=%d, data=0x%02x\\n\", \n\t\t\t     sc, i, *outp));\n#ifdef MIDI_SAVE\n\t\tmidisave.buf[midicnt] = *outp;\n\t\tmidicnt = (midicnt + 1) % MIDI_SAVE_SIZE;\n#endif\n\t\terror = sc->hw_if->output(sc->hw_hdl, *outp++);\n\t\tif (outp >= mb->end)\n\t\t\toutp = mb->start;\n\t\ts = splaudio();\n\t\tmb->outp = outp;\n\t\tmb->used--;\n\t}\n\tmidi_wakeup(&sc->wchan);\n\tselwakeup(&sc->wsel);\n\tif (sc->async)\n\t\tpsignal(sc->async, SIGIO);\n\tif (mb->used > 0) {\n\t\tif (!(sc->props & MIDI_PROP_OUT_INTR))\n\t\t\ttimeout(midi_timeout, sc, midi_wait);\n\t} else\n\t\tsc->pbus = 0;\n\tsplx(s);\n\treturn (error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"midiclose %p\\n\", sc)"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIDIUNIT",
          "args": [
            "dev"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n#include \"midi.h\"\n\nint\nmidiclose(dev, flags, ifmt, p)\n\tdev_t dev;\n\tint flags, ifmt;\n\tstruct proc *p;\n{\n\tint unit = MIDIUNIT(dev);\n\tstruct midi_softc *sc = midi_cd.cd_devs[unit];\n\tstruct midi_hw_if *hw = sc->hw_if;\n\tint s, error;\n\n\tDPRINTF((\"midiclose %p\\n\", sc));\n\n\tmidi_start_output(sc, 0);\n\terror = 0;\n\ts = splaudio();\n\twhile (sc->outbuf.used > 0 && !error) {\n\t\tDPRINTFN(2,(\"midiclose sleep used=%d\\n\", sc->outbuf.used));\n\t\terror = midi_sleep_timo(&sc->wchan, \"mid_dr\", 30*hz);\n\t}\n\tsplx(s);\n\tsc->isopen = 0;\n\thw->close(sc->hw_hdl);\n#if NSEQUENCER > 0\n\tsc->seqopen = 0;\n\tsc->seq_md = 0;\n#endif\n\treturn (0);\n}"
  },
  {
    "function_name": "midiopen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/midi.c",
    "lines": "347-390",
    "snippet": "int\nmidiopen(dev, flags, ifmt, p)\n\tdev_t dev;\n\tint flags, ifmt;\n\tstruct proc *p;\n{\n\tint unit = MIDIUNIT(dev);\n\tstruct midi_softc *sc;\n\tstruct midi_hw_if *hw;\n\tint error;\n\n\tif (unit >= midi_cd.cd_ndevs ||\n\t    (sc = midi_cd.cd_devs[unit]) == NULL)\n\t\treturn (ENXIO);\n\tDPRINTF((\"midiopen %p\\n\", sc));\n\n\thw = sc->hw_if;\n\tif (!hw)\n\t\treturn (ENXIO);\n\tif (sc->isopen)\n\t\treturn (EBUSY);\n\tsc->in_state = MIDI_IN_START;\n\tsc->in_status = 0;\n\terror = hw->open(sc->hw_hdl, flags, midi_in, midi_out, sc);\n\tif (error)\n\t\treturn (error);\n\tsc->isopen++;\n\tmidi_initbuf(&sc->outbuf);\n\tmidi_initbuf(&sc->inbuf);\n\tsc->flags = flags;\n\tsc->rchan = 0;\n\tsc->wchan = 0;\n\tsc->pbus = 0;\n\tsc->async = 0;\n\n#ifdef MIDI_SAVE\n\tif (midicnt != 0) {\n\t\tmidisave.cnt = midicnt;\n\t\tmidicnt = 0;\n\t}\n#endif\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/midivar.h>",
      "#include <dev/midi_if.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/midiio.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"sequencer.h\"",
      "#include \"midi.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "midi_initbuf",
          "args": [
            "&sc->inbuf"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "midi_initbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/midi.c",
          "lines": "182-190",
          "snippet": "void\nmidi_initbuf(mb)\n\tstruct midi_buffer *mb;\n{\n\tmb->used = 0;\n\tmb->usedhigh = MIDI_BUFSIZE;\n\tmb->end = mb->start + mb->usedhigh;\n\tmb->inp = mb->outp = mb->start;\n}",
          "includes": [
            "#include <dev/midivar.h>",
            "#include <dev/midi_if.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/midiio.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"sequencer.h\"",
            "#include \"midi.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n#include \"midi.h\"\n\nvoid\nmidi_initbuf(mb)\n\tstruct midi_buffer *mb;\n{\n\tmb->used = 0;\n\tmb->usedhigh = MIDI_BUFSIZE;\n\tmb->end = mb->start + mb->usedhigh;\n\tmb->inp = mb->outp = mb->start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hw->open",
          "args": [
            "sc->hw_hdl",
            "flags",
            "midi_in",
            "midi_out",
            "sc"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"midiopen %p\\n\", sc)"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIDIUNIT",
          "args": [
            "dev"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n#include \"midi.h\"\n\nint\nmidiopen(dev, flags, ifmt, p)\n\tdev_t dev;\n\tint flags, ifmt;\n\tstruct proc *p;\n{\n\tint unit = MIDIUNIT(dev);\n\tstruct midi_softc *sc;\n\tstruct midi_hw_if *hw;\n\tint error;\n\n\tif (unit >= midi_cd.cd_ndevs ||\n\t    (sc = midi_cd.cd_devs[unit]) == NULL)\n\t\treturn (ENXIO);\n\tDPRINTF((\"midiopen %p\\n\", sc));\n\n\thw = sc->hw_if;\n\tif (!hw)\n\t\treturn (ENXIO);\n\tif (sc->isopen)\n\t\treturn (EBUSY);\n\tsc->in_state = MIDI_IN_START;\n\tsc->in_status = 0;\n\terror = hw->open(sc->hw_hdl, flags, midi_in, midi_out, sc);\n\tif (error)\n\t\treturn (error);\n\tsc->isopen++;\n\tmidi_initbuf(&sc->outbuf);\n\tmidi_initbuf(&sc->inbuf);\n\tsc->flags = flags;\n\tsc->rchan = 0;\n\tsc->wchan = 0;\n\tsc->pbus = 0;\n\tsc->async = 0;\n\n#ifdef MIDI_SAVE\n\tif (midicnt != 0) {\n\t\tmidisave.cnt = midicnt;\n\t\tmidicnt = 0;\n\t}\n#endif\n\n\treturn (0);\n}"
  },
  {
    "function_name": "midi_out",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/midi.c",
    "lines": "335-345",
    "snippet": "void\nmidi_out(addr)\n\tvoid *addr;\n{\n\tstruct midi_softc *sc = addr;\n\n\tif (!sc->isopen)\n\t\treturn;\n\tDPRINTFN(3, (\"midi_out: %p\\n\", sc));\n\tmidi_start_output(sc, 1);\n}",
    "includes": [
      "#include <dev/midivar.h>",
      "#include <dev/midi_if.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/midiio.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"sequencer.h\"",
      "#include \"midi.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "midi_start_output",
          "args": [
            "sc",
            "1"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "midi_start_output",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/midi.c",
          "lines": "488-535",
          "snippet": "int\nmidi_start_output(sc, intr)\n\tstruct midi_softc *sc;\n\tint intr;\n{\n\tstruct midi_buffer *mb = &sc->outbuf;\n\tu_char *outp;\n\tint error;\n\tint s;\n\tint i, mmax;\n\n\terror = 0;\n\tmmax = sc->props & MIDI_PROP_OUT_INTR ? 1 : MIDI_MAX_WRITE;\n\ts = splaudio();\n\tif (sc->pbus && !intr) {\n\t\tDPRINTFN(4, (\"midi_start_output: busy\\n\"));\n\t\tsplx(s);\n\t\treturn (0);\n\t}\n\tsc->pbus = 1;\n\tfor (i = 0; i < mmax && mb->used > 0 && !error; i++) {\n\t\toutp = mb->outp;\n\t\tsplx(s);\n\t\tDPRINTFN(4, (\"midi_start_output: %p i=%d, data=0x%02x\\n\", \n\t\t\t     sc, i, *outp));\n#ifdef MIDI_SAVE\n\t\tmidisave.buf[midicnt] = *outp;\n\t\tmidicnt = (midicnt + 1) % MIDI_SAVE_SIZE;\n#endif\n\t\terror = sc->hw_if->output(sc->hw_hdl, *outp++);\n\t\tif (outp >= mb->end)\n\t\t\toutp = mb->start;\n\t\ts = splaudio();\n\t\tmb->outp = outp;\n\t\tmb->used--;\n\t}\n\tmidi_wakeup(&sc->wchan);\n\tselwakeup(&sc->wsel);\n\tif (sc->async)\n\t\tpsignal(sc->async, SIGIO);\n\tif (mb->used > 0) {\n\t\tif (!(sc->props & MIDI_PROP_OUT_INTR))\n\t\t\ttimeout(midi_timeout, sc, midi_wait);\n\t} else\n\t\tsc->pbus = 0;\n\tsplx(s);\n\treturn (error);\n}",
          "includes": [
            "#include <dev/midivar.h>",
            "#include <dev/midi_if.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/midiio.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"sequencer.h\"",
            "#include \"midi.h\""
          ],
          "macros_used": [
            "#define MIDI_SAVE_SIZE 100000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n#include \"midi.h\"\n\n#define MIDI_SAVE_SIZE 100000\n\nint\nmidi_start_output(sc, intr)\n\tstruct midi_softc *sc;\n\tint intr;\n{\n\tstruct midi_buffer *mb = &sc->outbuf;\n\tu_char *outp;\n\tint error;\n\tint s;\n\tint i, mmax;\n\n\terror = 0;\n\tmmax = sc->props & MIDI_PROP_OUT_INTR ? 1 : MIDI_MAX_WRITE;\n\ts = splaudio();\n\tif (sc->pbus && !intr) {\n\t\tDPRINTFN(4, (\"midi_start_output: busy\\n\"));\n\t\tsplx(s);\n\t\treturn (0);\n\t}\n\tsc->pbus = 1;\n\tfor (i = 0; i < mmax && mb->used > 0 && !error; i++) {\n\t\toutp = mb->outp;\n\t\tsplx(s);\n\t\tDPRINTFN(4, (\"midi_start_output: %p i=%d, data=0x%02x\\n\", \n\t\t\t     sc, i, *outp));\n#ifdef MIDI_SAVE\n\t\tmidisave.buf[midicnt] = *outp;\n\t\tmidicnt = (midicnt + 1) % MIDI_SAVE_SIZE;\n#endif\n\t\terror = sc->hw_if->output(sc->hw_hdl, *outp++);\n\t\tif (outp >= mb->end)\n\t\t\toutp = mb->start;\n\t\ts = splaudio();\n\t\tmb->outp = outp;\n\t\tmb->used--;\n\t}\n\tmidi_wakeup(&sc->wchan);\n\tselwakeup(&sc->wsel);\n\tif (sc->async)\n\t\tpsignal(sc->async, SIGIO);\n\tif (mb->used > 0) {\n\t\tif (!(sc->props & MIDI_PROP_OUT_INTR))\n\t\t\ttimeout(midi_timeout, sc, midi_wait);\n\t} else\n\t\tsc->pbus = 0;\n\tsplx(s);\n\treturn (error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "3",
            "(\"midi_out: %p\\n\", sc)"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n#include \"midi.h\"\n\nvoid\nmidi_out(addr)\n\tvoid *addr;\n{\n\tstruct midi_softc *sc = addr;\n\n\tif (!sc->isopen)\n\t\treturn;\n\tDPRINTFN(3, (\"midi_out: %p\\n\", sc));\n\tmidi_start_output(sc, 1);\n}"
  },
  {
    "function_name": "midi_in",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/midi.c",
    "lines": "237-333",
    "snippet": "void\nmidi_in(addr, data)\n\tvoid *addr;\n\tint data;\n{\n\tstruct midi_softc *sc = addr;\n\tstruct midi_buffer *mb = &sc->inbuf;\n\tint i;\n\n\tif (!sc->isopen)\n\t\treturn;\n\tif (data == MIDI_ACK)\n\t\treturn;\n\tDPRINTFN(3, (\"midi_in: %p 0x%02x\\n\", sc, data));\n\tif (!(sc->flags & FREAD))\n\t\treturn;\t\t/* discard data if not reading */\n\n\tswitch(sc->in_state) {\n\tcase MIDI_IN_START:\n\t\tif (MIDI_IS_STATUS(data)) {\n\t\t\tswitch(data) {\n\t\t\tcase 0xf0: /* Sysex */\n\t\t\t\tsc->in_state = MIDI_IN_SYSEX;\n\t\t\t\tbreak;\n\t\t\tcase 0xf1: /* MTC quarter frame */\n\t\t\tcase 0xf3: /* Song select */\n\t\t\t\tsc->in_state = MIDI_IN_DATA;\n\t\t\t\tsc->in_msg[0] = data;\n\t\t\t\tsc->in_pos = 1;\n\t\t\t\tsc->in_left = 1;\n\t\t\t\tbreak;\n\t\t\tcase 0xf2: /* Song position pointer */\n\t\t\t\tsc->in_state = MIDI_IN_DATA;\n\t\t\t\tsc->in_msg[0] = data;\n\t\t\t\tsc->in_pos = 1;\n\t\t\t\tsc->in_left = 2;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (MIDI_IS_COMMON(data)) {\n\t\t\t\t\tsc->in_msg[0] = data;\n\t\t\t\t\tsc->in_pos = 1;\n\t\t\t\t\tgoto deliver;\n\t\t\t\t} else {\n\t\t\t\t\tsc->in_state = MIDI_IN_DATA;\n\t\t\t\t\tsc->in_msg[0] = sc->in_status = data;\n\t\t\t\t\tsc->in_pos = 1;\n\t\t\t\t\tsc->in_left = \n\t\t\t\t\t\tMIDI_LENGTH(sc->in_status);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif (MIDI_IS_STATUS(sc->in_status)) {\n\t\t\t\tsc->in_state = MIDI_IN_DATA;\n\t\t\t\tsc->in_msg[0] = sc->in_status;\n\t\t\t\tsc->in_msg[1] = data;\n\t\t\t\tsc->in_pos = 2;\n\t\t\t\tsc->in_left = MIDI_LENGTH(sc->in_status) - 1;\n\t\t\t}\n\t\t}\n\t\treturn;\n\tcase MIDI_IN_DATA:\n\t\tsc->in_msg[sc->in_pos++] = data;\n\t\tif (--sc->in_left <= 0)\n\t\t\tbreak;\t/* deliver data */\n\t\treturn;\n\tcase MIDI_IN_SYSEX:\n\t\tif (data == MIDI_SYSEX_END)\n\t\t\tsc->in_state = MIDI_IN_START;\n\t\treturn;\n\t}\ndeliver:\n\tsc->in_state = MIDI_IN_START;\n#if NSEQUENCER > 0\n\tif (sc->seqopen) {\n\t\textern void midiseq_in __P((struct midi_dev *,u_char *,int));\n\t\tmidiseq_in(sc->seq_md, sc->in_msg, sc->in_pos);\n\t\treturn;\n\t}\n#endif\n\n\tif (mb->used + sc->in_pos > mb->usedhigh) {\n\t\tDPRINTF((\"midi_in: buffer full, discard data=0x%02x\\n\", \n\t\t\t sc->in_msg[0]));\n\t\treturn;\n\t}\n\tfor (i = 0; i < sc->in_pos; i++) {\n\t\t*mb->inp++ = sc->in_msg[i];\n\t\tif (mb->inp >= mb->end)\n\t\t\tmb->inp = mb->start;\n\t\tmb->used++;\n\t}\n\tmidi_wakeup(&sc->rchan);\n\tselwakeup(&sc->rsel);\n\tif (sc->async)\n\t\tpsignal(sc->async, SIGIO);\n}",
    "includes": [
      "#include <dev/midivar.h>",
      "#include <dev/midi_if.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/midiio.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"sequencer.h\"",
      "#include \"midi.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "psignal",
          "args": [
            "sc->async",
            "SIGIO"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "selwakeup",
          "args": [
            "&sc->rsel"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "midi_wakeup",
          "args": [
            "&sc->rchan"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "midi_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/midi.c",
          "lines": "222-231",
          "snippet": "void\nmidi_wakeup(chan)\n\tint *chan;\n{\n\tif (*chan) {\n\t\tDPRINTFN(5, (\"midi_wakeup: %p\\n\", chan));\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}",
          "includes": [
            "#include <dev/midivar.h>",
            "#include <dev/midi_if.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/midiio.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"sequencer.h\"",
            "#include \"midi.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n#include \"midi.h\"\n\nvoid\nmidi_wakeup(chan)\n\tint *chan;\n{\n\tif (*chan) {\n\t\tDPRINTFN(5, (\"midi_wakeup: %p\\n\", chan));\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"midi_in: buffer full, discard data=0x%02x\\n\", \n\t\t\t sc->in_msg[0])"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "midiseq_in",
          "args": [
            "sc->seq_md",
            "sc->in_msg",
            "sc->in_pos"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "midiseq_in",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sequencer.c",
          "lines": "1042-1083",
          "snippet": "void\nmidiseq_in(md, msg, len)\n\tstruct midi_dev *md;\n\tu_char *msg;\n\tint len;\n{\n\tint unit = md->unit;\n\tseq_event_rec ev;\n\tint status, chan;\n\n\tDPRINTFN(2, (\"midiseq_in: %p %02x %02x %02x\\n\", \n\t\t     md, msg[0], msg[1], msg[2]));\n\n\tstatus = MIDI_GET_STATUS(msg[0]);\n\tchan = MIDI_GET_CHAN(msg[0]);\n\tswitch (status) {\n\tcase MIDI_NOTEON:\n\t\tif (msg[2] == 0) {\n\t\t\tstatus = MIDI_NOTEOFF;\n\t\t\tmsg[2] = MIDI_HALF_VEL;\n\t\t}\n\t\t/* fall into */\n\tcase MIDI_NOTEOFF:\n\tcase MIDI_KEY_PRESSURE:\n\t\tSEQ_MK_CHN_VOICE(&ev, unit, status, chan, msg[1], msg[2]);\n\t\tbreak;\n\tcase MIDI_CTL_CHANGE:\n\t\tSEQ_MK_CHN_COMMON(&ev, unit, status, chan, msg[1], 0, msg[2]);\n\t\tbreak;\n\tcase MIDI_PGM_CHANGE:\n\tcase MIDI_CHN_PRESSURE:\n\t\tSEQ_MK_CHN_COMMON(&ev, unit, status, chan, msg[1], 0, 0);\n\t\tbreak;\n\tcase MIDI_PITCH_BEND:\n\t\tSEQ_MK_CHN_COMMON(&ev, unit, status, chan, 0, 0, \n\t\t\t\t  (msg[1] & 0x7f) | ((msg[2] & 0x7f) << 7));\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\tseq_event_intr(md->seq, &ev);\n}",
          "includes": [
            "#include \"midi.h\"",
            "#include <dev/sequencervar.h>",
            "#include <dev/midivar.h>",
            "#include <dev/midi_if.h>",
            "#include <sys/device.h>",
            "#include <sys/midiio.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"sequencer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"midi.h\"\n#include <dev/sequencervar.h>\n#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n\nvoid\nmidiseq_in(md, msg, len)\n\tstruct midi_dev *md;\n\tu_char *msg;\n\tint len;\n{\n\tint unit = md->unit;\n\tseq_event_rec ev;\n\tint status, chan;\n\n\tDPRINTFN(2, (\"midiseq_in: %p %02x %02x %02x\\n\", \n\t\t     md, msg[0], msg[1], msg[2]));\n\n\tstatus = MIDI_GET_STATUS(msg[0]);\n\tchan = MIDI_GET_CHAN(msg[0]);\n\tswitch (status) {\n\tcase MIDI_NOTEON:\n\t\tif (msg[2] == 0) {\n\t\t\tstatus = MIDI_NOTEOFF;\n\t\t\tmsg[2] = MIDI_HALF_VEL;\n\t\t}\n\t\t/* fall into */\n\tcase MIDI_NOTEOFF:\n\tcase MIDI_KEY_PRESSURE:\n\t\tSEQ_MK_CHN_VOICE(&ev, unit, status, chan, msg[1], msg[2]);\n\t\tbreak;\n\tcase MIDI_CTL_CHANGE:\n\t\tSEQ_MK_CHN_COMMON(&ev, unit, status, chan, msg[1], 0, msg[2]);\n\t\tbreak;\n\tcase MIDI_PGM_CHANGE:\n\tcase MIDI_CHN_PRESSURE:\n\t\tSEQ_MK_CHN_COMMON(&ev, unit, status, chan, msg[1], 0, 0);\n\t\tbreak;\n\tcase MIDI_PITCH_BEND:\n\t\tSEQ_MK_CHN_COMMON(&ev, unit, status, chan, 0, 0, \n\t\t\t\t  (msg[1] & 0x7f) | ((msg[2] & 0x7f) << 7));\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\tseq_event_intr(md->seq, &ev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__P",
          "args": [
            "(struct midi_dev *,u_char *,int)"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIDI_LENGTH",
          "args": [
            "sc->in_status"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIDI_IS_STATUS",
          "args": [
            "sc->in_status"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIDI_LENGTH",
          "args": [
            "sc->in_status"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIDI_IS_COMMON",
          "args": [
            "data"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIDI_IS_STATUS",
          "args": [
            "data"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "3",
            "(\"midi_in: %p 0x%02x\\n\", sc, data)"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n#include \"midi.h\"\n\nvoid\nmidi_in(addr, data)\n\tvoid *addr;\n\tint data;\n{\n\tstruct midi_softc *sc = addr;\n\tstruct midi_buffer *mb = &sc->inbuf;\n\tint i;\n\n\tif (!sc->isopen)\n\t\treturn;\n\tif (data == MIDI_ACK)\n\t\treturn;\n\tDPRINTFN(3, (\"midi_in: %p 0x%02x\\n\", sc, data));\n\tif (!(sc->flags & FREAD))\n\t\treturn;\t\t/* discard data if not reading */\n\n\tswitch(sc->in_state) {\n\tcase MIDI_IN_START:\n\t\tif (MIDI_IS_STATUS(data)) {\n\t\t\tswitch(data) {\n\t\t\tcase 0xf0: /* Sysex */\n\t\t\t\tsc->in_state = MIDI_IN_SYSEX;\n\t\t\t\tbreak;\n\t\t\tcase 0xf1: /* MTC quarter frame */\n\t\t\tcase 0xf3: /* Song select */\n\t\t\t\tsc->in_state = MIDI_IN_DATA;\n\t\t\t\tsc->in_msg[0] = data;\n\t\t\t\tsc->in_pos = 1;\n\t\t\t\tsc->in_left = 1;\n\t\t\t\tbreak;\n\t\t\tcase 0xf2: /* Song position pointer */\n\t\t\t\tsc->in_state = MIDI_IN_DATA;\n\t\t\t\tsc->in_msg[0] = data;\n\t\t\t\tsc->in_pos = 1;\n\t\t\t\tsc->in_left = 2;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (MIDI_IS_COMMON(data)) {\n\t\t\t\t\tsc->in_msg[0] = data;\n\t\t\t\t\tsc->in_pos = 1;\n\t\t\t\t\tgoto deliver;\n\t\t\t\t} else {\n\t\t\t\t\tsc->in_state = MIDI_IN_DATA;\n\t\t\t\t\tsc->in_msg[0] = sc->in_status = data;\n\t\t\t\t\tsc->in_pos = 1;\n\t\t\t\t\tsc->in_left = \n\t\t\t\t\t\tMIDI_LENGTH(sc->in_status);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif (MIDI_IS_STATUS(sc->in_status)) {\n\t\t\t\tsc->in_state = MIDI_IN_DATA;\n\t\t\t\tsc->in_msg[0] = sc->in_status;\n\t\t\t\tsc->in_msg[1] = data;\n\t\t\t\tsc->in_pos = 2;\n\t\t\t\tsc->in_left = MIDI_LENGTH(sc->in_status) - 1;\n\t\t\t}\n\t\t}\n\t\treturn;\n\tcase MIDI_IN_DATA:\n\t\tsc->in_msg[sc->in_pos++] = data;\n\t\tif (--sc->in_left <= 0)\n\t\t\tbreak;\t/* deliver data */\n\t\treturn;\n\tcase MIDI_IN_SYSEX:\n\t\tif (data == MIDI_SYSEX_END)\n\t\t\tsc->in_state = MIDI_IN_START;\n\t\treturn;\n\t}\ndeliver:\n\tsc->in_state = MIDI_IN_START;\n#if NSEQUENCER > 0\n\tif (sc->seqopen) {\n\t\textern void midiseq_in __P((struct midi_dev *,u_char *,int));\n\t\tmidiseq_in(sc->seq_md, sc->in_msg, sc->in_pos);\n\t\treturn;\n\t}\n#endif\n\n\tif (mb->used + sc->in_pos > mb->usedhigh) {\n\t\tDPRINTF((\"midi_in: buffer full, discard data=0x%02x\\n\", \n\t\t\t sc->in_msg[0]));\n\t\treturn;\n\t}\n\tfor (i = 0; i < sc->in_pos; i++) {\n\t\t*mb->inp++ = sc->in_msg[i];\n\t\tif (mb->inp >= mb->end)\n\t\t\tmb->inp = mb->start;\n\t\tmb->used++;\n\t}\n\tmidi_wakeup(&sc->rchan);\n\tselwakeup(&sc->rsel);\n\tif (sc->async)\n\t\tpsignal(sc->async, SIGIO);\n}"
  },
  {
    "function_name": "midi_wakeup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/midi.c",
    "lines": "222-231",
    "snippet": "void\nmidi_wakeup(chan)\n\tint *chan;\n{\n\tif (*chan) {\n\t\tDPRINTFN(5, (\"midi_wakeup: %p\\n\", chan));\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}",
    "includes": [
      "#include <dev/midivar.h>",
      "#include <dev/midi_if.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/midiio.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"sequencer.h\"",
      "#include \"midi.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "chan"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "midi_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/midi.c",
          "lines": "222-231",
          "snippet": "void\nmidi_wakeup(chan)\n\tint *chan;\n{\n\tif (*chan) {\n\t\tDPRINTFN(5, (\"midi_wakeup: %p\\n\", chan));\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"midi_wakeup: %p\\n\", chan)"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n#include \"midi.h\"\n\nvoid\nmidi_wakeup(chan)\n\tint *chan;\n{\n\tif (*chan) {\n\t\tDPRINTFN(5, (\"midi_wakeup: %p\\n\", chan));\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}"
  },
  {
    "function_name": "midi_sleep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/midi.c",
    "lines": "214-220",
    "snippet": "int\nmidi_sleep(chan, label)\n\tint *chan;\n\tchar *label;\n{\n\treturn (midi_sleep_timo(chan, label, 0));\n}",
    "includes": [
      "#include <dev/midivar.h>",
      "#include <dev/midi_if.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/midiio.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"sequencer.h\"",
      "#include \"midi.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "midi_sleep_timo",
          "args": [
            "chan",
            "label",
            "0"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "midi_sleep_timo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/midi.c",
          "lines": "192-212",
          "snippet": "int\nmidi_sleep_timo(chan, label, timo)\n\tint *chan;\n\tchar *label;\n\tint timo;\n{\n\tint st;\n\n\tif (!label)\n\t\tlabel = \"midi\";\n\n\tDPRINTFN(5, (\"midi_sleep_timo: %p %s %d\\n\", chan, label, timo));\n\t*chan = 1;\n\tst = tsleep(chan, PWAIT | PCATCH, label, timo);\n\t*chan = 0;\n#ifdef MIDI_DEBUG\n\tif (st != 0)\n\t\tprintf(\"midi_sleep: %d\\n\", st);\n#endif\n\treturn (st);\n}",
          "includes": [
            "#include <dev/midivar.h>",
            "#include <dev/midi_if.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/midiio.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"sequencer.h\"",
            "#include \"midi.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n#include \"midi.h\"\n\nint\nmidi_sleep_timo(chan, label, timo)\n\tint *chan;\n\tchar *label;\n\tint timo;\n{\n\tint st;\n\n\tif (!label)\n\t\tlabel = \"midi\";\n\n\tDPRINTFN(5, (\"midi_sleep_timo: %p %s %d\\n\", chan, label, timo));\n\t*chan = 1;\n\tst = tsleep(chan, PWAIT | PCATCH, label, timo);\n\t*chan = 0;\n#ifdef MIDI_DEBUG\n\tif (st != 0)\n\t\tprintf(\"midi_sleep: %d\\n\", st);\n#endif\n\treturn (st);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n#include \"midi.h\"\n\nint\nmidi_sleep(chan, label)\n\tint *chan;\n\tchar *label;\n{\n\treturn (midi_sleep_timo(chan, label, 0));\n}"
  },
  {
    "function_name": "midi_sleep_timo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/midi.c",
    "lines": "192-212",
    "snippet": "int\nmidi_sleep_timo(chan, label, timo)\n\tint *chan;\n\tchar *label;\n\tint timo;\n{\n\tint st;\n\n\tif (!label)\n\t\tlabel = \"midi\";\n\n\tDPRINTFN(5, (\"midi_sleep_timo: %p %s %d\\n\", chan, label, timo));\n\t*chan = 1;\n\tst = tsleep(chan, PWAIT | PCATCH, label, timo);\n\t*chan = 0;\n#ifdef MIDI_DEBUG\n\tif (st != 0)\n\t\tprintf(\"midi_sleep: %d\\n\", st);\n#endif\n\treturn (st);\n}",
    "includes": [
      "#include <dev/midivar.h>",
      "#include <dev/midi_if.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/midiio.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"sequencer.h\"",
      "#include \"midi.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"midi_sleep: %d\\n\"",
            "st"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tsleep",
          "args": [
            "chan",
            "PWAIT | PCATCH",
            "label",
            "timo"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"midi_sleep_timo: %p %s %d\\n\", chan, label, timo)"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n#include \"midi.h\"\n\nint\nmidi_sleep_timo(chan, label, timo)\n\tint *chan;\n\tchar *label;\n\tint timo;\n{\n\tint st;\n\n\tif (!label)\n\t\tlabel = \"midi\";\n\n\tDPRINTFN(5, (\"midi_sleep_timo: %p %s %d\\n\", chan, label, timo));\n\t*chan = 1;\n\tst = tsleep(chan, PWAIT | PCATCH, label, timo);\n\t*chan = 0;\n#ifdef MIDI_DEBUG\n\tif (st != 0)\n\t\tprintf(\"midi_sleep: %d\\n\", st);\n#endif\n\treturn (st);\n}"
  },
  {
    "function_name": "midi_initbuf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/midi.c",
    "lines": "182-190",
    "snippet": "void\nmidi_initbuf(mb)\n\tstruct midi_buffer *mb;\n{\n\tmb->used = 0;\n\tmb->usedhigh = MIDI_BUFSIZE;\n\tmb->end = mb->start + mb->usedhigh;\n\tmb->inp = mb->outp = mb->start;\n}",
    "includes": [
      "#include <dev/midivar.h>",
      "#include <dev/midi_if.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/midiio.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"sequencer.h\"",
      "#include \"midi.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n#include \"midi.h\"\n\nvoid\nmidi_initbuf(mb)\n\tstruct midi_buffer *mb;\n{\n\tmb->used = 0;\n\tmb->usedhigh = MIDI_BUFSIZE;\n\tmb->end = mb->start + mb->usedhigh;\n\tmb->inp = mb->outp = mb->start;\n}"
  },
  {
    "function_name": "midi_unit_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/midi.c",
    "lines": "176-180",
    "snippet": "int\nmidi_unit_count()\n{\n\treturn (midi_cd.cd_ndevs);\n}",
    "includes": [
      "#include <dev/midivar.h>",
      "#include <dev/midi_if.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/midiio.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"sequencer.h\"",
      "#include \"midi.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n#include \"midi.h\"\n\nint\nmidi_unit_count()\n{\n\treturn (midi_cd.cd_ndevs);\n}"
  },
  {
    "function_name": "midi_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/midi.c",
    "lines": "157-174",
    "snippet": "void\nmidi_attach(sc, parent)\n\tstruct midi_softc *sc;\n\tstruct device *parent;\n{\n\tstruct midi_info mi;\n\n\tsc->isopen = 0;\n\n\tmidi_wait = MIDI_WAIT * hz / 1000000;\n\tif (midi_wait == 0)\n\t\tmidi_wait = 1;\n\n\tsc->sc_dev = parent;\n\tsc->hw_if->getinfo(sc->hw_hdl, &mi);\n\tsc->props = mi.props;\n\tprintf(\": <%s>\\n\", mi.name);\n}",
    "includes": [
      "#include <dev/midivar.h>",
      "#include <dev/midi_if.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/midiio.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"sequencer.h\"",
      "#include \"midi.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\": <%s>\\n\"",
            "mi.name"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sc->hw_if->getinfo",
          "args": [
            "sc->hw_hdl",
            "&mi"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n#include \"midi.h\"\n\nvoid\nmidi_attach(sc, parent)\n\tstruct midi_softc *sc;\n\tstruct device *parent;\n{\n\tstruct midi_info mi;\n\n\tsc->isopen = 0;\n\n\tmidi_wait = MIDI_WAIT * hz / 1000000;\n\tif (midi_wait == 0)\n\t\tmidi_wait = 1;\n\n\tsc->sc_dev = parent;\n\tsc->hw_if->getinfo(sc->hw_hdl, &mi);\n\tsc->props = mi.props;\n\tprintf(\": <%s>\\n\", mi.name);\n}"
  },
  {
    "function_name": "midiattach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/midi.c",
    "lines": "130-155",
    "snippet": "void\nmidiattach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct midi_softc *sc = (void *)self;\n\tstruct audio_attach_args *sa = aux;\n\tstruct midi_hw_if *hwp = sa->hwif;\n\tvoid *hdlp = sa->hdl;\n\n\tDPRINTFN(6, (\"MIDI attach\\n\"));\n\n#ifdef DIAGNOSTIC\n\tif (hwp == 0 ||\n\t    hwp->open == 0 ||\n\t    hwp->close == 0 ||\n\t    hwp->output == 0 ||\n\t    hwp->getinfo == 0) {\n\t\tprintf(\"midi: missing method\\n\");\n\t\treturn;\n\t}\n#endif\n\tsc->hw_if = hwp;\n\tsc->hw_hdl = hdlp;\n\tmidi_attach(sc, parent);\n}",
    "includes": [
      "#include <dev/midivar.h>",
      "#include <dev/midi_if.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/midiio.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"sequencer.h\"",
      "#include \"midi.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "midi_attach",
          "args": [
            "sc",
            "parent"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "midi_attach_mi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/midi.c",
          "lines": "749-767",
          "snippet": "void\nmidi_attach_mi(mhwp, hdlp, dev)\n\tstruct midi_hw_if *mhwp;\n\tvoid *hdlp;\n\tstruct device *dev;\n{\n\tstruct audio_attach_args arg;\n\n#ifdef DIAGNOSTIC\n\tif (mhwp == NULL) {\n\t\tprintf(\"midi_attach_mi: NULL\\n\");\n\t\treturn;\n\t}\n#endif\n\targ.type = AUDIODEV_TYPE_MIDI;\n\targ.hwif = mhwp;\n\targ.hdl = hdlp;\n\t(void)config_found(dev, &arg, midiprint);\n}",
          "includes": [
            "#include <dev/midivar.h>",
            "#include <dev/midi_if.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/midiio.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"sequencer.h\"",
            "#include \"midi.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n#include \"midi.h\"\n\nvoid\nmidi_attach_mi(mhwp, hdlp, dev)\n\tstruct midi_hw_if *mhwp;\n\tvoid *hdlp;\n\tstruct device *dev;\n{\n\tstruct audio_attach_args arg;\n\n#ifdef DIAGNOSTIC\n\tif (mhwp == NULL) {\n\t\tprintf(\"midi_attach_mi: NULL\\n\");\n\t\treturn;\n\t}\n#endif\n\targ.type = AUDIODEV_TYPE_MIDI;\n\targ.hwif = mhwp;\n\targ.hdl = hdlp;\n\t(void)config_found(dev, &arg, midiprint);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"midi: missing method\\n\""
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "6",
            "(\"MIDI attach\\n\")"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n#include \"midi.h\"\n\nvoid\nmidiattach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct midi_softc *sc = (void *)self;\n\tstruct audio_attach_args *sa = aux;\n\tstruct midi_hw_if *hwp = sa->hwif;\n\tvoid *hdlp = sa->hdl;\n\n\tDPRINTFN(6, (\"MIDI attach\\n\"));\n\n#ifdef DIAGNOSTIC\n\tif (hwp == 0 ||\n\t    hwp->open == 0 ||\n\t    hwp->close == 0 ||\n\t    hwp->output == 0 ||\n\t    hwp->getinfo == 0) {\n\t\tprintf(\"midi: missing method\\n\");\n\t\treturn;\n\t}\n#endif\n\tsc->hw_if = hwp;\n\tsc->hw_hdl = hdlp;\n\tmidi_attach(sc, parent);\n}"
  }
]