[
  {
    "function_name": "ahc_istagged_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "5823-5842",
    "snippet": "STATIC int\nahc_istagged_device(ahc, xs)\nstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n{\n\tchar channel;\n\tu_int our_id, target;\n\tstruct tmode_tstate *tstate;\n\tstruct ahc_devinfo devinfo;\n\n\tchannel = SIM_CHANNEL(ahc, xs->sc_link);\n\tour_id = SIM_SCSI_ID(ahc, xs->sc_link);\n\ttarget = xs->sc_link->target;\n\t(void)ahc_fetch_transinfo(ahc, channel, our_id, target, &tstate);\n\n\tahc_compile_devinfo(&devinfo, our_id, target,\n\t    xs->sc_link->lun, channel, ROLE_INITIATOR);\n\n\treturn (tstate->tagenable & devinfo.target_mask);\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define STATIC\tstatic",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "ahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));",
      "STATIC void",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
      "STATIC void",
      "STATIC u_int",
      "STATIC void",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
      "STATIC void",
      "STATIC void",
      "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
      "STATIC int",
      "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
      "STATIC void",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));",
      "STATIC int",
      "STATIC int",
      "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
      "STATIC void",
      "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
      "STATIC void",
      "STATIC void",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC u_int",
      "STATIC void",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "STATIC u_int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
      "STATIC void",
      "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "static __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "char channel;",
      "u_int our_id;",
      "struct tmode_tstate **tstate;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "char channel;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *xs;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ahc_compile_devinfo",
          "args": [
            "&devinfo",
            "our_id",
            "target",
            "xs->sc_link->lun",
            "channel",
            "ROLE_INITIATOR"
          ],
          "line": 5838
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_compile_devinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "1568-1586",
          "snippet": "STATIC void\nahc_compile_devinfo(devinfo, our_id, target, lun, channel, role)\n\tstruct ahc_devinfo *devinfo;\n\tu_int our_id;\n\tu_int target;\n\tu_int lun;\n\tchar channel;\n\trole_t role;\n{\n\tdevinfo->our_scsiid = our_id;\n\tdevinfo->target = target;\n\tdevinfo->lun = lun;\n\tdevinfo->target_offset = target;\n\tdevinfo->channel = channel;\n\tdevinfo->role = role;\n\tif (channel == 'B')\n\t\tdevinfo->target_offset += 8;\n\tdevinfo->target_mask = (0x01 << devinfo->target_offset);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC int",
            "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "ahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "char channel;",
            "u_int our_id;",
            "STATIC struct",
            "STATIC struct",
            "STATIC struct",
            "char channel;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nchar channel;\nu_int our_id;\nSTATIC struct;\nSTATIC struct;\nSTATIC struct;\nchar channel;\n\nSTATIC void\nahc_compile_devinfo(devinfo, our_id, target, lun, channel, role)\n\tstruct ahc_devinfo *devinfo;\n\tu_int our_id;\n\tu_int target;\n\tu_int lun;\n\tchar channel;\n\trole_t role;\n{\n\tdevinfo->our_scsiid = our_id;\n\tdevinfo->target = target;\n\tdevinfo->lun = lun;\n\tdevinfo->target_offset = target;\n\tdevinfo->channel = channel;\n\tdevinfo->role = role;\n\tif (channel == 'B')\n\t\tdevinfo->target_offset += 8;\n\tdevinfo->target_mask = (0x01 << devinfo->target_offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_fetch_transinfo",
          "args": [
            "ahc",
            "channel",
            "our_id",
            "target",
            "&tstate"
          ],
          "line": 5836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIM_SCSI_ID",
          "args": [
            "ahc",
            "xs->sc_link"
          ],
          "line": 5834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIM_CHANNEL",
          "args": [
            "ahc",
            "xs->sc_link"
          ],
          "line": 5833
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));\nSTATIC int;\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nSTATIC void;\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nu_int our_id;\nstruct tmode_tstate **tstate;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n\nSTATIC int\nahc_istagged_device(ahc, xs)\nstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n{\n\tchar channel;\n\tu_int our_id, target;\n\tstruct tmode_tstate *tstate;\n\tstruct ahc_devinfo devinfo;\n\n\tchannel = SIM_CHANNEL(ahc, xs->sc_link);\n\tour_id = SIM_SCSI_ID(ahc, xs->sc_link);\n\ttarget = xs->sc_link->target;\n\t(void)ahc_fetch_transinfo(ahc, channel, our_id, target, &tstate);\n\n\tahc_compile_devinfo(&devinfo, our_id, target,\n\t    xs->sc_link->lun, channel, ROLE_INITIATOR);\n\n\treturn (tstate->tagenable & devinfo.target_mask);\n}"
  },
  {
    "function_name": "ahc_check_tags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "5774-5821",
    "snippet": "STATIC void\nahc_check_tags(ahc, xs)\nstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n{\n\tstruct scsi_inquiry_data *inq;\n\tstruct ahc_devinfo devinfo;\n\tint target_id, our_id;\n\n\tif (xs->cmd->opcode != INQUIRY || xs->error != XS_NOERROR)\n\t\treturn;\n\n\ttarget_id = xs->sc_link->target;\n\tour_id = SIM_SCSI_ID(ahc, xs->sc_link);\n\n\t/*\n\t * Sneak a look at the results of the SCSI Inquiry\n\t * command and see if we can do Tagged queing.  This\n\t * should really be done by the higher level drivers.\n\t */\n\tinq = (struct scsi_inquiry_data *)xs->data;\n\tif ((inq->flags & SID_CmdQue) && !(ahc_istagged_device(ahc, xs))) {\n#ifdef AHC_DEBUG \n\t\tprintf(\"%s: target %d using tagged queuing\\n\",\n\t\t\tahc_name(ahc), xs->sc_link->target);\n#endif \n\t\tahc_compile_devinfo(&devinfo,\n\t\t    our_id, target_id, xs->sc_link->lun,\t\n\t\t    SIM_CHANNEL(ahc, xs->sc_link), ROLE_INITIATOR);\n\t\tahc_set_tags(ahc, &devinfo, TRUE);\n\n\t\tif (ahc->scb_data->maxhscbs >= 16 ||\n\t\t    (ahc->flags & AHC_PAGESCBS)) {\n\t\t\t/* Default to 16 tags */\n\t\t\txs->sc_link->openings += 14;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Default to 4 tags on whimpy\n\t\t\t * cards that don't have much SCB\n\t\t\t * space and can't page.  This prevents\n\t\t\t * a single device from hogging all\n\t\t\t * slots.  We should really have a better\n\t\t\t * way of providing fairness.\n\t\t\t */\n\t\t\txs->sc_link->openings += 2;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define STATIC\tstatic",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "ahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));",
      "STATIC void",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
      "STATIC void",
      "STATIC void",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
      "STATIC void",
      "STATIC void",
      "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
      "STATIC int",
      "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
      "STATIC void",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));",
      "STATIC int",
      "STATIC int",
      "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
      "STATIC void",
      "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
      "STATIC void",
      "STATIC void",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));",
      "STATIC void",
      "ahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));",
      "STATIC void",
      "STATIC int",
      "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
      "STATIC void",
      "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "u_int our_id;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *xs;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ahc_set_tags",
          "args": [
            "ahc",
            "&devinfo",
            "TRUE"
          ],
          "line": 5803
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_set_tags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "1459-1476",
          "snippet": "STATIC void\nahc_set_tags(ahc, devinfo, enable)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n\tint enable;\n{\n\tstruct ahc_initiator_tinfo *tinfo;\n\tstruct tmode_tstate *tstate;\n\n\ttinfo = ahc_fetch_transinfo(ahc, devinfo->channel,\n\t\t\t\t    devinfo->our_scsiid,\n\t\t\t\t    devinfo->target,\n\t\t\t\t    &tstate);\n\tif (enable)\n\t\ttstate->tagenable |= devinfo->target_mask;\n\telse\n\t\ttstate->tagenable &= ~devinfo->target_mask;\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC int",
            "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_set_tags __P((struct ahc_softc *ahc,\n\t\t\t\t  struct ahc_devinfo *devinfo,int enable));",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "static __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct tmode_tstate **tstate;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_set_tags __P((struct ahc_softc *ahc,\n\t\t\t\t  struct ahc_devinfo *devinfo,int enable));\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct tmode_tstate **tstate;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_set_tags(ahc, devinfo, enable)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n\tint enable;\n{\n\tstruct ahc_initiator_tinfo *tinfo;\n\tstruct tmode_tstate *tstate;\n\n\ttinfo = ahc_fetch_transinfo(ahc, devinfo->channel,\n\t\t\t\t    devinfo->our_scsiid,\n\t\t\t\t    devinfo->target,\n\t\t\t\t    &tstate);\n\tif (enable)\n\t\ttstate->tagenable |= devinfo->target_mask;\n\telse\n\t\ttstate->tagenable &= ~devinfo->target_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_compile_devinfo",
          "args": [
            "&devinfo",
            "our_id",
            "target_id",
            "xs->sc_link->lun",
            "SIM_CHANNEL(ahc, xs->sc_link)",
            "ROLE_INITIATOR"
          ],
          "line": 5800
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_compile_devinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "1568-1586",
          "snippet": "STATIC void\nahc_compile_devinfo(devinfo, our_id, target, lun, channel, role)\n\tstruct ahc_devinfo *devinfo;\n\tu_int our_id;\n\tu_int target;\n\tu_int lun;\n\tchar channel;\n\trole_t role;\n{\n\tdevinfo->our_scsiid = our_id;\n\tdevinfo->target = target;\n\tdevinfo->lun = lun;\n\tdevinfo->target_offset = target;\n\tdevinfo->channel = channel;\n\tdevinfo->role = role;\n\tif (channel == 'B')\n\t\tdevinfo->target_offset += 8;\n\tdevinfo->target_mask = (0x01 << devinfo->target_offset);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC int",
            "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "ahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "char channel;",
            "u_int our_id;",
            "STATIC struct",
            "STATIC struct",
            "STATIC struct",
            "char channel;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nchar channel;\nu_int our_id;\nSTATIC struct;\nSTATIC struct;\nSTATIC struct;\nchar channel;\n\nSTATIC void\nahc_compile_devinfo(devinfo, our_id, target, lun, channel, role)\n\tstruct ahc_devinfo *devinfo;\n\tu_int our_id;\n\tu_int target;\n\tu_int lun;\n\tchar channel;\n\trole_t role;\n{\n\tdevinfo->our_scsiid = our_id;\n\tdevinfo->target = target;\n\tdevinfo->lun = lun;\n\tdevinfo->target_offset = target;\n\tdevinfo->channel = channel;\n\tdevinfo->role = role;\n\tif (channel == 'B')\n\t\tdevinfo->target_offset += 8;\n\tdevinfo->target_mask = (0x01 << devinfo->target_offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIM_CHANNEL",
          "args": [
            "ahc",
            "xs->sc_link"
          ],
          "line": 5802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: target %d using tagged queuing\\n\"",
            "ahc_name(ahc)",
            "xs->sc_link->target"
          ],
          "line": 5797
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 5798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_istagged_device",
          "args": [
            "ahc",
            "xs"
          ],
          "line": 5795
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_istagged_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "5823-5842",
          "snippet": "STATIC int\nahc_istagged_device(ahc, xs)\nstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n{\n\tchar channel;\n\tu_int our_id, target;\n\tstruct tmode_tstate *tstate;\n\tstruct ahc_devinfo devinfo;\n\n\tchannel = SIM_CHANNEL(ahc, xs->sc_link);\n\tour_id = SIM_SCSI_ID(ahc, xs->sc_link);\n\ttarget = xs->sc_link->target;\n\t(void)ahc_fetch_transinfo(ahc, channel, our_id, target, &tstate);\n\n\tahc_compile_devinfo(&devinfo, our_id, target,\n\t    xs->sc_link->lun, channel, ROLE_INITIATOR);\n\n\treturn (tstate->tagenable & devinfo.target_mask);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "ahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC int",
            "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));",
            "STATIC int",
            "STATIC int",
            "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
            "STATIC void",
            "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "static __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "u_int our_id;",
            "struct tmode_tstate **tstate;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *xs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));\nSTATIC int;\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nSTATIC void;\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nu_int our_id;\nstruct tmode_tstate **tstate;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n\nSTATIC int\nahc_istagged_device(ahc, xs)\nstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n{\n\tchar channel;\n\tu_int our_id, target;\n\tstruct tmode_tstate *tstate;\n\tstruct ahc_devinfo devinfo;\n\n\tchannel = SIM_CHANNEL(ahc, xs->sc_link);\n\tour_id = SIM_SCSI_ID(ahc, xs->sc_link);\n\ttarget = xs->sc_link->target;\n\t(void)ahc_fetch_transinfo(ahc, channel, our_id, target, &tstate);\n\n\tahc_compile_devinfo(&devinfo, our_id, target,\n\t    xs->sc_link->lun, channel, ROLE_INITIATOR);\n\n\treturn (tstate->tagenable & devinfo.target_mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIM_SCSI_ID",
          "args": [
            "ahc",
            "xs->sc_link"
          ],
          "line": 5787
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));\nSTATIC int;\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));\nSTATIC void;\nahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));\nSTATIC void;\nSTATIC int;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nSTATIC void;\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nu_int our_id;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n\nSTATIC void\nahc_check_tags(ahc, xs)\nstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n{\n\tstruct scsi_inquiry_data *inq;\n\tstruct ahc_devinfo devinfo;\n\tint target_id, our_id;\n\n\tif (xs->cmd->opcode != INQUIRY || xs->error != XS_NOERROR)\n\t\treturn;\n\n\ttarget_id = xs->sc_link->target;\n\tour_id = SIM_SCSI_ID(ahc, xs->sc_link);\n\n\t/*\n\t * Sneak a look at the results of the SCSI Inquiry\n\t * command and see if we can do Tagged queing.  This\n\t * should really be done by the higher level drivers.\n\t */\n\tinq = (struct scsi_inquiry_data *)xs->data;\n\tif ((inq->flags & SID_CmdQue) && !(ahc_istagged_device(ahc, xs))) {\n#ifdef AHC_DEBUG \n\t\tprintf(\"%s: target %d using tagged queuing\\n\",\n\t\t\tahc_name(ahc), xs->sc_link->target);\n#endif \n\t\tahc_compile_devinfo(&devinfo,\n\t\t    our_id, target_id, xs->sc_link->lun,\t\n\t\t    SIM_CHANNEL(ahc, xs->sc_link), ROLE_INITIATOR);\n\t\tahc_set_tags(ahc, &devinfo, TRUE);\n\n\t\tif (ahc->scb_data->maxhscbs >= 16 ||\n\t\t    (ahc->flags & AHC_PAGESCBS)) {\n\t\t\t/* Default to 16 tags */\n\t\t\txs->sc_link->openings += 14;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Default to 4 tags on whimpy\n\t\t\t * cards that don't have much SCB\n\t\t\t * space and can't page.  This prevents\n\t\t\t * a single device from hogging all\n\t\t\t * slots.  We should really have a better\n\t\t\t * way of providing fairness.\n\t\t\t */\n\t\t\txs->sc_link->openings += 2;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "ahc_shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "5724-5772",
    "snippet": "STATIC void\nahc_shutdown(void *arg)\n{\n\tstruct\tahc_softc *ahc;\n\tint\ti;\n\tu_int\tsxfrctl1_a, sxfrctl1_b;\n\n\tahc = (struct ahc_softc *)arg;\n\n\tpause_sequencer(ahc);\n\n\t/*\n\t * Preserve the value of the SXFRCTL1 register for all channels.\n\t * It contains settings that affect termination and we don't want\n\t * to disturb the integrity of the bus during shutdown in case\n\t * we are in a multi-initiator setup.\n\t */\n\tsxfrctl1_b = 0;\n\tif ((ahc->features & AHC_TWIN) != 0) {\n\t\tu_int sblkctl;\n\n\t\tsblkctl = ahc_inb(ahc, SBLKCTL);\n\t\tahc_outb(ahc, SBLKCTL, sblkctl | SELBUSB);\n\t\tsxfrctl1_b = ahc_inb(ahc, SXFRCTL1);\n\t\tahc_outb(ahc, SBLKCTL, sblkctl & ~SELBUSB);\n\t}\n\n\tsxfrctl1_a = ahc_inb(ahc, SXFRCTL1);\n\n\t/* This will reset most registers to 0, but not all */\n\tahc_reset(ahc);\n\n\tif ((ahc->features & AHC_TWIN) != 0) {\n\t\tu_int sblkctl;\n\n\t\tsblkctl = ahc_inb(ahc, SBLKCTL);\n\t\tahc_outb(ahc, SBLKCTL, sblkctl | SELBUSB);\n\t\tahc_outb(ahc, SXFRCTL1, sxfrctl1_b);\n\t\tahc_outb(ahc, SBLKCTL, sblkctl & ~SELBUSB);\n\t}\n\tahc_outb(ahc, SXFRCTL1, sxfrctl1_a);\n\n\tahc_outb(ahc, SCSISEQ, 0);\n\tahc_outb(ahc, SXFRCTL0, 0);\n\tahc_outb(ahc, DSPCISTATUS, 0);\n\n\tfor (i = TARG_SCSIRATE; i < HA_274_BIOSCTRL; i++)\n\t\tahc_outb(ahc, i, 0);\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define STATIC\tstatic",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "STATIC int",
      "STATIC void",
      "ahc_shutdown __P((void *arg));",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC u_int",
      "STATIC void",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC u_int",
      "STATIC void",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "STATIC u_int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "static __inline void pause_sequencer",
      "STATIC void",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "i",
            "0"
          ],
          "line": 5771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "DSPCISTATUS",
            "0"
          ],
          "line": 5768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SXFRCTL0",
            "0"
          ],
          "line": 5767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCSISEQ",
            "0"
          ],
          "line": 5766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SXFRCTL1",
            "sxfrctl1_a"
          ],
          "line": 5764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SBLKCTL",
            "sblkctl & ~SELBUSB"
          ],
          "line": 5762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SXFRCTL1",
            "sxfrctl1_b"
          ],
          "line": 5761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SBLKCTL",
            "sblkctl | SELBUSB"
          ],
          "line": 5760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SBLKCTL"
          ],
          "line": 5759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_reset",
          "args": [
            "ahc"
          ],
          "line": 5754
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_reset_channel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "5412-5527",
          "snippet": "STATIC int\nahc_reset_channel(ahc, channel, initiate_reset)\n\tstruct ahc_softc *ahc;\n\tchar channel;\n\tint initiate_reset;\n{\n\tu_int\tinitiator, target, max_scsiid;\n\tu_int\tsblkctl;\n\tu_int\tour_id;\n\tint\tfound;\n\tint\trestart_needed;\n\tchar\tcur_channel;\n\n\tahc->pending_device = NULL;\n\n\tpause_sequencer(ahc);\n\n\t/*\n\t * Run our command complete fifos to ensure that we perform\n\t * completion processing on any commands that 'completed'\n\t * before the reset occurred.\n\t */\n\tahc_run_qoutfifo(ahc);\n\n\t/*\n\t * Reset the bus if we are initiating this reset\n\t */\n\tsblkctl = ahc_inb(ahc, SBLKCTL);\n\tcur_channel = 'A';\n\tif ((ahc->features & AHC_TWIN) != 0\n\t && ((sblkctl & SELBUSB) != 0))\n\t    cur_channel = 'B';\n\tif (cur_channel != channel) {\n\t\t/* Case 1: Command for another bus is active\n\t\t * Stealthily reset the other bus without\n\t\t * upsetting the current bus.\n\t\t */\n\t\tahc_outb(ahc, SBLKCTL, sblkctl ^ SELBUSB);\n\t\tahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENBUSFREE);\n\t\tahc_outb(ahc, SCSISEQ,\n\t\t\t ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP));\n\t\tif (initiate_reset)\n\t\t\tahc_reset_current_bus(ahc);\n\t\tahc_clear_intstat(ahc);\n\t\tahc_outb(ahc, SBLKCTL, sblkctl);\n\t\trestart_needed = FALSE;\n\t} else {\n\t\t/* Case 2: A command from this bus is active or we're idle */\n\t\tahc_clear_msg_state(ahc);\n\t\tahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENBUSFREE);\n\t\tahc_outb(ahc, SCSISEQ,\n\t\t\t ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP));\n\t\tif (initiate_reset)\n\t\t\tahc_reset_current_bus(ahc);\n\t\tahc_clear_intstat(ahc);\n\n\t\t/*\n\t\t * Since we are going to restart the sequencer, avoid\n\t\t * a race in the sequencer that could cause corruption\n\t\t * of our Q pointers by starting over from index 0.\n\t\t */\n\t\tahc->qoutfifonext = 0;\n\t\tif ((ahc->features & AHC_QUEUE_REGS) != 0)\n\t\t\tahc_outb(ahc, SDSCB_QOFF, 0);\n\t\telse\n\t\t\tahc_outb(ahc, QOUTPOS, 0);\n\t\trestart_needed = TRUE;\n\t}\n\n\t/*\n\t * Clean up all the state information for the\n\t * pending transactions on this bus.\n\t */\n\tfound = ahc_abort_scbs(ahc, ALL_TARGETS, channel,\n\t\t\t       ALL_LUNS, SCB_LIST_NULL,\n\t\t\t       ROLE_UNKNOWN, XS_RESET);\n\tif (channel == 'B') {\n\t\tour_id = ahc->our_id_b;\n\t} else {\n\t\tour_id = ahc->our_id;\n\t}\n\n\tmax_scsiid = (ahc->features & AHC_WIDE) ? 15 : 7;\n\t\n\t/*\n\t * Revert to async/narrow transfers until we renegotiate.\n\t */\n\tfor (target = 0; target <= max_scsiid; target++) {\n\n\t\tif (ahc->enabled_targets[target] == NULL)\n\t\t\tcontinue;\n\t\tfor (initiator = 0; initiator <= max_scsiid; initiator++) {\n\t\t\tstruct ahc_devinfo devinfo;\n\n\t\t\tahc_compile_devinfo(&devinfo, target, initiator,\n\t\t\t\t\t    ALL_LUNS,\n\t\t\t\t\t    channel, ROLE_UNKNOWN);\n\t\t\tahc_set_width(ahc, &devinfo,\n\t\t\t\t      MSG_EXT_WDTR_BUS_8_BIT,\n\t\t\t\t      AHC_TRANS_CUR,\n\t\t\t\t      /*paused*/TRUE,\n\t\t\t\t      /*done*/FALSE);\n\t\t\tahc_set_syncrate(ahc, &devinfo,\n\t\t\t\t\t /*syncrate*/NULL, /*period*/0,\n\t\t\t\t\t /*offset*/0, AHC_TRANS_CUR,\n\t\t\t\t\t /*paused*/TRUE,\n\t\t\t\t\t /*done*/FALSE);\n\t\t}\n\t}\n\n\tif (restart_needed)\n\t\trestart_sequencer(ahc);\n\telse\n\t\tunpause_sequencer(ahc);\n\treturn found;\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC int",
            "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "ahc_reset_channel __P((struct ahc_softc *ahc, char channel,\n\t\t\t\t       int initiate_reset));",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "ahc_update_target_msg_request __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t\t      struct ahc_initiator_tinfo *tinfo,\n\t\t\t\t\t      int force, int paused));",
            "STATIC void",
            "ahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));",
            "STATIC void",
            "ahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "static __inline void pause_sequencer",
            "static __inline void unpause_sequencer",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "u_int our_id;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "u_int *period;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "u_int *period;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nahc_reset_channel __P((struct ahc_softc *ahc, char channel,\n\t\t\t\t       int initiate_reset));\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nahc_update_target_msg_request __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t\t      struct ahc_initiator_tinfo *tinfo,\n\t\t\t\t\t      int force, int paused));\nSTATIC void;\nahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));\nSTATIC void;\nahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nstatic __inline void pause_sequencer;\nstatic __inline void unpause_sequencer;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nu_int our_id;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC int\nahc_reset_channel(ahc, channel, initiate_reset)\n\tstruct ahc_softc *ahc;\n\tchar channel;\n\tint initiate_reset;\n{\n\tu_int\tinitiator, target, max_scsiid;\n\tu_int\tsblkctl;\n\tu_int\tour_id;\n\tint\tfound;\n\tint\trestart_needed;\n\tchar\tcur_channel;\n\n\tahc->pending_device = NULL;\n\n\tpause_sequencer(ahc);\n\n\t/*\n\t * Run our command complete fifos to ensure that we perform\n\t * completion processing on any commands that 'completed'\n\t * before the reset occurred.\n\t */\n\tahc_run_qoutfifo(ahc);\n\n\t/*\n\t * Reset the bus if we are initiating this reset\n\t */\n\tsblkctl = ahc_inb(ahc, SBLKCTL);\n\tcur_channel = 'A';\n\tif ((ahc->features & AHC_TWIN) != 0\n\t && ((sblkctl & SELBUSB) != 0))\n\t    cur_channel = 'B';\n\tif (cur_channel != channel) {\n\t\t/* Case 1: Command for another bus is active\n\t\t * Stealthily reset the other bus without\n\t\t * upsetting the current bus.\n\t\t */\n\t\tahc_outb(ahc, SBLKCTL, sblkctl ^ SELBUSB);\n\t\tahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENBUSFREE);\n\t\tahc_outb(ahc, SCSISEQ,\n\t\t\t ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP));\n\t\tif (initiate_reset)\n\t\t\tahc_reset_current_bus(ahc);\n\t\tahc_clear_intstat(ahc);\n\t\tahc_outb(ahc, SBLKCTL, sblkctl);\n\t\trestart_needed = FALSE;\n\t} else {\n\t\t/* Case 2: A command from this bus is active or we're idle */\n\t\tahc_clear_msg_state(ahc);\n\t\tahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENBUSFREE);\n\t\tahc_outb(ahc, SCSISEQ,\n\t\t\t ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP));\n\t\tif (initiate_reset)\n\t\t\tahc_reset_current_bus(ahc);\n\t\tahc_clear_intstat(ahc);\n\n\t\t/*\n\t\t * Since we are going to restart the sequencer, avoid\n\t\t * a race in the sequencer that could cause corruption\n\t\t * of our Q pointers by starting over from index 0.\n\t\t */\n\t\tahc->qoutfifonext = 0;\n\t\tif ((ahc->features & AHC_QUEUE_REGS) != 0)\n\t\t\tahc_outb(ahc, SDSCB_QOFF, 0);\n\t\telse\n\t\t\tahc_outb(ahc, QOUTPOS, 0);\n\t\trestart_needed = TRUE;\n\t}\n\n\t/*\n\t * Clean up all the state information for the\n\t * pending transactions on this bus.\n\t */\n\tfound = ahc_abort_scbs(ahc, ALL_TARGETS, channel,\n\t\t\t       ALL_LUNS, SCB_LIST_NULL,\n\t\t\t       ROLE_UNKNOWN, XS_RESET);\n\tif (channel == 'B') {\n\t\tour_id = ahc->our_id_b;\n\t} else {\n\t\tour_id = ahc->our_id;\n\t}\n\n\tmax_scsiid = (ahc->features & AHC_WIDE) ? 15 : 7;\n\t\n\t/*\n\t * Revert to async/narrow transfers until we renegotiate.\n\t */\n\tfor (target = 0; target <= max_scsiid; target++) {\n\n\t\tif (ahc->enabled_targets[target] == NULL)\n\t\t\tcontinue;\n\t\tfor (initiator = 0; initiator <= max_scsiid; initiator++) {\n\t\t\tstruct ahc_devinfo devinfo;\n\n\t\t\tahc_compile_devinfo(&devinfo, target, initiator,\n\t\t\t\t\t    ALL_LUNS,\n\t\t\t\t\t    channel, ROLE_UNKNOWN);\n\t\t\tahc_set_width(ahc, &devinfo,\n\t\t\t\t      MSG_EXT_WDTR_BUS_8_BIT,\n\t\t\t\t      AHC_TRANS_CUR,\n\t\t\t\t      /*paused*/TRUE,\n\t\t\t\t      /*done*/FALSE);\n\t\t\tahc_set_syncrate(ahc, &devinfo,\n\t\t\t\t\t /*syncrate*/NULL, /*period*/0,\n\t\t\t\t\t /*offset*/0, AHC_TRANS_CUR,\n\t\t\t\t\t /*paused*/TRUE,\n\t\t\t\t\t /*done*/FALSE);\n\t\t}\n\t}\n\n\tif (restart_needed)\n\t\trestart_sequencer(ahc);\n\telse\n\t\tunpause_sequencer(ahc);\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SXFRCTL1"
          ],
          "line": 5751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SBLKCTL",
            "sblkctl & ~SELBUSB"
          ],
          "line": 5748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SXFRCTL1"
          ],
          "line": 5747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SBLKCTL",
            "sblkctl | SELBUSB"
          ],
          "line": 5746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SBLKCTL"
          ],
          "line": 5745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pause_sequencer",
          "args": [
            "ahc"
          ],
          "line": 5733
        },
        "resolved": true,
        "details": {
          "function_name": "unpause_sequencer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "456-462",
          "snippet": "static __inline void\nunpause_sequencer(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tif ((ahc_inb(ahc, INTSTAT) & (SCSIINT | SEQINT | BRKADRINT)) == 0)\n\t\tahc_outb(ahc, HCNTRL, ahc->unpause);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "static __inline void unpause_sequencer",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC struct;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nahc_loadseq __P((struct ahc_softc *ahc));\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nahc_clear_intstat __P((struct ahc_softc *ahc));\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nstatic __inline void unpause_sequencer;\nrestart_sequencer __P((struct ahc_softc *ahc));\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nstatic __inline void\nunpause_sequencer(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tif ((ahc_inb(ahc, INTSTAT) & (SCSIINT | SEQINT | BRKADRINT)) == 0)\n\t\tahc_outb(ahc, HCNTRL, ahc->unpause);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nahc_shutdown __P((void *arg));\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nstatic __inline void pause_sequencer;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_shutdown(void *arg)\n{\n\tstruct\tahc_softc *ahc;\n\tint\ti;\n\tu_int\tsxfrctl1_a, sxfrctl1_b;\n\n\tahc = (struct ahc_softc *)arg;\n\n\tpause_sequencer(ahc);\n\n\t/*\n\t * Preserve the value of the SXFRCTL1 register for all channels.\n\t * It contains settings that affect termination and we don't want\n\t * to disturb the integrity of the bus during shutdown in case\n\t * we are in a multi-initiator setup.\n\t */\n\tsxfrctl1_b = 0;\n\tif ((ahc->features & AHC_TWIN) != 0) {\n\t\tu_int sblkctl;\n\n\t\tsblkctl = ahc_inb(ahc, SBLKCTL);\n\t\tahc_outb(ahc, SBLKCTL, sblkctl | SELBUSB);\n\t\tsxfrctl1_b = ahc_inb(ahc, SXFRCTL1);\n\t\tahc_outb(ahc, SBLKCTL, sblkctl & ~SELBUSB);\n\t}\n\n\tsxfrctl1_a = ahc_inb(ahc, SXFRCTL1);\n\n\t/* This will reset most registers to 0, but not all */\n\tahc_reset(ahc);\n\n\tif ((ahc->features & AHC_TWIN) != 0) {\n\t\tu_int sblkctl;\n\n\t\tsblkctl = ahc_inb(ahc, SBLKCTL);\n\t\tahc_outb(ahc, SBLKCTL, sblkctl | SELBUSB);\n\t\tahc_outb(ahc, SXFRCTL1, sxfrctl1_b);\n\t\tahc_outb(ahc, SBLKCTL, sblkctl & ~SELBUSB);\n\t}\n\tahc_outb(ahc, SXFRCTL1, sxfrctl1_a);\n\n\tahc_outb(ahc, SCSISEQ, 0);\n\tahc_outb(ahc, SXFRCTL0, 0);\n\tahc_outb(ahc, DSPCISTATUS, 0);\n\n\tfor (i = TARG_SCSIRATE; i < HA_274_BIOSCTRL; i++)\n\t\tahc_outb(ahc, i, 0);\n}"
  },
  {
    "function_name": "ahc_update_pending_syncrates",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "5633-5722",
    "snippet": "STATIC void\nahc_update_pending_syncrates(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tstruct\tscb *scb;\n\tint\tpending_scb_count;\n\tint\ti;\n\tu_int\tsaved_scbptr;\n\n\t/*\n\t * Traverse the pending SCB list and ensure that all of the\n\t * SCBs there have the proper settings.\n\t */\n\tscb = LIST_FIRST(&ahc->pending_scbs);\n\tpending_scb_count = 0;\n\twhile (scb != NULL) {\n\t\tstruct ahc_devinfo devinfo;\n\t\tstruct scsi_xfer *xs;\n\t\tstruct scb *pending_scb;\n\t\tstruct hardware_scb *pending_hscb;\n\t\tstruct ahc_initiator_tinfo *tinfo;\n\t\tstruct tmode_tstate *tstate;\n\t\tu_int  our_id, remote_id;\n\t\t\n\t\txs = scb->xs;\n\t\tpending_scb = scb;\n\t\tpending_hscb = pending_scb->hscb;\n\t\tour_id = SCB_IS_SCSIBUS_B(pending_scb)\n\t\t       ? ahc->our_id_b : ahc->our_id;\n\t\tremote_id = xs->sc_link->target;\n\t\tahc_compile_devinfo(&devinfo, our_id, remote_id,\n\t\t\t\t    SCB_LUN(pending_scb),\n\t\t\t\t    SCB_CHANNEL(pending_scb),\n\t\t\t\t    ROLE_UNKNOWN);\n\t\ttinfo = ahc_fetch_transinfo(ahc, devinfo.channel,\n\t\t\t\t\t    our_id, remote_id, &tstate);\n\t\tpending_hscb->control &= ~ULTRAENB;\n\t\tif ((tstate->ultraenb & devinfo.target_mask) != 0)\n\t\t\tpending_hscb->control |= ULTRAENB;\n\t\tpending_hscb->scsirate = tinfo->scsirate;\n\t\tpending_hscb->scsioffset = tinfo->current.offset;\n\t\tpending_scb_count++;\n\t\tscb = LIST_NEXT(scb, pend_links);\n\t}\n\n\tif (pending_scb_count == 0)\n\t\treturn;\n\n\tsaved_scbptr = ahc_inb(ahc, SCBPTR);\n\t/* Ensure that the hscbs down on the card match the new information */\n\tfor (i = 0; i < ahc->scb_data->maxhscbs; i++) {\n\t\tu_int scb_tag;\n\n\t\tahc_outb(ahc, SCBPTR, i);\n\t\tscb_tag = ahc_inb(ahc, SCB_TAG);\n\t\tif (scb_tag != SCB_LIST_NULL) {\n\t\t\tstruct\tahc_devinfo devinfo;\n\t\t\tstruct\tscb *pending_scb;\n\t\t\tstruct scsi_xfer *xs;\n\t\t\tstruct\thardware_scb *pending_hscb;\n\t\t\tstruct\tahc_initiator_tinfo *tinfo;\n\t\t\tstruct\ttmode_tstate *tstate;\n\t\t\tu_int\tour_id, remote_id;\n\t\t\tu_int\tcontrol;\n\n\t\t\tpending_scb = &ahc->scb_data->scbarray[scb_tag];\n\t\t\tif (pending_scb->flags == SCB_FREE)\n\t\t\t\tcontinue;\n\t\t\tpending_hscb = pending_scb->hscb;\n\t\t\txs = pending_scb->xs;\n\t\t\tour_id = SCB_IS_SCSIBUS_B(pending_scb)\n\t\t\t       ? ahc->our_id_b : ahc->our_id;\n\t\t\tremote_id = xs->sc_link->target;\n\t\t\tahc_compile_devinfo(&devinfo, our_id, remote_id,\n\t\t\t\t\t    SCB_LUN(pending_scb),\n\t\t\t\t\t    SCB_CHANNEL(pending_scb),\n\t\t\t\t\t    ROLE_UNKNOWN);\n\t\t\ttinfo = ahc_fetch_transinfo(ahc, devinfo.channel,\n\t\t\t\t\t\t    our_id, remote_id, &tstate);\n\t\t\tcontrol = ahc_inb(ahc, SCB_CONTROL);\n\t\t\tcontrol &= ~ULTRAENB;\n\t\t\tif ((tstate->ultraenb & devinfo.target_mask) != 0)\n\t\t\t\tcontrol |= ULTRAENB;\n\t\t\tahc_outb(ahc, SCB_CONTROL, control);\n\t\t\tahc_outb(ahc, SCB_SCSIRATE, tinfo->scsirate);\n\t\t\tahc_outb(ahc, SCB_SCSIOFFSET, tinfo->current.offset);\n\t\t}\n\t}\n\tahc_outb(ahc, SCBPTR, saved_scbptr);\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define STATIC\tstatic",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
      "STATIC void",
      "ahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));",
      "STATIC void",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
      "STATIC void",
      "STATIC u_int",
      "STATIC void",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
      "STATIC void",
      "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
      "STATIC void",
      "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
      "STATIC int",
      "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
      "STATIC void",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));",
      "STATIC int",
      "STATIC int",
      "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
      "STATIC void",
      "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
      "STATIC void",
      "STATIC void",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC u_int",
      "STATIC void",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "STATIC u_int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
      "STATIC void",
      "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
      "STATIC void",
      "ahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));",
      "STATIC void",
      "STATIC void",
      "ahc_calc_residual __P((struct scb *scb));",
      "STATIC void",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
      "STATIC void",
      "STATIC void",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "static __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo",
      "STATIC void",
      "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
      "STATIC void",
      "STATIC void",
      "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "char channel;",
      "u_int our_id;",
      "u_int remote_id;",
      "struct tmode_tstate **tstate;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "char channel;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *xs;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCBPTR",
            "saved_scbptr"
          ],
          "line": 5721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCB_SCSIOFFSET",
            "tinfo->current.offset"
          ],
          "line": 5718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCB_SCSIRATE",
            "tinfo->scsirate"
          ],
          "line": 5717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCB_CONTROL",
            "control"
          ],
          "line": 5716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCB_CONTROL"
          ],
          "line": 5712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_fetch_transinfo",
          "args": [
            "ahc",
            "devinfo.channel",
            "our_id",
            "remote_id",
            "&tstate"
          ],
          "line": 5710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_compile_devinfo",
          "args": [
            "&devinfo",
            "our_id",
            "remote_id",
            "SCB_LUN(pending_scb)",
            "SCB_CHANNEL(pending_scb)",
            "ROLE_UNKNOWN"
          ],
          "line": 5706
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_compile_devinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "1568-1586",
          "snippet": "STATIC void\nahc_compile_devinfo(devinfo, our_id, target, lun, channel, role)\n\tstruct ahc_devinfo *devinfo;\n\tu_int our_id;\n\tu_int target;\n\tu_int lun;\n\tchar channel;\n\trole_t role;\n{\n\tdevinfo->our_scsiid = our_id;\n\tdevinfo->target = target;\n\tdevinfo->lun = lun;\n\tdevinfo->target_offset = target;\n\tdevinfo->channel = channel;\n\tdevinfo->role = role;\n\tif (channel == 'B')\n\t\tdevinfo->target_offset += 8;\n\tdevinfo->target_mask = (0x01 << devinfo->target_offset);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC int",
            "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "ahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "char channel;",
            "u_int our_id;",
            "STATIC struct",
            "STATIC struct",
            "STATIC struct",
            "char channel;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nchar channel;\nu_int our_id;\nSTATIC struct;\nSTATIC struct;\nSTATIC struct;\nchar channel;\n\nSTATIC void\nahc_compile_devinfo(devinfo, our_id, target, lun, channel, role)\n\tstruct ahc_devinfo *devinfo;\n\tu_int our_id;\n\tu_int target;\n\tu_int lun;\n\tchar channel;\n\trole_t role;\n{\n\tdevinfo->our_scsiid = our_id;\n\tdevinfo->target = target;\n\tdevinfo->lun = lun;\n\tdevinfo->target_offset = target;\n\tdevinfo->channel = channel;\n\tdevinfo->role = role;\n\tif (channel == 'B')\n\t\tdevinfo->target_offset += 8;\n\tdevinfo->target_mask = (0x01 << devinfo->target_offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SCB_CHANNEL",
          "args": [
            "pending_scb"
          ],
          "line": 5708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCB_LUN",
          "args": [
            "pending_scb"
          ],
          "line": 5707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCB_IS_SCSIBUS_B",
          "args": [
            "pending_scb"
          ],
          "line": 5703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCB_TAG"
          ],
          "line": 5687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCBPTR",
            "i"
          ],
          "line": 5686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCBPTR"
          ],
          "line": 5681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_NEXT",
          "args": [
            "scb",
            "pend_links"
          ],
          "line": 5675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_fetch_transinfo",
          "args": [
            "ahc",
            "devinfo.channel",
            "our_id",
            "remote_id",
            "&tstate"
          ],
          "line": 5667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCB_CHANNEL",
          "args": [
            "pending_scb"
          ],
          "line": 5665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCB_LUN",
          "args": [
            "pending_scb"
          ],
          "line": 5664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCB_IS_SCSIBUS_B",
          "args": [
            "pending_scb"
          ],
          "line": 5660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_FIRST",
          "args": [
            "&ahc->pending_scbs"
          ],
          "line": 5646
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nSTATIC void;\nahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));\nSTATIC int;\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nSTATIC void;\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nSTATIC void;\nahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));\nSTATIC void;\nSTATIC void;\nahc_calc_residual __P((struct scb *scb));\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo;\nSTATIC void;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nu_int our_id;\nu_int remote_id;\nstruct tmode_tstate **tstate;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n\nSTATIC void\nahc_update_pending_syncrates(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tstruct\tscb *scb;\n\tint\tpending_scb_count;\n\tint\ti;\n\tu_int\tsaved_scbptr;\n\n\t/*\n\t * Traverse the pending SCB list and ensure that all of the\n\t * SCBs there have the proper settings.\n\t */\n\tscb = LIST_FIRST(&ahc->pending_scbs);\n\tpending_scb_count = 0;\n\twhile (scb != NULL) {\n\t\tstruct ahc_devinfo devinfo;\n\t\tstruct scsi_xfer *xs;\n\t\tstruct scb *pending_scb;\n\t\tstruct hardware_scb *pending_hscb;\n\t\tstruct ahc_initiator_tinfo *tinfo;\n\t\tstruct tmode_tstate *tstate;\n\t\tu_int  our_id, remote_id;\n\t\t\n\t\txs = scb->xs;\n\t\tpending_scb = scb;\n\t\tpending_hscb = pending_scb->hscb;\n\t\tour_id = SCB_IS_SCSIBUS_B(pending_scb)\n\t\t       ? ahc->our_id_b : ahc->our_id;\n\t\tremote_id = xs->sc_link->target;\n\t\tahc_compile_devinfo(&devinfo, our_id, remote_id,\n\t\t\t\t    SCB_LUN(pending_scb),\n\t\t\t\t    SCB_CHANNEL(pending_scb),\n\t\t\t\t    ROLE_UNKNOWN);\n\t\ttinfo = ahc_fetch_transinfo(ahc, devinfo.channel,\n\t\t\t\t\t    our_id, remote_id, &tstate);\n\t\tpending_hscb->control &= ~ULTRAENB;\n\t\tif ((tstate->ultraenb & devinfo.target_mask) != 0)\n\t\t\tpending_hscb->control |= ULTRAENB;\n\t\tpending_hscb->scsirate = tinfo->scsirate;\n\t\tpending_hscb->scsioffset = tinfo->current.offset;\n\t\tpending_scb_count++;\n\t\tscb = LIST_NEXT(scb, pend_links);\n\t}\n\n\tif (pending_scb_count == 0)\n\t\treturn;\n\n\tsaved_scbptr = ahc_inb(ahc, SCBPTR);\n\t/* Ensure that the hscbs down on the card match the new information */\n\tfor (i = 0; i < ahc->scb_data->maxhscbs; i++) {\n\t\tu_int scb_tag;\n\n\t\tahc_outb(ahc, SCBPTR, i);\n\t\tscb_tag = ahc_inb(ahc, SCB_TAG);\n\t\tif (scb_tag != SCB_LIST_NULL) {\n\t\t\tstruct\tahc_devinfo devinfo;\n\t\t\tstruct\tscb *pending_scb;\n\t\t\tstruct scsi_xfer *xs;\n\t\t\tstruct\thardware_scb *pending_hscb;\n\t\t\tstruct\tahc_initiator_tinfo *tinfo;\n\t\t\tstruct\ttmode_tstate *tstate;\n\t\t\tu_int\tour_id, remote_id;\n\t\t\tu_int\tcontrol;\n\n\t\t\tpending_scb = &ahc->scb_data->scbarray[scb_tag];\n\t\t\tif (pending_scb->flags == SCB_FREE)\n\t\t\t\tcontinue;\n\t\t\tpending_hscb = pending_scb->hscb;\n\t\t\txs = pending_scb->xs;\n\t\t\tour_id = SCB_IS_SCSIBUS_B(pending_scb)\n\t\t\t       ? ahc->our_id_b : ahc->our_id;\n\t\t\tremote_id = xs->sc_link->target;\n\t\t\tahc_compile_devinfo(&devinfo, our_id, remote_id,\n\t\t\t\t\t    SCB_LUN(pending_scb),\n\t\t\t\t\t    SCB_CHANNEL(pending_scb),\n\t\t\t\t\t    ROLE_UNKNOWN);\n\t\t\ttinfo = ahc_fetch_transinfo(ahc, devinfo.channel,\n\t\t\t\t\t\t    our_id, remote_id, &tstate);\n\t\t\tcontrol = ahc_inb(ahc, SCB_CONTROL);\n\t\t\tcontrol &= ~ULTRAENB;\n\t\t\tif ((tstate->ultraenb & devinfo.target_mask) != 0)\n\t\t\t\tcontrol |= ULTRAENB;\n\t\t\tahc_outb(ahc, SCB_CONTROL, control);\n\t\t\tahc_outb(ahc, SCB_SCSIRATE, tinfo->scsirate);\n\t\t\tahc_outb(ahc, SCB_SCSIOFFSET, tinfo->current.offset);\n\t\t}\n\t}\n\tahc_outb(ahc, SCBPTR, saved_scbptr);\n}"
  },
  {
    "function_name": "ahc_calc_residual",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "5577-5631",
    "snippet": "STATIC void\nahc_calc_residual(scb)\n\tstruct scb *scb;\n{\n\tstruct\thardware_scb *hscb;\n\n\thscb = scb->hscb;\n\n\t/*\n\t * If the disconnected flag is still set, this is bogus\n\t * residual information left over from a sequencer\n\t * pagin/pageout, so ignore this case.\n\t */\n\tif ((scb->hscb->control & DISCONNECTED) == 0) {\n\t\tu_int32_t resid;\n\t\tint\t  resid_sgs;\n\t\tint\t  sg;\n\t\t\n\t\t/*\n\t\t * Remainder of the SG where the transfer\n\t\t * stopped.\n\t\t */\n\t\tresid = (hscb->residual_data_count[2] << 16)\n\t\t      |\t(hscb->residual_data_count[1] <<8)\n\t\t      |\t(hscb->residual_data_count[0]);\n\n\t\t/*\n\t\t * Add up the contents of all residual\n\t\t * SG segments that are after the SG where\n\t\t * the transfer stopped.\n\t\t */\n\t\tresid_sgs = scb->hscb->residual_SG_count - 1/*current*/;\n\t\tsg = scb->sg_count - resid_sgs;\n\t\twhile (resid_sgs > 0) {\n\n\t\t\tresid += scb->sg_list[sg].len;\n\t\t\tsg++;\n\t\t\tresid_sgs--;\n\t\t}\n\t\tscb->xs->resid = resid;\n\t}\n\n\t/*\n\t * Clean out the residual information in this SCB for its\n\t * next consumer.\n\t */\n\thscb->residual_SG_count = 0;\n\n#ifdef AHC_DEBUG\n\tif (ahc_debug & AHC_SHOWMISC) {\n\t\tsc_print_addr(scb->xs->sc_link);\n\t\tprintf(\"Handled Residual of %ld bytes\\n\" ,scb->xs->resid);\n\t}\n#endif\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define STATIC\tstatic",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
      "STATIC void",
      "ahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "ahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC struct",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
      "STATIC void",
      "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_calc_residual __P((struct scb *scb));",
      "STATIC void",
      "STATIC void",
      "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
      "STATIC void",
      "STATIC void",
      "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
      "STATIC struct",
      "STATIC struct",
      "STATIC struct",
      "struct scsi_xfer *xs;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Handled Residual of %ld bytes\\n\"",
            "scb->xs->resid"
          ],
          "line": 5628
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sc_print_addr",
          "args": [
            "scb->xs->sc_link"
          ],
          "line": 5627
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nSTATIC void;\nahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nSTATIC void;\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_calc_residual __P((struct scb *scb));\nSTATIC void;\nSTATIC void;\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nSTATIC struct;\nSTATIC struct;\nSTATIC struct;\nstruct scsi_xfer *xs;\n\nSTATIC void\nahc_calc_residual(scb)\n\tstruct scb *scb;\n{\n\tstruct\thardware_scb *hscb;\n\n\thscb = scb->hscb;\n\n\t/*\n\t * If the disconnected flag is still set, this is bogus\n\t * residual information left over from a sequencer\n\t * pagin/pageout, so ignore this case.\n\t */\n\tif ((scb->hscb->control & DISCONNECTED) == 0) {\n\t\tu_int32_t resid;\n\t\tint\t  resid_sgs;\n\t\tint\t  sg;\n\t\t\n\t\t/*\n\t\t * Remainder of the SG where the transfer\n\t\t * stopped.\n\t\t */\n\t\tresid = (hscb->residual_data_count[2] << 16)\n\t\t      |\t(hscb->residual_data_count[1] <<8)\n\t\t      |\t(hscb->residual_data_count[0]);\n\n\t\t/*\n\t\t * Add up the contents of all residual\n\t\t * SG segments that are after the SG where\n\t\t * the transfer stopped.\n\t\t */\n\t\tresid_sgs = scb->hscb->residual_SG_count - 1/*current*/;\n\t\tsg = scb->sg_count - resid_sgs;\n\t\twhile (resid_sgs > 0) {\n\n\t\t\tresid += scb->sg_list[sg].len;\n\t\t\tsg++;\n\t\t\tresid_sgs--;\n\t\t}\n\t\tscb->xs->resid = resid;\n\t}\n\n\t/*\n\t * Clean out the residual information in this SCB for its\n\t * next consumer.\n\t */\n\thscb->residual_SG_count = 0;\n\n#ifdef AHC_DEBUG\n\tif (ahc_debug & AHC_SHOWMISC) {\n\t\tsc_print_addr(scb->xs->sc_link);\n\t\tprintf(\"Handled Residual of %ld bytes\\n\" ,scb->xs->resid);\n\t}\n#endif\n}"
  },
  {
    "function_name": "ahc_construct_wdtr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "5565-5575",
    "snippet": "STATIC void\nahc_construct_wdtr(ahc, bus_width)\n\tstruct ahc_softc *ahc;\n\tu_int bus_width;\n{\n\tahc->msgout_buf[ahc->msgout_index++] = MSG_EXTENDED;\n\tahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_WDTR_LEN;\n\tahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_WDTR;\n\tahc->msgout_buf[ahc->msgout_index++] = bus_width;\n\tahc->msgout_len += 4;\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define STATIC\tstatic",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC u_int",
      "STATIC void",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC u_int",
      "STATIC void",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "STATIC u_int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_construct_wdtr __P((struct ahc_softc *ahc, u_int bus_width));",
      "STATIC void",
      "STATIC void",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_construct_wdtr __P((struct ahc_softc *ahc, u_int bus_width));\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_construct_wdtr(ahc, bus_width)\n\tstruct ahc_softc *ahc;\n\tu_int bus_width;\n{\n\tahc->msgout_buf[ahc->msgout_index++] = MSG_EXTENDED;\n\tahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_WDTR_LEN;\n\tahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_WDTR;\n\tahc->msgout_buf[ahc->msgout_index++] = bus_width;\n\tahc->msgout_len += 4;\n}"
  },
  {
    "function_name": "ahc_construct_sdtr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "5551-5563",
    "snippet": "STATIC void\nahc_construct_sdtr(ahc, period, offset)\n\tstruct ahc_softc *ahc;\n\tu_int period;\n\tu_int offset;\n{\n\tahc->msgout_buf[ahc->msgout_index++] = MSG_EXTENDED;\n\tahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_SDTR_LEN;\n\tahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_SDTR;\n\tahc->msgout_buf[ahc->msgout_index++] = period;\n\tahc->msgout_buf[ahc->msgout_index++] = offset;\n\tahc->msgout_len += 5;\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define STATIC\tstatic",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC u_int",
      "STATIC void",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC u_int",
      "STATIC void",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "STATIC u_int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "ahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "u_int *period;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "u_int *period;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_construct_sdtr(ahc, period, offset)\n\tstruct ahc_softc *ahc;\n\tu_int period;\n\tu_int offset;\n{\n\tahc->msgout_buf[ahc->msgout_index++] = MSG_EXTENDED;\n\tahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_SDTR_LEN;\n\tahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_SDTR;\n\tahc->msgout_buf[ahc->msgout_index++] = period;\n\tahc->msgout_buf[ahc->msgout_index++] = offset;\n\tahc->msgout_len += 5;\n}"
  },
  {
    "function_name": "ahc_match_scb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "5529-5549",
    "snippet": "STATIC int\nahc_match_scb(scb, target, channel, lun, role, tag)\n\tstruct scb *scb;\n\tint target;\n\tchar channel;\n\tint lun;\n\trole_t role;\n\tu_int tag;\n{\n\tint targ = SCB_TARGET(scb);\n\tchar chan = SCB_CHANNEL(scb);\n\tint slun = SCB_LUN(scb);\n\tint match;\n\n\tmatch = ((chan == channel) || (channel == ALL_CHANNELS));\n\tif (match != 0)\n\t\tmatch = ((targ == target) || (target == ALL_TARGETS));\n\tif (match != 0)\n\t\tmatch = ((lun == slun) || (lun == ALL_LUNS));\n\treturn match;\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define STATIC\tstatic",
      "#define STATIC",
      "#define ALL_CHANNELS '\\0'"
    ],
    "globals_used": [
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));",
      "STATIC u_int",
      "STATIC void",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "ahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC u_int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC struct",
      "STATIC struct",
      "STATIC u_int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_calc_residual __P((struct scb *scb));",
      "STATIC void",
      "STATIC void",
      "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
      "STATIC void",
      "STATIC void",
      "char channel;",
      "STATIC struct",
      "STATIC struct",
      "STATIC struct",
      "char channel;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SCB_LUN",
          "args": [
            "scb"
          ],
          "line": 5540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCB_CHANNEL",
          "args": [
            "scb"
          ],
          "line": 5539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCB_TARGET",
          "args": [
            "scb"
          ],
          "line": 5538
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n#define ALL_CHANNELS '\\0'\n\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_calc_residual __P((struct scb *scb));\nSTATIC void;\nSTATIC void;\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nSTATIC void;\nSTATIC void;\nchar channel;\nSTATIC struct;\nSTATIC struct;\nSTATIC struct;\nchar channel;\n\nSTATIC int\nahc_match_scb(scb, target, channel, lun, role, tag)\n\tstruct scb *scb;\n\tint target;\n\tchar channel;\n\tint lun;\n\trole_t role;\n\tu_int tag;\n{\n\tint targ = SCB_TARGET(scb);\n\tchar chan = SCB_CHANNEL(scb);\n\tint slun = SCB_LUN(scb);\n\tint match;\n\n\tmatch = ((chan == channel) || (channel == ALL_CHANNELS));\n\tif (match != 0)\n\t\tmatch = ((targ == target) || (target == ALL_TARGETS));\n\tif (match != 0)\n\t\tmatch = ((lun == slun) || (lun == ALL_LUNS));\n\treturn match;\n}"
  },
  {
    "function_name": "ahc_reset_channel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "5412-5527",
    "snippet": "STATIC int\nahc_reset_channel(ahc, channel, initiate_reset)\n\tstruct ahc_softc *ahc;\n\tchar channel;\n\tint initiate_reset;\n{\n\tu_int\tinitiator, target, max_scsiid;\n\tu_int\tsblkctl;\n\tu_int\tour_id;\n\tint\tfound;\n\tint\trestart_needed;\n\tchar\tcur_channel;\n\n\tahc->pending_device = NULL;\n\n\tpause_sequencer(ahc);\n\n\t/*\n\t * Run our command complete fifos to ensure that we perform\n\t * completion processing on any commands that 'completed'\n\t * before the reset occurred.\n\t */\n\tahc_run_qoutfifo(ahc);\n\n\t/*\n\t * Reset the bus if we are initiating this reset\n\t */\n\tsblkctl = ahc_inb(ahc, SBLKCTL);\n\tcur_channel = 'A';\n\tif ((ahc->features & AHC_TWIN) != 0\n\t && ((sblkctl & SELBUSB) != 0))\n\t    cur_channel = 'B';\n\tif (cur_channel != channel) {\n\t\t/* Case 1: Command for another bus is active\n\t\t * Stealthily reset the other bus without\n\t\t * upsetting the current bus.\n\t\t */\n\t\tahc_outb(ahc, SBLKCTL, sblkctl ^ SELBUSB);\n\t\tahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENBUSFREE);\n\t\tahc_outb(ahc, SCSISEQ,\n\t\t\t ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP));\n\t\tif (initiate_reset)\n\t\t\tahc_reset_current_bus(ahc);\n\t\tahc_clear_intstat(ahc);\n\t\tahc_outb(ahc, SBLKCTL, sblkctl);\n\t\trestart_needed = FALSE;\n\t} else {\n\t\t/* Case 2: A command from this bus is active or we're idle */\n\t\tahc_clear_msg_state(ahc);\n\t\tahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENBUSFREE);\n\t\tahc_outb(ahc, SCSISEQ,\n\t\t\t ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP));\n\t\tif (initiate_reset)\n\t\t\tahc_reset_current_bus(ahc);\n\t\tahc_clear_intstat(ahc);\n\n\t\t/*\n\t\t * Since we are going to restart the sequencer, avoid\n\t\t * a race in the sequencer that could cause corruption\n\t\t * of our Q pointers by starting over from index 0.\n\t\t */\n\t\tahc->qoutfifonext = 0;\n\t\tif ((ahc->features & AHC_QUEUE_REGS) != 0)\n\t\t\tahc_outb(ahc, SDSCB_QOFF, 0);\n\t\telse\n\t\t\tahc_outb(ahc, QOUTPOS, 0);\n\t\trestart_needed = TRUE;\n\t}\n\n\t/*\n\t * Clean up all the state information for the\n\t * pending transactions on this bus.\n\t */\n\tfound = ahc_abort_scbs(ahc, ALL_TARGETS, channel,\n\t\t\t       ALL_LUNS, SCB_LIST_NULL,\n\t\t\t       ROLE_UNKNOWN, XS_RESET);\n\tif (channel == 'B') {\n\t\tour_id = ahc->our_id_b;\n\t} else {\n\t\tour_id = ahc->our_id;\n\t}\n\n\tmax_scsiid = (ahc->features & AHC_WIDE) ? 15 : 7;\n\t\n\t/*\n\t * Revert to async/narrow transfers until we renegotiate.\n\t */\n\tfor (target = 0; target <= max_scsiid; target++) {\n\n\t\tif (ahc->enabled_targets[target] == NULL)\n\t\t\tcontinue;\n\t\tfor (initiator = 0; initiator <= max_scsiid; initiator++) {\n\t\t\tstruct ahc_devinfo devinfo;\n\n\t\t\tahc_compile_devinfo(&devinfo, target, initiator,\n\t\t\t\t\t    ALL_LUNS,\n\t\t\t\t\t    channel, ROLE_UNKNOWN);\n\t\t\tahc_set_width(ahc, &devinfo,\n\t\t\t\t      MSG_EXT_WDTR_BUS_8_BIT,\n\t\t\t\t      AHC_TRANS_CUR,\n\t\t\t\t      /*paused*/TRUE,\n\t\t\t\t      /*done*/FALSE);\n\t\t\tahc_set_syncrate(ahc, &devinfo,\n\t\t\t\t\t /*syncrate*/NULL, /*period*/0,\n\t\t\t\t\t /*offset*/0, AHC_TRANS_CUR,\n\t\t\t\t\t /*paused*/TRUE,\n\t\t\t\t\t /*done*/FALSE);\n\t\t}\n\t}\n\n\tif (restart_needed)\n\t\trestart_sequencer(ahc);\n\telse\n\t\tunpause_sequencer(ahc);\n\treturn found;\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define STATIC\tstatic",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
      "STATIC void",
      "STATIC u_int",
      "STATIC void",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
      "STATIC void",
      "STATIC void",
      "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
      "STATIC int",
      "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
      "STATIC void",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
      "STATIC void",
      "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
      "STATIC void",
      "STATIC void",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "ahc_reset_channel __P((struct ahc_softc *ahc, char channel,\n\t\t\t\t       int initiate_reset));",
      "STATIC int",
      "STATIC int",
      "STATIC u_int",
      "STATIC void",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "STATIC u_int",
      "STATIC void",
      "STATIC void",
      "ahc_update_target_msg_request __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t\t      struct ahc_initiator_tinfo *tinfo,\n\t\t\t\t\t      int force, int paused));",
      "STATIC void",
      "ahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));",
      "STATIC void",
      "ahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "ahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "static __inline void pause_sequencer",
      "static __inline void unpause_sequencer",
      "STATIC void",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "char channel;",
      "u_int our_id;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "u_int *period;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "u_int *period;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "char channel;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unpause_sequencer",
          "args": [
            "ahc"
          ],
          "line": 5525
        },
        "resolved": true,
        "details": {
          "function_name": "unpause_sequencer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "456-462",
          "snippet": "static __inline void\nunpause_sequencer(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tif ((ahc_inb(ahc, INTSTAT) & (SCSIINT | SEQINT | BRKADRINT)) == 0)\n\t\tahc_outb(ahc, HCNTRL, ahc->unpause);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "static __inline void unpause_sequencer",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC struct;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nahc_loadseq __P((struct ahc_softc *ahc));\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nahc_clear_intstat __P((struct ahc_softc *ahc));\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nstatic __inline void unpause_sequencer;\nrestart_sequencer __P((struct ahc_softc *ahc));\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nstatic __inline void\nunpause_sequencer(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tif ((ahc_inb(ahc, INTSTAT) & (SCSIINT | SEQINT | BRKADRINT)) == 0)\n\t\tahc_outb(ahc, HCNTRL, ahc->unpause);\n}"
        }
      },
      {
        "call_info": {
          "callee": "restart_sequencer",
          "args": [
            "ahc"
          ],
          "line": 5523
        },
        "resolved": true,
        "details": {
          "function_name": "restart_sequencer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "467-495",
          "snippet": "STATIC void\nrestart_sequencer(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tu_int i;\n\n\tpause_sequencer(ahc);\n\n\t/*\n\t * Everytime we restart the sequencer, there\n\t * is the possiblitity that we have restarted\n\t * within a three instruction window where an\n\t * SCB has been marked free but has not made it\n\t * onto the free list.  Since SCSI events(bus reset,\n\t * unexpected bus free) will always freeze the\n\t * sequencer, we cannot close this window.  To\n\t * avoid losing an SCB, we reconsitute the free\n\t * list every time we restart the sequencer.\n\t */\n\tahc_outb(ahc, FREE_SCBH, SCB_LIST_NULL);\n\tfor (i = 0; i < ahc->scb_data->maxhscbs; i++) {\n\t\t\n\t\tahc_outb(ahc, SCBPTR, i);\n\t\tif (ahc_inb(ahc, SCB_TAG) == SCB_LIST_NULL)\n\t\t\tahc_add_curscb_to_free_list(ahc);\n\t}\n\tahc_outb(ahc, SEQCTL, FASTMODE|SEQRESET);\n\tunpause_sequencer(ahc);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "static __inline void pause_sequencer",
            "static __inline void unpause_sequencer",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nstatic __inline void pause_sequencer;\nstatic __inline void unpause_sequencer;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nrestart_sequencer(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tu_int i;\n\n\tpause_sequencer(ahc);\n\n\t/*\n\t * Everytime we restart the sequencer, there\n\t * is the possiblitity that we have restarted\n\t * within a three instruction window where an\n\t * SCB has been marked free but has not made it\n\t * onto the free list.  Since SCSI events(bus reset,\n\t * unexpected bus free) will always freeze the\n\t * sequencer, we cannot close this window.  To\n\t * avoid losing an SCB, we reconsitute the free\n\t * list every time we restart the sequencer.\n\t */\n\tahc_outb(ahc, FREE_SCBH, SCB_LIST_NULL);\n\tfor (i = 0; i < ahc->scb_data->maxhscbs; i++) {\n\t\t\n\t\tahc_outb(ahc, SCBPTR, i);\n\t\tif (ahc_inb(ahc, SCB_TAG) == SCB_LIST_NULL)\n\t\t\tahc_add_curscb_to_free_list(ahc);\n\t}\n\tahc_outb(ahc, SEQCTL, FASTMODE|SEQRESET);\n\tunpause_sequencer(ahc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_set_syncrate",
          "args": [
            "ahc",
            "&devinfo",
            "/*syncrate*/NULL",
            "/*period*/0",
            "/*offset*/0",
            "AHC_TRANS_CUR",
            "/*paused*/TRUE",
            "/*done*/FALSE"
          ],
          "line": 5514
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_set_syncrate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "1297-1406",
          "snippet": "STATIC void\nahc_set_syncrate(ahc, devinfo, syncrate, period, offset, type, paused, done)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n\tstruct ahc_syncrate *syncrate;\n\tu_int period;\n\tu_int offset;\n\tu_int type;\n\tint paused;\n\tint done;\n{\n\tstruct\tahc_initiator_tinfo *tinfo;\n\tstruct\ttmode_tstate *tstate;\n\tu_int\told_period;\n\tu_int\told_offset;\n\tint\tactive = (type & AHC_TRANS_ACTIVE) == AHC_TRANS_ACTIVE;\n\n\tif (syncrate == NULL) {\n\t\tperiod = 0;\n\t\toffset = 0;\n\t}\n\n\ttinfo = ahc_fetch_transinfo(ahc, devinfo->channel,\n\t\t\t\t    devinfo->our_scsiid,\n\t\t\t\t    devinfo->target, &tstate);\n\told_period = tinfo->current.period;\n\told_offset = tinfo->current.offset;\n\n\tif ((type & AHC_TRANS_CUR) != 0\n\t && (old_period != period || old_offset != offset)) {\n\t\tu_int\tscsirate;\n\n\t\tscsirate = tinfo->scsirate;\n\t\tif ((ahc->features & AHC_ULTRA2) != 0) {\n\n\t\t\t/* XXX */\n\t\t\t/* Force single edge until DT is fully implemented */\n\t\t\tscsirate &= ~(SXFR_ULTRA2|SINGLE_EDGE|ENABLE_CRC);\n\t\t\tif (syncrate != NULL)\n\t\t\t\tscsirate |= syncrate->sxfr_u2|SINGLE_EDGE;\n\n\t\t\tif (active)\n\t\t\t\tahc_outb(ahc, SCSIOFFSET, offset);\n\t\t} else {\n\n\t\t\tscsirate &= ~(SXFR|SOFS);\n\t\t\t/*\n\t\t\t * Ensure Ultra mode is set properly for\n\t\t\t * this target.\n\t\t\t */\n\t\t\ttstate->ultraenb &= ~devinfo->target_mask;\n\t\t\tif (syncrate != NULL) {\n\t\t\t\tif (syncrate->sxfr & ULTRA_SXFR) {\n\t\t\t\t\ttstate->ultraenb |=\n\t\t\t\t\t\tdevinfo->target_mask;\n\t\t\t\t}\n\t\t\t\tscsirate |= syncrate->sxfr & SXFR;\n\t\t\t\tscsirate |= offset & SOFS;\n\t\t\t}\n\t\t\tif (active) {\n\t\t\t\tu_int sxfrctl0;\n\n\t\t\t\tsxfrctl0 = ahc_inb(ahc, SXFRCTL0);\n\t\t\t\tsxfrctl0 &= ~FAST20;\n\t\t\t\tif (tstate->ultraenb & devinfo->target_mask)\n\t\t\t\t\tsxfrctl0 |= FAST20;\n\t\t\t\tahc_outb(ahc, SXFRCTL0, sxfrctl0);\n\t\t\t}\n\t\t}\n\t\tif (active)\n\t\t\tahc_outb(ahc, SCSIRATE, scsirate);\n\n\t\ttinfo->scsirate = scsirate;\n\t\ttinfo->current.period = period;\n\t\ttinfo->current.offset = offset;\n\n\t\t/* Update the syncrates in any pending scbs */\n\t\tahc_update_pending_syncrates(ahc);\n\t}\n\n\t/*\n\t * Print messages if we're verbose and at the end of a negotiation\n\t * cycle.\n\t */\n\tif (done) {\n\t\tif (offset != 0) {\n\t\t\tprintf(\"%s: target %d synchronous at %sMHz, \"\n\t\t\t       \"offset = 0x%x\\n\", ahc_name(ahc),\n\t\t\t       devinfo->target, syncrate->rate, offset);\n\t\t} else {\n\t\t\tprintf(\"%s: target %d using \"\n\t\t\t       \"asynchronous transfers\\n\",\n\t\t\t       ahc_name(ahc), devinfo->target);\n\t\t}\n\t}\n\n\tif ((type & AHC_TRANS_GOAL) != 0) {\n\t\ttinfo->goal.period = period;\n\t\ttinfo->goal.offset = offset;\n\t}\n\n\tif ((type & AHC_TRANS_USER) != 0) {\n\t\ttinfo->user.period = period;\n\t\ttinfo->user.offset = offset;\n\t}\n\n\tahc_update_target_msg_request(ahc, devinfo, tinfo,\n\t\t\t\t      /*force*/FALSE,\n\t\t\t\t      paused);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC int",
            "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "ahc_update_target_msg_request __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t\t      struct ahc_initiator_tinfo *tinfo,\n\t\t\t\t\t      int force, int paused));",
            "STATIC void",
            "ahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));",
            "STATIC void",
            "ahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "static __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct tmode_tstate **tstate;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "u_int *period;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "u_int *period;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nahc_update_target_msg_request __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t\t      struct ahc_initiator_tinfo *tinfo,\n\t\t\t\t\t      int force, int paused));\nSTATIC void;\nahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));\nSTATIC void;\nahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct tmode_tstate **tstate;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_set_syncrate(ahc, devinfo, syncrate, period, offset, type, paused, done)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n\tstruct ahc_syncrate *syncrate;\n\tu_int period;\n\tu_int offset;\n\tu_int type;\n\tint paused;\n\tint done;\n{\n\tstruct\tahc_initiator_tinfo *tinfo;\n\tstruct\ttmode_tstate *tstate;\n\tu_int\told_period;\n\tu_int\told_offset;\n\tint\tactive = (type & AHC_TRANS_ACTIVE) == AHC_TRANS_ACTIVE;\n\n\tif (syncrate == NULL) {\n\t\tperiod = 0;\n\t\toffset = 0;\n\t}\n\n\ttinfo = ahc_fetch_transinfo(ahc, devinfo->channel,\n\t\t\t\t    devinfo->our_scsiid,\n\t\t\t\t    devinfo->target, &tstate);\n\told_period = tinfo->current.period;\n\told_offset = tinfo->current.offset;\n\n\tif ((type & AHC_TRANS_CUR) != 0\n\t && (old_period != period || old_offset != offset)) {\n\t\tu_int\tscsirate;\n\n\t\tscsirate = tinfo->scsirate;\n\t\tif ((ahc->features & AHC_ULTRA2) != 0) {\n\n\t\t\t/* XXX */\n\t\t\t/* Force single edge until DT is fully implemented */\n\t\t\tscsirate &= ~(SXFR_ULTRA2|SINGLE_EDGE|ENABLE_CRC);\n\t\t\tif (syncrate != NULL)\n\t\t\t\tscsirate |= syncrate->sxfr_u2|SINGLE_EDGE;\n\n\t\t\tif (active)\n\t\t\t\tahc_outb(ahc, SCSIOFFSET, offset);\n\t\t} else {\n\n\t\t\tscsirate &= ~(SXFR|SOFS);\n\t\t\t/*\n\t\t\t * Ensure Ultra mode is set properly for\n\t\t\t * this target.\n\t\t\t */\n\t\t\ttstate->ultraenb &= ~devinfo->target_mask;\n\t\t\tif (syncrate != NULL) {\n\t\t\t\tif (syncrate->sxfr & ULTRA_SXFR) {\n\t\t\t\t\ttstate->ultraenb |=\n\t\t\t\t\t\tdevinfo->target_mask;\n\t\t\t\t}\n\t\t\t\tscsirate |= syncrate->sxfr & SXFR;\n\t\t\t\tscsirate |= offset & SOFS;\n\t\t\t}\n\t\t\tif (active) {\n\t\t\t\tu_int sxfrctl0;\n\n\t\t\t\tsxfrctl0 = ahc_inb(ahc, SXFRCTL0);\n\t\t\t\tsxfrctl0 &= ~FAST20;\n\t\t\t\tif (tstate->ultraenb & devinfo->target_mask)\n\t\t\t\t\tsxfrctl0 |= FAST20;\n\t\t\t\tahc_outb(ahc, SXFRCTL0, sxfrctl0);\n\t\t\t}\n\t\t}\n\t\tif (active)\n\t\t\tahc_outb(ahc, SCSIRATE, scsirate);\n\n\t\ttinfo->scsirate = scsirate;\n\t\ttinfo->current.period = period;\n\t\ttinfo->current.offset = offset;\n\n\t\t/* Update the syncrates in any pending scbs */\n\t\tahc_update_pending_syncrates(ahc);\n\t}\n\n\t/*\n\t * Print messages if we're verbose and at the end of a negotiation\n\t * cycle.\n\t */\n\tif (done) {\n\t\tif (offset != 0) {\n\t\t\tprintf(\"%s: target %d synchronous at %sMHz, \"\n\t\t\t       \"offset = 0x%x\\n\", ahc_name(ahc),\n\t\t\t       devinfo->target, syncrate->rate, offset);\n\t\t} else {\n\t\t\tprintf(\"%s: target %d using \"\n\t\t\t       \"asynchronous transfers\\n\",\n\t\t\t       ahc_name(ahc), devinfo->target);\n\t\t}\n\t}\n\n\tif ((type & AHC_TRANS_GOAL) != 0) {\n\t\ttinfo->goal.period = period;\n\t\ttinfo->goal.offset = offset;\n\t}\n\n\tif ((type & AHC_TRANS_USER) != 0) {\n\t\ttinfo->user.period = period;\n\t\ttinfo->user.offset = offset;\n\t}\n\n\tahc_update_target_msg_request(ahc, devinfo, tinfo,\n\t\t\t\t      /*force*/FALSE,\n\t\t\t\t      paused);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_set_width",
          "args": [
            "ahc",
            "&devinfo",
            "MSG_EXT_WDTR_BUS_8_BIT",
            "AHC_TRANS_CUR",
            "/*paused*/TRUE",
            "/*done*/FALSE"
          ],
          "line": 5509
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_set_width",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "1408-1457",
          "snippet": "STATIC void\nahc_set_width(ahc, devinfo, width, type, paused, done)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n\tu_int width;\n\tu_int type;\n\tint paused;\n\tint done;\n{\n\tstruct ahc_initiator_tinfo *tinfo;\n\tstruct tmode_tstate *tstate;\n\tu_int  oldwidth;\n\tint    active = (type & AHC_TRANS_ACTIVE) == AHC_TRANS_ACTIVE;\n\n\ttinfo = ahc_fetch_transinfo(ahc, devinfo->channel,\n\t\t\t\t    devinfo->our_scsiid,\n\t\t\t\t    devinfo->target,\n\t\t\t\t    &tstate);\n\toldwidth = tinfo->current.width;\n\n\tif ((type & AHC_TRANS_CUR) != 0 && oldwidth != width) {\n\t\tu_int\tscsirate;\n\n\t\tscsirate =  tinfo->scsirate;\n\t\tscsirate &= ~WIDEXFER;\n\t\tif (width == MSG_EXT_WDTR_BUS_16_BIT)\n\t\t\tscsirate |= WIDEXFER;\n\n\t\ttinfo->scsirate = scsirate;\n\n\t\tif (active)\n\t\t\tahc_outb(ahc, SCSIRATE, scsirate);\n\n\t\ttinfo->current.width = width;\n\t}\n\n\tif (done) {\n\t\tprintf(\"%s: target %d using %dbit transfers\\n\",\n\t\t       ahc_name(ahc), devinfo->target,\n\t\t       8 * (0x01 << width));\n\t}\n\n\tif ((type & AHC_TRANS_GOAL) != 0)\n\t\ttinfo->goal.width = width;\n\tif ((type & AHC_TRANS_USER) != 0)\n\t\ttinfo->user.width = width;\n\n\tahc_update_target_msg_request(ahc, devinfo, tinfo,\n\t\t\t\t      /*force*/FALSE, paused);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC int",
            "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "ahc_update_target_msg_request __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t\t      struct ahc_initiator_tinfo *tinfo,\n\t\t\t\t\t      int force, int paused));",
            "STATIC void",
            "ahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));",
            "STATIC void",
            "ahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "static __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct tmode_tstate **tstate;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nahc_update_target_msg_request __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t\t      struct ahc_initiator_tinfo *tinfo,\n\t\t\t\t\t      int force, int paused));\nSTATIC void;\nahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));\nSTATIC void;\nahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct tmode_tstate **tstate;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_set_width(ahc, devinfo, width, type, paused, done)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n\tu_int width;\n\tu_int type;\n\tint paused;\n\tint done;\n{\n\tstruct ahc_initiator_tinfo *tinfo;\n\tstruct tmode_tstate *tstate;\n\tu_int  oldwidth;\n\tint    active = (type & AHC_TRANS_ACTIVE) == AHC_TRANS_ACTIVE;\n\n\ttinfo = ahc_fetch_transinfo(ahc, devinfo->channel,\n\t\t\t\t    devinfo->our_scsiid,\n\t\t\t\t    devinfo->target,\n\t\t\t\t    &tstate);\n\toldwidth = tinfo->current.width;\n\n\tif ((type & AHC_TRANS_CUR) != 0 && oldwidth != width) {\n\t\tu_int\tscsirate;\n\n\t\tscsirate =  tinfo->scsirate;\n\t\tscsirate &= ~WIDEXFER;\n\t\tif (width == MSG_EXT_WDTR_BUS_16_BIT)\n\t\t\tscsirate |= WIDEXFER;\n\n\t\ttinfo->scsirate = scsirate;\n\n\t\tif (active)\n\t\t\tahc_outb(ahc, SCSIRATE, scsirate);\n\n\t\ttinfo->current.width = width;\n\t}\n\n\tif (done) {\n\t\tprintf(\"%s: target %d using %dbit transfers\\n\",\n\t\t       ahc_name(ahc), devinfo->target,\n\t\t       8 * (0x01 << width));\n\t}\n\n\tif ((type & AHC_TRANS_GOAL) != 0)\n\t\ttinfo->goal.width = width;\n\tif ((type & AHC_TRANS_USER) != 0)\n\t\ttinfo->user.width = width;\n\n\tahc_update_target_msg_request(ahc, devinfo, tinfo,\n\t\t\t\t      /*force*/FALSE, paused);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_compile_devinfo",
          "args": [
            "&devinfo",
            "target",
            "initiator",
            "ALL_LUNS",
            "channel",
            "ROLE_UNKNOWN"
          ],
          "line": 5506
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_compile_devinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "1568-1586",
          "snippet": "STATIC void\nahc_compile_devinfo(devinfo, our_id, target, lun, channel, role)\n\tstruct ahc_devinfo *devinfo;\n\tu_int our_id;\n\tu_int target;\n\tu_int lun;\n\tchar channel;\n\trole_t role;\n{\n\tdevinfo->our_scsiid = our_id;\n\tdevinfo->target = target;\n\tdevinfo->lun = lun;\n\tdevinfo->target_offset = target;\n\tdevinfo->channel = channel;\n\tdevinfo->role = role;\n\tif (channel == 'B')\n\t\tdevinfo->target_offset += 8;\n\tdevinfo->target_mask = (0x01 << devinfo->target_offset);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC int",
            "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "ahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "char channel;",
            "u_int our_id;",
            "STATIC struct",
            "STATIC struct",
            "STATIC struct",
            "char channel;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nchar channel;\nu_int our_id;\nSTATIC struct;\nSTATIC struct;\nSTATIC struct;\nchar channel;\n\nSTATIC void\nahc_compile_devinfo(devinfo, our_id, target, lun, channel, role)\n\tstruct ahc_devinfo *devinfo;\n\tu_int our_id;\n\tu_int target;\n\tu_int lun;\n\tchar channel;\n\trole_t role;\n{\n\tdevinfo->our_scsiid = our_id;\n\tdevinfo->target = target;\n\tdevinfo->lun = lun;\n\tdevinfo->target_offset = target;\n\tdevinfo->channel = channel;\n\tdevinfo->role = role;\n\tif (channel == 'B')\n\t\tdevinfo->target_offset += 8;\n\tdevinfo->target_mask = (0x01 << devinfo->target_offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_abort_scbs",
          "args": [
            "ahc",
            "ALL_TARGETS",
            "channel",
            "ALL_LUNS",
            "SCB_LIST_NULL",
            "ROLE_UNKNOWN",
            "XS_RESET"
          ],
          "line": 5485
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_abort_scbs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "5129-5231",
          "snippet": "STATIC int\nahc_abort_scbs(ahc, target, channel, lun, tag, role, status)\n\tstruct ahc_softc *ahc;\n\tint target;\n\tchar channel;\n\tint lun;\n\tu_int tag;\n\trole_t role;\n\tu_int32_t status;\n{\n\tstruct\tscb *scbp;\n\tu_int\tactive_scb;\n\tint\ti;\n\tint\tfound;\n\n\t/* restore this when we're done */\n\tactive_scb = ahc_inb(ahc, SCBPTR);\n\n\tfound = ahc_search_qinfifo(ahc, target, channel, lun, SCB_LIST_NULL,\n\t\t\t\t   role, SCB_REQUEUE, SEARCH_COMPLETE);\n\n\t/*\n\t * Search waiting for selection list.\n\t */\n\t{\n\t\tu_int8_t next, prev;\n                /* Start at head of list. */\n\t\tnext = ahc_inb(ahc, WAITING_SCBH);\n\t\tprev = SCB_LIST_NULL;\n\n\t\twhile (next != SCB_LIST_NULL) {\n\t\t\tu_int8_t scb_index;\n\n\t\t\tahc_outb(ahc, SCBPTR, next);\n\t\t\tscb_index = ahc_inb(ahc, SCB_TAG);\n\t\t\tif (scb_index >= ahc->scb_data->numscbs) {\n\t\t\t\tpanic(\"Waiting List inconsistency. \"\n\t\t\t\t      \"SCB index == %d, yet numscbs == %d.\",\n\t\t\t\t      scb_index, ahc->scb_data->numscbs);\n\t\t\t}\n\t\t\tscbp = &ahc->scb_data->scbarray[scb_index];\n\t\t\tif (ahc_match_scb(scbp, target, channel,\n\t\t\t\t\t  lun, SCB_LIST_NULL, role)) {\n\n\t\t\t\tnext = ahc_abort_wscb(ahc, next, prev);\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tprev = next;\n\t\t\t\tnext = ahc_inb(ahc, SCB_NEXT);\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\t * Go through the disconnected list and remove any entries we\n\t * have queued for completion, 0'ing their control byte too.\n\t * We save the active SCB and restore it ourselves, so there\n\t * is no reason for this search to restore it too.\n\t */\n\tahc_search_disc_list(ahc, target, channel, lun, tag,\n\t\t\t     /*stop_on_first*/FALSE, /*remove*/TRUE,\n\t\t\t     /*save_state*/FALSE);\n\n\t/*\n\t * Go through the hardware SCB array looking for commands that\n\t * were active but not on any list.\n\t */\n\tfor(i = 0; i < ahc->scb_data->maxhscbs; i++) {\n\t\tu_int scbid;\n\n\t\tahc_outb(ahc, SCBPTR, i);\n\t\tscbid = ahc_inb(ahc, SCB_TAG);\n\t\tscbp = &ahc->scb_data->scbarray[scbid];\n\t\tif (scbid < ahc->scb_data->numscbs && \n\t\t\t ahc_match_scb(scbp, target, channel, lun, tag, role))\n\t\t\t\tahc_add_curscb_to_free_list(ahc);\n\t}\n\n\t/*\n\t * Go through the pending CCB list and look for\n\t * commands for this target that are still active.\n\t * These are other tagged commands that were\n\t * disconnected when the reset occured.\n\t */\n\t{\n\t\tstruct scb *scb;\n\n\t\tscb = ahc->pending_scbs.lh_first;\n\t\twhile (scb != NULL) {\n\t\t\tscbp = scb;\n\t\t\tscb = scb->pend_links.le_next;\n\t\t\tif (ahc_match_scb(scbp, target, channel,\n\t\t\t\t\t  lun, tag, role)) {\n\t\t\t\tif (!(scbp->xs->flags & ITSDONE))\n\t\t\t\t\tahcsetccbstatus(scbp->xs, status);\n\t\t\t\tahc_freeze_ccb(scbp);\n\t\t\t\tahc_done(ahc, scbp);\n\t\t\t\tfound++;\n\t\t\t}\n\t\t}\n\t}\n\tahc_outb(ahc, SCBPTR, active_scb);\n\treturn found;\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "ahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));",
            "STATIC u_int",
            "ahc_abort_wscb __P((struct ahc_softc *ahc,\n\t\t\t\t    u_int scbpos, u_int prev));",
            "STATIC void",
            "ahc_done __P((struct ahc_softc *ahc, struct scb *scbp));",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "ahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "ahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));",
            "STATIC int",
            "ahc_search_disc_list __P((struct ahc_softc *ahc, int target,\n\t\t\t\t\t  char channel, int lun, u_int tag,\n\t\t\t\t\t  int stop_on_first, int remove,\n\t\t\t\t\t  int save_state));",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));",
            "STATIC void",
            "ahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));",
            "STATIC void",
            "STATIC int",
            "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
            "STATIC void",
            "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_calc_residual __P((struct scb *scb));",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "static __inline void ahc_freeze_ccb",
            "static __inline void ahcsetccbstatus",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *xs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));\nSTATIC u_int;\nahc_abort_wscb __P((struct ahc_softc *ahc,\n\t\t\t\t    u_int scbpos, u_int prev));\nSTATIC void;\nahc_done __P((struct ahc_softc *ahc, struct scb *scbp));\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));\nSTATIC int;\nahc_search_disc_list __P((struct ahc_softc *ahc, int target,\n\t\t\t\t\t  char channel, int lun, u_int tag,\n\t\t\t\t\t  int stop_on_first, int remove,\n\t\t\t\t\t  int save_state));\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));\nSTATIC void;\nahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));\nSTATIC void;\nSTATIC int;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nSTATIC void;\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_calc_residual __P((struct scb *scb));\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nstatic __inline void ahc_freeze_ccb;\nstatic __inline void ahcsetccbstatus;\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n\nSTATIC int\nahc_abort_scbs(ahc, target, channel, lun, tag, role, status)\n\tstruct ahc_softc *ahc;\n\tint target;\n\tchar channel;\n\tint lun;\n\tu_int tag;\n\trole_t role;\n\tu_int32_t status;\n{\n\tstruct\tscb *scbp;\n\tu_int\tactive_scb;\n\tint\ti;\n\tint\tfound;\n\n\t/* restore this when we're done */\n\tactive_scb = ahc_inb(ahc, SCBPTR);\n\n\tfound = ahc_search_qinfifo(ahc, target, channel, lun, SCB_LIST_NULL,\n\t\t\t\t   role, SCB_REQUEUE, SEARCH_COMPLETE);\n\n\t/*\n\t * Search waiting for selection list.\n\t */\n\t{\n\t\tu_int8_t next, prev;\n                /* Start at head of list. */\n\t\tnext = ahc_inb(ahc, WAITING_SCBH);\n\t\tprev = SCB_LIST_NULL;\n\n\t\twhile (next != SCB_LIST_NULL) {\n\t\t\tu_int8_t scb_index;\n\n\t\t\tahc_outb(ahc, SCBPTR, next);\n\t\t\tscb_index = ahc_inb(ahc, SCB_TAG);\n\t\t\tif (scb_index >= ahc->scb_data->numscbs) {\n\t\t\t\tpanic(\"Waiting List inconsistency. \"\n\t\t\t\t      \"SCB index == %d, yet numscbs == %d.\",\n\t\t\t\t      scb_index, ahc->scb_data->numscbs);\n\t\t\t}\n\t\t\tscbp = &ahc->scb_data->scbarray[scb_index];\n\t\t\tif (ahc_match_scb(scbp, target, channel,\n\t\t\t\t\t  lun, SCB_LIST_NULL, role)) {\n\n\t\t\t\tnext = ahc_abort_wscb(ahc, next, prev);\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tprev = next;\n\t\t\t\tnext = ahc_inb(ahc, SCB_NEXT);\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\t * Go through the disconnected list and remove any entries we\n\t * have queued for completion, 0'ing their control byte too.\n\t * We save the active SCB and restore it ourselves, so there\n\t * is no reason for this search to restore it too.\n\t */\n\tahc_search_disc_list(ahc, target, channel, lun, tag,\n\t\t\t     /*stop_on_first*/FALSE, /*remove*/TRUE,\n\t\t\t     /*save_state*/FALSE);\n\n\t/*\n\t * Go through the hardware SCB array looking for commands that\n\t * were active but not on any list.\n\t */\n\tfor(i = 0; i < ahc->scb_data->maxhscbs; i++) {\n\t\tu_int scbid;\n\n\t\tahc_outb(ahc, SCBPTR, i);\n\t\tscbid = ahc_inb(ahc, SCB_TAG);\n\t\tscbp = &ahc->scb_data->scbarray[scbid];\n\t\tif (scbid < ahc->scb_data->numscbs && \n\t\t\t ahc_match_scb(scbp, target, channel, lun, tag, role))\n\t\t\t\tahc_add_curscb_to_free_list(ahc);\n\t}\n\n\t/*\n\t * Go through the pending CCB list and look for\n\t * commands for this target that are still active.\n\t * These are other tagged commands that were\n\t * disconnected when the reset occured.\n\t */\n\t{\n\t\tstruct scb *scb;\n\n\t\tscb = ahc->pending_scbs.lh_first;\n\t\twhile (scb != NULL) {\n\t\t\tscbp = scb;\n\t\t\tscb = scb->pend_links.le_next;\n\t\t\tif (ahc_match_scb(scbp, target, channel,\n\t\t\t\t\t  lun, tag, role)) {\n\t\t\t\tif (!(scbp->xs->flags & ITSDONE))\n\t\t\t\t\tahcsetccbstatus(scbp->xs, status);\n\t\t\t\tahc_freeze_ccb(scbp);\n\t\t\t\tahc_done(ahc, scbp);\n\t\t\t\tfound++;\n\t\t\t}\n\t\t}\n\t}\n\tahc_outb(ahc, SCBPTR, active_scb);\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "QOUTPOS",
            "0"
          ],
          "line": 5477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SDSCB_QOFF",
            "0"
          ],
          "line": 5475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_clear_intstat",
          "args": [
            "ahc"
          ],
          "line": 5466
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_clear_intstat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "5381-5391",
          "snippet": "STATIC void\nahc_clear_intstat(ahc)\n\tstruct ahc_softc *ahc;\n{\n\t/* Clear any interrupt conditions this may have caused */\n\tahc_outb(ahc, CLRSINT0, CLRSELDO|CLRSELDI|CLRSELINGO);\n\tahc_outb(ahc, CLRSINT1, CLRSELTIMEO|CLRATNO|CLRSCSIRSTI\n\t\t\t\t|CLRBUSFREE|CLRSCSIPERR|CLRPHASECHG|\n\t\t\t\tCLRREQINIT);\n\tahc_outb(ahc, CLRINT, CLRSCSIINT);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_clear_intstat(ahc)\n\tstruct ahc_softc *ahc;\n{\n\t/* Clear any interrupt conditions this may have caused */\n\tahc_outb(ahc, CLRSINT0, CLRSELDO|CLRSELDI|CLRSELINGO);\n\tahc_outb(ahc, CLRSINT1, CLRSELTIMEO|CLRATNO|CLRSCSIRSTI\n\t\t\t\t|CLRBUSFREE|CLRSCSIPERR|CLRPHASECHG|\n\t\t\t\tCLRREQINIT);\n\tahc_outb(ahc, CLRINT, CLRSCSIINT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_reset_current_bus",
          "args": [
            "ahc"
          ],
          "line": 5465
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_reset_current_bus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "5393-5410",
          "snippet": "STATIC void\nahc_reset_current_bus(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tu_int8_t scsiseq;\n\n\tahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENSCSIRST);\n\tscsiseq = ahc_inb(ahc, SCSISEQ);\n\tahc_outb(ahc, SCSISEQ, scsiseq | SCSIRSTO);\n\tDELAY(AHC_BUSRESET_DELAY);\n\t/* Turn off the bus reset */\n\tahc_outb(ahc, SCSISEQ, scsiseq & ~SCSIRSTO);\n\n\tahc_clear_intstat(ahc);\n\n\t/* Re-enable reset interrupts */\n\tahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) | ENSCSIRST);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define AHC_BUSRESET_DELAY\t25\t/* Reset delay in us */",
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_set_tags __P((struct ahc_softc *ahc,\n\t\t\t\t  struct ahc_devinfo *devinfo,int enable));",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define AHC_BUSRESET_DELAY\t25\t/* Reset delay in us */\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_set_tags __P((struct ahc_softc *ahc,\n\t\t\t\t  struct ahc_devinfo *devinfo,int enable));\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_reset_current_bus(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tu_int8_t scsiseq;\n\n\tahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENSCSIRST);\n\tscsiseq = ahc_inb(ahc, SCSISEQ);\n\tahc_outb(ahc, SCSISEQ, scsiseq | SCSIRSTO);\n\tDELAY(AHC_BUSRESET_DELAY);\n\t/* Turn off the bus reset */\n\tahc_outb(ahc, SCSISEQ, scsiseq & ~SCSIRSTO);\n\n\tahc_clear_intstat(ahc);\n\n\t/* Re-enable reset interrupts */\n\tahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) | ENSCSIRST);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCSISEQ",
            "ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP)"
          ],
          "line": 5462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCSISEQ"
          ],
          "line": 5463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SIMODE1",
            "ahc_inb(ahc, SIMODE1) & ~ENBUSFREE"
          ],
          "line": 5461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SIMODE1"
          ],
          "line": 5461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_clear_msg_state",
          "args": [
            "ahc"
          ],
          "line": 5460
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_clear_msg_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "2680-2688",
          "snippet": "STATIC void\nahc_clear_msg_state(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tahc->msgout_len = 0;\n\tahc->msgin_index = 0;\n\tahc->msg_type = MSG_TYPE_NONE;\n\tahc_outb(ahc, MSG_OUT, MSG_NOOP);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_clear_msg_state(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tahc->msgout_len = 0;\n\tahc->msgin_index = 0;\n\tahc->msg_type = MSG_TYPE_NONE;\n\tahc_outb(ahc, MSG_OUT, MSG_NOOP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SBLKCTL",
            "sblkctl"
          ],
          "line": 5456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCSISEQ",
            "ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP)"
          ],
          "line": 5451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCSISEQ"
          ],
          "line": 5452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SIMODE1",
            "ahc_inb(ahc, SIMODE1) & ~ENBUSFREE"
          ],
          "line": 5450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SIMODE1"
          ],
          "line": 5450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SBLKCTL",
            "sblkctl ^ SELBUSB"
          ],
          "line": 5449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SBLKCTL"
          ],
          "line": 5439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_run_qoutfifo",
          "args": [
            "ahc"
          ],
          "line": 5434
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_run_qoutfifo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "576-610",
          "snippet": "STATIC void\nahc_run_qoutfifo(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tstruct scb *scb;\n\tu_int  scb_index;\n\n\tbus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, \n\t\t\tBUS_DMASYNC_POSTREAD);\n\n\twhile (ahc->qoutfifo[ahc->qoutfifonext] != SCB_LIST_NULL) {\n\t\tscb_index = ahc->qoutfifo[ahc->qoutfifonext];\n\t\tahc->qoutfifo[ahc->qoutfifonext++] = SCB_LIST_NULL;\n\n\t\tscb = &ahc->scb_data->scbarray[scb_index];\n\t\tif (scb_index >= ahc->scb_data->numscbs\n\t\t  || (scb->flags & SCB_ACTIVE) == 0) {\n\t\t\tprintf(\"%s: WARNING no command for scb %d \"\n\t\t\t       \"(cmdcmplt)\\nQOUTPOS = %d\\n\",\n\t\t\t       ahc_name(ahc), scb_index,\n\t\t\t       ahc->qoutfifonext - 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Save off the residual\n\t\t * if there is one.\n\t\t */\n\t\tif (scb->hscb->residual_SG_count != 0)\n\t\t\tahc_calc_residual(scb);\n\t\telse\n\t\t\tscb->xs->resid = 0;\n\t\tahc_done(ahc, scb);\n\t}\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
            "STATIC void",
            "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_calc_residual __P((struct scb *scb));",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *xs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nSTATIC void;\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_calc_residual __P((struct scb *scb));\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n\nSTATIC void\nahc_run_qoutfifo(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tstruct scb *scb;\n\tu_int  scb_index;\n\n\tbus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, \n\t\t\tBUS_DMASYNC_POSTREAD);\n\n\twhile (ahc->qoutfifo[ahc->qoutfifonext] != SCB_LIST_NULL) {\n\t\tscb_index = ahc->qoutfifo[ahc->qoutfifonext];\n\t\tahc->qoutfifo[ahc->qoutfifonext++] = SCB_LIST_NULL;\n\n\t\tscb = &ahc->scb_data->scbarray[scb_index];\n\t\tif (scb_index >= ahc->scb_data->numscbs\n\t\t  || (scb->flags & SCB_ACTIVE) == 0) {\n\t\t\tprintf(\"%s: WARNING no command for scb %d \"\n\t\t\t       \"(cmdcmplt)\\nQOUTPOS = %d\\n\",\n\t\t\t       ahc_name(ahc), scb_index,\n\t\t\t       ahc->qoutfifonext - 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Save off the residual\n\t\t * if there is one.\n\t\t */\n\t\tif (scb->hscb->residual_SG_count != 0)\n\t\t\tahc_calc_residual(scb);\n\t\telse\n\t\t\tscb->xs->resid = 0;\n\t\tahc_done(ahc, scb);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nahc_reset_channel __P((struct ahc_softc *ahc, char channel,\n\t\t\t\t       int initiate_reset));\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nahc_update_target_msg_request __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t\t      struct ahc_initiator_tinfo *tinfo,\n\t\t\t\t\t      int force, int paused));\nSTATIC void;\nahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));\nSTATIC void;\nahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nstatic __inline void pause_sequencer;\nstatic __inline void unpause_sequencer;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nu_int our_id;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC int\nahc_reset_channel(ahc, channel, initiate_reset)\n\tstruct ahc_softc *ahc;\n\tchar channel;\n\tint initiate_reset;\n{\n\tu_int\tinitiator, target, max_scsiid;\n\tu_int\tsblkctl;\n\tu_int\tour_id;\n\tint\tfound;\n\tint\trestart_needed;\n\tchar\tcur_channel;\n\n\tahc->pending_device = NULL;\n\n\tpause_sequencer(ahc);\n\n\t/*\n\t * Run our command complete fifos to ensure that we perform\n\t * completion processing on any commands that 'completed'\n\t * before the reset occurred.\n\t */\n\tahc_run_qoutfifo(ahc);\n\n\t/*\n\t * Reset the bus if we are initiating this reset\n\t */\n\tsblkctl = ahc_inb(ahc, SBLKCTL);\n\tcur_channel = 'A';\n\tif ((ahc->features & AHC_TWIN) != 0\n\t && ((sblkctl & SELBUSB) != 0))\n\t    cur_channel = 'B';\n\tif (cur_channel != channel) {\n\t\t/* Case 1: Command for another bus is active\n\t\t * Stealthily reset the other bus without\n\t\t * upsetting the current bus.\n\t\t */\n\t\tahc_outb(ahc, SBLKCTL, sblkctl ^ SELBUSB);\n\t\tahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENBUSFREE);\n\t\tahc_outb(ahc, SCSISEQ,\n\t\t\t ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP));\n\t\tif (initiate_reset)\n\t\t\tahc_reset_current_bus(ahc);\n\t\tahc_clear_intstat(ahc);\n\t\tahc_outb(ahc, SBLKCTL, sblkctl);\n\t\trestart_needed = FALSE;\n\t} else {\n\t\t/* Case 2: A command from this bus is active or we're idle */\n\t\tahc_clear_msg_state(ahc);\n\t\tahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENBUSFREE);\n\t\tahc_outb(ahc, SCSISEQ,\n\t\t\t ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP));\n\t\tif (initiate_reset)\n\t\t\tahc_reset_current_bus(ahc);\n\t\tahc_clear_intstat(ahc);\n\n\t\t/*\n\t\t * Since we are going to restart the sequencer, avoid\n\t\t * a race in the sequencer that could cause corruption\n\t\t * of our Q pointers by starting over from index 0.\n\t\t */\n\t\tahc->qoutfifonext = 0;\n\t\tif ((ahc->features & AHC_QUEUE_REGS) != 0)\n\t\t\tahc_outb(ahc, SDSCB_QOFF, 0);\n\t\telse\n\t\t\tahc_outb(ahc, QOUTPOS, 0);\n\t\trestart_needed = TRUE;\n\t}\n\n\t/*\n\t * Clean up all the state information for the\n\t * pending transactions on this bus.\n\t */\n\tfound = ahc_abort_scbs(ahc, ALL_TARGETS, channel,\n\t\t\t       ALL_LUNS, SCB_LIST_NULL,\n\t\t\t       ROLE_UNKNOWN, XS_RESET);\n\tif (channel == 'B') {\n\t\tour_id = ahc->our_id_b;\n\t} else {\n\t\tour_id = ahc->our_id;\n\t}\n\n\tmax_scsiid = (ahc->features & AHC_WIDE) ? 15 : 7;\n\t\n\t/*\n\t * Revert to async/narrow transfers until we renegotiate.\n\t */\n\tfor (target = 0; target <= max_scsiid; target++) {\n\n\t\tif (ahc->enabled_targets[target] == NULL)\n\t\t\tcontinue;\n\t\tfor (initiator = 0; initiator <= max_scsiid; initiator++) {\n\t\t\tstruct ahc_devinfo devinfo;\n\n\t\t\tahc_compile_devinfo(&devinfo, target, initiator,\n\t\t\t\t\t    ALL_LUNS,\n\t\t\t\t\t    channel, ROLE_UNKNOWN);\n\t\t\tahc_set_width(ahc, &devinfo,\n\t\t\t\t      MSG_EXT_WDTR_BUS_8_BIT,\n\t\t\t\t      AHC_TRANS_CUR,\n\t\t\t\t      /*paused*/TRUE,\n\t\t\t\t      /*done*/FALSE);\n\t\t\tahc_set_syncrate(ahc, &devinfo,\n\t\t\t\t\t /*syncrate*/NULL, /*period*/0,\n\t\t\t\t\t /*offset*/0, AHC_TRANS_CUR,\n\t\t\t\t\t /*paused*/TRUE,\n\t\t\t\t\t /*done*/FALSE);\n\t\t}\n\t}\n\n\tif (restart_needed)\n\t\trestart_sequencer(ahc);\n\telse\n\t\tunpause_sequencer(ahc);\n\treturn found;\n}"
  },
  {
    "function_name": "ahc_reset_current_bus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "5393-5410",
    "snippet": "STATIC void\nahc_reset_current_bus(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tu_int8_t scsiseq;\n\n\tahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENSCSIRST);\n\tscsiseq = ahc_inb(ahc, SCSISEQ);\n\tahc_outb(ahc, SCSISEQ, scsiseq | SCSIRSTO);\n\tDELAY(AHC_BUSRESET_DELAY);\n\t/* Turn off the bus reset */\n\tahc_outb(ahc, SCSISEQ, scsiseq & ~SCSIRSTO);\n\n\tahc_clear_intstat(ahc);\n\n\t/* Re-enable reset interrupts */\n\tahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) | ENSCSIRST);\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define AHC_BUSRESET_DELAY\t25\t/* Reset delay in us */",
      "#define STATIC\tstatic",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_set_tags __P((struct ahc_softc *ahc,\n\t\t\t\t  struct ahc_devinfo *devinfo,int enable));",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SIMODE1",
            "ahc_inb(ahc, SIMODE1) | ENSCSIRST"
          ],
          "line": 5409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SIMODE1"
          ],
          "line": 5409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_clear_intstat",
          "args": [
            "ahc"
          ],
          "line": 5406
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_clear_intstat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "5381-5391",
          "snippet": "STATIC void\nahc_clear_intstat(ahc)\n\tstruct ahc_softc *ahc;\n{\n\t/* Clear any interrupt conditions this may have caused */\n\tahc_outb(ahc, CLRSINT0, CLRSELDO|CLRSELDI|CLRSELINGO);\n\tahc_outb(ahc, CLRSINT1, CLRSELTIMEO|CLRATNO|CLRSCSIRSTI\n\t\t\t\t|CLRBUSFREE|CLRSCSIPERR|CLRPHASECHG|\n\t\t\t\tCLRREQINIT);\n\tahc_outb(ahc, CLRINT, CLRSCSIINT);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_clear_intstat(ahc)\n\tstruct ahc_softc *ahc;\n{\n\t/* Clear any interrupt conditions this may have caused */\n\tahc_outb(ahc, CLRSINT0, CLRSELDO|CLRSELDI|CLRSELINGO);\n\tahc_outb(ahc, CLRSINT1, CLRSELTIMEO|CLRATNO|CLRSCSIRSTI\n\t\t\t\t|CLRBUSFREE|CLRSCSIPERR|CLRPHASECHG|\n\t\t\t\tCLRREQINIT);\n\tahc_outb(ahc, CLRINT, CLRSCSIINT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCSISEQ",
            "scsiseq & ~SCSIRSTO"
          ],
          "line": 5404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "AHC_BUSRESET_DELAY"
          ],
          "line": 5402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCSISEQ",
            "scsiseq | SCSIRSTO"
          ],
          "line": 5401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCSISEQ"
          ],
          "line": 5400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SIMODE1",
            "ahc_inb(ahc, SIMODE1) & ~ENSCSIRST"
          ],
          "line": 5399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SIMODE1"
          ],
          "line": 5399
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define AHC_BUSRESET_DELAY\t25\t/* Reset delay in us */\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_set_tags __P((struct ahc_softc *ahc,\n\t\t\t\t  struct ahc_devinfo *devinfo,int enable));\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_reset_current_bus(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tu_int8_t scsiseq;\n\n\tahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENSCSIRST);\n\tscsiseq = ahc_inb(ahc, SCSISEQ);\n\tahc_outb(ahc, SCSISEQ, scsiseq | SCSIRSTO);\n\tDELAY(AHC_BUSRESET_DELAY);\n\t/* Turn off the bus reset */\n\tahc_outb(ahc, SCSISEQ, scsiseq & ~SCSIRSTO);\n\n\tahc_clear_intstat(ahc);\n\n\t/* Re-enable reset interrupts */\n\tahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) | ENSCSIRST);\n}"
  },
  {
    "function_name": "ahc_clear_intstat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "5381-5391",
    "snippet": "STATIC void\nahc_clear_intstat(ahc)\n\tstruct ahc_softc *ahc;\n{\n\t/* Clear any interrupt conditions this may have caused */\n\tahc_outb(ahc, CLRSINT0, CLRSELDO|CLRSELDI|CLRSELINGO);\n\tahc_outb(ahc, CLRSINT1, CLRSELTIMEO|CLRATNO|CLRSCSIRSTI\n\t\t\t\t|CLRBUSFREE|CLRSCSIPERR|CLRPHASECHG|\n\t\t\t\tCLRREQINIT);\n\tahc_outb(ahc, CLRINT, CLRSCSIINT);\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define STATIC\tstatic",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "CLRINT",
            "CLRSCSIINT"
          ],
          "line": 5390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "CLRSINT1",
            "CLRSELTIMEO|CLRATNO|CLRSCSIRSTI\n\t\t\t\t|CLRBUSFREE|CLRSCSIPERR|CLRPHASECHG|\n\t\t\t\tCLRREQINIT"
          ],
          "line": 5387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "CLRSINT0",
            "CLRSELDO|CLRSELDI|CLRSELINGO"
          ],
          "line": 5386
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_clear_intstat(ahc)\n\tstruct ahc_softc *ahc;\n{\n\t/* Clear any interrupt conditions this may have caused */\n\tahc_outb(ahc, CLRSINT0, CLRSELDO|CLRSELDI|CLRSELINGO);\n\tahc_outb(ahc, CLRSINT1, CLRSELTIMEO|CLRATNO|CLRSCSIRSTI\n\t\t\t\t|CLRBUSFREE|CLRSCSIPERR|CLRPHASECHG|\n\t\t\t\tCLRREQINIT);\n\tahc_outb(ahc, CLRINT, CLRSCSIINT);\n}"
  },
  {
    "function_name": "ahc_abort_wscb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "5334-5379",
    "snippet": "STATIC u_int\nahc_abort_wscb(ahc, scbpos, prev)\n\tstruct ahc_softc *ahc;\n\tu_int scbpos;\n        u_int prev;\n{       \n\tu_int curscb, next;\n\n\t/*\n\t * Select the SCB we want to abort and\n\t * pull the next pointer out of it.\n\t */\n\tcurscb = ahc_inb(ahc, SCBPTR);\n\tahc_outb(ahc, SCBPTR, scbpos);\n\tnext = ahc_inb(ahc, SCB_NEXT);\n\n\t/* Clear the necessary fields */\n\tahc_outb(ahc, SCB_CONTROL, 0);\n\n\tahc_add_curscb_to_free_list(ahc);\n\n\t/* update the waiting list */\n\tif (prev == SCB_LIST_NULL) {\n\t\t/* First in the list */\n\t\tahc_outb(ahc, WAITING_SCBH, next); \n\n\t\t/*\n\t\t * Ensure we aren't attempting to perform\n\t\t * selection for this entry.\n\t\t */\n\t\tahc_outb(ahc, SCSISEQ, (ahc_inb(ahc, SCSISEQ) & ~ENSELO));\n\t} else {\n\t\t/*\n\t\t * Select the scb that pointed to us \n\t\t * and update its next pointer.\n\t\t */\n\t\tahc_outb(ahc, SCBPTR, prev);\n\t\tahc_outb(ahc, SCB_NEXT, next);\n\t}\n\n\t/*\n\t * Point us back at the original scb position.\n\t */\n\tahc_outb(ahc, SCBPTR, curscb);\n\treturn next;\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define STATIC\tstatic",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
      "STATIC void",
      "STATIC void",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC u_int",
      "ahc_abort_wscb __P((struct ahc_softc *ahc,\n\t\t\t\t    u_int scbpos, u_int prev));",
      "STATIC void",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC u_int",
      "STATIC void",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "STATIC u_int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_calc_residual __P((struct scb *scb));",
      "STATIC void",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
      "STATIC void",
      "STATIC void",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
      "STATIC void",
      "STATIC void",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCBPTR",
            "curscb"
          ],
          "line": 5377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCB_NEXT",
            "next"
          ],
          "line": 5371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCBPTR",
            "prev"
          ],
          "line": 5370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCSISEQ",
            "(ahc_inb(ahc, SCSISEQ) & ~ENSELO)"
          ],
          "line": 5364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCSISEQ"
          ],
          "line": 5364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "WAITING_SCBH",
            "next"
          ],
          "line": 5358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_add_curscb_to_free_list",
          "args": [
            "ahc"
          ],
          "line": 5353
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_add_curscb_to_free_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "5319-5328",
          "snippet": "STATIC void\nahc_add_curscb_to_free_list(ahc)\n\tstruct ahc_softc *ahc;\n{\n\t/* Invalidate the tag so that ahc_find_scb doesn't think it's active */\n\tahc_outb(ahc, SCB_TAG, SCB_LIST_NULL);\n\n\tahc_outb(ahc, SCB_NEXT, ahc_inb(ahc, FREE_SCBH));\n\tahc_outb(ahc, FREE_SCBH, ahc_inb(ahc, SCBPTR));\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_add_curscb_to_free_list(ahc)\n\tstruct ahc_softc *ahc;\n{\n\t/* Invalidate the tag so that ahc_find_scb doesn't think it's active */\n\tahc_outb(ahc, SCB_TAG, SCB_LIST_NULL);\n\n\tahc_outb(ahc, SCB_NEXT, ahc_inb(ahc, FREE_SCBH));\n\tahc_outb(ahc, FREE_SCBH, ahc_inb(ahc, SCBPTR));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCB_CONTROL",
            "0"
          ],
          "line": 5351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCB_NEXT"
          ],
          "line": 5348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCBPTR",
            "scbpos"
          ],
          "line": 5347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCBPTR"
          ],
          "line": 5346
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC u_int;\nahc_abort_wscb __P((struct ahc_softc *ahc,\n\t\t\t\t    u_int scbpos, u_int prev));\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_calc_residual __P((struct scb *scb));\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC u_int\nahc_abort_wscb(ahc, scbpos, prev)\n\tstruct ahc_softc *ahc;\n\tu_int scbpos;\n        u_int prev;\n{       \n\tu_int curscb, next;\n\n\t/*\n\t * Select the SCB we want to abort and\n\t * pull the next pointer out of it.\n\t */\n\tcurscb = ahc_inb(ahc, SCBPTR);\n\tahc_outb(ahc, SCBPTR, scbpos);\n\tnext = ahc_inb(ahc, SCB_NEXT);\n\n\t/* Clear the necessary fields */\n\tahc_outb(ahc, SCB_CONTROL, 0);\n\n\tahc_add_curscb_to_free_list(ahc);\n\n\t/* update the waiting list */\n\tif (prev == SCB_LIST_NULL) {\n\t\t/* First in the list */\n\t\tahc_outb(ahc, WAITING_SCBH, next); \n\n\t\t/*\n\t\t * Ensure we aren't attempting to perform\n\t\t * selection for this entry.\n\t\t */\n\t\tahc_outb(ahc, SCSISEQ, (ahc_inb(ahc, SCSISEQ) & ~ENSELO));\n\t} else {\n\t\t/*\n\t\t * Select the scb that pointed to us \n\t\t * and update its next pointer.\n\t\t */\n\t\tahc_outb(ahc, SCBPTR, prev);\n\t\tahc_outb(ahc, SCB_NEXT, next);\n\t}\n\n\t/*\n\t * Point us back at the original scb position.\n\t */\n\tahc_outb(ahc, SCBPTR, curscb);\n\treturn next;\n}"
  },
  {
    "function_name": "ahc_add_curscb_to_free_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "5319-5328",
    "snippet": "STATIC void\nahc_add_curscb_to_free_list(ahc)\n\tstruct ahc_softc *ahc;\n{\n\t/* Invalidate the tag so that ahc_find_scb doesn't think it's active */\n\tahc_outb(ahc, SCB_TAG, SCB_LIST_NULL);\n\n\tahc_outb(ahc, SCB_NEXT, ahc_inb(ahc, FREE_SCBH));\n\tahc_outb(ahc, FREE_SCBH, ahc_inb(ahc, SCBPTR));\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define STATIC\tstatic",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "FREE_SCBH",
            "ahc_inb(ahc, SCBPTR)"
          ],
          "line": 5327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCBPTR"
          ],
          "line": 5327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCB_NEXT",
            "ahc_inb(ahc, FREE_SCBH)"
          ],
          "line": 5326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "FREE_SCBH"
          ],
          "line": 5326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCB_TAG",
            "SCB_LIST_NULL"
          ],
          "line": 5324
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_add_curscb_to_free_list(ahc)\n\tstruct ahc_softc *ahc;\n{\n\t/* Invalidate the tag so that ahc_find_scb doesn't think it's active */\n\tahc_outb(ahc, SCB_TAG, SCB_LIST_NULL);\n\n\tahc_outb(ahc, SCB_NEXT, ahc_inb(ahc, FREE_SCBH));\n\tahc_outb(ahc, FREE_SCBH, ahc_inb(ahc, SCBPTR));\n}"
  },
  {
    "function_name": "ahc_rem_scb_from_disc_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "5295-5317",
    "snippet": "STATIC u_int\nahc_rem_scb_from_disc_list(ahc, prev, scbptr)\n\tstruct ahc_softc *ahc;\n\tu_int prev;\n\tu_int scbptr;\n{\n\tu_int next;\n\n\tahc_outb(ahc, SCBPTR, scbptr);\n\tnext = ahc_inb(ahc, SCB_NEXT);\n\n\tahc_outb(ahc, SCB_CONTROL, 0);\n\n\tahc_add_curscb_to_free_list(ahc);\n\n\tif (prev != SCB_LIST_NULL) {\n\t\tahc_outb(ahc, SCBPTR, prev);\n\t\tahc_outb(ahc, SCB_NEXT, next);\n\t} else\n\t\tahc_outb(ahc, DISCONNECTED_SCBH, next);\n\n\treturn (next);\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define STATIC\tstatic",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC u_int",
      "ahc_abort_wscb __P((struct ahc_softc *ahc,\n\t\t\t\t    u_int scbpos, u_int prev));",
      "STATIC void",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC u_int",
      "ahc_rem_scb_from_disc_list __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tu_int prev, u_int scbptr));",
      "STATIC void",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "STATIC u_int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "DISCONNECTED_SCBH",
            "next"
          ],
          "line": 5314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCB_NEXT",
            "next"
          ],
          "line": 5312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCBPTR",
            "prev"
          ],
          "line": 5311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_add_curscb_to_free_list",
          "args": [
            "ahc"
          ],
          "line": 5308
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_add_curscb_to_free_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "5319-5328",
          "snippet": "STATIC void\nahc_add_curscb_to_free_list(ahc)\n\tstruct ahc_softc *ahc;\n{\n\t/* Invalidate the tag so that ahc_find_scb doesn't think it's active */\n\tahc_outb(ahc, SCB_TAG, SCB_LIST_NULL);\n\n\tahc_outb(ahc, SCB_NEXT, ahc_inb(ahc, FREE_SCBH));\n\tahc_outb(ahc, FREE_SCBH, ahc_inb(ahc, SCBPTR));\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_add_curscb_to_free_list(ahc)\n\tstruct ahc_softc *ahc;\n{\n\t/* Invalidate the tag so that ahc_find_scb doesn't think it's active */\n\tahc_outb(ahc, SCB_TAG, SCB_LIST_NULL);\n\n\tahc_outb(ahc, SCB_NEXT, ahc_inb(ahc, FREE_SCBH));\n\tahc_outb(ahc, FREE_SCBH, ahc_inb(ahc, SCBPTR));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCB_CONTROL",
            "0"
          ],
          "line": 5306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCB_NEXT"
          ],
          "line": 5304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCBPTR",
            "scbptr"
          ],
          "line": 5303
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC u_int;\nahc_abort_wscb __P((struct ahc_softc *ahc,\n\t\t\t\t    u_int scbpos, u_int prev));\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nahc_rem_scb_from_disc_list __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tu_int prev, u_int scbptr));\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC u_int\nahc_rem_scb_from_disc_list(ahc, prev, scbptr)\n\tstruct ahc_softc *ahc;\n\tu_int prev;\n\tu_int scbptr;\n{\n\tu_int next;\n\n\tahc_outb(ahc, SCBPTR, scbptr);\n\tnext = ahc_inb(ahc, SCB_NEXT);\n\n\tahc_outb(ahc, SCB_CONTROL, 0);\n\n\tahc_add_curscb_to_free_list(ahc);\n\n\tif (prev != SCB_LIST_NULL) {\n\t\tahc_outb(ahc, SCBPTR, prev);\n\t\tahc_outb(ahc, SCB_NEXT, next);\n\t} else\n\t\tahc_outb(ahc, DISCONNECTED_SCBH, next);\n\n\treturn (next);\n}"
  },
  {
    "function_name": "ahc_search_disc_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "5233-5293",
    "snippet": "STATIC int\nahc_search_disc_list(ahc, target, channel, lun, tag, stop_on_first, \n\t\t     remove, save_state)\n\tstruct ahc_softc *ahc;\n\tint target;\n\tchar channel;\n\tint lun;\n\tu_int tag;\n\tint stop_on_first;\n\tint remove;\n\tint save_state;\n{\n\tstruct\tscb *scbp;\n\tu_int\tnext;\n\tu_int\tprev;\n\tu_int\tcount;\n\tu_int\tactive_scb;\n\n\tcount = 0;\n\tnext = ahc_inb(ahc, DISCONNECTED_SCBH);\n\tprev = SCB_LIST_NULL;\n\n\tif (save_state) {\n\t/* restore this when we're done */\n\tactive_scb = ahc_inb(ahc, SCBPTR);\n\t} else\n\t\t/* Silence compiler */\n\t\tactive_scb = SCB_LIST_NULL;\n\n\twhile (next != SCB_LIST_NULL) {\n\t\tu_int scb_index;\n\n\t\tahc_outb(ahc, SCBPTR, next);\n\t\tscb_index = ahc_inb(ahc, SCB_TAG);\n\t\tif (scb_index >= ahc->scb_data->numscbs) {\n\t\t\tpanic(\"Disconnected List inconsistency. \"\n\t\t\t      \"SCB index == %d, yet numscbs == %d.\",\n\t\t\t      scb_index, ahc->scb_data->numscbs);\n\t\t}\n\t\tscbp = &ahc->scb_data->scbarray[scb_index];\n\t\tif (ahc_match_scb(scbp, target, channel, lun,\n\t\t\t\t  tag, ROLE_INITIATOR)) {\n\t\t\tcount++;\n\t\t\tif (remove) {\n\t\t\t\tnext =\n\t\t\t\t    ahc_rem_scb_from_disc_list(ahc, prev, next);\n\t\t\t} else {\n\t\t\t\tprev = next;\n\t\t\t\tnext = ahc_inb(ahc, SCB_NEXT);\n\t\t\t}\n\t\t\tif (stop_on_first)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tprev = next;\n\t\t\tnext = ahc_inb(ahc, SCB_NEXT);\n\t\t}\n\t}\n\tif (save_state)\n\tahc_outb(ahc, SCBPTR, active_scb);\n\treturn (count);\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define STATIC\tstatic",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
      "STATIC void",
      "STATIC void",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC u_int",
      "ahc_abort_wscb __P((struct ahc_softc *ahc,\n\t\t\t\t    u_int scbpos, u_int prev));",
      "STATIC void",
      "ahc_done __P((struct ahc_softc *ahc, struct scb *scbp));",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "ahc_search_disc_list __P((struct ahc_softc *ahc, int target,\n\t\t\t\t\t  char channel, int lun, u_int tag,\n\t\t\t\t\t  int stop_on_first, int remove,\n\t\t\t\t\t  int save_state));",
      "STATIC u_int",
      "STATIC void",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "STATIC u_int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));",
      "STATIC void",
      "ahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_calc_residual __P((struct scb *scb));",
      "STATIC void",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
      "STATIC void",
      "STATIC void",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
      "STATIC void",
      "STATIC void",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "char channel;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "char channel;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCBPTR",
            "active_scb"
          ],
          "line": 5291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCB_NEXT"
          ],
          "line": 5287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCB_NEXT"
          ],
          "line": 5281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_rem_scb_from_disc_list",
          "args": [
            "ahc",
            "prev",
            "next"
          ],
          "line": 5278
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_rem_scb_from_disc_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "5295-5317",
          "snippet": "STATIC u_int\nahc_rem_scb_from_disc_list(ahc, prev, scbptr)\n\tstruct ahc_softc *ahc;\n\tu_int prev;\n\tu_int scbptr;\n{\n\tu_int next;\n\n\tahc_outb(ahc, SCBPTR, scbptr);\n\tnext = ahc_inb(ahc, SCB_NEXT);\n\n\tahc_outb(ahc, SCB_CONTROL, 0);\n\n\tahc_add_curscb_to_free_list(ahc);\n\n\tif (prev != SCB_LIST_NULL) {\n\t\tahc_outb(ahc, SCBPTR, prev);\n\t\tahc_outb(ahc, SCB_NEXT, next);\n\t} else\n\t\tahc_outb(ahc, DISCONNECTED_SCBH, next);\n\n\treturn (next);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC u_int",
            "ahc_abort_wscb __P((struct ahc_softc *ahc,\n\t\t\t\t    u_int scbpos, u_int prev));",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "ahc_rem_scb_from_disc_list __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tu_int prev, u_int scbptr));",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC u_int;\nahc_abort_wscb __P((struct ahc_softc *ahc,\n\t\t\t\t    u_int scbpos, u_int prev));\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nahc_rem_scb_from_disc_list __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tu_int prev, u_int scbptr));\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC u_int\nahc_rem_scb_from_disc_list(ahc, prev, scbptr)\n\tstruct ahc_softc *ahc;\n\tu_int prev;\n\tu_int scbptr;\n{\n\tu_int next;\n\n\tahc_outb(ahc, SCBPTR, scbptr);\n\tnext = ahc_inb(ahc, SCB_NEXT);\n\n\tahc_outb(ahc, SCB_CONTROL, 0);\n\n\tahc_add_curscb_to_free_list(ahc);\n\n\tif (prev != SCB_LIST_NULL) {\n\t\tahc_outb(ahc, SCBPTR, prev);\n\t\tahc_outb(ahc, SCB_NEXT, next);\n\t} else\n\t\tahc_outb(ahc, DISCONNECTED_SCBH, next);\n\n\treturn (next);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_match_scb",
          "args": [
            "scbp",
            "target",
            "channel",
            "lun",
            "tag",
            "ROLE_INITIATOR"
          ],
          "line": 5273
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_match_scb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "5529-5549",
          "snippet": "STATIC int\nahc_match_scb(scb, target, channel, lun, role, tag)\n\tstruct scb *scb;\n\tint target;\n\tchar channel;\n\tint lun;\n\trole_t role;\n\tu_int tag;\n{\n\tint targ = SCB_TARGET(scb);\n\tchar chan = SCB_CHANNEL(scb);\n\tint slun = SCB_LUN(scb);\n\tint match;\n\n\tmatch = ((chan == channel) || (channel == ALL_CHANNELS));\n\tif (match != 0)\n\t\tmatch = ((targ == target) || (target == ALL_TARGETS));\n\tif (match != 0)\n\t\tmatch = ((lun == slun) || (lun == ALL_LUNS));\n\treturn match;\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC",
            "#define ALL_CHANNELS '\\0'"
          ],
          "globals_used": [
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "ahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_calc_residual __P((struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "char channel;",
            "STATIC struct",
            "STATIC struct",
            "STATIC struct",
            "char channel;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n#define ALL_CHANNELS '\\0'\n\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_calc_residual __P((struct scb *scb));\nSTATIC void;\nSTATIC void;\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nSTATIC void;\nSTATIC void;\nchar channel;\nSTATIC struct;\nSTATIC struct;\nSTATIC struct;\nchar channel;\n\nSTATIC int\nahc_match_scb(scb, target, channel, lun, role, tag)\n\tstruct scb *scb;\n\tint target;\n\tchar channel;\n\tint lun;\n\trole_t role;\n\tu_int tag;\n{\n\tint targ = SCB_TARGET(scb);\n\tchar chan = SCB_CHANNEL(scb);\n\tint slun = SCB_LUN(scb);\n\tint match;\n\n\tmatch = ((chan == channel) || (channel == ALL_CHANNELS));\n\tif (match != 0)\n\t\tmatch = ((targ == target) || (target == ALL_TARGETS));\n\tif (match != 0)\n\t\tmatch = ((lun == slun) || (lun == ALL_LUNS));\n\treturn match;\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"Disconnected List inconsistency. \"\n\t\t\t      \"SCB index == %d, yet numscbs == %d.\"",
            "scb_index",
            "ahc->scb_data->numscbs"
          ],
          "line": 5268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCB_TAG"
          ],
          "line": 5266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCBPTR",
            "next"
          ],
          "line": 5265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCBPTR"
          ],
          "line": 5257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "DISCONNECTED_SCBH"
          ],
          "line": 5252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC u_int;\nahc_abort_wscb __P((struct ahc_softc *ahc,\n\t\t\t\t    u_int scbpos, u_int prev));\nSTATIC void;\nahc_done __P((struct ahc_softc *ahc, struct scb *scbp));\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nahc_search_disc_list __P((struct ahc_softc *ahc, int target,\n\t\t\t\t\t  char channel, int lun, u_int tag,\n\t\t\t\t\t  int stop_on_first, int remove,\n\t\t\t\t\t  int save_state));\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));\nSTATIC void;\nahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_calc_residual __P((struct scb *scb));\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC int\nahc_search_disc_list(ahc, target, channel, lun, tag, stop_on_first, \n\t\t     remove, save_state)\n\tstruct ahc_softc *ahc;\n\tint target;\n\tchar channel;\n\tint lun;\n\tu_int tag;\n\tint stop_on_first;\n\tint remove;\n\tint save_state;\n{\n\tstruct\tscb *scbp;\n\tu_int\tnext;\n\tu_int\tprev;\n\tu_int\tcount;\n\tu_int\tactive_scb;\n\n\tcount = 0;\n\tnext = ahc_inb(ahc, DISCONNECTED_SCBH);\n\tprev = SCB_LIST_NULL;\n\n\tif (save_state) {\n\t/* restore this when we're done */\n\tactive_scb = ahc_inb(ahc, SCBPTR);\n\t} else\n\t\t/* Silence compiler */\n\t\tactive_scb = SCB_LIST_NULL;\n\n\twhile (next != SCB_LIST_NULL) {\n\t\tu_int scb_index;\n\n\t\tahc_outb(ahc, SCBPTR, next);\n\t\tscb_index = ahc_inb(ahc, SCB_TAG);\n\t\tif (scb_index >= ahc->scb_data->numscbs) {\n\t\t\tpanic(\"Disconnected List inconsistency. \"\n\t\t\t      \"SCB index == %d, yet numscbs == %d.\",\n\t\t\t      scb_index, ahc->scb_data->numscbs);\n\t\t}\n\t\tscbp = &ahc->scb_data->scbarray[scb_index];\n\t\tif (ahc_match_scb(scbp, target, channel, lun,\n\t\t\t\t  tag, ROLE_INITIATOR)) {\n\t\t\tcount++;\n\t\t\tif (remove) {\n\t\t\t\tnext =\n\t\t\t\t    ahc_rem_scb_from_disc_list(ahc, prev, next);\n\t\t\t} else {\n\t\t\t\tprev = next;\n\t\t\t\tnext = ahc_inb(ahc, SCB_NEXT);\n\t\t\t}\n\t\t\tif (stop_on_first)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tprev = next;\n\t\t\tnext = ahc_inb(ahc, SCB_NEXT);\n\t\t}\n\t}\n\tif (save_state)\n\tahc_outb(ahc, SCBPTR, active_scb);\n\treturn (count);\n}"
  },
  {
    "function_name": "ahc_abort_scbs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "5129-5231",
    "snippet": "STATIC int\nahc_abort_scbs(ahc, target, channel, lun, tag, role, status)\n\tstruct ahc_softc *ahc;\n\tint target;\n\tchar channel;\n\tint lun;\n\tu_int tag;\n\trole_t role;\n\tu_int32_t status;\n{\n\tstruct\tscb *scbp;\n\tu_int\tactive_scb;\n\tint\ti;\n\tint\tfound;\n\n\t/* restore this when we're done */\n\tactive_scb = ahc_inb(ahc, SCBPTR);\n\n\tfound = ahc_search_qinfifo(ahc, target, channel, lun, SCB_LIST_NULL,\n\t\t\t\t   role, SCB_REQUEUE, SEARCH_COMPLETE);\n\n\t/*\n\t * Search waiting for selection list.\n\t */\n\t{\n\t\tu_int8_t next, prev;\n                /* Start at head of list. */\n\t\tnext = ahc_inb(ahc, WAITING_SCBH);\n\t\tprev = SCB_LIST_NULL;\n\n\t\twhile (next != SCB_LIST_NULL) {\n\t\t\tu_int8_t scb_index;\n\n\t\t\tahc_outb(ahc, SCBPTR, next);\n\t\t\tscb_index = ahc_inb(ahc, SCB_TAG);\n\t\t\tif (scb_index >= ahc->scb_data->numscbs) {\n\t\t\t\tpanic(\"Waiting List inconsistency. \"\n\t\t\t\t      \"SCB index == %d, yet numscbs == %d.\",\n\t\t\t\t      scb_index, ahc->scb_data->numscbs);\n\t\t\t}\n\t\t\tscbp = &ahc->scb_data->scbarray[scb_index];\n\t\t\tif (ahc_match_scb(scbp, target, channel,\n\t\t\t\t\t  lun, SCB_LIST_NULL, role)) {\n\n\t\t\t\tnext = ahc_abort_wscb(ahc, next, prev);\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tprev = next;\n\t\t\t\tnext = ahc_inb(ahc, SCB_NEXT);\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\t * Go through the disconnected list and remove any entries we\n\t * have queued for completion, 0'ing their control byte too.\n\t * We save the active SCB and restore it ourselves, so there\n\t * is no reason for this search to restore it too.\n\t */\n\tahc_search_disc_list(ahc, target, channel, lun, tag,\n\t\t\t     /*stop_on_first*/FALSE, /*remove*/TRUE,\n\t\t\t     /*save_state*/FALSE);\n\n\t/*\n\t * Go through the hardware SCB array looking for commands that\n\t * were active but not on any list.\n\t */\n\tfor(i = 0; i < ahc->scb_data->maxhscbs; i++) {\n\t\tu_int scbid;\n\n\t\tahc_outb(ahc, SCBPTR, i);\n\t\tscbid = ahc_inb(ahc, SCB_TAG);\n\t\tscbp = &ahc->scb_data->scbarray[scbid];\n\t\tif (scbid < ahc->scb_data->numscbs && \n\t\t\t ahc_match_scb(scbp, target, channel, lun, tag, role))\n\t\t\t\tahc_add_curscb_to_free_list(ahc);\n\t}\n\n\t/*\n\t * Go through the pending CCB list and look for\n\t * commands for this target that are still active.\n\t * These are other tagged commands that were\n\t * disconnected when the reset occured.\n\t */\n\t{\n\t\tstruct scb *scb;\n\n\t\tscb = ahc->pending_scbs.lh_first;\n\t\twhile (scb != NULL) {\n\t\t\tscbp = scb;\n\t\t\tscb = scb->pend_links.le_next;\n\t\t\tif (ahc_match_scb(scbp, target, channel,\n\t\t\t\t\t  lun, tag, role)) {\n\t\t\t\tif (!(scbp->xs->flags & ITSDONE))\n\t\t\t\t\tahcsetccbstatus(scbp->xs, status);\n\t\t\t\tahc_freeze_ccb(scbp);\n\t\t\t\tahc_done(ahc, scbp);\n\t\t\t\tfound++;\n\t\t\t}\n\t\t}\n\t}\n\tahc_outb(ahc, SCBPTR, active_scb);\n\treturn found;\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define STATIC\tstatic",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
      "STATIC void",
      "STATIC void",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "ahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));",
      "STATIC u_int",
      "ahc_abort_wscb __P((struct ahc_softc *ahc,\n\t\t\t\t    u_int scbpos, u_int prev));",
      "STATIC void",
      "ahc_done __P((struct ahc_softc *ahc, struct scb *scbp));",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "ahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "ahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));",
      "STATIC int",
      "ahc_search_disc_list __P((struct ahc_softc *ahc, int target,\n\t\t\t\t\t  char channel, int lun, u_int tag,\n\t\t\t\t\t  int stop_on_first, int remove,\n\t\t\t\t\t  int save_state));",
      "STATIC u_int",
      "STATIC void",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "STATIC u_int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));",
      "STATIC void",
      "ahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));",
      "STATIC void",
      "STATIC int",
      "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
      "STATIC void",
      "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_calc_residual __P((struct scb *scb));",
      "STATIC void",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
      "STATIC void",
      "STATIC void",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "static __inline void ahc_freeze_ccb",
      "static __inline void ahcsetccbstatus",
      "STATIC void",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
      "STATIC void",
      "STATIC void",
      "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "char channel;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "char channel;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *xs;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCBPTR",
            "active_scb"
          ],
          "line": 5229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_done",
          "args": [
            "ahc",
            "scbp"
          ],
          "line": 5224
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "3401-3537",
          "snippet": "STATIC void\nahc_done(ahc, scb)\n\tstruct ahc_softc *ahc;\n\tstruct scb *scb;\n{\n\tstruct scsi_xfer *xs = scb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tint requeue = 0;\n\tint target;\n\n\tSC_DEBUG(xs->sc_link, SDEV_DB2, (\"ahc_done\\n\"));\n\t\n\tLIST_REMOVE(scb, pend_links);\n\n\tuntimeout(ahc_timeout, (caddr_t)scb);\n\n#ifdef AHC_DEBUG\n\tif (ahc_debug & AHC_SHOWCMDS) {\n\t\tsc_print_addr(sc_link);\n\t\tprintf(\"ahc_done opcode %d tag %x\\n\", xs->cmdstore.opcode,\n\t\t    scb->hscb->tag);\n\t}\n#endif\n\t\n\ttarget = sc_link->target;\n\t\n\tif (xs->datalen) {\n\t\tbus_dmasync_op_t op;\n\t\n\t\tif ((xs->flags & SCSI_DATA_IN) != 0)\n\t\t\top = BUS_DMASYNC_POSTREAD;\n\t\telse\n\t\t\top = BUS_DMASYNC_POSTWRITE;\n\t\tbus_dmamap_sync(ahc->sc_dmat, scb->dmamap, op);\n\t\tbus_dmamap_unload(ahc->sc_dmat, scb->dmamap);\n\t}\n\n\t/*\n\t * Unbusy this target/channel/lun.\n\t * XXX if we are holding two commands per lun, \n\t *     send the next command.\n\t */\n\tahc_index_busy_tcl(ahc, scb->hscb->tcl, /*unbusy*/TRUE);\n\n\t/*\n\t * If the recovery SCB completes, we have to be\n\t * out of our timeout.\n\t */\n\tif ((scb->flags & SCB_RECOVERY_SCB) != 0) {\n\n\t\tstruct\tscb *scbp;\n\n\t\t/*\n\t\t * We were able to complete the command successfully,\n\t\t * so reinstate the timeouts for all other pending\n\t\t * commands.\n\t\t */\n\t\tscbp = ahc->pending_scbs.lh_first;\n\t\twhile (scbp != NULL) {\n\t\t\tstruct scsi_xfer *txs = scbp->xs;\n\n\t\t\tif (!(txs->flags & SCSI_POLL)) {\n\t\t\t\ttimeout(ahc_timeout, scbp,\n\t\t\t\t    (scbp->xs->timeout * hz)/1000);\n\t\t\t}\n\t\t\tscbp = LIST_NEXT(scbp, pend_links);\n\t\t}\n\n\t\t/*\n\t\t * Ensure that we didn't put a second instance of this\n\t\t * SCB into the QINFIFO.\n\t\t */\n\t\tahc_search_qinfifo(ahc, SCB_TARGET(scb), SCB_CHANNEL(scb),\n\t\t\t\t   SCB_LUN(scb), scb->hscb->tag,\n\t\t\t\t   ROLE_INITIATOR, /*status*/0,\n\t\t\t\t   SEARCH_REMOVE);\n\t\tif (xs->error != XS_NOERROR)\n\t\t\tahcsetccbstatus(xs, XS_TIMEOUT);\n\t\tsc_print_addr(xs->sc_link);\n\t\tprintf(\"no longer in timeout, status = %x\\n\", xs->status);\n\t}\n\n\tif (xs->error != XS_NOERROR) {\n\t\t/* Don't clobber any existing error state */\n\t} else if ((scb->flags & SCB_SENSE) != 0) {\n\t\t/*\n\t\t * We performed autosense retrieval.\n\t\t *\n\t\t * bzero the sense data before having\n\t\t * the drive fill it.  The SCSI spec mandates\n\t\t * that any untransfered data should be\n\t\t * assumed to be zero.  Complete the 'bounce'\n\t\t * of sense information through buffers accessible\n\t\t * via bus-space by copying it into the clients\n\t\t * csio.\n\t\t */\n\t\tbzero(&xs->sense, sizeof(struct scsi_sense));\n\t\tbcopy(&ahc->scb_data->sense[scb->hscb->tag],\n\t\t      &xs->sense, scb->sg_list->len);\n\t\txs->error = XS_SENSE;\n\t}\n\tif (scb->flags & SCB_FREEZE_QUEUE) {\n\t\tahc->devqueue_blocked[target]--;\n\t\tscb->flags &= ~SCB_FREEZE_QUEUE;\n\t}\n\t\n\trequeue = scb->flags & SCB_REQUEUE;\n\tahcfreescb(ahc, scb);\n\n\tif (requeue) {\n\t\t/*\n\t\t * Re-insert at the front of the private queue to\n\t\t * preserve order.\n\t\t */\n\t\tint s;\n\n\t\ts = splbio();\n\t\t/* TAILQ_INSERT_HEAD(&ahc->sc_q, xs, adapter_q); */\n\t\tahc_list_insert_head(ahc, xs);\n\t\tsplx(s);\n\t} else {\n\t\txs->flags |= ITSDONE;\n\t\tahc_check_tags(ahc, xs);\n\t\tscsi_done(xs);\n\t}\n\n\t/*\n\t * If there are entries in the software queue, try to\n\t * run the first one.  We should be more or less guaranteed\n\t * to succeed, since we just freed an SCB.\n\t *\n\t * NOTE: ahc_scsi_cmd() relies on our calling it with\n\t * the first entry in the queue.\n\t */\n\tif ((xs = ahc->sc_xxxq.lh_first) != NULL)\n\t\t(void) ahc_scsi_cmd(xs);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
            "STATIC void",
            "ahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_done __P((struct ahc_softc *ahc, struct scb *scbp));",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "ahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));",
            "STATIC int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
            "STATIC void",
            "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_calc_residual __P((struct scb *scb));",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "static __inline u_int ahc_index_busy_tcl",
            "static __inline void ahcsetccbstatus",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "void   ahc_list_insert_head",
            "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *xs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nSTATIC void;\nahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_done __P((struct ahc_softc *ahc, struct scb *scbp));\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));\nSTATIC int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nSTATIC void;\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_calc_residual __P((struct scb *scb));\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nstatic __inline u_int ahc_index_busy_tcl;\nstatic __inline void ahcsetccbstatus;\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nSTATIC void;\nSTATIC void;\nvoid   ahc_list_insert_head;\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n\nSTATIC void\nahc_done(ahc, scb)\n\tstruct ahc_softc *ahc;\n\tstruct scb *scb;\n{\n\tstruct scsi_xfer *xs = scb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tint requeue = 0;\n\tint target;\n\n\tSC_DEBUG(xs->sc_link, SDEV_DB2, (\"ahc_done\\n\"));\n\t\n\tLIST_REMOVE(scb, pend_links);\n\n\tuntimeout(ahc_timeout, (caddr_t)scb);\n\n#ifdef AHC_DEBUG\n\tif (ahc_debug & AHC_SHOWCMDS) {\n\t\tsc_print_addr(sc_link);\n\t\tprintf(\"ahc_done opcode %d tag %x\\n\", xs->cmdstore.opcode,\n\t\t    scb->hscb->tag);\n\t}\n#endif\n\t\n\ttarget = sc_link->target;\n\t\n\tif (xs->datalen) {\n\t\tbus_dmasync_op_t op;\n\t\n\t\tif ((xs->flags & SCSI_DATA_IN) != 0)\n\t\t\top = BUS_DMASYNC_POSTREAD;\n\t\telse\n\t\t\top = BUS_DMASYNC_POSTWRITE;\n\t\tbus_dmamap_sync(ahc->sc_dmat, scb->dmamap, op);\n\t\tbus_dmamap_unload(ahc->sc_dmat, scb->dmamap);\n\t}\n\n\t/*\n\t * Unbusy this target/channel/lun.\n\t * XXX if we are holding two commands per lun, \n\t *     send the next command.\n\t */\n\tahc_index_busy_tcl(ahc, scb->hscb->tcl, /*unbusy*/TRUE);\n\n\t/*\n\t * If the recovery SCB completes, we have to be\n\t * out of our timeout.\n\t */\n\tif ((scb->flags & SCB_RECOVERY_SCB) != 0) {\n\n\t\tstruct\tscb *scbp;\n\n\t\t/*\n\t\t * We were able to complete the command successfully,\n\t\t * so reinstate the timeouts for all other pending\n\t\t * commands.\n\t\t */\n\t\tscbp = ahc->pending_scbs.lh_first;\n\t\twhile (scbp != NULL) {\n\t\t\tstruct scsi_xfer *txs = scbp->xs;\n\n\t\t\tif (!(txs->flags & SCSI_POLL)) {\n\t\t\t\ttimeout(ahc_timeout, scbp,\n\t\t\t\t    (scbp->xs->timeout * hz)/1000);\n\t\t\t}\n\t\t\tscbp = LIST_NEXT(scbp, pend_links);\n\t\t}\n\n\t\t/*\n\t\t * Ensure that we didn't put a second instance of this\n\t\t * SCB into the QINFIFO.\n\t\t */\n\t\tahc_search_qinfifo(ahc, SCB_TARGET(scb), SCB_CHANNEL(scb),\n\t\t\t\t   SCB_LUN(scb), scb->hscb->tag,\n\t\t\t\t   ROLE_INITIATOR, /*status*/0,\n\t\t\t\t   SEARCH_REMOVE);\n\t\tif (xs->error != XS_NOERROR)\n\t\t\tahcsetccbstatus(xs, XS_TIMEOUT);\n\t\tsc_print_addr(xs->sc_link);\n\t\tprintf(\"no longer in timeout, status = %x\\n\", xs->status);\n\t}\n\n\tif (xs->error != XS_NOERROR) {\n\t\t/* Don't clobber any existing error state */\n\t} else if ((scb->flags & SCB_SENSE) != 0) {\n\t\t/*\n\t\t * We performed autosense retrieval.\n\t\t *\n\t\t * bzero the sense data before having\n\t\t * the drive fill it.  The SCSI spec mandates\n\t\t * that any untransfered data should be\n\t\t * assumed to be zero.  Complete the 'bounce'\n\t\t * of sense information through buffers accessible\n\t\t * via bus-space by copying it into the clients\n\t\t * csio.\n\t\t */\n\t\tbzero(&xs->sense, sizeof(struct scsi_sense));\n\t\tbcopy(&ahc->scb_data->sense[scb->hscb->tag],\n\t\t      &xs->sense, scb->sg_list->len);\n\t\txs->error = XS_SENSE;\n\t}\n\tif (scb->flags & SCB_FREEZE_QUEUE) {\n\t\tahc->devqueue_blocked[target]--;\n\t\tscb->flags &= ~SCB_FREEZE_QUEUE;\n\t}\n\t\n\trequeue = scb->flags & SCB_REQUEUE;\n\tahcfreescb(ahc, scb);\n\n\tif (requeue) {\n\t\t/*\n\t\t * Re-insert at the front of the private queue to\n\t\t * preserve order.\n\t\t */\n\t\tint s;\n\n\t\ts = splbio();\n\t\t/* TAILQ_INSERT_HEAD(&ahc->sc_q, xs, adapter_q); */\n\t\tahc_list_insert_head(ahc, xs);\n\t\tsplx(s);\n\t} else {\n\t\txs->flags |= ITSDONE;\n\t\tahc_check_tags(ahc, xs);\n\t\tscsi_done(xs);\n\t}\n\n\t/*\n\t * If there are entries in the software queue, try to\n\t * run the first one.  We should be more or less guaranteed\n\t * to succeed, since we just freed an SCB.\n\t *\n\t * NOTE: ahc_scsi_cmd() relies on our calling it with\n\t * the first entry in the queue.\n\t */\n\tif ((xs = ahc->sc_xxxq.lh_first) != NULL)\n\t\t(void) ahc_scsi_cmd(xs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_freeze_ccb",
          "args": [
            "scbp"
          ],
          "line": 5223
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_freeze_ccb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "533-546",
          "snippet": "static __inline void\nahc_freeze_ccb(scb)\n\tstruct scb *scb;\n{\n\tstruct scsi_xfer *xs = scb->xs;\n\tstruct ahc_softc *ahc = (struct ahc_softc *)xs->sc_link->adapter_softc;\n\tint target;\n\n\ttarget = xs->sc_link->target;\n\tif (!(scb->flags & SCB_FREEZE_QUEUE)) {\n\t\tahc->devqueue_blocked[target]++;\n\t\tscb->flags |= SCB_FREEZE_QUEUE;\n\t}\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
            "ahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "ahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
            "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
            "ahc_calc_residual __P((struct scb *scb));",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "static __inline void ahc_freeze_ccb",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
            "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *xs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC struct;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));\nahc_loadseq __P((struct ahc_softc *ahc));\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nahc_clear_intstat __P((struct ahc_softc *ahc));\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nahc_calc_residual __P((struct scb *scb));\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nrestart_sequencer __P((struct ahc_softc *ahc));\nstatic __inline void ahc_freeze_ccb;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n\nstatic __inline void\nahc_freeze_ccb(scb)\n\tstruct scb *scb;\n{\n\tstruct scsi_xfer *xs = scb->xs;\n\tstruct ahc_softc *ahc = (struct ahc_softc *)xs->sc_link->adapter_softc;\n\tint target;\n\n\ttarget = xs->sc_link->target;\n\tif (!(scb->flags & SCB_FREEZE_QUEUE)) {\n\t\tahc->devqueue_blocked[target]++;\n\t\tscb->flags |= SCB_FREEZE_QUEUE;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahcsetccbstatus",
          "args": [
            "scbp->xs",
            "status"
          ],
          "line": 5222
        },
        "resolved": true,
        "details": {
          "function_name": "ahcsetccbstatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "548-554",
          "snippet": "static __inline void\nahcsetccbstatus(xs, status)\n\tstruct scsi_xfer *xs;\n\tint status;\n{\n\txs->error = status;\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "ahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));",
            "STATIC struct",
            "STATIC struct",
            "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
            "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
            "static __inline void ahcsetccbstatus",
            "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
            "STATIC struct",
            "STATIC struct",
            "STATIC struct",
            "struct scsi_xfer *xs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nSTATIC struct;\nahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));\nSTATIC struct;\nSTATIC struct;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nstatic __inline void ahcsetccbstatus;\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nSTATIC struct;\nSTATIC struct;\nSTATIC struct;\nstruct scsi_xfer *xs;\n\nstatic __inline void\nahcsetccbstatus(xs, status)\n\tstruct scsi_xfer *xs;\n\tint status;\n{\n\txs->error = status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_match_scb",
          "args": [
            "scbp",
            "target",
            "channel",
            "lun",
            "tag",
            "role"
          ],
          "line": 5219
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_match_scb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "5529-5549",
          "snippet": "STATIC int\nahc_match_scb(scb, target, channel, lun, role, tag)\n\tstruct scb *scb;\n\tint target;\n\tchar channel;\n\tint lun;\n\trole_t role;\n\tu_int tag;\n{\n\tint targ = SCB_TARGET(scb);\n\tchar chan = SCB_CHANNEL(scb);\n\tint slun = SCB_LUN(scb);\n\tint match;\n\n\tmatch = ((chan == channel) || (channel == ALL_CHANNELS));\n\tif (match != 0)\n\t\tmatch = ((targ == target) || (target == ALL_TARGETS));\n\tif (match != 0)\n\t\tmatch = ((lun == slun) || (lun == ALL_LUNS));\n\treturn match;\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC",
            "#define ALL_CHANNELS '\\0'"
          ],
          "globals_used": [
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "ahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_calc_residual __P((struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "char channel;",
            "STATIC struct",
            "STATIC struct",
            "STATIC struct",
            "char channel;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n#define ALL_CHANNELS '\\0'\n\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_calc_residual __P((struct scb *scb));\nSTATIC void;\nSTATIC void;\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nSTATIC void;\nSTATIC void;\nchar channel;\nSTATIC struct;\nSTATIC struct;\nSTATIC struct;\nchar channel;\n\nSTATIC int\nahc_match_scb(scb, target, channel, lun, role, tag)\n\tstruct scb *scb;\n\tint target;\n\tchar channel;\n\tint lun;\n\trole_t role;\n\tu_int tag;\n{\n\tint targ = SCB_TARGET(scb);\n\tchar chan = SCB_CHANNEL(scb);\n\tint slun = SCB_LUN(scb);\n\tint match;\n\n\tmatch = ((chan == channel) || (channel == ALL_CHANNELS));\n\tif (match != 0)\n\t\tmatch = ((targ == target) || (target == ALL_TARGETS));\n\tif (match != 0)\n\t\tmatch = ((lun == slun) || (lun == ALL_LUNS));\n\treturn match;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_add_curscb_to_free_list",
          "args": [
            "ahc"
          ],
          "line": 5203
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_add_curscb_to_free_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "5319-5328",
          "snippet": "STATIC void\nahc_add_curscb_to_free_list(ahc)\n\tstruct ahc_softc *ahc;\n{\n\t/* Invalidate the tag so that ahc_find_scb doesn't think it's active */\n\tahc_outb(ahc, SCB_TAG, SCB_LIST_NULL);\n\n\tahc_outb(ahc, SCB_NEXT, ahc_inb(ahc, FREE_SCBH));\n\tahc_outb(ahc, FREE_SCBH, ahc_inb(ahc, SCBPTR));\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_add_curscb_to_free_list(ahc)\n\tstruct ahc_softc *ahc;\n{\n\t/* Invalidate the tag so that ahc_find_scb doesn't think it's active */\n\tahc_outb(ahc, SCB_TAG, SCB_LIST_NULL);\n\n\tahc_outb(ahc, SCB_NEXT, ahc_inb(ahc, FREE_SCBH));\n\tahc_outb(ahc, FREE_SCBH, ahc_inb(ahc, SCBPTR));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCB_TAG"
          ],
          "line": 5199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCBPTR",
            "i"
          ],
          "line": 5198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_search_disc_list",
          "args": [
            "ahc",
            "target",
            "channel",
            "lun",
            "tag",
            "/*stop_on_first*/FALSE",
            "/*remove*/TRUE",
            "/*save_state*/FALSE"
          ],
          "line": 5187
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_search_disc_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "5233-5293",
          "snippet": "STATIC int\nahc_search_disc_list(ahc, target, channel, lun, tag, stop_on_first, \n\t\t     remove, save_state)\n\tstruct ahc_softc *ahc;\n\tint target;\n\tchar channel;\n\tint lun;\n\tu_int tag;\n\tint stop_on_first;\n\tint remove;\n\tint save_state;\n{\n\tstruct\tscb *scbp;\n\tu_int\tnext;\n\tu_int\tprev;\n\tu_int\tcount;\n\tu_int\tactive_scb;\n\n\tcount = 0;\n\tnext = ahc_inb(ahc, DISCONNECTED_SCBH);\n\tprev = SCB_LIST_NULL;\n\n\tif (save_state) {\n\t/* restore this when we're done */\n\tactive_scb = ahc_inb(ahc, SCBPTR);\n\t} else\n\t\t/* Silence compiler */\n\t\tactive_scb = SCB_LIST_NULL;\n\n\twhile (next != SCB_LIST_NULL) {\n\t\tu_int scb_index;\n\n\t\tahc_outb(ahc, SCBPTR, next);\n\t\tscb_index = ahc_inb(ahc, SCB_TAG);\n\t\tif (scb_index >= ahc->scb_data->numscbs) {\n\t\t\tpanic(\"Disconnected List inconsistency. \"\n\t\t\t      \"SCB index == %d, yet numscbs == %d.\",\n\t\t\t      scb_index, ahc->scb_data->numscbs);\n\t\t}\n\t\tscbp = &ahc->scb_data->scbarray[scb_index];\n\t\tif (ahc_match_scb(scbp, target, channel, lun,\n\t\t\t\t  tag, ROLE_INITIATOR)) {\n\t\t\tcount++;\n\t\t\tif (remove) {\n\t\t\t\tnext =\n\t\t\t\t    ahc_rem_scb_from_disc_list(ahc, prev, next);\n\t\t\t} else {\n\t\t\t\tprev = next;\n\t\t\t\tnext = ahc_inb(ahc, SCB_NEXT);\n\t\t\t}\n\t\t\tif (stop_on_first)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tprev = next;\n\t\t\tnext = ahc_inb(ahc, SCB_NEXT);\n\t\t}\n\t}\n\tif (save_state)\n\tahc_outb(ahc, SCBPTR, active_scb);\n\treturn (count);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC u_int",
            "ahc_abort_wscb __P((struct ahc_softc *ahc,\n\t\t\t\t    u_int scbpos, u_int prev));",
            "STATIC void",
            "ahc_done __P((struct ahc_softc *ahc, struct scb *scbp));",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "ahc_search_disc_list __P((struct ahc_softc *ahc, int target,\n\t\t\t\t\t  char channel, int lun, u_int tag,\n\t\t\t\t\t  int stop_on_first, int remove,\n\t\t\t\t\t  int save_state));",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));",
            "STATIC void",
            "ahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_calc_residual __P((struct scb *scb));",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC u_int;\nahc_abort_wscb __P((struct ahc_softc *ahc,\n\t\t\t\t    u_int scbpos, u_int prev));\nSTATIC void;\nahc_done __P((struct ahc_softc *ahc, struct scb *scbp));\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nahc_search_disc_list __P((struct ahc_softc *ahc, int target,\n\t\t\t\t\t  char channel, int lun, u_int tag,\n\t\t\t\t\t  int stop_on_first, int remove,\n\t\t\t\t\t  int save_state));\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));\nSTATIC void;\nahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_calc_residual __P((struct scb *scb));\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC int\nahc_search_disc_list(ahc, target, channel, lun, tag, stop_on_first, \n\t\t     remove, save_state)\n\tstruct ahc_softc *ahc;\n\tint target;\n\tchar channel;\n\tint lun;\n\tu_int tag;\n\tint stop_on_first;\n\tint remove;\n\tint save_state;\n{\n\tstruct\tscb *scbp;\n\tu_int\tnext;\n\tu_int\tprev;\n\tu_int\tcount;\n\tu_int\tactive_scb;\n\n\tcount = 0;\n\tnext = ahc_inb(ahc, DISCONNECTED_SCBH);\n\tprev = SCB_LIST_NULL;\n\n\tif (save_state) {\n\t/* restore this when we're done */\n\tactive_scb = ahc_inb(ahc, SCBPTR);\n\t} else\n\t\t/* Silence compiler */\n\t\tactive_scb = SCB_LIST_NULL;\n\n\twhile (next != SCB_LIST_NULL) {\n\t\tu_int scb_index;\n\n\t\tahc_outb(ahc, SCBPTR, next);\n\t\tscb_index = ahc_inb(ahc, SCB_TAG);\n\t\tif (scb_index >= ahc->scb_data->numscbs) {\n\t\t\tpanic(\"Disconnected List inconsistency. \"\n\t\t\t      \"SCB index == %d, yet numscbs == %d.\",\n\t\t\t      scb_index, ahc->scb_data->numscbs);\n\t\t}\n\t\tscbp = &ahc->scb_data->scbarray[scb_index];\n\t\tif (ahc_match_scb(scbp, target, channel, lun,\n\t\t\t\t  tag, ROLE_INITIATOR)) {\n\t\t\tcount++;\n\t\t\tif (remove) {\n\t\t\t\tnext =\n\t\t\t\t    ahc_rem_scb_from_disc_list(ahc, prev, next);\n\t\t\t} else {\n\t\t\t\tprev = next;\n\t\t\t\tnext = ahc_inb(ahc, SCB_NEXT);\n\t\t\t}\n\t\t\tif (stop_on_first)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tprev = next;\n\t\t\tnext = ahc_inb(ahc, SCB_NEXT);\n\t\t}\n\t}\n\tif (save_state)\n\tahc_outb(ahc, SCBPTR, active_scb);\n\treturn (count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCB_NEXT"
          ],
          "line": 5177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_abort_wscb",
          "args": [
            "ahc",
            "next",
            "prev"
          ],
          "line": 5173
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_abort_wscb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "5334-5379",
          "snippet": "STATIC u_int\nahc_abort_wscb(ahc, scbpos, prev)\n\tstruct ahc_softc *ahc;\n\tu_int scbpos;\n        u_int prev;\n{       \n\tu_int curscb, next;\n\n\t/*\n\t * Select the SCB we want to abort and\n\t * pull the next pointer out of it.\n\t */\n\tcurscb = ahc_inb(ahc, SCBPTR);\n\tahc_outb(ahc, SCBPTR, scbpos);\n\tnext = ahc_inb(ahc, SCB_NEXT);\n\n\t/* Clear the necessary fields */\n\tahc_outb(ahc, SCB_CONTROL, 0);\n\n\tahc_add_curscb_to_free_list(ahc);\n\n\t/* update the waiting list */\n\tif (prev == SCB_LIST_NULL) {\n\t\t/* First in the list */\n\t\tahc_outb(ahc, WAITING_SCBH, next); \n\n\t\t/*\n\t\t * Ensure we aren't attempting to perform\n\t\t * selection for this entry.\n\t\t */\n\t\tahc_outb(ahc, SCSISEQ, (ahc_inb(ahc, SCSISEQ) & ~ENSELO));\n\t} else {\n\t\t/*\n\t\t * Select the scb that pointed to us \n\t\t * and update its next pointer.\n\t\t */\n\t\tahc_outb(ahc, SCBPTR, prev);\n\t\tahc_outb(ahc, SCB_NEXT, next);\n\t}\n\n\t/*\n\t * Point us back at the original scb position.\n\t */\n\tahc_outb(ahc, SCBPTR, curscb);\n\treturn next;\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC u_int",
            "ahc_abort_wscb __P((struct ahc_softc *ahc,\n\t\t\t\t    u_int scbpos, u_int prev));",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_calc_residual __P((struct scb *scb));",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC u_int;\nahc_abort_wscb __P((struct ahc_softc *ahc,\n\t\t\t\t    u_int scbpos, u_int prev));\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_calc_residual __P((struct scb *scb));\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC u_int\nahc_abort_wscb(ahc, scbpos, prev)\n\tstruct ahc_softc *ahc;\n\tu_int scbpos;\n        u_int prev;\n{       \n\tu_int curscb, next;\n\n\t/*\n\t * Select the SCB we want to abort and\n\t * pull the next pointer out of it.\n\t */\n\tcurscb = ahc_inb(ahc, SCBPTR);\n\tahc_outb(ahc, SCBPTR, scbpos);\n\tnext = ahc_inb(ahc, SCB_NEXT);\n\n\t/* Clear the necessary fields */\n\tahc_outb(ahc, SCB_CONTROL, 0);\n\n\tahc_add_curscb_to_free_list(ahc);\n\n\t/* update the waiting list */\n\tif (prev == SCB_LIST_NULL) {\n\t\t/* First in the list */\n\t\tahc_outb(ahc, WAITING_SCBH, next); \n\n\t\t/*\n\t\t * Ensure we aren't attempting to perform\n\t\t * selection for this entry.\n\t\t */\n\t\tahc_outb(ahc, SCSISEQ, (ahc_inb(ahc, SCSISEQ) & ~ENSELO));\n\t} else {\n\t\t/*\n\t\t * Select the scb that pointed to us \n\t\t * and update its next pointer.\n\t\t */\n\t\tahc_outb(ahc, SCBPTR, prev);\n\t\tahc_outb(ahc, SCB_NEXT, next);\n\t}\n\n\t/*\n\t * Point us back at the original scb position.\n\t */\n\tahc_outb(ahc, SCBPTR, curscb);\n\treturn next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"Waiting List inconsistency. \"\n\t\t\t\t      \"SCB index == %d, yet numscbs == %d.\"",
            "scb_index",
            "ahc->scb_data->numscbs"
          ],
          "line": 5165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCB_TAG"
          ],
          "line": 5163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCBPTR",
            "next"
          ],
          "line": 5162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "WAITING_SCBH"
          ],
          "line": 5156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_search_qinfifo",
          "args": [
            "ahc",
            "target",
            "channel",
            "lun",
            "SCB_LIST_NULL",
            "role",
            "SCB_REQUEUE",
            "SEARCH_COMPLETE"
          ],
          "line": 5147
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_search_qinfifo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "5055-5121",
          "snippet": "STATIC int\nahc_search_qinfifo(ahc, target, channel, lun, tag, role, status, action)\n\tstruct ahc_softc *ahc;\n\tint target;\n\tchar channel;\n\tint lun;\n\tu_int tag;\n\trole_t role;\n\tu_int32_t status;\n\tahc_search_action action;\n{\n\tstruct\t scb *scbp;\n\tu_int8_t qinpos;\n\tu_int8_t qintail;\n\tint\t found;\n\n\tqinpos = ahc_inb(ahc, QINPOS);\n\tqintail = ahc->qinfifonext;\n\tfound = 0;\n\n\t/*\n\t * Start with an empty queue.  Entries that are not chosen\n\t * for removal will be re-added to the queue as we go.\n\t */\n\tahc->qinfifonext = qinpos;\n\tbus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, \n\t\t\tBUS_DMASYNC_POSTREAD);\n\n\twhile (qinpos != qintail) {\n\t\tscbp = &ahc->scb_data->scbarray[ahc->qinfifo[qinpos]];\n\t\tif (ahc_match_scb(scbp, target, channel, lun, tag, role)) {\n\t\t\t/*\n\t\t\t * We found an scb that needs to be removed.\n\t\t\t */\n\t\t\tswitch (action) {\n\t\t\tcase SEARCH_COMPLETE:\n\t\t\t\tif (!(scbp->xs->flags & ITSDONE)) {\n\t\t\t\t\tscbp->flags |= status;\n\t\t\t\t\tscbp->xs->error = XS_NOERROR;\n\t\t\t\t}\n\t\t\t\tahc_freeze_ccb(scbp);\n\t\t\t\tahc_done(ahc, scbp);\n\t\t\t\tbreak;\n\t\t\tcase SEARCH_COUNT:\n\t\t\t\tahc->qinfifo[ahc->qinfifonext++] =\n\t\t\t\t    scbp->hscb->tag;\n\t\t\t\tbreak;\n\t\t\tcase SEARCH_REMOVE:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfound++;\n\t\t} else {\n\t\t\tahc->qinfifo[ahc->qinfifonext++] = scbp->hscb->tag;\n\t\t}\n\t\tqinpos++;\n\t}\n\tbus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, \n\t\t\tBUS_DMASYNC_PREWRITE);\n\t\n\tif ((ahc->features & AHC_QUEUE_REGS) != 0) {\n\t\tahc_outb(ahc, HNSCB_QOFF, ahc->qinfifonext);\n\t} else {\n\t\tahc_outb(ahc, KERNEL_QINPOS, ahc->qinfifonext);\n\t}\n\n\treturn (found);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "ahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));",
            "STATIC u_int",
            "STATIC void",
            "ahc_done __P((struct ahc_softc *ahc, struct scb *scbp));",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "ahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));",
            "STATIC int",
            "ahc_search_qinfifo __P((struct ahc_softc *ahc, int target,\n\t\t\t\t\tchar channel, int lun, u_int tag,\n\t\t\t\t\trole_t role, u_int32_t status,\n\t\t\t\t\tahc_search_action action));",
            "STATIC int",
            "STATIC int",
            "ahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
            "STATIC void",
            "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_calc_residual __P((struct scb *scb));",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "static __inline void ahc_freeze_ccb",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *xs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));\nSTATIC u_int;\nSTATIC void;\nahc_done __P((struct ahc_softc *ahc, struct scb *scbp));\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));\nSTATIC int;\nahc_search_qinfifo __P((struct ahc_softc *ahc, int target,\n\t\t\t\t\tchar channel, int lun, u_int tag,\n\t\t\t\t\trole_t role, u_int32_t status,\n\t\t\t\t\tahc_search_action action));\nSTATIC int;\nSTATIC int;\nahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nSTATIC void;\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_calc_residual __P((struct scb *scb));\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nstatic __inline void ahc_freeze_ccb;\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n\nSTATIC int\nahc_search_qinfifo(ahc, target, channel, lun, tag, role, status, action)\n\tstruct ahc_softc *ahc;\n\tint target;\n\tchar channel;\n\tint lun;\n\tu_int tag;\n\trole_t role;\n\tu_int32_t status;\n\tahc_search_action action;\n{\n\tstruct\t scb *scbp;\n\tu_int8_t qinpos;\n\tu_int8_t qintail;\n\tint\t found;\n\n\tqinpos = ahc_inb(ahc, QINPOS);\n\tqintail = ahc->qinfifonext;\n\tfound = 0;\n\n\t/*\n\t * Start with an empty queue.  Entries that are not chosen\n\t * for removal will be re-added to the queue as we go.\n\t */\n\tahc->qinfifonext = qinpos;\n\tbus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, \n\t\t\tBUS_DMASYNC_POSTREAD);\n\n\twhile (qinpos != qintail) {\n\t\tscbp = &ahc->scb_data->scbarray[ahc->qinfifo[qinpos]];\n\t\tif (ahc_match_scb(scbp, target, channel, lun, tag, role)) {\n\t\t\t/*\n\t\t\t * We found an scb that needs to be removed.\n\t\t\t */\n\t\t\tswitch (action) {\n\t\t\tcase SEARCH_COMPLETE:\n\t\t\t\tif (!(scbp->xs->flags & ITSDONE)) {\n\t\t\t\t\tscbp->flags |= status;\n\t\t\t\t\tscbp->xs->error = XS_NOERROR;\n\t\t\t\t}\n\t\t\t\tahc_freeze_ccb(scbp);\n\t\t\t\tahc_done(ahc, scbp);\n\t\t\t\tbreak;\n\t\t\tcase SEARCH_COUNT:\n\t\t\t\tahc->qinfifo[ahc->qinfifonext++] =\n\t\t\t\t    scbp->hscb->tag;\n\t\t\t\tbreak;\n\t\t\tcase SEARCH_REMOVE:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfound++;\n\t\t} else {\n\t\t\tahc->qinfifo[ahc->qinfifonext++] = scbp->hscb->tag;\n\t\t}\n\t\tqinpos++;\n\t}\n\tbus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, \n\t\t\tBUS_DMASYNC_PREWRITE);\n\t\n\tif ((ahc->features & AHC_QUEUE_REGS) != 0) {\n\t\tahc_outb(ahc, HNSCB_QOFF, ahc->qinfifonext);\n\t} else {\n\t\tahc_outb(ahc, KERNEL_QINPOS, ahc->qinfifonext);\n\t}\n\n\treturn (found);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCBPTR"
          ],
          "line": 5145
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));\nSTATIC u_int;\nahc_abort_wscb __P((struct ahc_softc *ahc,\n\t\t\t\t    u_int scbpos, u_int prev));\nSTATIC void;\nahc_done __P((struct ahc_softc *ahc, struct scb *scbp));\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));\nSTATIC int;\nahc_search_disc_list __P((struct ahc_softc *ahc, int target,\n\t\t\t\t\t  char channel, int lun, u_int tag,\n\t\t\t\t\t  int stop_on_first, int remove,\n\t\t\t\t\t  int save_state));\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));\nSTATIC void;\nahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));\nSTATIC void;\nSTATIC int;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nSTATIC void;\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_calc_residual __P((struct scb *scb));\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nstatic __inline void ahc_freeze_ccb;\nstatic __inline void ahcsetccbstatus;\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n\nSTATIC int\nahc_abort_scbs(ahc, target, channel, lun, tag, role, status)\n\tstruct ahc_softc *ahc;\n\tint target;\n\tchar channel;\n\tint lun;\n\tu_int tag;\n\trole_t role;\n\tu_int32_t status;\n{\n\tstruct\tscb *scbp;\n\tu_int\tactive_scb;\n\tint\ti;\n\tint\tfound;\n\n\t/* restore this when we're done */\n\tactive_scb = ahc_inb(ahc, SCBPTR);\n\n\tfound = ahc_search_qinfifo(ahc, target, channel, lun, SCB_LIST_NULL,\n\t\t\t\t   role, SCB_REQUEUE, SEARCH_COMPLETE);\n\n\t/*\n\t * Search waiting for selection list.\n\t */\n\t{\n\t\tu_int8_t next, prev;\n                /* Start at head of list. */\n\t\tnext = ahc_inb(ahc, WAITING_SCBH);\n\t\tprev = SCB_LIST_NULL;\n\n\t\twhile (next != SCB_LIST_NULL) {\n\t\t\tu_int8_t scb_index;\n\n\t\t\tahc_outb(ahc, SCBPTR, next);\n\t\t\tscb_index = ahc_inb(ahc, SCB_TAG);\n\t\t\tif (scb_index >= ahc->scb_data->numscbs) {\n\t\t\t\tpanic(\"Waiting List inconsistency. \"\n\t\t\t\t      \"SCB index == %d, yet numscbs == %d.\",\n\t\t\t\t      scb_index, ahc->scb_data->numscbs);\n\t\t\t}\n\t\t\tscbp = &ahc->scb_data->scbarray[scb_index];\n\t\t\tif (ahc_match_scb(scbp, target, channel,\n\t\t\t\t\t  lun, SCB_LIST_NULL, role)) {\n\n\t\t\t\tnext = ahc_abort_wscb(ahc, next, prev);\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tprev = next;\n\t\t\t\tnext = ahc_inb(ahc, SCB_NEXT);\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\t * Go through the disconnected list and remove any entries we\n\t * have queued for completion, 0'ing their control byte too.\n\t * We save the active SCB and restore it ourselves, so there\n\t * is no reason for this search to restore it too.\n\t */\n\tahc_search_disc_list(ahc, target, channel, lun, tag,\n\t\t\t     /*stop_on_first*/FALSE, /*remove*/TRUE,\n\t\t\t     /*save_state*/FALSE);\n\n\t/*\n\t * Go through the hardware SCB array looking for commands that\n\t * were active but not on any list.\n\t */\n\tfor(i = 0; i < ahc->scb_data->maxhscbs; i++) {\n\t\tu_int scbid;\n\n\t\tahc_outb(ahc, SCBPTR, i);\n\t\tscbid = ahc_inb(ahc, SCB_TAG);\n\t\tscbp = &ahc->scb_data->scbarray[scbid];\n\t\tif (scbid < ahc->scb_data->numscbs && \n\t\t\t ahc_match_scb(scbp, target, channel, lun, tag, role))\n\t\t\t\tahc_add_curscb_to_free_list(ahc);\n\t}\n\n\t/*\n\t * Go through the pending CCB list and look for\n\t * commands for this target that are still active.\n\t * These are other tagged commands that were\n\t * disconnected when the reset occured.\n\t */\n\t{\n\t\tstruct scb *scb;\n\n\t\tscb = ahc->pending_scbs.lh_first;\n\t\twhile (scb != NULL) {\n\t\t\tscbp = scb;\n\t\t\tscb = scb->pend_links.le_next;\n\t\t\tif (ahc_match_scb(scbp, target, channel,\n\t\t\t\t\t  lun, tag, role)) {\n\t\t\t\tif (!(scbp->xs->flags & ITSDONE))\n\t\t\t\t\tahcsetccbstatus(scbp->xs, status);\n\t\t\t\tahc_freeze_ccb(scbp);\n\t\t\t\tahc_done(ahc, scbp);\n\t\t\t\tfound++;\n\t\t\t}\n\t\t}\n\t}\n\tahc_outb(ahc, SCBPTR, active_scb);\n\treturn found;\n}"
  },
  {
    "function_name": "ahc_search_qinfifo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "5055-5121",
    "snippet": "STATIC int\nahc_search_qinfifo(ahc, target, channel, lun, tag, role, status, action)\n\tstruct ahc_softc *ahc;\n\tint target;\n\tchar channel;\n\tint lun;\n\tu_int tag;\n\trole_t role;\n\tu_int32_t status;\n\tahc_search_action action;\n{\n\tstruct\t scb *scbp;\n\tu_int8_t qinpos;\n\tu_int8_t qintail;\n\tint\t found;\n\n\tqinpos = ahc_inb(ahc, QINPOS);\n\tqintail = ahc->qinfifonext;\n\tfound = 0;\n\n\t/*\n\t * Start with an empty queue.  Entries that are not chosen\n\t * for removal will be re-added to the queue as we go.\n\t */\n\tahc->qinfifonext = qinpos;\n\tbus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, \n\t\t\tBUS_DMASYNC_POSTREAD);\n\n\twhile (qinpos != qintail) {\n\t\tscbp = &ahc->scb_data->scbarray[ahc->qinfifo[qinpos]];\n\t\tif (ahc_match_scb(scbp, target, channel, lun, tag, role)) {\n\t\t\t/*\n\t\t\t * We found an scb that needs to be removed.\n\t\t\t */\n\t\t\tswitch (action) {\n\t\t\tcase SEARCH_COMPLETE:\n\t\t\t\tif (!(scbp->xs->flags & ITSDONE)) {\n\t\t\t\t\tscbp->flags |= status;\n\t\t\t\t\tscbp->xs->error = XS_NOERROR;\n\t\t\t\t}\n\t\t\t\tahc_freeze_ccb(scbp);\n\t\t\t\tahc_done(ahc, scbp);\n\t\t\t\tbreak;\n\t\t\tcase SEARCH_COUNT:\n\t\t\t\tahc->qinfifo[ahc->qinfifonext++] =\n\t\t\t\t    scbp->hscb->tag;\n\t\t\t\tbreak;\n\t\t\tcase SEARCH_REMOVE:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfound++;\n\t\t} else {\n\t\t\tahc->qinfifo[ahc->qinfifonext++] = scbp->hscb->tag;\n\t\t}\n\t\tqinpos++;\n\t}\n\tbus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, \n\t\t\tBUS_DMASYNC_PREWRITE);\n\t\n\tif ((ahc->features & AHC_QUEUE_REGS) != 0) {\n\t\tahc_outb(ahc, HNSCB_QOFF, ahc->qinfifonext);\n\t} else {\n\t\tahc_outb(ahc, KERNEL_QINPOS, ahc->qinfifonext);\n\t}\n\n\treturn (found);\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define STATIC\tstatic",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
      "STATIC void",
      "STATIC void",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "ahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));",
      "STATIC u_int",
      "STATIC void",
      "ahc_done __P((struct ahc_softc *ahc, struct scb *scbp));",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "ahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));",
      "STATIC int",
      "ahc_search_qinfifo __P((struct ahc_softc *ahc, int target,\n\t\t\t\t\tchar channel, int lun, u_int tag,\n\t\t\t\t\trole_t role, u_int32_t status,\n\t\t\t\t\tahc_search_action action));",
      "STATIC int",
      "STATIC int",
      "ahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));",
      "STATIC int",
      "STATIC u_int",
      "STATIC void",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "STATIC u_int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
      "STATIC void",
      "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_calc_residual __P((struct scb *scb));",
      "STATIC void",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
      "STATIC void",
      "STATIC void",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "static __inline void ahc_freeze_ccb",
      "STATIC void",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
      "STATIC void",
      "STATIC void",
      "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "char channel;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "char channel;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *xs;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "KERNEL_QINPOS",
            "ahc->qinfifonext"
          ],
          "line": 5117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "HNSCB_QOFF",
            "ahc->qinfifonext"
          ],
          "line": 5115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_sync",
          "args": [
            "ahc->sc_dmat",
            "ahc->shared_data_dmamap",
            "BUS_DMASYNC_PREWRITE"
          ],
          "line": 5111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_done",
          "args": [
            "ahc",
            "scbp"
          ],
          "line": 5096
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "3401-3537",
          "snippet": "STATIC void\nahc_done(ahc, scb)\n\tstruct ahc_softc *ahc;\n\tstruct scb *scb;\n{\n\tstruct scsi_xfer *xs = scb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tint requeue = 0;\n\tint target;\n\n\tSC_DEBUG(xs->sc_link, SDEV_DB2, (\"ahc_done\\n\"));\n\t\n\tLIST_REMOVE(scb, pend_links);\n\n\tuntimeout(ahc_timeout, (caddr_t)scb);\n\n#ifdef AHC_DEBUG\n\tif (ahc_debug & AHC_SHOWCMDS) {\n\t\tsc_print_addr(sc_link);\n\t\tprintf(\"ahc_done opcode %d tag %x\\n\", xs->cmdstore.opcode,\n\t\t    scb->hscb->tag);\n\t}\n#endif\n\t\n\ttarget = sc_link->target;\n\t\n\tif (xs->datalen) {\n\t\tbus_dmasync_op_t op;\n\t\n\t\tif ((xs->flags & SCSI_DATA_IN) != 0)\n\t\t\top = BUS_DMASYNC_POSTREAD;\n\t\telse\n\t\t\top = BUS_DMASYNC_POSTWRITE;\n\t\tbus_dmamap_sync(ahc->sc_dmat, scb->dmamap, op);\n\t\tbus_dmamap_unload(ahc->sc_dmat, scb->dmamap);\n\t}\n\n\t/*\n\t * Unbusy this target/channel/lun.\n\t * XXX if we are holding two commands per lun, \n\t *     send the next command.\n\t */\n\tahc_index_busy_tcl(ahc, scb->hscb->tcl, /*unbusy*/TRUE);\n\n\t/*\n\t * If the recovery SCB completes, we have to be\n\t * out of our timeout.\n\t */\n\tif ((scb->flags & SCB_RECOVERY_SCB) != 0) {\n\n\t\tstruct\tscb *scbp;\n\n\t\t/*\n\t\t * We were able to complete the command successfully,\n\t\t * so reinstate the timeouts for all other pending\n\t\t * commands.\n\t\t */\n\t\tscbp = ahc->pending_scbs.lh_first;\n\t\twhile (scbp != NULL) {\n\t\t\tstruct scsi_xfer *txs = scbp->xs;\n\n\t\t\tif (!(txs->flags & SCSI_POLL)) {\n\t\t\t\ttimeout(ahc_timeout, scbp,\n\t\t\t\t    (scbp->xs->timeout * hz)/1000);\n\t\t\t}\n\t\t\tscbp = LIST_NEXT(scbp, pend_links);\n\t\t}\n\n\t\t/*\n\t\t * Ensure that we didn't put a second instance of this\n\t\t * SCB into the QINFIFO.\n\t\t */\n\t\tahc_search_qinfifo(ahc, SCB_TARGET(scb), SCB_CHANNEL(scb),\n\t\t\t\t   SCB_LUN(scb), scb->hscb->tag,\n\t\t\t\t   ROLE_INITIATOR, /*status*/0,\n\t\t\t\t   SEARCH_REMOVE);\n\t\tif (xs->error != XS_NOERROR)\n\t\t\tahcsetccbstatus(xs, XS_TIMEOUT);\n\t\tsc_print_addr(xs->sc_link);\n\t\tprintf(\"no longer in timeout, status = %x\\n\", xs->status);\n\t}\n\n\tif (xs->error != XS_NOERROR) {\n\t\t/* Don't clobber any existing error state */\n\t} else if ((scb->flags & SCB_SENSE) != 0) {\n\t\t/*\n\t\t * We performed autosense retrieval.\n\t\t *\n\t\t * bzero the sense data before having\n\t\t * the drive fill it.  The SCSI spec mandates\n\t\t * that any untransfered data should be\n\t\t * assumed to be zero.  Complete the 'bounce'\n\t\t * of sense information through buffers accessible\n\t\t * via bus-space by copying it into the clients\n\t\t * csio.\n\t\t */\n\t\tbzero(&xs->sense, sizeof(struct scsi_sense));\n\t\tbcopy(&ahc->scb_data->sense[scb->hscb->tag],\n\t\t      &xs->sense, scb->sg_list->len);\n\t\txs->error = XS_SENSE;\n\t}\n\tif (scb->flags & SCB_FREEZE_QUEUE) {\n\t\tahc->devqueue_blocked[target]--;\n\t\tscb->flags &= ~SCB_FREEZE_QUEUE;\n\t}\n\t\n\trequeue = scb->flags & SCB_REQUEUE;\n\tahcfreescb(ahc, scb);\n\n\tif (requeue) {\n\t\t/*\n\t\t * Re-insert at the front of the private queue to\n\t\t * preserve order.\n\t\t */\n\t\tint s;\n\n\t\ts = splbio();\n\t\t/* TAILQ_INSERT_HEAD(&ahc->sc_q, xs, adapter_q); */\n\t\tahc_list_insert_head(ahc, xs);\n\t\tsplx(s);\n\t} else {\n\t\txs->flags |= ITSDONE;\n\t\tahc_check_tags(ahc, xs);\n\t\tscsi_done(xs);\n\t}\n\n\t/*\n\t * If there are entries in the software queue, try to\n\t * run the first one.  We should be more or less guaranteed\n\t * to succeed, since we just freed an SCB.\n\t *\n\t * NOTE: ahc_scsi_cmd() relies on our calling it with\n\t * the first entry in the queue.\n\t */\n\tif ((xs = ahc->sc_xxxq.lh_first) != NULL)\n\t\t(void) ahc_scsi_cmd(xs);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
            "STATIC void",
            "ahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_done __P((struct ahc_softc *ahc, struct scb *scbp));",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "ahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));",
            "STATIC int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
            "STATIC void",
            "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_calc_residual __P((struct scb *scb));",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "static __inline u_int ahc_index_busy_tcl",
            "static __inline void ahcsetccbstatus",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "void   ahc_list_insert_head",
            "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *xs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nSTATIC void;\nahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_done __P((struct ahc_softc *ahc, struct scb *scbp));\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));\nSTATIC int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nSTATIC void;\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_calc_residual __P((struct scb *scb));\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nstatic __inline u_int ahc_index_busy_tcl;\nstatic __inline void ahcsetccbstatus;\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nSTATIC void;\nSTATIC void;\nvoid   ahc_list_insert_head;\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n\nSTATIC void\nahc_done(ahc, scb)\n\tstruct ahc_softc *ahc;\n\tstruct scb *scb;\n{\n\tstruct scsi_xfer *xs = scb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tint requeue = 0;\n\tint target;\n\n\tSC_DEBUG(xs->sc_link, SDEV_DB2, (\"ahc_done\\n\"));\n\t\n\tLIST_REMOVE(scb, pend_links);\n\n\tuntimeout(ahc_timeout, (caddr_t)scb);\n\n#ifdef AHC_DEBUG\n\tif (ahc_debug & AHC_SHOWCMDS) {\n\t\tsc_print_addr(sc_link);\n\t\tprintf(\"ahc_done opcode %d tag %x\\n\", xs->cmdstore.opcode,\n\t\t    scb->hscb->tag);\n\t}\n#endif\n\t\n\ttarget = sc_link->target;\n\t\n\tif (xs->datalen) {\n\t\tbus_dmasync_op_t op;\n\t\n\t\tif ((xs->flags & SCSI_DATA_IN) != 0)\n\t\t\top = BUS_DMASYNC_POSTREAD;\n\t\telse\n\t\t\top = BUS_DMASYNC_POSTWRITE;\n\t\tbus_dmamap_sync(ahc->sc_dmat, scb->dmamap, op);\n\t\tbus_dmamap_unload(ahc->sc_dmat, scb->dmamap);\n\t}\n\n\t/*\n\t * Unbusy this target/channel/lun.\n\t * XXX if we are holding two commands per lun, \n\t *     send the next command.\n\t */\n\tahc_index_busy_tcl(ahc, scb->hscb->tcl, /*unbusy*/TRUE);\n\n\t/*\n\t * If the recovery SCB completes, we have to be\n\t * out of our timeout.\n\t */\n\tif ((scb->flags & SCB_RECOVERY_SCB) != 0) {\n\n\t\tstruct\tscb *scbp;\n\n\t\t/*\n\t\t * We were able to complete the command successfully,\n\t\t * so reinstate the timeouts for all other pending\n\t\t * commands.\n\t\t */\n\t\tscbp = ahc->pending_scbs.lh_first;\n\t\twhile (scbp != NULL) {\n\t\t\tstruct scsi_xfer *txs = scbp->xs;\n\n\t\t\tif (!(txs->flags & SCSI_POLL)) {\n\t\t\t\ttimeout(ahc_timeout, scbp,\n\t\t\t\t    (scbp->xs->timeout * hz)/1000);\n\t\t\t}\n\t\t\tscbp = LIST_NEXT(scbp, pend_links);\n\t\t}\n\n\t\t/*\n\t\t * Ensure that we didn't put a second instance of this\n\t\t * SCB into the QINFIFO.\n\t\t */\n\t\tahc_search_qinfifo(ahc, SCB_TARGET(scb), SCB_CHANNEL(scb),\n\t\t\t\t   SCB_LUN(scb), scb->hscb->tag,\n\t\t\t\t   ROLE_INITIATOR, /*status*/0,\n\t\t\t\t   SEARCH_REMOVE);\n\t\tif (xs->error != XS_NOERROR)\n\t\t\tahcsetccbstatus(xs, XS_TIMEOUT);\n\t\tsc_print_addr(xs->sc_link);\n\t\tprintf(\"no longer in timeout, status = %x\\n\", xs->status);\n\t}\n\n\tif (xs->error != XS_NOERROR) {\n\t\t/* Don't clobber any existing error state */\n\t} else if ((scb->flags & SCB_SENSE) != 0) {\n\t\t/*\n\t\t * We performed autosense retrieval.\n\t\t *\n\t\t * bzero the sense data before having\n\t\t * the drive fill it.  The SCSI spec mandates\n\t\t * that any untransfered data should be\n\t\t * assumed to be zero.  Complete the 'bounce'\n\t\t * of sense information through buffers accessible\n\t\t * via bus-space by copying it into the clients\n\t\t * csio.\n\t\t */\n\t\tbzero(&xs->sense, sizeof(struct scsi_sense));\n\t\tbcopy(&ahc->scb_data->sense[scb->hscb->tag],\n\t\t      &xs->sense, scb->sg_list->len);\n\t\txs->error = XS_SENSE;\n\t}\n\tif (scb->flags & SCB_FREEZE_QUEUE) {\n\t\tahc->devqueue_blocked[target]--;\n\t\tscb->flags &= ~SCB_FREEZE_QUEUE;\n\t}\n\t\n\trequeue = scb->flags & SCB_REQUEUE;\n\tahcfreescb(ahc, scb);\n\n\tif (requeue) {\n\t\t/*\n\t\t * Re-insert at the front of the private queue to\n\t\t * preserve order.\n\t\t */\n\t\tint s;\n\n\t\ts = splbio();\n\t\t/* TAILQ_INSERT_HEAD(&ahc->sc_q, xs, adapter_q); */\n\t\tahc_list_insert_head(ahc, xs);\n\t\tsplx(s);\n\t} else {\n\t\txs->flags |= ITSDONE;\n\t\tahc_check_tags(ahc, xs);\n\t\tscsi_done(xs);\n\t}\n\n\t/*\n\t * If there are entries in the software queue, try to\n\t * run the first one.  We should be more or less guaranteed\n\t * to succeed, since we just freed an SCB.\n\t *\n\t * NOTE: ahc_scsi_cmd() relies on our calling it with\n\t * the first entry in the queue.\n\t */\n\tif ((xs = ahc->sc_xxxq.lh_first) != NULL)\n\t\t(void) ahc_scsi_cmd(xs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_freeze_ccb",
          "args": [
            "scbp"
          ],
          "line": 5095
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_freeze_ccb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "533-546",
          "snippet": "static __inline void\nahc_freeze_ccb(scb)\n\tstruct scb *scb;\n{\n\tstruct scsi_xfer *xs = scb->xs;\n\tstruct ahc_softc *ahc = (struct ahc_softc *)xs->sc_link->adapter_softc;\n\tint target;\n\n\ttarget = xs->sc_link->target;\n\tif (!(scb->flags & SCB_FREEZE_QUEUE)) {\n\t\tahc->devqueue_blocked[target]++;\n\t\tscb->flags |= SCB_FREEZE_QUEUE;\n\t}\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
            "ahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "ahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
            "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
            "ahc_calc_residual __P((struct scb *scb));",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "static __inline void ahc_freeze_ccb",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
            "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *xs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC struct;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));\nahc_loadseq __P((struct ahc_softc *ahc));\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nahc_clear_intstat __P((struct ahc_softc *ahc));\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nahc_calc_residual __P((struct scb *scb));\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nrestart_sequencer __P((struct ahc_softc *ahc));\nstatic __inline void ahc_freeze_ccb;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n\nstatic __inline void\nahc_freeze_ccb(scb)\n\tstruct scb *scb;\n{\n\tstruct scsi_xfer *xs = scb->xs;\n\tstruct ahc_softc *ahc = (struct ahc_softc *)xs->sc_link->adapter_softc;\n\tint target;\n\n\ttarget = xs->sc_link->target;\n\tif (!(scb->flags & SCB_FREEZE_QUEUE)) {\n\t\tahc->devqueue_blocked[target]++;\n\t\tscb->flags |= SCB_FREEZE_QUEUE;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_match_scb",
          "args": [
            "scbp",
            "target",
            "channel",
            "lun",
            "tag",
            "role"
          ],
          "line": 5085
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_match_scb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "5529-5549",
          "snippet": "STATIC int\nahc_match_scb(scb, target, channel, lun, role, tag)\n\tstruct scb *scb;\n\tint target;\n\tchar channel;\n\tint lun;\n\trole_t role;\n\tu_int tag;\n{\n\tint targ = SCB_TARGET(scb);\n\tchar chan = SCB_CHANNEL(scb);\n\tint slun = SCB_LUN(scb);\n\tint match;\n\n\tmatch = ((chan == channel) || (channel == ALL_CHANNELS));\n\tif (match != 0)\n\t\tmatch = ((targ == target) || (target == ALL_TARGETS));\n\tif (match != 0)\n\t\tmatch = ((lun == slun) || (lun == ALL_LUNS));\n\treturn match;\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC",
            "#define ALL_CHANNELS '\\0'"
          ],
          "globals_used": [
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "ahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_calc_residual __P((struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "char channel;",
            "STATIC struct",
            "STATIC struct",
            "STATIC struct",
            "char channel;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n#define ALL_CHANNELS '\\0'\n\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_calc_residual __P((struct scb *scb));\nSTATIC void;\nSTATIC void;\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nSTATIC void;\nSTATIC void;\nchar channel;\nSTATIC struct;\nSTATIC struct;\nSTATIC struct;\nchar channel;\n\nSTATIC int\nahc_match_scb(scb, target, channel, lun, role, tag)\n\tstruct scb *scb;\n\tint target;\n\tchar channel;\n\tint lun;\n\trole_t role;\n\tu_int tag;\n{\n\tint targ = SCB_TARGET(scb);\n\tchar chan = SCB_CHANNEL(scb);\n\tint slun = SCB_LUN(scb);\n\tint match;\n\n\tmatch = ((chan == channel) || (channel == ALL_CHANNELS));\n\tif (match != 0)\n\t\tmatch = ((targ == target) || (target == ALL_TARGETS));\n\tif (match != 0)\n\t\tmatch = ((lun == slun) || (lun == ALL_LUNS));\n\treturn match;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_dmamap_sync",
          "args": [
            "ahc->sc_dmat",
            "ahc->shared_data_dmamap",
            "BUS_DMASYNC_POSTREAD"
          ],
          "line": 5080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "QINPOS"
          ],
          "line": 5071
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));\nSTATIC u_int;\nSTATIC void;\nahc_done __P((struct ahc_softc *ahc, struct scb *scbp));\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));\nSTATIC int;\nahc_search_qinfifo __P((struct ahc_softc *ahc, int target,\n\t\t\t\t\tchar channel, int lun, u_int tag,\n\t\t\t\t\trole_t role, u_int32_t status,\n\t\t\t\t\tahc_search_action action));\nSTATIC int;\nSTATIC int;\nahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nSTATIC void;\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_calc_residual __P((struct scb *scb));\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nstatic __inline void ahc_freeze_ccb;\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n\nSTATIC int\nahc_search_qinfifo(ahc, target, channel, lun, tag, role, status, action)\n\tstruct ahc_softc *ahc;\n\tint target;\n\tchar channel;\n\tint lun;\n\tu_int tag;\n\trole_t role;\n\tu_int32_t status;\n\tahc_search_action action;\n{\n\tstruct\t scb *scbp;\n\tu_int8_t qinpos;\n\tu_int8_t qintail;\n\tint\t found;\n\n\tqinpos = ahc_inb(ahc, QINPOS);\n\tqintail = ahc->qinfifonext;\n\tfound = 0;\n\n\t/*\n\t * Start with an empty queue.  Entries that are not chosen\n\t * for removal will be re-added to the queue as we go.\n\t */\n\tahc->qinfifonext = qinpos;\n\tbus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, \n\t\t\tBUS_DMASYNC_POSTREAD);\n\n\twhile (qinpos != qintail) {\n\t\tscbp = &ahc->scb_data->scbarray[ahc->qinfifo[qinpos]];\n\t\tif (ahc_match_scb(scbp, target, channel, lun, tag, role)) {\n\t\t\t/*\n\t\t\t * We found an scb that needs to be removed.\n\t\t\t */\n\t\t\tswitch (action) {\n\t\t\tcase SEARCH_COMPLETE:\n\t\t\t\tif (!(scbp->xs->flags & ITSDONE)) {\n\t\t\t\t\tscbp->flags |= status;\n\t\t\t\t\tscbp->xs->error = XS_NOERROR;\n\t\t\t\t}\n\t\t\t\tahc_freeze_ccb(scbp);\n\t\t\t\tahc_done(ahc, scbp);\n\t\t\t\tbreak;\n\t\t\tcase SEARCH_COUNT:\n\t\t\t\tahc->qinfifo[ahc->qinfifonext++] =\n\t\t\t\t    scbp->hscb->tag;\n\t\t\t\tbreak;\n\t\t\tcase SEARCH_REMOVE:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfound++;\n\t\t} else {\n\t\t\tahc->qinfifo[ahc->qinfifonext++] = scbp->hscb->tag;\n\t\t}\n\t\tqinpos++;\n\t}\n\tbus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, \n\t\t\tBUS_DMASYNC_PREWRITE);\n\t\n\tif ((ahc->features & AHC_QUEUE_REGS) != 0) {\n\t\tahc_outb(ahc, HNSCB_QOFF, ahc->qinfifonext);\n\t} else {\n\t\tahc_outb(ahc, KERNEL_QINPOS, ahc->qinfifonext);\n\t}\n\n\treturn (found);\n}"
  },
  {
    "function_name": "ahc_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "4777-5053",
    "snippet": "STATIC void\nahc_timeout(void *arg)\n{\n\tstruct\tscb *scb;\n\tstruct\tahc_softc *ahc;\n\tint\ts, found;\n\tu_int\tlast_phase;\n\tint\ttarget;\n\tint\tlun;\n\tint\ti;\n\tchar\tchannel;\n\n\tscb = (struct scb *)arg; \n\tahc = (struct ahc_softc *)scb->xs->sc_link->adapter_softc;\n\n\ts = splbio();\n\n\t/*\n\t * Ensure that the card doesn't do anything\n\t * behind our back.  Also make sure that we\n\t * didn't \"just\" miss an interrupt that would\n\t * affect this timeout.\n\t */\n\tdo {\n\t\tahc_intr(ahc);\n\t\tpause_sequencer(ahc);\n\t} while (ahc_inb(ahc, INTSTAT) & INT_PEND);\n\n\tif ((scb->flags & SCB_ACTIVE) == 0) {\n\t\t/* Previous timeout took care of me already */\n\t\tprintf(\"Timedout SCB handled by another timeout\\n\");\n\t\tunpause_sequencer(ahc);\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\ttarget = SCB_TARGET(scb);\n\tchannel = SCB_CHANNEL(scb);\n\tlun = SCB_LUN(scb);\n\n\tsc_print_addr(scb->xs->sc_link);\n\tprintf(\"SCB 0x%x - timed out \", scb->hscb->tag);\n\t/*\n\t * Take a snapshot of the bus state and print out\n\t * some information so we can track down driver bugs.\n\t */\n\tlast_phase = ahc_inb(ahc, LASTPHASE);\n\n\tfor (i = 0; i < num_phases; i++) {\n\t\tif (last_phase == phase_table[i].phase)\n\t\t\tbreak;\n\t}\n\tprintf(\"%s\", phase_table[i].phasemsg);\n  \n\tprintf(\", SEQADDR == 0x%x\\n\",\n\t       ahc_inb(ahc, SEQADDR0) | (ahc_inb(ahc, SEQADDR1) << 8));\n#if 0\n\tprintf(\"SSTAT1 == 0x%x\\n\", ahc_inb(ahc, SSTAT1));\n\tprintf(\"SSTAT3 == 0x%x\\n\", ahc_inb(ahc, SSTAT3));\n\tprintf(\"SCSIPHASE == 0x%x\\n\", ahc_inb(ahc, SCSIPHASE));\n\tprintf(\"SCSIRATE == 0x%x\\n\", ahc_inb(ahc, SCSIRATE));\n\tprintf(\"SCSIOFFSET == 0x%x\\n\", ahc_inb(ahc, SCSIOFFSET));\n\tprintf(\"SEQ_FLAGS == 0x%x\\n\", ahc_inb(ahc, SEQ_FLAGS));\n\tprintf(\"SCB_DATAPTR == 0x%x\\n\", ahc_inb(ahc, SCB_DATAPTR)\n\t\t\t\t      | ahc_inb(ahc, SCB_DATAPTR + 1) << 8\n\t\t\t\t      | ahc_inb(ahc, SCB_DATAPTR + 2) << 16\n\t\t\t\t      | ahc_inb(ahc, SCB_DATAPTR + 3) << 24);\n\tprintf(\"SCB_DATACNT == 0x%x\\n\", ahc_inb(ahc, SCB_DATACNT)\n\t\t\t\t      | ahc_inb(ahc, SCB_DATACNT + 1) << 8\n\t\t\t\t      | ahc_inb(ahc, SCB_DATACNT + 2) << 16);\n\tprintf(\"SCB_SGCOUNT == 0x%x\\n\", ahc_inb(ahc, SCB_SGCOUNT));\n\tprintf(\"CCSCBCTL == 0x%x\\n\", ahc_inb(ahc, CCSCBCTL));\n\tprintf(\"CCSCBCNT == 0x%x\\n\", ahc_inb(ahc, CCSCBCNT));\n\tprintf(\"DFCNTRL == 0x%x\\n\", ahc_inb(ahc, DFCNTRL));\n\tprintf(\"DFSTATUS == 0x%x\\n\", ahc_inb(ahc, DFSTATUS));\n\tprintf(\"CCHCNT == 0x%x\\n\", ahc_inb(ahc, CCHCNT));\n\tif (scb->sg_count > 0) {\n\t\tfor (i = 0; i < scb->sg_count; i++) {\n\t\t\tprintf(\"sg[%d] - Addr 0x%x : Length %d\\n\",\n\t\t\t       i,\n\t\t\t       scb->sg_list[i].addr,\n\t\t\t       scb->sg_list[i].len);\n\t\t}\n\t}\n#endif\n\tif (scb->flags & (SCB_DEVICE_RESET|SCB_ABORT)) {\n\t\t/*\n\t\t * Been down this road before.\n\t\t * Do a full bus reset.\n\t\t */\nbus_reset:\n\t\tahcsetccbstatus(scb->xs, XS_TIMEOUT);\n\t\tfound = ahc_reset_channel(ahc, channel, /*Initiate Reset*/TRUE);\n\t\tprintf(\"%s: Issued Channel %c Bus Reset. \"\n\t\t       \"%d SCBs aborted\\n\", ahc_name(ahc), channel, found);\n\t} else {\n\t\t/*\n\t\t * If we are a target, transition to bus free and report\n\t\t * the timeout.\n\t\t * \n\t\t * The target/initiator that is holding up the bus may not\n\t\t * be the same as the one that triggered this timeout\n\t\t * (different commands have different timeout lengths).\n\t\t * If the bus is idle and we are actiing as the initiator\n\t\t * for this request, queue a BDR message to the timed out\n\t\t * target.  Otherwise, if the timed out transaction is\n\t\t * active:\n\t\t *   Initiator transaction:\n\t\t *\tStuff the message buffer with a BDR message and assert\n\t\t *\tATN in the hopes that the target will let go of the bus\n\t\t *\tand go to the mesgout phase.  If this fails, we'll\n\t\t *\tget another timeout 2 seconds later which will attempt\n\t\t *\ta bus reset.\n\t\t *\n\t\t *   Target transaction:\n\t\t *\tTransition to BUS FREE and report the error.\n\t\t *\tIt's good to be the target!\n\t\t */\n\t\tu_int active_scb_index;\n\n\t\tactive_scb_index = ahc_inb(ahc, SCB_TAG);\n\n\t\tif (last_phase != P_BUSFREE \n\t\t  && (active_scb_index < ahc->scb_data->numscbs)) {\n\t\t\tstruct scb *active_scb;\n\n\t\t\t/*\n\t\t\t * If the active SCB is not from our device,\n\t\t\t * assume that another device is hogging the bus\n\t\t\t * and wait for it's timeout to expire before\n\t\t\t * taking additional action.\n\t\t\t */ \n\t\t\tactive_scb = &ahc->scb_data->scbarray[active_scb_index];\n\t\t\tif (active_scb->hscb->tcl != scb->hscb->tcl) {\n\t\t\t\tu_int\tnewtimeout;\n\n\t\t\t\tsc_print_addr(scb->xs->sc_link);\n\t\t\t\tprintf(\"Other SCB Timeout%s\",\n\t\t\t \t       (scb->flags & SCB_OTHERTCL_TIMEOUT) != 0\n\t\t\t\t       ? \" again\\n\" : \"\\n\");\n\t\t\t\tscb->flags |= SCB_OTHERTCL_TIMEOUT;\n\t\t\t\tnewtimeout = MAX(active_scb->xs->timeout,\n\t\t\t\t\t\t scb->xs->timeout);\n\t\t\t\ttimeout(ahc_timeout, scb,\n\t\t\t\t\t    (newtimeout * hz) / 1000);\n\t\t\t\tsplx(s);\n\t\t\t\treturn;\n\t\t\t} \n\n\t\t\t/* It's us */\n\t\t\tif ((scb->hscb->control & TARGET_SCB) != 0) {\n\n\t\t\t\t/*\n\t\t\t\t * Send back any queued up transactions\n\t\t\t\t * and properly record the error condition.\n\t\t\t\t */\n\t\t\t\tahc_freeze_devq(ahc, scb->xs->sc_link);\n\t\t\t\tahcsetccbstatus(scb->xs, XS_TIMEOUT);\n\t\t\t\tahc_freeze_ccb(scb);\n\t\t\t\tahc_done(ahc, scb);\n\n\t\t\t\t/* Will clear us from the bus */\n\t\t\t\trestart_sequencer(ahc);\n\t\t\t\treturn;\n\t\t\t} \n\n\t\t\tahc_set_recoveryscb(ahc, active_scb);\n\t\t\tahc_outb(ahc, MSG_OUT, MSG_BUS_DEV_RESET);\n\t\t\tahc_outb(ahc, SCSISIGO, last_phase|ATNO);\n\t\t\tsc_print_addr(active_scb->xs->sc_link);\n\t\t\tprintf(\"BDR message in message buffer\\n\");\n\t\t\tactive_scb->flags |=  SCB_DEVICE_RESET;\n\t\t\t    timeout(ahc_timeout, (caddr_t)active_scb, 2 * hz);\n\t\t\tunpause_sequencer(ahc);\n\t\t} else {\n\t\t\tint\t disconnected;\n\n\t\t\t/* XXX Shouldn't panic.  Just punt instead */\n\t\t\tif ((scb->hscb->control & TARGET_SCB) != 0)\n\t\t\t\tpanic(\"Timed-out target SCB but bus idle\");\n\n\t\t\tif (last_phase != P_BUSFREE\n\t\t\t && (ahc_inb(ahc, SSTAT0) & TARGET) != 0) {\n\t\t\t\t/* XXX What happened to the SCB? */\n\t\t\t\t/* Hung target selection.  Goto busfree */\n\t\t\t\tprintf(\"%s: Hung target selection\\n\",\n\t\t\t\t       ahc_name(ahc));\n\t\t\t\trestart_sequencer(ahc);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (ahc_search_qinfifo(ahc, target, channel, lun,\n\t\t\t\t\t       scb->hscb->tag, ROLE_INITIATOR,\n\t\t\t\t\t       /*status*/0, SEARCH_COUNT) > 0) {\n\t\t\t\tdisconnected = FALSE;\n\t\t\t} else {\n\t\t\t\tdisconnected = TRUE;\n\t\t\t}\n\n\t\t\tif (disconnected) {\n\t\t\t\tu_int active_scb;\n\n\t\t\t\tahc_set_recoveryscb(ahc, scb);\n\t\t\t\t/*\n\t\t\t\t * Simply set the MK_MESSAGE control bit.\n\t\t\t\t */\n\t\t\t\tscb->hscb->control |= MK_MESSAGE;\n\t\t\t\tscb->flags |= SCB_QUEUED_MSG\n\t\t\t\t\t   |  SCB_DEVICE_RESET;\n\n\t\t\t\t/*\n\t\t\t\t * Mark the cached copy of this SCB in the\n\t\t\t\t * disconnected list too, so that a reconnect\n\t\t\t\t * at this point causes a BDR or abort.\n\t\t\t\t */\n\t\t\t\tactive_scb = ahc_inb(ahc, SCBPTR);\n\t\t\t\tif (ahc_search_disc_list(ahc, target,\n\t\t\t\t\t\t\t channel, lun,\n\t\t\t\t\t\t\t scb->hscb->tag,\n\t\t\t\t\t\t\t /*stop_on_first*/TRUE,\n\t\t\t\t\t\t\t /*remove*/FALSE,\n\t\t\t\t\t\t\t /*save_state*/FALSE)) {\n\t\t\t\t\tu_int scb_control;\n\n\t\t\t\t\tscb_control = ahc_inb(ahc, SCB_CONTROL);\n\t\t\t\t\tscb_control |= MK_MESSAGE;\n\t\t\t\t\tahc_outb(ahc, SCB_CONTROL, scb_control);\n\t\t\t\t}\n\t\t\t\tahc_outb(ahc, SCBPTR, active_scb);\n\t\t\t\tahc_index_busy_tcl(ahc, scb->hscb->tcl,\n\t\t\t\t\t\t   /*unbusy*/TRUE);\n\n\t\t\t\t/*\n\t\t\t\t * Actually re-queue this SCB in case we can\n\t\t\t\t * select the device before it reconnects.\n\t\t\t\t * Clear out any entries in the QINFIFO first\n\t\t\t\t * so we are the next SCB for this target\n\t\t\t\t * to run.\n\t\t\t\t */\n\t\t\t\tahc_search_qinfifo(ahc, SCB_TARGET(scb),\n\t\t\t\t\t\t   channel, SCB_LUN(scb),\n\t\t\t\t\t\t   SCB_LIST_NULL,\n\t\t\t\t\t\t   ROLE_INITIATOR,\n\t\t\t\t\t\t   SCB_REQUEUE,\n\t\t\t\t\t\t   SEARCH_COMPLETE);\n\t\t\t\tsc_print_addr(scb->xs->sc_link);\n\t\t\t\tprintf(\"Queuing a BDR SCB\\n\");\n\t\t\t\tahc->qinfifo[ahc->qinfifonext++] =\n\t\t\t\t    scb->hscb->tag;\n\n\t\t\t\tbus_dmamap_sync(ahc->sc_dmat,\n\t\t\t\t    ahc->shared_data_dmamap,\n\t\t\t\t    BUS_DMASYNC_PREWRITE);\n\n\t\t\t\tif ((ahc->features & AHC_QUEUE_REGS) != 0) {\n\t\t\t\t\tahc_outb(ahc, HNSCB_QOFF,\n\t\t\t\t\t\t ahc->qinfifonext);\n\t\t\t\t} else {\n\t\t\t\t\tahc_outb(ahc, KERNEL_QINPOS,\n\t\t\t\t\t\t ahc->qinfifonext);\n\t\t\t\t}\n\t\t\t\ttimeout(ahc_timeout, (caddr_t)scb, 2 * hz);\n\t\t\t\tunpause_sequencer(ahc);\n\t\t\t} else {\n\t\t\t\t/* Go \"immediatly\" to the bus reset */\n\t\t\t\t/* This shouldn't happen */\n\t\t\t\tahc_set_recoveryscb(ahc, scb);\n\t\t\t\tsc_print_addr(scb->xs->sc_link);\n\t\t\t\tprintf(\"SCB %d: Immediate reset.  \"\n\t\t\t\t\t\"Flags = 0x%x\\n\", scb->hscb->tag,\n\t\t\t\t\tscb->flags);\n\t\t\t\tgoto bus_reset;\n\t\t\t}\n\t\t}\n\t}\n\tsplx(s);\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define STATIC\tstatic",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "STATIC int",
      "ahc_poll __P((struct ahc_softc *ahc, int wait));",
      "STATIC void",
      "ahc_shutdown __P((void *arg));",
      "STATIC int",
      "STATIC int",
      "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
      "STATIC void",
      "ahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));",
      "STATIC void",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC u_int",
      "STATIC void",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));",
      "STATIC int",
      "ahc_sent_msg __P((struct ahc_softc *ahc, u_int msgtype,\n\t\t\t\t  int full));",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "ahc_search_qinfifo __P((struct ahc_softc *ahc, int target,\n\t\t\t\t\tchar channel, int lun, u_int tag,\n\t\t\t\t\trole_t role, u_int32_t status,\n\t\t\t\t\tahc_search_action action));",
      "STATIC int",
      "STATIC int",
      "ahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));",
      "STATIC int",
      "ahc_search_disc_list __P((struct ahc_softc *ahc, int target,\n\t\t\t\t\t  char channel, int lun, u_int tag,\n\t\t\t\t\t  int stop_on_first, int remove,\n\t\t\t\t\t  int save_state));",
      "STATIC u_int",
      "STATIC void",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "STATIC u_int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
      "STATIC void",
      "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_calc_residual __P((struct scb *scb));",
      "STATIC void",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
      "STATIC void",
      "static __inline void pause_sequencer",
      "static __inline void unpause_sequencer",
      "STATIC void",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "static __inline u_int ahc_index_busy_tcl",
      "static __inline void ahc_freeze_ccb",
      "static __inline void ahcsetccbstatus",
      "STATIC void",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
      "STATIC void",
      "STATIC void",
      "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "char channel;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "static struct {\n        u_int8_t phase;\n        u_int8_t mesg_out; /* Message response to parity errors */\n\tchar *phasemsg;\n} phase_table[] = {\n\t{ P_DATAOUT,\tMSG_NOOP,\t\t\"in Data-out phase\"\t},\n\t{ P_DATAIN,\tMSG_INITIATOR_DET_ERR,\t\"in Data-in phase\"\t},\n\t{ P_COMMAND,\tMSG_NOOP,\t\t\"in Command phase\"\t},\n\t{ P_MESGOUT,\tMSG_NOOP,\t\t\"in Message-out phase\"\t},\n\t{ P_STATUS,\tMSG_INITIATOR_DET_ERR,\t\"in Status phase\"\t},\n\t{ P_MESGIN,\tMSG_PARITY_ERROR,\t\"in Message-in phase\"\t},\n\t{ P_BUSFREE,\tMSG_NOOP,\t\t\"while idle\"\t\t},\n\t{ 0,\t\tMSG_NOOP,\t\t\"in unknown phase\"\t}\n};",
      "static const int num_phases = (sizeof(phase_table)/sizeof(phase_table[0])) - 1;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "char channel;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *xs;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 5052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"SCB %d: Immediate reset.  \"\n\t\t\t\t\t\"Flags = 0x%x\\n\"",
            "scb->hscb->tag",
            "scb->flags"
          ],
          "line": 5045
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sc_print_addr",
          "args": [
            "scb->xs->sc_link"
          ],
          "line": 5044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_set_recoveryscb",
          "args": [
            "ahc",
            "scb"
          ],
          "line": 5043
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_set_recoveryscb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "4746-4775",
          "snippet": "STATIC void\nahc_set_recoveryscb(ahc, scb)\n\tstruct ahc_softc *ahc;\n\tstruct scb *scb;\n{\n\n\tif ((scb->flags & SCB_RECOVERY_SCB) == 0) {\n\t\tstruct scb *scbp;\n\n\t\tscb->flags |= SCB_RECOVERY_SCB;\n\n\t\t/*\n\t\t * Take all queued, but not sent SCBs out of the equation.\n\t\t * Also ensure that no new CCBs are queued to us while we\n\t\t * try to fix this problem.\n\t\t */\n\t\tahc->queue_blocked = 1;\n\n\t\t/*\n\t\t * Go through all of our pending SCBs and remove\n\t\t * any scheduled timeouts for them.  We will reschedule\n\t\t * them after we've successfully fixed this problem.\n\t\t */\n\t\tscbp = ahc->pending_scbs.lh_first;\n\t\twhile (scbp != NULL) {\n\t\t\tuntimeout(ahc_timeout, scbp);\n\t\t\tscbp = scbp->pend_links.le_next;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_done __P((struct ahc_softc *ahc, struct scb *scbp));",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_calc_residual __P((struct scb *scb));",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_done __P((struct ahc_softc *ahc, struct scb *scbp));\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_calc_residual __P((struct scb *scb));\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_set_recoveryscb(ahc, scb)\n\tstruct ahc_softc *ahc;\n\tstruct scb *scb;\n{\n\n\tif ((scb->flags & SCB_RECOVERY_SCB) == 0) {\n\t\tstruct scb *scbp;\n\n\t\tscb->flags |= SCB_RECOVERY_SCB;\n\n\t\t/*\n\t\t * Take all queued, but not sent SCBs out of the equation.\n\t\t * Also ensure that no new CCBs are queued to us while we\n\t\t * try to fix this problem.\n\t\t */\n\t\tahc->queue_blocked = 1;\n\n\t\t/*\n\t\t * Go through all of our pending SCBs and remove\n\t\t * any scheduled timeouts for them.  We will reschedule\n\t\t * them after we've successfully fixed this problem.\n\t\t */\n\t\tscbp = ahc->pending_scbs.lh_first;\n\t\twhile (scbp != NULL) {\n\t\t\tuntimeout(ahc_timeout, scbp);\n\t\t\tscbp = scbp->pend_links.le_next;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unpause_sequencer",
          "args": [
            "ahc"
          ],
          "line": 5039
        },
        "resolved": true,
        "details": {
          "function_name": "unpause_sequencer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "456-462",
          "snippet": "static __inline void\nunpause_sequencer(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tif ((ahc_inb(ahc, INTSTAT) & (SCSIINT | SEQINT | BRKADRINT)) == 0)\n\t\tahc_outb(ahc, HCNTRL, ahc->unpause);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "static __inline void unpause_sequencer",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC struct;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nahc_loadseq __P((struct ahc_softc *ahc));\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nahc_clear_intstat __P((struct ahc_softc *ahc));\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nstatic __inline void unpause_sequencer;\nrestart_sequencer __P((struct ahc_softc *ahc));\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nstatic __inline void\nunpause_sequencer(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tif ((ahc_inb(ahc, INTSTAT) & (SCSIINT | SEQINT | BRKADRINT)) == 0)\n\t\tahc_outb(ahc, HCNTRL, ahc->unpause);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "ahc_timeout",
            "(caddr_t)scb",
            "2 * hz"
          ],
          "line": 5038
        },
        "resolved": true,
        "details": {
          "function_name": "wdctimeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "952-980",
          "snippet": "void\nwdctimeout(arg)\n\tvoid *arg;\n{\n\tstruct channel_softc *chp = (struct channel_softc *)arg;\n\tstruct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;\n\tint s;\n\n\tWDCDEBUG_PRINT((\"wdctimeout\\n\"), DEBUG_FUNCS);\n\n\ts = splbio();\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) != 0) {\n\t\t__wdcerror(chp, \"timeout\");\n\t\tprintf(\"\\ttype: %s\\n\", (xfer->c_flags & C_ATAPI) ?\n\t\t    \"atapi\":\"ata\");\n\t\tprintf(\"\\tc_bcount: %d\\n\", xfer->c_bcount);\n\t\tprintf(\"\\tc_skip: %d\\n\", xfer->c_skip);\n\t\t/*\n\t\t * Call the interrupt routine. If we just missed and interrupt,\n\t\t * it will do what's needed. Else, it will take the needed\n\t\t * action (reset the device).\n\t\t */\n\t\txfer->c_flags |= C_TIMEOU;\n\t\tchp->ch_flags &= ~WDCF_IRQ_WAIT;\n\t\txfer->c_intr(chp, xfer, 1);\n\t} else\n\t\t__wdcerror(chp, \"missing untimeout\");\n\tsplx(s);\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_FUNCS  0x08"
          ],
          "globals_used": [
            "static void  __wdcerror"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_FUNCS  0x08\n\nstatic void  __wdcerror;\n\nvoid\nwdctimeout(arg)\n\tvoid *arg;\n{\n\tstruct channel_softc *chp = (struct channel_softc *)arg;\n\tstruct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;\n\tint s;\n\n\tWDCDEBUG_PRINT((\"wdctimeout\\n\"), DEBUG_FUNCS);\n\n\ts = splbio();\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) != 0) {\n\t\t__wdcerror(chp, \"timeout\");\n\t\tprintf(\"\\ttype: %s\\n\", (xfer->c_flags & C_ATAPI) ?\n\t\t    \"atapi\":\"ata\");\n\t\tprintf(\"\\tc_bcount: %d\\n\", xfer->c_bcount);\n\t\tprintf(\"\\tc_skip: %d\\n\", xfer->c_skip);\n\t\t/*\n\t\t * Call the interrupt routine. If we just missed and interrupt,\n\t\t * it will do what's needed. Else, it will take the needed\n\t\t * action (reset the device).\n\t\t */\n\t\txfer->c_flags |= C_TIMEOU;\n\t\tchp->ch_flags &= ~WDCF_IRQ_WAIT;\n\t\txfer->c_intr(chp, xfer, 1);\n\t} else\n\t\t__wdcerror(chp, \"missing untimeout\");\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "KERNEL_QINPOS",
            "ahc->qinfifonext"
          ],
          "line": 5035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "HNSCB_QOFF",
            "ahc->qinfifonext"
          ],
          "line": 5032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_sync",
          "args": [
            "ahc->sc_dmat",
            "ahc->shared_data_dmamap",
            "BUS_DMASYNC_PREWRITE"
          ],
          "line": 5027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc_print_addr",
          "args": [
            "scb->xs->sc_link"
          ],
          "line": 5022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_search_qinfifo",
          "args": [
            "ahc",
            "SCB_TARGET(scb)",
            "channel",
            "SCB_LUN(scb)",
            "SCB_LIST_NULL",
            "ROLE_INITIATOR",
            "SCB_REQUEUE",
            "SEARCH_COMPLETE"
          ],
          "line": 5016
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_search_qinfifo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "5055-5121",
          "snippet": "STATIC int\nahc_search_qinfifo(ahc, target, channel, lun, tag, role, status, action)\n\tstruct ahc_softc *ahc;\n\tint target;\n\tchar channel;\n\tint lun;\n\tu_int tag;\n\trole_t role;\n\tu_int32_t status;\n\tahc_search_action action;\n{\n\tstruct\t scb *scbp;\n\tu_int8_t qinpos;\n\tu_int8_t qintail;\n\tint\t found;\n\n\tqinpos = ahc_inb(ahc, QINPOS);\n\tqintail = ahc->qinfifonext;\n\tfound = 0;\n\n\t/*\n\t * Start with an empty queue.  Entries that are not chosen\n\t * for removal will be re-added to the queue as we go.\n\t */\n\tahc->qinfifonext = qinpos;\n\tbus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, \n\t\t\tBUS_DMASYNC_POSTREAD);\n\n\twhile (qinpos != qintail) {\n\t\tscbp = &ahc->scb_data->scbarray[ahc->qinfifo[qinpos]];\n\t\tif (ahc_match_scb(scbp, target, channel, lun, tag, role)) {\n\t\t\t/*\n\t\t\t * We found an scb that needs to be removed.\n\t\t\t */\n\t\t\tswitch (action) {\n\t\t\tcase SEARCH_COMPLETE:\n\t\t\t\tif (!(scbp->xs->flags & ITSDONE)) {\n\t\t\t\t\tscbp->flags |= status;\n\t\t\t\t\tscbp->xs->error = XS_NOERROR;\n\t\t\t\t}\n\t\t\t\tahc_freeze_ccb(scbp);\n\t\t\t\tahc_done(ahc, scbp);\n\t\t\t\tbreak;\n\t\t\tcase SEARCH_COUNT:\n\t\t\t\tahc->qinfifo[ahc->qinfifonext++] =\n\t\t\t\t    scbp->hscb->tag;\n\t\t\t\tbreak;\n\t\t\tcase SEARCH_REMOVE:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfound++;\n\t\t} else {\n\t\t\tahc->qinfifo[ahc->qinfifonext++] = scbp->hscb->tag;\n\t\t}\n\t\tqinpos++;\n\t}\n\tbus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, \n\t\t\tBUS_DMASYNC_PREWRITE);\n\t\n\tif ((ahc->features & AHC_QUEUE_REGS) != 0) {\n\t\tahc_outb(ahc, HNSCB_QOFF, ahc->qinfifonext);\n\t} else {\n\t\tahc_outb(ahc, KERNEL_QINPOS, ahc->qinfifonext);\n\t}\n\n\treturn (found);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "ahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));",
            "STATIC u_int",
            "STATIC void",
            "ahc_done __P((struct ahc_softc *ahc, struct scb *scbp));",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "ahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));",
            "STATIC int",
            "ahc_search_qinfifo __P((struct ahc_softc *ahc, int target,\n\t\t\t\t\tchar channel, int lun, u_int tag,\n\t\t\t\t\trole_t role, u_int32_t status,\n\t\t\t\t\tahc_search_action action));",
            "STATIC int",
            "STATIC int",
            "ahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
            "STATIC void",
            "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_calc_residual __P((struct scb *scb));",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "static __inline void ahc_freeze_ccb",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *xs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));\nSTATIC u_int;\nSTATIC void;\nahc_done __P((struct ahc_softc *ahc, struct scb *scbp));\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));\nSTATIC int;\nahc_search_qinfifo __P((struct ahc_softc *ahc, int target,\n\t\t\t\t\tchar channel, int lun, u_int tag,\n\t\t\t\t\trole_t role, u_int32_t status,\n\t\t\t\t\tahc_search_action action));\nSTATIC int;\nSTATIC int;\nahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nSTATIC void;\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_calc_residual __P((struct scb *scb));\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nstatic __inline void ahc_freeze_ccb;\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n\nSTATIC int\nahc_search_qinfifo(ahc, target, channel, lun, tag, role, status, action)\n\tstruct ahc_softc *ahc;\n\tint target;\n\tchar channel;\n\tint lun;\n\tu_int tag;\n\trole_t role;\n\tu_int32_t status;\n\tahc_search_action action;\n{\n\tstruct\t scb *scbp;\n\tu_int8_t qinpos;\n\tu_int8_t qintail;\n\tint\t found;\n\n\tqinpos = ahc_inb(ahc, QINPOS);\n\tqintail = ahc->qinfifonext;\n\tfound = 0;\n\n\t/*\n\t * Start with an empty queue.  Entries that are not chosen\n\t * for removal will be re-added to the queue as we go.\n\t */\n\tahc->qinfifonext = qinpos;\n\tbus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, \n\t\t\tBUS_DMASYNC_POSTREAD);\n\n\twhile (qinpos != qintail) {\n\t\tscbp = &ahc->scb_data->scbarray[ahc->qinfifo[qinpos]];\n\t\tif (ahc_match_scb(scbp, target, channel, lun, tag, role)) {\n\t\t\t/*\n\t\t\t * We found an scb that needs to be removed.\n\t\t\t */\n\t\t\tswitch (action) {\n\t\t\tcase SEARCH_COMPLETE:\n\t\t\t\tif (!(scbp->xs->flags & ITSDONE)) {\n\t\t\t\t\tscbp->flags |= status;\n\t\t\t\t\tscbp->xs->error = XS_NOERROR;\n\t\t\t\t}\n\t\t\t\tahc_freeze_ccb(scbp);\n\t\t\t\tahc_done(ahc, scbp);\n\t\t\t\tbreak;\n\t\t\tcase SEARCH_COUNT:\n\t\t\t\tahc->qinfifo[ahc->qinfifonext++] =\n\t\t\t\t    scbp->hscb->tag;\n\t\t\t\tbreak;\n\t\t\tcase SEARCH_REMOVE:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfound++;\n\t\t} else {\n\t\t\tahc->qinfifo[ahc->qinfifonext++] = scbp->hscb->tag;\n\t\t}\n\t\tqinpos++;\n\t}\n\tbus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, \n\t\t\tBUS_DMASYNC_PREWRITE);\n\t\n\tif ((ahc->features & AHC_QUEUE_REGS) != 0) {\n\t\tahc_outb(ahc, HNSCB_QOFF, ahc->qinfifonext);\n\t} else {\n\t\tahc_outb(ahc, KERNEL_QINPOS, ahc->qinfifonext);\n\t}\n\n\treturn (found);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SCB_LUN",
          "args": [
            "scb"
          ],
          "line": 5017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCB_TARGET",
          "args": [
            "scb"
          ],
          "line": 5016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_index_busy_tcl",
          "args": [
            "ahc",
            "scb->hscb->tcl",
            "/*unbusy*/TRUE"
          ],
          "line": 5006
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_index_busy_tcl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "497-513",
          "snippet": "static __inline u_int\nahc_index_busy_tcl(ahc, tcl, unbusy)\n\tstruct ahc_softc *ahc;\n\tu_int tcl;\n\tint unbusy;\n{\n\tu_int scbid;\n\n\tscbid = ahc->untagged_scbs[tcl];\n\tif (unbusy) {\n\t\tahc->untagged_scbs[tcl] = SCB_LIST_NULL;\n\t\tbus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, \n\t\t\t\tBUS_DMASYNC_PREWRITE);\n\t}\n\n\treturn (scbid);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC u_int",
            "STATIC struct",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC u_int",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "static __inline u_int ahc_index_busy_tcl",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC u_int;\nSTATIC struct;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC u_int;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nahc_clear_intstat __P((struct ahc_softc *ahc));\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nrestart_sequencer __P((struct ahc_softc *ahc));\nstatic __inline u_int ahc_index_busy_tcl;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nstatic __inline u_int\nahc_index_busy_tcl(ahc, tcl, unbusy)\n\tstruct ahc_softc *ahc;\n\tu_int tcl;\n\tint unbusy;\n{\n\tu_int scbid;\n\n\tscbid = ahc->untagged_scbs[tcl];\n\tif (unbusy) {\n\t\tahc->untagged_scbs[tcl] = SCB_LIST_NULL;\n\t\tbus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, \n\t\t\t\tBUS_DMASYNC_PREWRITE);\n\t}\n\n\treturn (scbid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCBPTR",
            "active_scb"
          ],
          "line": 5005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCB_CONTROL",
            "scb_control"
          ],
          "line": 5003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCB_CONTROL"
          ],
          "line": 5001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_search_disc_list",
          "args": [
            "ahc",
            "target",
            "channel",
            "lun",
            "scb->hscb->tag",
            "/*stop_on_first*/TRUE",
            "/*remove*/FALSE",
            "/*save_state*/FALSE"
          ],
          "line": 4993
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_search_disc_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "5233-5293",
          "snippet": "STATIC int\nahc_search_disc_list(ahc, target, channel, lun, tag, stop_on_first, \n\t\t     remove, save_state)\n\tstruct ahc_softc *ahc;\n\tint target;\n\tchar channel;\n\tint lun;\n\tu_int tag;\n\tint stop_on_first;\n\tint remove;\n\tint save_state;\n{\n\tstruct\tscb *scbp;\n\tu_int\tnext;\n\tu_int\tprev;\n\tu_int\tcount;\n\tu_int\tactive_scb;\n\n\tcount = 0;\n\tnext = ahc_inb(ahc, DISCONNECTED_SCBH);\n\tprev = SCB_LIST_NULL;\n\n\tif (save_state) {\n\t/* restore this when we're done */\n\tactive_scb = ahc_inb(ahc, SCBPTR);\n\t} else\n\t\t/* Silence compiler */\n\t\tactive_scb = SCB_LIST_NULL;\n\n\twhile (next != SCB_LIST_NULL) {\n\t\tu_int scb_index;\n\n\t\tahc_outb(ahc, SCBPTR, next);\n\t\tscb_index = ahc_inb(ahc, SCB_TAG);\n\t\tif (scb_index >= ahc->scb_data->numscbs) {\n\t\t\tpanic(\"Disconnected List inconsistency. \"\n\t\t\t      \"SCB index == %d, yet numscbs == %d.\",\n\t\t\t      scb_index, ahc->scb_data->numscbs);\n\t\t}\n\t\tscbp = &ahc->scb_data->scbarray[scb_index];\n\t\tif (ahc_match_scb(scbp, target, channel, lun,\n\t\t\t\t  tag, ROLE_INITIATOR)) {\n\t\t\tcount++;\n\t\t\tif (remove) {\n\t\t\t\tnext =\n\t\t\t\t    ahc_rem_scb_from_disc_list(ahc, prev, next);\n\t\t\t} else {\n\t\t\t\tprev = next;\n\t\t\t\tnext = ahc_inb(ahc, SCB_NEXT);\n\t\t\t}\n\t\t\tif (stop_on_first)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tprev = next;\n\t\t\tnext = ahc_inb(ahc, SCB_NEXT);\n\t\t}\n\t}\n\tif (save_state)\n\tahc_outb(ahc, SCBPTR, active_scb);\n\treturn (count);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC u_int",
            "ahc_abort_wscb __P((struct ahc_softc *ahc,\n\t\t\t\t    u_int scbpos, u_int prev));",
            "STATIC void",
            "ahc_done __P((struct ahc_softc *ahc, struct scb *scbp));",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "ahc_search_disc_list __P((struct ahc_softc *ahc, int target,\n\t\t\t\t\t  char channel, int lun, u_int tag,\n\t\t\t\t\t  int stop_on_first, int remove,\n\t\t\t\t\t  int save_state));",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));",
            "STATIC void",
            "ahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_calc_residual __P((struct scb *scb));",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC u_int;\nahc_abort_wscb __P((struct ahc_softc *ahc,\n\t\t\t\t    u_int scbpos, u_int prev));\nSTATIC void;\nahc_done __P((struct ahc_softc *ahc, struct scb *scbp));\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nahc_search_disc_list __P((struct ahc_softc *ahc, int target,\n\t\t\t\t\t  char channel, int lun, u_int tag,\n\t\t\t\t\t  int stop_on_first, int remove,\n\t\t\t\t\t  int save_state));\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));\nSTATIC void;\nahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_calc_residual __P((struct scb *scb));\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC int\nahc_search_disc_list(ahc, target, channel, lun, tag, stop_on_first, \n\t\t     remove, save_state)\n\tstruct ahc_softc *ahc;\n\tint target;\n\tchar channel;\n\tint lun;\n\tu_int tag;\n\tint stop_on_first;\n\tint remove;\n\tint save_state;\n{\n\tstruct\tscb *scbp;\n\tu_int\tnext;\n\tu_int\tprev;\n\tu_int\tcount;\n\tu_int\tactive_scb;\n\n\tcount = 0;\n\tnext = ahc_inb(ahc, DISCONNECTED_SCBH);\n\tprev = SCB_LIST_NULL;\n\n\tif (save_state) {\n\t/* restore this when we're done */\n\tactive_scb = ahc_inb(ahc, SCBPTR);\n\t} else\n\t\t/* Silence compiler */\n\t\tactive_scb = SCB_LIST_NULL;\n\n\twhile (next != SCB_LIST_NULL) {\n\t\tu_int scb_index;\n\n\t\tahc_outb(ahc, SCBPTR, next);\n\t\tscb_index = ahc_inb(ahc, SCB_TAG);\n\t\tif (scb_index >= ahc->scb_data->numscbs) {\n\t\t\tpanic(\"Disconnected List inconsistency. \"\n\t\t\t      \"SCB index == %d, yet numscbs == %d.\",\n\t\t\t      scb_index, ahc->scb_data->numscbs);\n\t\t}\n\t\tscbp = &ahc->scb_data->scbarray[scb_index];\n\t\tif (ahc_match_scb(scbp, target, channel, lun,\n\t\t\t\t  tag, ROLE_INITIATOR)) {\n\t\t\tcount++;\n\t\t\tif (remove) {\n\t\t\t\tnext =\n\t\t\t\t    ahc_rem_scb_from_disc_list(ahc, prev, next);\n\t\t\t} else {\n\t\t\t\tprev = next;\n\t\t\t\tnext = ahc_inb(ahc, SCB_NEXT);\n\t\t\t}\n\t\t\tif (stop_on_first)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tprev = next;\n\t\t\tnext = ahc_inb(ahc, SCB_NEXT);\n\t\t}\n\t}\n\tif (save_state)\n\tahc_outb(ahc, SCBPTR, active_scb);\n\treturn (count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCBPTR"
          ],
          "line": 4992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "restart_sequencer",
          "args": [
            "ahc"
          ],
          "line": 4964
        },
        "resolved": true,
        "details": {
          "function_name": "restart_sequencer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "467-495",
          "snippet": "STATIC void\nrestart_sequencer(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tu_int i;\n\n\tpause_sequencer(ahc);\n\n\t/*\n\t * Everytime we restart the sequencer, there\n\t * is the possiblitity that we have restarted\n\t * within a three instruction window where an\n\t * SCB has been marked free but has not made it\n\t * onto the free list.  Since SCSI events(bus reset,\n\t * unexpected bus free) will always freeze the\n\t * sequencer, we cannot close this window.  To\n\t * avoid losing an SCB, we reconsitute the free\n\t * list every time we restart the sequencer.\n\t */\n\tahc_outb(ahc, FREE_SCBH, SCB_LIST_NULL);\n\tfor (i = 0; i < ahc->scb_data->maxhscbs; i++) {\n\t\t\n\t\tahc_outb(ahc, SCBPTR, i);\n\t\tif (ahc_inb(ahc, SCB_TAG) == SCB_LIST_NULL)\n\t\t\tahc_add_curscb_to_free_list(ahc);\n\t}\n\tahc_outb(ahc, SEQCTL, FASTMODE|SEQRESET);\n\tunpause_sequencer(ahc);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "static __inline void pause_sequencer",
            "static __inline void unpause_sequencer",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nstatic __inline void pause_sequencer;\nstatic __inline void unpause_sequencer;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nrestart_sequencer(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tu_int i;\n\n\tpause_sequencer(ahc);\n\n\t/*\n\t * Everytime we restart the sequencer, there\n\t * is the possiblitity that we have restarted\n\t * within a three instruction window where an\n\t * SCB has been marked free but has not made it\n\t * onto the free list.  Since SCSI events(bus reset,\n\t * unexpected bus free) will always freeze the\n\t * sequencer, we cannot close this window.  To\n\t * avoid losing an SCB, we reconsitute the free\n\t * list every time we restart the sequencer.\n\t */\n\tahc_outb(ahc, FREE_SCBH, SCB_LIST_NULL);\n\tfor (i = 0; i < ahc->scb_data->maxhscbs; i++) {\n\t\t\n\t\tahc_outb(ahc, SCBPTR, i);\n\t\tif (ahc_inb(ahc, SCB_TAG) == SCB_LIST_NULL)\n\t\t\tahc_add_curscb_to_free_list(ahc);\n\t}\n\tahc_outb(ahc, SEQCTL, FASTMODE|SEQRESET);\n\tunpause_sequencer(ahc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 4963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SSTAT0"
          ],
          "line": 4959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"Timed-out target SCB but bus idle\""
          ],
          "line": 4956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc_print_addr",
          "args": [
            "active_scb->xs->sc_link"
          ],
          "line": 4946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCSISIGO",
            "last_phase|ATNO"
          ],
          "line": 4945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "MSG_OUT",
            "MSG_BUS_DEV_RESET"
          ],
          "line": 4944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_done",
          "args": [
            "ahc",
            "scb"
          ],
          "line": 4936
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "3401-3537",
          "snippet": "STATIC void\nahc_done(ahc, scb)\n\tstruct ahc_softc *ahc;\n\tstruct scb *scb;\n{\n\tstruct scsi_xfer *xs = scb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tint requeue = 0;\n\tint target;\n\n\tSC_DEBUG(xs->sc_link, SDEV_DB2, (\"ahc_done\\n\"));\n\t\n\tLIST_REMOVE(scb, pend_links);\n\n\tuntimeout(ahc_timeout, (caddr_t)scb);\n\n#ifdef AHC_DEBUG\n\tif (ahc_debug & AHC_SHOWCMDS) {\n\t\tsc_print_addr(sc_link);\n\t\tprintf(\"ahc_done opcode %d tag %x\\n\", xs->cmdstore.opcode,\n\t\t    scb->hscb->tag);\n\t}\n#endif\n\t\n\ttarget = sc_link->target;\n\t\n\tif (xs->datalen) {\n\t\tbus_dmasync_op_t op;\n\t\n\t\tif ((xs->flags & SCSI_DATA_IN) != 0)\n\t\t\top = BUS_DMASYNC_POSTREAD;\n\t\telse\n\t\t\top = BUS_DMASYNC_POSTWRITE;\n\t\tbus_dmamap_sync(ahc->sc_dmat, scb->dmamap, op);\n\t\tbus_dmamap_unload(ahc->sc_dmat, scb->dmamap);\n\t}\n\n\t/*\n\t * Unbusy this target/channel/lun.\n\t * XXX if we are holding two commands per lun, \n\t *     send the next command.\n\t */\n\tahc_index_busy_tcl(ahc, scb->hscb->tcl, /*unbusy*/TRUE);\n\n\t/*\n\t * If the recovery SCB completes, we have to be\n\t * out of our timeout.\n\t */\n\tif ((scb->flags & SCB_RECOVERY_SCB) != 0) {\n\n\t\tstruct\tscb *scbp;\n\n\t\t/*\n\t\t * We were able to complete the command successfully,\n\t\t * so reinstate the timeouts for all other pending\n\t\t * commands.\n\t\t */\n\t\tscbp = ahc->pending_scbs.lh_first;\n\t\twhile (scbp != NULL) {\n\t\t\tstruct scsi_xfer *txs = scbp->xs;\n\n\t\t\tif (!(txs->flags & SCSI_POLL)) {\n\t\t\t\ttimeout(ahc_timeout, scbp,\n\t\t\t\t    (scbp->xs->timeout * hz)/1000);\n\t\t\t}\n\t\t\tscbp = LIST_NEXT(scbp, pend_links);\n\t\t}\n\n\t\t/*\n\t\t * Ensure that we didn't put a second instance of this\n\t\t * SCB into the QINFIFO.\n\t\t */\n\t\tahc_search_qinfifo(ahc, SCB_TARGET(scb), SCB_CHANNEL(scb),\n\t\t\t\t   SCB_LUN(scb), scb->hscb->tag,\n\t\t\t\t   ROLE_INITIATOR, /*status*/0,\n\t\t\t\t   SEARCH_REMOVE);\n\t\tif (xs->error != XS_NOERROR)\n\t\t\tahcsetccbstatus(xs, XS_TIMEOUT);\n\t\tsc_print_addr(xs->sc_link);\n\t\tprintf(\"no longer in timeout, status = %x\\n\", xs->status);\n\t}\n\n\tif (xs->error != XS_NOERROR) {\n\t\t/* Don't clobber any existing error state */\n\t} else if ((scb->flags & SCB_SENSE) != 0) {\n\t\t/*\n\t\t * We performed autosense retrieval.\n\t\t *\n\t\t * bzero the sense data before having\n\t\t * the drive fill it.  The SCSI spec mandates\n\t\t * that any untransfered data should be\n\t\t * assumed to be zero.  Complete the 'bounce'\n\t\t * of sense information through buffers accessible\n\t\t * via bus-space by copying it into the clients\n\t\t * csio.\n\t\t */\n\t\tbzero(&xs->sense, sizeof(struct scsi_sense));\n\t\tbcopy(&ahc->scb_data->sense[scb->hscb->tag],\n\t\t      &xs->sense, scb->sg_list->len);\n\t\txs->error = XS_SENSE;\n\t}\n\tif (scb->flags & SCB_FREEZE_QUEUE) {\n\t\tahc->devqueue_blocked[target]--;\n\t\tscb->flags &= ~SCB_FREEZE_QUEUE;\n\t}\n\t\n\trequeue = scb->flags & SCB_REQUEUE;\n\tahcfreescb(ahc, scb);\n\n\tif (requeue) {\n\t\t/*\n\t\t * Re-insert at the front of the private queue to\n\t\t * preserve order.\n\t\t */\n\t\tint s;\n\n\t\ts = splbio();\n\t\t/* TAILQ_INSERT_HEAD(&ahc->sc_q, xs, adapter_q); */\n\t\tahc_list_insert_head(ahc, xs);\n\t\tsplx(s);\n\t} else {\n\t\txs->flags |= ITSDONE;\n\t\tahc_check_tags(ahc, xs);\n\t\tscsi_done(xs);\n\t}\n\n\t/*\n\t * If there are entries in the software queue, try to\n\t * run the first one.  We should be more or less guaranteed\n\t * to succeed, since we just freed an SCB.\n\t *\n\t * NOTE: ahc_scsi_cmd() relies on our calling it with\n\t * the first entry in the queue.\n\t */\n\tif ((xs = ahc->sc_xxxq.lh_first) != NULL)\n\t\t(void) ahc_scsi_cmd(xs);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
            "STATIC void",
            "ahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_done __P((struct ahc_softc *ahc, struct scb *scbp));",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "ahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));",
            "STATIC int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
            "STATIC void",
            "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_calc_residual __P((struct scb *scb));",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "static __inline u_int ahc_index_busy_tcl",
            "static __inline void ahcsetccbstatus",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "void   ahc_list_insert_head",
            "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *xs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nSTATIC void;\nahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_done __P((struct ahc_softc *ahc, struct scb *scbp));\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));\nSTATIC int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nSTATIC void;\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_calc_residual __P((struct scb *scb));\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nstatic __inline u_int ahc_index_busy_tcl;\nstatic __inline void ahcsetccbstatus;\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nSTATIC void;\nSTATIC void;\nvoid   ahc_list_insert_head;\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n\nSTATIC void\nahc_done(ahc, scb)\n\tstruct ahc_softc *ahc;\n\tstruct scb *scb;\n{\n\tstruct scsi_xfer *xs = scb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tint requeue = 0;\n\tint target;\n\n\tSC_DEBUG(xs->sc_link, SDEV_DB2, (\"ahc_done\\n\"));\n\t\n\tLIST_REMOVE(scb, pend_links);\n\n\tuntimeout(ahc_timeout, (caddr_t)scb);\n\n#ifdef AHC_DEBUG\n\tif (ahc_debug & AHC_SHOWCMDS) {\n\t\tsc_print_addr(sc_link);\n\t\tprintf(\"ahc_done opcode %d tag %x\\n\", xs->cmdstore.opcode,\n\t\t    scb->hscb->tag);\n\t}\n#endif\n\t\n\ttarget = sc_link->target;\n\t\n\tif (xs->datalen) {\n\t\tbus_dmasync_op_t op;\n\t\n\t\tif ((xs->flags & SCSI_DATA_IN) != 0)\n\t\t\top = BUS_DMASYNC_POSTREAD;\n\t\telse\n\t\t\top = BUS_DMASYNC_POSTWRITE;\n\t\tbus_dmamap_sync(ahc->sc_dmat, scb->dmamap, op);\n\t\tbus_dmamap_unload(ahc->sc_dmat, scb->dmamap);\n\t}\n\n\t/*\n\t * Unbusy this target/channel/lun.\n\t * XXX if we are holding two commands per lun, \n\t *     send the next command.\n\t */\n\tahc_index_busy_tcl(ahc, scb->hscb->tcl, /*unbusy*/TRUE);\n\n\t/*\n\t * If the recovery SCB completes, we have to be\n\t * out of our timeout.\n\t */\n\tif ((scb->flags & SCB_RECOVERY_SCB) != 0) {\n\n\t\tstruct\tscb *scbp;\n\n\t\t/*\n\t\t * We were able to complete the command successfully,\n\t\t * so reinstate the timeouts for all other pending\n\t\t * commands.\n\t\t */\n\t\tscbp = ahc->pending_scbs.lh_first;\n\t\twhile (scbp != NULL) {\n\t\t\tstruct scsi_xfer *txs = scbp->xs;\n\n\t\t\tif (!(txs->flags & SCSI_POLL)) {\n\t\t\t\ttimeout(ahc_timeout, scbp,\n\t\t\t\t    (scbp->xs->timeout * hz)/1000);\n\t\t\t}\n\t\t\tscbp = LIST_NEXT(scbp, pend_links);\n\t\t}\n\n\t\t/*\n\t\t * Ensure that we didn't put a second instance of this\n\t\t * SCB into the QINFIFO.\n\t\t */\n\t\tahc_search_qinfifo(ahc, SCB_TARGET(scb), SCB_CHANNEL(scb),\n\t\t\t\t   SCB_LUN(scb), scb->hscb->tag,\n\t\t\t\t   ROLE_INITIATOR, /*status*/0,\n\t\t\t\t   SEARCH_REMOVE);\n\t\tif (xs->error != XS_NOERROR)\n\t\t\tahcsetccbstatus(xs, XS_TIMEOUT);\n\t\tsc_print_addr(xs->sc_link);\n\t\tprintf(\"no longer in timeout, status = %x\\n\", xs->status);\n\t}\n\n\tif (xs->error != XS_NOERROR) {\n\t\t/* Don't clobber any existing error state */\n\t} else if ((scb->flags & SCB_SENSE) != 0) {\n\t\t/*\n\t\t * We performed autosense retrieval.\n\t\t *\n\t\t * bzero the sense data before having\n\t\t * the drive fill it.  The SCSI spec mandates\n\t\t * that any untransfered data should be\n\t\t * assumed to be zero.  Complete the 'bounce'\n\t\t * of sense information through buffers accessible\n\t\t * via bus-space by copying it into the clients\n\t\t * csio.\n\t\t */\n\t\tbzero(&xs->sense, sizeof(struct scsi_sense));\n\t\tbcopy(&ahc->scb_data->sense[scb->hscb->tag],\n\t\t      &xs->sense, scb->sg_list->len);\n\t\txs->error = XS_SENSE;\n\t}\n\tif (scb->flags & SCB_FREEZE_QUEUE) {\n\t\tahc->devqueue_blocked[target]--;\n\t\tscb->flags &= ~SCB_FREEZE_QUEUE;\n\t}\n\t\n\trequeue = scb->flags & SCB_REQUEUE;\n\tahcfreescb(ahc, scb);\n\n\tif (requeue) {\n\t\t/*\n\t\t * Re-insert at the front of the private queue to\n\t\t * preserve order.\n\t\t */\n\t\tint s;\n\n\t\ts = splbio();\n\t\t/* TAILQ_INSERT_HEAD(&ahc->sc_q, xs, adapter_q); */\n\t\tahc_list_insert_head(ahc, xs);\n\t\tsplx(s);\n\t} else {\n\t\txs->flags |= ITSDONE;\n\t\tahc_check_tags(ahc, xs);\n\t\tscsi_done(xs);\n\t}\n\n\t/*\n\t * If there are entries in the software queue, try to\n\t * run the first one.  We should be more or less guaranteed\n\t * to succeed, since we just freed an SCB.\n\t *\n\t * NOTE: ahc_scsi_cmd() relies on our calling it with\n\t * the first entry in the queue.\n\t */\n\tif ((xs = ahc->sc_xxxq.lh_first) != NULL)\n\t\t(void) ahc_scsi_cmd(xs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_freeze_ccb",
          "args": [
            "scb"
          ],
          "line": 4935
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_freeze_ccb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "533-546",
          "snippet": "static __inline void\nahc_freeze_ccb(scb)\n\tstruct scb *scb;\n{\n\tstruct scsi_xfer *xs = scb->xs;\n\tstruct ahc_softc *ahc = (struct ahc_softc *)xs->sc_link->adapter_softc;\n\tint target;\n\n\ttarget = xs->sc_link->target;\n\tif (!(scb->flags & SCB_FREEZE_QUEUE)) {\n\t\tahc->devqueue_blocked[target]++;\n\t\tscb->flags |= SCB_FREEZE_QUEUE;\n\t}\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
            "ahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "ahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
            "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
            "ahc_calc_residual __P((struct scb *scb));",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "static __inline void ahc_freeze_ccb",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
            "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *xs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC struct;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));\nahc_loadseq __P((struct ahc_softc *ahc));\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nahc_clear_intstat __P((struct ahc_softc *ahc));\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nahc_calc_residual __P((struct scb *scb));\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nrestart_sequencer __P((struct ahc_softc *ahc));\nstatic __inline void ahc_freeze_ccb;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n\nstatic __inline void\nahc_freeze_ccb(scb)\n\tstruct scb *scb;\n{\n\tstruct scsi_xfer *xs = scb->xs;\n\tstruct ahc_softc *ahc = (struct ahc_softc *)xs->sc_link->adapter_softc;\n\tint target;\n\n\ttarget = xs->sc_link->target;\n\tif (!(scb->flags & SCB_FREEZE_QUEUE)) {\n\t\tahc->devqueue_blocked[target]++;\n\t\tscb->flags |= SCB_FREEZE_QUEUE;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahcsetccbstatus",
          "args": [
            "scb->xs",
            "XS_TIMEOUT"
          ],
          "line": 4934
        },
        "resolved": true,
        "details": {
          "function_name": "ahcsetccbstatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "548-554",
          "snippet": "static __inline void\nahcsetccbstatus(xs, status)\n\tstruct scsi_xfer *xs;\n\tint status;\n{\n\txs->error = status;\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "ahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));",
            "STATIC struct",
            "STATIC struct",
            "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
            "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
            "static __inline void ahcsetccbstatus",
            "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
            "STATIC struct",
            "STATIC struct",
            "STATIC struct",
            "struct scsi_xfer *xs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nSTATIC struct;\nahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));\nSTATIC struct;\nSTATIC struct;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nstatic __inline void ahcsetccbstatus;\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nSTATIC struct;\nSTATIC struct;\nSTATIC struct;\nstruct scsi_xfer *xs;\n\nstatic __inline void\nahcsetccbstatus(xs, status)\n\tstruct scsi_xfer *xs;\n\tint status;\n{\n\txs->error = status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_freeze_devq",
          "args": [
            "ahc",
            "scb->xs->sc_link"
          ],
          "line": 4933
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_freeze_devq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "4434-4450",
          "snippet": "STATIC void\nahc_freeze_devq(ahc, sc_link)\n\tstruct ahc_softc *ahc;\n\tstruct scsi_link *sc_link;\n{\n\tint\ttarget;\n\tchar\tchannel;\n\tint\tlun;\n\n\ttarget = sc_link->target;\n\tlun = sc_link->lun;\n\tchannel = SIM_CHANNEL(ahc, sc_link);\n\t\n\tahc_search_qinfifo(ahc, target, channel, lun,\n\t\t\t   /*tag*/SCB_LIST_NULL, ROLE_UNKNOWN,\n\t\t\t   SCB_REQUEUE, SEARCH_COMPLETE);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "ahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_freeze_devq(ahc, sc_link)\n\tstruct ahc_softc *ahc;\n\tstruct scsi_link *sc_link;\n{\n\tint\ttarget;\n\tchar\tchannel;\n\tint\tlun;\n\n\ttarget = sc_link->target;\n\tlun = sc_link->lun;\n\tchannel = SIM_CHANNEL(ahc, sc_link);\n\t\n\tahc_search_qinfifo(ahc, target, channel, lun,\n\t\t\t   /*tag*/SCB_LIST_NULL, ROLE_UNKNOWN,\n\t\t\t   SCB_REQUEUE, SEARCH_COMPLETE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 4922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAX",
          "args": [
            "active_scb->xs->timeout",
            "scb->xs->timeout"
          ],
          "line": 4918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc_print_addr",
          "args": [
            "scb->xs->sc_link"
          ],
          "line": 4913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCB_TAG"
          ],
          "line": 4897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 4871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_reset_channel",
          "args": [
            "ahc",
            "channel",
            "/*Initiate Reset*/TRUE"
          ],
          "line": 4869
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_reset_channel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "5412-5527",
          "snippet": "STATIC int\nahc_reset_channel(ahc, channel, initiate_reset)\n\tstruct ahc_softc *ahc;\n\tchar channel;\n\tint initiate_reset;\n{\n\tu_int\tinitiator, target, max_scsiid;\n\tu_int\tsblkctl;\n\tu_int\tour_id;\n\tint\tfound;\n\tint\trestart_needed;\n\tchar\tcur_channel;\n\n\tahc->pending_device = NULL;\n\n\tpause_sequencer(ahc);\n\n\t/*\n\t * Run our command complete fifos to ensure that we perform\n\t * completion processing on any commands that 'completed'\n\t * before the reset occurred.\n\t */\n\tahc_run_qoutfifo(ahc);\n\n\t/*\n\t * Reset the bus if we are initiating this reset\n\t */\n\tsblkctl = ahc_inb(ahc, SBLKCTL);\n\tcur_channel = 'A';\n\tif ((ahc->features & AHC_TWIN) != 0\n\t && ((sblkctl & SELBUSB) != 0))\n\t    cur_channel = 'B';\n\tif (cur_channel != channel) {\n\t\t/* Case 1: Command for another bus is active\n\t\t * Stealthily reset the other bus without\n\t\t * upsetting the current bus.\n\t\t */\n\t\tahc_outb(ahc, SBLKCTL, sblkctl ^ SELBUSB);\n\t\tahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENBUSFREE);\n\t\tahc_outb(ahc, SCSISEQ,\n\t\t\t ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP));\n\t\tif (initiate_reset)\n\t\t\tahc_reset_current_bus(ahc);\n\t\tahc_clear_intstat(ahc);\n\t\tahc_outb(ahc, SBLKCTL, sblkctl);\n\t\trestart_needed = FALSE;\n\t} else {\n\t\t/* Case 2: A command from this bus is active or we're idle */\n\t\tahc_clear_msg_state(ahc);\n\t\tahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENBUSFREE);\n\t\tahc_outb(ahc, SCSISEQ,\n\t\t\t ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP));\n\t\tif (initiate_reset)\n\t\t\tahc_reset_current_bus(ahc);\n\t\tahc_clear_intstat(ahc);\n\n\t\t/*\n\t\t * Since we are going to restart the sequencer, avoid\n\t\t * a race in the sequencer that could cause corruption\n\t\t * of our Q pointers by starting over from index 0.\n\t\t */\n\t\tahc->qoutfifonext = 0;\n\t\tif ((ahc->features & AHC_QUEUE_REGS) != 0)\n\t\t\tahc_outb(ahc, SDSCB_QOFF, 0);\n\t\telse\n\t\t\tahc_outb(ahc, QOUTPOS, 0);\n\t\trestart_needed = TRUE;\n\t}\n\n\t/*\n\t * Clean up all the state information for the\n\t * pending transactions on this bus.\n\t */\n\tfound = ahc_abort_scbs(ahc, ALL_TARGETS, channel,\n\t\t\t       ALL_LUNS, SCB_LIST_NULL,\n\t\t\t       ROLE_UNKNOWN, XS_RESET);\n\tif (channel == 'B') {\n\t\tour_id = ahc->our_id_b;\n\t} else {\n\t\tour_id = ahc->our_id;\n\t}\n\n\tmax_scsiid = (ahc->features & AHC_WIDE) ? 15 : 7;\n\t\n\t/*\n\t * Revert to async/narrow transfers until we renegotiate.\n\t */\n\tfor (target = 0; target <= max_scsiid; target++) {\n\n\t\tif (ahc->enabled_targets[target] == NULL)\n\t\t\tcontinue;\n\t\tfor (initiator = 0; initiator <= max_scsiid; initiator++) {\n\t\t\tstruct ahc_devinfo devinfo;\n\n\t\t\tahc_compile_devinfo(&devinfo, target, initiator,\n\t\t\t\t\t    ALL_LUNS,\n\t\t\t\t\t    channel, ROLE_UNKNOWN);\n\t\t\tahc_set_width(ahc, &devinfo,\n\t\t\t\t      MSG_EXT_WDTR_BUS_8_BIT,\n\t\t\t\t      AHC_TRANS_CUR,\n\t\t\t\t      /*paused*/TRUE,\n\t\t\t\t      /*done*/FALSE);\n\t\t\tahc_set_syncrate(ahc, &devinfo,\n\t\t\t\t\t /*syncrate*/NULL, /*period*/0,\n\t\t\t\t\t /*offset*/0, AHC_TRANS_CUR,\n\t\t\t\t\t /*paused*/TRUE,\n\t\t\t\t\t /*done*/FALSE);\n\t\t}\n\t}\n\n\tif (restart_needed)\n\t\trestart_sequencer(ahc);\n\telse\n\t\tunpause_sequencer(ahc);\n\treturn found;\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC int",
            "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "ahc_reset_channel __P((struct ahc_softc *ahc, char channel,\n\t\t\t\t       int initiate_reset));",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "ahc_update_target_msg_request __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t\t      struct ahc_initiator_tinfo *tinfo,\n\t\t\t\t\t      int force, int paused));",
            "STATIC void",
            "ahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));",
            "STATIC void",
            "ahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "static __inline void pause_sequencer",
            "static __inline void unpause_sequencer",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "u_int our_id;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "u_int *period;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "u_int *period;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nahc_reset_channel __P((struct ahc_softc *ahc, char channel,\n\t\t\t\t       int initiate_reset));\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nahc_update_target_msg_request __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t\t      struct ahc_initiator_tinfo *tinfo,\n\t\t\t\t\t      int force, int paused));\nSTATIC void;\nahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));\nSTATIC void;\nahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nstatic __inline void pause_sequencer;\nstatic __inline void unpause_sequencer;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nu_int our_id;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC int\nahc_reset_channel(ahc, channel, initiate_reset)\n\tstruct ahc_softc *ahc;\n\tchar channel;\n\tint initiate_reset;\n{\n\tu_int\tinitiator, target, max_scsiid;\n\tu_int\tsblkctl;\n\tu_int\tour_id;\n\tint\tfound;\n\tint\trestart_needed;\n\tchar\tcur_channel;\n\n\tahc->pending_device = NULL;\n\n\tpause_sequencer(ahc);\n\n\t/*\n\t * Run our command complete fifos to ensure that we perform\n\t * completion processing on any commands that 'completed'\n\t * before the reset occurred.\n\t */\n\tahc_run_qoutfifo(ahc);\n\n\t/*\n\t * Reset the bus if we are initiating this reset\n\t */\n\tsblkctl = ahc_inb(ahc, SBLKCTL);\n\tcur_channel = 'A';\n\tif ((ahc->features & AHC_TWIN) != 0\n\t && ((sblkctl & SELBUSB) != 0))\n\t    cur_channel = 'B';\n\tif (cur_channel != channel) {\n\t\t/* Case 1: Command for another bus is active\n\t\t * Stealthily reset the other bus without\n\t\t * upsetting the current bus.\n\t\t */\n\t\tahc_outb(ahc, SBLKCTL, sblkctl ^ SELBUSB);\n\t\tahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENBUSFREE);\n\t\tahc_outb(ahc, SCSISEQ,\n\t\t\t ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP));\n\t\tif (initiate_reset)\n\t\t\tahc_reset_current_bus(ahc);\n\t\tahc_clear_intstat(ahc);\n\t\tahc_outb(ahc, SBLKCTL, sblkctl);\n\t\trestart_needed = FALSE;\n\t} else {\n\t\t/* Case 2: A command from this bus is active or we're idle */\n\t\tahc_clear_msg_state(ahc);\n\t\tahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENBUSFREE);\n\t\tahc_outb(ahc, SCSISEQ,\n\t\t\t ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP));\n\t\tif (initiate_reset)\n\t\t\tahc_reset_current_bus(ahc);\n\t\tahc_clear_intstat(ahc);\n\n\t\t/*\n\t\t * Since we are going to restart the sequencer, avoid\n\t\t * a race in the sequencer that could cause corruption\n\t\t * of our Q pointers by starting over from index 0.\n\t\t */\n\t\tahc->qoutfifonext = 0;\n\t\tif ((ahc->features & AHC_QUEUE_REGS) != 0)\n\t\t\tahc_outb(ahc, SDSCB_QOFF, 0);\n\t\telse\n\t\t\tahc_outb(ahc, QOUTPOS, 0);\n\t\trestart_needed = TRUE;\n\t}\n\n\t/*\n\t * Clean up all the state information for the\n\t * pending transactions on this bus.\n\t */\n\tfound = ahc_abort_scbs(ahc, ALL_TARGETS, channel,\n\t\t\t       ALL_LUNS, SCB_LIST_NULL,\n\t\t\t       ROLE_UNKNOWN, XS_RESET);\n\tif (channel == 'B') {\n\t\tour_id = ahc->our_id_b;\n\t} else {\n\t\tour_id = ahc->our_id;\n\t}\n\n\tmax_scsiid = (ahc->features & AHC_WIDE) ? 15 : 7;\n\t\n\t/*\n\t * Revert to async/narrow transfers until we renegotiate.\n\t */\n\tfor (target = 0; target <= max_scsiid; target++) {\n\n\t\tif (ahc->enabled_targets[target] == NULL)\n\t\t\tcontinue;\n\t\tfor (initiator = 0; initiator <= max_scsiid; initiator++) {\n\t\t\tstruct ahc_devinfo devinfo;\n\n\t\t\tahc_compile_devinfo(&devinfo, target, initiator,\n\t\t\t\t\t    ALL_LUNS,\n\t\t\t\t\t    channel, ROLE_UNKNOWN);\n\t\t\tahc_set_width(ahc, &devinfo,\n\t\t\t\t      MSG_EXT_WDTR_BUS_8_BIT,\n\t\t\t\t      AHC_TRANS_CUR,\n\t\t\t\t      /*paused*/TRUE,\n\t\t\t\t      /*done*/FALSE);\n\t\t\tahc_set_syncrate(ahc, &devinfo,\n\t\t\t\t\t /*syncrate*/NULL, /*period*/0,\n\t\t\t\t\t /*offset*/0, AHC_TRANS_CUR,\n\t\t\t\t\t /*paused*/TRUE,\n\t\t\t\t\t /*done*/FALSE);\n\t\t}\n\t}\n\n\tif (restart_needed)\n\t\trestart_sequencer(ahc);\n\telse\n\t\tunpause_sequencer(ahc);\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "CCHCNT"
          ],
          "line": 4852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "DFSTATUS"
          ],
          "line": 4851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "DFCNTRL"
          ],
          "line": 4850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "CCSCBCNT"
          ],
          "line": 4849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "CCSCBCTL"
          ],
          "line": 4848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCB_SGCOUNT"
          ],
          "line": 4847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCB_DATACNT + 2"
          ],
          "line": 4846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCB_DATACNT + 1"
          ],
          "line": 4845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCB_DATACNT"
          ],
          "line": 4844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCB_DATAPTR + 3"
          ],
          "line": 4843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCB_DATAPTR + 2"
          ],
          "line": 4842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCB_DATAPTR + 1"
          ],
          "line": 4841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCB_DATAPTR"
          ],
          "line": 4840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SEQ_FLAGS"
          ],
          "line": 4839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCSIOFFSET"
          ],
          "line": 4838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCSIRATE"
          ],
          "line": 4837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCSIPHASE"
          ],
          "line": 4836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SSTAT3"
          ],
          "line": 4835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SSTAT1"
          ],
          "line": 4834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SEQADDR1"
          ],
          "line": 4832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SEQADDR0"
          ],
          "line": 4832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "LASTPHASE"
          ],
          "line": 4823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc_print_addr",
          "args": [
            "scb->xs->sc_link"
          ],
          "line": 4817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCB_LUN",
          "args": [
            "scb"
          ],
          "line": 4815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCB_CHANNEL",
          "args": [
            "scb"
          ],
          "line": 4814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCB_TARGET",
          "args": [
            "scb"
          ],
          "line": 4813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 4809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "INTSTAT"
          ],
          "line": 4803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_intr",
          "args": [
            "ahc"
          ],
          "line": 4801
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "1591-1655",
          "snippet": "int\nahc_intr(void *arg)\n{\n\tstruct\tahc_softc *ahc;\n\tu_int\tintstat;\n\n\tahc = (struct ahc_softc *)arg; \n\n\tintstat = ahc_inb(ahc, INTSTAT);\n\n\t/*\n\t * Any interrupts to process?\n\t */\n\tif ((intstat & INT_PEND) == 0) {\n\t\tif (ahc->pci_intr_func && ahc->pci_intr_func(ahc)) {\n#ifdef AHC_DEBUG\n\t\t\tprintf(\"%s: bus intr: CCHADDR %x HADDR %x SEQADDR %x\\n\",\n\t\t\t    ahc_name(ahc),\n\t\t\t    ahc_inb(ahc, CCHADDR) |\n\t\t\t    (ahc_inb(ahc, CCHADDR+1) << 8)\n\t\t\t    | (ahc_inb(ahc, CCHADDR+2) << 16)\n\t\t\t    | (ahc_inb(ahc, CCHADDR+3) << 24),\n\t\t\t    ahc_inb(ahc, HADDR) | (ahc_inb(ahc, HADDR+1) << 8)\n\t\t\t    | (ahc_inb(ahc, HADDR+2) << 16)\n\t\t\t    | (ahc_inb(ahc, HADDR+3) << 24),\n\t\t\t    ahc_inb(ahc, SEQADDR0) |\n\t\t\t    (ahc_inb(ahc, SEQADDR1) << 8));\n#endif\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (intstat & CMDCMPLT) {\n\t\tahc_outb(ahc, CLRINT, CLRCMDINT);\n\t\tahc_run_qoutfifo(ahc);\n\t}\n\tif (intstat & BRKADRINT) {\n\t\t/*\n\t\t * We upset the sequencer :-(\n\t\t * Lookup the error message\n\t\t */\n\t\tint i, error, num_errors;\n\n\t\terror = ahc_inb(ahc, ERROR);\n\t\tnum_errors =  sizeof(hard_error)/sizeof(hard_error[0]);\n\t\tfor (i = 0; error != 1 && i < num_errors; i++)\n\t\t\terror >>= 1;\n\t\tpanic(\"%s: brkadrint, %s at seqaddr = 0x%x\\n\",\n\t\t      ahc_name(ahc), hard_error[i].errmesg,\n\t\t      ahc_inb(ahc, SEQADDR0) |\n\t\t      (ahc_inb(ahc, SEQADDR1) << 8));\n\n\t\t/* Tell everyone that this HBA is no longer availible */\n\t\tahc_abort_scbs(ahc, ALL_TARGETS, ALL_CHANNELS,\n\t\t\t       ALL_LUNS, SCB_LIST_NULL, ROLE_UNKNOWN,\n\t\t\t       XS_DRIVER_STUFFUP);\n\t}\n\tif (intstat & SEQINT)\n\t\tahc_handle_seqint(ahc, intstat);\n\n\tif (intstat & SCSIINT)\n\t\tahc_handle_scsiint(ahc, intstat);\n\treturn(1);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define ALL_CHANNELS '\\0'"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "ahc_shutdown __P((void *arg));",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC u_int",
            "STATIC struct",
            "ahc_handle_seqint __P((struct ahc_softc *ahc, u_int intstat));",
            "ahc_handle_scsiint __P((struct ahc_softc *ahc, u_int intstat));",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC u_int",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "static struct {\n        u_int8_t errno;\n\tchar *errmesg;\n} hard_error[] = {\n\t{ ILLHADDR,\t\"Illegal Host Access\" },\n\t{ ILLSADDR,\t\"Illegal Sequencer Address referrenced\" },\n\t{ ILLOPCODE,\t\"Illegal Opcode in sequencer program\" },\n\t{ SQPARERR,\t\"Sequencer Parity Error\" },\n\t{ DPARERR,\t\"Data-path Parity Error\" },\n\t{ MPARERR,\t\"Scratch or SCB Memory Parity Error\" },\n\t{ PCIERRSTAT,\t\"PCI Error detected\" },\n\t{ CIOPARERR,\t\"CIOBUS Parity Error\" },\n};",
            "static const int num_errors = sizeof(hard_error)/sizeof(hard_error[0]);",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define ALL_CHANNELS '\\0'\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nahc_shutdown __P((void *arg));\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC u_int;\nSTATIC struct;\nahc_handle_seqint __P((struct ahc_softc *ahc, u_int intstat));\nahc_handle_scsiint __P((struct ahc_softc *ahc, u_int intstat));\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC u_int;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nahc_clear_intstat __P((struct ahc_softc *ahc));\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nrestart_sequencer __P((struct ahc_softc *ahc));\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nstatic struct {\n        u_int8_t errno;\n\tchar *errmesg;\n} hard_error[] = {\n\t{ ILLHADDR,\t\"Illegal Host Access\" },\n\t{ ILLSADDR,\t\"Illegal Sequencer Address referrenced\" },\n\t{ ILLOPCODE,\t\"Illegal Opcode in sequencer program\" },\n\t{ SQPARERR,\t\"Sequencer Parity Error\" },\n\t{ DPARERR,\t\"Data-path Parity Error\" },\n\t{ MPARERR,\t\"Scratch or SCB Memory Parity Error\" },\n\t{ PCIERRSTAT,\t\"PCI Error detected\" },\n\t{ CIOPARERR,\t\"CIOBUS Parity Error\" },\n};\nstatic const int num_errors = sizeof(hard_error)/sizeof(hard_error[0]);\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nint\nahc_intr(void *arg)\n{\n\tstruct\tahc_softc *ahc;\n\tu_int\tintstat;\n\n\tahc = (struct ahc_softc *)arg; \n\n\tintstat = ahc_inb(ahc, INTSTAT);\n\n\t/*\n\t * Any interrupts to process?\n\t */\n\tif ((intstat & INT_PEND) == 0) {\n\t\tif (ahc->pci_intr_func && ahc->pci_intr_func(ahc)) {\n#ifdef AHC_DEBUG\n\t\t\tprintf(\"%s: bus intr: CCHADDR %x HADDR %x SEQADDR %x\\n\",\n\t\t\t    ahc_name(ahc),\n\t\t\t    ahc_inb(ahc, CCHADDR) |\n\t\t\t    (ahc_inb(ahc, CCHADDR+1) << 8)\n\t\t\t    | (ahc_inb(ahc, CCHADDR+2) << 16)\n\t\t\t    | (ahc_inb(ahc, CCHADDR+3) << 24),\n\t\t\t    ahc_inb(ahc, HADDR) | (ahc_inb(ahc, HADDR+1) << 8)\n\t\t\t    | (ahc_inb(ahc, HADDR+2) << 16)\n\t\t\t    | (ahc_inb(ahc, HADDR+3) << 24),\n\t\t\t    ahc_inb(ahc, SEQADDR0) |\n\t\t\t    (ahc_inb(ahc, SEQADDR1) << 8));\n#endif\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (intstat & CMDCMPLT) {\n\t\tahc_outb(ahc, CLRINT, CLRCMDINT);\n\t\tahc_run_qoutfifo(ahc);\n\t}\n\tif (intstat & BRKADRINT) {\n\t\t/*\n\t\t * We upset the sequencer :-(\n\t\t * Lookup the error message\n\t\t */\n\t\tint i, error, num_errors;\n\n\t\terror = ahc_inb(ahc, ERROR);\n\t\tnum_errors =  sizeof(hard_error)/sizeof(hard_error[0]);\n\t\tfor (i = 0; error != 1 && i < num_errors; i++)\n\t\t\terror >>= 1;\n\t\tpanic(\"%s: brkadrint, %s at seqaddr = 0x%x\\n\",\n\t\t      ahc_name(ahc), hard_error[i].errmesg,\n\t\t      ahc_inb(ahc, SEQADDR0) |\n\t\t      (ahc_inb(ahc, SEQADDR1) << 8));\n\n\t\t/* Tell everyone that this HBA is no longer availible */\n\t\tahc_abort_scbs(ahc, ALL_TARGETS, ALL_CHANNELS,\n\t\t\t       ALL_LUNS, SCB_LIST_NULL, ROLE_UNKNOWN,\n\t\t\t       XS_DRIVER_STUFFUP);\n\t}\n\tif (intstat & SEQINT)\n\t\tahc_handle_seqint(ahc, intstat);\n\n\tif (intstat & SCSIINT)\n\t\tahc_handle_scsiint(ahc, intstat);\n\treturn(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 4792
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nahc_poll __P((struct ahc_softc *ahc, int wait));\nSTATIC void;\nahc_shutdown __P((void *arg));\nSTATIC int;\nSTATIC int;\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nSTATIC void;\nahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));\nSTATIC int;\nahc_sent_msg __P((struct ahc_softc *ahc, u_int msgtype,\n\t\t\t\t  int full));\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_search_qinfifo __P((struct ahc_softc *ahc, int target,\n\t\t\t\t\tchar channel, int lun, u_int tag,\n\t\t\t\t\trole_t role, u_int32_t status,\n\t\t\t\t\tahc_search_action action));\nSTATIC int;\nSTATIC int;\nahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));\nSTATIC int;\nahc_search_disc_list __P((struct ahc_softc *ahc, int target,\n\t\t\t\t\t  char channel, int lun, u_int tag,\n\t\t\t\t\t  int stop_on_first, int remove,\n\t\t\t\t\t  int save_state));\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nSTATIC void;\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_calc_residual __P((struct scb *scb));\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nSTATIC void;\nstatic __inline void pause_sequencer;\nstatic __inline void unpause_sequencer;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nstatic __inline u_int ahc_index_busy_tcl;\nstatic __inline void ahc_freeze_ccb;\nstatic __inline void ahcsetccbstatus;\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nstatic struct {\n        u_int8_t phase;\n        u_int8_t mesg_out; /* Message response to parity errors */\n\tchar *phasemsg;\n} phase_table[] = {\n\t{ P_DATAOUT,\tMSG_NOOP,\t\t\"in Data-out phase\"\t},\n\t{ P_DATAIN,\tMSG_INITIATOR_DET_ERR,\t\"in Data-in phase\"\t},\n\t{ P_COMMAND,\tMSG_NOOP,\t\t\"in Command phase\"\t},\n\t{ P_MESGOUT,\tMSG_NOOP,\t\t\"in Message-out phase\"\t},\n\t{ P_STATUS,\tMSG_INITIATOR_DET_ERR,\t\"in Status phase\"\t},\n\t{ P_MESGIN,\tMSG_PARITY_ERROR,\t\"in Message-in phase\"\t},\n\t{ P_BUSFREE,\tMSG_NOOP,\t\t\"while idle\"\t\t},\n\t{ 0,\t\tMSG_NOOP,\t\t\"in unknown phase\"\t}\n};\nstatic const int num_phases = (sizeof(phase_table)/sizeof(phase_table[0])) - 1;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n\nSTATIC void\nahc_timeout(void *arg)\n{\n\tstruct\tscb *scb;\n\tstruct\tahc_softc *ahc;\n\tint\ts, found;\n\tu_int\tlast_phase;\n\tint\ttarget;\n\tint\tlun;\n\tint\ti;\n\tchar\tchannel;\n\n\tscb = (struct scb *)arg; \n\tahc = (struct ahc_softc *)scb->xs->sc_link->adapter_softc;\n\n\ts = splbio();\n\n\t/*\n\t * Ensure that the card doesn't do anything\n\t * behind our back.  Also make sure that we\n\t * didn't \"just\" miss an interrupt that would\n\t * affect this timeout.\n\t */\n\tdo {\n\t\tahc_intr(ahc);\n\t\tpause_sequencer(ahc);\n\t} while (ahc_inb(ahc, INTSTAT) & INT_PEND);\n\n\tif ((scb->flags & SCB_ACTIVE) == 0) {\n\t\t/* Previous timeout took care of me already */\n\t\tprintf(\"Timedout SCB handled by another timeout\\n\");\n\t\tunpause_sequencer(ahc);\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\ttarget = SCB_TARGET(scb);\n\tchannel = SCB_CHANNEL(scb);\n\tlun = SCB_LUN(scb);\n\n\tsc_print_addr(scb->xs->sc_link);\n\tprintf(\"SCB 0x%x - timed out \", scb->hscb->tag);\n\t/*\n\t * Take a snapshot of the bus state and print out\n\t * some information so we can track down driver bugs.\n\t */\n\tlast_phase = ahc_inb(ahc, LASTPHASE);\n\n\tfor (i = 0; i < num_phases; i++) {\n\t\tif (last_phase == phase_table[i].phase)\n\t\t\tbreak;\n\t}\n\tprintf(\"%s\", phase_table[i].phasemsg);\n  \n\tprintf(\", SEQADDR == 0x%x\\n\",\n\t       ahc_inb(ahc, SEQADDR0) | (ahc_inb(ahc, SEQADDR1) << 8));\n#if 0\n\tprintf(\"SSTAT1 == 0x%x\\n\", ahc_inb(ahc, SSTAT1));\n\tprintf(\"SSTAT3 == 0x%x\\n\", ahc_inb(ahc, SSTAT3));\n\tprintf(\"SCSIPHASE == 0x%x\\n\", ahc_inb(ahc, SCSIPHASE));\n\tprintf(\"SCSIRATE == 0x%x\\n\", ahc_inb(ahc, SCSIRATE));\n\tprintf(\"SCSIOFFSET == 0x%x\\n\", ahc_inb(ahc, SCSIOFFSET));\n\tprintf(\"SEQ_FLAGS == 0x%x\\n\", ahc_inb(ahc, SEQ_FLAGS));\n\tprintf(\"SCB_DATAPTR == 0x%x\\n\", ahc_inb(ahc, SCB_DATAPTR)\n\t\t\t\t      | ahc_inb(ahc, SCB_DATAPTR + 1) << 8\n\t\t\t\t      | ahc_inb(ahc, SCB_DATAPTR + 2) << 16\n\t\t\t\t      | ahc_inb(ahc, SCB_DATAPTR + 3) << 24);\n\tprintf(\"SCB_DATACNT == 0x%x\\n\", ahc_inb(ahc, SCB_DATACNT)\n\t\t\t\t      | ahc_inb(ahc, SCB_DATACNT + 1) << 8\n\t\t\t\t      | ahc_inb(ahc, SCB_DATACNT + 2) << 16);\n\tprintf(\"SCB_SGCOUNT == 0x%x\\n\", ahc_inb(ahc, SCB_SGCOUNT));\n\tprintf(\"CCSCBCTL == 0x%x\\n\", ahc_inb(ahc, CCSCBCTL));\n\tprintf(\"CCSCBCNT == 0x%x\\n\", ahc_inb(ahc, CCSCBCNT));\n\tprintf(\"DFCNTRL == 0x%x\\n\", ahc_inb(ahc, DFCNTRL));\n\tprintf(\"DFSTATUS == 0x%x\\n\", ahc_inb(ahc, DFSTATUS));\n\tprintf(\"CCHCNT == 0x%x\\n\", ahc_inb(ahc, CCHCNT));\n\tif (scb->sg_count > 0) {\n\t\tfor (i = 0; i < scb->sg_count; i++) {\n\t\t\tprintf(\"sg[%d] - Addr 0x%x : Length %d\\n\",\n\t\t\t       i,\n\t\t\t       scb->sg_list[i].addr,\n\t\t\t       scb->sg_list[i].len);\n\t\t}\n\t}\n#endif\n\tif (scb->flags & (SCB_DEVICE_RESET|SCB_ABORT)) {\n\t\t/*\n\t\t * Been down this road before.\n\t\t * Do a full bus reset.\n\t\t */\nbus_reset:\n\t\tahcsetccbstatus(scb->xs, XS_TIMEOUT);\n\t\tfound = ahc_reset_channel(ahc, channel, /*Initiate Reset*/TRUE);\n\t\tprintf(\"%s: Issued Channel %c Bus Reset. \"\n\t\t       \"%d SCBs aborted\\n\", ahc_name(ahc), channel, found);\n\t} else {\n\t\t/*\n\t\t * If we are a target, transition to bus free and report\n\t\t * the timeout.\n\t\t * \n\t\t * The target/initiator that is holding up the bus may not\n\t\t * be the same as the one that triggered this timeout\n\t\t * (different commands have different timeout lengths).\n\t\t * If the bus is idle and we are actiing as the initiator\n\t\t * for this request, queue a BDR message to the timed out\n\t\t * target.  Otherwise, if the timed out transaction is\n\t\t * active:\n\t\t *   Initiator transaction:\n\t\t *\tStuff the message buffer with a BDR message and assert\n\t\t *\tATN in the hopes that the target will let go of the bus\n\t\t *\tand go to the mesgout phase.  If this fails, we'll\n\t\t *\tget another timeout 2 seconds later which will attempt\n\t\t *\ta bus reset.\n\t\t *\n\t\t *   Target transaction:\n\t\t *\tTransition to BUS FREE and report the error.\n\t\t *\tIt's good to be the target!\n\t\t */\n\t\tu_int active_scb_index;\n\n\t\tactive_scb_index = ahc_inb(ahc, SCB_TAG);\n\n\t\tif (last_phase != P_BUSFREE \n\t\t  && (active_scb_index < ahc->scb_data->numscbs)) {\n\t\t\tstruct scb *active_scb;\n\n\t\t\t/*\n\t\t\t * If the active SCB is not from our device,\n\t\t\t * assume that another device is hogging the bus\n\t\t\t * and wait for it's timeout to expire before\n\t\t\t * taking additional action.\n\t\t\t */ \n\t\t\tactive_scb = &ahc->scb_data->scbarray[active_scb_index];\n\t\t\tif (active_scb->hscb->tcl != scb->hscb->tcl) {\n\t\t\t\tu_int\tnewtimeout;\n\n\t\t\t\tsc_print_addr(scb->xs->sc_link);\n\t\t\t\tprintf(\"Other SCB Timeout%s\",\n\t\t\t \t       (scb->flags & SCB_OTHERTCL_TIMEOUT) != 0\n\t\t\t\t       ? \" again\\n\" : \"\\n\");\n\t\t\t\tscb->flags |= SCB_OTHERTCL_TIMEOUT;\n\t\t\t\tnewtimeout = MAX(active_scb->xs->timeout,\n\t\t\t\t\t\t scb->xs->timeout);\n\t\t\t\ttimeout(ahc_timeout, scb,\n\t\t\t\t\t    (newtimeout * hz) / 1000);\n\t\t\t\tsplx(s);\n\t\t\t\treturn;\n\t\t\t} \n\n\t\t\t/* It's us */\n\t\t\tif ((scb->hscb->control & TARGET_SCB) != 0) {\n\n\t\t\t\t/*\n\t\t\t\t * Send back any queued up transactions\n\t\t\t\t * and properly record the error condition.\n\t\t\t\t */\n\t\t\t\tahc_freeze_devq(ahc, scb->xs->sc_link);\n\t\t\t\tahcsetccbstatus(scb->xs, XS_TIMEOUT);\n\t\t\t\tahc_freeze_ccb(scb);\n\t\t\t\tahc_done(ahc, scb);\n\n\t\t\t\t/* Will clear us from the bus */\n\t\t\t\trestart_sequencer(ahc);\n\t\t\t\treturn;\n\t\t\t} \n\n\t\t\tahc_set_recoveryscb(ahc, active_scb);\n\t\t\tahc_outb(ahc, MSG_OUT, MSG_BUS_DEV_RESET);\n\t\t\tahc_outb(ahc, SCSISIGO, last_phase|ATNO);\n\t\t\tsc_print_addr(active_scb->xs->sc_link);\n\t\t\tprintf(\"BDR message in message buffer\\n\");\n\t\t\tactive_scb->flags |=  SCB_DEVICE_RESET;\n\t\t\t    timeout(ahc_timeout, (caddr_t)active_scb, 2 * hz);\n\t\t\tunpause_sequencer(ahc);\n\t\t} else {\n\t\t\tint\t disconnected;\n\n\t\t\t/* XXX Shouldn't panic.  Just punt instead */\n\t\t\tif ((scb->hscb->control & TARGET_SCB) != 0)\n\t\t\t\tpanic(\"Timed-out target SCB but bus idle\");\n\n\t\t\tif (last_phase != P_BUSFREE\n\t\t\t && (ahc_inb(ahc, SSTAT0) & TARGET) != 0) {\n\t\t\t\t/* XXX What happened to the SCB? */\n\t\t\t\t/* Hung target selection.  Goto busfree */\n\t\t\t\tprintf(\"%s: Hung target selection\\n\",\n\t\t\t\t       ahc_name(ahc));\n\t\t\t\trestart_sequencer(ahc);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (ahc_search_qinfifo(ahc, target, channel, lun,\n\t\t\t\t\t       scb->hscb->tag, ROLE_INITIATOR,\n\t\t\t\t\t       /*status*/0, SEARCH_COUNT) > 0) {\n\t\t\t\tdisconnected = FALSE;\n\t\t\t} else {\n\t\t\t\tdisconnected = TRUE;\n\t\t\t}\n\n\t\t\tif (disconnected) {\n\t\t\t\tu_int active_scb;\n\n\t\t\t\tahc_set_recoveryscb(ahc, scb);\n\t\t\t\t/*\n\t\t\t\t * Simply set the MK_MESSAGE control bit.\n\t\t\t\t */\n\t\t\t\tscb->hscb->control |= MK_MESSAGE;\n\t\t\t\tscb->flags |= SCB_QUEUED_MSG\n\t\t\t\t\t   |  SCB_DEVICE_RESET;\n\n\t\t\t\t/*\n\t\t\t\t * Mark the cached copy of this SCB in the\n\t\t\t\t * disconnected list too, so that a reconnect\n\t\t\t\t * at this point causes a BDR or abort.\n\t\t\t\t */\n\t\t\t\tactive_scb = ahc_inb(ahc, SCBPTR);\n\t\t\t\tif (ahc_search_disc_list(ahc, target,\n\t\t\t\t\t\t\t channel, lun,\n\t\t\t\t\t\t\t scb->hscb->tag,\n\t\t\t\t\t\t\t /*stop_on_first*/TRUE,\n\t\t\t\t\t\t\t /*remove*/FALSE,\n\t\t\t\t\t\t\t /*save_state*/FALSE)) {\n\t\t\t\t\tu_int scb_control;\n\n\t\t\t\t\tscb_control = ahc_inb(ahc, SCB_CONTROL);\n\t\t\t\t\tscb_control |= MK_MESSAGE;\n\t\t\t\t\tahc_outb(ahc, SCB_CONTROL, scb_control);\n\t\t\t\t}\n\t\t\t\tahc_outb(ahc, SCBPTR, active_scb);\n\t\t\t\tahc_index_busy_tcl(ahc, scb->hscb->tcl,\n\t\t\t\t\t\t   /*unbusy*/TRUE);\n\n\t\t\t\t/*\n\t\t\t\t * Actually re-queue this SCB in case we can\n\t\t\t\t * select the device before it reconnects.\n\t\t\t\t * Clear out any entries in the QINFIFO first\n\t\t\t\t * so we are the next SCB for this target\n\t\t\t\t * to run.\n\t\t\t\t */\n\t\t\t\tahc_search_qinfifo(ahc, SCB_TARGET(scb),\n\t\t\t\t\t\t   channel, SCB_LUN(scb),\n\t\t\t\t\t\t   SCB_LIST_NULL,\n\t\t\t\t\t\t   ROLE_INITIATOR,\n\t\t\t\t\t\t   SCB_REQUEUE,\n\t\t\t\t\t\t   SEARCH_COMPLETE);\n\t\t\t\tsc_print_addr(scb->xs->sc_link);\n\t\t\t\tprintf(\"Queuing a BDR SCB\\n\");\n\t\t\t\tahc->qinfifo[ahc->qinfifonext++] =\n\t\t\t\t    scb->hscb->tag;\n\n\t\t\t\tbus_dmamap_sync(ahc->sc_dmat,\n\t\t\t\t    ahc->shared_data_dmamap,\n\t\t\t\t    BUS_DMASYNC_PREWRITE);\n\n\t\t\t\tif ((ahc->features & AHC_QUEUE_REGS) != 0) {\n\t\t\t\t\tahc_outb(ahc, HNSCB_QOFF,\n\t\t\t\t\t\t ahc->qinfifonext);\n\t\t\t\t} else {\n\t\t\t\t\tahc_outb(ahc, KERNEL_QINPOS,\n\t\t\t\t\t\t ahc->qinfifonext);\n\t\t\t\t}\n\t\t\t\ttimeout(ahc_timeout, (caddr_t)scb, 2 * hz);\n\t\t\t\tunpause_sequencer(ahc);\n\t\t\t} else {\n\t\t\t\t/* Go \"immediatly\" to the bus reset */\n\t\t\t\t/* This shouldn't happen */\n\t\t\t\tahc_set_recoveryscb(ahc, scb);\n\t\t\t\tsc_print_addr(scb->xs->sc_link);\n\t\t\t\tprintf(\"SCB %d: Immediate reset.  \"\n\t\t\t\t\t\"Flags = 0x%x\\n\", scb->hscb->tag,\n\t\t\t\t\tscb->flags);\n\t\t\t\tgoto bus_reset;\n\t\t\t}\n\t\t}\n\t}\n\tsplx(s);\n}"
  },
  {
    "function_name": "ahc_set_recoveryscb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "4746-4775",
    "snippet": "STATIC void\nahc_set_recoveryscb(ahc, scb)\n\tstruct ahc_softc *ahc;\n\tstruct scb *scb;\n{\n\n\tif ((scb->flags & SCB_RECOVERY_SCB) == 0) {\n\t\tstruct scb *scbp;\n\n\t\tscb->flags |= SCB_RECOVERY_SCB;\n\n\t\t/*\n\t\t * Take all queued, but not sent SCBs out of the equation.\n\t\t * Also ensure that no new CCBs are queued to us while we\n\t\t * try to fix this problem.\n\t\t */\n\t\tahc->queue_blocked = 1;\n\n\t\t/*\n\t\t * Go through all of our pending SCBs and remove\n\t\t * any scheduled timeouts for them.  We will reschedule\n\t\t * them after we've successfully fixed this problem.\n\t\t */\n\t\tscbp = ahc->pending_scbs.lh_first;\n\t\twhile (scbp != NULL) {\n\t\t\tuntimeout(ahc_timeout, scbp);\n\t\t\tscbp = scbp->pend_links.le_next;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define STATIC\tstatic",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
      "STATIC void",
      "STATIC void",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_done __P((struct ahc_softc *ahc, struct scb *scbp));",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_calc_residual __P((struct scb *scb));",
      "STATIC void",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
      "STATIC void",
      "STATIC void",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
      "STATIC void",
      "STATIC void",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "untimeout",
          "args": [
            "ahc_timeout",
            "scbp"
          ],
          "line": 4771
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_done __P((struct ahc_softc *ahc, struct scb *scbp));\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_calc_residual __P((struct scb *scb));\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_set_recoveryscb(ahc, scb)\n\tstruct ahc_softc *ahc;\n\tstruct scb *scb;\n{\n\n\tif ((scb->flags & SCB_RECOVERY_SCB) == 0) {\n\t\tstruct scb *scbp;\n\n\t\tscb->flags |= SCB_RECOVERY_SCB;\n\n\t\t/*\n\t\t * Take all queued, but not sent SCBs out of the equation.\n\t\t * Also ensure that no new CCBs are queued to us while we\n\t\t * try to fix this problem.\n\t\t */\n\t\tahc->queue_blocked = 1;\n\n\t\t/*\n\t\t * Go through all of our pending SCBs and remove\n\t\t * any scheduled timeouts for them.  We will reschedule\n\t\t * them after we've successfully fixed this problem.\n\t\t */\n\t\tscbp = ahc->pending_scbs.lh_first;\n\t\twhile (scbp != NULL) {\n\t\t\tuntimeout(ahc_timeout, scbp);\n\t\t\tscbp = scbp->pend_links.le_next;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "ahc_download_instr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "4637-4744",
    "snippet": "STATIC void\nahc_download_instr(ahc, instrptr, dconsts)\n\tstruct ahc_softc *ahc;\n\tint instrptr;\n\tu_int8_t *dconsts;\n{\n\tunion\tins_formats instr;\n\tstruct\tins_format1 *fmt1_ins;\n\tstruct\tins_format3 *fmt3_ins;\n\tu_int\topcode;\n\n\t/* Structure copy */\n\tinstr = *(union ins_formats*)&seqprog[instrptr * 4];\n\n\tfmt1_ins = &instr.format1;\n\tfmt3_ins = NULL;\n\n\t/* Pull the opcode */\n\topcode = instr.format1.opcode;\n\tswitch (opcode) {\n\tcase AIC_OP_JMP:\n\tcase AIC_OP_JC:\n\tcase AIC_OP_JNC:\n\tcase AIC_OP_CALL:\n\tcase AIC_OP_JNE:\n\tcase AIC_OP_JNZ:\n\tcase AIC_OP_JE:\n\tcase AIC_OP_JZ:\n\t{\n\t\tstruct patch *cur_patch;\n\t\tint address_offset;\n\t\tu_int address;\n\t\tint skip_addr;\n\t\tint i;\n\n\t\tfmt3_ins = &instr.format3;\n\t\taddress_offset = 0;\n\t\taddress = fmt3_ins->address;\n\t\tcur_patch = patches;\n\t\tskip_addr = 0;\n\n\t\tfor (i = 0; i < address;) {\n\n\t\t\tahc_check_patch(ahc, &cur_patch, i, &skip_addr);\n\n\t\t\tif (skip_addr > i) {\n\t\t\t\tint end_addr;\n\n\t\t\t\tend_addr = MIN(address, skip_addr);\n\t\t\t\taddress_offset += end_addr - i;\n\t\t\t\ti = skip_addr;\n\t\t\t} else {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\taddress -= address_offset;\n\t\tfmt3_ins->address = address;\n\t\t/* FALLTHROUGH */\n\t}\n\tcase AIC_OP_OR:\n\tcase AIC_OP_AND:\n\tcase AIC_OP_XOR:\n\tcase AIC_OP_ADD:\n\tcase AIC_OP_ADC:\n\tcase AIC_OP_BMOV:\n\t\tif (fmt1_ins->parity != 0) {\n\t\t\tfmt1_ins->immediate = dconsts[fmt1_ins->immediate];\n\t\t}\n\t\tfmt1_ins->parity = 0;\n\t\t/* FALLTHROUGH */\n\tcase AIC_OP_ROL:\n\t\tif ((ahc->features & AHC_ULTRA2) != 0) {\n\t\t\tint i, count;\n\n\t\t\t/* Calculate odd parity for the instruction */\n\t\t\tfor (i = 0, count = 0; i < 31; i++) {\n\t\t\t\tu_int32_t mask;\n\n\t\t\t\tmask = 0x01 << i;\n\t\t\t\tif ((instr.integer & mask) != 0)\n\t\t\t\t\tcount++;\n\t\t\t}\n\t\t\tif ((count & 0x01) == 0)\n\t\t\t\tinstr.format1.parity = 1;\n\t\t} else {\n\t\t\t/* Compress the instruction for older sequencers */\n\t\t\tif (fmt3_ins != NULL) {\n\t\t\t\tinstr.integer =\n\t\t\t\t\tfmt3_ins->immediate\n\t\t\t\t      | (fmt3_ins->source << 8)\n\t\t\t\t      | (fmt3_ins->address << 16)\n\t\t\t\t      |\t(fmt3_ins->opcode << 25);\n\t\t\t} else {\n\t\t\t\tinstr.integer =\n\t\t\t\t\tfmt1_ins->immediate\n\t\t\t\t      | (fmt1_ins->source << 8)\n\t\t\t\t      | (fmt1_ins->destination << 16)\n\t\t\t\t      |\t(fmt1_ins->ret << 24)\n\t\t\t\t      |\t(fmt1_ins->opcode << 25);\n\t\t\t}\n\t\t}\n\t\tahc_outsb(ahc, SEQRAM, instr.bytes, 4);\n\t\tbreak;\n\tdefault:\n\t\tpanic(\"Unknown opcode encountered in seq program\");\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define STATIC\tstatic",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC u_int",
      "STATIC void",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "STATIC int",
      "ahc_check_patch __P((struct ahc_softc *ahc,\n\t\t\t\t     struct patch **start_patch,\n\t\t\t\t     int start_instr, int *skip_addr));",
      "STATIC void",
      "ahc_download_instr __P((struct ahc_softc *ahc,\n\t\t\t\t\tint instrptr, u_int8_t *dconsts));",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC u_int",
      "STATIC void",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "STATIC u_int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"Unknown opcode encountered in seq program\""
          ],
          "line": 4741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outsb",
          "args": [
            "ahc",
            "SEQRAM",
            "instr.bytes",
            "4"
          ],
          "line": 4738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIN",
          "args": [
            "address",
            "skip_addr"
          ],
          "line": 4685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_check_patch",
          "args": [
            "ahc",
            "&cur_patch",
            "i",
            "&skip_addr"
          ],
          "line": 4680
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_check_patch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "4598-4635",
          "snippet": "STATIC int\nahc_check_patch(ahc, start_patch, start_instr,skip_addr)\n\tstruct ahc_softc *ahc;\n\tstruct patch **start_patch;\n\tint start_instr;\n\tint *skip_addr;\n{\n\tstruct\tpatch *cur_patch;\n\tstruct\tpatch *last_patch;\n\tint\tnum_patches;\n\n\tnum_patches = sizeof(patches)/sizeof(struct patch);\n\tlast_patch = &patches[num_patches];\n\tcur_patch = *start_patch;\n\n\twhile (cur_patch < last_patch && start_instr == cur_patch->begin) {\n\n\t\tif (cur_patch->patch_func(ahc) == 0) {\n\n\t\t\t/* Start rejecting code */\n\t\t\t*skip_addr = start_instr + cur_patch->skip_instr;\n\t\t\tcur_patch += cur_patch->skip_patch;\n\t\t} else {\n\t\t\t/* Accepted this patch.  Advance to the next\n\t\t\t * one and wait for our intruction pointer to\n\t\t\t * hit this point.\n\t\t\t */\n\t\t\tcur_patch++;\n\t\t}\n\t}\n\n\t*start_patch = cur_patch;\n\tif (start_instr < *skip_addr)\n\t\t/* Still skipping */\n\t\treturn (0);\n\n\treturn (1);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "ahc_poll __P((struct ahc_softc *ahc, int wait));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "ahc_check_patch __P((struct ahc_softc *ahc,\n\t\t\t\t     struct patch **start_patch,\n\t\t\t\t     int start_instr, int *skip_addr));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nahc_poll __P((struct ahc_softc *ahc, int wait));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nahc_check_patch __P((struct ahc_softc *ahc,\n\t\t\t\t     struct patch **start_patch,\n\t\t\t\t     int start_instr, int *skip_addr));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC int\nahc_check_patch(ahc, start_patch, start_instr,skip_addr)\n\tstruct ahc_softc *ahc;\n\tstruct patch **start_patch;\n\tint start_instr;\n\tint *skip_addr;\n{\n\tstruct\tpatch *cur_patch;\n\tstruct\tpatch *last_patch;\n\tint\tnum_patches;\n\n\tnum_patches = sizeof(patches)/sizeof(struct patch);\n\tlast_patch = &patches[num_patches];\n\tcur_patch = *start_patch;\n\n\twhile (cur_patch < last_patch && start_instr == cur_patch->begin) {\n\n\t\tif (cur_patch->patch_func(ahc) == 0) {\n\n\t\t\t/* Start rejecting code */\n\t\t\t*skip_addr = start_instr + cur_patch->skip_instr;\n\t\t\tcur_patch += cur_patch->skip_patch;\n\t\t} else {\n\t\t\t/* Accepted this patch.  Advance to the next\n\t\t\t * one and wait for our intruction pointer to\n\t\t\t * hit this point.\n\t\t\t */\n\t\t\tcur_patch++;\n\t\t}\n\t}\n\n\t*start_patch = cur_patch;\n\tif (start_instr < *skip_addr)\n\t\t/* Still skipping */\n\t\treturn (0);\n\n\treturn (1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nahc_check_patch __P((struct ahc_softc *ahc,\n\t\t\t\t     struct patch **start_patch,\n\t\t\t\t     int start_instr, int *skip_addr));\nSTATIC void;\nahc_download_instr __P((struct ahc_softc *ahc,\n\t\t\t\t\tint instrptr, u_int8_t *dconsts));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_download_instr(ahc, instrptr, dconsts)\n\tstruct ahc_softc *ahc;\n\tint instrptr;\n\tu_int8_t *dconsts;\n{\n\tunion\tins_formats instr;\n\tstruct\tins_format1 *fmt1_ins;\n\tstruct\tins_format3 *fmt3_ins;\n\tu_int\topcode;\n\n\t/* Structure copy */\n\tinstr = *(union ins_formats*)&seqprog[instrptr * 4];\n\n\tfmt1_ins = &instr.format1;\n\tfmt3_ins = NULL;\n\n\t/* Pull the opcode */\n\topcode = instr.format1.opcode;\n\tswitch (opcode) {\n\tcase AIC_OP_JMP:\n\tcase AIC_OP_JC:\n\tcase AIC_OP_JNC:\n\tcase AIC_OP_CALL:\n\tcase AIC_OP_JNE:\n\tcase AIC_OP_JNZ:\n\tcase AIC_OP_JE:\n\tcase AIC_OP_JZ:\n\t{\n\t\tstruct patch *cur_patch;\n\t\tint address_offset;\n\t\tu_int address;\n\t\tint skip_addr;\n\t\tint i;\n\n\t\tfmt3_ins = &instr.format3;\n\t\taddress_offset = 0;\n\t\taddress = fmt3_ins->address;\n\t\tcur_patch = patches;\n\t\tskip_addr = 0;\n\n\t\tfor (i = 0; i < address;) {\n\n\t\t\tahc_check_patch(ahc, &cur_patch, i, &skip_addr);\n\n\t\t\tif (skip_addr > i) {\n\t\t\t\tint end_addr;\n\n\t\t\t\tend_addr = MIN(address, skip_addr);\n\t\t\t\taddress_offset += end_addr - i;\n\t\t\t\ti = skip_addr;\n\t\t\t} else {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\taddress -= address_offset;\n\t\tfmt3_ins->address = address;\n\t\t/* FALLTHROUGH */\n\t}\n\tcase AIC_OP_OR:\n\tcase AIC_OP_AND:\n\tcase AIC_OP_XOR:\n\tcase AIC_OP_ADD:\n\tcase AIC_OP_ADC:\n\tcase AIC_OP_BMOV:\n\t\tif (fmt1_ins->parity != 0) {\n\t\t\tfmt1_ins->immediate = dconsts[fmt1_ins->immediate];\n\t\t}\n\t\tfmt1_ins->parity = 0;\n\t\t/* FALLTHROUGH */\n\tcase AIC_OP_ROL:\n\t\tif ((ahc->features & AHC_ULTRA2) != 0) {\n\t\t\tint i, count;\n\n\t\t\t/* Calculate odd parity for the instruction */\n\t\t\tfor (i = 0, count = 0; i < 31; i++) {\n\t\t\t\tu_int32_t mask;\n\n\t\t\t\tmask = 0x01 << i;\n\t\t\t\tif ((instr.integer & mask) != 0)\n\t\t\t\t\tcount++;\n\t\t\t}\n\t\t\tif ((count & 0x01) == 0)\n\t\t\t\tinstr.format1.parity = 1;\n\t\t} else {\n\t\t\t/* Compress the instruction for older sequencers */\n\t\t\tif (fmt3_ins != NULL) {\n\t\t\t\tinstr.integer =\n\t\t\t\t\tfmt3_ins->immediate\n\t\t\t\t      | (fmt3_ins->source << 8)\n\t\t\t\t      | (fmt3_ins->address << 16)\n\t\t\t\t      |\t(fmt3_ins->opcode << 25);\n\t\t\t} else {\n\t\t\t\tinstr.integer =\n\t\t\t\t\tfmt1_ins->immediate\n\t\t\t\t      | (fmt1_ins->source << 8)\n\t\t\t\t      | (fmt1_ins->destination << 16)\n\t\t\t\t      |\t(fmt1_ins->ret << 24)\n\t\t\t\t      |\t(fmt1_ins->opcode << 25);\n\t\t\t}\n\t\t}\n\t\tahc_outsb(ahc, SEQRAM, instr.bytes, 4);\n\t\tbreak;\n\tdefault:\n\t\tpanic(\"Unknown opcode encountered in seq program\");\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "ahc_check_patch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "4598-4635",
    "snippet": "STATIC int\nahc_check_patch(ahc, start_patch, start_instr,skip_addr)\n\tstruct ahc_softc *ahc;\n\tstruct patch **start_patch;\n\tint start_instr;\n\tint *skip_addr;\n{\n\tstruct\tpatch *cur_patch;\n\tstruct\tpatch *last_patch;\n\tint\tnum_patches;\n\n\tnum_patches = sizeof(patches)/sizeof(struct patch);\n\tlast_patch = &patches[num_patches];\n\tcur_patch = *start_patch;\n\n\twhile (cur_patch < last_patch && start_instr == cur_patch->begin) {\n\n\t\tif (cur_patch->patch_func(ahc) == 0) {\n\n\t\t\t/* Start rejecting code */\n\t\t\t*skip_addr = start_instr + cur_patch->skip_instr;\n\t\t\tcur_patch += cur_patch->skip_patch;\n\t\t} else {\n\t\t\t/* Accepted this patch.  Advance to the next\n\t\t\t * one and wait for our intruction pointer to\n\t\t\t * hit this point.\n\t\t\t */\n\t\t\tcur_patch++;\n\t\t}\n\t}\n\n\t*start_patch = cur_patch;\n\tif (start_instr < *skip_addr)\n\t\t/* Still skipping */\n\t\treturn (0);\n\n\treturn (1);\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define STATIC\tstatic",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "STATIC int",
      "ahc_poll __P((struct ahc_softc *ahc, int wait));",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "STATIC int",
      "ahc_check_patch __P((struct ahc_softc *ahc,\n\t\t\t\t     struct patch **start_patch,\n\t\t\t\t     int start_instr, int *skip_addr));",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cur_patch->patch_func",
          "args": [
            "ahc"
          ],
          "line": 4615
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nahc_poll __P((struct ahc_softc *ahc, int wait));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nahc_check_patch __P((struct ahc_softc *ahc,\n\t\t\t\t     struct patch **start_patch,\n\t\t\t\t     int start_instr, int *skip_addr));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC int\nahc_check_patch(ahc, start_patch, start_instr,skip_addr)\n\tstruct ahc_softc *ahc;\n\tstruct patch **start_patch;\n\tint start_instr;\n\tint *skip_addr;\n{\n\tstruct\tpatch *cur_patch;\n\tstruct\tpatch *last_patch;\n\tint\tnum_patches;\n\n\tnum_patches = sizeof(patches)/sizeof(struct patch);\n\tlast_patch = &patches[num_patches];\n\tcur_patch = *start_patch;\n\n\twhile (cur_patch < last_patch && start_instr == cur_patch->begin) {\n\n\t\tif (cur_patch->patch_func(ahc) == 0) {\n\n\t\t\t/* Start rejecting code */\n\t\t\t*skip_addr = start_instr + cur_patch->skip_instr;\n\t\t\tcur_patch += cur_patch->skip_patch;\n\t\t} else {\n\t\t\t/* Accepted this patch.  Advance to the next\n\t\t\t * one and wait for our intruction pointer to\n\t\t\t * hit this point.\n\t\t\t */\n\t\t\tcur_patch++;\n\t\t}\n\t}\n\n\t*start_patch = cur_patch;\n\tif (start_instr < *skip_addr)\n\t\t/* Still skipping */\n\t\treturn (0);\n\n\treturn (1);\n}"
  },
  {
    "function_name": "ahc_loadseq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "4557-4596",
    "snippet": "STATIC void\nahc_loadseq(ahc)\n\tstruct ahc_softc* ahc;\n{\n\tstruct patch *cur_patch;\n\tint i;\n\tint downloaded;\n\tint skip_addr;\n\tu_int8_t download_consts[4];\n\n\t/* Setup downloadable constant table */\n#if 0\n\t/* No downloaded constants are currently defined. */\n\tdownload_consts[TMODE_NUMCMDS] = ahc->num_targetcmds;\n#endif\n\n\tcur_patch = patches;\n\tdownloaded = 0;\n\tskip_addr = 0;\n\tahc_outb(ahc, SEQCTL, PERRORDIS|FAILDIS|FASTMODE|LOADRAM);\n\tahc_outb(ahc, SEQADDR0, 0);\n\tahc_outb(ahc, SEQADDR1, 0);\n\n\tfor (i = 0; i < sizeof(seqprog)/4; i++) {\n\t\tif (ahc_check_patch(ahc, &cur_patch, i, &skip_addr) == 0) {\n\t\t\t/*\n\t\t\t * Don't download this instruction as it\n\t\t\t * is in a patch that was removed.\n\t\t\t */\n                        continue;\n\t\t}\n\t\tahc_download_instr(ahc, i, download_consts);\n\t\tdownloaded++;\n\t}\n\tahc_outb(ahc, SEQCTL, PERRORDIS|FAILDIS|FASTMODE);\n\trestart_sequencer(ahc);\n\n\tif (bootverbose)\n\t\tprintf(\" %d instructions downloaded\\n\", downloaded);\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define STATIC\tstatic",
      "#define bootverbose\t0",
      "#define STATIC",
      "#define bootverbose\t1"
    ],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "STATIC int",
      "ahc_check_patch __P((struct ahc_softc *ahc,\n\t\t\t\t     struct patch **start_patch,\n\t\t\t\t     int start_instr, int *skip_addr));",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" %d instructions downloaded\\n\"",
            "downloaded"
          ],
          "line": 4595
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "restart_sequencer",
          "args": [
            "ahc"
          ],
          "line": 4592
        },
        "resolved": true,
        "details": {
          "function_name": "restart_sequencer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "467-495",
          "snippet": "STATIC void\nrestart_sequencer(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tu_int i;\n\n\tpause_sequencer(ahc);\n\n\t/*\n\t * Everytime we restart the sequencer, there\n\t * is the possiblitity that we have restarted\n\t * within a three instruction window where an\n\t * SCB has been marked free but has not made it\n\t * onto the free list.  Since SCSI events(bus reset,\n\t * unexpected bus free) will always freeze the\n\t * sequencer, we cannot close this window.  To\n\t * avoid losing an SCB, we reconsitute the free\n\t * list every time we restart the sequencer.\n\t */\n\tahc_outb(ahc, FREE_SCBH, SCB_LIST_NULL);\n\tfor (i = 0; i < ahc->scb_data->maxhscbs; i++) {\n\t\t\n\t\tahc_outb(ahc, SCBPTR, i);\n\t\tif (ahc_inb(ahc, SCB_TAG) == SCB_LIST_NULL)\n\t\t\tahc_add_curscb_to_free_list(ahc);\n\t}\n\tahc_outb(ahc, SEQCTL, FASTMODE|SEQRESET);\n\tunpause_sequencer(ahc);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "static __inline void pause_sequencer",
            "static __inline void unpause_sequencer",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nstatic __inline void pause_sequencer;\nstatic __inline void unpause_sequencer;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nrestart_sequencer(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tu_int i;\n\n\tpause_sequencer(ahc);\n\n\t/*\n\t * Everytime we restart the sequencer, there\n\t * is the possiblitity that we have restarted\n\t * within a three instruction window where an\n\t * SCB has been marked free but has not made it\n\t * onto the free list.  Since SCSI events(bus reset,\n\t * unexpected bus free) will always freeze the\n\t * sequencer, we cannot close this window.  To\n\t * avoid losing an SCB, we reconsitute the free\n\t * list every time we restart the sequencer.\n\t */\n\tahc_outb(ahc, FREE_SCBH, SCB_LIST_NULL);\n\tfor (i = 0; i < ahc->scb_data->maxhscbs; i++) {\n\t\t\n\t\tahc_outb(ahc, SCBPTR, i);\n\t\tif (ahc_inb(ahc, SCB_TAG) == SCB_LIST_NULL)\n\t\t\tahc_add_curscb_to_free_list(ahc);\n\t}\n\tahc_outb(ahc, SEQCTL, FASTMODE|SEQRESET);\n\tunpause_sequencer(ahc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SEQCTL",
            "PERRORDIS|FAILDIS|FASTMODE"
          ],
          "line": 4591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_download_instr",
          "args": [
            "ahc",
            "i",
            "download_consts"
          ],
          "line": 4588
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_download_instr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "4637-4744",
          "snippet": "STATIC void\nahc_download_instr(ahc, instrptr, dconsts)\n\tstruct ahc_softc *ahc;\n\tint instrptr;\n\tu_int8_t *dconsts;\n{\n\tunion\tins_formats instr;\n\tstruct\tins_format1 *fmt1_ins;\n\tstruct\tins_format3 *fmt3_ins;\n\tu_int\topcode;\n\n\t/* Structure copy */\n\tinstr = *(union ins_formats*)&seqprog[instrptr * 4];\n\n\tfmt1_ins = &instr.format1;\n\tfmt3_ins = NULL;\n\n\t/* Pull the opcode */\n\topcode = instr.format1.opcode;\n\tswitch (opcode) {\n\tcase AIC_OP_JMP:\n\tcase AIC_OP_JC:\n\tcase AIC_OP_JNC:\n\tcase AIC_OP_CALL:\n\tcase AIC_OP_JNE:\n\tcase AIC_OP_JNZ:\n\tcase AIC_OP_JE:\n\tcase AIC_OP_JZ:\n\t{\n\t\tstruct patch *cur_patch;\n\t\tint address_offset;\n\t\tu_int address;\n\t\tint skip_addr;\n\t\tint i;\n\n\t\tfmt3_ins = &instr.format3;\n\t\taddress_offset = 0;\n\t\taddress = fmt3_ins->address;\n\t\tcur_patch = patches;\n\t\tskip_addr = 0;\n\n\t\tfor (i = 0; i < address;) {\n\n\t\t\tahc_check_patch(ahc, &cur_patch, i, &skip_addr);\n\n\t\t\tif (skip_addr > i) {\n\t\t\t\tint end_addr;\n\n\t\t\t\tend_addr = MIN(address, skip_addr);\n\t\t\t\taddress_offset += end_addr - i;\n\t\t\t\ti = skip_addr;\n\t\t\t} else {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\taddress -= address_offset;\n\t\tfmt3_ins->address = address;\n\t\t/* FALLTHROUGH */\n\t}\n\tcase AIC_OP_OR:\n\tcase AIC_OP_AND:\n\tcase AIC_OP_XOR:\n\tcase AIC_OP_ADD:\n\tcase AIC_OP_ADC:\n\tcase AIC_OP_BMOV:\n\t\tif (fmt1_ins->parity != 0) {\n\t\t\tfmt1_ins->immediate = dconsts[fmt1_ins->immediate];\n\t\t}\n\t\tfmt1_ins->parity = 0;\n\t\t/* FALLTHROUGH */\n\tcase AIC_OP_ROL:\n\t\tif ((ahc->features & AHC_ULTRA2) != 0) {\n\t\t\tint i, count;\n\n\t\t\t/* Calculate odd parity for the instruction */\n\t\t\tfor (i = 0, count = 0; i < 31; i++) {\n\t\t\t\tu_int32_t mask;\n\n\t\t\t\tmask = 0x01 << i;\n\t\t\t\tif ((instr.integer & mask) != 0)\n\t\t\t\t\tcount++;\n\t\t\t}\n\t\t\tif ((count & 0x01) == 0)\n\t\t\t\tinstr.format1.parity = 1;\n\t\t} else {\n\t\t\t/* Compress the instruction for older sequencers */\n\t\t\tif (fmt3_ins != NULL) {\n\t\t\t\tinstr.integer =\n\t\t\t\t\tfmt3_ins->immediate\n\t\t\t\t      | (fmt3_ins->source << 8)\n\t\t\t\t      | (fmt3_ins->address << 16)\n\t\t\t\t      |\t(fmt3_ins->opcode << 25);\n\t\t\t} else {\n\t\t\t\tinstr.integer =\n\t\t\t\t\tfmt1_ins->immediate\n\t\t\t\t      | (fmt1_ins->source << 8)\n\t\t\t\t      | (fmt1_ins->destination << 16)\n\t\t\t\t      |\t(fmt1_ins->ret << 24)\n\t\t\t\t      |\t(fmt1_ins->opcode << 25);\n\t\t\t}\n\t\t}\n\t\tahc_outsb(ahc, SEQRAM, instr.bytes, 4);\n\t\tbreak;\n\tdefault:\n\t\tpanic(\"Unknown opcode encountered in seq program\");\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "ahc_check_patch __P((struct ahc_softc *ahc,\n\t\t\t\t     struct patch **start_patch,\n\t\t\t\t     int start_instr, int *skip_addr));",
            "STATIC void",
            "ahc_download_instr __P((struct ahc_softc *ahc,\n\t\t\t\t\tint instrptr, u_int8_t *dconsts));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nahc_check_patch __P((struct ahc_softc *ahc,\n\t\t\t\t     struct patch **start_patch,\n\t\t\t\t     int start_instr, int *skip_addr));\nSTATIC void;\nahc_download_instr __P((struct ahc_softc *ahc,\n\t\t\t\t\tint instrptr, u_int8_t *dconsts));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_download_instr(ahc, instrptr, dconsts)\n\tstruct ahc_softc *ahc;\n\tint instrptr;\n\tu_int8_t *dconsts;\n{\n\tunion\tins_formats instr;\n\tstruct\tins_format1 *fmt1_ins;\n\tstruct\tins_format3 *fmt3_ins;\n\tu_int\topcode;\n\n\t/* Structure copy */\n\tinstr = *(union ins_formats*)&seqprog[instrptr * 4];\n\n\tfmt1_ins = &instr.format1;\n\tfmt3_ins = NULL;\n\n\t/* Pull the opcode */\n\topcode = instr.format1.opcode;\n\tswitch (opcode) {\n\tcase AIC_OP_JMP:\n\tcase AIC_OP_JC:\n\tcase AIC_OP_JNC:\n\tcase AIC_OP_CALL:\n\tcase AIC_OP_JNE:\n\tcase AIC_OP_JNZ:\n\tcase AIC_OP_JE:\n\tcase AIC_OP_JZ:\n\t{\n\t\tstruct patch *cur_patch;\n\t\tint address_offset;\n\t\tu_int address;\n\t\tint skip_addr;\n\t\tint i;\n\n\t\tfmt3_ins = &instr.format3;\n\t\taddress_offset = 0;\n\t\taddress = fmt3_ins->address;\n\t\tcur_patch = patches;\n\t\tskip_addr = 0;\n\n\t\tfor (i = 0; i < address;) {\n\n\t\t\tahc_check_patch(ahc, &cur_patch, i, &skip_addr);\n\n\t\t\tif (skip_addr > i) {\n\t\t\t\tint end_addr;\n\n\t\t\t\tend_addr = MIN(address, skip_addr);\n\t\t\t\taddress_offset += end_addr - i;\n\t\t\t\ti = skip_addr;\n\t\t\t} else {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\taddress -= address_offset;\n\t\tfmt3_ins->address = address;\n\t\t/* FALLTHROUGH */\n\t}\n\tcase AIC_OP_OR:\n\tcase AIC_OP_AND:\n\tcase AIC_OP_XOR:\n\tcase AIC_OP_ADD:\n\tcase AIC_OP_ADC:\n\tcase AIC_OP_BMOV:\n\t\tif (fmt1_ins->parity != 0) {\n\t\t\tfmt1_ins->immediate = dconsts[fmt1_ins->immediate];\n\t\t}\n\t\tfmt1_ins->parity = 0;\n\t\t/* FALLTHROUGH */\n\tcase AIC_OP_ROL:\n\t\tif ((ahc->features & AHC_ULTRA2) != 0) {\n\t\t\tint i, count;\n\n\t\t\t/* Calculate odd parity for the instruction */\n\t\t\tfor (i = 0, count = 0; i < 31; i++) {\n\t\t\t\tu_int32_t mask;\n\n\t\t\t\tmask = 0x01 << i;\n\t\t\t\tif ((instr.integer & mask) != 0)\n\t\t\t\t\tcount++;\n\t\t\t}\n\t\t\tif ((count & 0x01) == 0)\n\t\t\t\tinstr.format1.parity = 1;\n\t\t} else {\n\t\t\t/* Compress the instruction for older sequencers */\n\t\t\tif (fmt3_ins != NULL) {\n\t\t\t\tinstr.integer =\n\t\t\t\t\tfmt3_ins->immediate\n\t\t\t\t      | (fmt3_ins->source << 8)\n\t\t\t\t      | (fmt3_ins->address << 16)\n\t\t\t\t      |\t(fmt3_ins->opcode << 25);\n\t\t\t} else {\n\t\t\t\tinstr.integer =\n\t\t\t\t\tfmt1_ins->immediate\n\t\t\t\t      | (fmt1_ins->source << 8)\n\t\t\t\t      | (fmt1_ins->destination << 16)\n\t\t\t\t      |\t(fmt1_ins->ret << 24)\n\t\t\t\t      |\t(fmt1_ins->opcode << 25);\n\t\t\t}\n\t\t}\n\t\tahc_outsb(ahc, SEQRAM, instr.bytes, 4);\n\t\tbreak;\n\tdefault:\n\t\tpanic(\"Unknown opcode encountered in seq program\");\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_check_patch",
          "args": [
            "ahc",
            "&cur_patch",
            "i",
            "&skip_addr"
          ],
          "line": 4581
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_check_patch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "4598-4635",
          "snippet": "STATIC int\nahc_check_patch(ahc, start_patch, start_instr,skip_addr)\n\tstruct ahc_softc *ahc;\n\tstruct patch **start_patch;\n\tint start_instr;\n\tint *skip_addr;\n{\n\tstruct\tpatch *cur_patch;\n\tstruct\tpatch *last_patch;\n\tint\tnum_patches;\n\n\tnum_patches = sizeof(patches)/sizeof(struct patch);\n\tlast_patch = &patches[num_patches];\n\tcur_patch = *start_patch;\n\n\twhile (cur_patch < last_patch && start_instr == cur_patch->begin) {\n\n\t\tif (cur_patch->patch_func(ahc) == 0) {\n\n\t\t\t/* Start rejecting code */\n\t\t\t*skip_addr = start_instr + cur_patch->skip_instr;\n\t\t\tcur_patch += cur_patch->skip_patch;\n\t\t} else {\n\t\t\t/* Accepted this patch.  Advance to the next\n\t\t\t * one and wait for our intruction pointer to\n\t\t\t * hit this point.\n\t\t\t */\n\t\t\tcur_patch++;\n\t\t}\n\t}\n\n\t*start_patch = cur_patch;\n\tif (start_instr < *skip_addr)\n\t\t/* Still skipping */\n\t\treturn (0);\n\n\treturn (1);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "ahc_poll __P((struct ahc_softc *ahc, int wait));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "ahc_check_patch __P((struct ahc_softc *ahc,\n\t\t\t\t     struct patch **start_patch,\n\t\t\t\t     int start_instr, int *skip_addr));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nahc_poll __P((struct ahc_softc *ahc, int wait));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nahc_check_patch __P((struct ahc_softc *ahc,\n\t\t\t\t     struct patch **start_patch,\n\t\t\t\t     int start_instr, int *skip_addr));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC int\nahc_check_patch(ahc, start_patch, start_instr,skip_addr)\n\tstruct ahc_softc *ahc;\n\tstruct patch **start_patch;\n\tint start_instr;\n\tint *skip_addr;\n{\n\tstruct\tpatch *cur_patch;\n\tstruct\tpatch *last_patch;\n\tint\tnum_patches;\n\n\tnum_patches = sizeof(patches)/sizeof(struct patch);\n\tlast_patch = &patches[num_patches];\n\tcur_patch = *start_patch;\n\n\twhile (cur_patch < last_patch && start_instr == cur_patch->begin) {\n\n\t\tif (cur_patch->patch_func(ahc) == 0) {\n\n\t\t\t/* Start rejecting code */\n\t\t\t*skip_addr = start_instr + cur_patch->skip_instr;\n\t\t\tcur_patch += cur_patch->skip_patch;\n\t\t} else {\n\t\t\t/* Accepted this patch.  Advance to the next\n\t\t\t * one and wait for our intruction pointer to\n\t\t\t * hit this point.\n\t\t\t */\n\t\t\tcur_patch++;\n\t\t}\n\t}\n\n\t*start_patch = cur_patch;\n\tif (start_instr < *skip_addr)\n\t\t/* Still skipping */\n\t\treturn (0);\n\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SEQADDR1",
            "0"
          ],
          "line": 4578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SEQADDR0",
            "0"
          ],
          "line": 4577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SEQCTL",
            "PERRORDIS|FAILDIS|FASTMODE|LOADRAM"
          ],
          "line": 4576
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define bootverbose\t0\n#define STATIC\n#define bootverbose\t1\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nahc_check_patch __P((struct ahc_softc *ahc,\n\t\t\t\t     struct patch **start_patch,\n\t\t\t\t     int start_instr, int *skip_addr));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_loadseq(ahc)\n\tstruct ahc_softc* ahc;\n{\n\tstruct patch *cur_patch;\n\tint i;\n\tint downloaded;\n\tint skip_addr;\n\tu_int8_t download_consts[4];\n\n\t/* Setup downloadable constant table */\n#if 0\n\t/* No downloaded constants are currently defined. */\n\tdownload_consts[TMODE_NUMCMDS] = ahc->num_targetcmds;\n#endif\n\n\tcur_patch = patches;\n\tdownloaded = 0;\n\tskip_addr = 0;\n\tahc_outb(ahc, SEQCTL, PERRORDIS|FAILDIS|FASTMODE|LOADRAM);\n\tahc_outb(ahc, SEQADDR0, 0);\n\tahc_outb(ahc, SEQADDR1, 0);\n\n\tfor (i = 0; i < sizeof(seqprog)/4; i++) {\n\t\tif (ahc_check_patch(ahc, &cur_patch, i, &skip_addr) == 0) {\n\t\t\t/*\n\t\t\t * Don't download this instruction as it\n\t\t\t * is in a patch that was removed.\n\t\t\t */\n                        continue;\n\t\t}\n\t\tahc_download_instr(ahc, i, download_consts);\n\t\tdownloaded++;\n\t}\n\tahc_outb(ahc, SEQCTL, PERRORDIS|FAILDIS|FASTMODE);\n\trestart_sequencer(ahc);\n\n\tif (bootverbose)\n\t\tprintf(\" %d instructions downloaded\\n\", downloaded);\n}"
  },
  {
    "function_name": "ahc_dumpseq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "4528-4554",
    "snippet": "STATIC void\nahc_dumpseq(ahc)\n\tstruct ahc_softc* ahc;\n{\n\tint i;\n\tint max_prog;\n\n\tif ((ahc->chip & AHC_BUS_MASK) < AHC_PCI)\n\t\tmax_prog = 448;\n\telse if ((ahc->features & AHC_ULTRA2) != 0)\n\t\tmax_prog = 768;\n\telse\n\t\tmax_prog = 512;\n\n\tahc_outb(ahc, SEQCTL, PERRORDIS|FAILDIS|FASTMODE|LOADRAM);\n\tahc_outb(ahc, SEQADDR0, 0);\n\tahc_outb(ahc, SEQADDR1, 0);\n\tfor (i = 0; i < max_prog; i++) {\n\t\tu_int8_t ins_bytes[4];\n\n\t\tahc_insb(ahc, SEQRAM, ins_bytes, 4);\n\t\tprintf(\"0x%08x\\n\", ins_bytes[0] << 24\n\t\t\t\t | ins_bytes[1] << 16\n\t\t\t\t | ins_bytes[2] << 8\n\t\t\t\t | ins_bytes[3]);\n\t}\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define STATIC\tstatic",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"0x%08x\\n\"",
            "ins_bytes[0] << 24\n\t\t\t\t | ins_bytes[1] << 16\n\t\t\t\t | ins_bytes[2] << 8\n\t\t\t\t | ins_bytes[3]"
          ],
          "line": 4549
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_insb",
          "args": [
            "ahc",
            "SEQRAM",
            "ins_bytes",
            "4"
          ],
          "line": 4548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SEQADDR1",
            "0"
          ],
          "line": 4544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SEQADDR0",
            "0"
          ],
          "line": 4543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SEQCTL",
            "PERRORDIS|FAILDIS|FASTMODE|LOADRAM"
          ],
          "line": 4542
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_dumpseq(ahc)\n\tstruct ahc_softc* ahc;\n{\n\tint i;\n\tint max_prog;\n\n\tif ((ahc->chip & AHC_BUS_MASK) < AHC_PCI)\n\t\tmax_prog = 448;\n\telse if ((ahc->features & AHC_ULTRA2) != 0)\n\t\tmax_prog = 768;\n\telse\n\t\tmax_prog = 512;\n\n\tahc_outb(ahc, SEQCTL, PERRORDIS|FAILDIS|FASTMODE|LOADRAM);\n\tahc_outb(ahc, SEQADDR0, 0);\n\tahc_outb(ahc, SEQADDR1, 0);\n\tfor (i = 0; i < max_prog; i++) {\n\t\tu_int8_t ins_bytes[4];\n\n\t\tahc_insb(ahc, SEQRAM, ins_bytes, 4);\n\t\tprintf(\"0x%08x\\n\", ins_bytes[0] << 24\n\t\t\t\t | ins_bytes[1] << 16\n\t\t\t\t | ins_bytes[2] << 8\n\t\t\t\t | ins_bytes[3]);\n\t}\n}"
  },
  {
    "function_name": "ahcallocscbs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "4452-4525",
    "snippet": "STATIC void\nahcallocscbs(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tstruct scb_data *scb_data;\n\tstruct scb *next_scb;\n\tstruct sg_map_node *sg_map;\n\tbus_addr_t physaddr;\n\tstruct ahc_dma_seg *segs;\n\tint newcount;\n\tint i;\n\tint dma_flags = 0;\n\n\tscb_data = ahc->scb_data;\n\tif (scb_data->numscbs >= AHC_SCB_MAX)\n\t\t/* Can't allocate any more */\n\t\treturn;\n\n\tnext_scb = &scb_data->scbarray[scb_data->numscbs];\n\n\tsg_map = malloc(sizeof(*sg_map), M_DEVBUF, M_NOWAIT);\n\n\tif (sg_map == NULL)\n\t\treturn;\n\tbzero(sg_map, sizeof(struct sg_map_node));\n\t\n\tif (ahc_createdmamem(ahc, PAGE_SIZE, &sg_map->sg_dmamap,\n\t    (caddr_t *)&sg_map->sg_vaddr, &sg_map->sg_physaddr,\n\t    &sg_map->sg_dmasegs, &sg_map->sg_nseg, \"SG space\") < 0) {\n\t\tfree(sg_map, M_DEVBUF);\n\t\treturn;\n\t}\n\t\n\tSLIST_INSERT_HEAD(&scb_data->sg_maps, sg_map, links);\n\n\tsegs = sg_map->sg_vaddr;\n\tphysaddr = sg_map->sg_physaddr;\n\n\tnewcount = (PAGE_SIZE / (AHC_NSEG * sizeof(struct ahc_dma_seg)));\n\n\tfor (i = 0; scb_data->numscbs < AHC_SCB_MAX && i < newcount; i++) {\n\t\tint error;\n\n\t\tnext_scb->sg_list = segs;\n\t\t/*\n\t\t * The sequencer always starts with the second entry.\n\t\t * The first entry is embedded in the scb.\n\t\t */\n\t\tnext_scb->sg_list_phys = physaddr + sizeof(struct ahc_dma_seg);\n\t\tnext_scb->flags = SCB_FREE;\n\t\t\n\t\t/* set up AHA-284x right. */\n\t\tdma_flags = ((ahc->chip & AHC_VL) !=0) ? \n\t\t\tBUS_DMA_NOWAIT|ISABUS_DMA_32BIT :\n\t\t\tBUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW;\n\t\t\n\t\terror = bus_dmamap_create(ahc->sc_dmat,\n\t\t\t\t AHC_MAXTRANSFER_SIZE, AHC_NSEG, MAXBSIZE, 0,\n\t\t\t\t dma_flags, &next_scb->dmamap);\n\t\tif (error !=0) \n\t\t\tbreak;\n\n\t\tnext_scb->hscb = &scb_data->hscbs[scb_data->numscbs];\n\t\tnext_scb->hscb->tag = ahc->scb_data->numscbs;\n\t\tnext_scb->hscb->cmdstore_busaddr = \n\t\t\tahc_hscb_busaddr(ahc, next_scb->hscb->tag) + \n\t\t\toffsetof(struct hardware_scb, cmdstore);\t\n\t\tSLIST_INSERT_HEAD(&ahc->scb_data->free_scbs, next_scb, links);\n\t\tsegs += AHC_NSEG;\n\t\tphysaddr += (AHC_NSEG * sizeof(struct ahc_dma_seg));\n\t\tnext_scb++;\n\t\tahc->scb_data->numscbs++;\n\t}\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define STATIC\tstatic",
      "#define STATIC",
      "#define ISABUS_DMA_32BIT\tBUS_DMA_BUS1"
    ],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
      "STATIC void",
      "STATIC void",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_calc_residual __P((struct scb *scb));",
      "STATIC void",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
      "STATIC void",
      "STATIC void",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
      "int    ahc_createdmamem",
      "STATIC void",
      "STATIC void",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SLIST_INSERT_HEAD",
          "args": [
            "&ahc->scb_data->free_scbs",
            "next_scb",
            "links"
          ],
          "line": 4519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_hscb_busaddr",
          "args": [
            "ahc",
            "next_scb->hscb->tag"
          ],
          "line": 4517
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_hscb_busaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "426-431",
          "snippet": "static __inline u_int32_t\nahc_hscb_busaddr(struct ahc_softc *ahc, u_int index)\n{\n\treturn (ahc->scb_data->hscb_busaddr\n\t\t+ (sizeof(struct hardware_scb) * index));\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC u_int",
            "STATIC struct",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC u_int",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC u_int;\nSTATIC struct;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC u_int;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nahc_clear_intstat __P((struct ahc_softc *ahc));\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nrestart_sequencer __P((struct ahc_softc *ahc));\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nstatic __inline u_int32_t\nahc_hscb_busaddr(struct ahc_softc *ahc, u_int index)\n{\n\treturn (ahc->scb_data->hscb_busaddr\n\t\t+ (sizeof(struct hardware_scb) * index));\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_dmamap_create",
          "args": [
            "ahc->sc_dmat",
            "AHC_MAXTRANSFER_SIZE",
            "AHC_NSEG",
            "MAXBSIZE",
            "0",
            "dma_flags",
            "&next_scb->dmamap"
          ],
          "line": 4508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SLIST_INSERT_HEAD",
          "args": [
            "&scb_data->sg_maps",
            "sg_map",
            "links"
          ],
          "line": 4485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "sg_map",
            "M_DEVBUF"
          ],
          "line": 4481
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_add_curscb_to_free_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "5319-5328",
          "snippet": "STATIC void\nahc_add_curscb_to_free_list(ahc)\n\tstruct ahc_softc *ahc;\n{\n\t/* Invalidate the tag so that ahc_find_scb doesn't think it's active */\n\tahc_outb(ahc, SCB_TAG, SCB_LIST_NULL);\n\n\tahc_outb(ahc, SCB_NEXT, ahc_inb(ahc, FREE_SCBH));\n\tahc_outb(ahc, FREE_SCBH, ahc_inb(ahc, SCBPTR));\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_add_curscb_to_free_list(ahc)\n\tstruct ahc_softc *ahc;\n{\n\t/* Invalidate the tag so that ahc_find_scb doesn't think it's active */\n\tahc_outb(ahc, SCB_TAG, SCB_LIST_NULL);\n\n\tahc_outb(ahc, SCB_NEXT, ahc_inb(ahc, FREE_SCBH));\n\tahc_outb(ahc, FREE_SCBH, ahc_inb(ahc, SCBPTR));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_createdmamem",
          "args": [
            "ahc",
            "PAGE_SIZE",
            "&sg_map->sg_dmamap",
            "(caddr_t *)&sg_map->sg_vaddr",
            "&sg_map->sg_physaddr",
            "&sg_map->sg_dmasegs",
            "&sg_map->sg_nseg",
            "\"SG space\""
          ],
          "line": 4478
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_createdmamem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "678-745",
          "snippet": "int\nahc_createdmamem(ahc, size, mapp, vaddr, baddr, seg, nseg, what)\n\tstruct ahc_softc *ahc;\n\tint size;\n\tbus_dmamap_t *mapp;\n\tcaddr_t *vaddr;\n\tbus_addr_t *baddr;\n\tbus_dma_segment_t *seg;\n\tint *nseg;\n\tconst char *what;\n{\n\tint error, level = 0;\n\tint dma_flags = BUS_DMA_NOWAIT;\n\tbus_dma_tag_t tag = ahc->sc_dmat;\n\tconst char *myname = ahc_name(ahc);\n\tif ((ahc->chip & AHC_VL) !=0)\n\t\tdma_flags |= ISABUS_DMA_32BIT;\n\t\n\tif ((error = bus_dmamem_alloc(tag, size, NBPG, 0,\n\t\t\tseg, 1, nseg, BUS_DMA_NOWAIT)) != 0) {\n\t\tprintf(\"%s: failed to allocate DMA mem for %s, error = %d\\n\",\n\t\t\tmyname, what, error);\n\t\tgoto out;\n\t}\n\tlevel++;\n\n\tif ((error = bus_dmamem_map(tag, seg, *nseg, size, vaddr,\n\t\t\tBUS_DMA_NOWAIT|BUS_DMA_COHERENT)) != 0) {\n\t\tprintf(\"%s: failed to map DMA mem for %s, error = %d\\n\",\n\t\t\tmyname, what, error);\n\t\tgoto out;\n\t}\n\tlevel++;\n\n\tif ((error = bus_dmamap_create(tag, size, 1, size, 0,\n\t\t\tdma_flags, mapp)) != 0) {\n\t\tprintf(\"%s: failed to create DMA map for %s, error = %d\\n\",\n\t\t\tmyname, what, error);\n\t\tgoto out;\n        }\n\tlevel++;\n\n\tif ((error = bus_dmamap_load(tag, *mapp, *vaddr, size, NULL,\n\t\t\tBUS_DMA_NOWAIT)) != 0) {\n\t\tprintf(\"%s: failed to load DMA map for %s, error = %d\\n\",\n\t\t\tmyname, what, error);\n\t\tgoto out;\n        }\n\n\t*baddr = (*mapp)->dm_segs[0].ds_addr;\n\treturn 0;\nout:\n\tswitch (level) {\n\tcase 3:\n\t\tbus_dmamap_destroy(tag, *mapp);\n\t\t/* FALLTHROUGH */\n\tcase 2:\n\t\tbus_dmamem_unmap(tag, *vaddr, size);\n\t\t/* FALLTHROUGH */\n\tcase 1:\n\t\tbus_dmamem_free(tag, seg, *nseg);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define ISABUS_DMA_32BIT\tBUS_DMA_BUS1"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "int    ahc_createdmamem",
            "ahc_freedmamem __P((bus_dma_tag_t tag, int size,\n\t\t\t\tbus_dmamap_t map, caddr_t vaddr,\n\t\t\t\tbus_dma_segment_t *seg, int nseg));",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define ISABUS_DMA_32BIT\tBUS_DMA_BUS1\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC struct;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nahc_loadseq __P((struct ahc_softc *ahc));\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nahc_clear_intstat __P((struct ahc_softc *ahc));\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nrestart_sequencer __P((struct ahc_softc *ahc));\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nint    ahc_createdmamem;\nahc_freedmamem __P((bus_dma_tag_t tag, int size,\n\t\t\t\tbus_dmamap_t map, caddr_t vaddr,\n\t\t\t\tbus_dma_segment_t *seg, int nseg));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nint\nahc_createdmamem(ahc, size, mapp, vaddr, baddr, seg, nseg, what)\n\tstruct ahc_softc *ahc;\n\tint size;\n\tbus_dmamap_t *mapp;\n\tcaddr_t *vaddr;\n\tbus_addr_t *baddr;\n\tbus_dma_segment_t *seg;\n\tint *nseg;\n\tconst char *what;\n{\n\tint error, level = 0;\n\tint dma_flags = BUS_DMA_NOWAIT;\n\tbus_dma_tag_t tag = ahc->sc_dmat;\n\tconst char *myname = ahc_name(ahc);\n\tif ((ahc->chip & AHC_VL) !=0)\n\t\tdma_flags |= ISABUS_DMA_32BIT;\n\t\n\tif ((error = bus_dmamem_alloc(tag, size, NBPG, 0,\n\t\t\tseg, 1, nseg, BUS_DMA_NOWAIT)) != 0) {\n\t\tprintf(\"%s: failed to allocate DMA mem for %s, error = %d\\n\",\n\t\t\tmyname, what, error);\n\t\tgoto out;\n\t}\n\tlevel++;\n\n\tif ((error = bus_dmamem_map(tag, seg, *nseg, size, vaddr,\n\t\t\tBUS_DMA_NOWAIT|BUS_DMA_COHERENT)) != 0) {\n\t\tprintf(\"%s: failed to map DMA mem for %s, error = %d\\n\",\n\t\t\tmyname, what, error);\n\t\tgoto out;\n\t}\n\tlevel++;\n\n\tif ((error = bus_dmamap_create(tag, size, 1, size, 0,\n\t\t\tdma_flags, mapp)) != 0) {\n\t\tprintf(\"%s: failed to create DMA map for %s, error = %d\\n\",\n\t\t\tmyname, what, error);\n\t\tgoto out;\n        }\n\tlevel++;\n\n\tif ((error = bus_dmamap_load(tag, *mapp, *vaddr, size, NULL,\n\t\t\tBUS_DMA_NOWAIT)) != 0) {\n\t\tprintf(\"%s: failed to load DMA map for %s, error = %d\\n\",\n\t\t\tmyname, what, error);\n\t\tgoto out;\n        }\n\n\t*baddr = (*mapp)->dm_segs[0].ds_addr;\n\treturn 0;\nout:\n\tswitch (level) {\n\tcase 3:\n\t\tbus_dmamap_destroy(tag, *mapp);\n\t\t/* FALLTHROUGH */\n\tcase 2:\n\t\tbus_dmamem_unmap(tag, *vaddr, size);\n\t\t/* FALLTHROUGH */\n\tcase 1:\n\t\tbus_dmamem_free(tag, seg, *nseg);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "sg_map",
            "sizeof(struct sg_map_node)"
          ],
          "line": 4476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(*sg_map)",
            "M_DEVBUF",
            "M_NOWAIT"
          ],
          "line": 4472
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n#define ISABUS_DMA_32BIT\tBUS_DMA_BUS1\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_calc_residual __P((struct scb *scb));\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nint    ahc_createdmamem;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahcallocscbs(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tstruct scb_data *scb_data;\n\tstruct scb *next_scb;\n\tstruct sg_map_node *sg_map;\n\tbus_addr_t physaddr;\n\tstruct ahc_dma_seg *segs;\n\tint newcount;\n\tint i;\n\tint dma_flags = 0;\n\n\tscb_data = ahc->scb_data;\n\tif (scb_data->numscbs >= AHC_SCB_MAX)\n\t\t/* Can't allocate any more */\n\t\treturn;\n\n\tnext_scb = &scb_data->scbarray[scb_data->numscbs];\n\n\tsg_map = malloc(sizeof(*sg_map), M_DEVBUF, M_NOWAIT);\n\n\tif (sg_map == NULL)\n\t\treturn;\n\tbzero(sg_map, sizeof(struct sg_map_node));\n\t\n\tif (ahc_createdmamem(ahc, PAGE_SIZE, &sg_map->sg_dmamap,\n\t    (caddr_t *)&sg_map->sg_vaddr, &sg_map->sg_physaddr,\n\t    &sg_map->sg_dmasegs, &sg_map->sg_nseg, \"SG space\") < 0) {\n\t\tfree(sg_map, M_DEVBUF);\n\t\treturn;\n\t}\n\t\n\tSLIST_INSERT_HEAD(&scb_data->sg_maps, sg_map, links);\n\n\tsegs = sg_map->sg_vaddr;\n\tphysaddr = sg_map->sg_physaddr;\n\n\tnewcount = (PAGE_SIZE / (AHC_NSEG * sizeof(struct ahc_dma_seg)));\n\n\tfor (i = 0; scb_data->numscbs < AHC_SCB_MAX && i < newcount; i++) {\n\t\tint error;\n\n\t\tnext_scb->sg_list = segs;\n\t\t/*\n\t\t * The sequencer always starts with the second entry.\n\t\t * The first entry is embedded in the scb.\n\t\t */\n\t\tnext_scb->sg_list_phys = physaddr + sizeof(struct ahc_dma_seg);\n\t\tnext_scb->flags = SCB_FREE;\n\t\t\n\t\t/* set up AHA-284x right. */\n\t\tdma_flags = ((ahc->chip & AHC_VL) !=0) ? \n\t\t\tBUS_DMA_NOWAIT|ISABUS_DMA_32BIT :\n\t\t\tBUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW;\n\t\t\n\t\terror = bus_dmamap_create(ahc->sc_dmat,\n\t\t\t\t AHC_MAXTRANSFER_SIZE, AHC_NSEG, MAXBSIZE, 0,\n\t\t\t\t dma_flags, &next_scb->dmamap);\n\t\tif (error !=0) \n\t\t\tbreak;\n\n\t\tnext_scb->hscb = &scb_data->hscbs[scb_data->numscbs];\n\t\tnext_scb->hscb->tag = ahc->scb_data->numscbs;\n\t\tnext_scb->hscb->cmdstore_busaddr = \n\t\t\tahc_hscb_busaddr(ahc, next_scb->hscb->tag) + \n\t\t\toffsetof(struct hardware_scb, cmdstore);\t\n\t\tSLIST_INSERT_HEAD(&ahc->scb_data->free_scbs, next_scb, links);\n\t\tsegs += AHC_NSEG;\n\t\tphysaddr += (AHC_NSEG * sizeof(struct ahc_dma_seg));\n\t\tnext_scb++;\n\t\tahc->scb_data->numscbs++;\n\t}\n}"
  },
  {
    "function_name": "ahc_freeze_devq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "4434-4450",
    "snippet": "STATIC void\nahc_freeze_devq(ahc, sc_link)\n\tstruct ahc_softc *ahc;\n\tstruct scsi_link *sc_link;\n{\n\tint\ttarget;\n\tchar\tchannel;\n\tint\tlun;\n\n\ttarget = sc_link->target;\n\tlun = sc_link->lun;\n\tchannel = SIM_CHANNEL(ahc, sc_link);\n\t\n\tahc_search_qinfifo(ahc, target, channel, lun,\n\t\t\t   /*tag*/SCB_LIST_NULL, ROLE_UNKNOWN,\n\t\t\t   SCB_REQUEUE, SEARCH_COMPLETE);\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define STATIC\tstatic",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "ahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));",
      "STATIC void",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "char channel;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "char channel;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ahc_search_qinfifo",
          "args": [
            "ahc",
            "target",
            "channel",
            "lun",
            "/*tag*/SCB_LIST_NULL",
            "ROLE_UNKNOWN",
            "SCB_REQUEUE",
            "SEARCH_COMPLETE"
          ],
          "line": 4447
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_search_qinfifo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "5055-5121",
          "snippet": "STATIC int\nahc_search_qinfifo(ahc, target, channel, lun, tag, role, status, action)\n\tstruct ahc_softc *ahc;\n\tint target;\n\tchar channel;\n\tint lun;\n\tu_int tag;\n\trole_t role;\n\tu_int32_t status;\n\tahc_search_action action;\n{\n\tstruct\t scb *scbp;\n\tu_int8_t qinpos;\n\tu_int8_t qintail;\n\tint\t found;\n\n\tqinpos = ahc_inb(ahc, QINPOS);\n\tqintail = ahc->qinfifonext;\n\tfound = 0;\n\n\t/*\n\t * Start with an empty queue.  Entries that are not chosen\n\t * for removal will be re-added to the queue as we go.\n\t */\n\tahc->qinfifonext = qinpos;\n\tbus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, \n\t\t\tBUS_DMASYNC_POSTREAD);\n\n\twhile (qinpos != qintail) {\n\t\tscbp = &ahc->scb_data->scbarray[ahc->qinfifo[qinpos]];\n\t\tif (ahc_match_scb(scbp, target, channel, lun, tag, role)) {\n\t\t\t/*\n\t\t\t * We found an scb that needs to be removed.\n\t\t\t */\n\t\t\tswitch (action) {\n\t\t\tcase SEARCH_COMPLETE:\n\t\t\t\tif (!(scbp->xs->flags & ITSDONE)) {\n\t\t\t\t\tscbp->flags |= status;\n\t\t\t\t\tscbp->xs->error = XS_NOERROR;\n\t\t\t\t}\n\t\t\t\tahc_freeze_ccb(scbp);\n\t\t\t\tahc_done(ahc, scbp);\n\t\t\t\tbreak;\n\t\t\tcase SEARCH_COUNT:\n\t\t\t\tahc->qinfifo[ahc->qinfifonext++] =\n\t\t\t\t    scbp->hscb->tag;\n\t\t\t\tbreak;\n\t\t\tcase SEARCH_REMOVE:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfound++;\n\t\t} else {\n\t\t\tahc->qinfifo[ahc->qinfifonext++] = scbp->hscb->tag;\n\t\t}\n\t\tqinpos++;\n\t}\n\tbus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, \n\t\t\tBUS_DMASYNC_PREWRITE);\n\t\n\tif ((ahc->features & AHC_QUEUE_REGS) != 0) {\n\t\tahc_outb(ahc, HNSCB_QOFF, ahc->qinfifonext);\n\t} else {\n\t\tahc_outb(ahc, KERNEL_QINPOS, ahc->qinfifonext);\n\t}\n\n\treturn (found);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "ahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));",
            "STATIC u_int",
            "STATIC void",
            "ahc_done __P((struct ahc_softc *ahc, struct scb *scbp));",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "ahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));",
            "STATIC int",
            "ahc_search_qinfifo __P((struct ahc_softc *ahc, int target,\n\t\t\t\t\tchar channel, int lun, u_int tag,\n\t\t\t\t\trole_t role, u_int32_t status,\n\t\t\t\t\tahc_search_action action));",
            "STATIC int",
            "STATIC int",
            "ahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
            "STATIC void",
            "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_calc_residual __P((struct scb *scb));",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "static __inline void ahc_freeze_ccb",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *xs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));\nSTATIC u_int;\nSTATIC void;\nahc_done __P((struct ahc_softc *ahc, struct scb *scbp));\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));\nSTATIC int;\nahc_search_qinfifo __P((struct ahc_softc *ahc, int target,\n\t\t\t\t\tchar channel, int lun, u_int tag,\n\t\t\t\t\trole_t role, u_int32_t status,\n\t\t\t\t\tahc_search_action action));\nSTATIC int;\nSTATIC int;\nahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nSTATIC void;\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_calc_residual __P((struct scb *scb));\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nstatic __inline void ahc_freeze_ccb;\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n\nSTATIC int\nahc_search_qinfifo(ahc, target, channel, lun, tag, role, status, action)\n\tstruct ahc_softc *ahc;\n\tint target;\n\tchar channel;\n\tint lun;\n\tu_int tag;\n\trole_t role;\n\tu_int32_t status;\n\tahc_search_action action;\n{\n\tstruct\t scb *scbp;\n\tu_int8_t qinpos;\n\tu_int8_t qintail;\n\tint\t found;\n\n\tqinpos = ahc_inb(ahc, QINPOS);\n\tqintail = ahc->qinfifonext;\n\tfound = 0;\n\n\t/*\n\t * Start with an empty queue.  Entries that are not chosen\n\t * for removal will be re-added to the queue as we go.\n\t */\n\tahc->qinfifonext = qinpos;\n\tbus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, \n\t\t\tBUS_DMASYNC_POSTREAD);\n\n\twhile (qinpos != qintail) {\n\t\tscbp = &ahc->scb_data->scbarray[ahc->qinfifo[qinpos]];\n\t\tif (ahc_match_scb(scbp, target, channel, lun, tag, role)) {\n\t\t\t/*\n\t\t\t * We found an scb that needs to be removed.\n\t\t\t */\n\t\t\tswitch (action) {\n\t\t\tcase SEARCH_COMPLETE:\n\t\t\t\tif (!(scbp->xs->flags & ITSDONE)) {\n\t\t\t\t\tscbp->flags |= status;\n\t\t\t\t\tscbp->xs->error = XS_NOERROR;\n\t\t\t\t}\n\t\t\t\tahc_freeze_ccb(scbp);\n\t\t\t\tahc_done(ahc, scbp);\n\t\t\t\tbreak;\n\t\t\tcase SEARCH_COUNT:\n\t\t\t\tahc->qinfifo[ahc->qinfifonext++] =\n\t\t\t\t    scbp->hscb->tag;\n\t\t\t\tbreak;\n\t\t\tcase SEARCH_REMOVE:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfound++;\n\t\t} else {\n\t\t\tahc->qinfifo[ahc->qinfifonext++] = scbp->hscb->tag;\n\t\t}\n\t\tqinpos++;\n\t}\n\tbus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, \n\t\t\tBUS_DMASYNC_PREWRITE);\n\t\n\tif ((ahc->features & AHC_QUEUE_REGS) != 0) {\n\t\tahc_outb(ahc, HNSCB_QOFF, ahc->qinfifonext);\n\t} else {\n\t\tahc_outb(ahc, KERNEL_QINPOS, ahc->qinfifonext);\n\t}\n\n\treturn (found);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIM_CHANNEL",
          "args": [
            "ahc",
            "sc_link"
          ],
          "line": 4445
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_freeze_devq(ahc, sc_link)\n\tstruct ahc_softc *ahc;\n\tstruct scsi_link *sc_link;\n{\n\tint\ttarget;\n\tchar\tchannel;\n\tint\tlun;\n\n\ttarget = sc_link->target;\n\tlun = sc_link->lun;\n\tchannel = SIM_CHANNEL(ahc, sc_link);\n\t\n\tahc_search_qinfifo(ahc, target, channel, lun,\n\t\t\t   /*tag*/SCB_LIST_NULL, ROLE_UNKNOWN,\n\t\t\t   SCB_REQUEUE, SEARCH_COMPLETE);\n}"
  },
  {
    "function_name": "ahc_setup_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "4396-4432",
    "snippet": "STATIC int\nahc_setup_data(ahc, xs, scb)\n\tstruct ahc_softc *ahc;\n\tstruct scsi_xfer *xs;\n\tstruct scb *scb;\n{\n\tstruct hardware_scb *hscb;\n\t\n\thscb = scb->hscb;\n\txs->resid = xs->status = 0;\n\t\n\thscb->cmdlen = xs->cmdlen;\n\tbcopy(xs->cmd, hscb->cmdstore, xs->cmdlen);\n\thscb->cmdpointer = hscb->cmdstore_busaddr;\n\n\t/* Only use S/G if there is a transfer */\n\tif (xs->datalen) {\n\t\tint error;\n\n\t\terror = bus_dmamap_load(ahc->sc_dmat,\n\t\t\t    scb->dmamap, xs->data,\n\t\t\t    xs->datalen, NULL,\n\t\t\t    (xs->flags & SCSI_NOSLEEP) ?\n\t\t\t    BUS_DMA_NOWAIT : BUS_DMA_WAITOK);\n\t\tif (error) {\n\t\t\tif (!ahc_istagged_device(ahc, xs))\n\t\t\t\tahc_index_busy_tcl(ahc, hscb->tcl, TRUE);\n\t\t\treturn (TRY_AGAIN_LATER);\t/* XXX fvdl */\n\t\t}\n\t\terror = ahc_execute_scb(scb,\n\t\t    scb->dmamap->dm_segs,\n\t\t    scb->dmamap->dm_nsegs);\n\t\treturn error;\n\t} else {\n\t\treturn ahc_execute_scb(scb, NULL, 0);\n\t}\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define STATIC\tstatic",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
      "STATIC void",
      "STATIC void",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "ahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));",
      "STATIC int",
      "STATIC void",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
      "STATIC void",
      "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_calc_residual __P((struct scb *scb));",
      "STATIC void",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
      "STATIC void",
      "STATIC void",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "static __inline u_int ahc_index_busy_tcl",
      "STATIC void",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
      "STATIC void",
      "STATIC void",
      "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *xs;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ahc_execute_scb",
          "args": [
            "scb",
            "NULL",
            "0"
          ],
          "line": 4430
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_execute_scb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "4237-4374",
          "snippet": "STATIC int\nahc_execute_scb(arg, dm_segs, nsegments)\n\tvoid *arg;\n\tbus_dma_segment_t *dm_segs;\n\tint nsegments;\n{\n\tstruct\t scb *scb;\n\tstruct scsi_xfer *xs;\n\tstruct\t ahc_softc *ahc;\n\tint\t s;\n\n\tscb = (struct scb *)arg;\n\txs = scb->xs;\n\tahc = (struct ahc_softc *)xs->sc_link->adapter_softc;\n\n\n\tif (nsegments != 0) {\n\t\tstruct\t  ahc_dma_seg *sg;\n\t\tbus_dma_segment_t *end_seg;\n\t\tbus_dmasync_op_t op;\n\n\t\tend_seg = dm_segs + nsegments;\n\n\t\t/* Copy the first SG into the data pointer area */\n\t\tscb->hscb->data = dm_segs->ds_addr;\n\t\tscb->hscb->datalen = dm_segs->ds_len;\n\n\t\t/* Copy the segments into our SG list */\n\t\tsg = scb->sg_list;\n\t\twhile (dm_segs < end_seg) {\n\t\t\tsg->addr = dm_segs->ds_addr;\n\t\t\tsg->len = dm_segs->ds_len;\n\t\t\tsg++;\n\t\t\tdm_segs++;\n\t\t}\n\n\t\t/* Note where to find the SG entries in bus space */\n\t\tscb->hscb->SG_pointer = scb->sg_list_phys;\n\t\tif ((scb->xs->flags & SCSI_DATA_IN) != 0)\n\t\t\top = BUS_DMASYNC_PREREAD;\n\t\telse\n\t\t\top = BUS_DMASYNC_PREWRITE;\n\t\tbus_dmamap_sync(ahc->sc_dmat, scb->dmamap, op);\n\t} else {\n\t\tscb->hscb->SG_pointer = 0;\n\t\tscb->hscb->data = 0;\n\t\tscb->hscb->datalen = 0;\n\t}\n\t\n\tscb->sg_count = scb->hscb->SG_count = nsegments;\n\n\ts = splbio();\n\n\t/*\n\t * Last time we need to check if this SCB needs to\n\t * be aborted.\n\t */\n\tif (xs->flags & ITSDONE) {\n\t\tif (!ahc_istagged_device(ahc, xs))\n\t\t\tahc_index_busy_tcl(ahc, scb->hscb->tcl, TRUE);\n\t\tif (nsegments != 0)\n\t\t\tbus_dmamap_unload(ahc->sc_dmat, scb->dmamap);\n\t\tahcfreescb(ahc, scb);\n\t\tsplx(s);\n\t\treturn (COMPLETE);\n\t}\n\n#ifdef DIAGNOSTIC\n\tif (scb->sg_count > 255)\n\t\tpanic(\"ahc bad sg_count\");\n#endif\n\t\t\n\tLIST_INSERT_HEAD(&ahc->pending_scbs, scb, pend_links);\n\n\tscb->flags |= SCB_ACTIVE;\n\n\tif (!(xs->flags & SCSI_POLL))\n\ttimeout(ahc_timeout, (caddr_t)scb, \n\t\t    (xs->timeout * hz) / 1000);\n\n\tif ((scb->flags & SCB_TARGET_IMMEDIATE) != 0) {\n#if 0\n\t\tprintf(\"Continueing Immediate Command %d:%d\\n\",\n\t\t       xs->sc_link->target,\n\t\t       xs->sc_link->lun);\n#endif\n\t\tpause_sequencer(ahc);\n\t\tif ((ahc->flags & AHC_PAGESCBS) == 0)\n\t\t\tahc_outb(ahc, SCBPTR, scb->hscb->tag);\n\t\tahc_outb(ahc, SCB_TAG, scb->hscb->tag);\n\t\tahc_outb(ahc, RETURN_1, CONT_MSG_LOOP);\n\t\tunpause_sequencer(ahc);\n\t} else {\n\n\t\tahc->qinfifo[ahc->qinfifonext++] = scb->hscb->tag;\n\n\t\tbus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, \n\t\t\t\tBUS_DMASYNC_PREWRITE);\n\t\t\n\t\tif ((ahc->features & AHC_QUEUE_REGS) != 0) {\n\t\t\tahc_outb(ahc, HNSCB_QOFF, ahc->qinfifonext);\n\t\t} else {\n\t\t\tpause_sequencer(ahc);\n\t\t\tahc_outb(ahc, KERNEL_QINPOS, ahc->qinfifonext);\n\t\t\tunpause_sequencer(ahc);\n\t\t}\n\t}\n\n#ifdef AHC_DEBUG\n\tif (ahc_debug & AHC_SHOWCMDS) {\n\t\tsc_print_addr(xs->sc_link);\n\t\tprintf(\"opcode %d tag %x len %d flags %x control %x fpos %u\"\n\t\t    \" rate %x\\n\",\n\t\t    xs->cmdstore.opcode, scb->hscb->tag, scb->hscb->datalen,\n\t\t    scb->flags, scb->hscb->control, ahc->qinfifonext,\n\t\t    scb->hscb->scsirate);\n\t}\n#endif\n\n\tif (!(xs->flags & SCSI_POLL)) {\n\t\tsplx(s);\n\t\treturn (SUCCESSFULLY_QUEUED);\n\t}\n\t/*\n\t * If we can't use interrupts, poll for completion\n\t */\n\tSC_DEBUG(xs->sc_link, SDEV_DB3, (\"cmd_poll\\n\"));\n\tdo {\n\t\tif (ahc_poll(ahc, xs->timeout)) {\n\t\t\tif (!(xs->flags & SCSI_SILENT))\n\t\t\t\tprintf(\"cmd fail\\n\");\n\t\t\tahc_timeout(scb);\n\t\t\tbreak;\n\t\t}\n\t} while (!(xs->flags & ITSDONE));\n\tsplx(s);\n\treturn (COMPLETE);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "ahc_shutdown __P((void *arg));",
            "STATIC int",
            "ahc_execute_scb __P((void *arg, bus_dma_segment_t *dm_segs,\n\t\t\t\t     int nsegments));",
            "STATIC int",
            "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
            "STATIC void",
            "ahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
            "STATIC void",
            "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_calc_residual __P((struct scb *scb));",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
            "STATIC void",
            "static __inline void pause_sequencer",
            "static __inline void unpause_sequencer",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "static __inline u_int ahc_index_busy_tcl",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *xs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nahc_shutdown __P((void *arg));\nSTATIC int;\nahc_execute_scb __P((void *arg, bus_dma_segment_t *dm_segs,\n\t\t\t\t     int nsegments));\nSTATIC int;\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nSTATIC void;\nahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nSTATIC void;\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_calc_residual __P((struct scb *scb));\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nSTATIC void;\nstatic __inline void pause_sequencer;\nstatic __inline void unpause_sequencer;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nstatic __inline u_int ahc_index_busy_tcl;\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n\nSTATIC int\nahc_execute_scb(arg, dm_segs, nsegments)\n\tvoid *arg;\n\tbus_dma_segment_t *dm_segs;\n\tint nsegments;\n{\n\tstruct\t scb *scb;\n\tstruct scsi_xfer *xs;\n\tstruct\t ahc_softc *ahc;\n\tint\t s;\n\n\tscb = (struct scb *)arg;\n\txs = scb->xs;\n\tahc = (struct ahc_softc *)xs->sc_link->adapter_softc;\n\n\n\tif (nsegments != 0) {\n\t\tstruct\t  ahc_dma_seg *sg;\n\t\tbus_dma_segment_t *end_seg;\n\t\tbus_dmasync_op_t op;\n\n\t\tend_seg = dm_segs + nsegments;\n\n\t\t/* Copy the first SG into the data pointer area */\n\t\tscb->hscb->data = dm_segs->ds_addr;\n\t\tscb->hscb->datalen = dm_segs->ds_len;\n\n\t\t/* Copy the segments into our SG list */\n\t\tsg = scb->sg_list;\n\t\twhile (dm_segs < end_seg) {\n\t\t\tsg->addr = dm_segs->ds_addr;\n\t\t\tsg->len = dm_segs->ds_len;\n\t\t\tsg++;\n\t\t\tdm_segs++;\n\t\t}\n\n\t\t/* Note where to find the SG entries in bus space */\n\t\tscb->hscb->SG_pointer = scb->sg_list_phys;\n\t\tif ((scb->xs->flags & SCSI_DATA_IN) != 0)\n\t\t\top = BUS_DMASYNC_PREREAD;\n\t\telse\n\t\t\top = BUS_DMASYNC_PREWRITE;\n\t\tbus_dmamap_sync(ahc->sc_dmat, scb->dmamap, op);\n\t} else {\n\t\tscb->hscb->SG_pointer = 0;\n\t\tscb->hscb->data = 0;\n\t\tscb->hscb->datalen = 0;\n\t}\n\t\n\tscb->sg_count = scb->hscb->SG_count = nsegments;\n\n\ts = splbio();\n\n\t/*\n\t * Last time we need to check if this SCB needs to\n\t * be aborted.\n\t */\n\tif (xs->flags & ITSDONE) {\n\t\tif (!ahc_istagged_device(ahc, xs))\n\t\t\tahc_index_busy_tcl(ahc, scb->hscb->tcl, TRUE);\n\t\tif (nsegments != 0)\n\t\t\tbus_dmamap_unload(ahc->sc_dmat, scb->dmamap);\n\t\tahcfreescb(ahc, scb);\n\t\tsplx(s);\n\t\treturn (COMPLETE);\n\t}\n\n#ifdef DIAGNOSTIC\n\tif (scb->sg_count > 255)\n\t\tpanic(\"ahc bad sg_count\");\n#endif\n\t\t\n\tLIST_INSERT_HEAD(&ahc->pending_scbs, scb, pend_links);\n\n\tscb->flags |= SCB_ACTIVE;\n\n\tif (!(xs->flags & SCSI_POLL))\n\ttimeout(ahc_timeout, (caddr_t)scb, \n\t\t    (xs->timeout * hz) / 1000);\n\n\tif ((scb->flags & SCB_TARGET_IMMEDIATE) != 0) {\n#if 0\n\t\tprintf(\"Continueing Immediate Command %d:%d\\n\",\n\t\t       xs->sc_link->target,\n\t\t       xs->sc_link->lun);\n#endif\n\t\tpause_sequencer(ahc);\n\t\tif ((ahc->flags & AHC_PAGESCBS) == 0)\n\t\t\tahc_outb(ahc, SCBPTR, scb->hscb->tag);\n\t\tahc_outb(ahc, SCB_TAG, scb->hscb->tag);\n\t\tahc_outb(ahc, RETURN_1, CONT_MSG_LOOP);\n\t\tunpause_sequencer(ahc);\n\t} else {\n\n\t\tahc->qinfifo[ahc->qinfifonext++] = scb->hscb->tag;\n\n\t\tbus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, \n\t\t\t\tBUS_DMASYNC_PREWRITE);\n\t\t\n\t\tif ((ahc->features & AHC_QUEUE_REGS) != 0) {\n\t\t\tahc_outb(ahc, HNSCB_QOFF, ahc->qinfifonext);\n\t\t} else {\n\t\t\tpause_sequencer(ahc);\n\t\t\tahc_outb(ahc, KERNEL_QINPOS, ahc->qinfifonext);\n\t\t\tunpause_sequencer(ahc);\n\t\t}\n\t}\n\n#ifdef AHC_DEBUG\n\tif (ahc_debug & AHC_SHOWCMDS) {\n\t\tsc_print_addr(xs->sc_link);\n\t\tprintf(\"opcode %d tag %x len %d flags %x control %x fpos %u\"\n\t\t    \" rate %x\\n\",\n\t\t    xs->cmdstore.opcode, scb->hscb->tag, scb->hscb->datalen,\n\t\t    scb->flags, scb->hscb->control, ahc->qinfifonext,\n\t\t    scb->hscb->scsirate);\n\t}\n#endif\n\n\tif (!(xs->flags & SCSI_POLL)) {\n\t\tsplx(s);\n\t\treturn (SUCCESSFULLY_QUEUED);\n\t}\n\t/*\n\t * If we can't use interrupts, poll for completion\n\t */\n\tSC_DEBUG(xs->sc_link, SDEV_DB3, (\"cmd_poll\\n\"));\n\tdo {\n\t\tif (ahc_poll(ahc, xs->timeout)) {\n\t\t\tif (!(xs->flags & SCSI_SILENT))\n\t\t\t\tprintf(\"cmd fail\\n\");\n\t\t\tahc_timeout(scb);\n\t\t\tbreak;\n\t\t}\n\t} while (!(xs->flags & ITSDONE));\n\tsplx(s);\n\treturn (COMPLETE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_index_busy_tcl",
          "args": [
            "ahc",
            "hscb->tcl",
            "TRUE"
          ],
          "line": 4422
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_index_busy_tcl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "497-513",
          "snippet": "static __inline u_int\nahc_index_busy_tcl(ahc, tcl, unbusy)\n\tstruct ahc_softc *ahc;\n\tu_int tcl;\n\tint unbusy;\n{\n\tu_int scbid;\n\n\tscbid = ahc->untagged_scbs[tcl];\n\tif (unbusy) {\n\t\tahc->untagged_scbs[tcl] = SCB_LIST_NULL;\n\t\tbus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, \n\t\t\t\tBUS_DMASYNC_PREWRITE);\n\t}\n\n\treturn (scbid);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC u_int",
            "STATIC struct",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC u_int",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "static __inline u_int ahc_index_busy_tcl",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC u_int;\nSTATIC struct;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC u_int;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nahc_clear_intstat __P((struct ahc_softc *ahc));\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nrestart_sequencer __P((struct ahc_softc *ahc));\nstatic __inline u_int ahc_index_busy_tcl;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nstatic __inline u_int\nahc_index_busy_tcl(ahc, tcl, unbusy)\n\tstruct ahc_softc *ahc;\n\tu_int tcl;\n\tint unbusy;\n{\n\tu_int scbid;\n\n\tscbid = ahc->untagged_scbs[tcl];\n\tif (unbusy) {\n\t\tahc->untagged_scbs[tcl] = SCB_LIST_NULL;\n\t\tbus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, \n\t\t\t\tBUS_DMASYNC_PREWRITE);\n\t}\n\n\treturn (scbid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_istagged_device",
          "args": [
            "ahc",
            "xs"
          ],
          "line": 4421
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_istagged_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "5823-5842",
          "snippet": "STATIC int\nahc_istagged_device(ahc, xs)\nstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n{\n\tchar channel;\n\tu_int our_id, target;\n\tstruct tmode_tstate *tstate;\n\tstruct ahc_devinfo devinfo;\n\n\tchannel = SIM_CHANNEL(ahc, xs->sc_link);\n\tour_id = SIM_SCSI_ID(ahc, xs->sc_link);\n\ttarget = xs->sc_link->target;\n\t(void)ahc_fetch_transinfo(ahc, channel, our_id, target, &tstate);\n\n\tahc_compile_devinfo(&devinfo, our_id, target,\n\t    xs->sc_link->lun, channel, ROLE_INITIATOR);\n\n\treturn (tstate->tagenable & devinfo.target_mask);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "ahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC int",
            "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));",
            "STATIC int",
            "STATIC int",
            "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
            "STATIC void",
            "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "static __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "u_int our_id;",
            "struct tmode_tstate **tstate;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *xs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));\nSTATIC int;\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nSTATIC void;\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nu_int our_id;\nstruct tmode_tstate **tstate;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n\nSTATIC int\nahc_istagged_device(ahc, xs)\nstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n{\n\tchar channel;\n\tu_int our_id, target;\n\tstruct tmode_tstate *tstate;\n\tstruct ahc_devinfo devinfo;\n\n\tchannel = SIM_CHANNEL(ahc, xs->sc_link);\n\tour_id = SIM_SCSI_ID(ahc, xs->sc_link);\n\ttarget = xs->sc_link->target;\n\t(void)ahc_fetch_transinfo(ahc, channel, our_id, target, &tstate);\n\n\tahc_compile_devinfo(&devinfo, our_id, target,\n\t    xs->sc_link->lun, channel, ROLE_INITIATOR);\n\n\treturn (tstate->tagenable & devinfo.target_mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_dmamap_load",
          "args": [
            "ahc->sc_dmat",
            "scb->dmamap",
            "xs->data",
            "xs->datalen",
            "NULL",
            "(xs->flags & SCSI_NOSLEEP) ?\n\t\t\t    BUS_DMA_NOWAIT : BUS_DMA_WAITOK"
          ],
          "line": 4415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "xs->cmd",
            "hscb->cmdstore",
            "xs->cmdlen"
          ],
          "line": 4408
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));\nSTATIC int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nSTATIC void;\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_calc_residual __P((struct scb *scb));\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nstatic __inline u_int ahc_index_busy_tcl;\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n\nSTATIC int\nahc_setup_data(ahc, xs, scb)\n\tstruct ahc_softc *ahc;\n\tstruct scsi_xfer *xs;\n\tstruct scb *scb;\n{\n\tstruct hardware_scb *hscb;\n\t\n\thscb = scb->hscb;\n\txs->resid = xs->status = 0;\n\t\n\thscb->cmdlen = xs->cmdlen;\n\tbcopy(xs->cmd, hscb->cmdstore, xs->cmdlen);\n\thscb->cmdpointer = hscb->cmdstore_busaddr;\n\n\t/* Only use S/G if there is a transfer */\n\tif (xs->datalen) {\n\t\tint error;\n\n\t\terror = bus_dmamap_load(ahc->sc_dmat,\n\t\t\t    scb->dmamap, xs->data,\n\t\t\t    xs->datalen, NULL,\n\t\t\t    (xs->flags & SCSI_NOSLEEP) ?\n\t\t\t    BUS_DMA_NOWAIT : BUS_DMA_WAITOK);\n\t\tif (error) {\n\t\t\tif (!ahc_istagged_device(ahc, xs))\n\t\t\t\tahc_index_busy_tcl(ahc, hscb->tcl, TRUE);\n\t\t\treturn (TRY_AGAIN_LATER);\t/* XXX fvdl */\n\t\t}\n\t\terror = ahc_execute_scb(scb,\n\t\t    scb->dmamap->dm_segs,\n\t\t    scb->dmamap->dm_nsegs);\n\t\treturn error;\n\t} else {\n\t\treturn ahc_execute_scb(scb, NULL, 0);\n\t}\n}"
  },
  {
    "function_name": "ahc_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "4376-4394",
    "snippet": "STATIC int\nahc_poll(ahc, wait)\n\tstruct   ahc_softc *ahc;\n\tint   wait;\t/* in msec */\n{\n\twhile (--wait) {\n\t\tDELAY(1000);\n\t\tif (ahc_inb(ahc, INTSTAT) & INT_PEND)\n\t\t\tbreak;\n\t}\n\n\tif (wait == 0) {\n\t\tprintf(\"%s: board is not responding\\n\", ahc_name(ahc));\n\t\treturn (EIO);\n\t}\n\t\t\n\tahc_intr((void *)ahc);\n\treturn (0);\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define STATIC\tstatic",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "STATIC int",
      "ahc_poll __P((struct ahc_softc *ahc, int wait));",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ahc_intr",
          "args": [
            "(void *)ahc"
          ],
          "line": 4392
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "1591-1655",
          "snippet": "int\nahc_intr(void *arg)\n{\n\tstruct\tahc_softc *ahc;\n\tu_int\tintstat;\n\n\tahc = (struct ahc_softc *)arg; \n\n\tintstat = ahc_inb(ahc, INTSTAT);\n\n\t/*\n\t * Any interrupts to process?\n\t */\n\tif ((intstat & INT_PEND) == 0) {\n\t\tif (ahc->pci_intr_func && ahc->pci_intr_func(ahc)) {\n#ifdef AHC_DEBUG\n\t\t\tprintf(\"%s: bus intr: CCHADDR %x HADDR %x SEQADDR %x\\n\",\n\t\t\t    ahc_name(ahc),\n\t\t\t    ahc_inb(ahc, CCHADDR) |\n\t\t\t    (ahc_inb(ahc, CCHADDR+1) << 8)\n\t\t\t    | (ahc_inb(ahc, CCHADDR+2) << 16)\n\t\t\t    | (ahc_inb(ahc, CCHADDR+3) << 24),\n\t\t\t    ahc_inb(ahc, HADDR) | (ahc_inb(ahc, HADDR+1) << 8)\n\t\t\t    | (ahc_inb(ahc, HADDR+2) << 16)\n\t\t\t    | (ahc_inb(ahc, HADDR+3) << 24),\n\t\t\t    ahc_inb(ahc, SEQADDR0) |\n\t\t\t    (ahc_inb(ahc, SEQADDR1) << 8));\n#endif\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (intstat & CMDCMPLT) {\n\t\tahc_outb(ahc, CLRINT, CLRCMDINT);\n\t\tahc_run_qoutfifo(ahc);\n\t}\n\tif (intstat & BRKADRINT) {\n\t\t/*\n\t\t * We upset the sequencer :-(\n\t\t * Lookup the error message\n\t\t */\n\t\tint i, error, num_errors;\n\n\t\terror = ahc_inb(ahc, ERROR);\n\t\tnum_errors =  sizeof(hard_error)/sizeof(hard_error[0]);\n\t\tfor (i = 0; error != 1 && i < num_errors; i++)\n\t\t\terror >>= 1;\n\t\tpanic(\"%s: brkadrint, %s at seqaddr = 0x%x\\n\",\n\t\t      ahc_name(ahc), hard_error[i].errmesg,\n\t\t      ahc_inb(ahc, SEQADDR0) |\n\t\t      (ahc_inb(ahc, SEQADDR1) << 8));\n\n\t\t/* Tell everyone that this HBA is no longer availible */\n\t\tahc_abort_scbs(ahc, ALL_TARGETS, ALL_CHANNELS,\n\t\t\t       ALL_LUNS, SCB_LIST_NULL, ROLE_UNKNOWN,\n\t\t\t       XS_DRIVER_STUFFUP);\n\t}\n\tif (intstat & SEQINT)\n\t\tahc_handle_seqint(ahc, intstat);\n\n\tif (intstat & SCSIINT)\n\t\tahc_handle_scsiint(ahc, intstat);\n\treturn(1);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define ALL_CHANNELS '\\0'"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "ahc_shutdown __P((void *arg));",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC u_int",
            "STATIC struct",
            "ahc_handle_seqint __P((struct ahc_softc *ahc, u_int intstat));",
            "ahc_handle_scsiint __P((struct ahc_softc *ahc, u_int intstat));",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC u_int",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "static struct {\n        u_int8_t errno;\n\tchar *errmesg;\n} hard_error[] = {\n\t{ ILLHADDR,\t\"Illegal Host Access\" },\n\t{ ILLSADDR,\t\"Illegal Sequencer Address referrenced\" },\n\t{ ILLOPCODE,\t\"Illegal Opcode in sequencer program\" },\n\t{ SQPARERR,\t\"Sequencer Parity Error\" },\n\t{ DPARERR,\t\"Data-path Parity Error\" },\n\t{ MPARERR,\t\"Scratch or SCB Memory Parity Error\" },\n\t{ PCIERRSTAT,\t\"PCI Error detected\" },\n\t{ CIOPARERR,\t\"CIOBUS Parity Error\" },\n};",
            "static const int num_errors = sizeof(hard_error)/sizeof(hard_error[0]);",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define ALL_CHANNELS '\\0'\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nahc_shutdown __P((void *arg));\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC u_int;\nSTATIC struct;\nahc_handle_seqint __P((struct ahc_softc *ahc, u_int intstat));\nahc_handle_scsiint __P((struct ahc_softc *ahc, u_int intstat));\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC u_int;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nahc_clear_intstat __P((struct ahc_softc *ahc));\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nrestart_sequencer __P((struct ahc_softc *ahc));\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nstatic struct {\n        u_int8_t errno;\n\tchar *errmesg;\n} hard_error[] = {\n\t{ ILLHADDR,\t\"Illegal Host Access\" },\n\t{ ILLSADDR,\t\"Illegal Sequencer Address referrenced\" },\n\t{ ILLOPCODE,\t\"Illegal Opcode in sequencer program\" },\n\t{ SQPARERR,\t\"Sequencer Parity Error\" },\n\t{ DPARERR,\t\"Data-path Parity Error\" },\n\t{ MPARERR,\t\"Scratch or SCB Memory Parity Error\" },\n\t{ PCIERRSTAT,\t\"PCI Error detected\" },\n\t{ CIOPARERR,\t\"CIOBUS Parity Error\" },\n};\nstatic const int num_errors = sizeof(hard_error)/sizeof(hard_error[0]);\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nint\nahc_intr(void *arg)\n{\n\tstruct\tahc_softc *ahc;\n\tu_int\tintstat;\n\n\tahc = (struct ahc_softc *)arg; \n\n\tintstat = ahc_inb(ahc, INTSTAT);\n\n\t/*\n\t * Any interrupts to process?\n\t */\n\tif ((intstat & INT_PEND) == 0) {\n\t\tif (ahc->pci_intr_func && ahc->pci_intr_func(ahc)) {\n#ifdef AHC_DEBUG\n\t\t\tprintf(\"%s: bus intr: CCHADDR %x HADDR %x SEQADDR %x\\n\",\n\t\t\t    ahc_name(ahc),\n\t\t\t    ahc_inb(ahc, CCHADDR) |\n\t\t\t    (ahc_inb(ahc, CCHADDR+1) << 8)\n\t\t\t    | (ahc_inb(ahc, CCHADDR+2) << 16)\n\t\t\t    | (ahc_inb(ahc, CCHADDR+3) << 24),\n\t\t\t    ahc_inb(ahc, HADDR) | (ahc_inb(ahc, HADDR+1) << 8)\n\t\t\t    | (ahc_inb(ahc, HADDR+2) << 16)\n\t\t\t    | (ahc_inb(ahc, HADDR+3) << 24),\n\t\t\t    ahc_inb(ahc, SEQADDR0) |\n\t\t\t    (ahc_inb(ahc, SEQADDR1) << 8));\n#endif\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (intstat & CMDCMPLT) {\n\t\tahc_outb(ahc, CLRINT, CLRCMDINT);\n\t\tahc_run_qoutfifo(ahc);\n\t}\n\tif (intstat & BRKADRINT) {\n\t\t/*\n\t\t * We upset the sequencer :-(\n\t\t * Lookup the error message\n\t\t */\n\t\tint i, error, num_errors;\n\n\t\terror = ahc_inb(ahc, ERROR);\n\t\tnum_errors =  sizeof(hard_error)/sizeof(hard_error[0]);\n\t\tfor (i = 0; error != 1 && i < num_errors; i++)\n\t\t\terror >>= 1;\n\t\tpanic(\"%s: brkadrint, %s at seqaddr = 0x%x\\n\",\n\t\t      ahc_name(ahc), hard_error[i].errmesg,\n\t\t      ahc_inb(ahc, SEQADDR0) |\n\t\t      (ahc_inb(ahc, SEQADDR1) << 8));\n\n\t\t/* Tell everyone that this HBA is no longer availible */\n\t\tahc_abort_scbs(ahc, ALL_TARGETS, ALL_CHANNELS,\n\t\t\t       ALL_LUNS, SCB_LIST_NULL, ROLE_UNKNOWN,\n\t\t\t       XS_DRIVER_STUFFUP);\n\t}\n\tif (intstat & SEQINT)\n\t\tahc_handle_seqint(ahc, intstat);\n\n\tif (intstat & SCSIINT)\n\t\tahc_handle_scsiint(ahc, intstat);\n\treturn(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: board is not responding\\n\"",
            "ahc_name(ahc)"
          ],
          "line": 4388
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 4388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "INTSTAT"
          ],
          "line": 4383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1000"
          ],
          "line": 4382
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nahc_poll __P((struct ahc_softc *ahc, int wait));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC int\nahc_poll(ahc, wait)\n\tstruct   ahc_softc *ahc;\n\tint   wait;\t/* in msec */\n{\n\twhile (--wait) {\n\t\tDELAY(1000);\n\t\tif (ahc_inb(ahc, INTSTAT) & INT_PEND)\n\t\t\tbreak;\n\t}\n\n\tif (wait == 0) {\n\t\tprintf(\"%s: board is not responding\\n\", ahc_name(ahc));\n\t\treturn (EIO);\n\t}\n\t\t\n\tahc_intr((void *)ahc);\n\treturn (0);\n}"
  },
  {
    "function_name": "ahc_execute_scb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "4237-4374",
    "snippet": "STATIC int\nahc_execute_scb(arg, dm_segs, nsegments)\n\tvoid *arg;\n\tbus_dma_segment_t *dm_segs;\n\tint nsegments;\n{\n\tstruct\t scb *scb;\n\tstruct scsi_xfer *xs;\n\tstruct\t ahc_softc *ahc;\n\tint\t s;\n\n\tscb = (struct scb *)arg;\n\txs = scb->xs;\n\tahc = (struct ahc_softc *)xs->sc_link->adapter_softc;\n\n\n\tif (nsegments != 0) {\n\t\tstruct\t  ahc_dma_seg *sg;\n\t\tbus_dma_segment_t *end_seg;\n\t\tbus_dmasync_op_t op;\n\n\t\tend_seg = dm_segs + nsegments;\n\n\t\t/* Copy the first SG into the data pointer area */\n\t\tscb->hscb->data = dm_segs->ds_addr;\n\t\tscb->hscb->datalen = dm_segs->ds_len;\n\n\t\t/* Copy the segments into our SG list */\n\t\tsg = scb->sg_list;\n\t\twhile (dm_segs < end_seg) {\n\t\t\tsg->addr = dm_segs->ds_addr;\n\t\t\tsg->len = dm_segs->ds_len;\n\t\t\tsg++;\n\t\t\tdm_segs++;\n\t\t}\n\n\t\t/* Note where to find the SG entries in bus space */\n\t\tscb->hscb->SG_pointer = scb->sg_list_phys;\n\t\tif ((scb->xs->flags & SCSI_DATA_IN) != 0)\n\t\t\top = BUS_DMASYNC_PREREAD;\n\t\telse\n\t\t\top = BUS_DMASYNC_PREWRITE;\n\t\tbus_dmamap_sync(ahc->sc_dmat, scb->dmamap, op);\n\t} else {\n\t\tscb->hscb->SG_pointer = 0;\n\t\tscb->hscb->data = 0;\n\t\tscb->hscb->datalen = 0;\n\t}\n\t\n\tscb->sg_count = scb->hscb->SG_count = nsegments;\n\n\ts = splbio();\n\n\t/*\n\t * Last time we need to check if this SCB needs to\n\t * be aborted.\n\t */\n\tif (xs->flags & ITSDONE) {\n\t\tif (!ahc_istagged_device(ahc, xs))\n\t\t\tahc_index_busy_tcl(ahc, scb->hscb->tcl, TRUE);\n\t\tif (nsegments != 0)\n\t\t\tbus_dmamap_unload(ahc->sc_dmat, scb->dmamap);\n\t\tahcfreescb(ahc, scb);\n\t\tsplx(s);\n\t\treturn (COMPLETE);\n\t}\n\n#ifdef DIAGNOSTIC\n\tif (scb->sg_count > 255)\n\t\tpanic(\"ahc bad sg_count\");\n#endif\n\t\t\n\tLIST_INSERT_HEAD(&ahc->pending_scbs, scb, pend_links);\n\n\tscb->flags |= SCB_ACTIVE;\n\n\tif (!(xs->flags & SCSI_POLL))\n\ttimeout(ahc_timeout, (caddr_t)scb, \n\t\t    (xs->timeout * hz) / 1000);\n\n\tif ((scb->flags & SCB_TARGET_IMMEDIATE) != 0) {\n#if 0\n\t\tprintf(\"Continueing Immediate Command %d:%d\\n\",\n\t\t       xs->sc_link->target,\n\t\t       xs->sc_link->lun);\n#endif\n\t\tpause_sequencer(ahc);\n\t\tif ((ahc->flags & AHC_PAGESCBS) == 0)\n\t\t\tahc_outb(ahc, SCBPTR, scb->hscb->tag);\n\t\tahc_outb(ahc, SCB_TAG, scb->hscb->tag);\n\t\tahc_outb(ahc, RETURN_1, CONT_MSG_LOOP);\n\t\tunpause_sequencer(ahc);\n\t} else {\n\n\t\tahc->qinfifo[ahc->qinfifonext++] = scb->hscb->tag;\n\n\t\tbus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, \n\t\t\t\tBUS_DMASYNC_PREWRITE);\n\t\t\n\t\tif ((ahc->features & AHC_QUEUE_REGS) != 0) {\n\t\t\tahc_outb(ahc, HNSCB_QOFF, ahc->qinfifonext);\n\t\t} else {\n\t\t\tpause_sequencer(ahc);\n\t\t\tahc_outb(ahc, KERNEL_QINPOS, ahc->qinfifonext);\n\t\t\tunpause_sequencer(ahc);\n\t\t}\n\t}\n\n#ifdef AHC_DEBUG\n\tif (ahc_debug & AHC_SHOWCMDS) {\n\t\tsc_print_addr(xs->sc_link);\n\t\tprintf(\"opcode %d tag %x len %d flags %x control %x fpos %u\"\n\t\t    \" rate %x\\n\",\n\t\t    xs->cmdstore.opcode, scb->hscb->tag, scb->hscb->datalen,\n\t\t    scb->flags, scb->hscb->control, ahc->qinfifonext,\n\t\t    scb->hscb->scsirate);\n\t}\n#endif\n\n\tif (!(xs->flags & SCSI_POLL)) {\n\t\tsplx(s);\n\t\treturn (SUCCESSFULLY_QUEUED);\n\t}\n\t/*\n\t * If we can't use interrupts, poll for completion\n\t */\n\tSC_DEBUG(xs->sc_link, SDEV_DB3, (\"cmd_poll\\n\"));\n\tdo {\n\t\tif (ahc_poll(ahc, xs->timeout)) {\n\t\t\tif (!(xs->flags & SCSI_SILENT))\n\t\t\t\tprintf(\"cmd fail\\n\");\n\t\t\tahc_timeout(scb);\n\t\t\tbreak;\n\t\t}\n\t} while (!(xs->flags & ITSDONE));\n\tsplx(s);\n\treturn (COMPLETE);\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define STATIC\tstatic",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "STATIC int",
      "STATIC void",
      "ahc_shutdown __P((void *arg));",
      "STATIC int",
      "ahc_execute_scb __P((void *arg, bus_dma_segment_t *dm_segs,\n\t\t\t\t     int nsegments));",
      "STATIC int",
      "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
      "STATIC void",
      "ahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));",
      "STATIC void",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
      "STATIC void",
      "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_calc_residual __P((struct scb *scb));",
      "STATIC void",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
      "STATIC void",
      "static __inline void pause_sequencer",
      "static __inline void unpause_sequencer",
      "STATIC void",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "static __inline u_int ahc_index_busy_tcl",
      "STATIC void",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
      "STATIC void",
      "STATIC void",
      "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *xs;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 4372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_timeout",
          "args": [
            "scb"
          ],
          "line": 4368
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "4777-5053",
          "snippet": "STATIC void\nahc_timeout(void *arg)\n{\n\tstruct\tscb *scb;\n\tstruct\tahc_softc *ahc;\n\tint\ts, found;\n\tu_int\tlast_phase;\n\tint\ttarget;\n\tint\tlun;\n\tint\ti;\n\tchar\tchannel;\n\n\tscb = (struct scb *)arg; \n\tahc = (struct ahc_softc *)scb->xs->sc_link->adapter_softc;\n\n\ts = splbio();\n\n\t/*\n\t * Ensure that the card doesn't do anything\n\t * behind our back.  Also make sure that we\n\t * didn't \"just\" miss an interrupt that would\n\t * affect this timeout.\n\t */\n\tdo {\n\t\tahc_intr(ahc);\n\t\tpause_sequencer(ahc);\n\t} while (ahc_inb(ahc, INTSTAT) & INT_PEND);\n\n\tif ((scb->flags & SCB_ACTIVE) == 0) {\n\t\t/* Previous timeout took care of me already */\n\t\tprintf(\"Timedout SCB handled by another timeout\\n\");\n\t\tunpause_sequencer(ahc);\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\ttarget = SCB_TARGET(scb);\n\tchannel = SCB_CHANNEL(scb);\n\tlun = SCB_LUN(scb);\n\n\tsc_print_addr(scb->xs->sc_link);\n\tprintf(\"SCB 0x%x - timed out \", scb->hscb->tag);\n\t/*\n\t * Take a snapshot of the bus state and print out\n\t * some information so we can track down driver bugs.\n\t */\n\tlast_phase = ahc_inb(ahc, LASTPHASE);\n\n\tfor (i = 0; i < num_phases; i++) {\n\t\tif (last_phase == phase_table[i].phase)\n\t\t\tbreak;\n\t}\n\tprintf(\"%s\", phase_table[i].phasemsg);\n  \n\tprintf(\", SEQADDR == 0x%x\\n\",\n\t       ahc_inb(ahc, SEQADDR0) | (ahc_inb(ahc, SEQADDR1) << 8));\n#if 0\n\tprintf(\"SSTAT1 == 0x%x\\n\", ahc_inb(ahc, SSTAT1));\n\tprintf(\"SSTAT3 == 0x%x\\n\", ahc_inb(ahc, SSTAT3));\n\tprintf(\"SCSIPHASE == 0x%x\\n\", ahc_inb(ahc, SCSIPHASE));\n\tprintf(\"SCSIRATE == 0x%x\\n\", ahc_inb(ahc, SCSIRATE));\n\tprintf(\"SCSIOFFSET == 0x%x\\n\", ahc_inb(ahc, SCSIOFFSET));\n\tprintf(\"SEQ_FLAGS == 0x%x\\n\", ahc_inb(ahc, SEQ_FLAGS));\n\tprintf(\"SCB_DATAPTR == 0x%x\\n\", ahc_inb(ahc, SCB_DATAPTR)\n\t\t\t\t      | ahc_inb(ahc, SCB_DATAPTR + 1) << 8\n\t\t\t\t      | ahc_inb(ahc, SCB_DATAPTR + 2) << 16\n\t\t\t\t      | ahc_inb(ahc, SCB_DATAPTR + 3) << 24);\n\tprintf(\"SCB_DATACNT == 0x%x\\n\", ahc_inb(ahc, SCB_DATACNT)\n\t\t\t\t      | ahc_inb(ahc, SCB_DATACNT + 1) << 8\n\t\t\t\t      | ahc_inb(ahc, SCB_DATACNT + 2) << 16);\n\tprintf(\"SCB_SGCOUNT == 0x%x\\n\", ahc_inb(ahc, SCB_SGCOUNT));\n\tprintf(\"CCSCBCTL == 0x%x\\n\", ahc_inb(ahc, CCSCBCTL));\n\tprintf(\"CCSCBCNT == 0x%x\\n\", ahc_inb(ahc, CCSCBCNT));\n\tprintf(\"DFCNTRL == 0x%x\\n\", ahc_inb(ahc, DFCNTRL));\n\tprintf(\"DFSTATUS == 0x%x\\n\", ahc_inb(ahc, DFSTATUS));\n\tprintf(\"CCHCNT == 0x%x\\n\", ahc_inb(ahc, CCHCNT));\n\tif (scb->sg_count > 0) {\n\t\tfor (i = 0; i < scb->sg_count; i++) {\n\t\t\tprintf(\"sg[%d] - Addr 0x%x : Length %d\\n\",\n\t\t\t       i,\n\t\t\t       scb->sg_list[i].addr,\n\t\t\t       scb->sg_list[i].len);\n\t\t}\n\t}\n#endif\n\tif (scb->flags & (SCB_DEVICE_RESET|SCB_ABORT)) {\n\t\t/*\n\t\t * Been down this road before.\n\t\t * Do a full bus reset.\n\t\t */\nbus_reset:\n\t\tahcsetccbstatus(scb->xs, XS_TIMEOUT);\n\t\tfound = ahc_reset_channel(ahc, channel, /*Initiate Reset*/TRUE);\n\t\tprintf(\"%s: Issued Channel %c Bus Reset. \"\n\t\t       \"%d SCBs aborted\\n\", ahc_name(ahc), channel, found);\n\t} else {\n\t\t/*\n\t\t * If we are a target, transition to bus free and report\n\t\t * the timeout.\n\t\t * \n\t\t * The target/initiator that is holding up the bus may not\n\t\t * be the same as the one that triggered this timeout\n\t\t * (different commands have different timeout lengths).\n\t\t * If the bus is idle and we are actiing as the initiator\n\t\t * for this request, queue a BDR message to the timed out\n\t\t * target.  Otherwise, if the timed out transaction is\n\t\t * active:\n\t\t *   Initiator transaction:\n\t\t *\tStuff the message buffer with a BDR message and assert\n\t\t *\tATN in the hopes that the target will let go of the bus\n\t\t *\tand go to the mesgout phase.  If this fails, we'll\n\t\t *\tget another timeout 2 seconds later which will attempt\n\t\t *\ta bus reset.\n\t\t *\n\t\t *   Target transaction:\n\t\t *\tTransition to BUS FREE and report the error.\n\t\t *\tIt's good to be the target!\n\t\t */\n\t\tu_int active_scb_index;\n\n\t\tactive_scb_index = ahc_inb(ahc, SCB_TAG);\n\n\t\tif (last_phase != P_BUSFREE \n\t\t  && (active_scb_index < ahc->scb_data->numscbs)) {\n\t\t\tstruct scb *active_scb;\n\n\t\t\t/*\n\t\t\t * If the active SCB is not from our device,\n\t\t\t * assume that another device is hogging the bus\n\t\t\t * and wait for it's timeout to expire before\n\t\t\t * taking additional action.\n\t\t\t */ \n\t\t\tactive_scb = &ahc->scb_data->scbarray[active_scb_index];\n\t\t\tif (active_scb->hscb->tcl != scb->hscb->tcl) {\n\t\t\t\tu_int\tnewtimeout;\n\n\t\t\t\tsc_print_addr(scb->xs->sc_link);\n\t\t\t\tprintf(\"Other SCB Timeout%s\",\n\t\t\t \t       (scb->flags & SCB_OTHERTCL_TIMEOUT) != 0\n\t\t\t\t       ? \" again\\n\" : \"\\n\");\n\t\t\t\tscb->flags |= SCB_OTHERTCL_TIMEOUT;\n\t\t\t\tnewtimeout = MAX(active_scb->xs->timeout,\n\t\t\t\t\t\t scb->xs->timeout);\n\t\t\t\ttimeout(ahc_timeout, scb,\n\t\t\t\t\t    (newtimeout * hz) / 1000);\n\t\t\t\tsplx(s);\n\t\t\t\treturn;\n\t\t\t} \n\n\t\t\t/* It's us */\n\t\t\tif ((scb->hscb->control & TARGET_SCB) != 0) {\n\n\t\t\t\t/*\n\t\t\t\t * Send back any queued up transactions\n\t\t\t\t * and properly record the error condition.\n\t\t\t\t */\n\t\t\t\tahc_freeze_devq(ahc, scb->xs->sc_link);\n\t\t\t\tahcsetccbstatus(scb->xs, XS_TIMEOUT);\n\t\t\t\tahc_freeze_ccb(scb);\n\t\t\t\tahc_done(ahc, scb);\n\n\t\t\t\t/* Will clear us from the bus */\n\t\t\t\trestart_sequencer(ahc);\n\t\t\t\treturn;\n\t\t\t} \n\n\t\t\tahc_set_recoveryscb(ahc, active_scb);\n\t\t\tahc_outb(ahc, MSG_OUT, MSG_BUS_DEV_RESET);\n\t\t\tahc_outb(ahc, SCSISIGO, last_phase|ATNO);\n\t\t\tsc_print_addr(active_scb->xs->sc_link);\n\t\t\tprintf(\"BDR message in message buffer\\n\");\n\t\t\tactive_scb->flags |=  SCB_DEVICE_RESET;\n\t\t\t    timeout(ahc_timeout, (caddr_t)active_scb, 2 * hz);\n\t\t\tunpause_sequencer(ahc);\n\t\t} else {\n\t\t\tint\t disconnected;\n\n\t\t\t/* XXX Shouldn't panic.  Just punt instead */\n\t\t\tif ((scb->hscb->control & TARGET_SCB) != 0)\n\t\t\t\tpanic(\"Timed-out target SCB but bus idle\");\n\n\t\t\tif (last_phase != P_BUSFREE\n\t\t\t && (ahc_inb(ahc, SSTAT0) & TARGET) != 0) {\n\t\t\t\t/* XXX What happened to the SCB? */\n\t\t\t\t/* Hung target selection.  Goto busfree */\n\t\t\t\tprintf(\"%s: Hung target selection\\n\",\n\t\t\t\t       ahc_name(ahc));\n\t\t\t\trestart_sequencer(ahc);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (ahc_search_qinfifo(ahc, target, channel, lun,\n\t\t\t\t\t       scb->hscb->tag, ROLE_INITIATOR,\n\t\t\t\t\t       /*status*/0, SEARCH_COUNT) > 0) {\n\t\t\t\tdisconnected = FALSE;\n\t\t\t} else {\n\t\t\t\tdisconnected = TRUE;\n\t\t\t}\n\n\t\t\tif (disconnected) {\n\t\t\t\tu_int active_scb;\n\n\t\t\t\tahc_set_recoveryscb(ahc, scb);\n\t\t\t\t/*\n\t\t\t\t * Simply set the MK_MESSAGE control bit.\n\t\t\t\t */\n\t\t\t\tscb->hscb->control |= MK_MESSAGE;\n\t\t\t\tscb->flags |= SCB_QUEUED_MSG\n\t\t\t\t\t   |  SCB_DEVICE_RESET;\n\n\t\t\t\t/*\n\t\t\t\t * Mark the cached copy of this SCB in the\n\t\t\t\t * disconnected list too, so that a reconnect\n\t\t\t\t * at this point causes a BDR or abort.\n\t\t\t\t */\n\t\t\t\tactive_scb = ahc_inb(ahc, SCBPTR);\n\t\t\t\tif (ahc_search_disc_list(ahc, target,\n\t\t\t\t\t\t\t channel, lun,\n\t\t\t\t\t\t\t scb->hscb->tag,\n\t\t\t\t\t\t\t /*stop_on_first*/TRUE,\n\t\t\t\t\t\t\t /*remove*/FALSE,\n\t\t\t\t\t\t\t /*save_state*/FALSE)) {\n\t\t\t\t\tu_int scb_control;\n\n\t\t\t\t\tscb_control = ahc_inb(ahc, SCB_CONTROL);\n\t\t\t\t\tscb_control |= MK_MESSAGE;\n\t\t\t\t\tahc_outb(ahc, SCB_CONTROL, scb_control);\n\t\t\t\t}\n\t\t\t\tahc_outb(ahc, SCBPTR, active_scb);\n\t\t\t\tahc_index_busy_tcl(ahc, scb->hscb->tcl,\n\t\t\t\t\t\t   /*unbusy*/TRUE);\n\n\t\t\t\t/*\n\t\t\t\t * Actually re-queue this SCB in case we can\n\t\t\t\t * select the device before it reconnects.\n\t\t\t\t * Clear out any entries in the QINFIFO first\n\t\t\t\t * so we are the next SCB for this target\n\t\t\t\t * to run.\n\t\t\t\t */\n\t\t\t\tahc_search_qinfifo(ahc, SCB_TARGET(scb),\n\t\t\t\t\t\t   channel, SCB_LUN(scb),\n\t\t\t\t\t\t   SCB_LIST_NULL,\n\t\t\t\t\t\t   ROLE_INITIATOR,\n\t\t\t\t\t\t   SCB_REQUEUE,\n\t\t\t\t\t\t   SEARCH_COMPLETE);\n\t\t\t\tsc_print_addr(scb->xs->sc_link);\n\t\t\t\tprintf(\"Queuing a BDR SCB\\n\");\n\t\t\t\tahc->qinfifo[ahc->qinfifonext++] =\n\t\t\t\t    scb->hscb->tag;\n\n\t\t\t\tbus_dmamap_sync(ahc->sc_dmat,\n\t\t\t\t    ahc->shared_data_dmamap,\n\t\t\t\t    BUS_DMASYNC_PREWRITE);\n\n\t\t\t\tif ((ahc->features & AHC_QUEUE_REGS) != 0) {\n\t\t\t\t\tahc_outb(ahc, HNSCB_QOFF,\n\t\t\t\t\t\t ahc->qinfifonext);\n\t\t\t\t} else {\n\t\t\t\t\tahc_outb(ahc, KERNEL_QINPOS,\n\t\t\t\t\t\t ahc->qinfifonext);\n\t\t\t\t}\n\t\t\t\ttimeout(ahc_timeout, (caddr_t)scb, 2 * hz);\n\t\t\t\tunpause_sequencer(ahc);\n\t\t\t} else {\n\t\t\t\t/* Go \"immediatly\" to the bus reset */\n\t\t\t\t/* This shouldn't happen */\n\t\t\t\tahc_set_recoveryscb(ahc, scb);\n\t\t\t\tsc_print_addr(scb->xs->sc_link);\n\t\t\t\tprintf(\"SCB %d: Immediate reset.  \"\n\t\t\t\t\t\"Flags = 0x%x\\n\", scb->hscb->tag,\n\t\t\t\t\tscb->flags);\n\t\t\t\tgoto bus_reset;\n\t\t\t}\n\t\t}\n\t}\n\tsplx(s);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "ahc_poll __P((struct ahc_softc *ahc, int wait));",
            "STATIC void",
            "ahc_shutdown __P((void *arg));",
            "STATIC int",
            "STATIC int",
            "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
            "STATIC void",
            "ahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));",
            "STATIC int",
            "ahc_sent_msg __P((struct ahc_softc *ahc, u_int msgtype,\n\t\t\t\t  int full));",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_search_qinfifo __P((struct ahc_softc *ahc, int target,\n\t\t\t\t\tchar channel, int lun, u_int tag,\n\t\t\t\t\trole_t role, u_int32_t status,\n\t\t\t\t\tahc_search_action action));",
            "STATIC int",
            "STATIC int",
            "ahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));",
            "STATIC int",
            "ahc_search_disc_list __P((struct ahc_softc *ahc, int target,\n\t\t\t\t\t  char channel, int lun, u_int tag,\n\t\t\t\t\t  int stop_on_first, int remove,\n\t\t\t\t\t  int save_state));",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
            "STATIC void",
            "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_calc_residual __P((struct scb *scb));",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
            "STATIC void",
            "static __inline void pause_sequencer",
            "static __inline void unpause_sequencer",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "static __inline u_int ahc_index_busy_tcl",
            "static __inline void ahc_freeze_ccb",
            "static __inline void ahcsetccbstatus",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "static struct {\n        u_int8_t phase;\n        u_int8_t mesg_out; /* Message response to parity errors */\n\tchar *phasemsg;\n} phase_table[] = {\n\t{ P_DATAOUT,\tMSG_NOOP,\t\t\"in Data-out phase\"\t},\n\t{ P_DATAIN,\tMSG_INITIATOR_DET_ERR,\t\"in Data-in phase\"\t},\n\t{ P_COMMAND,\tMSG_NOOP,\t\t\"in Command phase\"\t},\n\t{ P_MESGOUT,\tMSG_NOOP,\t\t\"in Message-out phase\"\t},\n\t{ P_STATUS,\tMSG_INITIATOR_DET_ERR,\t\"in Status phase\"\t},\n\t{ P_MESGIN,\tMSG_PARITY_ERROR,\t\"in Message-in phase\"\t},\n\t{ P_BUSFREE,\tMSG_NOOP,\t\t\"while idle\"\t\t},\n\t{ 0,\t\tMSG_NOOP,\t\t\"in unknown phase\"\t}\n};",
            "static const int num_phases = (sizeof(phase_table)/sizeof(phase_table[0])) - 1;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *xs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nahc_poll __P((struct ahc_softc *ahc, int wait));\nSTATIC void;\nahc_shutdown __P((void *arg));\nSTATIC int;\nSTATIC int;\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nSTATIC void;\nahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));\nSTATIC int;\nahc_sent_msg __P((struct ahc_softc *ahc, u_int msgtype,\n\t\t\t\t  int full));\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_search_qinfifo __P((struct ahc_softc *ahc, int target,\n\t\t\t\t\tchar channel, int lun, u_int tag,\n\t\t\t\t\trole_t role, u_int32_t status,\n\t\t\t\t\tahc_search_action action));\nSTATIC int;\nSTATIC int;\nahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));\nSTATIC int;\nahc_search_disc_list __P((struct ahc_softc *ahc, int target,\n\t\t\t\t\t  char channel, int lun, u_int tag,\n\t\t\t\t\t  int stop_on_first, int remove,\n\t\t\t\t\t  int save_state));\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nSTATIC void;\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_calc_residual __P((struct scb *scb));\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nSTATIC void;\nstatic __inline void pause_sequencer;\nstatic __inline void unpause_sequencer;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nstatic __inline u_int ahc_index_busy_tcl;\nstatic __inline void ahc_freeze_ccb;\nstatic __inline void ahcsetccbstatus;\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nstatic struct {\n        u_int8_t phase;\n        u_int8_t mesg_out; /* Message response to parity errors */\n\tchar *phasemsg;\n} phase_table[] = {\n\t{ P_DATAOUT,\tMSG_NOOP,\t\t\"in Data-out phase\"\t},\n\t{ P_DATAIN,\tMSG_INITIATOR_DET_ERR,\t\"in Data-in phase\"\t},\n\t{ P_COMMAND,\tMSG_NOOP,\t\t\"in Command phase\"\t},\n\t{ P_MESGOUT,\tMSG_NOOP,\t\t\"in Message-out phase\"\t},\n\t{ P_STATUS,\tMSG_INITIATOR_DET_ERR,\t\"in Status phase\"\t},\n\t{ P_MESGIN,\tMSG_PARITY_ERROR,\t\"in Message-in phase\"\t},\n\t{ P_BUSFREE,\tMSG_NOOP,\t\t\"while idle\"\t\t},\n\t{ 0,\t\tMSG_NOOP,\t\t\"in unknown phase\"\t}\n};\nstatic const int num_phases = (sizeof(phase_table)/sizeof(phase_table[0])) - 1;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n\nSTATIC void\nahc_timeout(void *arg)\n{\n\tstruct\tscb *scb;\n\tstruct\tahc_softc *ahc;\n\tint\ts, found;\n\tu_int\tlast_phase;\n\tint\ttarget;\n\tint\tlun;\n\tint\ti;\n\tchar\tchannel;\n\n\tscb = (struct scb *)arg; \n\tahc = (struct ahc_softc *)scb->xs->sc_link->adapter_softc;\n\n\ts = splbio();\n\n\t/*\n\t * Ensure that the card doesn't do anything\n\t * behind our back.  Also make sure that we\n\t * didn't \"just\" miss an interrupt that would\n\t * affect this timeout.\n\t */\n\tdo {\n\t\tahc_intr(ahc);\n\t\tpause_sequencer(ahc);\n\t} while (ahc_inb(ahc, INTSTAT) & INT_PEND);\n\n\tif ((scb->flags & SCB_ACTIVE) == 0) {\n\t\t/* Previous timeout took care of me already */\n\t\tprintf(\"Timedout SCB handled by another timeout\\n\");\n\t\tunpause_sequencer(ahc);\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\ttarget = SCB_TARGET(scb);\n\tchannel = SCB_CHANNEL(scb);\n\tlun = SCB_LUN(scb);\n\n\tsc_print_addr(scb->xs->sc_link);\n\tprintf(\"SCB 0x%x - timed out \", scb->hscb->tag);\n\t/*\n\t * Take a snapshot of the bus state and print out\n\t * some information so we can track down driver bugs.\n\t */\n\tlast_phase = ahc_inb(ahc, LASTPHASE);\n\n\tfor (i = 0; i < num_phases; i++) {\n\t\tif (last_phase == phase_table[i].phase)\n\t\t\tbreak;\n\t}\n\tprintf(\"%s\", phase_table[i].phasemsg);\n  \n\tprintf(\", SEQADDR == 0x%x\\n\",\n\t       ahc_inb(ahc, SEQADDR0) | (ahc_inb(ahc, SEQADDR1) << 8));\n#if 0\n\tprintf(\"SSTAT1 == 0x%x\\n\", ahc_inb(ahc, SSTAT1));\n\tprintf(\"SSTAT3 == 0x%x\\n\", ahc_inb(ahc, SSTAT3));\n\tprintf(\"SCSIPHASE == 0x%x\\n\", ahc_inb(ahc, SCSIPHASE));\n\tprintf(\"SCSIRATE == 0x%x\\n\", ahc_inb(ahc, SCSIRATE));\n\tprintf(\"SCSIOFFSET == 0x%x\\n\", ahc_inb(ahc, SCSIOFFSET));\n\tprintf(\"SEQ_FLAGS == 0x%x\\n\", ahc_inb(ahc, SEQ_FLAGS));\n\tprintf(\"SCB_DATAPTR == 0x%x\\n\", ahc_inb(ahc, SCB_DATAPTR)\n\t\t\t\t      | ahc_inb(ahc, SCB_DATAPTR + 1) << 8\n\t\t\t\t      | ahc_inb(ahc, SCB_DATAPTR + 2) << 16\n\t\t\t\t      | ahc_inb(ahc, SCB_DATAPTR + 3) << 24);\n\tprintf(\"SCB_DATACNT == 0x%x\\n\", ahc_inb(ahc, SCB_DATACNT)\n\t\t\t\t      | ahc_inb(ahc, SCB_DATACNT + 1) << 8\n\t\t\t\t      | ahc_inb(ahc, SCB_DATACNT + 2) << 16);\n\tprintf(\"SCB_SGCOUNT == 0x%x\\n\", ahc_inb(ahc, SCB_SGCOUNT));\n\tprintf(\"CCSCBCTL == 0x%x\\n\", ahc_inb(ahc, CCSCBCTL));\n\tprintf(\"CCSCBCNT == 0x%x\\n\", ahc_inb(ahc, CCSCBCNT));\n\tprintf(\"DFCNTRL == 0x%x\\n\", ahc_inb(ahc, DFCNTRL));\n\tprintf(\"DFSTATUS == 0x%x\\n\", ahc_inb(ahc, DFSTATUS));\n\tprintf(\"CCHCNT == 0x%x\\n\", ahc_inb(ahc, CCHCNT));\n\tif (scb->sg_count > 0) {\n\t\tfor (i = 0; i < scb->sg_count; i++) {\n\t\t\tprintf(\"sg[%d] - Addr 0x%x : Length %d\\n\",\n\t\t\t       i,\n\t\t\t       scb->sg_list[i].addr,\n\t\t\t       scb->sg_list[i].len);\n\t\t}\n\t}\n#endif\n\tif (scb->flags & (SCB_DEVICE_RESET|SCB_ABORT)) {\n\t\t/*\n\t\t * Been down this road before.\n\t\t * Do a full bus reset.\n\t\t */\nbus_reset:\n\t\tahcsetccbstatus(scb->xs, XS_TIMEOUT);\n\t\tfound = ahc_reset_channel(ahc, channel, /*Initiate Reset*/TRUE);\n\t\tprintf(\"%s: Issued Channel %c Bus Reset. \"\n\t\t       \"%d SCBs aborted\\n\", ahc_name(ahc), channel, found);\n\t} else {\n\t\t/*\n\t\t * If we are a target, transition to bus free and report\n\t\t * the timeout.\n\t\t * \n\t\t * The target/initiator that is holding up the bus may not\n\t\t * be the same as the one that triggered this timeout\n\t\t * (different commands have different timeout lengths).\n\t\t * If the bus is idle and we are actiing as the initiator\n\t\t * for this request, queue a BDR message to the timed out\n\t\t * target.  Otherwise, if the timed out transaction is\n\t\t * active:\n\t\t *   Initiator transaction:\n\t\t *\tStuff the message buffer with a BDR message and assert\n\t\t *\tATN in the hopes that the target will let go of the bus\n\t\t *\tand go to the mesgout phase.  If this fails, we'll\n\t\t *\tget another timeout 2 seconds later which will attempt\n\t\t *\ta bus reset.\n\t\t *\n\t\t *   Target transaction:\n\t\t *\tTransition to BUS FREE and report the error.\n\t\t *\tIt's good to be the target!\n\t\t */\n\t\tu_int active_scb_index;\n\n\t\tactive_scb_index = ahc_inb(ahc, SCB_TAG);\n\n\t\tif (last_phase != P_BUSFREE \n\t\t  && (active_scb_index < ahc->scb_data->numscbs)) {\n\t\t\tstruct scb *active_scb;\n\n\t\t\t/*\n\t\t\t * If the active SCB is not from our device,\n\t\t\t * assume that another device is hogging the bus\n\t\t\t * and wait for it's timeout to expire before\n\t\t\t * taking additional action.\n\t\t\t */ \n\t\t\tactive_scb = &ahc->scb_data->scbarray[active_scb_index];\n\t\t\tif (active_scb->hscb->tcl != scb->hscb->tcl) {\n\t\t\t\tu_int\tnewtimeout;\n\n\t\t\t\tsc_print_addr(scb->xs->sc_link);\n\t\t\t\tprintf(\"Other SCB Timeout%s\",\n\t\t\t \t       (scb->flags & SCB_OTHERTCL_TIMEOUT) != 0\n\t\t\t\t       ? \" again\\n\" : \"\\n\");\n\t\t\t\tscb->flags |= SCB_OTHERTCL_TIMEOUT;\n\t\t\t\tnewtimeout = MAX(active_scb->xs->timeout,\n\t\t\t\t\t\t scb->xs->timeout);\n\t\t\t\ttimeout(ahc_timeout, scb,\n\t\t\t\t\t    (newtimeout * hz) / 1000);\n\t\t\t\tsplx(s);\n\t\t\t\treturn;\n\t\t\t} \n\n\t\t\t/* It's us */\n\t\t\tif ((scb->hscb->control & TARGET_SCB) != 0) {\n\n\t\t\t\t/*\n\t\t\t\t * Send back any queued up transactions\n\t\t\t\t * and properly record the error condition.\n\t\t\t\t */\n\t\t\t\tahc_freeze_devq(ahc, scb->xs->sc_link);\n\t\t\t\tahcsetccbstatus(scb->xs, XS_TIMEOUT);\n\t\t\t\tahc_freeze_ccb(scb);\n\t\t\t\tahc_done(ahc, scb);\n\n\t\t\t\t/* Will clear us from the bus */\n\t\t\t\trestart_sequencer(ahc);\n\t\t\t\treturn;\n\t\t\t} \n\n\t\t\tahc_set_recoveryscb(ahc, active_scb);\n\t\t\tahc_outb(ahc, MSG_OUT, MSG_BUS_DEV_RESET);\n\t\t\tahc_outb(ahc, SCSISIGO, last_phase|ATNO);\n\t\t\tsc_print_addr(active_scb->xs->sc_link);\n\t\t\tprintf(\"BDR message in message buffer\\n\");\n\t\t\tactive_scb->flags |=  SCB_DEVICE_RESET;\n\t\t\t    timeout(ahc_timeout, (caddr_t)active_scb, 2 * hz);\n\t\t\tunpause_sequencer(ahc);\n\t\t} else {\n\t\t\tint\t disconnected;\n\n\t\t\t/* XXX Shouldn't panic.  Just punt instead */\n\t\t\tif ((scb->hscb->control & TARGET_SCB) != 0)\n\t\t\t\tpanic(\"Timed-out target SCB but bus idle\");\n\n\t\t\tif (last_phase != P_BUSFREE\n\t\t\t && (ahc_inb(ahc, SSTAT0) & TARGET) != 0) {\n\t\t\t\t/* XXX What happened to the SCB? */\n\t\t\t\t/* Hung target selection.  Goto busfree */\n\t\t\t\tprintf(\"%s: Hung target selection\\n\",\n\t\t\t\t       ahc_name(ahc));\n\t\t\t\trestart_sequencer(ahc);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (ahc_search_qinfifo(ahc, target, channel, lun,\n\t\t\t\t\t       scb->hscb->tag, ROLE_INITIATOR,\n\t\t\t\t\t       /*status*/0, SEARCH_COUNT) > 0) {\n\t\t\t\tdisconnected = FALSE;\n\t\t\t} else {\n\t\t\t\tdisconnected = TRUE;\n\t\t\t}\n\n\t\t\tif (disconnected) {\n\t\t\t\tu_int active_scb;\n\n\t\t\t\tahc_set_recoveryscb(ahc, scb);\n\t\t\t\t/*\n\t\t\t\t * Simply set the MK_MESSAGE control bit.\n\t\t\t\t */\n\t\t\t\tscb->hscb->control |= MK_MESSAGE;\n\t\t\t\tscb->flags |= SCB_QUEUED_MSG\n\t\t\t\t\t   |  SCB_DEVICE_RESET;\n\n\t\t\t\t/*\n\t\t\t\t * Mark the cached copy of this SCB in the\n\t\t\t\t * disconnected list too, so that a reconnect\n\t\t\t\t * at this point causes a BDR or abort.\n\t\t\t\t */\n\t\t\t\tactive_scb = ahc_inb(ahc, SCBPTR);\n\t\t\t\tif (ahc_search_disc_list(ahc, target,\n\t\t\t\t\t\t\t channel, lun,\n\t\t\t\t\t\t\t scb->hscb->tag,\n\t\t\t\t\t\t\t /*stop_on_first*/TRUE,\n\t\t\t\t\t\t\t /*remove*/FALSE,\n\t\t\t\t\t\t\t /*save_state*/FALSE)) {\n\t\t\t\t\tu_int scb_control;\n\n\t\t\t\t\tscb_control = ahc_inb(ahc, SCB_CONTROL);\n\t\t\t\t\tscb_control |= MK_MESSAGE;\n\t\t\t\t\tahc_outb(ahc, SCB_CONTROL, scb_control);\n\t\t\t\t}\n\t\t\t\tahc_outb(ahc, SCBPTR, active_scb);\n\t\t\t\tahc_index_busy_tcl(ahc, scb->hscb->tcl,\n\t\t\t\t\t\t   /*unbusy*/TRUE);\n\n\t\t\t\t/*\n\t\t\t\t * Actually re-queue this SCB in case we can\n\t\t\t\t * select the device before it reconnects.\n\t\t\t\t * Clear out any entries in the QINFIFO first\n\t\t\t\t * so we are the next SCB for this target\n\t\t\t\t * to run.\n\t\t\t\t */\n\t\t\t\tahc_search_qinfifo(ahc, SCB_TARGET(scb),\n\t\t\t\t\t\t   channel, SCB_LUN(scb),\n\t\t\t\t\t\t   SCB_LIST_NULL,\n\t\t\t\t\t\t   ROLE_INITIATOR,\n\t\t\t\t\t\t   SCB_REQUEUE,\n\t\t\t\t\t\t   SEARCH_COMPLETE);\n\t\t\t\tsc_print_addr(scb->xs->sc_link);\n\t\t\t\tprintf(\"Queuing a BDR SCB\\n\");\n\t\t\t\tahc->qinfifo[ahc->qinfifonext++] =\n\t\t\t\t    scb->hscb->tag;\n\n\t\t\t\tbus_dmamap_sync(ahc->sc_dmat,\n\t\t\t\t    ahc->shared_data_dmamap,\n\t\t\t\t    BUS_DMASYNC_PREWRITE);\n\n\t\t\t\tif ((ahc->features & AHC_QUEUE_REGS) != 0) {\n\t\t\t\t\tahc_outb(ahc, HNSCB_QOFF,\n\t\t\t\t\t\t ahc->qinfifonext);\n\t\t\t\t} else {\n\t\t\t\t\tahc_outb(ahc, KERNEL_QINPOS,\n\t\t\t\t\t\t ahc->qinfifonext);\n\t\t\t\t}\n\t\t\t\ttimeout(ahc_timeout, (caddr_t)scb, 2 * hz);\n\t\t\t\tunpause_sequencer(ahc);\n\t\t\t} else {\n\t\t\t\t/* Go \"immediatly\" to the bus reset */\n\t\t\t\t/* This shouldn't happen */\n\t\t\t\tahc_set_recoveryscb(ahc, scb);\n\t\t\t\tsc_print_addr(scb->xs->sc_link);\n\t\t\t\tprintf(\"SCB %d: Immediate reset.  \"\n\t\t\t\t\t\"Flags = 0x%x\\n\", scb->hscb->tag,\n\t\t\t\t\tscb->flags);\n\t\t\t\tgoto bus_reset;\n\t\t\t}\n\t\t}\n\t}\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"cmd fail\\n\""
          ],
          "line": 4367
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_poll",
          "args": [
            "ahc",
            "xs->timeout"
          ],
          "line": 4365
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_poll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "4376-4394",
          "snippet": "STATIC int\nahc_poll(ahc, wait)\n\tstruct   ahc_softc *ahc;\n\tint   wait;\t/* in msec */\n{\n\twhile (--wait) {\n\t\tDELAY(1000);\n\t\tif (ahc_inb(ahc, INTSTAT) & INT_PEND)\n\t\t\tbreak;\n\t}\n\n\tif (wait == 0) {\n\t\tprintf(\"%s: board is not responding\\n\", ahc_name(ahc));\n\t\treturn (EIO);\n\t}\n\t\t\n\tahc_intr((void *)ahc);\n\treturn (0);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "ahc_poll __P((struct ahc_softc *ahc, int wait));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nahc_poll __P((struct ahc_softc *ahc, int wait));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC int\nahc_poll(ahc, wait)\n\tstruct   ahc_softc *ahc;\n\tint   wait;\t/* in msec */\n{\n\twhile (--wait) {\n\t\tDELAY(1000);\n\t\tif (ahc_inb(ahc, INTSTAT) & INT_PEND)\n\t\t\tbreak;\n\t}\n\n\tif (wait == 0) {\n\t\tprintf(\"%s: board is not responding\\n\", ahc_name(ahc));\n\t\treturn (EIO);\n\t}\n\t\t\n\tahc_intr((void *)ahc);\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SC_DEBUG",
          "args": [
            "xs->sc_link",
            "SDEV_DB3",
            "(\"cmd_poll\\n\")"
          ],
          "line": 4363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 4357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc_print_addr",
          "args": [
            "xs->sc_link"
          ],
          "line": 4347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unpause_sequencer",
          "args": [
            "ahc"
          ],
          "line": 4341
        },
        "resolved": true,
        "details": {
          "function_name": "unpause_sequencer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "456-462",
          "snippet": "static __inline void\nunpause_sequencer(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tif ((ahc_inb(ahc, INTSTAT) & (SCSIINT | SEQINT | BRKADRINT)) == 0)\n\t\tahc_outb(ahc, HCNTRL, ahc->unpause);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "static __inline void unpause_sequencer",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC struct;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nahc_loadseq __P((struct ahc_softc *ahc));\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nahc_clear_intstat __P((struct ahc_softc *ahc));\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nstatic __inline void unpause_sequencer;\nrestart_sequencer __P((struct ahc_softc *ahc));\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nstatic __inline void\nunpause_sequencer(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tif ((ahc_inb(ahc, INTSTAT) & (SCSIINT | SEQINT | BRKADRINT)) == 0)\n\t\tahc_outb(ahc, HCNTRL, ahc->unpause);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "KERNEL_QINPOS",
            "ahc->qinfifonext"
          ],
          "line": 4340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "HNSCB_QOFF",
            "ahc->qinfifonext"
          ],
          "line": 4337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_sync",
          "args": [
            "ahc->sc_dmat",
            "ahc->shared_data_dmamap",
            "BUS_DMASYNC_PREWRITE"
          ],
          "line": 4333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "RETURN_1",
            "CONT_MSG_LOOP"
          ],
          "line": 4327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCB_TAG",
            "scb->hscb->tag"
          ],
          "line": 4326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCBPTR",
            "scb->hscb->tag"
          ],
          "line": 4325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "ahc_timeout",
            "(caddr_t)scb",
            "(xs->timeout * hz) / 1000"
          ],
          "line": 4314
        },
        "resolved": true,
        "details": {
          "function_name": "wdctimeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "952-980",
          "snippet": "void\nwdctimeout(arg)\n\tvoid *arg;\n{\n\tstruct channel_softc *chp = (struct channel_softc *)arg;\n\tstruct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;\n\tint s;\n\n\tWDCDEBUG_PRINT((\"wdctimeout\\n\"), DEBUG_FUNCS);\n\n\ts = splbio();\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) != 0) {\n\t\t__wdcerror(chp, \"timeout\");\n\t\tprintf(\"\\ttype: %s\\n\", (xfer->c_flags & C_ATAPI) ?\n\t\t    \"atapi\":\"ata\");\n\t\tprintf(\"\\tc_bcount: %d\\n\", xfer->c_bcount);\n\t\tprintf(\"\\tc_skip: %d\\n\", xfer->c_skip);\n\t\t/*\n\t\t * Call the interrupt routine. If we just missed and interrupt,\n\t\t * it will do what's needed. Else, it will take the needed\n\t\t * action (reset the device).\n\t\t */\n\t\txfer->c_flags |= C_TIMEOU;\n\t\tchp->ch_flags &= ~WDCF_IRQ_WAIT;\n\t\txfer->c_intr(chp, xfer, 1);\n\t} else\n\t\t__wdcerror(chp, \"missing untimeout\");\n\tsplx(s);\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_FUNCS  0x08"
          ],
          "globals_used": [
            "static void  __wdcerror"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_FUNCS  0x08\n\nstatic void  __wdcerror;\n\nvoid\nwdctimeout(arg)\n\tvoid *arg;\n{\n\tstruct channel_softc *chp = (struct channel_softc *)arg;\n\tstruct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;\n\tint s;\n\n\tWDCDEBUG_PRINT((\"wdctimeout\\n\"), DEBUG_FUNCS);\n\n\ts = splbio();\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) != 0) {\n\t\t__wdcerror(chp, \"timeout\");\n\t\tprintf(\"\\ttype: %s\\n\", (xfer->c_flags & C_ATAPI) ?\n\t\t    \"atapi\":\"ata\");\n\t\tprintf(\"\\tc_bcount: %d\\n\", xfer->c_bcount);\n\t\tprintf(\"\\tc_skip: %d\\n\", xfer->c_skip);\n\t\t/*\n\t\t * Call the interrupt routine. If we just missed and interrupt,\n\t\t * it will do what's needed. Else, it will take the needed\n\t\t * action (reset the device).\n\t\t */\n\t\txfer->c_flags |= C_TIMEOU;\n\t\tchp->ch_flags &= ~WDCF_IRQ_WAIT;\n\t\txfer->c_intr(chp, xfer, 1);\n\t} else\n\t\t__wdcerror(chp, \"missing untimeout\");\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_INSERT_HEAD",
          "args": [
            "&ahc->pending_scbs",
            "scb",
            "pend_links"
          ],
          "line": 4309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"ahc bad sg_count\""
          ],
          "line": 4306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 4300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahcfreescb",
          "args": [
            "ahc",
            "scb"
          ],
          "line": 4299
        },
        "resolved": true,
        "details": {
          "function_name": "ahcfreescb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "617-648",
          "snippet": "STATIC void\nahcfreescb(ahc, scb)\n\tstruct ahc_softc *ahc;\n\tstruct scb *scb;\n{       \n\tstruct hardware_scb *hscb;\n\tint opri;\n\n\thscb = scb->hscb;\n\n#ifdef AHC_DEBUG\n\tif (ahc_debug & AHC_SHOWSCBALLOC)\n\t\tprintf(\"%s: free SCB tag %x\\n\", ahc_name(ahc), hscb->tag);\n#endif\n\n\topri = splbio();\n\n\tif ((ahc->flags & AHC_RESOURCE_SHORTAGE) != 0 ||\n\t    (scb->flags & SCB_RECOVERY_SCB) != 0) {\n\t\tahc->flags &= ~AHC_RESOURCE_SHORTAGE;\n\t\tahc->queue_blocked = 0;\n\t}\n\n\t/* Clean up for the next user */\n\tscb->flags = SCB_FREE;\n\thscb->control = 0;\n\thscb->status = 0;\n\n\tSLIST_INSERT_HEAD(&ahc->scb_data->free_scbs, scb, links);\n\n\tsplx(opri);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "ahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));",
            "STATIC int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_calc_residual __P((struct scb *scb));",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));\nSTATIC int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_calc_residual __P((struct scb *scb));\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahcfreescb(ahc, scb)\n\tstruct ahc_softc *ahc;\n\tstruct scb *scb;\n{       \n\tstruct hardware_scb *hscb;\n\tint opri;\n\n\thscb = scb->hscb;\n\n#ifdef AHC_DEBUG\n\tif (ahc_debug & AHC_SHOWSCBALLOC)\n\t\tprintf(\"%s: free SCB tag %x\\n\", ahc_name(ahc), hscb->tag);\n#endif\n\n\topri = splbio();\n\n\tif ((ahc->flags & AHC_RESOURCE_SHORTAGE) != 0 ||\n\t    (scb->flags & SCB_RECOVERY_SCB) != 0) {\n\t\tahc->flags &= ~AHC_RESOURCE_SHORTAGE;\n\t\tahc->queue_blocked = 0;\n\t}\n\n\t/* Clean up for the next user */\n\tscb->flags = SCB_FREE;\n\thscb->control = 0;\n\thscb->status = 0;\n\n\tSLIST_INSERT_HEAD(&ahc->scb_data->free_scbs, scb, links);\n\n\tsplx(opri);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_dmamap_unload",
          "args": [
            "ahc->sc_dmat",
            "scb->dmamap"
          ],
          "line": 4298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_index_busy_tcl",
          "args": [
            "ahc",
            "scb->hscb->tcl",
            "TRUE"
          ],
          "line": 4296
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_index_busy_tcl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "497-513",
          "snippet": "static __inline u_int\nahc_index_busy_tcl(ahc, tcl, unbusy)\n\tstruct ahc_softc *ahc;\n\tu_int tcl;\n\tint unbusy;\n{\n\tu_int scbid;\n\n\tscbid = ahc->untagged_scbs[tcl];\n\tif (unbusy) {\n\t\tahc->untagged_scbs[tcl] = SCB_LIST_NULL;\n\t\tbus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, \n\t\t\t\tBUS_DMASYNC_PREWRITE);\n\t}\n\n\treturn (scbid);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC u_int",
            "STATIC struct",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC u_int",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "static __inline u_int ahc_index_busy_tcl",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC u_int;\nSTATIC struct;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC u_int;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nahc_clear_intstat __P((struct ahc_softc *ahc));\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nrestart_sequencer __P((struct ahc_softc *ahc));\nstatic __inline u_int ahc_index_busy_tcl;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nstatic __inline u_int\nahc_index_busy_tcl(ahc, tcl, unbusy)\n\tstruct ahc_softc *ahc;\n\tu_int tcl;\n\tint unbusy;\n{\n\tu_int scbid;\n\n\tscbid = ahc->untagged_scbs[tcl];\n\tif (unbusy) {\n\t\tahc->untagged_scbs[tcl] = SCB_LIST_NULL;\n\t\tbus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, \n\t\t\t\tBUS_DMASYNC_PREWRITE);\n\t}\n\n\treturn (scbid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_istagged_device",
          "args": [
            "ahc",
            "xs"
          ],
          "line": 4295
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_istagged_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "5823-5842",
          "snippet": "STATIC int\nahc_istagged_device(ahc, xs)\nstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n{\n\tchar channel;\n\tu_int our_id, target;\n\tstruct tmode_tstate *tstate;\n\tstruct ahc_devinfo devinfo;\n\n\tchannel = SIM_CHANNEL(ahc, xs->sc_link);\n\tour_id = SIM_SCSI_ID(ahc, xs->sc_link);\n\ttarget = xs->sc_link->target;\n\t(void)ahc_fetch_transinfo(ahc, channel, our_id, target, &tstate);\n\n\tahc_compile_devinfo(&devinfo, our_id, target,\n\t    xs->sc_link->lun, channel, ROLE_INITIATOR);\n\n\treturn (tstate->tagenable & devinfo.target_mask);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "ahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC int",
            "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));",
            "STATIC int",
            "STATIC int",
            "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
            "STATIC void",
            "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "static __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "u_int our_id;",
            "struct tmode_tstate **tstate;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *xs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));\nSTATIC int;\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nSTATIC void;\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nu_int our_id;\nstruct tmode_tstate **tstate;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n\nSTATIC int\nahc_istagged_device(ahc, xs)\nstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n{\n\tchar channel;\n\tu_int our_id, target;\n\tstruct tmode_tstate *tstate;\n\tstruct ahc_devinfo devinfo;\n\n\tchannel = SIM_CHANNEL(ahc, xs->sc_link);\n\tour_id = SIM_SCSI_ID(ahc, xs->sc_link);\n\ttarget = xs->sc_link->target;\n\t(void)ahc_fetch_transinfo(ahc, channel, our_id, target, &tstate);\n\n\tahc_compile_devinfo(&devinfo, our_id, target,\n\t    xs->sc_link->lun, channel, ROLE_INITIATOR);\n\n\treturn (tstate->tagenable & devinfo.target_mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 4288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_sync",
          "args": [
            "ahc->sc_dmat",
            "scb->dmamap",
            "op"
          ],
          "line": 4279
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nahc_shutdown __P((void *arg));\nSTATIC int;\nahc_execute_scb __P((void *arg, bus_dma_segment_t *dm_segs,\n\t\t\t\t     int nsegments));\nSTATIC int;\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nSTATIC void;\nahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nSTATIC void;\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_calc_residual __P((struct scb *scb));\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nSTATIC void;\nstatic __inline void pause_sequencer;\nstatic __inline void unpause_sequencer;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nstatic __inline u_int ahc_index_busy_tcl;\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n\nSTATIC int\nahc_execute_scb(arg, dm_segs, nsegments)\n\tvoid *arg;\n\tbus_dma_segment_t *dm_segs;\n\tint nsegments;\n{\n\tstruct\t scb *scb;\n\tstruct scsi_xfer *xs;\n\tstruct\t ahc_softc *ahc;\n\tint\t s;\n\n\tscb = (struct scb *)arg;\n\txs = scb->xs;\n\tahc = (struct ahc_softc *)xs->sc_link->adapter_softc;\n\n\n\tif (nsegments != 0) {\n\t\tstruct\t  ahc_dma_seg *sg;\n\t\tbus_dma_segment_t *end_seg;\n\t\tbus_dmasync_op_t op;\n\n\t\tend_seg = dm_segs + nsegments;\n\n\t\t/* Copy the first SG into the data pointer area */\n\t\tscb->hscb->data = dm_segs->ds_addr;\n\t\tscb->hscb->datalen = dm_segs->ds_len;\n\n\t\t/* Copy the segments into our SG list */\n\t\tsg = scb->sg_list;\n\t\twhile (dm_segs < end_seg) {\n\t\t\tsg->addr = dm_segs->ds_addr;\n\t\t\tsg->len = dm_segs->ds_len;\n\t\t\tsg++;\n\t\t\tdm_segs++;\n\t\t}\n\n\t\t/* Note where to find the SG entries in bus space */\n\t\tscb->hscb->SG_pointer = scb->sg_list_phys;\n\t\tif ((scb->xs->flags & SCSI_DATA_IN) != 0)\n\t\t\top = BUS_DMASYNC_PREREAD;\n\t\telse\n\t\t\top = BUS_DMASYNC_PREWRITE;\n\t\tbus_dmamap_sync(ahc->sc_dmat, scb->dmamap, op);\n\t} else {\n\t\tscb->hscb->SG_pointer = 0;\n\t\tscb->hscb->data = 0;\n\t\tscb->hscb->datalen = 0;\n\t}\n\t\n\tscb->sg_count = scb->hscb->SG_count = nsegments;\n\n\ts = splbio();\n\n\t/*\n\t * Last time we need to check if this SCB needs to\n\t * be aborted.\n\t */\n\tif (xs->flags & ITSDONE) {\n\t\tif (!ahc_istagged_device(ahc, xs))\n\t\t\tahc_index_busy_tcl(ahc, scb->hscb->tcl, TRUE);\n\t\tif (nsegments != 0)\n\t\t\tbus_dmamap_unload(ahc->sc_dmat, scb->dmamap);\n\t\tahcfreescb(ahc, scb);\n\t\tsplx(s);\n\t\treturn (COMPLETE);\n\t}\n\n#ifdef DIAGNOSTIC\n\tif (scb->sg_count > 255)\n\t\tpanic(\"ahc bad sg_count\");\n#endif\n\t\t\n\tLIST_INSERT_HEAD(&ahc->pending_scbs, scb, pend_links);\n\n\tscb->flags |= SCB_ACTIVE;\n\n\tif (!(xs->flags & SCSI_POLL))\n\ttimeout(ahc_timeout, (caddr_t)scb, \n\t\t    (xs->timeout * hz) / 1000);\n\n\tif ((scb->flags & SCB_TARGET_IMMEDIATE) != 0) {\n#if 0\n\t\tprintf(\"Continueing Immediate Command %d:%d\\n\",\n\t\t       xs->sc_link->target,\n\t\t       xs->sc_link->lun);\n#endif\n\t\tpause_sequencer(ahc);\n\t\tif ((ahc->flags & AHC_PAGESCBS) == 0)\n\t\t\tahc_outb(ahc, SCBPTR, scb->hscb->tag);\n\t\tahc_outb(ahc, SCB_TAG, scb->hscb->tag);\n\t\tahc_outb(ahc, RETURN_1, CONT_MSG_LOOP);\n\t\tunpause_sequencer(ahc);\n\t} else {\n\n\t\tahc->qinfifo[ahc->qinfifonext++] = scb->hscb->tag;\n\n\t\tbus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, \n\t\t\t\tBUS_DMASYNC_PREWRITE);\n\t\t\n\t\tif ((ahc->features & AHC_QUEUE_REGS) != 0) {\n\t\t\tahc_outb(ahc, HNSCB_QOFF, ahc->qinfifonext);\n\t\t} else {\n\t\t\tpause_sequencer(ahc);\n\t\t\tahc_outb(ahc, KERNEL_QINPOS, ahc->qinfifonext);\n\t\t\tunpause_sequencer(ahc);\n\t\t}\n\t}\n\n#ifdef AHC_DEBUG\n\tif (ahc_debug & AHC_SHOWCMDS) {\n\t\tsc_print_addr(xs->sc_link);\n\t\tprintf(\"opcode %d tag %x len %d flags %x control %x fpos %u\"\n\t\t    \" rate %x\\n\",\n\t\t    xs->cmdstore.opcode, scb->hscb->tag, scb->hscb->datalen,\n\t\t    scb->flags, scb->hscb->control, ahc->qinfifonext,\n\t\t    scb->hscb->scsirate);\n\t}\n#endif\n\n\tif (!(xs->flags & SCSI_POLL)) {\n\t\tsplx(s);\n\t\treturn (SUCCESSFULLY_QUEUED);\n\t}\n\t/*\n\t * If we can't use interrupts, poll for completion\n\t */\n\tSC_DEBUG(xs->sc_link, SDEV_DB3, (\"cmd_poll\\n\"));\n\tdo {\n\t\tif (ahc_poll(ahc, xs->timeout)) {\n\t\t\tif (!(xs->flags & SCSI_SILENT))\n\t\t\t\tprintf(\"cmd fail\\n\");\n\t\t\tahc_timeout(scb);\n\t\t\tbreak;\n\t\t}\n\t} while (!(xs->flags & ITSDONE));\n\tsplx(s);\n\treturn (COMPLETE);\n}"
  },
  {
    "function_name": "ahc_scsi_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "4050-4235",
    "snippet": "STATIC int32_t\nahc_scsi_cmd(xs)\n\tstruct scsi_xfer *xs;\n{\n\tstruct scsi_xfer *first_xs, *next_xs = NULL;\n\tstruct ahc_softc *ahc;\n\tstruct scb *scb;\n\tstruct hardware_scb *hscb;\t\n\tstruct ahc_initiator_tinfo *tinfo;\n\tstruct tmode_tstate *tstate;\n\tu_int target_id;\n\tu_int our_id;\n\tint s, tcl;\n\tu_int16_t mask;\n\tint dontqueue = 0, fromqueue = 0;\n\n\tSC_DEBUG(xs->sc_link, SDEV_DB3, (\"ahc_scsi_cmd\\n\"));\n\tahc = (struct ahc_softc *)xs->sc_link->adapter_softc;\n\n\t/* must protect the queue */\n\ts = splbio();\n\n\tif (xs == ahc->sc_xxxq.lh_first) {\n\t\t/*\n\t\t * Called from ahc_done. Calling with the first entry in\n\t\t * the queue is really just a way of seeing where we're\n\t\t * called from. Now, find the first eligible SCB to send,\n\t\t * e.g. one which will be accepted immediately.\n\t\t */\n\n\t\tif (ahc->queue_blocked) {\n\t\t\tsplx(s);\n\t\t\treturn (TRY_AGAIN_LATER);\n\t\t}\n\n\t\txs = ahc_first_xs(ahc);\n\t\tif (xs == NULL) {\n\t\t\tsplx(s);\n\t\t\treturn (TRY_AGAIN_LATER);\n\t\t}\n\n\t\tnext_xs = ahc_list_next(ahc, xs);\n\t\tahc_list_remove(ahc, xs);\n\t\tfromqueue = 1;\n\t\tgoto get_scb;\n\t}\n\n\t/* determine safety of software queueing */\n\tdontqueue = xs->flags & SCSI_POLL;\n\t\n\t/*\n\t * If no new requests are accepted, just insert into the\n\t * private queue to wait for our turn.\n\t */\n\ttcl = XS_TCL(ahc, xs);\n\n\tif (ahc->queue_blocked ||\n\t    ahc->devqueue_blocked[xs->sc_link->target] ||\n\t    (!ahc_istagged_device(ahc, xs) &&\n\t     ahc_index_busy_tcl(ahc, tcl, FALSE) != SCB_LIST_NULL)) {\n\t\tif (dontqueue) {\n\t\t\tsplx(s);\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\treturn TRY_AGAIN_LATER;\n\t\t}\n\t\tahc_list_insert_tail(ahc, xs);\n\t\tsplx(s);\n\t\treturn SUCCESSFULLY_QUEUED;\n\t}\n\n\tfirst_xs = ahc_first_xs(ahc);\n\n\t/* determine safety of software queueing */\n\tdontqueue = xs->flags & SCSI_POLL;\n\n\t/*\n\t * Handle situations where there's already entries in the\n\t * queue.\n\t */\n\tif (first_xs != NULL) {\n\t\t/*\n\t\t * If we can't queue, we have to abort, since\n\t\t * we have to preserve order.\n\t\t */\n\t\tif (dontqueue) {\n\t\t\tsplx(s);\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\treturn (TRY_AGAIN_LATER);\n\t\t}\n\n\t\t/*\n\t\t * Swap with the first queue entry.\n\t\t */\n\t\tahc_list_insert_tail(ahc, xs);\n\t\txs = first_xs;\n\t\tnext_xs = ahc_list_next(ahc, xs);\n\t\tahc_list_remove(ahc, xs);\n\t\tfromqueue = 1;\n\n\t}\n\nget_scb:\n\n\ttarget_id = xs->sc_link->target;\n\tour_id = SIM_SCSI_ID(ahc, xs->sc_link);\n\n\t/*\n\t * get an scb to use.\n\t */\n\tif ((scb = ahcgetscb(ahc)) == NULL) {\n\n\t\tif (dontqueue) {\n\t\t\tsplx(s);\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\treturn (TRY_AGAIN_LATER);\n\t\t}\n\n\t\t/*\n\t\t * If we were pulled off the queue, put ourselves\n\t\t * back to where we came from, otherwise tack ourselves\n\t\t * onto the end.\n\t\t */\n\t\tif (fromqueue && next_xs != NULL)\n\t\t\tahc_list_insert_before(ahc, xs, next_xs);\n\t\telse\n\t\t\tahc_list_insert_tail(ahc, xs);\n\n\t\tsplx(s);\n\t\treturn (SUCCESSFULLY_QUEUED);\n\t}\n\n\ttcl = XS_TCL(ahc, xs);\n\n#ifdef DIAGNOSTIC\n\tif (ahc_index_busy_tcl(ahc, tcl, FALSE) != SCB_LIST_NULL)\n\t\tpanic(\"ahc: queuing for busy target\");\n#endif\n\t\n\tscb->xs = xs;\n\thscb = scb->hscb;\n\thscb->tcl = tcl;\n\n\tif (ahc_istagged_device(ahc, xs))\n\t\tscb->hscb->control |= MSG_SIMPLE_Q_TAG;\n\telse\n\t\tahc_busy_tcl(ahc, scb);\n\n\tsplx(s);\n \n\t/*\n\t * Put all the arguments for the xfer in the scb\n\t */\n\n\tmask = SCB_TARGET_MASK(scb);\n\ttinfo = ahc_fetch_transinfo(ahc, SIM_CHANNEL(ahc, xs->sc_link), our_id,\n\t\t\t\t    target_id, &tstate);\n\tif (ahc->inited_targets[target_id] == 0) {\n\t\tstruct ahc_devinfo devinfo;\n\n\t\ts = splbio();\n\t\tahc_compile_devinfo(&devinfo, our_id, target_id,\n\t\t    xs->sc_link->lun, SIM_CHANNEL(ahc, xs->sc_link),\n\t\t    ROLE_INITIATOR);\n\t\tahc_update_target_msg_request(ahc, &devinfo, tinfo, TRUE,\n\t\t    FALSE);\n\t\tahc->inited_targets[target_id] = 1;\n\t\tsplx(s);\n\t}\n\n\thscb->scsirate = tinfo->scsirate;\n\thscb->scsioffset = tinfo->current.offset;\n\tif ((tstate->ultraenb & mask) != 0)\n\t\thscb->control |= ULTRAENB;\n\t\t\n\tif ((tstate->discenable & mask) != 0)\n\t\thscb->control |= DISCENB;\n\n\tif (xs->flags & SCSI_RESET) {\n\t\thscb->cmdpointer = NULL;\n\t\tscb->flags |= SCB_DEVICE_RESET;\n\t\thscb->control |= MK_MESSAGE;\n\t\treturn ahc_execute_scb(scb, NULL, 0);\n\t}\n\n\treturn ahc_setup_data(ahc, xs, scb);\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define STATIC\tstatic",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "STATIC int",
      "ahc_poll __P((struct ahc_softc *ahc, int wait));",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
      "STATIC void",
      "ahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));",
      "STATIC void",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
      "STATIC void",
      "STATIC u_int",
      "STATIC void",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
      "STATIC void",
      "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
      "STATIC void",
      "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
      "STATIC int",
      "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
      "STATIC void",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));",
      "STATIC int",
      "STATIC int",
      "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
      "STATIC void",
      "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
      "STATIC void",
      "STATIC void",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC u_int",
      "STATIC void",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "STATIC u_int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
      "STATIC void",
      "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
      "STATIC void",
      "ahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));",
      "STATIC void",
      "STATIC void",
      "ahc_calc_residual __P((struct scb *scb));",
      "STATIC void",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
      "STATIC void",
      "STATIC void",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "static __inline u_int ahc_index_busy_tcl",
      "static __inline void\tahc_busy_tcl",
      "STATIC void",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "static __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo",
      "STATIC void",
      "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
      "static __inline struct scb *ahcgetscb",
      "STATIC void",
      "STATIC void",
      "struct scsi_xfer *ahc_first_xs",
      "void   ahc_list_insert_before",
      "void   ahc_list_insert_tail",
      "void   ahc_list_remove",
      "struct scsi_xfer *ahc_list_next",
      "STATIC int32_t",
      "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "u_int our_id;",
      "struct tmode_tstate **tstate;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *xs;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ahc_setup_data",
          "args": [
            "ahc",
            "xs",
            "scb"
          ],
          "line": 4234
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_setup_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "4396-4432",
          "snippet": "STATIC int\nahc_setup_data(ahc, xs, scb)\n\tstruct ahc_softc *ahc;\n\tstruct scsi_xfer *xs;\n\tstruct scb *scb;\n{\n\tstruct hardware_scb *hscb;\n\t\n\thscb = scb->hscb;\n\txs->resid = xs->status = 0;\n\t\n\thscb->cmdlen = xs->cmdlen;\n\tbcopy(xs->cmd, hscb->cmdstore, xs->cmdlen);\n\thscb->cmdpointer = hscb->cmdstore_busaddr;\n\n\t/* Only use S/G if there is a transfer */\n\tif (xs->datalen) {\n\t\tint error;\n\n\t\terror = bus_dmamap_load(ahc->sc_dmat,\n\t\t\t    scb->dmamap, xs->data,\n\t\t\t    xs->datalen, NULL,\n\t\t\t    (xs->flags & SCSI_NOSLEEP) ?\n\t\t\t    BUS_DMA_NOWAIT : BUS_DMA_WAITOK);\n\t\tif (error) {\n\t\t\tif (!ahc_istagged_device(ahc, xs))\n\t\t\t\tahc_index_busy_tcl(ahc, hscb->tcl, TRUE);\n\t\t\treturn (TRY_AGAIN_LATER);\t/* XXX fvdl */\n\t\t}\n\t\terror = ahc_execute_scb(scb,\n\t\t    scb->dmamap->dm_segs,\n\t\t    scb->dmamap->dm_nsegs);\n\t\treturn error;\n\t} else {\n\t\treturn ahc_execute_scb(scb, NULL, 0);\n\t}\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "ahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));",
            "STATIC int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
            "STATIC void",
            "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_calc_residual __P((struct scb *scb));",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "static __inline u_int ahc_index_busy_tcl",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *xs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));\nSTATIC int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nSTATIC void;\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_calc_residual __P((struct scb *scb));\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nstatic __inline u_int ahc_index_busy_tcl;\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n\nSTATIC int\nahc_setup_data(ahc, xs, scb)\n\tstruct ahc_softc *ahc;\n\tstruct scsi_xfer *xs;\n\tstruct scb *scb;\n{\n\tstruct hardware_scb *hscb;\n\t\n\thscb = scb->hscb;\n\txs->resid = xs->status = 0;\n\t\n\thscb->cmdlen = xs->cmdlen;\n\tbcopy(xs->cmd, hscb->cmdstore, xs->cmdlen);\n\thscb->cmdpointer = hscb->cmdstore_busaddr;\n\n\t/* Only use S/G if there is a transfer */\n\tif (xs->datalen) {\n\t\tint error;\n\n\t\terror = bus_dmamap_load(ahc->sc_dmat,\n\t\t\t    scb->dmamap, xs->data,\n\t\t\t    xs->datalen, NULL,\n\t\t\t    (xs->flags & SCSI_NOSLEEP) ?\n\t\t\t    BUS_DMA_NOWAIT : BUS_DMA_WAITOK);\n\t\tif (error) {\n\t\t\tif (!ahc_istagged_device(ahc, xs))\n\t\t\t\tahc_index_busy_tcl(ahc, hscb->tcl, TRUE);\n\t\t\treturn (TRY_AGAIN_LATER);\t/* XXX fvdl */\n\t\t}\n\t\terror = ahc_execute_scb(scb,\n\t\t    scb->dmamap->dm_segs,\n\t\t    scb->dmamap->dm_nsegs);\n\t\treturn error;\n\t} else {\n\t\treturn ahc_execute_scb(scb, NULL, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_execute_scb",
          "args": [
            "scb",
            "NULL",
            "0"
          ],
          "line": 4231
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_execute_scb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "4237-4374",
          "snippet": "STATIC int\nahc_execute_scb(arg, dm_segs, nsegments)\n\tvoid *arg;\n\tbus_dma_segment_t *dm_segs;\n\tint nsegments;\n{\n\tstruct\t scb *scb;\n\tstruct scsi_xfer *xs;\n\tstruct\t ahc_softc *ahc;\n\tint\t s;\n\n\tscb = (struct scb *)arg;\n\txs = scb->xs;\n\tahc = (struct ahc_softc *)xs->sc_link->adapter_softc;\n\n\n\tif (nsegments != 0) {\n\t\tstruct\t  ahc_dma_seg *sg;\n\t\tbus_dma_segment_t *end_seg;\n\t\tbus_dmasync_op_t op;\n\n\t\tend_seg = dm_segs + nsegments;\n\n\t\t/* Copy the first SG into the data pointer area */\n\t\tscb->hscb->data = dm_segs->ds_addr;\n\t\tscb->hscb->datalen = dm_segs->ds_len;\n\n\t\t/* Copy the segments into our SG list */\n\t\tsg = scb->sg_list;\n\t\twhile (dm_segs < end_seg) {\n\t\t\tsg->addr = dm_segs->ds_addr;\n\t\t\tsg->len = dm_segs->ds_len;\n\t\t\tsg++;\n\t\t\tdm_segs++;\n\t\t}\n\n\t\t/* Note where to find the SG entries in bus space */\n\t\tscb->hscb->SG_pointer = scb->sg_list_phys;\n\t\tif ((scb->xs->flags & SCSI_DATA_IN) != 0)\n\t\t\top = BUS_DMASYNC_PREREAD;\n\t\telse\n\t\t\top = BUS_DMASYNC_PREWRITE;\n\t\tbus_dmamap_sync(ahc->sc_dmat, scb->dmamap, op);\n\t} else {\n\t\tscb->hscb->SG_pointer = 0;\n\t\tscb->hscb->data = 0;\n\t\tscb->hscb->datalen = 0;\n\t}\n\t\n\tscb->sg_count = scb->hscb->SG_count = nsegments;\n\n\ts = splbio();\n\n\t/*\n\t * Last time we need to check if this SCB needs to\n\t * be aborted.\n\t */\n\tif (xs->flags & ITSDONE) {\n\t\tif (!ahc_istagged_device(ahc, xs))\n\t\t\tahc_index_busy_tcl(ahc, scb->hscb->tcl, TRUE);\n\t\tif (nsegments != 0)\n\t\t\tbus_dmamap_unload(ahc->sc_dmat, scb->dmamap);\n\t\tahcfreescb(ahc, scb);\n\t\tsplx(s);\n\t\treturn (COMPLETE);\n\t}\n\n#ifdef DIAGNOSTIC\n\tif (scb->sg_count > 255)\n\t\tpanic(\"ahc bad sg_count\");\n#endif\n\t\t\n\tLIST_INSERT_HEAD(&ahc->pending_scbs, scb, pend_links);\n\n\tscb->flags |= SCB_ACTIVE;\n\n\tif (!(xs->flags & SCSI_POLL))\n\ttimeout(ahc_timeout, (caddr_t)scb, \n\t\t    (xs->timeout * hz) / 1000);\n\n\tif ((scb->flags & SCB_TARGET_IMMEDIATE) != 0) {\n#if 0\n\t\tprintf(\"Continueing Immediate Command %d:%d\\n\",\n\t\t       xs->sc_link->target,\n\t\t       xs->sc_link->lun);\n#endif\n\t\tpause_sequencer(ahc);\n\t\tif ((ahc->flags & AHC_PAGESCBS) == 0)\n\t\t\tahc_outb(ahc, SCBPTR, scb->hscb->tag);\n\t\tahc_outb(ahc, SCB_TAG, scb->hscb->tag);\n\t\tahc_outb(ahc, RETURN_1, CONT_MSG_LOOP);\n\t\tunpause_sequencer(ahc);\n\t} else {\n\n\t\tahc->qinfifo[ahc->qinfifonext++] = scb->hscb->tag;\n\n\t\tbus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, \n\t\t\t\tBUS_DMASYNC_PREWRITE);\n\t\t\n\t\tif ((ahc->features & AHC_QUEUE_REGS) != 0) {\n\t\t\tahc_outb(ahc, HNSCB_QOFF, ahc->qinfifonext);\n\t\t} else {\n\t\t\tpause_sequencer(ahc);\n\t\t\tahc_outb(ahc, KERNEL_QINPOS, ahc->qinfifonext);\n\t\t\tunpause_sequencer(ahc);\n\t\t}\n\t}\n\n#ifdef AHC_DEBUG\n\tif (ahc_debug & AHC_SHOWCMDS) {\n\t\tsc_print_addr(xs->sc_link);\n\t\tprintf(\"opcode %d tag %x len %d flags %x control %x fpos %u\"\n\t\t    \" rate %x\\n\",\n\t\t    xs->cmdstore.opcode, scb->hscb->tag, scb->hscb->datalen,\n\t\t    scb->flags, scb->hscb->control, ahc->qinfifonext,\n\t\t    scb->hscb->scsirate);\n\t}\n#endif\n\n\tif (!(xs->flags & SCSI_POLL)) {\n\t\tsplx(s);\n\t\treturn (SUCCESSFULLY_QUEUED);\n\t}\n\t/*\n\t * If we can't use interrupts, poll for completion\n\t */\n\tSC_DEBUG(xs->sc_link, SDEV_DB3, (\"cmd_poll\\n\"));\n\tdo {\n\t\tif (ahc_poll(ahc, xs->timeout)) {\n\t\t\tif (!(xs->flags & SCSI_SILENT))\n\t\t\t\tprintf(\"cmd fail\\n\");\n\t\t\tahc_timeout(scb);\n\t\t\tbreak;\n\t\t}\n\t} while (!(xs->flags & ITSDONE));\n\tsplx(s);\n\treturn (COMPLETE);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "ahc_shutdown __P((void *arg));",
            "STATIC int",
            "ahc_execute_scb __P((void *arg, bus_dma_segment_t *dm_segs,\n\t\t\t\t     int nsegments));",
            "STATIC int",
            "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
            "STATIC void",
            "ahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
            "STATIC void",
            "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_calc_residual __P((struct scb *scb));",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
            "STATIC void",
            "static __inline void pause_sequencer",
            "static __inline void unpause_sequencer",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "static __inline u_int ahc_index_busy_tcl",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *xs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nahc_shutdown __P((void *arg));\nSTATIC int;\nahc_execute_scb __P((void *arg, bus_dma_segment_t *dm_segs,\n\t\t\t\t     int nsegments));\nSTATIC int;\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nSTATIC void;\nahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nSTATIC void;\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_calc_residual __P((struct scb *scb));\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nSTATIC void;\nstatic __inline void pause_sequencer;\nstatic __inline void unpause_sequencer;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nstatic __inline u_int ahc_index_busy_tcl;\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n\nSTATIC int\nahc_execute_scb(arg, dm_segs, nsegments)\n\tvoid *arg;\n\tbus_dma_segment_t *dm_segs;\n\tint nsegments;\n{\n\tstruct\t scb *scb;\n\tstruct scsi_xfer *xs;\n\tstruct\t ahc_softc *ahc;\n\tint\t s;\n\n\tscb = (struct scb *)arg;\n\txs = scb->xs;\n\tahc = (struct ahc_softc *)xs->sc_link->adapter_softc;\n\n\n\tif (nsegments != 0) {\n\t\tstruct\t  ahc_dma_seg *sg;\n\t\tbus_dma_segment_t *end_seg;\n\t\tbus_dmasync_op_t op;\n\n\t\tend_seg = dm_segs + nsegments;\n\n\t\t/* Copy the first SG into the data pointer area */\n\t\tscb->hscb->data = dm_segs->ds_addr;\n\t\tscb->hscb->datalen = dm_segs->ds_len;\n\n\t\t/* Copy the segments into our SG list */\n\t\tsg = scb->sg_list;\n\t\twhile (dm_segs < end_seg) {\n\t\t\tsg->addr = dm_segs->ds_addr;\n\t\t\tsg->len = dm_segs->ds_len;\n\t\t\tsg++;\n\t\t\tdm_segs++;\n\t\t}\n\n\t\t/* Note where to find the SG entries in bus space */\n\t\tscb->hscb->SG_pointer = scb->sg_list_phys;\n\t\tif ((scb->xs->flags & SCSI_DATA_IN) != 0)\n\t\t\top = BUS_DMASYNC_PREREAD;\n\t\telse\n\t\t\top = BUS_DMASYNC_PREWRITE;\n\t\tbus_dmamap_sync(ahc->sc_dmat, scb->dmamap, op);\n\t} else {\n\t\tscb->hscb->SG_pointer = 0;\n\t\tscb->hscb->data = 0;\n\t\tscb->hscb->datalen = 0;\n\t}\n\t\n\tscb->sg_count = scb->hscb->SG_count = nsegments;\n\n\ts = splbio();\n\n\t/*\n\t * Last time we need to check if this SCB needs to\n\t * be aborted.\n\t */\n\tif (xs->flags & ITSDONE) {\n\t\tif (!ahc_istagged_device(ahc, xs))\n\t\t\tahc_index_busy_tcl(ahc, scb->hscb->tcl, TRUE);\n\t\tif (nsegments != 0)\n\t\t\tbus_dmamap_unload(ahc->sc_dmat, scb->dmamap);\n\t\tahcfreescb(ahc, scb);\n\t\tsplx(s);\n\t\treturn (COMPLETE);\n\t}\n\n#ifdef DIAGNOSTIC\n\tif (scb->sg_count > 255)\n\t\tpanic(\"ahc bad sg_count\");\n#endif\n\t\t\n\tLIST_INSERT_HEAD(&ahc->pending_scbs, scb, pend_links);\n\n\tscb->flags |= SCB_ACTIVE;\n\n\tif (!(xs->flags & SCSI_POLL))\n\ttimeout(ahc_timeout, (caddr_t)scb, \n\t\t    (xs->timeout * hz) / 1000);\n\n\tif ((scb->flags & SCB_TARGET_IMMEDIATE) != 0) {\n#if 0\n\t\tprintf(\"Continueing Immediate Command %d:%d\\n\",\n\t\t       xs->sc_link->target,\n\t\t       xs->sc_link->lun);\n#endif\n\t\tpause_sequencer(ahc);\n\t\tif ((ahc->flags & AHC_PAGESCBS) == 0)\n\t\t\tahc_outb(ahc, SCBPTR, scb->hscb->tag);\n\t\tahc_outb(ahc, SCB_TAG, scb->hscb->tag);\n\t\tahc_outb(ahc, RETURN_1, CONT_MSG_LOOP);\n\t\tunpause_sequencer(ahc);\n\t} else {\n\n\t\tahc->qinfifo[ahc->qinfifonext++] = scb->hscb->tag;\n\n\t\tbus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, \n\t\t\t\tBUS_DMASYNC_PREWRITE);\n\t\t\n\t\tif ((ahc->features & AHC_QUEUE_REGS) != 0) {\n\t\t\tahc_outb(ahc, HNSCB_QOFF, ahc->qinfifonext);\n\t\t} else {\n\t\t\tpause_sequencer(ahc);\n\t\t\tahc_outb(ahc, KERNEL_QINPOS, ahc->qinfifonext);\n\t\t\tunpause_sequencer(ahc);\n\t\t}\n\t}\n\n#ifdef AHC_DEBUG\n\tif (ahc_debug & AHC_SHOWCMDS) {\n\t\tsc_print_addr(xs->sc_link);\n\t\tprintf(\"opcode %d tag %x len %d flags %x control %x fpos %u\"\n\t\t    \" rate %x\\n\",\n\t\t    xs->cmdstore.opcode, scb->hscb->tag, scb->hscb->datalen,\n\t\t    scb->flags, scb->hscb->control, ahc->qinfifonext,\n\t\t    scb->hscb->scsirate);\n\t}\n#endif\n\n\tif (!(xs->flags & SCSI_POLL)) {\n\t\tsplx(s);\n\t\treturn (SUCCESSFULLY_QUEUED);\n\t}\n\t/*\n\t * If we can't use interrupts, poll for completion\n\t */\n\tSC_DEBUG(xs->sc_link, SDEV_DB3, (\"cmd_poll\\n\"));\n\tdo {\n\t\tif (ahc_poll(ahc, xs->timeout)) {\n\t\t\tif (!(xs->flags & SCSI_SILENT))\n\t\t\t\tprintf(\"cmd fail\\n\");\n\t\t\tahc_timeout(scb);\n\t\t\tbreak;\n\t\t}\n\t} while (!(xs->flags & ITSDONE));\n\tsplx(s);\n\treturn (COMPLETE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 4216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_update_target_msg_request",
          "args": [
            "ahc",
            "&devinfo",
            "tinfo",
            "TRUE",
            "FALSE"
          ],
          "line": 4213
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_update_target_msg_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "1250-1295",
          "snippet": "STATIC void\nahc_update_target_msg_request(ahc, devinfo, tinfo, force, paused)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n\tstruct ahc_initiator_tinfo *tinfo;\n\tint force;\n\tint paused;\n{\n\tu_int targ_msg_req_orig;\n\n\ttarg_msg_req_orig = ahc->targ_msg_req;\n\tif (tinfo->current.period != tinfo->goal.period\n\t    || tinfo->current.width != tinfo->goal.width\n\t    || tinfo->current.offset != tinfo->goal.offset\n\t    || (force && (tinfo->goal.period != 0\n\t    || tinfo->goal.width != MSG_EXT_WDTR_BUS_8_BIT)))\n\t\tahc->targ_msg_req |= devinfo->target_mask;\n\telse\n\t\tahc->targ_msg_req &= ~devinfo->target_mask;\n\n\tif (ahc->targ_msg_req != targ_msg_req_orig) {\n\t\t/* Update the message request bit for this target */\n\t\tif ((ahc->features & AHC_HS_MAILBOX) != 0) {\n\t\t\tif (paused) {\n\t\t\t\tahc_outb(ahc, TARGET_MSG_REQUEST,\n\t\t\t\t\t ahc->targ_msg_req & 0xFF);\n\t\t\t\tahc_outb(ahc, TARGET_MSG_REQUEST + 1,\n\t\t\t\t\t (ahc->targ_msg_req >> 8) & 0xFF);\n\t\t\t} else {\n\t\t\t\tahc_outb(ahc, HS_MAILBOX,\n\t\t\t\t\t 0x01 << HOST_MAILBOX_SHIFT);\n\t\t\t}\n\t\t} else {\n\t\t\tif (!paused)\n\t\t\t\tpause_sequencer(ahc);\n\n\t\t\tahc_outb(ahc, TARGET_MSG_REQUEST,\n\t\t\t\t ahc->targ_msg_req & 0xFF);\n\t\t\tahc_outb(ahc, TARGET_MSG_REQUEST + 1,\n\t\t\t\t (ahc->targ_msg_req >> 8) & 0xFF);\n\n\t\t\tif (!paused)\n\t\t\t\tunpause_sequencer(ahc);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC int",
            "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "ahc_update_target_msg_request __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t\t      struct ahc_initiator_tinfo *tinfo,\n\t\t\t\t\t      int force, int paused));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "static __inline void pause_sequencer",
            "static __inline void unpause_sequencer",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "u_int *period;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "u_int *period;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nahc_update_target_msg_request __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t\t      struct ahc_initiator_tinfo *tinfo,\n\t\t\t\t\t      int force, int paused));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nstatic __inline void pause_sequencer;\nstatic __inline void unpause_sequencer;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_update_target_msg_request(ahc, devinfo, tinfo, force, paused)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n\tstruct ahc_initiator_tinfo *tinfo;\n\tint force;\n\tint paused;\n{\n\tu_int targ_msg_req_orig;\n\n\ttarg_msg_req_orig = ahc->targ_msg_req;\n\tif (tinfo->current.period != tinfo->goal.period\n\t    || tinfo->current.width != tinfo->goal.width\n\t    || tinfo->current.offset != tinfo->goal.offset\n\t    || (force && (tinfo->goal.period != 0\n\t    || tinfo->goal.width != MSG_EXT_WDTR_BUS_8_BIT)))\n\t\tahc->targ_msg_req |= devinfo->target_mask;\n\telse\n\t\tahc->targ_msg_req &= ~devinfo->target_mask;\n\n\tif (ahc->targ_msg_req != targ_msg_req_orig) {\n\t\t/* Update the message request bit for this target */\n\t\tif ((ahc->features & AHC_HS_MAILBOX) != 0) {\n\t\t\tif (paused) {\n\t\t\t\tahc_outb(ahc, TARGET_MSG_REQUEST,\n\t\t\t\t\t ahc->targ_msg_req & 0xFF);\n\t\t\t\tahc_outb(ahc, TARGET_MSG_REQUEST + 1,\n\t\t\t\t\t (ahc->targ_msg_req >> 8) & 0xFF);\n\t\t\t} else {\n\t\t\t\tahc_outb(ahc, HS_MAILBOX,\n\t\t\t\t\t 0x01 << HOST_MAILBOX_SHIFT);\n\t\t\t}\n\t\t} else {\n\t\t\tif (!paused)\n\t\t\t\tpause_sequencer(ahc);\n\n\t\t\tahc_outb(ahc, TARGET_MSG_REQUEST,\n\t\t\t\t ahc->targ_msg_req & 0xFF);\n\t\t\tahc_outb(ahc, TARGET_MSG_REQUEST + 1,\n\t\t\t\t (ahc->targ_msg_req >> 8) & 0xFF);\n\n\t\t\tif (!paused)\n\t\t\t\tunpause_sequencer(ahc);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_compile_devinfo",
          "args": [
            "&devinfo",
            "our_id",
            "target_id",
            "xs->sc_link->lun",
            "SIM_CHANNEL(ahc, xs->sc_link)",
            "ROLE_INITIATOR"
          ],
          "line": 4210
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_compile_devinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "1568-1586",
          "snippet": "STATIC void\nahc_compile_devinfo(devinfo, our_id, target, lun, channel, role)\n\tstruct ahc_devinfo *devinfo;\n\tu_int our_id;\n\tu_int target;\n\tu_int lun;\n\tchar channel;\n\trole_t role;\n{\n\tdevinfo->our_scsiid = our_id;\n\tdevinfo->target = target;\n\tdevinfo->lun = lun;\n\tdevinfo->target_offset = target;\n\tdevinfo->channel = channel;\n\tdevinfo->role = role;\n\tif (channel == 'B')\n\t\tdevinfo->target_offset += 8;\n\tdevinfo->target_mask = (0x01 << devinfo->target_offset);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC int",
            "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "ahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "char channel;",
            "u_int our_id;",
            "STATIC struct",
            "STATIC struct",
            "STATIC struct",
            "char channel;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nchar channel;\nu_int our_id;\nSTATIC struct;\nSTATIC struct;\nSTATIC struct;\nchar channel;\n\nSTATIC void\nahc_compile_devinfo(devinfo, our_id, target, lun, channel, role)\n\tstruct ahc_devinfo *devinfo;\n\tu_int our_id;\n\tu_int target;\n\tu_int lun;\n\tchar channel;\n\trole_t role;\n{\n\tdevinfo->our_scsiid = our_id;\n\tdevinfo->target = target;\n\tdevinfo->lun = lun;\n\tdevinfo->target_offset = target;\n\tdevinfo->channel = channel;\n\tdevinfo->role = role;\n\tif (channel == 'B')\n\t\tdevinfo->target_offset += 8;\n\tdevinfo->target_mask = (0x01 << devinfo->target_offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIM_CHANNEL",
          "args": [
            "ahc",
            "xs->sc_link"
          ],
          "line": 4211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 4209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_fetch_transinfo",
          "args": [
            "ahc",
            "SIM_CHANNEL(ahc, xs->sc_link)",
            "our_id",
            "target_id",
            "&tstate"
          ],
          "line": 4204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIM_CHANNEL",
          "args": [
            "ahc",
            "xs->sc_link"
          ],
          "line": 4204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCB_TARGET_MASK",
          "args": [
            "scb"
          ],
          "line": 4203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 4197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_busy_tcl",
          "args": [
            "ahc",
            "scb"
          ],
          "line": 4195
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_busy_tcl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "515-523",
          "snippet": "static __inline void\nahc_busy_tcl(ahc, scb)\n\tstruct ahc_softc *ahc;\n\tstruct scb *scb;\n{\n\tahc->untagged_scbs[scb->hscb->tcl] = scb->hscb->tag;\n\tbus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, \n\t\t\tBUS_DMASYNC_PREWRITE);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "ahc_calc_residual __P((struct scb *scb));",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "static __inline void\tahc_busy_tcl",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC struct;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nahc_loadseq __P((struct ahc_softc *ahc));\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nahc_clear_intstat __P((struct ahc_softc *ahc));\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nahc_calc_residual __P((struct scb *scb));\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nrestart_sequencer __P((struct ahc_softc *ahc));\nstatic __inline void\tahc_busy_tcl;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nstatic __inline void\nahc_busy_tcl(ahc, scb)\n\tstruct ahc_softc *ahc;\n\tstruct scb *scb;\n{\n\tahc->untagged_scbs[scb->hscb->tcl] = scb->hscb->tag;\n\tbus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, \n\t\t\tBUS_DMASYNC_PREWRITE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_istagged_device",
          "args": [
            "ahc",
            "xs"
          ],
          "line": 4192
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_istagged_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "5823-5842",
          "snippet": "STATIC int\nahc_istagged_device(ahc, xs)\nstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n{\n\tchar channel;\n\tu_int our_id, target;\n\tstruct tmode_tstate *tstate;\n\tstruct ahc_devinfo devinfo;\n\n\tchannel = SIM_CHANNEL(ahc, xs->sc_link);\n\tour_id = SIM_SCSI_ID(ahc, xs->sc_link);\n\ttarget = xs->sc_link->target;\n\t(void)ahc_fetch_transinfo(ahc, channel, our_id, target, &tstate);\n\n\tahc_compile_devinfo(&devinfo, our_id, target,\n\t    xs->sc_link->lun, channel, ROLE_INITIATOR);\n\n\treturn (tstate->tagenable & devinfo.target_mask);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "ahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC int",
            "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));",
            "STATIC int",
            "STATIC int",
            "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
            "STATIC void",
            "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "static __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "u_int our_id;",
            "struct tmode_tstate **tstate;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *xs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));\nSTATIC int;\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nSTATIC void;\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nu_int our_id;\nstruct tmode_tstate **tstate;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n\nSTATIC int\nahc_istagged_device(ahc, xs)\nstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n{\n\tchar channel;\n\tu_int our_id, target;\n\tstruct tmode_tstate *tstate;\n\tstruct ahc_devinfo devinfo;\n\n\tchannel = SIM_CHANNEL(ahc, xs->sc_link);\n\tour_id = SIM_SCSI_ID(ahc, xs->sc_link);\n\ttarget = xs->sc_link->target;\n\t(void)ahc_fetch_transinfo(ahc, channel, our_id, target, &tstate);\n\n\tahc_compile_devinfo(&devinfo, our_id, target,\n\t    xs->sc_link->lun, channel, ROLE_INITIATOR);\n\n\treturn (tstate->tagenable & devinfo.target_mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"ahc: queuing for busy target\""
          ],
          "line": 4185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_index_busy_tcl",
          "args": [
            "ahc",
            "tcl",
            "FALSE"
          ],
          "line": 4184
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_index_busy_tcl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "497-513",
          "snippet": "static __inline u_int\nahc_index_busy_tcl(ahc, tcl, unbusy)\n\tstruct ahc_softc *ahc;\n\tu_int tcl;\n\tint unbusy;\n{\n\tu_int scbid;\n\n\tscbid = ahc->untagged_scbs[tcl];\n\tif (unbusy) {\n\t\tahc->untagged_scbs[tcl] = SCB_LIST_NULL;\n\t\tbus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, \n\t\t\t\tBUS_DMASYNC_PREWRITE);\n\t}\n\n\treturn (scbid);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC u_int",
            "STATIC struct",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC u_int",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "static __inline u_int ahc_index_busy_tcl",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC u_int;\nSTATIC struct;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC u_int;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nahc_clear_intstat __P((struct ahc_softc *ahc));\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nrestart_sequencer __P((struct ahc_softc *ahc));\nstatic __inline u_int ahc_index_busy_tcl;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nstatic __inline u_int\nahc_index_busy_tcl(ahc, tcl, unbusy)\n\tstruct ahc_softc *ahc;\n\tu_int tcl;\n\tint unbusy;\n{\n\tu_int scbid;\n\n\tscbid = ahc->untagged_scbs[tcl];\n\tif (unbusy) {\n\t\tahc->untagged_scbs[tcl] = SCB_LIST_NULL;\n\t\tbus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, \n\t\t\t\tBUS_DMASYNC_PREWRITE);\n\t}\n\n\treturn (scbid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XS_TCL",
          "args": [
            "ahc",
            "xs"
          ],
          "line": 4181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 4177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_list_insert_tail",
          "args": [
            "ahc",
            "xs"
          ],
          "line": 4175
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_list_insert_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "3982-3994",
          "snippet": "void\nahc_list_insert_tail(ahc, xs)\n\tstruct ahc_softc *ahc;\n\tstruct scsi_xfer *xs;\n{\n\tif (ahc->sc_xxxq.lh_first == NULL){\n\t\tahc->sc_xxxqlast = xs;\n\t\tLIST_INSERT_HEAD(&ahc->sc_xxxq, xs, free_list);\n\t\treturn;\n\t}\n\tLIST_INSERT_AFTER(ahc->sc_xxxqlast, xs, free_list);\n\tahc->sc_xxxqlast = xs;\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
            "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "void   ahc_list_insert_tail",
            "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *xs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC struct;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nahc_loadseq __P((struct ahc_softc *ahc));\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nahc_clear_intstat __P((struct ahc_softc *ahc));\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nrestart_sequencer __P((struct ahc_softc *ahc));\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nvoid   ahc_list_insert_tail;\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n\nvoid\nahc_list_insert_tail(ahc, xs)\n\tstruct ahc_softc *ahc;\n\tstruct scsi_xfer *xs;\n{\n\tif (ahc->sc_xxxq.lh_first == NULL){\n\t\tahc->sc_xxxqlast = xs;\n\t\tLIST_INSERT_HEAD(&ahc->sc_xxxq, xs, free_list);\n\t\treturn;\n\t}\n\tLIST_INSERT_AFTER(ahc->sc_xxxqlast, xs, free_list);\n\tahc->sc_xxxqlast = xs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_list_insert_before",
          "args": [
            "ahc",
            "xs",
            "next_xs"
          ],
          "line": 4173
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_list_insert_before",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "3961-3969",
          "snippet": "void\nahc_list_insert_before(ahc, xs, next_xs)\n\tstruct ahc_softc *ahc;\n\tstruct scsi_xfer *xs;\n\tstruct scsi_xfer *next_xs;\n{\n\tLIST_INSERT_BEFORE(xs, next_xs, free_list); \n\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
            "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "void   ahc_list_insert_before",
            "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *xs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC struct;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nahc_loadseq __P((struct ahc_softc *ahc));\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nahc_clear_intstat __P((struct ahc_softc *ahc));\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nrestart_sequencer __P((struct ahc_softc *ahc));\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nvoid   ahc_list_insert_before;\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n\nvoid\nahc_list_insert_before(ahc, xs, next_xs)\n\tstruct ahc_softc *ahc;\n\tstruct scsi_xfer *xs;\n\tstruct scsi_xfer *next_xs;\n{\n\tLIST_INSERT_BEFORE(xs, next_xs, free_list); \n\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 4162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahcgetscb",
          "args": [
            "ahc"
          ],
          "line": 4159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIM_SCSI_ID",
          "args": [
            "ahc",
            "xs->sc_link"
          ],
          "line": 4154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_list_remove",
          "args": [
            "ahc",
            "xs"
          ],
          "line": 4146
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_list_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "3996-4016",
          "snippet": "void\nahc_list_remove(ahc, xs)\n\tstruct ahc_softc *ahc;\n\tstruct scsi_xfer *xs;\n{\n\tstruct scsi_xfer *lxs;\n\tif (xs == ahc->sc_xxxqlast) {\n\t\tlxs = ahc->sc_xxxq.lh_first;\n\t\twhile (lxs != NULL) {\n\t\t\tif (LIST_NEXT(lxs, free_list) == ahc->sc_xxxqlast) {\n                                ahc->sc_xxxqlast = lxs;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlxs = LIST_NEXT(xs, free_list);\n\t\t}\n\t}\n\t\n\tLIST_REMOVE(xs, free_list);\n\tif (ahc->sc_xxxq.lh_first == NULL)\n\t\tahc->sc_xxxqlast = NULL;\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
            "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "void   ahc_list_remove",
            "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *xs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC struct;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nahc_loadseq __P((struct ahc_softc *ahc));\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nahc_clear_intstat __P((struct ahc_softc *ahc));\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nrestart_sequencer __P((struct ahc_softc *ahc));\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nvoid   ahc_list_remove;\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n\nvoid\nahc_list_remove(ahc, xs)\n\tstruct ahc_softc *ahc;\n\tstruct scsi_xfer *xs;\n{\n\tstruct scsi_xfer *lxs;\n\tif (xs == ahc->sc_xxxqlast) {\n\t\tlxs = ahc->sc_xxxq.lh_first;\n\t\twhile (lxs != NULL) {\n\t\t\tif (LIST_NEXT(lxs, free_list) == ahc->sc_xxxqlast) {\n                                ahc->sc_xxxqlast = lxs;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlxs = LIST_NEXT(xs, free_list);\n\t\t}\n\t}\n\t\n\tLIST_REMOVE(xs, free_list);\n\tif (ahc->sc_xxxq.lh_first == NULL)\n\t\tahc->sc_xxxqlast = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_list_next",
          "args": [
            "ahc",
            "xs"
          ],
          "line": 4145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 4135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_first_xs",
          "args": [
            "ahc"
          ],
          "line": 4120
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_first_xs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "4029-4048",
          "snippet": "struct scsi_xfer *\nahc_first_xs(struct ahc_softc *ahc)\n{\n\tint target;\n\tstruct scsi_xfer *xs = ahc->sc_xxxq.lh_first;\n\n\tif (ahc->queue_blocked)\n        \treturn NULL;\n\n\twhile (xs != NULL) {\n\t\ttarget = xs->sc_link->target;\n\t\tif (ahc->devqueue_blocked[target] == 0 &&\n\t\t    ahc_index_busy_tcl(ahc, XS_TCL(ahc, xs), FALSE) ==\n\t\t\tSCB_LIST_NULL)\n\t\t\tbreak;\n\t\txs = LIST_NEXT(xs, free_list);\n\t}\n\n\treturn xs;\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "ahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "ahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
            "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "static __inline u_int ahc_index_busy_tcl",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "struct scsi_xfer *ahc_first_xs",
            "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *xs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC struct;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));\nahc_loadseq __P((struct ahc_softc *ahc));\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nahc_clear_intstat __P((struct ahc_softc *ahc));\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nrestart_sequencer __P((struct ahc_softc *ahc));\nstatic __inline u_int ahc_index_busy_tcl;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstruct scsi_xfer *ahc_first_xs;\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n\nstruct scsi_xfer *\nahc_first_xs(struct ahc_softc *ahc)\n{\n\tint target;\n\tstruct scsi_xfer *xs = ahc->sc_xxxq.lh_first;\n\n\tif (ahc->queue_blocked)\n        \treturn NULL;\n\n\twhile (xs != NULL) {\n\t\ttarget = xs->sc_link->target;\n\t\tif (ahc->devqueue_blocked[target] == 0 &&\n\t\t    ahc_index_busy_tcl(ahc, XS_TCL(ahc, xs), FALSE) ==\n\t\t\tSCB_LIST_NULL)\n\t\t\tbreak;\n\t\txs = LIST_NEXT(xs, free_list);\n\t}\n\n\treturn xs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 4116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 4111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_TCL",
          "args": [
            "ahc",
            "xs"
          ],
          "line": 4104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_list_next",
          "args": [
            "ahc",
            "xs"
          ],
          "line": 4091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 4087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 4081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 4070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SC_DEBUG",
          "args": [
            "xs->sc_link",
            "SDEV_DB3",
            "(\"ahc_scsi_cmd\\n\")"
          ],
          "line": 4066
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nahc_poll __P((struct ahc_softc *ahc, int wait));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nSTATIC void;\nahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));\nSTATIC int;\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nSTATIC void;\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nSTATIC void;\nahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));\nSTATIC void;\nSTATIC void;\nahc_calc_residual __P((struct scb *scb));\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nstatic __inline u_int ahc_index_busy_tcl;\nstatic __inline void\tahc_busy_tcl;\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo;\nSTATIC void;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nstatic __inline struct scb *ahcgetscb;\nSTATIC void;\nSTATIC void;\nstruct scsi_xfer *ahc_first_xs;\nvoid   ahc_list_insert_before;\nvoid   ahc_list_insert_tail;\nvoid   ahc_list_remove;\nstruct scsi_xfer *ahc_list_next;\nSTATIC int32_t;\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nu_int our_id;\nstruct tmode_tstate **tstate;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n\nSTATIC int32_t\nahc_scsi_cmd(xs)\n\tstruct scsi_xfer *xs;\n{\n\tstruct scsi_xfer *first_xs, *next_xs = NULL;\n\tstruct ahc_softc *ahc;\n\tstruct scb *scb;\n\tstruct hardware_scb *hscb;\t\n\tstruct ahc_initiator_tinfo *tinfo;\n\tstruct tmode_tstate *tstate;\n\tu_int target_id;\n\tu_int our_id;\n\tint s, tcl;\n\tu_int16_t mask;\n\tint dontqueue = 0, fromqueue = 0;\n\n\tSC_DEBUG(xs->sc_link, SDEV_DB3, (\"ahc_scsi_cmd\\n\"));\n\tahc = (struct ahc_softc *)xs->sc_link->adapter_softc;\n\n\t/* must protect the queue */\n\ts = splbio();\n\n\tif (xs == ahc->sc_xxxq.lh_first) {\n\t\t/*\n\t\t * Called from ahc_done. Calling with the first entry in\n\t\t * the queue is really just a way of seeing where we're\n\t\t * called from. Now, find the first eligible SCB to send,\n\t\t * e.g. one which will be accepted immediately.\n\t\t */\n\n\t\tif (ahc->queue_blocked) {\n\t\t\tsplx(s);\n\t\t\treturn (TRY_AGAIN_LATER);\n\t\t}\n\n\t\txs = ahc_first_xs(ahc);\n\t\tif (xs == NULL) {\n\t\t\tsplx(s);\n\t\t\treturn (TRY_AGAIN_LATER);\n\t\t}\n\n\t\tnext_xs = ahc_list_next(ahc, xs);\n\t\tahc_list_remove(ahc, xs);\n\t\tfromqueue = 1;\n\t\tgoto get_scb;\n\t}\n\n\t/* determine safety of software queueing */\n\tdontqueue = xs->flags & SCSI_POLL;\n\t\n\t/*\n\t * If no new requests are accepted, just insert into the\n\t * private queue to wait for our turn.\n\t */\n\ttcl = XS_TCL(ahc, xs);\n\n\tif (ahc->queue_blocked ||\n\t    ahc->devqueue_blocked[xs->sc_link->target] ||\n\t    (!ahc_istagged_device(ahc, xs) &&\n\t     ahc_index_busy_tcl(ahc, tcl, FALSE) != SCB_LIST_NULL)) {\n\t\tif (dontqueue) {\n\t\t\tsplx(s);\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\treturn TRY_AGAIN_LATER;\n\t\t}\n\t\tahc_list_insert_tail(ahc, xs);\n\t\tsplx(s);\n\t\treturn SUCCESSFULLY_QUEUED;\n\t}\n\n\tfirst_xs = ahc_first_xs(ahc);\n\n\t/* determine safety of software queueing */\n\tdontqueue = xs->flags & SCSI_POLL;\n\n\t/*\n\t * Handle situations where there's already entries in the\n\t * queue.\n\t */\n\tif (first_xs != NULL) {\n\t\t/*\n\t\t * If we can't queue, we have to abort, since\n\t\t * we have to preserve order.\n\t\t */\n\t\tif (dontqueue) {\n\t\t\tsplx(s);\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\treturn (TRY_AGAIN_LATER);\n\t\t}\n\n\t\t/*\n\t\t * Swap with the first queue entry.\n\t\t */\n\t\tahc_list_insert_tail(ahc, xs);\n\t\txs = first_xs;\n\t\tnext_xs = ahc_list_next(ahc, xs);\n\t\tahc_list_remove(ahc, xs);\n\t\tfromqueue = 1;\n\n\t}\n\nget_scb:\n\n\ttarget_id = xs->sc_link->target;\n\tour_id = SIM_SCSI_ID(ahc, xs->sc_link);\n\n\t/*\n\t * get an scb to use.\n\t */\n\tif ((scb = ahcgetscb(ahc)) == NULL) {\n\n\t\tif (dontqueue) {\n\t\t\tsplx(s);\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\treturn (TRY_AGAIN_LATER);\n\t\t}\n\n\t\t/*\n\t\t * If we were pulled off the queue, put ourselves\n\t\t * back to where we came from, otherwise tack ourselves\n\t\t * onto the end.\n\t\t */\n\t\tif (fromqueue && next_xs != NULL)\n\t\t\tahc_list_insert_before(ahc, xs, next_xs);\n\t\telse\n\t\t\tahc_list_insert_tail(ahc, xs);\n\n\t\tsplx(s);\n\t\treturn (SUCCESSFULLY_QUEUED);\n\t}\n\n\ttcl = XS_TCL(ahc, xs);\n\n#ifdef DIAGNOSTIC\n\tif (ahc_index_busy_tcl(ahc, tcl, FALSE) != SCB_LIST_NULL)\n\t\tpanic(\"ahc: queuing for busy target\");\n#endif\n\t\n\tscb->xs = xs;\n\thscb = scb->hscb;\n\thscb->tcl = tcl;\n\n\tif (ahc_istagged_device(ahc, xs))\n\t\tscb->hscb->control |= MSG_SIMPLE_Q_TAG;\n\telse\n\t\tahc_busy_tcl(ahc, scb);\n\n\tsplx(s);\n \n\t/*\n\t * Put all the arguments for the xfer in the scb\n\t */\n\n\tmask = SCB_TARGET_MASK(scb);\n\ttinfo = ahc_fetch_transinfo(ahc, SIM_CHANNEL(ahc, xs->sc_link), our_id,\n\t\t\t\t    target_id, &tstate);\n\tif (ahc->inited_targets[target_id] == 0) {\n\t\tstruct ahc_devinfo devinfo;\n\n\t\ts = splbio();\n\t\tahc_compile_devinfo(&devinfo, our_id, target_id,\n\t\t    xs->sc_link->lun, SIM_CHANNEL(ahc, xs->sc_link),\n\t\t    ROLE_INITIATOR);\n\t\tahc_update_target_msg_request(ahc, &devinfo, tinfo, TRUE,\n\t\t    FALSE);\n\t\tahc->inited_targets[target_id] = 1;\n\t\tsplx(s);\n\t}\n\n\thscb->scsirate = tinfo->scsirate;\n\thscb->scsioffset = tinfo->current.offset;\n\tif ((tstate->ultraenb & mask) != 0)\n\t\thscb->control |= ULTRAENB;\n\t\t\n\tif ((tstate->discenable & mask) != 0)\n\t\thscb->control |= DISCENB;\n\n\tif (xs->flags & SCSI_RESET) {\n\t\thscb->cmdpointer = NULL;\n\t\tscb->flags |= SCB_DEVICE_RESET;\n\t\thscb->control |= MK_MESSAGE;\n\t\treturn ahc_execute_scb(scb, NULL, 0);\n\t}\n\n\treturn ahc_setup_data(ahc, xs, scb);\n}"
  },
  {
    "function_name": "ahc_first_xs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "4029-4048",
    "snippet": "struct scsi_xfer *\nahc_first_xs(struct ahc_softc *ahc)\n{\n\tint target;\n\tstruct scsi_xfer *xs = ahc->sc_xxxq.lh_first;\n\n\tif (ahc->queue_blocked)\n        \treturn NULL;\n\n\twhile (xs != NULL) {\n\t\ttarget = xs->sc_link->target;\n\t\tif (ahc->devqueue_blocked[target] == 0 &&\n\t\t    ahc_index_busy_tcl(ahc, XS_TCL(ahc, xs), FALSE) ==\n\t\t\tSCB_LIST_NULL)\n\t\t\tbreak;\n\t\txs = LIST_NEXT(xs, free_list);\n\t}\n\n\treturn xs;\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "ahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "ahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
      "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "static __inline u_int ahc_index_busy_tcl",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "struct scsi_xfer *ahc_first_xs",
      "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *xs;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LIST_NEXT",
          "args": [
            "xs",
            "free_list"
          ],
          "line": 4044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_index_busy_tcl",
          "args": [
            "ahc",
            "XS_TCL(ahc, xs)",
            "FALSE"
          ],
          "line": 4041
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_index_busy_tcl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "497-513",
          "snippet": "static __inline u_int\nahc_index_busy_tcl(ahc, tcl, unbusy)\n\tstruct ahc_softc *ahc;\n\tu_int tcl;\n\tint unbusy;\n{\n\tu_int scbid;\n\n\tscbid = ahc->untagged_scbs[tcl];\n\tif (unbusy) {\n\t\tahc->untagged_scbs[tcl] = SCB_LIST_NULL;\n\t\tbus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, \n\t\t\t\tBUS_DMASYNC_PREWRITE);\n\t}\n\n\treturn (scbid);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC u_int",
            "STATIC struct",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC u_int",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "static __inline u_int ahc_index_busy_tcl",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC u_int;\nSTATIC struct;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC u_int;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nahc_clear_intstat __P((struct ahc_softc *ahc));\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nrestart_sequencer __P((struct ahc_softc *ahc));\nstatic __inline u_int ahc_index_busy_tcl;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nstatic __inline u_int\nahc_index_busy_tcl(ahc, tcl, unbusy)\n\tstruct ahc_softc *ahc;\n\tu_int tcl;\n\tint unbusy;\n{\n\tu_int scbid;\n\n\tscbid = ahc->untagged_scbs[tcl];\n\tif (unbusy) {\n\t\tahc->untagged_scbs[tcl] = SCB_LIST_NULL;\n\t\tbus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, \n\t\t\t\tBUS_DMASYNC_PREWRITE);\n\t}\n\n\treturn (scbid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XS_TCL",
          "args": [
            "ahc",
            "xs"
          ],
          "line": 4041
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC struct;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));\nahc_loadseq __P((struct ahc_softc *ahc));\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nahc_clear_intstat __P((struct ahc_softc *ahc));\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nrestart_sequencer __P((struct ahc_softc *ahc));\nstatic __inline u_int ahc_index_busy_tcl;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstruct scsi_xfer *ahc_first_xs;\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n\nstruct scsi_xfer *\nahc_first_xs(struct ahc_softc *ahc)\n{\n\tint target;\n\tstruct scsi_xfer *xs = ahc->sc_xxxq.lh_first;\n\n\tif (ahc->queue_blocked)\n        \treturn NULL;\n\n\twhile (xs != NULL) {\n\t\ttarget = xs->sc_link->target;\n\t\tif (ahc->devqueue_blocked[target] == 0 &&\n\t\t    ahc_index_busy_tcl(ahc, XS_TCL(ahc, xs), FALSE) ==\n\t\t\tSCB_LIST_NULL)\n\t\t\tbreak;\n\t\txs = LIST_NEXT(xs, free_list);\n\t}\n\n\treturn xs;\n}"
  },
  {
    "function_name": "ahc_list_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "3996-4016",
    "snippet": "void\nahc_list_remove(ahc, xs)\n\tstruct ahc_softc *ahc;\n\tstruct scsi_xfer *xs;\n{\n\tstruct scsi_xfer *lxs;\n\tif (xs == ahc->sc_xxxqlast) {\n\t\tlxs = ahc->sc_xxxq.lh_first;\n\t\twhile (lxs != NULL) {\n\t\t\tif (LIST_NEXT(lxs, free_list) == ahc->sc_xxxqlast) {\n                                ahc->sc_xxxqlast = lxs;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlxs = LIST_NEXT(xs, free_list);\n\t\t}\n\t}\n\t\n\tLIST_REMOVE(xs, free_list);\n\tif (ahc->sc_xxxq.lh_first == NULL)\n\t\tahc->sc_xxxqlast = NULL;\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
      "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "void   ahc_list_remove",
      "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *xs;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LIST_REMOVE",
          "args": [
            "xs",
            "free_list"
          ],
          "line": 4013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_NEXT",
          "args": [
            "xs",
            "free_list"
          ],
          "line": 4009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_NEXT",
          "args": [
            "lxs",
            "free_list"
          ],
          "line": 4005
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC struct;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nahc_loadseq __P((struct ahc_softc *ahc));\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nahc_clear_intstat __P((struct ahc_softc *ahc));\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nrestart_sequencer __P((struct ahc_softc *ahc));\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nvoid   ahc_list_remove;\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n\nvoid\nahc_list_remove(ahc, xs)\n\tstruct ahc_softc *ahc;\n\tstruct scsi_xfer *xs;\n{\n\tstruct scsi_xfer *lxs;\n\tif (xs == ahc->sc_xxxqlast) {\n\t\tlxs = ahc->sc_xxxq.lh_first;\n\t\twhile (lxs != NULL) {\n\t\t\tif (LIST_NEXT(lxs, free_list) == ahc->sc_xxxqlast) {\n                                ahc->sc_xxxqlast = lxs;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlxs = LIST_NEXT(xs, free_list);\n\t\t}\n\t}\n\t\n\tLIST_REMOVE(xs, free_list);\n\tif (ahc->sc_xxxq.lh_first == NULL)\n\t\tahc->sc_xxxqlast = NULL;\n}"
  },
  {
    "function_name": "ahc_list_insert_tail",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "3982-3994",
    "snippet": "void\nahc_list_insert_tail(ahc, xs)\n\tstruct ahc_softc *ahc;\n\tstruct scsi_xfer *xs;\n{\n\tif (ahc->sc_xxxq.lh_first == NULL){\n\t\tahc->sc_xxxqlast = xs;\n\t\tLIST_INSERT_HEAD(&ahc->sc_xxxq, xs, free_list);\n\t\treturn;\n\t}\n\tLIST_INSERT_AFTER(ahc->sc_xxxqlast, xs, free_list);\n\tahc->sc_xxxqlast = xs;\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
      "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "void   ahc_list_insert_tail",
      "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *xs;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LIST_INSERT_AFTER",
          "args": [
            "ahc->sc_xxxqlast",
            "xs",
            "free_list"
          ],
          "line": 3992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_INSERT_HEAD",
          "args": [
            "&ahc->sc_xxxq",
            "xs",
            "free_list"
          ],
          "line": 3989
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC struct;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nahc_loadseq __P((struct ahc_softc *ahc));\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nahc_clear_intstat __P((struct ahc_softc *ahc));\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nrestart_sequencer __P((struct ahc_softc *ahc));\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nvoid   ahc_list_insert_tail;\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n\nvoid\nahc_list_insert_tail(ahc, xs)\n\tstruct ahc_softc *ahc;\n\tstruct scsi_xfer *xs;\n{\n\tif (ahc->sc_xxxq.lh_first == NULL){\n\t\tahc->sc_xxxqlast = xs;\n\t\tLIST_INSERT_HEAD(&ahc->sc_xxxq, xs, free_list);\n\t\treturn;\n\t}\n\tLIST_INSERT_AFTER(ahc->sc_xxxqlast, xs, free_list);\n\tahc->sc_xxxqlast = xs;\n}"
  },
  {
    "function_name": "ahc_list_insert_head",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "3971-3980",
    "snippet": "void\nahc_list_insert_head(ahc, xs)\n\tstruct ahc_softc *ahc;\n\tstruct scsi_xfer *xs;\n{\n\tif (ahc->sc_xxxq.lh_first == NULL)\n\t\tahc->sc_xxxqlast = xs;\n\tLIST_INSERT_HEAD(&ahc->sc_xxxq, xs, free_list);\n\treturn;\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
      "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "void   ahc_list_insert_head",
      "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *xs;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LIST_INSERT_HEAD",
          "args": [
            "&ahc->sc_xxxq",
            "xs",
            "free_list"
          ],
          "line": 3978
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC struct;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nahc_loadseq __P((struct ahc_softc *ahc));\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nahc_clear_intstat __P((struct ahc_softc *ahc));\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nrestart_sequencer __P((struct ahc_softc *ahc));\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nvoid   ahc_list_insert_head;\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n\nvoid\nahc_list_insert_head(ahc, xs)\n\tstruct ahc_softc *ahc;\n\tstruct scsi_xfer *xs;\n{\n\tif (ahc->sc_xxxq.lh_first == NULL)\n\t\tahc->sc_xxxqlast = xs;\n\tLIST_INSERT_HEAD(&ahc->sc_xxxq, xs, free_list);\n\treturn;\n}"
  },
  {
    "function_name": "ahc_list_insert_before",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "3961-3969",
    "snippet": "void\nahc_list_insert_before(ahc, xs, next_xs)\n\tstruct ahc_softc *ahc;\n\tstruct scsi_xfer *xs;\n\tstruct scsi_xfer *next_xs;\n{\n\tLIST_INSERT_BEFORE(xs, next_xs, free_list); \n\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
      "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "void   ahc_list_insert_before",
      "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *xs;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LIST_INSERT_BEFORE",
          "args": [
            "xs",
            "next_xs",
            "free_list"
          ],
          "line": 3967
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC struct;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nahc_loadseq __P((struct ahc_softc *ahc));\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nahc_clear_intstat __P((struct ahc_softc *ahc));\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nrestart_sequencer __P((struct ahc_softc *ahc));\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nvoid   ahc_list_insert_before;\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n\nvoid\nahc_list_insert_before(ahc, xs, next_xs)\n\tstruct ahc_softc *ahc;\n\tstruct scsi_xfer *xs;\n\tstruct scsi_xfer *next_xs;\n{\n\tLIST_INSERT_BEFORE(xs, next_xs, free_list); \n\n}"
  },
  {
    "function_name": "ahc_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "3564-3953",
    "snippet": "int\nahc_init(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tint\t  max_targ = 15;\n\tint\t  i;\n\tint\t  term;\n\tu_int\t  scsi_conf;\n\tu_int\t  scsiseq_template;\n\tu_int\t  ultraenb;\n\tu_int\t  discenable;\n\tu_int\t  tagenable;\n\tsize_t\t  driver_data_size;\n\tu_int32_t physaddr;\n\tstruct scb_data *scb_data = NULL;\n\n#ifdef AHC_PRINT_SRAM\n\tprintf(\"Scratch Ram:\");\n\tfor (i = 0x20; i < 0x5f; i++) {\n\t\tif (((i % 8) == 0) && (i != 0)) {\n\t\t\tprintf (\"\\n              \");\n\t\t}\n\t\tprintf (\" 0x%x\", ahc_inb(ahc, i));\n\t}\n\tif ((ahc->features & AHC_MORE_SRAM) != 0) {\n\t\tfor (i = 0x70; i < 0x7f; i++) {\n\t\t\tif (((i % 8) == 0) && (i != 0)) {\n\t\t\t\tprintf (\"\\n              \");\n\t\t\t}\n\t\t\tprintf (\" 0x%x\", ahc_inb(ahc, i));\n\t\t}\n\t}\n\tprintf (\"\\n\");\n#endif\n\n\tif (ahc->scb_data == NULL) {\n\t\tscb_data = malloc(sizeof (struct scb_data), M_DEVBUF, M_NOWAIT);\n\t\tif (scb_data == NULL) {\n\t\t\tprintf(\"%s: cannot malloc scb_data!\\n\", ahc_name(ahc));\n\t\t\treturn (ENOMEM);\n\t\t}\n\t\tbzero(scb_data, sizeof(struct scb_data));\n\t\tahc->scb_data = scb_data;\n\t}\n\t/*\n\t * Assume we have a board at this stage and it has been reset.\n\t */\n\tif ((ahc->flags & AHC_USEDEFAULTS) != 0)\n\t\tahc->our_id = ahc->our_id_b = 7;\n\t\n\t/*\n\t * Default to allowing initiator operations.\n\t */\n\tahc->flags |= AHC_INITIATORMODE;\n\t\n\t/*\n\t * DMA tag for our command fifos and other data in system memory\n\t * the card's sequencer must be able to access.  For initiator\n\t * roles, we need to allocate space for the qinfifo, qoutfifo,\n\t * and untagged_scb arrays each of which are composed of 256\n\t * 1 byte elements.  When providing for the target mode role,\n\t * we additionally must provide space for the incoming target\n\t * command fifo.\n\t */\n\tdriver_data_size = 3 * 256 * sizeof(u_int8_t);\n\n\tif (ahc_createdmamem(ahc, driver_data_size, \n\t    &ahc->shared_data_dmamap, (caddr_t *)&ahc->qoutfifo,\n\t    &ahc->shared_data_busaddr, &ahc->shared_data_seg,\n\t    &ahc->shared_data_nseg, \"shared data\") < 0)\n\t\treturn (ENOMEM);\n\n\tahc->init_level++;\n\n\t/* Allocate SCB data now that sc_dmat is initialized */\n\tif (ahc->scb_data->maxhscbs == 0)\n\t\tif (ahcinitscbdata(ahc) != 0)\n\t\t\treturn (ENOMEM);\n\n\tahc->qinfifo = &ahc->qoutfifo[256];\n\tahc->untagged_scbs = &ahc->qinfifo[256];\n\t/* There are no untagged SCBs active yet. */\n\tfor (i = 0; i < 256; i++)\n\t\tahc->untagged_scbs[i] = SCB_LIST_NULL;\n\n\t/* All of our queues are empty */\n\tfor (i = 0; i < 256; i++)\n\t\tahc->qoutfifo[i] = SCB_LIST_NULL;\n\n\tbus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap,\n\t\t\tBUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);\n\t\n\t/*\n\t * Allocate a tstate to house information for our\n\t * initiator presence on the bus as well as the user\n\t * data for any target mode initiator.\n\t */\n\tif (ahc_alloc_tstate(ahc, ahc->our_id, 'A') == NULL) {\n\t\tprintf(\"%s: unable to allocate tmode_tstate.  \"\n\t\t       \"Failing attach\\n\", ahc_name(ahc));\n\t\treturn (-1);\n\t}\n\n\tif ((ahc->features & AHC_TWIN) != 0) {\n\t\tif (ahc_alloc_tstate(ahc, ahc->our_id_b, 'B') == NULL) {\n\t\t\tprintf(\"%s: unable to allocate tmode_tstate.  \"\n\t\t\t       \"Failing attach\\n\", ahc_name(ahc));\n\t\t\treturn (-1);\n\t\t}\n \t\tprintf(\"Twin Channel, A SCSI Id=%d, B SCSI Id=%d, primary %c, \",\n\t\t       ahc->our_id, ahc->our_id_b,\n\t\t       ahc->flags & AHC_CHANNEL_B_PRIMARY? 'B': 'A');\n\t} else {\n\t\tif ((ahc->features & AHC_WIDE) != 0) {\n\t\t\tprintf(\"Wide \");\n\t\t} else {\n\t\t\tprintf(\"Single \");\n\t\t}\n\t\tprintf(\"Channel %c, SCSI Id=%d, \", ahc->channel, ahc->our_id);\n\t}\n\n\tahc_outb(ahc, SEQ_FLAGS, 0);\n\n\tif (ahc->scb_data->maxhscbs < AHC_SCB_MAX) {\n\t\tahc->flags |= AHC_PAGESCBS;\n\t\tprintf(\"%d/%d SCBs\\n\", ahc->scb_data->maxhscbs, AHC_SCB_MAX);\n\t} else {\n\t\tahc->flags &= ~AHC_PAGESCBS;\n\t\tprintf(\"%d SCBs\\n\", ahc->scb_data->maxhscbs);\n\t}\n\n#ifdef AHC_DEBUG\n\tif (ahc_debug & AHC_SHOWMISC) {\n\t\tprintf(\"%s: hardware scb %d bytes; kernel scb %d bytes; \"\n\t\t       \"ahc_dma %d bytes\\n\",\n\t\t\tahc_name(ahc),\n\t\t        sizeof(struct hardware_scb),\n\t\t\tsizeof(struct scb),\n\t\t\tsizeof(struct ahc_dma_seg));\n\t}\n#endif /* AHC_DEBUG */\n\n\t/* Set the SCSI Id,SXFRCTL0,SXFRCTL1, and SIMODE1, for both channels*/\n\tif (ahc->features & AHC_TWIN) {\n\n\t\t/*\n\t\t * The device is gated to channel B after a chip reset,\n\t\t * so set those values first\n\t\t */\n\t\tterm = (ahc->flags & AHC_TERM_ENB_B) != 0 ? STPWEN : 0;\n\t\tif ((ahc->features & AHC_ULTRA2) != 0)\n\t\t\tahc_outb(ahc, SCSIID_ULTRA2, ahc->our_id_b);\n\t\telse\n\t\t\tahc_outb(ahc, SCSIID, ahc->our_id_b);\n\t\tscsi_conf = ahc_inb(ahc, SCSICONF + 1);\n\t\tahc_outb(ahc, SXFRCTL1, (scsi_conf & (ENSPCHK|STIMESEL))\n\t\t\t\t\t|term|ENSTIMER|ACTNEGEN);\n\t\tahc_outb(ahc, SIMODE1, ENSELTIMO|ENSCSIRST|ENSCSIPERR);\n\t\tahc_outb(ahc, SXFRCTL0, DFON|SPIOEN);\n\n\t\tif ((scsi_conf & RESET_SCSI) != 0\n\t\t && (ahc->flags & AHC_INITIATORMODE) != 0)\n\t\t\tahc->flags |= AHC_RESET_BUS_B;\n\n\t\t/* Select Channel A */\n\t\tahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) & ~SELBUSB);\n\t}\n\tterm = (ahc->flags & AHC_TERM_ENB_A) != 0 ? STPWEN : 0;\n\tif ((ahc->features & AHC_ULTRA2) != 0)\n\t\tahc_outb(ahc, SCSIID_ULTRA2, ahc->our_id);\n\telse\n\t\tahc_outb(ahc, SCSIID, ahc->our_id);\n\tscsi_conf = ahc_inb(ahc, SCSICONF);\n\tahc_outb(ahc, SXFRCTL1, (scsi_conf & (ENSPCHK|STIMESEL))\n\t\t\t\t|term\n\t\t\t\t|ENSTIMER|ACTNEGEN);\n\tahc_outb(ahc, SIMODE1, ENSELTIMO|ENSCSIRST|ENSCSIPERR);\n\tahc_outb(ahc, SXFRCTL0, DFON|SPIOEN);\n\n\tif ((scsi_conf & RESET_SCSI) != 0\n\t && (ahc->flags & AHC_INITIATORMODE) != 0)\n\t\tahc->flags |= AHC_RESET_BUS_A;\n\n\t/*\n\t * Look at the information that board initialization or\n\t * the board bios has left us.\n\t */\n\tultraenb = 0;\t\n\ttagenable = ALL_TARGETS_MASK;\n\n\t/* Grab the disconnection disable table and invert it for our needs */\n\tif (ahc->flags & AHC_USEDEFAULTS) {\n\t\tprintf(\"%s: Host Adapter Bios disabled.  Using default SCSI \"\n\t\t\t\"device parameters\\n\", ahc_name(ahc));\n\t\tahc->flags |= AHC_EXTENDED_TRANS_A|AHC_EXTENDED_TRANS_B|\n\t\t\t      AHC_TERM_ENB_A|AHC_TERM_ENB_B;\n\t\tdiscenable = ALL_TARGETS_MASK;\n\t\tif ((ahc->features & AHC_ULTRA) != 0)\n\t\t\tultraenb = ALL_TARGETS_MASK;\n\t} else {\n\t\tdiscenable = ~((ahc_inb(ahc, DISC_DSB + 1) << 8)\n\t\t\t   | ahc_inb(ahc, DISC_DSB));\n\t\tif ((ahc->features & (AHC_ULTRA|AHC_ULTRA2)) != 0)\n\t\t\tultraenb = (ahc_inb(ahc, ULTRA_ENB + 1) << 8)\n\t\t\t\t      | ahc_inb(ahc, ULTRA_ENB);\n\t}\n\n\tif ((ahc->features & (AHC_WIDE|AHC_TWIN)) == 0)\n\t\tmax_targ = 7;\n\n\tfor (i = 0; i <= max_targ; i++) {\n\t\tstruct ahc_initiator_tinfo *tinfo;\n\t\tstruct tmode_tstate *tstate;\n\t\tu_int our_id;\n\t\tu_int target_id;\n\t\tchar channel;\n\n\t\tchannel = 'A';\n\t\tour_id = ahc->our_id;\n\t\ttarget_id = i;\n\t\tif (i > 7 && (ahc->features & AHC_TWIN) != 0) {\n\t\t\tchannel = 'B';\n\t\t\tour_id = ahc->our_id_b;\n\t\t\ttarget_id = i % 8;\n\t\t}\n\t\ttinfo = ahc_fetch_transinfo(ahc, channel, our_id,\n\t\t\t\t\t    target_id, &tstate);\n\t\t/* Default to async narrow across the board */\n\t\tbzero(tinfo, sizeof(*tinfo));\n\t\tif (ahc->flags & AHC_USEDEFAULTS) {\n\t\t\tif ((ahc->features & AHC_WIDE) != 0)\n\t\t\t\ttinfo->user.width = MSG_EXT_WDTR_BUS_16_BIT;\n\n\t\t\t/*\n\t\t\t * These will be truncated when we determine the\n\t\t\t * connection type we have with the target.\n\t\t\t */\n\t\t\ttinfo->user.period = ahc_syncrates->period;\n\t\t\ttinfo->user.offset = ~0;\n\t\t} else {\n\t\t\tu_int scsirate;\n\t\t\tu_int16_t mask;\n\n\t\t\t/* Take the settings leftover in scratch RAM. */\n\t\t\tscsirate = ahc_inb(ahc, TARG_SCSIRATE + i);\n\t\t\tmask = (0x01 << i);\n\t\t\tif ((ahc->features & AHC_ULTRA2) != 0) {\n\t\t\t\tu_int offset;\n\t\t\t\tu_int maxsync;\n\n\t\t\t\tif ((scsirate & SOFS) == 0x0F) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Haven't negotiated yet,\n\t\t\t\t\t * so the format is different.\n\t\t\t\t\t */\n\t\t\t\t\tscsirate = (scsirate & SXFR) >> 4\n\t\t\t\t\t\t | (ultraenb & mask)\n\t\t\t\t\t\t  ? 0x08 : 0x0\n\t\t\t\t\t\t | (scsirate & WIDEXFER);\n\t\t\t\t\toffset = MAX_OFFSET_ULTRA2;\n\t\t\t\t} else\n\t\t\t\t\toffset = ahc_inb(ahc, TARG_OFFSET + i);\n\t\t\t\tmaxsync = AHC_SYNCRATE_ULTRA2;\n\t\t\t\tif ((ahc->features & AHC_DT) != 0)\n\t\t\t\t\tmaxsync = AHC_SYNCRATE_DT;\n\t\t\t\ttinfo->user.period =\n\t\t\t\t    ahc_find_period(ahc, scsirate, maxsync);\n\t\t\t\tif (offset == 0)\n\t\t\t\t\ttinfo->user.period = 0;\n\t\t\t\telse\n\t\t\t\t\ttinfo->user.offset = ~0;\n\t\t\t} else if ((scsirate & SOFS) != 0) {\n\t\t\t\ttinfo->user.period = \n\t\t\t\t    ahc_find_period(ahc, scsirate,\n\t\t\t\t\t\t    (ultraenb & mask)\n\t\t\t\t\t\t   ? AHC_SYNCRATE_ULTRA\n\t\t\t\t\t\t   : AHC_SYNCRATE_FAST);\n\t\t\t\tif (tinfo->user.period != 0)\n\t\t\t\t\ttinfo->user.offset = ~0;\n\t\t\t}\n\t\t\tif ((scsirate & WIDEXFER) != 0\n\t\t\t && (ahc->features & AHC_WIDE) != 0)\n\t\t\t\ttinfo->user.width = MSG_EXT_WDTR_BUS_16_BIT;\n\t\t}\n\t\ttinfo->goal = tinfo->user; /* force negotiation */\n\t\ttstate->ultraenb = ultraenb;\n\t\ttstate->discenable = discenable;\n\t\ttstate->tagenable = 0; /* Wait until the XPT says its okay */\n\t}\n\tahc->user_discenable = discenable;\n\tahc->user_tagenable = tagenable;\n\n\t/*\n\t * Tell the sequencer where it can find our arrays in memory.\n\t */\n\tphysaddr = ahc->scb_data->hscb_busaddr;\n\tahc_outb(ahc, HSCB_ADDR, physaddr & 0xFF);\n\tahc_outb(ahc, HSCB_ADDR + 1, (physaddr >> 8) & 0xFF);\n\tahc_outb(ahc, HSCB_ADDR + 2, (physaddr >> 16) & 0xFF);\n\tahc_outb(ahc, HSCB_ADDR + 3, (physaddr >> 24) & 0xFF);\n\n\tphysaddr = ahc->shared_data_busaddr;\n\tahc_outb(ahc, SCBID_ADDR, physaddr & 0xFF);\n\tahc_outb(ahc, SCBID_ADDR + 1, (physaddr >> 8) & 0xFF);\n\tahc_outb(ahc, SCBID_ADDR + 2, (physaddr >> 16) & 0xFF);\n\tahc_outb(ahc, SCBID_ADDR + 3, (physaddr >> 24) & 0xFF);\n\n\t/* Target mode incomding command fifo */\n\tphysaddr += 3 * 256 * sizeof(u_int8_t);\n\tahc_outb(ahc, TMODE_CMDADDR, physaddr & 0xFF);\n\tahc_outb(ahc, TMODE_CMDADDR + 1, (physaddr >> 8) & 0xFF);\n\tahc_outb(ahc, TMODE_CMDADDR + 2, (physaddr >> 16) & 0xFF);\n\tahc_outb(ahc, TMODE_CMDADDR + 3, (physaddr >> 24) & 0xFF);\n\n\t/*\n\t * Initialize the group code to command length table.\n\t * This overrides the values in TARG_SCSIRATE, so only\n\t * setup the table after we have processed that information.\n\t */\n\tahc_outb(ahc, CMDSIZE_TABLE, 5);\n\tahc_outb(ahc, CMDSIZE_TABLE + 1, 9);\n\tahc_outb(ahc, CMDSIZE_TABLE + 2, 9);\n\tahc_outb(ahc, CMDSIZE_TABLE + 3, 0);\n\tahc_outb(ahc, CMDSIZE_TABLE + 4, 15);\n\tahc_outb(ahc, CMDSIZE_TABLE + 5, 11);\n\tahc_outb(ahc, CMDSIZE_TABLE + 6, 0);\n\tahc_outb(ahc, CMDSIZE_TABLE + 7, 0);\n\t\t\n\t/* Tell the sequencer of our initial queue positions */\n\tahc_outb(ahc, KERNEL_QINPOS, 0);\n\tahc_outb(ahc, QINPOS, 0);\n\tahc_outb(ahc, QOUTPOS, 0);\n\n#ifdef AHC_DEBUG\n\tif (ahc_debug & AHC_SHOWMISC)\n\t\tprintf(\"NEEDSDTR == 0x%x\\nNEEDWDTR == 0x%x\\n\"\n\t\t       \"DISCENABLE == 0x%x\\nULTRAENB == 0x%x\\n\",\n\t\t       ahc->needsdtr_orig, ahc->needwdtr_orig,\n\t\t       discenable, ultraenb);\n#endif\n\n\t/* Don't have any special messages to send to targets */\n\tahc_outb(ahc, TARGET_MSG_REQUEST, 0);\n\tahc_outb(ahc, TARGET_MSG_REQUEST + 1, 0);\n\n\t/*\n\t * Use the built in queue management registers\n\t * if they are available.\n\t */\n\tif ((ahc->features & AHC_QUEUE_REGS) != 0) {\n\t\tahc_outb(ahc, QOFF_CTLSTA, SCB_QSIZE_256);\n\t\tahc_outb(ahc, SDSCB_QOFF, 0);\n\t\tahc_outb(ahc, SNSCB_QOFF, 0);\n\t\tahc_outb(ahc, HNSCB_QOFF, 0);\n\t}\n\n\n\t/* We don't have any waiting selections */\n\tahc_outb(ahc, WAITING_SCBH, SCB_LIST_NULL);\n\n\t/* Our disconnection list is empty too */\n\tahc_outb(ahc, DISCONNECTED_SCBH, SCB_LIST_NULL);\n\n\t/* Message out buffer starts empty */\n\tahc_outb(ahc, MSG_OUT, MSG_NOOP);\n\n\t/*\n\t * Setup the allowed SCSI Sequences based on operational mode.\n\t * If we are a target, we'll enalbe select in operations once\n\t * we've had a lun enabled.\n\t */\n\tscsiseq_template = ENSELO|ENAUTOATNO|ENAUTOATNP;\n\tif ((ahc->flags & AHC_INITIATORMODE) != 0)\n\t\tscsiseq_template |= ENRSELI;\n\tahc_outb(ahc, SCSISEQ_TEMPLATE, scsiseq_template);\n\n\t/*\n\t * Load the Sequencer program and Enable the adapter\n\t * in \"fast\" mode.\n         */\n\tif (bootverbose)\n\t\tprintf(\"%s: Downloading Sequencer Program...\",\n\t\t       ahc_name(ahc));\n\n\tahc_loadseq(ahc);\n\n\t/* We have to wait until after any system dumps... */\n\tshutdownhook_establish(ahc_shutdown, ahc);\n\treturn (0);\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define AHC_SYNCRATE_FAST\t6",
      "#define AHC_SYNCRATE_ULTRA\t3",
      "#define AHC_SYNCRATE_ULTRA2\t1",
      "#define AHC_SYNCRATE_DT\t\t0",
      "#define bootverbose\t0",
      "#define bootverbose\t1",
      "#define ALL_TARGETS_MASK 0xFFFF"
    ],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "ahc_poll __P((struct ahc_softc *ahc, int wait));",
      "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "ahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));",
      "STATIC u_int",
      "STATIC struct",
      "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "ahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));",
      "STATIC u_int",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "STATIC u_int",
      "ahc_find_period __P((struct ahc_softc *ahc, u_int scsirate,\n\t\t\t\t  u_int maxsync));",
      "ahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));",
      "ahc_calc_residual __P((struct scb *scb));",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "static __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo",
      "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
      "int    ahc_createdmamem",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "char channel;",
      "u_int our_id;",
      "struct tmode_tstate **tstate;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "static struct ahc_syncrate ahc_syncrates[] = {\n      /* ultra2    fast/ultra  period     rate */\n\t{ 0x42,      0x000,      9,      \"80.0\" },\n\t{ 0x03,      0x000,     10,      \"40.0\" },\n\t{ 0x04,      0x000,     11,      \"33.0\" },\n\t{ 0x05,      0x100,     12,      \"20.0\" },\n\t{ 0x06,      0x110,     15,      \"16.0\" },\n\t{ 0x07,      0x120,     18,      \"13.4\" },\n\t{ 0x08,      0x000,     25,      \"10.0\" },\n\t{ 0x19,      0x010,     31,      \"8.0\"  },\n\t{ 0x1a,      0x020,     37,      \"6.67\" },\n\t{ 0x1b,      0x030,     43,      \"5.7\"  },\n\t{ 0x1c,      0x040,     50,      \"5.0\"  },\n\t{ 0x00,      0x050,     56,      \"4.4\"  },\n\t{ 0x00,      0x060,     62,      \"4.0\"  },\n\t{ 0x00,      0x070,     68,      \"3.6\"  },\n\t{ 0x00,      0x000,      0,      NULL   }\n};",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "u_int *period;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "u_int *period;",
      "u_int maxsync;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "char channel;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "shutdownhook_establish",
          "args": [
            "ahc_shutdown",
            "ahc"
          ],
          "line": 3951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_loadseq",
          "args": [
            "ahc"
          ],
          "line": 3948
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_loadseq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "4557-4596",
          "snippet": "STATIC void\nahc_loadseq(ahc)\n\tstruct ahc_softc* ahc;\n{\n\tstruct patch *cur_patch;\n\tint i;\n\tint downloaded;\n\tint skip_addr;\n\tu_int8_t download_consts[4];\n\n\t/* Setup downloadable constant table */\n#if 0\n\t/* No downloaded constants are currently defined. */\n\tdownload_consts[TMODE_NUMCMDS] = ahc->num_targetcmds;\n#endif\n\n\tcur_patch = patches;\n\tdownloaded = 0;\n\tskip_addr = 0;\n\tahc_outb(ahc, SEQCTL, PERRORDIS|FAILDIS|FASTMODE|LOADRAM);\n\tahc_outb(ahc, SEQADDR0, 0);\n\tahc_outb(ahc, SEQADDR1, 0);\n\n\tfor (i = 0; i < sizeof(seqprog)/4; i++) {\n\t\tif (ahc_check_patch(ahc, &cur_patch, i, &skip_addr) == 0) {\n\t\t\t/*\n\t\t\t * Don't download this instruction as it\n\t\t\t * is in a patch that was removed.\n\t\t\t */\n                        continue;\n\t\t}\n\t\tahc_download_instr(ahc, i, download_consts);\n\t\tdownloaded++;\n\t}\n\tahc_outb(ahc, SEQCTL, PERRORDIS|FAILDIS|FASTMODE);\n\trestart_sequencer(ahc);\n\n\tif (bootverbose)\n\t\tprintf(\" %d instructions downloaded\\n\", downloaded);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define bootverbose\t0",
            "#define STATIC",
            "#define bootverbose\t1"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "ahc_check_patch __P((struct ahc_softc *ahc,\n\t\t\t\t     struct patch **start_patch,\n\t\t\t\t     int start_instr, int *skip_addr));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define bootverbose\t0\n#define STATIC\n#define bootverbose\t1\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nahc_check_patch __P((struct ahc_softc *ahc,\n\t\t\t\t     struct patch **start_patch,\n\t\t\t\t     int start_instr, int *skip_addr));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_loadseq(ahc)\n\tstruct ahc_softc* ahc;\n{\n\tstruct patch *cur_patch;\n\tint i;\n\tint downloaded;\n\tint skip_addr;\n\tu_int8_t download_consts[4];\n\n\t/* Setup downloadable constant table */\n#if 0\n\t/* No downloaded constants are currently defined. */\n\tdownload_consts[TMODE_NUMCMDS] = ahc->num_targetcmds;\n#endif\n\n\tcur_patch = patches;\n\tdownloaded = 0;\n\tskip_addr = 0;\n\tahc_outb(ahc, SEQCTL, PERRORDIS|FAILDIS|FASTMODE|LOADRAM);\n\tahc_outb(ahc, SEQADDR0, 0);\n\tahc_outb(ahc, SEQADDR1, 0);\n\n\tfor (i = 0; i < sizeof(seqprog)/4; i++) {\n\t\tif (ahc_check_patch(ahc, &cur_patch, i, &skip_addr) == 0) {\n\t\t\t/*\n\t\t\t * Don't download this instruction as it\n\t\t\t * is in a patch that was removed.\n\t\t\t */\n                        continue;\n\t\t}\n\t\tahc_download_instr(ahc, i, download_consts);\n\t\tdownloaded++;\n\t}\n\tahc_outb(ahc, SEQCTL, PERRORDIS|FAILDIS|FASTMODE);\n\trestart_sequencer(ahc);\n\n\tif (bootverbose)\n\t\tprintf(\" %d instructions downloaded\\n\", downloaded);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: Downloading Sequencer Program...\"",
            "ahc_name(ahc)"
          ],
          "line": 3945
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 3946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCSISEQ_TEMPLATE",
            "scsiseq_template"
          ],
          "line": 3938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "MSG_OUT",
            "MSG_NOOP"
          ],
          "line": 3928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "DISCONNECTED_SCBH",
            "SCB_LIST_NULL"
          ],
          "line": 3925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "WAITING_SCBH",
            "SCB_LIST_NULL"
          ],
          "line": 3922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "HNSCB_QOFF",
            "0"
          ],
          "line": 3917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SNSCB_QOFF",
            "0"
          ],
          "line": 3916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SDSCB_QOFF",
            "0"
          ],
          "line": 3915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "QOFF_CTLSTA",
            "SCB_QSIZE_256"
          ],
          "line": 3914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "TARGET_MSG_REQUEST + 1",
            "0"
          ],
          "line": 3907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "TARGET_MSG_REQUEST",
            "0"
          ],
          "line": 3906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "QOUTPOS",
            "0"
          ],
          "line": 3895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "QINPOS",
            "0"
          ],
          "line": 3894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "KERNEL_QINPOS",
            "0"
          ],
          "line": 3893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "CMDSIZE_TABLE + 7",
            "0"
          ],
          "line": 3890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "CMDSIZE_TABLE + 6",
            "0"
          ],
          "line": 3889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "CMDSIZE_TABLE + 5",
            "11"
          ],
          "line": 3888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "CMDSIZE_TABLE + 4",
            "15"
          ],
          "line": 3887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "CMDSIZE_TABLE + 3",
            "0"
          ],
          "line": 3886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "CMDSIZE_TABLE + 2",
            "9"
          ],
          "line": 3885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "CMDSIZE_TABLE + 1",
            "9"
          ],
          "line": 3884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "CMDSIZE_TABLE",
            "5"
          ],
          "line": 3883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "TMODE_CMDADDR + 3",
            "(physaddr >> 24) & 0xFF"
          ],
          "line": 3876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "TMODE_CMDADDR + 2",
            "(physaddr >> 16) & 0xFF"
          ],
          "line": 3875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "TMODE_CMDADDR + 1",
            "(physaddr >> 8) & 0xFF"
          ],
          "line": 3874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "TMODE_CMDADDR",
            "physaddr & 0xFF"
          ],
          "line": 3873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCBID_ADDR + 3",
            "(physaddr >> 24) & 0xFF"
          ],
          "line": 3869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCBID_ADDR + 2",
            "(physaddr >> 16) & 0xFF"
          ],
          "line": 3868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCBID_ADDR + 1",
            "(physaddr >> 8) & 0xFF"
          ],
          "line": 3867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCBID_ADDR",
            "physaddr & 0xFF"
          ],
          "line": 3866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "HSCB_ADDR + 3",
            "(physaddr >> 24) & 0xFF"
          ],
          "line": 3863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "HSCB_ADDR + 2",
            "(physaddr >> 16) & 0xFF"
          ],
          "line": 3862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "HSCB_ADDR + 1",
            "(physaddr >> 8) & 0xFF"
          ],
          "line": 3861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "HSCB_ADDR",
            "physaddr & 0xFF"
          ],
          "line": 3860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_find_period",
          "args": [
            "ahc",
            "scsirate",
            "(ultraenb & mask)\n\t\t\t\t\t\t   ? AHC_SYNCRATE_ULTRA\n\t\t\t\t\t\t   : AHC_SYNCRATE_FAST"
          ],
          "line": 3837
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_find_period",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "1198-1225",
          "snippet": "STATIC u_int\nahc_find_period(ahc, scsirate, maxsync)\n\tstruct ahc_softc *ahc;\n\tu_int scsirate;\n\tu_int maxsync;\n{\n\tstruct ahc_syncrate *syncrate;\n\n\tif ((ahc->features & AHC_ULTRA2) != 0)\n\t\tscsirate &= SXFR_ULTRA2;\n\telse\n\t\tscsirate &= SXFR;\n\n\tsyncrate = &ahc_syncrates[maxsync];\n\twhile (syncrate->rate != NULL) {\n\n\t\tif ((ahc->features & AHC_ULTRA2) != 0) {\n\t\t\tif (syncrate->sxfr_u2 == 0)\n\t\t\t\tbreak;\n\t\t\telse if (scsirate == (syncrate->sxfr_u2 & SXFR_ULTRA2))\n\t\t\t\treturn (syncrate->period);\n\t\t} else if (scsirate == (syncrate->sxfr & SXFR)) {\n\t\t\t\treturn (syncrate->period);\n\t\t}\n\t\tsyncrate++;\n\t}\n\treturn (0); /* async */\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "ahc_find_period __P((struct ahc_softc *ahc, u_int scsirate,\n\t\t\t\t  u_int maxsync));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "static struct ahc_syncrate ahc_syncrates[] = {\n      /* ultra2    fast/ultra  period     rate */\n\t{ 0x42,      0x000,      9,      \"80.0\" },\n\t{ 0x03,      0x000,     10,      \"40.0\" },\n\t{ 0x04,      0x000,     11,      \"33.0\" },\n\t{ 0x05,      0x100,     12,      \"20.0\" },\n\t{ 0x06,      0x110,     15,      \"16.0\" },\n\t{ 0x07,      0x120,     18,      \"13.4\" },\n\t{ 0x08,      0x000,     25,      \"10.0\" },\n\t{ 0x19,      0x010,     31,      \"8.0\"  },\n\t{ 0x1a,      0x020,     37,      \"6.67\" },\n\t{ 0x1b,      0x030,     43,      \"5.7\"  },\n\t{ 0x1c,      0x040,     50,      \"5.0\"  },\n\t{ 0x00,      0x050,     56,      \"4.4\"  },\n\t{ 0x00,      0x060,     62,      \"4.0\"  },\n\t{ 0x00,      0x070,     68,      \"3.6\"  },\n\t{ 0x00,      0x000,      0,      NULL   }\n};",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "u_int *period;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "u_int *period;",
            "u_int maxsync;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nahc_find_period __P((struct ahc_softc *ahc, u_int scsirate,\n\t\t\t\t  u_int maxsync));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nstatic struct ahc_syncrate ahc_syncrates[] = {\n      /* ultra2    fast/ultra  period     rate */\n\t{ 0x42,      0x000,      9,      \"80.0\" },\n\t{ 0x03,      0x000,     10,      \"40.0\" },\n\t{ 0x04,      0x000,     11,      \"33.0\" },\n\t{ 0x05,      0x100,     12,      \"20.0\" },\n\t{ 0x06,      0x110,     15,      \"16.0\" },\n\t{ 0x07,      0x120,     18,      \"13.4\" },\n\t{ 0x08,      0x000,     25,      \"10.0\" },\n\t{ 0x19,      0x010,     31,      \"8.0\"  },\n\t{ 0x1a,      0x020,     37,      \"6.67\" },\n\t{ 0x1b,      0x030,     43,      \"5.7\"  },\n\t{ 0x1c,      0x040,     50,      \"5.0\"  },\n\t{ 0x00,      0x050,     56,      \"4.4\"  },\n\t{ 0x00,      0x060,     62,      \"4.0\"  },\n\t{ 0x00,      0x070,     68,      \"3.6\"  },\n\t{ 0x00,      0x000,      0,      NULL   }\n};\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nu_int *period;\nu_int maxsync;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC u_int\nahc_find_period(ahc, scsirate, maxsync)\n\tstruct ahc_softc *ahc;\n\tu_int scsirate;\n\tu_int maxsync;\n{\n\tstruct ahc_syncrate *syncrate;\n\n\tif ((ahc->features & AHC_ULTRA2) != 0)\n\t\tscsirate &= SXFR_ULTRA2;\n\telse\n\t\tscsirate &= SXFR;\n\n\tsyncrate = &ahc_syncrates[maxsync];\n\twhile (syncrate->rate != NULL) {\n\n\t\tif ((ahc->features & AHC_ULTRA2) != 0) {\n\t\t\tif (syncrate->sxfr_u2 == 0)\n\t\t\t\tbreak;\n\t\t\telse if (scsirate == (syncrate->sxfr_u2 & SXFR_ULTRA2))\n\t\t\t\treturn (syncrate->period);\n\t\t} else if (scsirate == (syncrate->sxfr & SXFR)) {\n\t\t\t\treturn (syncrate->period);\n\t\t}\n\t\tsyncrate++;\n\t}\n\treturn (0); /* async */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "TARG_OFFSET + i"
          ],
          "line": 3825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "TARG_SCSIRATE + i"
          ],
          "line": 3808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "tinfo",
            "sizeof(*tinfo)"
          ],
          "line": 3792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_fetch_transinfo",
          "args": [
            "ahc",
            "channel",
            "our_id",
            "target_id",
            "&tstate"
          ],
          "line": 3789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "ULTRA_ENB"
          ],
          "line": 3768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "ULTRA_ENB + 1"
          ],
          "line": 3767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "DISC_DSB"
          ],
          "line": 3765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "DISC_DSB + 1"
          ],
          "line": 3764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 3757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SXFRCTL0",
            "DFON|SPIOEN"
          ],
          "line": 3741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SIMODE1",
            "ENSELTIMO|ENSCSIRST|ENSCSIPERR"
          ],
          "line": 3740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SXFRCTL1",
            "(scsi_conf & (ENSPCHK|STIMESEL))\n\t\t\t\t|term\n\t\t\t\t|ENSTIMER|ACTNEGEN"
          ],
          "line": 3737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCSICONF"
          ],
          "line": 3736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCSIID",
            "ahc->our_id"
          ],
          "line": 3735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCSIID_ULTRA2",
            "ahc->our_id"
          ],
          "line": 3733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SBLKCTL",
            "ahc_inb(ahc, SBLKCTL) & ~SELBUSB"
          ],
          "line": 3729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SBLKCTL"
          ],
          "line": 3729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SXFRCTL0",
            "DFON|SPIOEN"
          ],
          "line": 3722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SIMODE1",
            "ENSELTIMO|ENSCSIRST|ENSCSIPERR"
          ],
          "line": 3721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SXFRCTL1",
            "(scsi_conf & (ENSPCHK|STIMESEL))\n\t\t\t\t\t|term|ENSTIMER|ACTNEGEN"
          ],
          "line": 3719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCSICONF + 1"
          ],
          "line": 3718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCSIID",
            "ahc->our_id_b"
          ],
          "line": 3717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCSIID_ULTRA2",
            "ahc->our_id_b"
          ],
          "line": 3715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 3699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SEQ_FLAGS",
            "0"
          ],
          "line": 3685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 3670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_alloc_tstate",
          "args": [
            "ahc",
            "ahc->our_id_b",
            "'B'"
          ],
          "line": 3668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 3663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_alloc_tstate",
          "args": [
            "ahc",
            "ahc->our_id",
            "'A'"
          ],
          "line": 3661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_sync",
          "args": [
            "ahc->sc_dmat",
            "ahc->shared_data_dmamap",
            "BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE"
          ],
          "line": 3653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahcinitscbdata",
          "args": [
            "ahc"
          ],
          "line": 3640
        },
        "resolved": true,
        "details": {
          "function_name": "ahcinitscbdata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "903-1002",
          "snippet": "STATIC int\nahcinitscbdata(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tstruct scb_data *scb_data;\n\tint i;\n\t\n\tscb_data = ahc->scb_data;\n\tSLIST_INIT(&scb_data->free_scbs);\n\tSLIST_INIT(&scb_data->sg_maps);\n\n\t/* Allocate SCB resources */\n\tscb_data->scbarray =\n\t    (struct scb *)malloc(sizeof(struct scb) * AHC_SCB_MAX,\n\t\t\t\t M_DEVBUF, M_NOWAIT);\n\tif (scb_data->scbarray == NULL)\n\t\treturn (ENOMEM);\n\tbzero(scb_data->scbarray, sizeof(struct scb) * AHC_SCB_MAX);\n\n\t/* Determine the number of hardware SCBs and initialize them */\n\n\tscb_data->maxhscbs = ahc_probe_scbs(ahc);\n\t/* SCB 0 heads the free list */\n\tahc_outb(ahc, FREE_SCBH, 0);\n\tfor (i = 0; i < ahc->scb_data->maxhscbs; i++) {\n\t\tahc_outb(ahc, SCBPTR, i);\n\n\t\t/* Clear the control byte. */\n\t\tahc_outb(ahc, SCB_CONTROL, 0);\n\n\t\t/* Set the next pointer */\n\t\tahc_outb(ahc, SCB_NEXT, i+1);\n\n\t\t/* Make the tag number invalid */\n\t\tahc_outb(ahc, SCB_TAG, SCB_LIST_NULL);\n\t}\n\n\t/* Make sure that the last SCB terminates the free list */\n\tahc_outb(ahc, SCBPTR, i-1);\n\tahc_outb(ahc, SCB_NEXT, SCB_LIST_NULL);\n\n\t/* Ensure we clear the 0 SCB's control byte. */\n\tahc_outb(ahc, SCBPTR, 0);\n\tahc_outb(ahc, SCB_CONTROL, 0);\n\n\tscb_data->maxhscbs = i;\n\n\tif (ahc->scb_data->maxhscbs == 0)\n\t\tpanic(\"%s: No SCB space found\", ahc_name(ahc));\n\n\t/*\n\t * Create our DMA tags.  These tags define the kinds of device\n\t * accessable memory allocations and memory mappings we will\n\t * need to perform during normal operation.\n\t *\n\t * Unless we need to further restrict the allocation, we rely\n\t * on the restrictions of the parent dmat, hence the common\n\t * use of MAXADDR and MAXSIZE.\n\t */\n\n\tif (ahc_createdmamem(ahc,\n\t    AHC_SCB_MAX * sizeof(struct hardware_scb), \n\t    &scb_data->hscb_dmamap, (caddr_t *)&scb_data->hscbs, \n\t    &scb_data->hscb_busaddr, &scb_data->hscb_seg,\n\t    &scb_data->hscb_nseg, \"hardware SCB structures\") < 0)\n\t\tgoto error_exit;\n\n\tscb_data->init_level++;\n\n\tif (ahc_createdmamem(ahc,\n\t    AHC_SCB_MAX * sizeof(struct scsi_sense_data),\n\t    &scb_data->sense_dmamap, (caddr_t *)&scb_data->sense,\n\t    &scb_data->sense_busaddr, &scb_data->sense_seg,\n\t    &scb_data->sense_nseg, \"sense buffers\") < 0)\n\t\tgoto error_exit;\n\n\tscb_data->init_level++;\n\n\t/* Perform initial CCB allocation */\n\tbzero(scb_data->hscbs, AHC_SCB_MAX * sizeof(struct hardware_scb));\n\tahcallocscbs(ahc);\n\n\tif (scb_data->numscbs == 0) {\n\t\tprintf(\"%s: ahc_init_scb_data - \"\n\t\t       \"Unable to allocate initial scbs\\n\",\n\t\t       ahc_name(ahc));\n\t\tgoto error_exit;\n\t}\n\n\tscb_data->init_level++;\n\n\t/*\n\t * Note that we were successfull\n\t */\n\treturn 0; \n\nerror_exit:\n\n\treturn ENOMEM;\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_calc_residual __P((struct scb *scb));",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
            "int    ahc_createdmamem",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_calc_residual __P((struct scb *scb));\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nint    ahc_createdmamem;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC int\nahcinitscbdata(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tstruct scb_data *scb_data;\n\tint i;\n\t\n\tscb_data = ahc->scb_data;\n\tSLIST_INIT(&scb_data->free_scbs);\n\tSLIST_INIT(&scb_data->sg_maps);\n\n\t/* Allocate SCB resources */\n\tscb_data->scbarray =\n\t    (struct scb *)malloc(sizeof(struct scb) * AHC_SCB_MAX,\n\t\t\t\t M_DEVBUF, M_NOWAIT);\n\tif (scb_data->scbarray == NULL)\n\t\treturn (ENOMEM);\n\tbzero(scb_data->scbarray, sizeof(struct scb) * AHC_SCB_MAX);\n\n\t/* Determine the number of hardware SCBs and initialize them */\n\n\tscb_data->maxhscbs = ahc_probe_scbs(ahc);\n\t/* SCB 0 heads the free list */\n\tahc_outb(ahc, FREE_SCBH, 0);\n\tfor (i = 0; i < ahc->scb_data->maxhscbs; i++) {\n\t\tahc_outb(ahc, SCBPTR, i);\n\n\t\t/* Clear the control byte. */\n\t\tahc_outb(ahc, SCB_CONTROL, 0);\n\n\t\t/* Set the next pointer */\n\t\tahc_outb(ahc, SCB_NEXT, i+1);\n\n\t\t/* Make the tag number invalid */\n\t\tahc_outb(ahc, SCB_TAG, SCB_LIST_NULL);\n\t}\n\n\t/* Make sure that the last SCB terminates the free list */\n\tahc_outb(ahc, SCBPTR, i-1);\n\tahc_outb(ahc, SCB_NEXT, SCB_LIST_NULL);\n\n\t/* Ensure we clear the 0 SCB's control byte. */\n\tahc_outb(ahc, SCBPTR, 0);\n\tahc_outb(ahc, SCB_CONTROL, 0);\n\n\tscb_data->maxhscbs = i;\n\n\tif (ahc->scb_data->maxhscbs == 0)\n\t\tpanic(\"%s: No SCB space found\", ahc_name(ahc));\n\n\t/*\n\t * Create our DMA tags.  These tags define the kinds of device\n\t * accessable memory allocations and memory mappings we will\n\t * need to perform during normal operation.\n\t *\n\t * Unless we need to further restrict the allocation, we rely\n\t * on the restrictions of the parent dmat, hence the common\n\t * use of MAXADDR and MAXSIZE.\n\t */\n\n\tif (ahc_createdmamem(ahc,\n\t    AHC_SCB_MAX * sizeof(struct hardware_scb), \n\t    &scb_data->hscb_dmamap, (caddr_t *)&scb_data->hscbs, \n\t    &scb_data->hscb_busaddr, &scb_data->hscb_seg,\n\t    &scb_data->hscb_nseg, \"hardware SCB structures\") < 0)\n\t\tgoto error_exit;\n\n\tscb_data->init_level++;\n\n\tif (ahc_createdmamem(ahc,\n\t    AHC_SCB_MAX * sizeof(struct scsi_sense_data),\n\t    &scb_data->sense_dmamap, (caddr_t *)&scb_data->sense,\n\t    &scb_data->sense_busaddr, &scb_data->sense_seg,\n\t    &scb_data->sense_nseg, \"sense buffers\") < 0)\n\t\tgoto error_exit;\n\n\tscb_data->init_level++;\n\n\t/* Perform initial CCB allocation */\n\tbzero(scb_data->hscbs, AHC_SCB_MAX * sizeof(struct hardware_scb));\n\tahcallocscbs(ahc);\n\n\tif (scb_data->numscbs == 0) {\n\t\tprintf(\"%s: ahc_init_scb_data - \"\n\t\t       \"Unable to allocate initial scbs\\n\",\n\t\t       ahc_name(ahc));\n\t\tgoto error_exit;\n\t}\n\n\tscb_data->init_level++;\n\n\t/*\n\t * Note that we were successfull\n\t */\n\treturn 0; \n\nerror_exit:\n\n\treturn ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_createdmamem",
          "args": [
            "ahc",
            "driver_data_size",
            "&ahc->shared_data_dmamap",
            "(caddr_t *)&ahc->qoutfifo",
            "&ahc->shared_data_busaddr",
            "&ahc->shared_data_seg",
            "&ahc->shared_data_nseg",
            "\"shared data\""
          ],
          "line": 3630
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_createdmamem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "678-745",
          "snippet": "int\nahc_createdmamem(ahc, size, mapp, vaddr, baddr, seg, nseg, what)\n\tstruct ahc_softc *ahc;\n\tint size;\n\tbus_dmamap_t *mapp;\n\tcaddr_t *vaddr;\n\tbus_addr_t *baddr;\n\tbus_dma_segment_t *seg;\n\tint *nseg;\n\tconst char *what;\n{\n\tint error, level = 0;\n\tint dma_flags = BUS_DMA_NOWAIT;\n\tbus_dma_tag_t tag = ahc->sc_dmat;\n\tconst char *myname = ahc_name(ahc);\n\tif ((ahc->chip & AHC_VL) !=0)\n\t\tdma_flags |= ISABUS_DMA_32BIT;\n\t\n\tif ((error = bus_dmamem_alloc(tag, size, NBPG, 0,\n\t\t\tseg, 1, nseg, BUS_DMA_NOWAIT)) != 0) {\n\t\tprintf(\"%s: failed to allocate DMA mem for %s, error = %d\\n\",\n\t\t\tmyname, what, error);\n\t\tgoto out;\n\t}\n\tlevel++;\n\n\tif ((error = bus_dmamem_map(tag, seg, *nseg, size, vaddr,\n\t\t\tBUS_DMA_NOWAIT|BUS_DMA_COHERENT)) != 0) {\n\t\tprintf(\"%s: failed to map DMA mem for %s, error = %d\\n\",\n\t\t\tmyname, what, error);\n\t\tgoto out;\n\t}\n\tlevel++;\n\n\tif ((error = bus_dmamap_create(tag, size, 1, size, 0,\n\t\t\tdma_flags, mapp)) != 0) {\n\t\tprintf(\"%s: failed to create DMA map for %s, error = %d\\n\",\n\t\t\tmyname, what, error);\n\t\tgoto out;\n        }\n\tlevel++;\n\n\tif ((error = bus_dmamap_load(tag, *mapp, *vaddr, size, NULL,\n\t\t\tBUS_DMA_NOWAIT)) != 0) {\n\t\tprintf(\"%s: failed to load DMA map for %s, error = %d\\n\",\n\t\t\tmyname, what, error);\n\t\tgoto out;\n        }\n\n\t*baddr = (*mapp)->dm_segs[0].ds_addr;\n\treturn 0;\nout:\n\tswitch (level) {\n\tcase 3:\n\t\tbus_dmamap_destroy(tag, *mapp);\n\t\t/* FALLTHROUGH */\n\tcase 2:\n\t\tbus_dmamem_unmap(tag, *vaddr, size);\n\t\t/* FALLTHROUGH */\n\tcase 1:\n\t\tbus_dmamem_free(tag, seg, *nseg);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define ISABUS_DMA_32BIT\tBUS_DMA_BUS1"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "int    ahc_createdmamem",
            "ahc_freedmamem __P((bus_dma_tag_t tag, int size,\n\t\t\t\tbus_dmamap_t map, caddr_t vaddr,\n\t\t\t\tbus_dma_segment_t *seg, int nseg));",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define ISABUS_DMA_32BIT\tBUS_DMA_BUS1\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC struct;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nahc_loadseq __P((struct ahc_softc *ahc));\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nahc_clear_intstat __P((struct ahc_softc *ahc));\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nrestart_sequencer __P((struct ahc_softc *ahc));\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nint    ahc_createdmamem;\nahc_freedmamem __P((bus_dma_tag_t tag, int size,\n\t\t\t\tbus_dmamap_t map, caddr_t vaddr,\n\t\t\t\tbus_dma_segment_t *seg, int nseg));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nint\nahc_createdmamem(ahc, size, mapp, vaddr, baddr, seg, nseg, what)\n\tstruct ahc_softc *ahc;\n\tint size;\n\tbus_dmamap_t *mapp;\n\tcaddr_t *vaddr;\n\tbus_addr_t *baddr;\n\tbus_dma_segment_t *seg;\n\tint *nseg;\n\tconst char *what;\n{\n\tint error, level = 0;\n\tint dma_flags = BUS_DMA_NOWAIT;\n\tbus_dma_tag_t tag = ahc->sc_dmat;\n\tconst char *myname = ahc_name(ahc);\n\tif ((ahc->chip & AHC_VL) !=0)\n\t\tdma_flags |= ISABUS_DMA_32BIT;\n\t\n\tif ((error = bus_dmamem_alloc(tag, size, NBPG, 0,\n\t\t\tseg, 1, nseg, BUS_DMA_NOWAIT)) != 0) {\n\t\tprintf(\"%s: failed to allocate DMA mem for %s, error = %d\\n\",\n\t\t\tmyname, what, error);\n\t\tgoto out;\n\t}\n\tlevel++;\n\n\tif ((error = bus_dmamem_map(tag, seg, *nseg, size, vaddr,\n\t\t\tBUS_DMA_NOWAIT|BUS_DMA_COHERENT)) != 0) {\n\t\tprintf(\"%s: failed to map DMA mem for %s, error = %d\\n\",\n\t\t\tmyname, what, error);\n\t\tgoto out;\n\t}\n\tlevel++;\n\n\tif ((error = bus_dmamap_create(tag, size, 1, size, 0,\n\t\t\tdma_flags, mapp)) != 0) {\n\t\tprintf(\"%s: failed to create DMA map for %s, error = %d\\n\",\n\t\t\tmyname, what, error);\n\t\tgoto out;\n        }\n\tlevel++;\n\n\tif ((error = bus_dmamap_load(tag, *mapp, *vaddr, size, NULL,\n\t\t\tBUS_DMA_NOWAIT)) != 0) {\n\t\tprintf(\"%s: failed to load DMA map for %s, error = %d\\n\",\n\t\t\tmyname, what, error);\n\t\tgoto out;\n        }\n\n\t*baddr = (*mapp)->dm_segs[0].ds_addr;\n\treturn 0;\nout:\n\tswitch (level) {\n\tcase 3:\n\t\tbus_dmamap_destroy(tag, *mapp);\n\t\t/* FALLTHROUGH */\n\tcase 2:\n\t\tbus_dmamem_unmap(tag, *vaddr, size);\n\t\t/* FALLTHROUGH */\n\tcase 1:\n\t\tbus_dmamem_free(tag, seg, *nseg);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "scb_data",
            "sizeof(struct scb_data)"
          ],
          "line": 3605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 3602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof (struct scb_data)",
            "M_DEVBUF",
            "M_NOWAIT"
          ],
          "line": 3600
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "i"
          ],
          "line": 3593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "i"
          ],
          "line": 3586
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define AHC_SYNCRATE_FAST\t6\n#define AHC_SYNCRATE_ULTRA\t3\n#define AHC_SYNCRATE_ULTRA2\t1\n#define AHC_SYNCRATE_DT\t\t0\n#define bootverbose\t0\n#define bootverbose\t1\n#define ALL_TARGETS_MASK 0xFFFF\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nahc_poll __P((struct ahc_softc *ahc, int wait));\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nahcallocscbs __P((struct ahc_softc *ahc));\nahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));\nSTATIC u_int;\nSTATIC struct;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nahc_loadseq __P((struct ahc_softc *ahc));\nahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));\nSTATIC u_int;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nahc_clear_intstat __P((struct ahc_softc *ahc));\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nahc_find_period __P((struct ahc_softc *ahc, u_int scsirate,\n\t\t\t\t  u_int maxsync));\nahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));\nahc_calc_residual __P((struct scb *scb));\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nrestart_sequencer __P((struct ahc_softc *ahc));\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nint    ahc_createdmamem;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nu_int our_id;\nstruct tmode_tstate **tstate;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nstatic struct ahc_syncrate ahc_syncrates[] = {\n      /* ultra2    fast/ultra  period     rate */\n\t{ 0x42,      0x000,      9,      \"80.0\" },\n\t{ 0x03,      0x000,     10,      \"40.0\" },\n\t{ 0x04,      0x000,     11,      \"33.0\" },\n\t{ 0x05,      0x100,     12,      \"20.0\" },\n\t{ 0x06,      0x110,     15,      \"16.0\" },\n\t{ 0x07,      0x120,     18,      \"13.4\" },\n\t{ 0x08,      0x000,     25,      \"10.0\" },\n\t{ 0x19,      0x010,     31,      \"8.0\"  },\n\t{ 0x1a,      0x020,     37,      \"6.67\" },\n\t{ 0x1b,      0x030,     43,      \"5.7\"  },\n\t{ 0x1c,      0x040,     50,      \"5.0\"  },\n\t{ 0x00,      0x050,     56,      \"4.4\"  },\n\t{ 0x00,      0x060,     62,      \"4.0\"  },\n\t{ 0x00,      0x070,     68,      \"3.6\"  },\n\t{ 0x00,      0x000,      0,      NULL   }\n};\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nu_int *period;\nu_int maxsync;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nint\nahc_init(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tint\t  max_targ = 15;\n\tint\t  i;\n\tint\t  term;\n\tu_int\t  scsi_conf;\n\tu_int\t  scsiseq_template;\n\tu_int\t  ultraenb;\n\tu_int\t  discenable;\n\tu_int\t  tagenable;\n\tsize_t\t  driver_data_size;\n\tu_int32_t physaddr;\n\tstruct scb_data *scb_data = NULL;\n\n#ifdef AHC_PRINT_SRAM\n\tprintf(\"Scratch Ram:\");\n\tfor (i = 0x20; i < 0x5f; i++) {\n\t\tif (((i % 8) == 0) && (i != 0)) {\n\t\t\tprintf (\"\\n              \");\n\t\t}\n\t\tprintf (\" 0x%x\", ahc_inb(ahc, i));\n\t}\n\tif ((ahc->features & AHC_MORE_SRAM) != 0) {\n\t\tfor (i = 0x70; i < 0x7f; i++) {\n\t\t\tif (((i % 8) == 0) && (i != 0)) {\n\t\t\t\tprintf (\"\\n              \");\n\t\t\t}\n\t\t\tprintf (\" 0x%x\", ahc_inb(ahc, i));\n\t\t}\n\t}\n\tprintf (\"\\n\");\n#endif\n\n\tif (ahc->scb_data == NULL) {\n\t\tscb_data = malloc(sizeof (struct scb_data), M_DEVBUF, M_NOWAIT);\n\t\tif (scb_data == NULL) {\n\t\t\tprintf(\"%s: cannot malloc scb_data!\\n\", ahc_name(ahc));\n\t\t\treturn (ENOMEM);\n\t\t}\n\t\tbzero(scb_data, sizeof(struct scb_data));\n\t\tahc->scb_data = scb_data;\n\t}\n\t/*\n\t * Assume we have a board at this stage and it has been reset.\n\t */\n\tif ((ahc->flags & AHC_USEDEFAULTS) != 0)\n\t\tahc->our_id = ahc->our_id_b = 7;\n\t\n\t/*\n\t * Default to allowing initiator operations.\n\t */\n\tahc->flags |= AHC_INITIATORMODE;\n\t\n\t/*\n\t * DMA tag for our command fifos and other data in system memory\n\t * the card's sequencer must be able to access.  For initiator\n\t * roles, we need to allocate space for the qinfifo, qoutfifo,\n\t * and untagged_scb arrays each of which are composed of 256\n\t * 1 byte elements.  When providing for the target mode role,\n\t * we additionally must provide space for the incoming target\n\t * command fifo.\n\t */\n\tdriver_data_size = 3 * 256 * sizeof(u_int8_t);\n\n\tif (ahc_createdmamem(ahc, driver_data_size, \n\t    &ahc->shared_data_dmamap, (caddr_t *)&ahc->qoutfifo,\n\t    &ahc->shared_data_busaddr, &ahc->shared_data_seg,\n\t    &ahc->shared_data_nseg, \"shared data\") < 0)\n\t\treturn (ENOMEM);\n\n\tahc->init_level++;\n\n\t/* Allocate SCB data now that sc_dmat is initialized */\n\tif (ahc->scb_data->maxhscbs == 0)\n\t\tif (ahcinitscbdata(ahc) != 0)\n\t\t\treturn (ENOMEM);\n\n\tahc->qinfifo = &ahc->qoutfifo[256];\n\tahc->untagged_scbs = &ahc->qinfifo[256];\n\t/* There are no untagged SCBs active yet. */\n\tfor (i = 0; i < 256; i++)\n\t\tahc->untagged_scbs[i] = SCB_LIST_NULL;\n\n\t/* All of our queues are empty */\n\tfor (i = 0; i < 256; i++)\n\t\tahc->qoutfifo[i] = SCB_LIST_NULL;\n\n\tbus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap,\n\t\t\tBUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);\n\t\n\t/*\n\t * Allocate a tstate to house information for our\n\t * initiator presence on the bus as well as the user\n\t * data for any target mode initiator.\n\t */\n\tif (ahc_alloc_tstate(ahc, ahc->our_id, 'A') == NULL) {\n\t\tprintf(\"%s: unable to allocate tmode_tstate.  \"\n\t\t       \"Failing attach\\n\", ahc_name(ahc));\n\t\treturn (-1);\n\t}\n\n\tif ((ahc->features & AHC_TWIN) != 0) {\n\t\tif (ahc_alloc_tstate(ahc, ahc->our_id_b, 'B') == NULL) {\n\t\t\tprintf(\"%s: unable to allocate tmode_tstate.  \"\n\t\t\t       \"Failing attach\\n\", ahc_name(ahc));\n\t\t\treturn (-1);\n\t\t}\n \t\tprintf(\"Twin Channel, A SCSI Id=%d, B SCSI Id=%d, primary %c, \",\n\t\t       ahc->our_id, ahc->our_id_b,\n\t\t       ahc->flags & AHC_CHANNEL_B_PRIMARY? 'B': 'A');\n\t} else {\n\t\tif ((ahc->features & AHC_WIDE) != 0) {\n\t\t\tprintf(\"Wide \");\n\t\t} else {\n\t\t\tprintf(\"Single \");\n\t\t}\n\t\tprintf(\"Channel %c, SCSI Id=%d, \", ahc->channel, ahc->our_id);\n\t}\n\n\tahc_outb(ahc, SEQ_FLAGS, 0);\n\n\tif (ahc->scb_data->maxhscbs < AHC_SCB_MAX) {\n\t\tahc->flags |= AHC_PAGESCBS;\n\t\tprintf(\"%d/%d SCBs\\n\", ahc->scb_data->maxhscbs, AHC_SCB_MAX);\n\t} else {\n\t\tahc->flags &= ~AHC_PAGESCBS;\n\t\tprintf(\"%d SCBs\\n\", ahc->scb_data->maxhscbs);\n\t}\n\n#ifdef AHC_DEBUG\n\tif (ahc_debug & AHC_SHOWMISC) {\n\t\tprintf(\"%s: hardware scb %d bytes; kernel scb %d bytes; \"\n\t\t       \"ahc_dma %d bytes\\n\",\n\t\t\tahc_name(ahc),\n\t\t        sizeof(struct hardware_scb),\n\t\t\tsizeof(struct scb),\n\t\t\tsizeof(struct ahc_dma_seg));\n\t}\n#endif /* AHC_DEBUG */\n\n\t/* Set the SCSI Id,SXFRCTL0,SXFRCTL1, and SIMODE1, for both channels*/\n\tif (ahc->features & AHC_TWIN) {\n\n\t\t/*\n\t\t * The device is gated to channel B after a chip reset,\n\t\t * so set those values first\n\t\t */\n\t\tterm = (ahc->flags & AHC_TERM_ENB_B) != 0 ? STPWEN : 0;\n\t\tif ((ahc->features & AHC_ULTRA2) != 0)\n\t\t\tahc_outb(ahc, SCSIID_ULTRA2, ahc->our_id_b);\n\t\telse\n\t\t\tahc_outb(ahc, SCSIID, ahc->our_id_b);\n\t\tscsi_conf = ahc_inb(ahc, SCSICONF + 1);\n\t\tahc_outb(ahc, SXFRCTL1, (scsi_conf & (ENSPCHK|STIMESEL))\n\t\t\t\t\t|term|ENSTIMER|ACTNEGEN);\n\t\tahc_outb(ahc, SIMODE1, ENSELTIMO|ENSCSIRST|ENSCSIPERR);\n\t\tahc_outb(ahc, SXFRCTL0, DFON|SPIOEN);\n\n\t\tif ((scsi_conf & RESET_SCSI) != 0\n\t\t && (ahc->flags & AHC_INITIATORMODE) != 0)\n\t\t\tahc->flags |= AHC_RESET_BUS_B;\n\n\t\t/* Select Channel A */\n\t\tahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) & ~SELBUSB);\n\t}\n\tterm = (ahc->flags & AHC_TERM_ENB_A) != 0 ? STPWEN : 0;\n\tif ((ahc->features & AHC_ULTRA2) != 0)\n\t\tahc_outb(ahc, SCSIID_ULTRA2, ahc->our_id);\n\telse\n\t\tahc_outb(ahc, SCSIID, ahc->our_id);\n\tscsi_conf = ahc_inb(ahc, SCSICONF);\n\tahc_outb(ahc, SXFRCTL1, (scsi_conf & (ENSPCHK|STIMESEL))\n\t\t\t\t|term\n\t\t\t\t|ENSTIMER|ACTNEGEN);\n\tahc_outb(ahc, SIMODE1, ENSELTIMO|ENSCSIRST|ENSCSIPERR);\n\tahc_outb(ahc, SXFRCTL0, DFON|SPIOEN);\n\n\tif ((scsi_conf & RESET_SCSI) != 0\n\t && (ahc->flags & AHC_INITIATORMODE) != 0)\n\t\tahc->flags |= AHC_RESET_BUS_A;\n\n\t/*\n\t * Look at the information that board initialization or\n\t * the board bios has left us.\n\t */\n\tultraenb = 0;\t\n\ttagenable = ALL_TARGETS_MASK;\n\n\t/* Grab the disconnection disable table and invert it for our needs */\n\tif (ahc->flags & AHC_USEDEFAULTS) {\n\t\tprintf(\"%s: Host Adapter Bios disabled.  Using default SCSI \"\n\t\t\t\"device parameters\\n\", ahc_name(ahc));\n\t\tahc->flags |= AHC_EXTENDED_TRANS_A|AHC_EXTENDED_TRANS_B|\n\t\t\t      AHC_TERM_ENB_A|AHC_TERM_ENB_B;\n\t\tdiscenable = ALL_TARGETS_MASK;\n\t\tif ((ahc->features & AHC_ULTRA) != 0)\n\t\t\tultraenb = ALL_TARGETS_MASK;\n\t} else {\n\t\tdiscenable = ~((ahc_inb(ahc, DISC_DSB + 1) << 8)\n\t\t\t   | ahc_inb(ahc, DISC_DSB));\n\t\tif ((ahc->features & (AHC_ULTRA|AHC_ULTRA2)) != 0)\n\t\t\tultraenb = (ahc_inb(ahc, ULTRA_ENB + 1) << 8)\n\t\t\t\t      | ahc_inb(ahc, ULTRA_ENB);\n\t}\n\n\tif ((ahc->features & (AHC_WIDE|AHC_TWIN)) == 0)\n\t\tmax_targ = 7;\n\n\tfor (i = 0; i <= max_targ; i++) {\n\t\tstruct ahc_initiator_tinfo *tinfo;\n\t\tstruct tmode_tstate *tstate;\n\t\tu_int our_id;\n\t\tu_int target_id;\n\t\tchar channel;\n\n\t\tchannel = 'A';\n\t\tour_id = ahc->our_id;\n\t\ttarget_id = i;\n\t\tif (i > 7 && (ahc->features & AHC_TWIN) != 0) {\n\t\t\tchannel = 'B';\n\t\t\tour_id = ahc->our_id_b;\n\t\t\ttarget_id = i % 8;\n\t\t}\n\t\ttinfo = ahc_fetch_transinfo(ahc, channel, our_id,\n\t\t\t\t\t    target_id, &tstate);\n\t\t/* Default to async narrow across the board */\n\t\tbzero(tinfo, sizeof(*tinfo));\n\t\tif (ahc->flags & AHC_USEDEFAULTS) {\n\t\t\tif ((ahc->features & AHC_WIDE) != 0)\n\t\t\t\ttinfo->user.width = MSG_EXT_WDTR_BUS_16_BIT;\n\n\t\t\t/*\n\t\t\t * These will be truncated when we determine the\n\t\t\t * connection type we have with the target.\n\t\t\t */\n\t\t\ttinfo->user.period = ahc_syncrates->period;\n\t\t\ttinfo->user.offset = ~0;\n\t\t} else {\n\t\t\tu_int scsirate;\n\t\t\tu_int16_t mask;\n\n\t\t\t/* Take the settings leftover in scratch RAM. */\n\t\t\tscsirate = ahc_inb(ahc, TARG_SCSIRATE + i);\n\t\t\tmask = (0x01 << i);\n\t\t\tif ((ahc->features & AHC_ULTRA2) != 0) {\n\t\t\t\tu_int offset;\n\t\t\t\tu_int maxsync;\n\n\t\t\t\tif ((scsirate & SOFS) == 0x0F) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Haven't negotiated yet,\n\t\t\t\t\t * so the format is different.\n\t\t\t\t\t */\n\t\t\t\t\tscsirate = (scsirate & SXFR) >> 4\n\t\t\t\t\t\t | (ultraenb & mask)\n\t\t\t\t\t\t  ? 0x08 : 0x0\n\t\t\t\t\t\t | (scsirate & WIDEXFER);\n\t\t\t\t\toffset = MAX_OFFSET_ULTRA2;\n\t\t\t\t} else\n\t\t\t\t\toffset = ahc_inb(ahc, TARG_OFFSET + i);\n\t\t\t\tmaxsync = AHC_SYNCRATE_ULTRA2;\n\t\t\t\tif ((ahc->features & AHC_DT) != 0)\n\t\t\t\t\tmaxsync = AHC_SYNCRATE_DT;\n\t\t\t\ttinfo->user.period =\n\t\t\t\t    ahc_find_period(ahc, scsirate, maxsync);\n\t\t\t\tif (offset == 0)\n\t\t\t\t\ttinfo->user.period = 0;\n\t\t\t\telse\n\t\t\t\t\ttinfo->user.offset = ~0;\n\t\t\t} else if ((scsirate & SOFS) != 0) {\n\t\t\t\ttinfo->user.period = \n\t\t\t\t    ahc_find_period(ahc, scsirate,\n\t\t\t\t\t\t    (ultraenb & mask)\n\t\t\t\t\t\t   ? AHC_SYNCRATE_ULTRA\n\t\t\t\t\t\t   : AHC_SYNCRATE_FAST);\n\t\t\t\tif (tinfo->user.period != 0)\n\t\t\t\t\ttinfo->user.offset = ~0;\n\t\t\t}\n\t\t\tif ((scsirate & WIDEXFER) != 0\n\t\t\t && (ahc->features & AHC_WIDE) != 0)\n\t\t\t\ttinfo->user.width = MSG_EXT_WDTR_BUS_16_BIT;\n\t\t}\n\t\ttinfo->goal = tinfo->user; /* force negotiation */\n\t\ttstate->ultraenb = ultraenb;\n\t\ttstate->discenable = discenable;\n\t\ttstate->tagenable = 0; /* Wait until the XPT says its okay */\n\t}\n\tahc->user_discenable = discenable;\n\tahc->user_tagenable = tagenable;\n\n\t/*\n\t * Tell the sequencer where it can find our arrays in memory.\n\t */\n\tphysaddr = ahc->scb_data->hscb_busaddr;\n\tahc_outb(ahc, HSCB_ADDR, physaddr & 0xFF);\n\tahc_outb(ahc, HSCB_ADDR + 1, (physaddr >> 8) & 0xFF);\n\tahc_outb(ahc, HSCB_ADDR + 2, (physaddr >> 16) & 0xFF);\n\tahc_outb(ahc, HSCB_ADDR + 3, (physaddr >> 24) & 0xFF);\n\n\tphysaddr = ahc->shared_data_busaddr;\n\tahc_outb(ahc, SCBID_ADDR, physaddr & 0xFF);\n\tahc_outb(ahc, SCBID_ADDR + 1, (physaddr >> 8) & 0xFF);\n\tahc_outb(ahc, SCBID_ADDR + 2, (physaddr >> 16) & 0xFF);\n\tahc_outb(ahc, SCBID_ADDR + 3, (physaddr >> 24) & 0xFF);\n\n\t/* Target mode incomding command fifo */\n\tphysaddr += 3 * 256 * sizeof(u_int8_t);\n\tahc_outb(ahc, TMODE_CMDADDR, physaddr & 0xFF);\n\tahc_outb(ahc, TMODE_CMDADDR + 1, (physaddr >> 8) & 0xFF);\n\tahc_outb(ahc, TMODE_CMDADDR + 2, (physaddr >> 16) & 0xFF);\n\tahc_outb(ahc, TMODE_CMDADDR + 3, (physaddr >> 24) & 0xFF);\n\n\t/*\n\t * Initialize the group code to command length table.\n\t * This overrides the values in TARG_SCSIRATE, so only\n\t * setup the table after we have processed that information.\n\t */\n\tahc_outb(ahc, CMDSIZE_TABLE, 5);\n\tahc_outb(ahc, CMDSIZE_TABLE + 1, 9);\n\tahc_outb(ahc, CMDSIZE_TABLE + 2, 9);\n\tahc_outb(ahc, CMDSIZE_TABLE + 3, 0);\n\tahc_outb(ahc, CMDSIZE_TABLE + 4, 15);\n\tahc_outb(ahc, CMDSIZE_TABLE + 5, 11);\n\tahc_outb(ahc, CMDSIZE_TABLE + 6, 0);\n\tahc_outb(ahc, CMDSIZE_TABLE + 7, 0);\n\t\t\n\t/* Tell the sequencer of our initial queue positions */\n\tahc_outb(ahc, KERNEL_QINPOS, 0);\n\tahc_outb(ahc, QINPOS, 0);\n\tahc_outb(ahc, QOUTPOS, 0);\n\n#ifdef AHC_DEBUG\n\tif (ahc_debug & AHC_SHOWMISC)\n\t\tprintf(\"NEEDSDTR == 0x%x\\nNEEDWDTR == 0x%x\\n\"\n\t\t       \"DISCENABLE == 0x%x\\nULTRAENB == 0x%x\\n\",\n\t\t       ahc->needsdtr_orig, ahc->needwdtr_orig,\n\t\t       discenable, ultraenb);\n#endif\n\n\t/* Don't have any special messages to send to targets */\n\tahc_outb(ahc, TARGET_MSG_REQUEST, 0);\n\tahc_outb(ahc, TARGET_MSG_REQUEST + 1, 0);\n\n\t/*\n\t * Use the built in queue management registers\n\t * if they are available.\n\t */\n\tif ((ahc->features & AHC_QUEUE_REGS) != 0) {\n\t\tahc_outb(ahc, QOFF_CTLSTA, SCB_QSIZE_256);\n\t\tahc_outb(ahc, SDSCB_QOFF, 0);\n\t\tahc_outb(ahc, SNSCB_QOFF, 0);\n\t\tahc_outb(ahc, HNSCB_QOFF, 0);\n\t}\n\n\n\t/* We don't have any waiting selections */\n\tahc_outb(ahc, WAITING_SCBH, SCB_LIST_NULL);\n\n\t/* Our disconnection list is empty too */\n\tahc_outb(ahc, DISCONNECTED_SCBH, SCB_LIST_NULL);\n\n\t/* Message out buffer starts empty */\n\tahc_outb(ahc, MSG_OUT, MSG_NOOP);\n\n\t/*\n\t * Setup the allowed SCSI Sequences based on operational mode.\n\t * If we are a target, we'll enalbe select in operations once\n\t * we've had a lun enabled.\n\t */\n\tscsiseq_template = ENSELO|ENAUTOATNO|ENAUTOATNP;\n\tif ((ahc->flags & AHC_INITIATORMODE) != 0)\n\t\tscsiseq_template |= ENRSELI;\n\tahc_outb(ahc, SCSISEQ_TEMPLATE, scsiseq_template);\n\n\t/*\n\t * Load the Sequencer program and Enable the adapter\n\t * in \"fast\" mode.\n         */\n\tif (bootverbose)\n\t\tprintf(\"%s: Downloading Sequencer Program...\",\n\t\t       ahc_name(ahc));\n\n\tahc_loadseq(ahc);\n\n\t/* We have to wait until after any system dumps... */\n\tshutdownhook_establish(ahc_shutdown, ahc);\n\treturn (0);\n}"
  },
  {
    "function_name": "ahc_probe_scbs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "3542-3559",
    "snippet": "int\nahc_probe_scbs(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tint i;\n\n\tfor (i = 0; i < AHC_SCB_MAX; i++) {\n\t\tahc_outb(ahc, SCBPTR, i);\n\t\tahc_outb(ahc, SCB_CONTROL, i);\n\t\tif (ahc_inb(ahc, SCB_CONTROL) != i)\n\t\t\tbreak;\n\t\tahc_outb(ahc, SCBPTR, 0);\n\t\tif (ahc_inb(ahc, SCB_CONTROL) != 0)\n\t\t\tbreak;\n\t}\n\t\n\treturn (i);\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCB_CONTROL"
          ],
          "line": 3554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCBPTR",
            "0"
          ],
          "line": 3553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCB_CONTROL"
          ],
          "line": 3551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCB_CONTROL",
            "i"
          ],
          "line": 3550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCBPTR",
            "i"
          ],
          "line": 3549
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC struct;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nahc_loadseq __P((struct ahc_softc *ahc));\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nahc_clear_intstat __P((struct ahc_softc *ahc));\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nrestart_sequencer __P((struct ahc_softc *ahc));\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nint\nahc_probe_scbs(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tint i;\n\n\tfor (i = 0; i < AHC_SCB_MAX; i++) {\n\t\tahc_outb(ahc, SCBPTR, i);\n\t\tahc_outb(ahc, SCB_CONTROL, i);\n\t\tif (ahc_inb(ahc, SCB_CONTROL) != i)\n\t\t\tbreak;\n\t\tahc_outb(ahc, SCBPTR, 0);\n\t\tif (ahc_inb(ahc, SCB_CONTROL) != 0)\n\t\t\tbreak;\n\t}\n\t\n\treturn (i);\n}"
  },
  {
    "function_name": "ahc_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "3401-3537",
    "snippet": "STATIC void\nahc_done(ahc, scb)\n\tstruct ahc_softc *ahc;\n\tstruct scb *scb;\n{\n\tstruct scsi_xfer *xs = scb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tint requeue = 0;\n\tint target;\n\n\tSC_DEBUG(xs->sc_link, SDEV_DB2, (\"ahc_done\\n\"));\n\t\n\tLIST_REMOVE(scb, pend_links);\n\n\tuntimeout(ahc_timeout, (caddr_t)scb);\n\n#ifdef AHC_DEBUG\n\tif (ahc_debug & AHC_SHOWCMDS) {\n\t\tsc_print_addr(sc_link);\n\t\tprintf(\"ahc_done opcode %d tag %x\\n\", xs->cmdstore.opcode,\n\t\t    scb->hscb->tag);\n\t}\n#endif\n\t\n\ttarget = sc_link->target;\n\t\n\tif (xs->datalen) {\n\t\tbus_dmasync_op_t op;\n\t\n\t\tif ((xs->flags & SCSI_DATA_IN) != 0)\n\t\t\top = BUS_DMASYNC_POSTREAD;\n\t\telse\n\t\t\top = BUS_DMASYNC_POSTWRITE;\n\t\tbus_dmamap_sync(ahc->sc_dmat, scb->dmamap, op);\n\t\tbus_dmamap_unload(ahc->sc_dmat, scb->dmamap);\n\t}\n\n\t/*\n\t * Unbusy this target/channel/lun.\n\t * XXX if we are holding two commands per lun, \n\t *     send the next command.\n\t */\n\tahc_index_busy_tcl(ahc, scb->hscb->tcl, /*unbusy*/TRUE);\n\n\t/*\n\t * If the recovery SCB completes, we have to be\n\t * out of our timeout.\n\t */\n\tif ((scb->flags & SCB_RECOVERY_SCB) != 0) {\n\n\t\tstruct\tscb *scbp;\n\n\t\t/*\n\t\t * We were able to complete the command successfully,\n\t\t * so reinstate the timeouts for all other pending\n\t\t * commands.\n\t\t */\n\t\tscbp = ahc->pending_scbs.lh_first;\n\t\twhile (scbp != NULL) {\n\t\t\tstruct scsi_xfer *txs = scbp->xs;\n\n\t\t\tif (!(txs->flags & SCSI_POLL)) {\n\t\t\t\ttimeout(ahc_timeout, scbp,\n\t\t\t\t    (scbp->xs->timeout * hz)/1000);\n\t\t\t}\n\t\t\tscbp = LIST_NEXT(scbp, pend_links);\n\t\t}\n\n\t\t/*\n\t\t * Ensure that we didn't put a second instance of this\n\t\t * SCB into the QINFIFO.\n\t\t */\n\t\tahc_search_qinfifo(ahc, SCB_TARGET(scb), SCB_CHANNEL(scb),\n\t\t\t\t   SCB_LUN(scb), scb->hscb->tag,\n\t\t\t\t   ROLE_INITIATOR, /*status*/0,\n\t\t\t\t   SEARCH_REMOVE);\n\t\tif (xs->error != XS_NOERROR)\n\t\t\tahcsetccbstatus(xs, XS_TIMEOUT);\n\t\tsc_print_addr(xs->sc_link);\n\t\tprintf(\"no longer in timeout, status = %x\\n\", xs->status);\n\t}\n\n\tif (xs->error != XS_NOERROR) {\n\t\t/* Don't clobber any existing error state */\n\t} else if ((scb->flags & SCB_SENSE) != 0) {\n\t\t/*\n\t\t * We performed autosense retrieval.\n\t\t *\n\t\t * bzero the sense data before having\n\t\t * the drive fill it.  The SCSI spec mandates\n\t\t * that any untransfered data should be\n\t\t * assumed to be zero.  Complete the 'bounce'\n\t\t * of sense information through buffers accessible\n\t\t * via bus-space by copying it into the clients\n\t\t * csio.\n\t\t */\n\t\tbzero(&xs->sense, sizeof(struct scsi_sense));\n\t\tbcopy(&ahc->scb_data->sense[scb->hscb->tag],\n\t\t      &xs->sense, scb->sg_list->len);\n\t\txs->error = XS_SENSE;\n\t}\n\tif (scb->flags & SCB_FREEZE_QUEUE) {\n\t\tahc->devqueue_blocked[target]--;\n\t\tscb->flags &= ~SCB_FREEZE_QUEUE;\n\t}\n\t\n\trequeue = scb->flags & SCB_REQUEUE;\n\tahcfreescb(ahc, scb);\n\n\tif (requeue) {\n\t\t/*\n\t\t * Re-insert at the front of the private queue to\n\t\t * preserve order.\n\t\t */\n\t\tint s;\n\n\t\ts = splbio();\n\t\t/* TAILQ_INSERT_HEAD(&ahc->sc_q, xs, adapter_q); */\n\t\tahc_list_insert_head(ahc, xs);\n\t\tsplx(s);\n\t} else {\n\t\txs->flags |= ITSDONE;\n\t\tahc_check_tags(ahc, xs);\n\t\tscsi_done(xs);\n\t}\n\n\t/*\n\t * If there are entries in the software queue, try to\n\t * run the first one.  We should be more or less guaranteed\n\t * to succeed, since we just freed an SCB.\n\t *\n\t * NOTE: ahc_scsi_cmd() relies on our calling it with\n\t * the first entry in the queue.\n\t */\n\tif ((xs = ahc->sc_xxxq.lh_first) != NULL)\n\t\t(void) ahc_scsi_cmd(xs);\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define STATIC\tstatic",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
      "STATIC void",
      "ahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));",
      "STATIC void",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_done __P((struct ahc_softc *ahc, struct scb *scbp));",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "ahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));",
      "STATIC int",
      "STATIC void",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
      "STATIC void",
      "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_calc_residual __P((struct scb *scb));",
      "STATIC void",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
      "STATIC void",
      "STATIC void",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "static __inline u_int ahc_index_busy_tcl",
      "static __inline void ahcsetccbstatus",
      "STATIC void",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
      "STATIC void",
      "STATIC void",
      "void   ahc_list_insert_head",
      "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "char channel;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "char channel;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *xs;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ahc_scsi_cmd",
          "args": [
            "xs"
          ],
          "line": 3536
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_scsi_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "4050-4235",
          "snippet": "STATIC int32_t\nahc_scsi_cmd(xs)\n\tstruct scsi_xfer *xs;\n{\n\tstruct scsi_xfer *first_xs, *next_xs = NULL;\n\tstruct ahc_softc *ahc;\n\tstruct scb *scb;\n\tstruct hardware_scb *hscb;\t\n\tstruct ahc_initiator_tinfo *tinfo;\n\tstruct tmode_tstate *tstate;\n\tu_int target_id;\n\tu_int our_id;\n\tint s, tcl;\n\tu_int16_t mask;\n\tint dontqueue = 0, fromqueue = 0;\n\n\tSC_DEBUG(xs->sc_link, SDEV_DB3, (\"ahc_scsi_cmd\\n\"));\n\tahc = (struct ahc_softc *)xs->sc_link->adapter_softc;\n\n\t/* must protect the queue */\n\ts = splbio();\n\n\tif (xs == ahc->sc_xxxq.lh_first) {\n\t\t/*\n\t\t * Called from ahc_done. Calling with the first entry in\n\t\t * the queue is really just a way of seeing where we're\n\t\t * called from. Now, find the first eligible SCB to send,\n\t\t * e.g. one which will be accepted immediately.\n\t\t */\n\n\t\tif (ahc->queue_blocked) {\n\t\t\tsplx(s);\n\t\t\treturn (TRY_AGAIN_LATER);\n\t\t}\n\n\t\txs = ahc_first_xs(ahc);\n\t\tif (xs == NULL) {\n\t\t\tsplx(s);\n\t\t\treturn (TRY_AGAIN_LATER);\n\t\t}\n\n\t\tnext_xs = ahc_list_next(ahc, xs);\n\t\tahc_list_remove(ahc, xs);\n\t\tfromqueue = 1;\n\t\tgoto get_scb;\n\t}\n\n\t/* determine safety of software queueing */\n\tdontqueue = xs->flags & SCSI_POLL;\n\t\n\t/*\n\t * If no new requests are accepted, just insert into the\n\t * private queue to wait for our turn.\n\t */\n\ttcl = XS_TCL(ahc, xs);\n\n\tif (ahc->queue_blocked ||\n\t    ahc->devqueue_blocked[xs->sc_link->target] ||\n\t    (!ahc_istagged_device(ahc, xs) &&\n\t     ahc_index_busy_tcl(ahc, tcl, FALSE) != SCB_LIST_NULL)) {\n\t\tif (dontqueue) {\n\t\t\tsplx(s);\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\treturn TRY_AGAIN_LATER;\n\t\t}\n\t\tahc_list_insert_tail(ahc, xs);\n\t\tsplx(s);\n\t\treturn SUCCESSFULLY_QUEUED;\n\t}\n\n\tfirst_xs = ahc_first_xs(ahc);\n\n\t/* determine safety of software queueing */\n\tdontqueue = xs->flags & SCSI_POLL;\n\n\t/*\n\t * Handle situations where there's already entries in the\n\t * queue.\n\t */\n\tif (first_xs != NULL) {\n\t\t/*\n\t\t * If we can't queue, we have to abort, since\n\t\t * we have to preserve order.\n\t\t */\n\t\tif (dontqueue) {\n\t\t\tsplx(s);\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\treturn (TRY_AGAIN_LATER);\n\t\t}\n\n\t\t/*\n\t\t * Swap with the first queue entry.\n\t\t */\n\t\tahc_list_insert_tail(ahc, xs);\n\t\txs = first_xs;\n\t\tnext_xs = ahc_list_next(ahc, xs);\n\t\tahc_list_remove(ahc, xs);\n\t\tfromqueue = 1;\n\n\t}\n\nget_scb:\n\n\ttarget_id = xs->sc_link->target;\n\tour_id = SIM_SCSI_ID(ahc, xs->sc_link);\n\n\t/*\n\t * get an scb to use.\n\t */\n\tif ((scb = ahcgetscb(ahc)) == NULL) {\n\n\t\tif (dontqueue) {\n\t\t\tsplx(s);\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\treturn (TRY_AGAIN_LATER);\n\t\t}\n\n\t\t/*\n\t\t * If we were pulled off the queue, put ourselves\n\t\t * back to where we came from, otherwise tack ourselves\n\t\t * onto the end.\n\t\t */\n\t\tif (fromqueue && next_xs != NULL)\n\t\t\tahc_list_insert_before(ahc, xs, next_xs);\n\t\telse\n\t\t\tahc_list_insert_tail(ahc, xs);\n\n\t\tsplx(s);\n\t\treturn (SUCCESSFULLY_QUEUED);\n\t}\n\n\ttcl = XS_TCL(ahc, xs);\n\n#ifdef DIAGNOSTIC\n\tif (ahc_index_busy_tcl(ahc, tcl, FALSE) != SCB_LIST_NULL)\n\t\tpanic(\"ahc: queuing for busy target\");\n#endif\n\t\n\tscb->xs = xs;\n\thscb = scb->hscb;\n\thscb->tcl = tcl;\n\n\tif (ahc_istagged_device(ahc, xs))\n\t\tscb->hscb->control |= MSG_SIMPLE_Q_TAG;\n\telse\n\t\tahc_busy_tcl(ahc, scb);\n\n\tsplx(s);\n \n\t/*\n\t * Put all the arguments for the xfer in the scb\n\t */\n\n\tmask = SCB_TARGET_MASK(scb);\n\ttinfo = ahc_fetch_transinfo(ahc, SIM_CHANNEL(ahc, xs->sc_link), our_id,\n\t\t\t\t    target_id, &tstate);\n\tif (ahc->inited_targets[target_id] == 0) {\n\t\tstruct ahc_devinfo devinfo;\n\n\t\ts = splbio();\n\t\tahc_compile_devinfo(&devinfo, our_id, target_id,\n\t\t    xs->sc_link->lun, SIM_CHANNEL(ahc, xs->sc_link),\n\t\t    ROLE_INITIATOR);\n\t\tahc_update_target_msg_request(ahc, &devinfo, tinfo, TRUE,\n\t\t    FALSE);\n\t\tahc->inited_targets[target_id] = 1;\n\t\tsplx(s);\n\t}\n\n\thscb->scsirate = tinfo->scsirate;\n\thscb->scsioffset = tinfo->current.offset;\n\tif ((tstate->ultraenb & mask) != 0)\n\t\thscb->control |= ULTRAENB;\n\t\t\n\tif ((tstate->discenable & mask) != 0)\n\t\thscb->control |= DISCENB;\n\n\tif (xs->flags & SCSI_RESET) {\n\t\thscb->cmdpointer = NULL;\n\t\tscb->flags |= SCB_DEVICE_RESET;\n\t\thscb->control |= MK_MESSAGE;\n\t\treturn ahc_execute_scb(scb, NULL, 0);\n\t}\n\n\treturn ahc_setup_data(ahc, xs, scb);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "ahc_poll __P((struct ahc_softc *ahc, int wait));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
            "STATIC void",
            "ahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
            "STATIC void",
            "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC int",
            "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));",
            "STATIC int",
            "STATIC int",
            "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
            "STATIC void",
            "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
            "STATIC void",
            "ahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));",
            "STATIC void",
            "STATIC void",
            "ahc_calc_residual __P((struct scb *scb));",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "static __inline u_int ahc_index_busy_tcl",
            "static __inline void\tahc_busy_tcl",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "static __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo",
            "STATIC void",
            "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
            "static __inline struct scb *ahcgetscb",
            "STATIC void",
            "STATIC void",
            "struct scsi_xfer *ahc_first_xs",
            "void   ahc_list_insert_before",
            "void   ahc_list_insert_tail",
            "void   ahc_list_remove",
            "struct scsi_xfer *ahc_list_next",
            "STATIC int32_t",
            "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "u_int our_id;",
            "struct tmode_tstate **tstate;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *xs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nahc_poll __P((struct ahc_softc *ahc, int wait));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nSTATIC void;\nahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));\nSTATIC int;\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nSTATIC void;\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nSTATIC void;\nahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));\nSTATIC void;\nSTATIC void;\nahc_calc_residual __P((struct scb *scb));\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nstatic __inline u_int ahc_index_busy_tcl;\nstatic __inline void\tahc_busy_tcl;\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo;\nSTATIC void;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nstatic __inline struct scb *ahcgetscb;\nSTATIC void;\nSTATIC void;\nstruct scsi_xfer *ahc_first_xs;\nvoid   ahc_list_insert_before;\nvoid   ahc_list_insert_tail;\nvoid   ahc_list_remove;\nstruct scsi_xfer *ahc_list_next;\nSTATIC int32_t;\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nu_int our_id;\nstruct tmode_tstate **tstate;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n\nSTATIC int32_t\nahc_scsi_cmd(xs)\n\tstruct scsi_xfer *xs;\n{\n\tstruct scsi_xfer *first_xs, *next_xs = NULL;\n\tstruct ahc_softc *ahc;\n\tstruct scb *scb;\n\tstruct hardware_scb *hscb;\t\n\tstruct ahc_initiator_tinfo *tinfo;\n\tstruct tmode_tstate *tstate;\n\tu_int target_id;\n\tu_int our_id;\n\tint s, tcl;\n\tu_int16_t mask;\n\tint dontqueue = 0, fromqueue = 0;\n\n\tSC_DEBUG(xs->sc_link, SDEV_DB3, (\"ahc_scsi_cmd\\n\"));\n\tahc = (struct ahc_softc *)xs->sc_link->adapter_softc;\n\n\t/* must protect the queue */\n\ts = splbio();\n\n\tif (xs == ahc->sc_xxxq.lh_first) {\n\t\t/*\n\t\t * Called from ahc_done. Calling with the first entry in\n\t\t * the queue is really just a way of seeing where we're\n\t\t * called from. Now, find the first eligible SCB to send,\n\t\t * e.g. one which will be accepted immediately.\n\t\t */\n\n\t\tif (ahc->queue_blocked) {\n\t\t\tsplx(s);\n\t\t\treturn (TRY_AGAIN_LATER);\n\t\t}\n\n\t\txs = ahc_first_xs(ahc);\n\t\tif (xs == NULL) {\n\t\t\tsplx(s);\n\t\t\treturn (TRY_AGAIN_LATER);\n\t\t}\n\n\t\tnext_xs = ahc_list_next(ahc, xs);\n\t\tahc_list_remove(ahc, xs);\n\t\tfromqueue = 1;\n\t\tgoto get_scb;\n\t}\n\n\t/* determine safety of software queueing */\n\tdontqueue = xs->flags & SCSI_POLL;\n\t\n\t/*\n\t * If no new requests are accepted, just insert into the\n\t * private queue to wait for our turn.\n\t */\n\ttcl = XS_TCL(ahc, xs);\n\n\tif (ahc->queue_blocked ||\n\t    ahc->devqueue_blocked[xs->sc_link->target] ||\n\t    (!ahc_istagged_device(ahc, xs) &&\n\t     ahc_index_busy_tcl(ahc, tcl, FALSE) != SCB_LIST_NULL)) {\n\t\tif (dontqueue) {\n\t\t\tsplx(s);\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\treturn TRY_AGAIN_LATER;\n\t\t}\n\t\tahc_list_insert_tail(ahc, xs);\n\t\tsplx(s);\n\t\treturn SUCCESSFULLY_QUEUED;\n\t}\n\n\tfirst_xs = ahc_first_xs(ahc);\n\n\t/* determine safety of software queueing */\n\tdontqueue = xs->flags & SCSI_POLL;\n\n\t/*\n\t * Handle situations where there's already entries in the\n\t * queue.\n\t */\n\tif (first_xs != NULL) {\n\t\t/*\n\t\t * If we can't queue, we have to abort, since\n\t\t * we have to preserve order.\n\t\t */\n\t\tif (dontqueue) {\n\t\t\tsplx(s);\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\treturn (TRY_AGAIN_LATER);\n\t\t}\n\n\t\t/*\n\t\t * Swap with the first queue entry.\n\t\t */\n\t\tahc_list_insert_tail(ahc, xs);\n\t\txs = first_xs;\n\t\tnext_xs = ahc_list_next(ahc, xs);\n\t\tahc_list_remove(ahc, xs);\n\t\tfromqueue = 1;\n\n\t}\n\nget_scb:\n\n\ttarget_id = xs->sc_link->target;\n\tour_id = SIM_SCSI_ID(ahc, xs->sc_link);\n\n\t/*\n\t * get an scb to use.\n\t */\n\tif ((scb = ahcgetscb(ahc)) == NULL) {\n\n\t\tif (dontqueue) {\n\t\t\tsplx(s);\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\treturn (TRY_AGAIN_LATER);\n\t\t}\n\n\t\t/*\n\t\t * If we were pulled off the queue, put ourselves\n\t\t * back to where we came from, otherwise tack ourselves\n\t\t * onto the end.\n\t\t */\n\t\tif (fromqueue && next_xs != NULL)\n\t\t\tahc_list_insert_before(ahc, xs, next_xs);\n\t\telse\n\t\t\tahc_list_insert_tail(ahc, xs);\n\n\t\tsplx(s);\n\t\treturn (SUCCESSFULLY_QUEUED);\n\t}\n\n\ttcl = XS_TCL(ahc, xs);\n\n#ifdef DIAGNOSTIC\n\tif (ahc_index_busy_tcl(ahc, tcl, FALSE) != SCB_LIST_NULL)\n\t\tpanic(\"ahc: queuing for busy target\");\n#endif\n\t\n\tscb->xs = xs;\n\thscb = scb->hscb;\n\thscb->tcl = tcl;\n\n\tif (ahc_istagged_device(ahc, xs))\n\t\tscb->hscb->control |= MSG_SIMPLE_Q_TAG;\n\telse\n\t\tahc_busy_tcl(ahc, scb);\n\n\tsplx(s);\n \n\t/*\n\t * Put all the arguments for the xfer in the scb\n\t */\n\n\tmask = SCB_TARGET_MASK(scb);\n\ttinfo = ahc_fetch_transinfo(ahc, SIM_CHANNEL(ahc, xs->sc_link), our_id,\n\t\t\t\t    target_id, &tstate);\n\tif (ahc->inited_targets[target_id] == 0) {\n\t\tstruct ahc_devinfo devinfo;\n\n\t\ts = splbio();\n\t\tahc_compile_devinfo(&devinfo, our_id, target_id,\n\t\t    xs->sc_link->lun, SIM_CHANNEL(ahc, xs->sc_link),\n\t\t    ROLE_INITIATOR);\n\t\tahc_update_target_msg_request(ahc, &devinfo, tinfo, TRUE,\n\t\t    FALSE);\n\t\tahc->inited_targets[target_id] = 1;\n\t\tsplx(s);\n\t}\n\n\thscb->scsirate = tinfo->scsirate;\n\thscb->scsioffset = tinfo->current.offset;\n\tif ((tstate->ultraenb & mask) != 0)\n\t\thscb->control |= ULTRAENB;\n\t\t\n\tif ((tstate->discenable & mask) != 0)\n\t\thscb->control |= DISCENB;\n\n\tif (xs->flags & SCSI_RESET) {\n\t\thscb->cmdpointer = NULL;\n\t\tscb->flags |= SCB_DEVICE_RESET;\n\t\thscb->control |= MK_MESSAGE;\n\t\treturn ahc_execute_scb(scb, NULL, 0);\n\t}\n\n\treturn ahc_setup_data(ahc, xs, scb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "scsi_done",
          "args": [
            "xs"
          ],
          "line": 3524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_check_tags",
          "args": [
            "ahc",
            "xs"
          ],
          "line": 3523
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_check_tags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "5774-5821",
          "snippet": "STATIC void\nahc_check_tags(ahc, xs)\nstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n{\n\tstruct scsi_inquiry_data *inq;\n\tstruct ahc_devinfo devinfo;\n\tint target_id, our_id;\n\n\tif (xs->cmd->opcode != INQUIRY || xs->error != XS_NOERROR)\n\t\treturn;\n\n\ttarget_id = xs->sc_link->target;\n\tour_id = SIM_SCSI_ID(ahc, xs->sc_link);\n\n\t/*\n\t * Sneak a look at the results of the SCSI Inquiry\n\t * command and see if we can do Tagged queing.  This\n\t * should really be done by the higher level drivers.\n\t */\n\tinq = (struct scsi_inquiry_data *)xs->data;\n\tif ((inq->flags & SID_CmdQue) && !(ahc_istagged_device(ahc, xs))) {\n#ifdef AHC_DEBUG \n\t\tprintf(\"%s: target %d using tagged queuing\\n\",\n\t\t\tahc_name(ahc), xs->sc_link->target);\n#endif \n\t\tahc_compile_devinfo(&devinfo,\n\t\t    our_id, target_id, xs->sc_link->lun,\t\n\t\t    SIM_CHANNEL(ahc, xs->sc_link), ROLE_INITIATOR);\n\t\tahc_set_tags(ahc, &devinfo, TRUE);\n\n\t\tif (ahc->scb_data->maxhscbs >= 16 ||\n\t\t    (ahc->flags & AHC_PAGESCBS)) {\n\t\t\t/* Default to 16 tags */\n\t\t\txs->sc_link->openings += 14;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Default to 4 tags on whimpy\n\t\t\t * cards that don't have much SCB\n\t\t\t * space and can't page.  This prevents\n\t\t\t * a single device from hogging all\n\t\t\t * slots.  We should really have a better\n\t\t\t * way of providing fairness.\n\t\t\t */\n\t\t\txs->sc_link->openings += 2;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "ahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC int",
            "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));",
            "STATIC int",
            "STATIC int",
            "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));",
            "STATIC void",
            "ahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));",
            "STATIC void",
            "STATIC int",
            "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
            "STATIC void",
            "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "u_int our_id;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *xs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));\nSTATIC int;\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));\nSTATIC void;\nahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));\nSTATIC void;\nSTATIC int;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nSTATIC void;\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nu_int our_id;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n\nSTATIC void\nahc_check_tags(ahc, xs)\nstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n{\n\tstruct scsi_inquiry_data *inq;\n\tstruct ahc_devinfo devinfo;\n\tint target_id, our_id;\n\n\tif (xs->cmd->opcode != INQUIRY || xs->error != XS_NOERROR)\n\t\treturn;\n\n\ttarget_id = xs->sc_link->target;\n\tour_id = SIM_SCSI_ID(ahc, xs->sc_link);\n\n\t/*\n\t * Sneak a look at the results of the SCSI Inquiry\n\t * command and see if we can do Tagged queing.  This\n\t * should really be done by the higher level drivers.\n\t */\n\tinq = (struct scsi_inquiry_data *)xs->data;\n\tif ((inq->flags & SID_CmdQue) && !(ahc_istagged_device(ahc, xs))) {\n#ifdef AHC_DEBUG \n\t\tprintf(\"%s: target %d using tagged queuing\\n\",\n\t\t\tahc_name(ahc), xs->sc_link->target);\n#endif \n\t\tahc_compile_devinfo(&devinfo,\n\t\t    our_id, target_id, xs->sc_link->lun,\t\n\t\t    SIM_CHANNEL(ahc, xs->sc_link), ROLE_INITIATOR);\n\t\tahc_set_tags(ahc, &devinfo, TRUE);\n\n\t\tif (ahc->scb_data->maxhscbs >= 16 ||\n\t\t    (ahc->flags & AHC_PAGESCBS)) {\n\t\t\t/* Default to 16 tags */\n\t\t\txs->sc_link->openings += 14;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Default to 4 tags on whimpy\n\t\t\t * cards that don't have much SCB\n\t\t\t * space and can't page.  This prevents\n\t\t\t * a single device from hogging all\n\t\t\t * slots.  We should really have a better\n\t\t\t * way of providing fairness.\n\t\t\t */\n\t\t\txs->sc_link->openings += 2;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 3520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_list_insert_head",
          "args": [
            "ahc",
            "xs"
          ],
          "line": 3519
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_list_insert_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "3971-3980",
          "snippet": "void\nahc_list_insert_head(ahc, xs)\n\tstruct ahc_softc *ahc;\n\tstruct scsi_xfer *xs;\n{\n\tif (ahc->sc_xxxq.lh_first == NULL)\n\t\tahc->sc_xxxqlast = xs;\n\tLIST_INSERT_HEAD(&ahc->sc_xxxq, xs, free_list);\n\treturn;\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
            "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "void   ahc_list_insert_head",
            "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *xs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC struct;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nahc_loadseq __P((struct ahc_softc *ahc));\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nahc_clear_intstat __P((struct ahc_softc *ahc));\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nrestart_sequencer __P((struct ahc_softc *ahc));\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nvoid   ahc_list_insert_head;\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n\nvoid\nahc_list_insert_head(ahc, xs)\n\tstruct ahc_softc *ahc;\n\tstruct scsi_xfer *xs;\n{\n\tif (ahc->sc_xxxq.lh_first == NULL)\n\t\tahc->sc_xxxqlast = xs;\n\tLIST_INSERT_HEAD(&ahc->sc_xxxq, xs, free_list);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 3517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahcfreescb",
          "args": [
            "ahc",
            "scb"
          ],
          "line": 3508
        },
        "resolved": true,
        "details": {
          "function_name": "ahcfreescb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "617-648",
          "snippet": "STATIC void\nahcfreescb(ahc, scb)\n\tstruct ahc_softc *ahc;\n\tstruct scb *scb;\n{       \n\tstruct hardware_scb *hscb;\n\tint opri;\n\n\thscb = scb->hscb;\n\n#ifdef AHC_DEBUG\n\tif (ahc_debug & AHC_SHOWSCBALLOC)\n\t\tprintf(\"%s: free SCB tag %x\\n\", ahc_name(ahc), hscb->tag);\n#endif\n\n\topri = splbio();\n\n\tif ((ahc->flags & AHC_RESOURCE_SHORTAGE) != 0 ||\n\t    (scb->flags & SCB_RECOVERY_SCB) != 0) {\n\t\tahc->flags &= ~AHC_RESOURCE_SHORTAGE;\n\t\tahc->queue_blocked = 0;\n\t}\n\n\t/* Clean up for the next user */\n\tscb->flags = SCB_FREE;\n\thscb->control = 0;\n\thscb->status = 0;\n\n\tSLIST_INSERT_HEAD(&ahc->scb_data->free_scbs, scb, links);\n\n\tsplx(opri);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "ahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));",
            "STATIC int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_calc_residual __P((struct scb *scb));",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));\nSTATIC int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_calc_residual __P((struct scb *scb));\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahcfreescb(ahc, scb)\n\tstruct ahc_softc *ahc;\n\tstruct scb *scb;\n{       \n\tstruct hardware_scb *hscb;\n\tint opri;\n\n\thscb = scb->hscb;\n\n#ifdef AHC_DEBUG\n\tif (ahc_debug & AHC_SHOWSCBALLOC)\n\t\tprintf(\"%s: free SCB tag %x\\n\", ahc_name(ahc), hscb->tag);\n#endif\n\n\topri = splbio();\n\n\tif ((ahc->flags & AHC_RESOURCE_SHORTAGE) != 0 ||\n\t    (scb->flags & SCB_RECOVERY_SCB) != 0) {\n\t\tahc->flags &= ~AHC_RESOURCE_SHORTAGE;\n\t\tahc->queue_blocked = 0;\n\t}\n\n\t/* Clean up for the next user */\n\tscb->flags = SCB_FREE;\n\thscb->control = 0;\n\thscb->status = 0;\n\n\tSLIST_INSERT_HEAD(&ahc->scb_data->free_scbs, scb, links);\n\n\tsplx(opri);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "&ahc->scb_data->sense[scb->hscb->tag]",
            "&xs->sense",
            "scb->sg_list->len"
          ],
          "line": 3498
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "&xs->sense",
            "sizeof(struct scsi_sense)"
          ],
          "line": 3497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"no longer in timeout, status = %x\\n\"",
            "xs->status"
          ],
          "line": 3480
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sc_print_addr",
          "args": [
            "xs->sc_link"
          ],
          "line": 3479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahcsetccbstatus",
          "args": [
            "xs",
            "XS_TIMEOUT"
          ],
          "line": 3478
        },
        "resolved": true,
        "details": {
          "function_name": "ahcsetccbstatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "548-554",
          "snippet": "static __inline void\nahcsetccbstatus(xs, status)\n\tstruct scsi_xfer *xs;\n\tint status;\n{\n\txs->error = status;\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "ahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));",
            "STATIC struct",
            "STATIC struct",
            "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
            "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
            "static __inline void ahcsetccbstatus",
            "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
            "STATIC struct",
            "STATIC struct",
            "STATIC struct",
            "struct scsi_xfer *xs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nSTATIC struct;\nahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));\nSTATIC struct;\nSTATIC struct;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nstatic __inline void ahcsetccbstatus;\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nSTATIC struct;\nSTATIC struct;\nSTATIC struct;\nstruct scsi_xfer *xs;\n\nstatic __inline void\nahcsetccbstatus(xs, status)\n\tstruct scsi_xfer *xs;\n\tint status;\n{\n\txs->error = status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_search_qinfifo",
          "args": [
            "ahc",
            "SCB_TARGET(scb)",
            "SCB_CHANNEL(scb)",
            "SCB_LUN(scb)",
            "scb->hscb->tag",
            "ROLE_INITIATOR",
            "/*status*/0",
            "SEARCH_REMOVE"
          ],
          "line": 3473
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_search_qinfifo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "5055-5121",
          "snippet": "STATIC int\nahc_search_qinfifo(ahc, target, channel, lun, tag, role, status, action)\n\tstruct ahc_softc *ahc;\n\tint target;\n\tchar channel;\n\tint lun;\n\tu_int tag;\n\trole_t role;\n\tu_int32_t status;\n\tahc_search_action action;\n{\n\tstruct\t scb *scbp;\n\tu_int8_t qinpos;\n\tu_int8_t qintail;\n\tint\t found;\n\n\tqinpos = ahc_inb(ahc, QINPOS);\n\tqintail = ahc->qinfifonext;\n\tfound = 0;\n\n\t/*\n\t * Start with an empty queue.  Entries that are not chosen\n\t * for removal will be re-added to the queue as we go.\n\t */\n\tahc->qinfifonext = qinpos;\n\tbus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, \n\t\t\tBUS_DMASYNC_POSTREAD);\n\n\twhile (qinpos != qintail) {\n\t\tscbp = &ahc->scb_data->scbarray[ahc->qinfifo[qinpos]];\n\t\tif (ahc_match_scb(scbp, target, channel, lun, tag, role)) {\n\t\t\t/*\n\t\t\t * We found an scb that needs to be removed.\n\t\t\t */\n\t\t\tswitch (action) {\n\t\t\tcase SEARCH_COMPLETE:\n\t\t\t\tif (!(scbp->xs->flags & ITSDONE)) {\n\t\t\t\t\tscbp->flags |= status;\n\t\t\t\t\tscbp->xs->error = XS_NOERROR;\n\t\t\t\t}\n\t\t\t\tahc_freeze_ccb(scbp);\n\t\t\t\tahc_done(ahc, scbp);\n\t\t\t\tbreak;\n\t\t\tcase SEARCH_COUNT:\n\t\t\t\tahc->qinfifo[ahc->qinfifonext++] =\n\t\t\t\t    scbp->hscb->tag;\n\t\t\t\tbreak;\n\t\t\tcase SEARCH_REMOVE:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfound++;\n\t\t} else {\n\t\t\tahc->qinfifo[ahc->qinfifonext++] = scbp->hscb->tag;\n\t\t}\n\t\tqinpos++;\n\t}\n\tbus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, \n\t\t\tBUS_DMASYNC_PREWRITE);\n\t\n\tif ((ahc->features & AHC_QUEUE_REGS) != 0) {\n\t\tahc_outb(ahc, HNSCB_QOFF, ahc->qinfifonext);\n\t} else {\n\t\tahc_outb(ahc, KERNEL_QINPOS, ahc->qinfifonext);\n\t}\n\n\treturn (found);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "ahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));",
            "STATIC u_int",
            "STATIC void",
            "ahc_done __P((struct ahc_softc *ahc, struct scb *scbp));",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "ahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));",
            "STATIC int",
            "ahc_search_qinfifo __P((struct ahc_softc *ahc, int target,\n\t\t\t\t\tchar channel, int lun, u_int tag,\n\t\t\t\t\trole_t role, u_int32_t status,\n\t\t\t\t\tahc_search_action action));",
            "STATIC int",
            "STATIC int",
            "ahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
            "STATIC void",
            "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_calc_residual __P((struct scb *scb));",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "static __inline void ahc_freeze_ccb",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *xs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));\nSTATIC u_int;\nSTATIC void;\nahc_done __P((struct ahc_softc *ahc, struct scb *scbp));\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));\nSTATIC int;\nahc_search_qinfifo __P((struct ahc_softc *ahc, int target,\n\t\t\t\t\tchar channel, int lun, u_int tag,\n\t\t\t\t\trole_t role, u_int32_t status,\n\t\t\t\t\tahc_search_action action));\nSTATIC int;\nSTATIC int;\nahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nSTATIC void;\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_calc_residual __P((struct scb *scb));\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nstatic __inline void ahc_freeze_ccb;\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n\nSTATIC int\nahc_search_qinfifo(ahc, target, channel, lun, tag, role, status, action)\n\tstruct ahc_softc *ahc;\n\tint target;\n\tchar channel;\n\tint lun;\n\tu_int tag;\n\trole_t role;\n\tu_int32_t status;\n\tahc_search_action action;\n{\n\tstruct\t scb *scbp;\n\tu_int8_t qinpos;\n\tu_int8_t qintail;\n\tint\t found;\n\n\tqinpos = ahc_inb(ahc, QINPOS);\n\tqintail = ahc->qinfifonext;\n\tfound = 0;\n\n\t/*\n\t * Start with an empty queue.  Entries that are not chosen\n\t * for removal will be re-added to the queue as we go.\n\t */\n\tahc->qinfifonext = qinpos;\n\tbus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, \n\t\t\tBUS_DMASYNC_POSTREAD);\n\n\twhile (qinpos != qintail) {\n\t\tscbp = &ahc->scb_data->scbarray[ahc->qinfifo[qinpos]];\n\t\tif (ahc_match_scb(scbp, target, channel, lun, tag, role)) {\n\t\t\t/*\n\t\t\t * We found an scb that needs to be removed.\n\t\t\t */\n\t\t\tswitch (action) {\n\t\t\tcase SEARCH_COMPLETE:\n\t\t\t\tif (!(scbp->xs->flags & ITSDONE)) {\n\t\t\t\t\tscbp->flags |= status;\n\t\t\t\t\tscbp->xs->error = XS_NOERROR;\n\t\t\t\t}\n\t\t\t\tahc_freeze_ccb(scbp);\n\t\t\t\tahc_done(ahc, scbp);\n\t\t\t\tbreak;\n\t\t\tcase SEARCH_COUNT:\n\t\t\t\tahc->qinfifo[ahc->qinfifonext++] =\n\t\t\t\t    scbp->hscb->tag;\n\t\t\t\tbreak;\n\t\t\tcase SEARCH_REMOVE:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfound++;\n\t\t} else {\n\t\t\tahc->qinfifo[ahc->qinfifonext++] = scbp->hscb->tag;\n\t\t}\n\t\tqinpos++;\n\t}\n\tbus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, \n\t\t\tBUS_DMASYNC_PREWRITE);\n\t\n\tif ((ahc->features & AHC_QUEUE_REGS) != 0) {\n\t\tahc_outb(ahc, HNSCB_QOFF, ahc->qinfifonext);\n\t} else {\n\t\tahc_outb(ahc, KERNEL_QINPOS, ahc->qinfifonext);\n\t}\n\n\treturn (found);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SCB_LUN",
          "args": [
            "scb"
          ],
          "line": 3474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCB_CHANNEL",
          "args": [
            "scb"
          ],
          "line": 3473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCB_TARGET",
          "args": [
            "scb"
          ],
          "line": 3473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_NEXT",
          "args": [
            "scbp",
            "pend_links"
          ],
          "line": 3466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "ahc_timeout",
            "scbp",
            "(scbp->xs->timeout * hz)/1000"
          ],
          "line": 3463
        },
        "resolved": true,
        "details": {
          "function_name": "wdctimeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "952-980",
          "snippet": "void\nwdctimeout(arg)\n\tvoid *arg;\n{\n\tstruct channel_softc *chp = (struct channel_softc *)arg;\n\tstruct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;\n\tint s;\n\n\tWDCDEBUG_PRINT((\"wdctimeout\\n\"), DEBUG_FUNCS);\n\n\ts = splbio();\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) != 0) {\n\t\t__wdcerror(chp, \"timeout\");\n\t\tprintf(\"\\ttype: %s\\n\", (xfer->c_flags & C_ATAPI) ?\n\t\t    \"atapi\":\"ata\");\n\t\tprintf(\"\\tc_bcount: %d\\n\", xfer->c_bcount);\n\t\tprintf(\"\\tc_skip: %d\\n\", xfer->c_skip);\n\t\t/*\n\t\t * Call the interrupt routine. If we just missed and interrupt,\n\t\t * it will do what's needed. Else, it will take the needed\n\t\t * action (reset the device).\n\t\t */\n\t\txfer->c_flags |= C_TIMEOU;\n\t\tchp->ch_flags &= ~WDCF_IRQ_WAIT;\n\t\txfer->c_intr(chp, xfer, 1);\n\t} else\n\t\t__wdcerror(chp, \"missing untimeout\");\n\tsplx(s);\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_FUNCS  0x08"
          ],
          "globals_used": [
            "static void  __wdcerror"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_FUNCS  0x08\n\nstatic void  __wdcerror;\n\nvoid\nwdctimeout(arg)\n\tvoid *arg;\n{\n\tstruct channel_softc *chp = (struct channel_softc *)arg;\n\tstruct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;\n\tint s;\n\n\tWDCDEBUG_PRINT((\"wdctimeout\\n\"), DEBUG_FUNCS);\n\n\ts = splbio();\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) != 0) {\n\t\t__wdcerror(chp, \"timeout\");\n\t\tprintf(\"\\ttype: %s\\n\", (xfer->c_flags & C_ATAPI) ?\n\t\t    \"atapi\":\"ata\");\n\t\tprintf(\"\\tc_bcount: %d\\n\", xfer->c_bcount);\n\t\tprintf(\"\\tc_skip: %d\\n\", xfer->c_skip);\n\t\t/*\n\t\t * Call the interrupt routine. If we just missed and interrupt,\n\t\t * it will do what's needed. Else, it will take the needed\n\t\t * action (reset the device).\n\t\t */\n\t\txfer->c_flags |= C_TIMEOU;\n\t\tchp->ch_flags &= ~WDCF_IRQ_WAIT;\n\t\txfer->c_intr(chp, xfer, 1);\n\t} else\n\t\t__wdcerror(chp, \"missing untimeout\");\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_index_busy_tcl",
          "args": [
            "ahc",
            "scb->hscb->tcl",
            "/*unbusy*/TRUE"
          ],
          "line": 3443
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_index_busy_tcl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "497-513",
          "snippet": "static __inline u_int\nahc_index_busy_tcl(ahc, tcl, unbusy)\n\tstruct ahc_softc *ahc;\n\tu_int tcl;\n\tint unbusy;\n{\n\tu_int scbid;\n\n\tscbid = ahc->untagged_scbs[tcl];\n\tif (unbusy) {\n\t\tahc->untagged_scbs[tcl] = SCB_LIST_NULL;\n\t\tbus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, \n\t\t\t\tBUS_DMASYNC_PREWRITE);\n\t}\n\n\treturn (scbid);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC u_int",
            "STATIC struct",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC u_int",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "static __inline u_int ahc_index_busy_tcl",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC u_int;\nSTATIC struct;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC u_int;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nahc_clear_intstat __P((struct ahc_softc *ahc));\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nrestart_sequencer __P((struct ahc_softc *ahc));\nstatic __inline u_int ahc_index_busy_tcl;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nstatic __inline u_int\nahc_index_busy_tcl(ahc, tcl, unbusy)\n\tstruct ahc_softc *ahc;\n\tu_int tcl;\n\tint unbusy;\n{\n\tu_int scbid;\n\n\tscbid = ahc->untagged_scbs[tcl];\n\tif (unbusy) {\n\t\tahc->untagged_scbs[tcl] = SCB_LIST_NULL;\n\t\tbus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, \n\t\t\t\tBUS_DMASYNC_PREWRITE);\n\t}\n\n\treturn (scbid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_dmamap_unload",
          "args": [
            "ahc->sc_dmat",
            "scb->dmamap"
          ],
          "line": 3435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_sync",
          "args": [
            "ahc->sc_dmat",
            "scb->dmamap",
            "op"
          ],
          "line": 3434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc_print_addr",
          "args": [
            "sc_link"
          ],
          "line": 3419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "untimeout",
          "args": [
            "ahc_timeout",
            "(caddr_t)scb"
          ],
          "line": 3415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_REMOVE",
          "args": [
            "scb",
            "pend_links"
          ],
          "line": 3413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SC_DEBUG",
          "args": [
            "xs->sc_link",
            "SDEV_DB2",
            "(\"ahc_done\\n\")"
          ],
          "line": 3411
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nSTATIC void;\nahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_done __P((struct ahc_softc *ahc, struct scb *scbp));\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));\nSTATIC int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nSTATIC void;\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_calc_residual __P((struct scb *scb));\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nstatic __inline u_int ahc_index_busy_tcl;\nstatic __inline void ahcsetccbstatus;\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nSTATIC void;\nSTATIC void;\nvoid   ahc_list_insert_head;\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n\nSTATIC void\nahc_done(ahc, scb)\n\tstruct ahc_softc *ahc;\n\tstruct scb *scb;\n{\n\tstruct scsi_xfer *xs = scb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tint requeue = 0;\n\tint target;\n\n\tSC_DEBUG(xs->sc_link, SDEV_DB2, (\"ahc_done\\n\"));\n\t\n\tLIST_REMOVE(scb, pend_links);\n\n\tuntimeout(ahc_timeout, (caddr_t)scb);\n\n#ifdef AHC_DEBUG\n\tif (ahc_debug & AHC_SHOWCMDS) {\n\t\tsc_print_addr(sc_link);\n\t\tprintf(\"ahc_done opcode %d tag %x\\n\", xs->cmdstore.opcode,\n\t\t    scb->hscb->tag);\n\t}\n#endif\n\t\n\ttarget = sc_link->target;\n\t\n\tif (xs->datalen) {\n\t\tbus_dmasync_op_t op;\n\t\n\t\tif ((xs->flags & SCSI_DATA_IN) != 0)\n\t\t\top = BUS_DMASYNC_POSTREAD;\n\t\telse\n\t\t\top = BUS_DMASYNC_POSTWRITE;\n\t\tbus_dmamap_sync(ahc->sc_dmat, scb->dmamap, op);\n\t\tbus_dmamap_unload(ahc->sc_dmat, scb->dmamap);\n\t}\n\n\t/*\n\t * Unbusy this target/channel/lun.\n\t * XXX if we are holding two commands per lun, \n\t *     send the next command.\n\t */\n\tahc_index_busy_tcl(ahc, scb->hscb->tcl, /*unbusy*/TRUE);\n\n\t/*\n\t * If the recovery SCB completes, we have to be\n\t * out of our timeout.\n\t */\n\tif ((scb->flags & SCB_RECOVERY_SCB) != 0) {\n\n\t\tstruct\tscb *scbp;\n\n\t\t/*\n\t\t * We were able to complete the command successfully,\n\t\t * so reinstate the timeouts for all other pending\n\t\t * commands.\n\t\t */\n\t\tscbp = ahc->pending_scbs.lh_first;\n\t\twhile (scbp != NULL) {\n\t\t\tstruct scsi_xfer *txs = scbp->xs;\n\n\t\t\tif (!(txs->flags & SCSI_POLL)) {\n\t\t\t\ttimeout(ahc_timeout, scbp,\n\t\t\t\t    (scbp->xs->timeout * hz)/1000);\n\t\t\t}\n\t\t\tscbp = LIST_NEXT(scbp, pend_links);\n\t\t}\n\n\t\t/*\n\t\t * Ensure that we didn't put a second instance of this\n\t\t * SCB into the QINFIFO.\n\t\t */\n\t\tahc_search_qinfifo(ahc, SCB_TARGET(scb), SCB_CHANNEL(scb),\n\t\t\t\t   SCB_LUN(scb), scb->hscb->tag,\n\t\t\t\t   ROLE_INITIATOR, /*status*/0,\n\t\t\t\t   SEARCH_REMOVE);\n\t\tif (xs->error != XS_NOERROR)\n\t\t\tahcsetccbstatus(xs, XS_TIMEOUT);\n\t\tsc_print_addr(xs->sc_link);\n\t\tprintf(\"no longer in timeout, status = %x\\n\", xs->status);\n\t}\n\n\tif (xs->error != XS_NOERROR) {\n\t\t/* Don't clobber any existing error state */\n\t} else if ((scb->flags & SCB_SENSE) != 0) {\n\t\t/*\n\t\t * We performed autosense retrieval.\n\t\t *\n\t\t * bzero the sense data before having\n\t\t * the drive fill it.  The SCSI spec mandates\n\t\t * that any untransfered data should be\n\t\t * assumed to be zero.  Complete the 'bounce'\n\t\t * of sense information through buffers accessible\n\t\t * via bus-space by copying it into the clients\n\t\t * csio.\n\t\t */\n\t\tbzero(&xs->sense, sizeof(struct scsi_sense));\n\t\tbcopy(&ahc->scb_data->sense[scb->hscb->tag],\n\t\t      &xs->sense, scb->sg_list->len);\n\t\txs->error = XS_SENSE;\n\t}\n\tif (scb->flags & SCB_FREEZE_QUEUE) {\n\t\tahc->devqueue_blocked[target]--;\n\t\tscb->flags &= ~SCB_FREEZE_QUEUE;\n\t}\n\t\n\trequeue = scb->flags & SCB_REQUEUE;\n\tahcfreescb(ahc, scb);\n\n\tif (requeue) {\n\t\t/*\n\t\t * Re-insert at the front of the private queue to\n\t\t * preserve order.\n\t\t */\n\t\tint s;\n\n\t\ts = splbio();\n\t\t/* TAILQ_INSERT_HEAD(&ahc->sc_q, xs, adapter_q); */\n\t\tahc_list_insert_head(ahc, xs);\n\t\tsplx(s);\n\t} else {\n\t\txs->flags |= ITSDONE;\n\t\tahc_check_tags(ahc, xs);\n\t\tscsi_done(xs);\n\t}\n\n\t/*\n\t * If there are entries in the software queue, try to\n\t * run the first one.  We should be more or less guaranteed\n\t * to succeed, since we just freed an SCB.\n\t *\n\t * NOTE: ahc_scsi_cmd() relies on our calling it with\n\t * the first entry in the queue.\n\t */\n\tif ((xs = ahc->sc_xxxq.lh_first) != NULL)\n\t\t(void) ahc_scsi_cmd(xs);\n}"
  },
  {
    "function_name": "ahc_handle_devreset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "3365-3394",
    "snippet": "STATIC void\nahc_handle_devreset(ahc, devinfo, status, message, verbose_level)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n\tint status;\n\tchar *message;\n\tint verbose_level;\n{\n\tint found;\n\n\tfound = ahc_abort_scbs(ahc, devinfo->target, devinfo->channel,\n\t\t\t       ALL_LUNS, SCB_LIST_NULL, devinfo->role,\n\t\t\t       status);\n\t\n\t/*\n\t * Go back to async/narrow transfers and renegotiate.\n\t * ahc_set_width and ahc_set_syncrate can cope with NULL\n\t * paths.\n\t */\n\tahc_set_width(ahc, devinfo, MSG_EXT_WDTR_BUS_8_BIT,\n\t\t      AHC_TRANS_CUR, /*paused*/TRUE, /*done*/FALSE);\n\tahc_set_syncrate(ahc, devinfo, /*syncrate*/NULL,\n\t\t\t /*period*/0, /*offset*/0, AHC_TRANS_CUR,\n\t\t\t /*paused*/TRUE, /*done*/FALSE);\n\t\n\tif (message != NULL\n\t && (verbose_level <= bootverbose))\n\t\tprintf(\"%s: %s on %c:%d. %d SCBs aborted\\n\", ahc_name(ahc),\n\t\t       message, devinfo->channel, devinfo->target, found);\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define STATIC\tstatic",
      "#define bootverbose\t0",
      "#define STATIC",
      "#define bootverbose\t1"
    ],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
      "STATIC void",
      "ahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));",
      "STATIC void",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
      "STATIC void",
      "STATIC void",
      "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
      "STATIC int",
      "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
      "STATIC void",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
      "STATIC void",
      "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
      "STATIC void",
      "ahc_handle_devreset __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct ahc_devinfo *devinfo,\n\t\t\t\t\t int status, char *message,\n\t\t\t\t\t int verbose_level));",
      "STATIC void",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "ahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "ahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));",
      "STATIC int",
      "STATIC void",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "ahc_update_target_msg_request __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t\t      struct ahc_initiator_tinfo *tinfo,\n\t\t\t\t\t      int force, int paused));",
      "STATIC void",
      "ahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));",
      "STATIC void",
      "ahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "ahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "char channel;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "u_int *period;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "u_int *period;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "char channel;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: %s on %c:%d. %d SCBs aborted\\n\"",
            "ahc_name(ahc)",
            "message",
            "devinfo->channel",
            "devinfo->target",
            "found"
          ],
          "line": 3392
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 3392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_set_syncrate",
          "args": [
            "ahc",
            "devinfo",
            "/*syncrate*/NULL",
            "/*period*/0",
            "/*offset*/0",
            "AHC_TRANS_CUR",
            "/*paused*/TRUE",
            "/*done*/FALSE"
          ],
          "line": 3386
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_set_syncrate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "1297-1406",
          "snippet": "STATIC void\nahc_set_syncrate(ahc, devinfo, syncrate, period, offset, type, paused, done)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n\tstruct ahc_syncrate *syncrate;\n\tu_int period;\n\tu_int offset;\n\tu_int type;\n\tint paused;\n\tint done;\n{\n\tstruct\tahc_initiator_tinfo *tinfo;\n\tstruct\ttmode_tstate *tstate;\n\tu_int\told_period;\n\tu_int\told_offset;\n\tint\tactive = (type & AHC_TRANS_ACTIVE) == AHC_TRANS_ACTIVE;\n\n\tif (syncrate == NULL) {\n\t\tperiod = 0;\n\t\toffset = 0;\n\t}\n\n\ttinfo = ahc_fetch_transinfo(ahc, devinfo->channel,\n\t\t\t\t    devinfo->our_scsiid,\n\t\t\t\t    devinfo->target, &tstate);\n\told_period = tinfo->current.period;\n\told_offset = tinfo->current.offset;\n\n\tif ((type & AHC_TRANS_CUR) != 0\n\t && (old_period != period || old_offset != offset)) {\n\t\tu_int\tscsirate;\n\n\t\tscsirate = tinfo->scsirate;\n\t\tif ((ahc->features & AHC_ULTRA2) != 0) {\n\n\t\t\t/* XXX */\n\t\t\t/* Force single edge until DT is fully implemented */\n\t\t\tscsirate &= ~(SXFR_ULTRA2|SINGLE_EDGE|ENABLE_CRC);\n\t\t\tif (syncrate != NULL)\n\t\t\t\tscsirate |= syncrate->sxfr_u2|SINGLE_EDGE;\n\n\t\t\tif (active)\n\t\t\t\tahc_outb(ahc, SCSIOFFSET, offset);\n\t\t} else {\n\n\t\t\tscsirate &= ~(SXFR|SOFS);\n\t\t\t/*\n\t\t\t * Ensure Ultra mode is set properly for\n\t\t\t * this target.\n\t\t\t */\n\t\t\ttstate->ultraenb &= ~devinfo->target_mask;\n\t\t\tif (syncrate != NULL) {\n\t\t\t\tif (syncrate->sxfr & ULTRA_SXFR) {\n\t\t\t\t\ttstate->ultraenb |=\n\t\t\t\t\t\tdevinfo->target_mask;\n\t\t\t\t}\n\t\t\t\tscsirate |= syncrate->sxfr & SXFR;\n\t\t\t\tscsirate |= offset & SOFS;\n\t\t\t}\n\t\t\tif (active) {\n\t\t\t\tu_int sxfrctl0;\n\n\t\t\t\tsxfrctl0 = ahc_inb(ahc, SXFRCTL0);\n\t\t\t\tsxfrctl0 &= ~FAST20;\n\t\t\t\tif (tstate->ultraenb & devinfo->target_mask)\n\t\t\t\t\tsxfrctl0 |= FAST20;\n\t\t\t\tahc_outb(ahc, SXFRCTL0, sxfrctl0);\n\t\t\t}\n\t\t}\n\t\tif (active)\n\t\t\tahc_outb(ahc, SCSIRATE, scsirate);\n\n\t\ttinfo->scsirate = scsirate;\n\t\ttinfo->current.period = period;\n\t\ttinfo->current.offset = offset;\n\n\t\t/* Update the syncrates in any pending scbs */\n\t\tahc_update_pending_syncrates(ahc);\n\t}\n\n\t/*\n\t * Print messages if we're verbose and at the end of a negotiation\n\t * cycle.\n\t */\n\tif (done) {\n\t\tif (offset != 0) {\n\t\t\tprintf(\"%s: target %d synchronous at %sMHz, \"\n\t\t\t       \"offset = 0x%x\\n\", ahc_name(ahc),\n\t\t\t       devinfo->target, syncrate->rate, offset);\n\t\t} else {\n\t\t\tprintf(\"%s: target %d using \"\n\t\t\t       \"asynchronous transfers\\n\",\n\t\t\t       ahc_name(ahc), devinfo->target);\n\t\t}\n\t}\n\n\tif ((type & AHC_TRANS_GOAL) != 0) {\n\t\ttinfo->goal.period = period;\n\t\ttinfo->goal.offset = offset;\n\t}\n\n\tif ((type & AHC_TRANS_USER) != 0) {\n\t\ttinfo->user.period = period;\n\t\ttinfo->user.offset = offset;\n\t}\n\n\tahc_update_target_msg_request(ahc, devinfo, tinfo,\n\t\t\t\t      /*force*/FALSE,\n\t\t\t\t      paused);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC int",
            "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "ahc_update_target_msg_request __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t\t      struct ahc_initiator_tinfo *tinfo,\n\t\t\t\t\t      int force, int paused));",
            "STATIC void",
            "ahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));",
            "STATIC void",
            "ahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "static __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct tmode_tstate **tstate;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "u_int *period;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "u_int *period;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nahc_update_target_msg_request __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t\t      struct ahc_initiator_tinfo *tinfo,\n\t\t\t\t\t      int force, int paused));\nSTATIC void;\nahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));\nSTATIC void;\nahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct tmode_tstate **tstate;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_set_syncrate(ahc, devinfo, syncrate, period, offset, type, paused, done)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n\tstruct ahc_syncrate *syncrate;\n\tu_int period;\n\tu_int offset;\n\tu_int type;\n\tint paused;\n\tint done;\n{\n\tstruct\tahc_initiator_tinfo *tinfo;\n\tstruct\ttmode_tstate *tstate;\n\tu_int\told_period;\n\tu_int\told_offset;\n\tint\tactive = (type & AHC_TRANS_ACTIVE) == AHC_TRANS_ACTIVE;\n\n\tif (syncrate == NULL) {\n\t\tperiod = 0;\n\t\toffset = 0;\n\t}\n\n\ttinfo = ahc_fetch_transinfo(ahc, devinfo->channel,\n\t\t\t\t    devinfo->our_scsiid,\n\t\t\t\t    devinfo->target, &tstate);\n\told_period = tinfo->current.period;\n\told_offset = tinfo->current.offset;\n\n\tif ((type & AHC_TRANS_CUR) != 0\n\t && (old_period != period || old_offset != offset)) {\n\t\tu_int\tscsirate;\n\n\t\tscsirate = tinfo->scsirate;\n\t\tif ((ahc->features & AHC_ULTRA2) != 0) {\n\n\t\t\t/* XXX */\n\t\t\t/* Force single edge until DT is fully implemented */\n\t\t\tscsirate &= ~(SXFR_ULTRA2|SINGLE_EDGE|ENABLE_CRC);\n\t\t\tif (syncrate != NULL)\n\t\t\t\tscsirate |= syncrate->sxfr_u2|SINGLE_EDGE;\n\n\t\t\tif (active)\n\t\t\t\tahc_outb(ahc, SCSIOFFSET, offset);\n\t\t} else {\n\n\t\t\tscsirate &= ~(SXFR|SOFS);\n\t\t\t/*\n\t\t\t * Ensure Ultra mode is set properly for\n\t\t\t * this target.\n\t\t\t */\n\t\t\ttstate->ultraenb &= ~devinfo->target_mask;\n\t\t\tif (syncrate != NULL) {\n\t\t\t\tif (syncrate->sxfr & ULTRA_SXFR) {\n\t\t\t\t\ttstate->ultraenb |=\n\t\t\t\t\t\tdevinfo->target_mask;\n\t\t\t\t}\n\t\t\t\tscsirate |= syncrate->sxfr & SXFR;\n\t\t\t\tscsirate |= offset & SOFS;\n\t\t\t}\n\t\t\tif (active) {\n\t\t\t\tu_int sxfrctl0;\n\n\t\t\t\tsxfrctl0 = ahc_inb(ahc, SXFRCTL0);\n\t\t\t\tsxfrctl0 &= ~FAST20;\n\t\t\t\tif (tstate->ultraenb & devinfo->target_mask)\n\t\t\t\t\tsxfrctl0 |= FAST20;\n\t\t\t\tahc_outb(ahc, SXFRCTL0, sxfrctl0);\n\t\t\t}\n\t\t}\n\t\tif (active)\n\t\t\tahc_outb(ahc, SCSIRATE, scsirate);\n\n\t\ttinfo->scsirate = scsirate;\n\t\ttinfo->current.period = period;\n\t\ttinfo->current.offset = offset;\n\n\t\t/* Update the syncrates in any pending scbs */\n\t\tahc_update_pending_syncrates(ahc);\n\t}\n\n\t/*\n\t * Print messages if we're verbose and at the end of a negotiation\n\t * cycle.\n\t */\n\tif (done) {\n\t\tif (offset != 0) {\n\t\t\tprintf(\"%s: target %d synchronous at %sMHz, \"\n\t\t\t       \"offset = 0x%x\\n\", ahc_name(ahc),\n\t\t\t       devinfo->target, syncrate->rate, offset);\n\t\t} else {\n\t\t\tprintf(\"%s: target %d using \"\n\t\t\t       \"asynchronous transfers\\n\",\n\t\t\t       ahc_name(ahc), devinfo->target);\n\t\t}\n\t}\n\n\tif ((type & AHC_TRANS_GOAL) != 0) {\n\t\ttinfo->goal.period = period;\n\t\ttinfo->goal.offset = offset;\n\t}\n\n\tif ((type & AHC_TRANS_USER) != 0) {\n\t\ttinfo->user.period = period;\n\t\ttinfo->user.offset = offset;\n\t}\n\n\tahc_update_target_msg_request(ahc, devinfo, tinfo,\n\t\t\t\t      /*force*/FALSE,\n\t\t\t\t      paused);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_set_width",
          "args": [
            "ahc",
            "devinfo",
            "MSG_EXT_WDTR_BUS_8_BIT",
            "AHC_TRANS_CUR",
            "/*paused*/TRUE",
            "/*done*/FALSE"
          ],
          "line": 3384
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_set_width",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "1408-1457",
          "snippet": "STATIC void\nahc_set_width(ahc, devinfo, width, type, paused, done)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n\tu_int width;\n\tu_int type;\n\tint paused;\n\tint done;\n{\n\tstruct ahc_initiator_tinfo *tinfo;\n\tstruct tmode_tstate *tstate;\n\tu_int  oldwidth;\n\tint    active = (type & AHC_TRANS_ACTIVE) == AHC_TRANS_ACTIVE;\n\n\ttinfo = ahc_fetch_transinfo(ahc, devinfo->channel,\n\t\t\t\t    devinfo->our_scsiid,\n\t\t\t\t    devinfo->target,\n\t\t\t\t    &tstate);\n\toldwidth = tinfo->current.width;\n\n\tif ((type & AHC_TRANS_CUR) != 0 && oldwidth != width) {\n\t\tu_int\tscsirate;\n\n\t\tscsirate =  tinfo->scsirate;\n\t\tscsirate &= ~WIDEXFER;\n\t\tif (width == MSG_EXT_WDTR_BUS_16_BIT)\n\t\t\tscsirate |= WIDEXFER;\n\n\t\ttinfo->scsirate = scsirate;\n\n\t\tif (active)\n\t\t\tahc_outb(ahc, SCSIRATE, scsirate);\n\n\t\ttinfo->current.width = width;\n\t}\n\n\tif (done) {\n\t\tprintf(\"%s: target %d using %dbit transfers\\n\",\n\t\t       ahc_name(ahc), devinfo->target,\n\t\t       8 * (0x01 << width));\n\t}\n\n\tif ((type & AHC_TRANS_GOAL) != 0)\n\t\ttinfo->goal.width = width;\n\tif ((type & AHC_TRANS_USER) != 0)\n\t\ttinfo->user.width = width;\n\n\tahc_update_target_msg_request(ahc, devinfo, tinfo,\n\t\t\t\t      /*force*/FALSE, paused);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC int",
            "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "ahc_update_target_msg_request __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t\t      struct ahc_initiator_tinfo *tinfo,\n\t\t\t\t\t      int force, int paused));",
            "STATIC void",
            "ahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));",
            "STATIC void",
            "ahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "static __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct tmode_tstate **tstate;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nahc_update_target_msg_request __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t\t      struct ahc_initiator_tinfo *tinfo,\n\t\t\t\t\t      int force, int paused));\nSTATIC void;\nahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));\nSTATIC void;\nahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct tmode_tstate **tstate;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_set_width(ahc, devinfo, width, type, paused, done)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n\tu_int width;\n\tu_int type;\n\tint paused;\n\tint done;\n{\n\tstruct ahc_initiator_tinfo *tinfo;\n\tstruct tmode_tstate *tstate;\n\tu_int  oldwidth;\n\tint    active = (type & AHC_TRANS_ACTIVE) == AHC_TRANS_ACTIVE;\n\n\ttinfo = ahc_fetch_transinfo(ahc, devinfo->channel,\n\t\t\t\t    devinfo->our_scsiid,\n\t\t\t\t    devinfo->target,\n\t\t\t\t    &tstate);\n\toldwidth = tinfo->current.width;\n\n\tif ((type & AHC_TRANS_CUR) != 0 && oldwidth != width) {\n\t\tu_int\tscsirate;\n\n\t\tscsirate =  tinfo->scsirate;\n\t\tscsirate &= ~WIDEXFER;\n\t\tif (width == MSG_EXT_WDTR_BUS_16_BIT)\n\t\t\tscsirate |= WIDEXFER;\n\n\t\ttinfo->scsirate = scsirate;\n\n\t\tif (active)\n\t\t\tahc_outb(ahc, SCSIRATE, scsirate);\n\n\t\ttinfo->current.width = width;\n\t}\n\n\tif (done) {\n\t\tprintf(\"%s: target %d using %dbit transfers\\n\",\n\t\t       ahc_name(ahc), devinfo->target,\n\t\t       8 * (0x01 << width));\n\t}\n\n\tif ((type & AHC_TRANS_GOAL) != 0)\n\t\ttinfo->goal.width = width;\n\tif ((type & AHC_TRANS_USER) != 0)\n\t\ttinfo->user.width = width;\n\n\tahc_update_target_msg_request(ahc, devinfo, tinfo,\n\t\t\t\t      /*force*/FALSE, paused);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_abort_scbs",
          "args": [
            "ahc",
            "devinfo->target",
            "devinfo->channel",
            "ALL_LUNS",
            "SCB_LIST_NULL",
            "devinfo->role",
            "status"
          ],
          "line": 3375
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_abort_scbs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "5129-5231",
          "snippet": "STATIC int\nahc_abort_scbs(ahc, target, channel, lun, tag, role, status)\n\tstruct ahc_softc *ahc;\n\tint target;\n\tchar channel;\n\tint lun;\n\tu_int tag;\n\trole_t role;\n\tu_int32_t status;\n{\n\tstruct\tscb *scbp;\n\tu_int\tactive_scb;\n\tint\ti;\n\tint\tfound;\n\n\t/* restore this when we're done */\n\tactive_scb = ahc_inb(ahc, SCBPTR);\n\n\tfound = ahc_search_qinfifo(ahc, target, channel, lun, SCB_LIST_NULL,\n\t\t\t\t   role, SCB_REQUEUE, SEARCH_COMPLETE);\n\n\t/*\n\t * Search waiting for selection list.\n\t */\n\t{\n\t\tu_int8_t next, prev;\n                /* Start at head of list. */\n\t\tnext = ahc_inb(ahc, WAITING_SCBH);\n\t\tprev = SCB_LIST_NULL;\n\n\t\twhile (next != SCB_LIST_NULL) {\n\t\t\tu_int8_t scb_index;\n\n\t\t\tahc_outb(ahc, SCBPTR, next);\n\t\t\tscb_index = ahc_inb(ahc, SCB_TAG);\n\t\t\tif (scb_index >= ahc->scb_data->numscbs) {\n\t\t\t\tpanic(\"Waiting List inconsistency. \"\n\t\t\t\t      \"SCB index == %d, yet numscbs == %d.\",\n\t\t\t\t      scb_index, ahc->scb_data->numscbs);\n\t\t\t}\n\t\t\tscbp = &ahc->scb_data->scbarray[scb_index];\n\t\t\tif (ahc_match_scb(scbp, target, channel,\n\t\t\t\t\t  lun, SCB_LIST_NULL, role)) {\n\n\t\t\t\tnext = ahc_abort_wscb(ahc, next, prev);\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tprev = next;\n\t\t\t\tnext = ahc_inb(ahc, SCB_NEXT);\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\t * Go through the disconnected list and remove any entries we\n\t * have queued for completion, 0'ing their control byte too.\n\t * We save the active SCB and restore it ourselves, so there\n\t * is no reason for this search to restore it too.\n\t */\n\tahc_search_disc_list(ahc, target, channel, lun, tag,\n\t\t\t     /*stop_on_first*/FALSE, /*remove*/TRUE,\n\t\t\t     /*save_state*/FALSE);\n\n\t/*\n\t * Go through the hardware SCB array looking for commands that\n\t * were active but not on any list.\n\t */\n\tfor(i = 0; i < ahc->scb_data->maxhscbs; i++) {\n\t\tu_int scbid;\n\n\t\tahc_outb(ahc, SCBPTR, i);\n\t\tscbid = ahc_inb(ahc, SCB_TAG);\n\t\tscbp = &ahc->scb_data->scbarray[scbid];\n\t\tif (scbid < ahc->scb_data->numscbs && \n\t\t\t ahc_match_scb(scbp, target, channel, lun, tag, role))\n\t\t\t\tahc_add_curscb_to_free_list(ahc);\n\t}\n\n\t/*\n\t * Go through the pending CCB list and look for\n\t * commands for this target that are still active.\n\t * These are other tagged commands that were\n\t * disconnected when the reset occured.\n\t */\n\t{\n\t\tstruct scb *scb;\n\n\t\tscb = ahc->pending_scbs.lh_first;\n\t\twhile (scb != NULL) {\n\t\t\tscbp = scb;\n\t\t\tscb = scb->pend_links.le_next;\n\t\t\tif (ahc_match_scb(scbp, target, channel,\n\t\t\t\t\t  lun, tag, role)) {\n\t\t\t\tif (!(scbp->xs->flags & ITSDONE))\n\t\t\t\t\tahcsetccbstatus(scbp->xs, status);\n\t\t\t\tahc_freeze_ccb(scbp);\n\t\t\t\tahc_done(ahc, scbp);\n\t\t\t\tfound++;\n\t\t\t}\n\t\t}\n\t}\n\tahc_outb(ahc, SCBPTR, active_scb);\n\treturn found;\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "ahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));",
            "STATIC u_int",
            "ahc_abort_wscb __P((struct ahc_softc *ahc,\n\t\t\t\t    u_int scbpos, u_int prev));",
            "STATIC void",
            "ahc_done __P((struct ahc_softc *ahc, struct scb *scbp));",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "ahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "ahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));",
            "STATIC int",
            "ahc_search_disc_list __P((struct ahc_softc *ahc, int target,\n\t\t\t\t\t  char channel, int lun, u_int tag,\n\t\t\t\t\t  int stop_on_first, int remove,\n\t\t\t\t\t  int save_state));",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));",
            "STATIC void",
            "ahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));",
            "STATIC void",
            "STATIC int",
            "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
            "STATIC void",
            "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_calc_residual __P((struct scb *scb));",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "static __inline void ahc_freeze_ccb",
            "static __inline void ahcsetccbstatus",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *xs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));\nSTATIC u_int;\nahc_abort_wscb __P((struct ahc_softc *ahc,\n\t\t\t\t    u_int scbpos, u_int prev));\nSTATIC void;\nahc_done __P((struct ahc_softc *ahc, struct scb *scbp));\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));\nSTATIC int;\nahc_search_disc_list __P((struct ahc_softc *ahc, int target,\n\t\t\t\t\t  char channel, int lun, u_int tag,\n\t\t\t\t\t  int stop_on_first, int remove,\n\t\t\t\t\t  int save_state));\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));\nSTATIC void;\nahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));\nSTATIC void;\nSTATIC int;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nSTATIC void;\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_calc_residual __P((struct scb *scb));\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nstatic __inline void ahc_freeze_ccb;\nstatic __inline void ahcsetccbstatus;\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n\nSTATIC int\nahc_abort_scbs(ahc, target, channel, lun, tag, role, status)\n\tstruct ahc_softc *ahc;\n\tint target;\n\tchar channel;\n\tint lun;\n\tu_int tag;\n\trole_t role;\n\tu_int32_t status;\n{\n\tstruct\tscb *scbp;\n\tu_int\tactive_scb;\n\tint\ti;\n\tint\tfound;\n\n\t/* restore this when we're done */\n\tactive_scb = ahc_inb(ahc, SCBPTR);\n\n\tfound = ahc_search_qinfifo(ahc, target, channel, lun, SCB_LIST_NULL,\n\t\t\t\t   role, SCB_REQUEUE, SEARCH_COMPLETE);\n\n\t/*\n\t * Search waiting for selection list.\n\t */\n\t{\n\t\tu_int8_t next, prev;\n                /* Start at head of list. */\n\t\tnext = ahc_inb(ahc, WAITING_SCBH);\n\t\tprev = SCB_LIST_NULL;\n\n\t\twhile (next != SCB_LIST_NULL) {\n\t\t\tu_int8_t scb_index;\n\n\t\t\tahc_outb(ahc, SCBPTR, next);\n\t\t\tscb_index = ahc_inb(ahc, SCB_TAG);\n\t\t\tif (scb_index >= ahc->scb_data->numscbs) {\n\t\t\t\tpanic(\"Waiting List inconsistency. \"\n\t\t\t\t      \"SCB index == %d, yet numscbs == %d.\",\n\t\t\t\t      scb_index, ahc->scb_data->numscbs);\n\t\t\t}\n\t\t\tscbp = &ahc->scb_data->scbarray[scb_index];\n\t\t\tif (ahc_match_scb(scbp, target, channel,\n\t\t\t\t\t  lun, SCB_LIST_NULL, role)) {\n\n\t\t\t\tnext = ahc_abort_wscb(ahc, next, prev);\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tprev = next;\n\t\t\t\tnext = ahc_inb(ahc, SCB_NEXT);\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\t * Go through the disconnected list and remove any entries we\n\t * have queued for completion, 0'ing their control byte too.\n\t * We save the active SCB and restore it ourselves, so there\n\t * is no reason for this search to restore it too.\n\t */\n\tahc_search_disc_list(ahc, target, channel, lun, tag,\n\t\t\t     /*stop_on_first*/FALSE, /*remove*/TRUE,\n\t\t\t     /*save_state*/FALSE);\n\n\t/*\n\t * Go through the hardware SCB array looking for commands that\n\t * were active but not on any list.\n\t */\n\tfor(i = 0; i < ahc->scb_data->maxhscbs; i++) {\n\t\tu_int scbid;\n\n\t\tahc_outb(ahc, SCBPTR, i);\n\t\tscbid = ahc_inb(ahc, SCB_TAG);\n\t\tscbp = &ahc->scb_data->scbarray[scbid];\n\t\tif (scbid < ahc->scb_data->numscbs && \n\t\t\t ahc_match_scb(scbp, target, channel, lun, tag, role))\n\t\t\t\tahc_add_curscb_to_free_list(ahc);\n\t}\n\n\t/*\n\t * Go through the pending CCB list and look for\n\t * commands for this target that are still active.\n\t * These are other tagged commands that were\n\t * disconnected when the reset occured.\n\t */\n\t{\n\t\tstruct scb *scb;\n\n\t\tscb = ahc->pending_scbs.lh_first;\n\t\twhile (scb != NULL) {\n\t\t\tscbp = scb;\n\t\t\tscb = scb->pend_links.le_next;\n\t\t\tif (ahc_match_scb(scbp, target, channel,\n\t\t\t\t\t  lun, tag, role)) {\n\t\t\t\tif (!(scbp->xs->flags & ITSDONE))\n\t\t\t\t\tahcsetccbstatus(scbp->xs, status);\n\t\t\t\tahc_freeze_ccb(scbp);\n\t\t\t\tahc_done(ahc, scbp);\n\t\t\t\tfound++;\n\t\t\t}\n\t\t}\n\t}\n\tahc_outb(ahc, SCBPTR, active_scb);\n\treturn found;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define bootverbose\t0\n#define STATIC\n#define bootverbose\t1\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_devreset __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct ahc_devinfo *devinfo,\n\t\t\t\t\t int status, char *message,\n\t\t\t\t\t int verbose_level));\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));\nSTATIC int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nahc_update_target_msg_request __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t\t      struct ahc_initiator_tinfo *tinfo,\n\t\t\t\t\t      int force, int paused));\nSTATIC void;\nahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));\nSTATIC void;\nahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_handle_devreset(ahc, devinfo, status, message, verbose_level)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n\tint status;\n\tchar *message;\n\tint verbose_level;\n{\n\tint found;\n\n\tfound = ahc_abort_scbs(ahc, devinfo->target, devinfo->channel,\n\t\t\t       ALL_LUNS, SCB_LIST_NULL, devinfo->role,\n\t\t\t       status);\n\t\n\t/*\n\t * Go back to async/narrow transfers and renegotiate.\n\t * ahc_set_width and ahc_set_syncrate can cope with NULL\n\t * paths.\n\t */\n\tahc_set_width(ahc, devinfo, MSG_EXT_WDTR_BUS_8_BIT,\n\t\t      AHC_TRANS_CUR, /*paused*/TRUE, /*done*/FALSE);\n\tahc_set_syncrate(ahc, devinfo, /*syncrate*/NULL,\n\t\t\t /*period*/0, /*offset*/0, AHC_TRANS_CUR,\n\t\t\t /*paused*/TRUE, /*done*/FALSE);\n\t\n\tif (message != NULL\n\t && (verbose_level <= bootverbose))\n\t\tprintf(\"%s: %s on %c:%d. %d SCBs aborted\\n\", ahc_name(ahc),\n\t\t       message, devinfo->channel, devinfo->target, found);\n}"
  },
  {
    "function_name": "ahc_handle_ign_wide_residue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "3277-3363",
    "snippet": "STATIC void\nahc_handle_ign_wide_residue(ahc, devinfo)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n{\n\tu_int scb_index;\n\tstruct scb *scb;\n\n\tscb_index = ahc_inb(ahc, SCB_TAG);\n\tscb = &ahc->scb_data->scbarray[scb_index];\n\tif ((ahc_inb(ahc, SEQ_FLAGS) & DPHASE) == 0\n\t || !(scb->xs->flags & SCSI_DATA_IN)) {\n\t\t/*\n\t\t * Ignore the message if we haven't\n\t\t * seen an appropriate data phase yet.\n\t\t */\n\t} else {\n\t\t/*\n\t\t * If the residual occurred on the last\n\t\t * transfer and the transfer request was\n\t\t * expected to end on an odd count, do\n\t\t * nothing.  Otherwise, subtract a byte\n\t\t * and update the residual count accordingly.\n\t\t */\n\t\tu_int resid_sgcnt;\n\n\t\tresid_sgcnt = ahc_inb(ahc, SCB_RESID_SGCNT);\n\t\tif (resid_sgcnt == 0\n\t\t && ahc_inb(ahc, DATA_COUNT_ODD) == 1) {\n\t\t\t/*\n\t\t\t * If the residual occurred on the last\n\t\t\t * transfer and the transfer request was\n\t\t\t * expected to end on an odd count, do\n\t\t\t * nothing.\n\t\t\t */\n\t\t} else {\n\t\t\tu_int data_cnt;\n\t\t\tu_int data_addr;\n\t\t\tu_int sg_index;\n\n\t\t\tdata_cnt = (ahc_inb(ahc, SCB_RESID_DCNT + 2) << 16)\n\t\t\t\t | (ahc_inb(ahc, SCB_RESID_DCNT + 1) << 8)\n\t\t\t\t | (ahc_inb(ahc, SCB_RESID_DCNT));\n\n\t\t\tdata_addr = (ahc_inb(ahc, SHADDR + 3) << 24)\n\t\t\t\t  | (ahc_inb(ahc, SHADDR + 2) << 16)\n\t\t\t\t  | (ahc_inb(ahc, SHADDR + 1) << 8)\n\t\t\t\t  | (ahc_inb(ahc, SHADDR));\n\n\t\t\tdata_cnt += 1;\n\t\t\tdata_addr -= 1;\n\n\t\t\tsg_index = scb->sg_count - resid_sgcnt;\n\n\t\t\tif (sg_index != 0\n\t\t\t && (scb->sg_list[sg_index].len < data_cnt)) {\n\t\t\t\tu_int sg_addr;\n\n\t\t\t\tsg_index--;\n\t\t\t\tdata_cnt = 1;\n\t\t\t\tdata_addr = scb->sg_list[sg_index].addr\n\t\t\t\t\t  + scb->sg_list[sg_index].len - 1;\n\t\t\t\t\n\t\t\t\t/*\n\t\t\t\t * The physical address base points to the\n\t\t\t\t * second entry as it is always used for\n\t\t\t\t * calculating the \"next S/G pointer\".\n\t\t\t\t */\n\t\t\t\tsg_addr = scb->sg_list_phys\n\t\t\t\t\t+ (sg_index* sizeof(*scb->sg_list));\n\t\t\t\tahc_outb(ahc, SG_NEXT + 3, sg_addr >> 24);\n\t\t\t\tahc_outb(ahc, SG_NEXT + 2, sg_addr >> 16);\n\t\t\t\tahc_outb(ahc, SG_NEXT + 1, sg_addr >> 8);\n\t\t\t\tahc_outb(ahc, SG_NEXT, sg_addr);\n\t\t\t}\n\n\t\t\tahc_outb(ahc, SCB_RESID_DCNT + 2, data_cnt >> 16);\n\t\t\tahc_outb(ahc, SCB_RESID_DCNT + 1, data_cnt >> 8);\n\t\t\tahc_outb(ahc, SCB_RESID_DCNT, data_cnt);\n\n\t\t\tahc_outb(ahc, SHADDR + 3, data_addr >> 24);\n\t\t\tahc_outb(ahc, SHADDR + 2, data_addr >> 16);\n\t\t\tahc_outb(ahc, SHADDR + 1, data_addr >> 8);\n\t\t\tahc_outb(ahc, SHADDR, data_addr);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define STATIC\tstatic",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
      "STATIC void",
      "STATIC void",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
      "STATIC void",
      "STATIC u_int",
      "STATIC void",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
      "STATIC void",
      "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
      "STATIC void",
      "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
      "STATIC int",
      "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
      "STATIC void",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
      "STATIC void",
      "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
      "STATIC void",
      "STATIC void",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC u_int",
      "STATIC void",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "STATIC u_int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
      "STATIC void",
      "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_calc_residual __P((struct scb *scb));",
      "STATIC void",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
      "STATIC void",
      "STATIC void",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
      "STATIC void",
      "STATIC void",
      "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *xs;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SHADDR",
            "data_addr"
          ],
          "line": 3360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SHADDR + 1",
            "data_addr >> 8"
          ],
          "line": 3359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SHADDR + 2",
            "data_addr >> 16"
          ],
          "line": 3358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SHADDR + 3",
            "data_addr >> 24"
          ],
          "line": 3357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCB_RESID_DCNT",
            "data_cnt"
          ],
          "line": 3355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCB_RESID_DCNT + 1",
            "data_cnt >> 8"
          ],
          "line": 3354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCB_RESID_DCNT + 2",
            "data_cnt >> 16"
          ],
          "line": 3353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SG_NEXT",
            "sg_addr"
          ],
          "line": 3350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SG_NEXT + 1",
            "sg_addr >> 8"
          ],
          "line": 3349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SG_NEXT + 2",
            "sg_addr >> 16"
          ],
          "line": 3348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SG_NEXT + 3",
            "sg_addr >> 24"
          ],
          "line": 3347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SHADDR"
          ],
          "line": 3324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SHADDR + 1"
          ],
          "line": 3323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SHADDR + 2"
          ],
          "line": 3322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SHADDR + 3"
          ],
          "line": 3321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCB_RESID_DCNT"
          ],
          "line": 3319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCB_RESID_DCNT + 1"
          ],
          "line": 3318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCB_RESID_DCNT + 2"
          ],
          "line": 3317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "DATA_COUNT_ODD"
          ],
          "line": 3305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCB_RESID_SGCNT"
          ],
          "line": 3303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SEQ_FLAGS"
          ],
          "line": 3287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCB_TAG"
          ],
          "line": 3285
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nSTATIC void;\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_calc_residual __P((struct scb *scb));\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n\nSTATIC void\nahc_handle_ign_wide_residue(ahc, devinfo)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n{\n\tu_int scb_index;\n\tstruct scb *scb;\n\n\tscb_index = ahc_inb(ahc, SCB_TAG);\n\tscb = &ahc->scb_data->scbarray[scb_index];\n\tif ((ahc_inb(ahc, SEQ_FLAGS) & DPHASE) == 0\n\t || !(scb->xs->flags & SCSI_DATA_IN)) {\n\t\t/*\n\t\t * Ignore the message if we haven't\n\t\t * seen an appropriate data phase yet.\n\t\t */\n\t} else {\n\t\t/*\n\t\t * If the residual occurred on the last\n\t\t * transfer and the transfer request was\n\t\t * expected to end on an odd count, do\n\t\t * nothing.  Otherwise, subtract a byte\n\t\t * and update the residual count accordingly.\n\t\t */\n\t\tu_int resid_sgcnt;\n\n\t\tresid_sgcnt = ahc_inb(ahc, SCB_RESID_SGCNT);\n\t\tif (resid_sgcnt == 0\n\t\t && ahc_inb(ahc, DATA_COUNT_ODD) == 1) {\n\t\t\t/*\n\t\t\t * If the residual occurred on the last\n\t\t\t * transfer and the transfer request was\n\t\t\t * expected to end on an odd count, do\n\t\t\t * nothing.\n\t\t\t */\n\t\t} else {\n\t\t\tu_int data_cnt;\n\t\t\tu_int data_addr;\n\t\t\tu_int sg_index;\n\n\t\t\tdata_cnt = (ahc_inb(ahc, SCB_RESID_DCNT + 2) << 16)\n\t\t\t\t | (ahc_inb(ahc, SCB_RESID_DCNT + 1) << 8)\n\t\t\t\t | (ahc_inb(ahc, SCB_RESID_DCNT));\n\n\t\t\tdata_addr = (ahc_inb(ahc, SHADDR + 3) << 24)\n\t\t\t\t  | (ahc_inb(ahc, SHADDR + 2) << 16)\n\t\t\t\t  | (ahc_inb(ahc, SHADDR + 1) << 8)\n\t\t\t\t  | (ahc_inb(ahc, SHADDR));\n\n\t\t\tdata_cnt += 1;\n\t\t\tdata_addr -= 1;\n\n\t\t\tsg_index = scb->sg_count - resid_sgcnt;\n\n\t\t\tif (sg_index != 0\n\t\t\t && (scb->sg_list[sg_index].len < data_cnt)) {\n\t\t\t\tu_int sg_addr;\n\n\t\t\t\tsg_index--;\n\t\t\t\tdata_cnt = 1;\n\t\t\t\tdata_addr = scb->sg_list[sg_index].addr\n\t\t\t\t\t  + scb->sg_list[sg_index].len - 1;\n\t\t\t\t\n\t\t\t\t/*\n\t\t\t\t * The physical address base points to the\n\t\t\t\t * second entry as it is always used for\n\t\t\t\t * calculating the \"next S/G pointer\".\n\t\t\t\t */\n\t\t\t\tsg_addr = scb->sg_list_phys\n\t\t\t\t\t+ (sg_index* sizeof(*scb->sg_list));\n\t\t\t\tahc_outb(ahc, SG_NEXT + 3, sg_addr >> 24);\n\t\t\t\tahc_outb(ahc, SG_NEXT + 2, sg_addr >> 16);\n\t\t\t\tahc_outb(ahc, SG_NEXT + 1, sg_addr >> 8);\n\t\t\t\tahc_outb(ahc, SG_NEXT, sg_addr);\n\t\t\t}\n\n\t\t\tahc_outb(ahc, SCB_RESID_DCNT + 2, data_cnt >> 16);\n\t\t\tahc_outb(ahc, SCB_RESID_DCNT + 1, data_cnt >> 8);\n\t\t\tahc_outb(ahc, SCB_RESID_DCNT, data_cnt);\n\n\t\t\tahc_outb(ahc, SHADDR + 3, data_addr >> 24);\n\t\t\tahc_outb(ahc, SHADDR + 2, data_addr >> 16);\n\t\t\tahc_outb(ahc, SHADDR + 1, data_addr >> 8);\n\t\t\tahc_outb(ahc, SHADDR, data_addr);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "ahc_parse_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "2986-3275",
    "snippet": "STATIC int\nahc_parse_msg(ahc, sc_link, devinfo)\n\tstruct ahc_softc *ahc;\n\tstruct scsi_link *sc_link;\n\tstruct ahc_devinfo *devinfo;\n{\n\tstruct\tahc_initiator_tinfo *tinfo;\n\tstruct\ttmode_tstate *tstate;\n\tint\treject;\n\tint\tdone;\n\tint\tresponse;\n\tu_int\ttarg_scsirate;\n\n\tdone = MSGLOOP_IN_PROG;\n\tresponse = FALSE;\n\treject = FALSE;\n\ttinfo = ahc_fetch_transinfo(ahc, devinfo->channel, devinfo->our_scsiid,\n\t\t\t\t    devinfo->target, &tstate);\n\ttarg_scsirate = tinfo->scsirate;\n\n\t/*\n\t * Parse as much of the message as is availible,\n\t * rejecting it if we don't support it.  When\n\t * the entire message is availible and has been\n\t * handled, return MSGLOOP_MSGCOMPLETE, indicating\n\t * that we have parsed an entire message.\n\t *\n\t * In the case of extended messages, we accept the length\n\t * byte outright and perform more checking once we know the\n\t * extended message type.\n\t */\n\tswitch (ahc->msgin_buf[0]) {\n\tcase MSG_MESSAGE_REJECT:\n\t\tresponse = ahc_handle_msg_reject(ahc, devinfo);\n\t\t/* FALLTHROUGH */\n\tcase MSG_NOOP:\n\t\tdone = MSGLOOP_MSGCOMPLETE;\n\t\tbreak;\n\tcase MSG_IGN_WIDE_RESIDUE:\n\t{\n\t\t/* Wait for the whole message */\n\t\tif (ahc->msgin_index >= 1) {\n\t\t\tif (ahc->msgin_buf[1] != 1\n\t\t\t || tinfo->current.width == MSG_EXT_WDTR_BUS_8_BIT) {\n\t\t\t\treject = TRUE;\n\t\t\t\tdone = MSGLOOP_MSGCOMPLETE;\n\t\t\t} else\n\t\t\t\tahc_handle_ign_wide_residue(ahc, devinfo);\n\t\t}\n\t\tbreak;\n\t}\n\tcase MSG_EXTENDED:\n\t{\n\t\t/* Wait for enough of the message to begin validation */\n\t\tif (ahc->msgin_index < 2)\n\t\t\tbreak;\n\t\tswitch (ahc->msgin_buf[2]) {\n\t\tcase MSG_EXT_SDTR:\n\t\t{\n\t\t\tstruct\t ahc_syncrate *syncrate;\n\t\t\tu_int\t period;\n\t\t\tu_int\t offset;\n\t\t\tu_int\t saved_offset;\n\t\t\t\n\t\t\tif (ahc->msgin_buf[1] != MSG_EXT_SDTR_LEN) {\n\t\t\t\treject = TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Wait until we have both args before validating\n\t\t\t * and acting on this message.\n\t\t\t *\n\t\t\t * Add one to MSG_EXT_SDTR_LEN to account for\n\t\t\t * the extended message preamble.\n\t\t\t */\n\t\t\tif (ahc->msgin_index < (MSG_EXT_SDTR_LEN + 1))\n\t\t\t\tbreak;\n\n\t\t\tperiod = ahc->msgin_buf[3];\n\t\t\tsaved_offset = offset = ahc->msgin_buf[4];\n\t\t\tsyncrate = ahc_devlimited_syncrate(ahc, &period);\n\t\t\tahc_validate_offset(ahc, syncrate, &offset,\n\t\t\t\t\t    targ_scsirate & WIDEXFER);\n\t\t\tahc_set_syncrate(ahc, devinfo,\n\t\t\t\t\t syncrate, period, offset,\n\t\t\t\t\t AHC_TRANS_ACTIVE|AHC_TRANS_GOAL,\n\t\t\t\t\t /*paused*/TRUE, /*done*/TRUE);\n\n\t\t\t/*\n\t\t\t * See if we initiated Sync Negotiation\n\t\t\t * and didn't have to fall down to async\n\t\t\t * transfers.\n\t\t\t */\n\t\t\tif (ahc_sent_msg(ahc, MSG_EXT_SDTR, /*full*/TRUE)) {\n\t\t\t\t/* We started it */\n\t\t\t\tif (saved_offset != offset) {\n\t\t\t\t\t/* Went too low - force async */\n\t\t\t\t\treject = TRUE;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Send our own SDTR in reply\n\t\t\t\t */\n\t\t\t\tif (bootverbose)\n\t\t\t\t\tprintf(\"Sending SDTR!\\n\");\n\t\t\t\tahc->msgout_index = 0;\n\t\t\t\tahc->msgout_len = 0;\n\t\t\t\tahc_construct_sdtr(ahc, period, offset);\n\t\t\t\tahc->msgout_index = 0;\n\t\t\t\tresponse = TRUE;\n\t\t\t}\n\t\t\tdone = MSGLOOP_MSGCOMPLETE;\n\t\t\tbreak;\n\t\t}\n\t\tcase MSG_EXT_WDTR:\n\t\t{\n\t\t\tu_int\tbus_width;\n\t\t\tu_int\tsending_reply;\n\n\t\t\tsending_reply = FALSE;\n\t\t\tif (ahc->msgin_buf[1] != MSG_EXT_WDTR_LEN) {\n\t\t\t\treject = TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Wait until we have our arg before validating\n\t\t\t * and acting on this message.\n\t\t\t *\n\t\t\t * Add one to MSG_EXT_WDTR_LEN to account for\n\t\t\t * the extended message preamble.\n\t\t\t */\n\t\t\tif (ahc->msgin_index < (MSG_EXT_WDTR_LEN + 1))\n\t\t\t\tbreak;\n\n\t\t\tbus_width = ahc->msgin_buf[3];\n\t\t\tif (ahc_sent_msg(ahc, MSG_EXT_WDTR, /*full*/TRUE)) {\n\t\t\t\t/*\n\t\t\t\t * Don't send a WDTR back to the\n\t\t\t\t * target, since we asked first.\n\t\t\t\t */\n\t\t\t\tswitch (bus_width){\n\t\t\t\tdefault:\n\t\t\t\t\t/*\n\t\t\t\t\t * How can we do anything greater\n\t\t\t\t\t * than 16bit transfers on a 16bit\n\t\t\t\t\t * bus?\n\t\t\t\t\t */\n\t\t\t\t\treject = TRUE;\n\t\t\t\t\tprintf(\"%s: target %d requested %dBit \"\n\t\t\t\t\t       \"transfers.  Rejecting...\\n\",\n\t\t\t\t\t       ahc_name(ahc), devinfo->target,\n\t\t\t\t\t       8 * (0x01 << bus_width));\n\t\t\t\t\t/* FALLTHROUGH */\n\t\t\t\tcase MSG_EXT_WDTR_BUS_8_BIT:\n\t\t\t\t\tbus_width = MSG_EXT_WDTR_BUS_8_BIT;\n\t\t\t\t\tbreak;\n\t\t\t\tcase MSG_EXT_WDTR_BUS_16_BIT:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Send our own WDTR in reply\n\t\t\t\t */\n\t\t\t\tif (bootverbose)\n\t\t\t\t\tprintf(\"Sending WDTR!\\n\");\n\t\t\t\tswitch (bus_width) {\n\t\t\t\tdefault:\n\t\t\t\t\tif (ahc->features & AHC_WIDE) {\n\t\t\t\t\t\t/* Respond Wide */\n\t\t\t\t\t\tbus_width =\n\t\t\t\t\t\t    MSG_EXT_WDTR_BUS_16_BIT;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t/* FALLTHROUGH */\n\t\t\t\tcase MSG_EXT_WDTR_BUS_8_BIT:\n\t\t\t\t\tbus_width = MSG_EXT_WDTR_BUS_8_BIT;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tahc->msgout_index = 0;\n\t\t\t\tahc->msgout_len = 0;\n\t\t\t\tahc_construct_wdtr(ahc, bus_width);\n\t\t\t\tahc->msgout_index = 0;\n\t\t\t\tresponse = TRUE;\n\t\t\t\tsending_reply = TRUE;\n\t\t\t}\n\t\t\tahc_set_width(ahc, devinfo, bus_width,\n\t\t\t\t      AHC_TRANS_ACTIVE|AHC_TRANS_GOAL,\n\t\t\t\t      /*paused*/TRUE, /*done*/TRUE);\n\n\t\t\t/* After a wide message, we are async */\n\t\t\tahc_set_syncrate(ahc, devinfo,\n\t\t\t\t\t /*syncrate*/NULL, /*period*/0,\n\t\t\t\t\t /*offset*/0, AHC_TRANS_ACTIVE,\n\t\t\t\t\t /*paused*/TRUE, /*done*/FALSE);\n\t\t\tif (sending_reply == FALSE && reject == FALSE) {\n\n\t\t\t\tif (tinfo->goal.period) {\n\t\t\t\t\tstruct\tahc_syncrate *rate;\n\t\t\t\t\tu_int\tperiod;\n\t\t\t\t\tu_int\toffset;\n\n\t\t\t\t\t/* Start the sync negotiation */\n\t\t\t\t\tperiod = tinfo->goal.period;\n\t\t\t\t\trate = ahc_devlimited_syncrate(ahc,\n\t\t\t\t\t\t\t\t       &period);\n\t\t\t\t\toffset = tinfo->goal.offset;\n\t\t\t\t\tahc_validate_offset(ahc, rate, &offset,\n\t\t\t\t\t\t\t  tinfo->current.width);\n\t\t\t\t\tahc->msgout_index = 0;\n\t\t\t\t\tahc->msgout_len = 0;\n\t\t\t\t\tahc_construct_sdtr(ahc, period, offset);\n\t\t\t\t\tahc->msgout_index = 0;\n\t\t\t\t\tresponse = TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdone = MSGLOOP_MSGCOMPLETE;\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\t/* Unknown extended message.  Reject it. */\n\t\t\treject = TRUE;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\tcase MSG_BUS_DEV_RESET:\n\t\tahc_handle_devreset(ahc, devinfo,\n\t\t\t\t    XS_RESET, \"Bus Device Reset Received\",\n\t\t\t\t    /*verbose_level*/0);\n\t\trestart_sequencer(ahc);\n\t\tdone = MSGLOOP_TERMINATED;\n\t\tbreak;\n\tcase MSG_ABORT_TAG:\n\tcase MSG_ABORT:\n\tcase MSG_CLEAR_QUEUE:\n\t\t/* Target mode messages */\n\t\tif (devinfo->role != ROLE_TARGET) {\n\t\t\treject = TRUE;\n\t\t\tbreak;\n\t\t}\n#if AHC_TARGET_MODE\n\t\tahc_abort_scbs(ahc, devinfo->target, devinfo->channel,\n\t\t\t       devinfo->lun,\n\t\t\t       ahc->msgin_buf[0] == MSG_ABORT_TAG ? SCB_LIST_NULL\n\t\t\t       : ahc_inb(ahc, INITIATOR_TAG),\n\t\t\t\tROLE_TARGET, XS_DRIVER_STUFFUP);\n\n\t\ttstate = ahc->enabled_targets[devinfo->our_scsiid];\n\t\tif (tstate != NULL) {\n\t\t\tstruct tmode_lstate* lstate;\n\n\t\t\tlstate = tstate->enabled_luns[devinfo->lun];\n\t\t\tif (lstate != NULL) {\n\t\t\t\tahc_queue_lstate_event(ahc, lstate,\n\t\t\t\t\t\t       devinfo->our_scsiid,\n\t\t\t\t\t\t       ahc->msgin_buf[0],\n\t\t\t\t\t\t       /*arg*/0);\n\t\t\t\tahc_send_lstate_events(ahc, lstate);\n\t\t\t}\n\t\t}\n\t\tdone = MSGLOOP_MSGCOMPLETE;\n#else\n\t\tpanic(\"ahc: got target mode message\");\n#endif\n\t\tbreak;\n\tcase MSG_TERM_IO_PROC:\n\tdefault:\n\t\treject = TRUE;\n\t\tbreak;\n\t}\n\n\tif (reject) {\n\t\t/*\n\t\t * Setup to reject the message.\n\t\t */\n\t\tahc->msgout_index = 0;\n\t\tahc->msgout_len = 1;\n\t\tahc->msgout_buf[0] = MSG_MESSAGE_REJECT;\n\t\tdone = MSGLOOP_MSGCOMPLETE;\n\t\tresponse = TRUE;\n\t}\n\n\tif (done != MSGLOOP_IN_PROG && !response)\n\t\t/* Clear the outgoing message buffer */\n\t\tahc->msgout_len = 0;\n\n\treturn (done);\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define STATIC\tstatic",
      "#define bootverbose\t0",
      "#define STATIC",
      "#define bootverbose\t1"
    ],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "STATIC int",
      "STATIC void",
      "ahc_shutdown __P((void *arg));",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "ahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));",
      "STATIC void",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
      "STATIC void",
      "ahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));",
      "STATIC u_int",
      "STATIC void",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
      "STATIC void",
      "STATIC void",
      "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
      "STATIC int",
      "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
      "STATIC void",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));",
      "STATIC int",
      "ahc_sent_msg __P((struct ahc_softc *ahc, u_int msgtype,\n\t\t\t\t  int full));",
      "STATIC int",
      "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
      "STATIC void",
      "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
      "STATIC void",
      "ahc_handle_devreset __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct ahc_devinfo *devinfo,\n\t\t\t\t\t int status, char *message,\n\t\t\t\t\t int verbose_level));",
      "STATIC void",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "ahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC u_int",
      "STATIC void",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "STATIC u_int",
      "STATIC void",
      "ahc_validate_offset __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct ahc_syncrate *syncrate,\n\t\t\t\t\t u_int *offset, int wide));",
      "STATIC void",
      "ahc_update_target_msg_request __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t\t      struct ahc_initiator_tinfo *tinfo,\n\t\t\t\t\t      int force, int paused));",
      "STATIC void",
      "ahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));",
      "STATIC void",
      "ahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "ahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));",
      "STATIC void",
      "ahc_construct_wdtr __P((struct ahc_softc *ahc, u_int bus_width));",
      "STATIC void",
      "STATIC void",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "static __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "char channel;",
      "struct tmode_tstate **tstate;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "u_int *period;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "u_int *period;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "char channel;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"ahc: got target mode message\""
          ],
          "line": 3250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_send_lstate_events",
          "args": [
            "ahc",
            "lstate"
          ],
          "line": 3245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_queue_lstate_event",
          "args": [
            "ahc",
            "lstate",
            "devinfo->our_scsiid",
            "ahc->msgin_buf[0]",
            "/*arg*/0"
          ],
          "line": 3241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_abort_scbs",
          "args": [
            "ahc",
            "devinfo->target",
            "devinfo->channel",
            "devinfo->lun",
            "ahc->msgin_buf[0] == MSG_ABORT_TAG ? SCB_LIST_NULL\n\t\t\t       : ahc_inb(ahc, INITIATOR_TAG)",
            "ROLE_TARGET",
            "XS_DRIVER_STUFFUP"
          ],
          "line": 3229
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_abort_scbs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "5129-5231",
          "snippet": "STATIC int\nahc_abort_scbs(ahc, target, channel, lun, tag, role, status)\n\tstruct ahc_softc *ahc;\n\tint target;\n\tchar channel;\n\tint lun;\n\tu_int tag;\n\trole_t role;\n\tu_int32_t status;\n{\n\tstruct\tscb *scbp;\n\tu_int\tactive_scb;\n\tint\ti;\n\tint\tfound;\n\n\t/* restore this when we're done */\n\tactive_scb = ahc_inb(ahc, SCBPTR);\n\n\tfound = ahc_search_qinfifo(ahc, target, channel, lun, SCB_LIST_NULL,\n\t\t\t\t   role, SCB_REQUEUE, SEARCH_COMPLETE);\n\n\t/*\n\t * Search waiting for selection list.\n\t */\n\t{\n\t\tu_int8_t next, prev;\n                /* Start at head of list. */\n\t\tnext = ahc_inb(ahc, WAITING_SCBH);\n\t\tprev = SCB_LIST_NULL;\n\n\t\twhile (next != SCB_LIST_NULL) {\n\t\t\tu_int8_t scb_index;\n\n\t\t\tahc_outb(ahc, SCBPTR, next);\n\t\t\tscb_index = ahc_inb(ahc, SCB_TAG);\n\t\t\tif (scb_index >= ahc->scb_data->numscbs) {\n\t\t\t\tpanic(\"Waiting List inconsistency. \"\n\t\t\t\t      \"SCB index == %d, yet numscbs == %d.\",\n\t\t\t\t      scb_index, ahc->scb_data->numscbs);\n\t\t\t}\n\t\t\tscbp = &ahc->scb_data->scbarray[scb_index];\n\t\t\tif (ahc_match_scb(scbp, target, channel,\n\t\t\t\t\t  lun, SCB_LIST_NULL, role)) {\n\n\t\t\t\tnext = ahc_abort_wscb(ahc, next, prev);\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tprev = next;\n\t\t\t\tnext = ahc_inb(ahc, SCB_NEXT);\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\t * Go through the disconnected list and remove any entries we\n\t * have queued for completion, 0'ing their control byte too.\n\t * We save the active SCB and restore it ourselves, so there\n\t * is no reason for this search to restore it too.\n\t */\n\tahc_search_disc_list(ahc, target, channel, lun, tag,\n\t\t\t     /*stop_on_first*/FALSE, /*remove*/TRUE,\n\t\t\t     /*save_state*/FALSE);\n\n\t/*\n\t * Go through the hardware SCB array looking for commands that\n\t * were active but not on any list.\n\t */\n\tfor(i = 0; i < ahc->scb_data->maxhscbs; i++) {\n\t\tu_int scbid;\n\n\t\tahc_outb(ahc, SCBPTR, i);\n\t\tscbid = ahc_inb(ahc, SCB_TAG);\n\t\tscbp = &ahc->scb_data->scbarray[scbid];\n\t\tif (scbid < ahc->scb_data->numscbs && \n\t\t\t ahc_match_scb(scbp, target, channel, lun, tag, role))\n\t\t\t\tahc_add_curscb_to_free_list(ahc);\n\t}\n\n\t/*\n\t * Go through the pending CCB list and look for\n\t * commands for this target that are still active.\n\t * These are other tagged commands that were\n\t * disconnected when the reset occured.\n\t */\n\t{\n\t\tstruct scb *scb;\n\n\t\tscb = ahc->pending_scbs.lh_first;\n\t\twhile (scb != NULL) {\n\t\t\tscbp = scb;\n\t\t\tscb = scb->pend_links.le_next;\n\t\t\tif (ahc_match_scb(scbp, target, channel,\n\t\t\t\t\t  lun, tag, role)) {\n\t\t\t\tif (!(scbp->xs->flags & ITSDONE))\n\t\t\t\t\tahcsetccbstatus(scbp->xs, status);\n\t\t\t\tahc_freeze_ccb(scbp);\n\t\t\t\tahc_done(ahc, scbp);\n\t\t\t\tfound++;\n\t\t\t}\n\t\t}\n\t}\n\tahc_outb(ahc, SCBPTR, active_scb);\n\treturn found;\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "ahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));",
            "STATIC u_int",
            "ahc_abort_wscb __P((struct ahc_softc *ahc,\n\t\t\t\t    u_int scbpos, u_int prev));",
            "STATIC void",
            "ahc_done __P((struct ahc_softc *ahc, struct scb *scbp));",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "ahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "ahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));",
            "STATIC int",
            "ahc_search_disc_list __P((struct ahc_softc *ahc, int target,\n\t\t\t\t\t  char channel, int lun, u_int tag,\n\t\t\t\t\t  int stop_on_first, int remove,\n\t\t\t\t\t  int save_state));",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));",
            "STATIC void",
            "ahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));",
            "STATIC void",
            "STATIC int",
            "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
            "STATIC void",
            "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_calc_residual __P((struct scb *scb));",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "static __inline void ahc_freeze_ccb",
            "static __inline void ahcsetccbstatus",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *xs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));\nSTATIC u_int;\nahc_abort_wscb __P((struct ahc_softc *ahc,\n\t\t\t\t    u_int scbpos, u_int prev));\nSTATIC void;\nahc_done __P((struct ahc_softc *ahc, struct scb *scbp));\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));\nSTATIC int;\nahc_search_disc_list __P((struct ahc_softc *ahc, int target,\n\t\t\t\t\t  char channel, int lun, u_int tag,\n\t\t\t\t\t  int stop_on_first, int remove,\n\t\t\t\t\t  int save_state));\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));\nSTATIC void;\nahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));\nSTATIC void;\nSTATIC int;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nSTATIC void;\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_calc_residual __P((struct scb *scb));\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nstatic __inline void ahc_freeze_ccb;\nstatic __inline void ahcsetccbstatus;\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n\nSTATIC int\nahc_abort_scbs(ahc, target, channel, lun, tag, role, status)\n\tstruct ahc_softc *ahc;\n\tint target;\n\tchar channel;\n\tint lun;\n\tu_int tag;\n\trole_t role;\n\tu_int32_t status;\n{\n\tstruct\tscb *scbp;\n\tu_int\tactive_scb;\n\tint\ti;\n\tint\tfound;\n\n\t/* restore this when we're done */\n\tactive_scb = ahc_inb(ahc, SCBPTR);\n\n\tfound = ahc_search_qinfifo(ahc, target, channel, lun, SCB_LIST_NULL,\n\t\t\t\t   role, SCB_REQUEUE, SEARCH_COMPLETE);\n\n\t/*\n\t * Search waiting for selection list.\n\t */\n\t{\n\t\tu_int8_t next, prev;\n                /* Start at head of list. */\n\t\tnext = ahc_inb(ahc, WAITING_SCBH);\n\t\tprev = SCB_LIST_NULL;\n\n\t\twhile (next != SCB_LIST_NULL) {\n\t\t\tu_int8_t scb_index;\n\n\t\t\tahc_outb(ahc, SCBPTR, next);\n\t\t\tscb_index = ahc_inb(ahc, SCB_TAG);\n\t\t\tif (scb_index >= ahc->scb_data->numscbs) {\n\t\t\t\tpanic(\"Waiting List inconsistency. \"\n\t\t\t\t      \"SCB index == %d, yet numscbs == %d.\",\n\t\t\t\t      scb_index, ahc->scb_data->numscbs);\n\t\t\t}\n\t\t\tscbp = &ahc->scb_data->scbarray[scb_index];\n\t\t\tif (ahc_match_scb(scbp, target, channel,\n\t\t\t\t\t  lun, SCB_LIST_NULL, role)) {\n\n\t\t\t\tnext = ahc_abort_wscb(ahc, next, prev);\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tprev = next;\n\t\t\t\tnext = ahc_inb(ahc, SCB_NEXT);\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\t * Go through the disconnected list and remove any entries we\n\t * have queued for completion, 0'ing their control byte too.\n\t * We save the active SCB and restore it ourselves, so there\n\t * is no reason for this search to restore it too.\n\t */\n\tahc_search_disc_list(ahc, target, channel, lun, tag,\n\t\t\t     /*stop_on_first*/FALSE, /*remove*/TRUE,\n\t\t\t     /*save_state*/FALSE);\n\n\t/*\n\t * Go through the hardware SCB array looking for commands that\n\t * were active but not on any list.\n\t */\n\tfor(i = 0; i < ahc->scb_data->maxhscbs; i++) {\n\t\tu_int scbid;\n\n\t\tahc_outb(ahc, SCBPTR, i);\n\t\tscbid = ahc_inb(ahc, SCB_TAG);\n\t\tscbp = &ahc->scb_data->scbarray[scbid];\n\t\tif (scbid < ahc->scb_data->numscbs && \n\t\t\t ahc_match_scb(scbp, target, channel, lun, tag, role))\n\t\t\t\tahc_add_curscb_to_free_list(ahc);\n\t}\n\n\t/*\n\t * Go through the pending CCB list and look for\n\t * commands for this target that are still active.\n\t * These are other tagged commands that were\n\t * disconnected when the reset occured.\n\t */\n\t{\n\t\tstruct scb *scb;\n\n\t\tscb = ahc->pending_scbs.lh_first;\n\t\twhile (scb != NULL) {\n\t\t\tscbp = scb;\n\t\t\tscb = scb->pend_links.le_next;\n\t\t\tif (ahc_match_scb(scbp, target, channel,\n\t\t\t\t\t  lun, tag, role)) {\n\t\t\t\tif (!(scbp->xs->flags & ITSDONE))\n\t\t\t\t\tahcsetccbstatus(scbp->xs, status);\n\t\t\t\tahc_freeze_ccb(scbp);\n\t\t\t\tahc_done(ahc, scbp);\n\t\t\t\tfound++;\n\t\t\t}\n\t\t}\n\t}\n\tahc_outb(ahc, SCBPTR, active_scb);\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "INITIATOR_TAG"
          ],
          "line": 3232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "restart_sequencer",
          "args": [
            "ahc"
          ],
          "line": 3217
        },
        "resolved": true,
        "details": {
          "function_name": "restart_sequencer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "467-495",
          "snippet": "STATIC void\nrestart_sequencer(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tu_int i;\n\n\tpause_sequencer(ahc);\n\n\t/*\n\t * Everytime we restart the sequencer, there\n\t * is the possiblitity that we have restarted\n\t * within a three instruction window where an\n\t * SCB has been marked free but has not made it\n\t * onto the free list.  Since SCSI events(bus reset,\n\t * unexpected bus free) will always freeze the\n\t * sequencer, we cannot close this window.  To\n\t * avoid losing an SCB, we reconsitute the free\n\t * list every time we restart the sequencer.\n\t */\n\tahc_outb(ahc, FREE_SCBH, SCB_LIST_NULL);\n\tfor (i = 0; i < ahc->scb_data->maxhscbs; i++) {\n\t\t\n\t\tahc_outb(ahc, SCBPTR, i);\n\t\tif (ahc_inb(ahc, SCB_TAG) == SCB_LIST_NULL)\n\t\t\tahc_add_curscb_to_free_list(ahc);\n\t}\n\tahc_outb(ahc, SEQCTL, FASTMODE|SEQRESET);\n\tunpause_sequencer(ahc);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "static __inline void pause_sequencer",
            "static __inline void unpause_sequencer",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nstatic __inline void pause_sequencer;\nstatic __inline void unpause_sequencer;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nrestart_sequencer(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tu_int i;\n\n\tpause_sequencer(ahc);\n\n\t/*\n\t * Everytime we restart the sequencer, there\n\t * is the possiblitity that we have restarted\n\t * within a three instruction window where an\n\t * SCB has been marked free but has not made it\n\t * onto the free list.  Since SCSI events(bus reset,\n\t * unexpected bus free) will always freeze the\n\t * sequencer, we cannot close this window.  To\n\t * avoid losing an SCB, we reconsitute the free\n\t * list every time we restart the sequencer.\n\t */\n\tahc_outb(ahc, FREE_SCBH, SCB_LIST_NULL);\n\tfor (i = 0; i < ahc->scb_data->maxhscbs; i++) {\n\t\t\n\t\tahc_outb(ahc, SCBPTR, i);\n\t\tif (ahc_inb(ahc, SCB_TAG) == SCB_LIST_NULL)\n\t\t\tahc_add_curscb_to_free_list(ahc);\n\t}\n\tahc_outb(ahc, SEQCTL, FASTMODE|SEQRESET);\n\tunpause_sequencer(ahc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_handle_devreset",
          "args": [
            "ahc",
            "devinfo",
            "XS_RESET",
            "\"Bus Device Reset Received\"",
            "/*verbose_level*/0"
          ],
          "line": 3214
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_handle_devreset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "3365-3394",
          "snippet": "STATIC void\nahc_handle_devreset(ahc, devinfo, status, message, verbose_level)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n\tint status;\n\tchar *message;\n\tint verbose_level;\n{\n\tint found;\n\n\tfound = ahc_abort_scbs(ahc, devinfo->target, devinfo->channel,\n\t\t\t       ALL_LUNS, SCB_LIST_NULL, devinfo->role,\n\t\t\t       status);\n\t\n\t/*\n\t * Go back to async/narrow transfers and renegotiate.\n\t * ahc_set_width and ahc_set_syncrate can cope with NULL\n\t * paths.\n\t */\n\tahc_set_width(ahc, devinfo, MSG_EXT_WDTR_BUS_8_BIT,\n\t\t      AHC_TRANS_CUR, /*paused*/TRUE, /*done*/FALSE);\n\tahc_set_syncrate(ahc, devinfo, /*syncrate*/NULL,\n\t\t\t /*period*/0, /*offset*/0, AHC_TRANS_CUR,\n\t\t\t /*paused*/TRUE, /*done*/FALSE);\n\t\n\tif (message != NULL\n\t && (verbose_level <= bootverbose))\n\t\tprintf(\"%s: %s on %c:%d. %d SCBs aborted\\n\", ahc_name(ahc),\n\t\t       message, devinfo->channel, devinfo->target, found);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define bootverbose\t0",
            "#define STATIC",
            "#define bootverbose\t1"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC int",
            "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_handle_devreset __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct ahc_devinfo *devinfo,\n\t\t\t\t\t int status, char *message,\n\t\t\t\t\t int verbose_level));",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "ahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "ahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));",
            "STATIC int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "ahc_update_target_msg_request __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t\t      struct ahc_initiator_tinfo *tinfo,\n\t\t\t\t\t      int force, int paused));",
            "STATIC void",
            "ahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));",
            "STATIC void",
            "ahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "u_int *period;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "u_int *period;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define bootverbose\t0\n#define STATIC\n#define bootverbose\t1\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_devreset __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct ahc_devinfo *devinfo,\n\t\t\t\t\t int status, char *message,\n\t\t\t\t\t int verbose_level));\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));\nSTATIC int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nahc_update_target_msg_request __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t\t      struct ahc_initiator_tinfo *tinfo,\n\t\t\t\t\t      int force, int paused));\nSTATIC void;\nahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));\nSTATIC void;\nahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_handle_devreset(ahc, devinfo, status, message, verbose_level)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n\tint status;\n\tchar *message;\n\tint verbose_level;\n{\n\tint found;\n\n\tfound = ahc_abort_scbs(ahc, devinfo->target, devinfo->channel,\n\t\t\t       ALL_LUNS, SCB_LIST_NULL, devinfo->role,\n\t\t\t       status);\n\t\n\t/*\n\t * Go back to async/narrow transfers and renegotiate.\n\t * ahc_set_width and ahc_set_syncrate can cope with NULL\n\t * paths.\n\t */\n\tahc_set_width(ahc, devinfo, MSG_EXT_WDTR_BUS_8_BIT,\n\t\t      AHC_TRANS_CUR, /*paused*/TRUE, /*done*/FALSE);\n\tahc_set_syncrate(ahc, devinfo, /*syncrate*/NULL,\n\t\t\t /*period*/0, /*offset*/0, AHC_TRANS_CUR,\n\t\t\t /*paused*/TRUE, /*done*/FALSE);\n\t\n\tif (message != NULL\n\t && (verbose_level <= bootverbose))\n\t\tprintf(\"%s: %s on %c:%d. %d SCBs aborted\\n\", ahc_name(ahc),\n\t\t       message, devinfo->channel, devinfo->target, found);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_construct_sdtr",
          "args": [
            "ahc",
            "period",
            "offset"
          ],
          "line": 3198
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_construct_sdtr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "5551-5563",
          "snippet": "STATIC void\nahc_construct_sdtr(ahc, period, offset)\n\tstruct ahc_softc *ahc;\n\tu_int period;\n\tu_int offset;\n{\n\tahc->msgout_buf[ahc->msgout_index++] = MSG_EXTENDED;\n\tahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_SDTR_LEN;\n\tahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_SDTR;\n\tahc->msgout_buf[ahc->msgout_index++] = period;\n\tahc->msgout_buf[ahc->msgout_index++] = offset;\n\tahc->msgout_len += 5;\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "u_int *period;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "u_int *period;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_construct_sdtr(ahc, period, offset)\n\tstruct ahc_softc *ahc;\n\tu_int period;\n\tu_int offset;\n{\n\tahc->msgout_buf[ahc->msgout_index++] = MSG_EXTENDED;\n\tahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_SDTR_LEN;\n\tahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_SDTR;\n\tahc->msgout_buf[ahc->msgout_index++] = period;\n\tahc->msgout_buf[ahc->msgout_index++] = offset;\n\tahc->msgout_len += 5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_validate_offset",
          "args": [
            "ahc",
            "rate",
            "&offset",
            "tinfo->current.width"
          ],
          "line": 3194
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_validate_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "1227-1248",
          "snippet": "STATIC void\nahc_validate_offset(ahc, syncrate, offset, wide)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_syncrate *syncrate;\n\tu_int *offset;\n\tint wide;\n{\n\tu_int maxoffset;\n\n\t/* Limit offset to what we can do */\n\tif (syncrate == NULL) {\n\t\tmaxoffset = 0;\n\t} else if ((ahc->features & AHC_ULTRA2) != 0) {\n\t\tmaxoffset = MAX_OFFSET_ULTRA2;\n\t} else {\n\t\tif (wide)\n\t\t\tmaxoffset = MAX_OFFSET_16BIT;\n\t\telse\n\t\t\tmaxoffset = MAX_OFFSET_8BIT;\n\t}\n\t*offset = MIN(*offset, maxoffset);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "ahc_validate_offset __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct ahc_syncrate *syncrate,\n\t\t\t\t\t u_int *offset, int wide));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nahc_validate_offset __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct ahc_syncrate *syncrate,\n\t\t\t\t\t u_int *offset, int wide));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_validate_offset(ahc, syncrate, offset, wide)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_syncrate *syncrate;\n\tu_int *offset;\n\tint wide;\n{\n\tu_int maxoffset;\n\n\t/* Limit offset to what we can do */\n\tif (syncrate == NULL) {\n\t\tmaxoffset = 0;\n\t} else if ((ahc->features & AHC_ULTRA2) != 0) {\n\t\tmaxoffset = MAX_OFFSET_ULTRA2;\n\t} else {\n\t\tif (wide)\n\t\t\tmaxoffset = MAX_OFFSET_16BIT;\n\t\telse\n\t\t\tmaxoffset = MAX_OFFSET_8BIT;\n\t}\n\t*offset = MIN(*offset, maxoffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_devlimited_syncrate",
          "args": [
            "ahc",
            "&period"
          ],
          "line": 3191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_set_syncrate",
          "args": [
            "ahc",
            "devinfo",
            "/*syncrate*/NULL",
            "/*period*/0",
            "/*offset*/0",
            "AHC_TRANS_ACTIVE",
            "/*paused*/TRUE",
            "/*done*/FALSE"
          ],
          "line": 3178
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_set_syncrate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "1297-1406",
          "snippet": "STATIC void\nahc_set_syncrate(ahc, devinfo, syncrate, period, offset, type, paused, done)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n\tstruct ahc_syncrate *syncrate;\n\tu_int period;\n\tu_int offset;\n\tu_int type;\n\tint paused;\n\tint done;\n{\n\tstruct\tahc_initiator_tinfo *tinfo;\n\tstruct\ttmode_tstate *tstate;\n\tu_int\told_period;\n\tu_int\told_offset;\n\tint\tactive = (type & AHC_TRANS_ACTIVE) == AHC_TRANS_ACTIVE;\n\n\tif (syncrate == NULL) {\n\t\tperiod = 0;\n\t\toffset = 0;\n\t}\n\n\ttinfo = ahc_fetch_transinfo(ahc, devinfo->channel,\n\t\t\t\t    devinfo->our_scsiid,\n\t\t\t\t    devinfo->target, &tstate);\n\told_period = tinfo->current.period;\n\told_offset = tinfo->current.offset;\n\n\tif ((type & AHC_TRANS_CUR) != 0\n\t && (old_period != period || old_offset != offset)) {\n\t\tu_int\tscsirate;\n\n\t\tscsirate = tinfo->scsirate;\n\t\tif ((ahc->features & AHC_ULTRA2) != 0) {\n\n\t\t\t/* XXX */\n\t\t\t/* Force single edge until DT is fully implemented */\n\t\t\tscsirate &= ~(SXFR_ULTRA2|SINGLE_EDGE|ENABLE_CRC);\n\t\t\tif (syncrate != NULL)\n\t\t\t\tscsirate |= syncrate->sxfr_u2|SINGLE_EDGE;\n\n\t\t\tif (active)\n\t\t\t\tahc_outb(ahc, SCSIOFFSET, offset);\n\t\t} else {\n\n\t\t\tscsirate &= ~(SXFR|SOFS);\n\t\t\t/*\n\t\t\t * Ensure Ultra mode is set properly for\n\t\t\t * this target.\n\t\t\t */\n\t\t\ttstate->ultraenb &= ~devinfo->target_mask;\n\t\t\tif (syncrate != NULL) {\n\t\t\t\tif (syncrate->sxfr & ULTRA_SXFR) {\n\t\t\t\t\ttstate->ultraenb |=\n\t\t\t\t\t\tdevinfo->target_mask;\n\t\t\t\t}\n\t\t\t\tscsirate |= syncrate->sxfr & SXFR;\n\t\t\t\tscsirate |= offset & SOFS;\n\t\t\t}\n\t\t\tif (active) {\n\t\t\t\tu_int sxfrctl0;\n\n\t\t\t\tsxfrctl0 = ahc_inb(ahc, SXFRCTL0);\n\t\t\t\tsxfrctl0 &= ~FAST20;\n\t\t\t\tif (tstate->ultraenb & devinfo->target_mask)\n\t\t\t\t\tsxfrctl0 |= FAST20;\n\t\t\t\tahc_outb(ahc, SXFRCTL0, sxfrctl0);\n\t\t\t}\n\t\t}\n\t\tif (active)\n\t\t\tahc_outb(ahc, SCSIRATE, scsirate);\n\n\t\ttinfo->scsirate = scsirate;\n\t\ttinfo->current.period = period;\n\t\ttinfo->current.offset = offset;\n\n\t\t/* Update the syncrates in any pending scbs */\n\t\tahc_update_pending_syncrates(ahc);\n\t}\n\n\t/*\n\t * Print messages if we're verbose and at the end of a negotiation\n\t * cycle.\n\t */\n\tif (done) {\n\t\tif (offset != 0) {\n\t\t\tprintf(\"%s: target %d synchronous at %sMHz, \"\n\t\t\t       \"offset = 0x%x\\n\", ahc_name(ahc),\n\t\t\t       devinfo->target, syncrate->rate, offset);\n\t\t} else {\n\t\t\tprintf(\"%s: target %d using \"\n\t\t\t       \"asynchronous transfers\\n\",\n\t\t\t       ahc_name(ahc), devinfo->target);\n\t\t}\n\t}\n\n\tif ((type & AHC_TRANS_GOAL) != 0) {\n\t\ttinfo->goal.period = period;\n\t\ttinfo->goal.offset = offset;\n\t}\n\n\tif ((type & AHC_TRANS_USER) != 0) {\n\t\ttinfo->user.period = period;\n\t\ttinfo->user.offset = offset;\n\t}\n\n\tahc_update_target_msg_request(ahc, devinfo, tinfo,\n\t\t\t\t      /*force*/FALSE,\n\t\t\t\t      paused);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC int",
            "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "ahc_update_target_msg_request __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t\t      struct ahc_initiator_tinfo *tinfo,\n\t\t\t\t\t      int force, int paused));",
            "STATIC void",
            "ahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));",
            "STATIC void",
            "ahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "static __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct tmode_tstate **tstate;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "u_int *period;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "u_int *period;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nahc_update_target_msg_request __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t\t      struct ahc_initiator_tinfo *tinfo,\n\t\t\t\t\t      int force, int paused));\nSTATIC void;\nahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));\nSTATIC void;\nahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct tmode_tstate **tstate;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_set_syncrate(ahc, devinfo, syncrate, period, offset, type, paused, done)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n\tstruct ahc_syncrate *syncrate;\n\tu_int period;\n\tu_int offset;\n\tu_int type;\n\tint paused;\n\tint done;\n{\n\tstruct\tahc_initiator_tinfo *tinfo;\n\tstruct\ttmode_tstate *tstate;\n\tu_int\told_period;\n\tu_int\told_offset;\n\tint\tactive = (type & AHC_TRANS_ACTIVE) == AHC_TRANS_ACTIVE;\n\n\tif (syncrate == NULL) {\n\t\tperiod = 0;\n\t\toffset = 0;\n\t}\n\n\ttinfo = ahc_fetch_transinfo(ahc, devinfo->channel,\n\t\t\t\t    devinfo->our_scsiid,\n\t\t\t\t    devinfo->target, &tstate);\n\told_period = tinfo->current.period;\n\told_offset = tinfo->current.offset;\n\n\tif ((type & AHC_TRANS_CUR) != 0\n\t && (old_period != period || old_offset != offset)) {\n\t\tu_int\tscsirate;\n\n\t\tscsirate = tinfo->scsirate;\n\t\tif ((ahc->features & AHC_ULTRA2) != 0) {\n\n\t\t\t/* XXX */\n\t\t\t/* Force single edge until DT is fully implemented */\n\t\t\tscsirate &= ~(SXFR_ULTRA2|SINGLE_EDGE|ENABLE_CRC);\n\t\t\tif (syncrate != NULL)\n\t\t\t\tscsirate |= syncrate->sxfr_u2|SINGLE_EDGE;\n\n\t\t\tif (active)\n\t\t\t\tahc_outb(ahc, SCSIOFFSET, offset);\n\t\t} else {\n\n\t\t\tscsirate &= ~(SXFR|SOFS);\n\t\t\t/*\n\t\t\t * Ensure Ultra mode is set properly for\n\t\t\t * this target.\n\t\t\t */\n\t\t\ttstate->ultraenb &= ~devinfo->target_mask;\n\t\t\tif (syncrate != NULL) {\n\t\t\t\tif (syncrate->sxfr & ULTRA_SXFR) {\n\t\t\t\t\ttstate->ultraenb |=\n\t\t\t\t\t\tdevinfo->target_mask;\n\t\t\t\t}\n\t\t\t\tscsirate |= syncrate->sxfr & SXFR;\n\t\t\t\tscsirate |= offset & SOFS;\n\t\t\t}\n\t\t\tif (active) {\n\t\t\t\tu_int sxfrctl0;\n\n\t\t\t\tsxfrctl0 = ahc_inb(ahc, SXFRCTL0);\n\t\t\t\tsxfrctl0 &= ~FAST20;\n\t\t\t\tif (tstate->ultraenb & devinfo->target_mask)\n\t\t\t\t\tsxfrctl0 |= FAST20;\n\t\t\t\tahc_outb(ahc, SXFRCTL0, sxfrctl0);\n\t\t\t}\n\t\t}\n\t\tif (active)\n\t\t\tahc_outb(ahc, SCSIRATE, scsirate);\n\n\t\ttinfo->scsirate = scsirate;\n\t\ttinfo->current.period = period;\n\t\ttinfo->current.offset = offset;\n\n\t\t/* Update the syncrates in any pending scbs */\n\t\tahc_update_pending_syncrates(ahc);\n\t}\n\n\t/*\n\t * Print messages if we're verbose and at the end of a negotiation\n\t * cycle.\n\t */\n\tif (done) {\n\t\tif (offset != 0) {\n\t\t\tprintf(\"%s: target %d synchronous at %sMHz, \"\n\t\t\t       \"offset = 0x%x\\n\", ahc_name(ahc),\n\t\t\t       devinfo->target, syncrate->rate, offset);\n\t\t} else {\n\t\t\tprintf(\"%s: target %d using \"\n\t\t\t       \"asynchronous transfers\\n\",\n\t\t\t       ahc_name(ahc), devinfo->target);\n\t\t}\n\t}\n\n\tif ((type & AHC_TRANS_GOAL) != 0) {\n\t\ttinfo->goal.period = period;\n\t\ttinfo->goal.offset = offset;\n\t}\n\n\tif ((type & AHC_TRANS_USER) != 0) {\n\t\ttinfo->user.period = period;\n\t\ttinfo->user.offset = offset;\n\t}\n\n\tahc_update_target_msg_request(ahc, devinfo, tinfo,\n\t\t\t\t      /*force*/FALSE,\n\t\t\t\t      paused);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_set_width",
          "args": [
            "ahc",
            "devinfo",
            "bus_width",
            "AHC_TRANS_ACTIVE|AHC_TRANS_GOAL",
            "/*paused*/TRUE",
            "/*done*/TRUE"
          ],
          "line": 3173
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_set_width",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "1408-1457",
          "snippet": "STATIC void\nahc_set_width(ahc, devinfo, width, type, paused, done)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n\tu_int width;\n\tu_int type;\n\tint paused;\n\tint done;\n{\n\tstruct ahc_initiator_tinfo *tinfo;\n\tstruct tmode_tstate *tstate;\n\tu_int  oldwidth;\n\tint    active = (type & AHC_TRANS_ACTIVE) == AHC_TRANS_ACTIVE;\n\n\ttinfo = ahc_fetch_transinfo(ahc, devinfo->channel,\n\t\t\t\t    devinfo->our_scsiid,\n\t\t\t\t    devinfo->target,\n\t\t\t\t    &tstate);\n\toldwidth = tinfo->current.width;\n\n\tif ((type & AHC_TRANS_CUR) != 0 && oldwidth != width) {\n\t\tu_int\tscsirate;\n\n\t\tscsirate =  tinfo->scsirate;\n\t\tscsirate &= ~WIDEXFER;\n\t\tif (width == MSG_EXT_WDTR_BUS_16_BIT)\n\t\t\tscsirate |= WIDEXFER;\n\n\t\ttinfo->scsirate = scsirate;\n\n\t\tif (active)\n\t\t\tahc_outb(ahc, SCSIRATE, scsirate);\n\n\t\ttinfo->current.width = width;\n\t}\n\n\tif (done) {\n\t\tprintf(\"%s: target %d using %dbit transfers\\n\",\n\t\t       ahc_name(ahc), devinfo->target,\n\t\t       8 * (0x01 << width));\n\t}\n\n\tif ((type & AHC_TRANS_GOAL) != 0)\n\t\ttinfo->goal.width = width;\n\tif ((type & AHC_TRANS_USER) != 0)\n\t\ttinfo->user.width = width;\n\n\tahc_update_target_msg_request(ahc, devinfo, tinfo,\n\t\t\t\t      /*force*/FALSE, paused);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC int",
            "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "ahc_update_target_msg_request __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t\t      struct ahc_initiator_tinfo *tinfo,\n\t\t\t\t\t      int force, int paused));",
            "STATIC void",
            "ahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));",
            "STATIC void",
            "ahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "static __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct tmode_tstate **tstate;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nahc_update_target_msg_request __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t\t      struct ahc_initiator_tinfo *tinfo,\n\t\t\t\t\t      int force, int paused));\nSTATIC void;\nahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));\nSTATIC void;\nahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct tmode_tstate **tstate;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_set_width(ahc, devinfo, width, type, paused, done)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n\tu_int width;\n\tu_int type;\n\tint paused;\n\tint done;\n{\n\tstruct ahc_initiator_tinfo *tinfo;\n\tstruct tmode_tstate *tstate;\n\tu_int  oldwidth;\n\tint    active = (type & AHC_TRANS_ACTIVE) == AHC_TRANS_ACTIVE;\n\n\ttinfo = ahc_fetch_transinfo(ahc, devinfo->channel,\n\t\t\t\t    devinfo->our_scsiid,\n\t\t\t\t    devinfo->target,\n\t\t\t\t    &tstate);\n\toldwidth = tinfo->current.width;\n\n\tif ((type & AHC_TRANS_CUR) != 0 && oldwidth != width) {\n\t\tu_int\tscsirate;\n\n\t\tscsirate =  tinfo->scsirate;\n\t\tscsirate &= ~WIDEXFER;\n\t\tif (width == MSG_EXT_WDTR_BUS_16_BIT)\n\t\t\tscsirate |= WIDEXFER;\n\n\t\ttinfo->scsirate = scsirate;\n\n\t\tif (active)\n\t\t\tahc_outb(ahc, SCSIRATE, scsirate);\n\n\t\ttinfo->current.width = width;\n\t}\n\n\tif (done) {\n\t\tprintf(\"%s: target %d using %dbit transfers\\n\",\n\t\t       ahc_name(ahc), devinfo->target,\n\t\t       8 * (0x01 << width));\n\t}\n\n\tif ((type & AHC_TRANS_GOAL) != 0)\n\t\ttinfo->goal.width = width;\n\tif ((type & AHC_TRANS_USER) != 0)\n\t\ttinfo->user.width = width;\n\n\tahc_update_target_msg_request(ahc, devinfo, tinfo,\n\t\t\t\t      /*force*/FALSE, paused);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_construct_wdtr",
          "args": [
            "ahc",
            "bus_width"
          ],
          "line": 3168
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_construct_wdtr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "5565-5575",
          "snippet": "STATIC void\nahc_construct_wdtr(ahc, bus_width)\n\tstruct ahc_softc *ahc;\n\tu_int bus_width;\n{\n\tahc->msgout_buf[ahc->msgout_index++] = MSG_EXTENDED;\n\tahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_WDTR_LEN;\n\tahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_WDTR;\n\tahc->msgout_buf[ahc->msgout_index++] = bus_width;\n\tahc->msgout_len += 4;\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_construct_wdtr __P((struct ahc_softc *ahc, u_int bus_width));",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_construct_wdtr __P((struct ahc_softc *ahc, u_int bus_width));\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_construct_wdtr(ahc, bus_width)\n\tstruct ahc_softc *ahc;\n\tu_int bus_width;\n{\n\tahc->msgout_buf[ahc->msgout_index++] = MSG_EXTENDED;\n\tahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_WDTR_LEN;\n\tahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_WDTR;\n\tahc->msgout_buf[ahc->msgout_index++] = bus_width;\n\tahc->msgout_len += 4;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Sending WDTR!\\n\""
          ],
          "line": 3152
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 3138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_sent_msg",
          "args": [
            "ahc",
            "MSG_EXT_WDTR",
            "/*full*/TRUE"
          ],
          "line": 3123
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_sent_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "2945-2984",
          "snippet": "STATIC int\nahc_sent_msg(ahc, msgtype, full)\n\tstruct ahc_softc *ahc;\n\tu_int msgtype;\n\tint full;\n{\n\tint found;\n\tint index;\n\n\tfound = FALSE;\n\tindex = 0;\n\n\twhile (index < ahc->msgout_len) {\n\t\tif (ahc->msgout_buf[index] == MSG_EXTENDED) {\n\n\t\t\t/* Found a candidate */\n\t\t\tif (ahc->msgout_buf[index+2] == msgtype) {\n\t\t\t\tu_int end_index;\n\n\t\t\t\tend_index = index + 1\n\t\t\t\t\t  + ahc->msgout_buf[index + 1];\n\t\t\t\tif (full) {\n\t\t\t\t\tif (ahc->msgout_index > end_index)\n\t\t\t\t\t\tfound = TRUE;\n\t\t\t\t} else if (ahc->msgout_index > index)\n\t\t\t\t\tfound = TRUE;\n\t\t\t}\n\t\t\tbreak;\n\t\t} else if (ahc->msgout_buf[index] >= MSG_SIMPLE_Q_TAG\n\t\t\t&& ahc->msgout_buf[index] <= MSG_IGN_WIDE_RESIDUE) {\n\n\t\t\t/* Skip tag type and tag id or residue param*/\n\t\t\tindex += 2;\n\t\t} else {\n\t\t\t/* Single byte message */\n\t\t\tindex++;\n\t\t}\n\t}\n\treturn (found);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "ahc_sent_msg __P((struct ahc_softc *ahc, u_int msgtype,\n\t\t\t\t  int full));",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nahc_sent_msg __P((struct ahc_softc *ahc, u_int msgtype,\n\t\t\t\t  int full));\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC int\nahc_sent_msg(ahc, msgtype, full)\n\tstruct ahc_softc *ahc;\n\tu_int msgtype;\n\tint full;\n{\n\tint found;\n\tint index;\n\n\tfound = FALSE;\n\tindex = 0;\n\n\twhile (index < ahc->msgout_len) {\n\t\tif (ahc->msgout_buf[index] == MSG_EXTENDED) {\n\n\t\t\t/* Found a candidate */\n\t\t\tif (ahc->msgout_buf[index+2] == msgtype) {\n\t\t\t\tu_int end_index;\n\n\t\t\t\tend_index = index + 1\n\t\t\t\t\t  + ahc->msgout_buf[index + 1];\n\t\t\t\tif (full) {\n\t\t\t\t\tif (ahc->msgout_index > end_index)\n\t\t\t\t\t\tfound = TRUE;\n\t\t\t\t} else if (ahc->msgout_index > index)\n\t\t\t\t\tfound = TRUE;\n\t\t\t}\n\t\t\tbreak;\n\t\t} else if (ahc->msgout_buf[index] >= MSG_SIMPLE_Q_TAG\n\t\t\t&& ahc->msgout_buf[index] <= MSG_IGN_WIDE_RESIDUE) {\n\n\t\t\t/* Skip tag type and tag id or residue param*/\n\t\t\tindex += 2;\n\t\t} else {\n\t\t\t/* Single byte message */\n\t\t\tindex++;\n\t\t}\n\t}\n\treturn (found);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_devlimited_syncrate",
          "args": [
            "ahc",
            "&period"
          ],
          "line": 3067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_handle_ign_wide_residue",
          "args": [
            "ahc",
            "devinfo"
          ],
          "line": 3033
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_handle_ign_wide_residue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "3277-3363",
          "snippet": "STATIC void\nahc_handle_ign_wide_residue(ahc, devinfo)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n{\n\tu_int scb_index;\n\tstruct scb *scb;\n\n\tscb_index = ahc_inb(ahc, SCB_TAG);\n\tscb = &ahc->scb_data->scbarray[scb_index];\n\tif ((ahc_inb(ahc, SEQ_FLAGS) & DPHASE) == 0\n\t || !(scb->xs->flags & SCSI_DATA_IN)) {\n\t\t/*\n\t\t * Ignore the message if we haven't\n\t\t * seen an appropriate data phase yet.\n\t\t */\n\t} else {\n\t\t/*\n\t\t * If the residual occurred on the last\n\t\t * transfer and the transfer request was\n\t\t * expected to end on an odd count, do\n\t\t * nothing.  Otherwise, subtract a byte\n\t\t * and update the residual count accordingly.\n\t\t */\n\t\tu_int resid_sgcnt;\n\n\t\tresid_sgcnt = ahc_inb(ahc, SCB_RESID_SGCNT);\n\t\tif (resid_sgcnt == 0\n\t\t && ahc_inb(ahc, DATA_COUNT_ODD) == 1) {\n\t\t\t/*\n\t\t\t * If the residual occurred on the last\n\t\t\t * transfer and the transfer request was\n\t\t\t * expected to end on an odd count, do\n\t\t\t * nothing.\n\t\t\t */\n\t\t} else {\n\t\t\tu_int data_cnt;\n\t\t\tu_int data_addr;\n\t\t\tu_int sg_index;\n\n\t\t\tdata_cnt = (ahc_inb(ahc, SCB_RESID_DCNT + 2) << 16)\n\t\t\t\t | (ahc_inb(ahc, SCB_RESID_DCNT + 1) << 8)\n\t\t\t\t | (ahc_inb(ahc, SCB_RESID_DCNT));\n\n\t\t\tdata_addr = (ahc_inb(ahc, SHADDR + 3) << 24)\n\t\t\t\t  | (ahc_inb(ahc, SHADDR + 2) << 16)\n\t\t\t\t  | (ahc_inb(ahc, SHADDR + 1) << 8)\n\t\t\t\t  | (ahc_inb(ahc, SHADDR));\n\n\t\t\tdata_cnt += 1;\n\t\t\tdata_addr -= 1;\n\n\t\t\tsg_index = scb->sg_count - resid_sgcnt;\n\n\t\t\tif (sg_index != 0\n\t\t\t && (scb->sg_list[sg_index].len < data_cnt)) {\n\t\t\t\tu_int sg_addr;\n\n\t\t\t\tsg_index--;\n\t\t\t\tdata_cnt = 1;\n\t\t\t\tdata_addr = scb->sg_list[sg_index].addr\n\t\t\t\t\t  + scb->sg_list[sg_index].len - 1;\n\t\t\t\t\n\t\t\t\t/*\n\t\t\t\t * The physical address base points to the\n\t\t\t\t * second entry as it is always used for\n\t\t\t\t * calculating the \"next S/G pointer\".\n\t\t\t\t */\n\t\t\t\tsg_addr = scb->sg_list_phys\n\t\t\t\t\t+ (sg_index* sizeof(*scb->sg_list));\n\t\t\t\tahc_outb(ahc, SG_NEXT + 3, sg_addr >> 24);\n\t\t\t\tahc_outb(ahc, SG_NEXT + 2, sg_addr >> 16);\n\t\t\t\tahc_outb(ahc, SG_NEXT + 1, sg_addr >> 8);\n\t\t\t\tahc_outb(ahc, SG_NEXT, sg_addr);\n\t\t\t}\n\n\t\t\tahc_outb(ahc, SCB_RESID_DCNT + 2, data_cnt >> 16);\n\t\t\tahc_outb(ahc, SCB_RESID_DCNT + 1, data_cnt >> 8);\n\t\t\tahc_outb(ahc, SCB_RESID_DCNT, data_cnt);\n\n\t\t\tahc_outb(ahc, SHADDR + 3, data_addr >> 24);\n\t\t\tahc_outb(ahc, SHADDR + 2, data_addr >> 16);\n\t\t\tahc_outb(ahc, SHADDR + 1, data_addr >> 8);\n\t\t\tahc_outb(ahc, SHADDR, data_addr);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
            "STATIC void",
            "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC int",
            "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
            "STATIC void",
            "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_calc_residual __P((struct scb *scb));",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *xs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nSTATIC void;\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_calc_residual __P((struct scb *scb));\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n\nSTATIC void\nahc_handle_ign_wide_residue(ahc, devinfo)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n{\n\tu_int scb_index;\n\tstruct scb *scb;\n\n\tscb_index = ahc_inb(ahc, SCB_TAG);\n\tscb = &ahc->scb_data->scbarray[scb_index];\n\tif ((ahc_inb(ahc, SEQ_FLAGS) & DPHASE) == 0\n\t || !(scb->xs->flags & SCSI_DATA_IN)) {\n\t\t/*\n\t\t * Ignore the message if we haven't\n\t\t * seen an appropriate data phase yet.\n\t\t */\n\t} else {\n\t\t/*\n\t\t * If the residual occurred on the last\n\t\t * transfer and the transfer request was\n\t\t * expected to end on an odd count, do\n\t\t * nothing.  Otherwise, subtract a byte\n\t\t * and update the residual count accordingly.\n\t\t */\n\t\tu_int resid_sgcnt;\n\n\t\tresid_sgcnt = ahc_inb(ahc, SCB_RESID_SGCNT);\n\t\tif (resid_sgcnt == 0\n\t\t && ahc_inb(ahc, DATA_COUNT_ODD) == 1) {\n\t\t\t/*\n\t\t\t * If the residual occurred on the last\n\t\t\t * transfer and the transfer request was\n\t\t\t * expected to end on an odd count, do\n\t\t\t * nothing.\n\t\t\t */\n\t\t} else {\n\t\t\tu_int data_cnt;\n\t\t\tu_int data_addr;\n\t\t\tu_int sg_index;\n\n\t\t\tdata_cnt = (ahc_inb(ahc, SCB_RESID_DCNT + 2) << 16)\n\t\t\t\t | (ahc_inb(ahc, SCB_RESID_DCNT + 1) << 8)\n\t\t\t\t | (ahc_inb(ahc, SCB_RESID_DCNT));\n\n\t\t\tdata_addr = (ahc_inb(ahc, SHADDR + 3) << 24)\n\t\t\t\t  | (ahc_inb(ahc, SHADDR + 2) << 16)\n\t\t\t\t  | (ahc_inb(ahc, SHADDR + 1) << 8)\n\t\t\t\t  | (ahc_inb(ahc, SHADDR));\n\n\t\t\tdata_cnt += 1;\n\t\t\tdata_addr -= 1;\n\n\t\t\tsg_index = scb->sg_count - resid_sgcnt;\n\n\t\t\tif (sg_index != 0\n\t\t\t && (scb->sg_list[sg_index].len < data_cnt)) {\n\t\t\t\tu_int sg_addr;\n\n\t\t\t\tsg_index--;\n\t\t\t\tdata_cnt = 1;\n\t\t\t\tdata_addr = scb->sg_list[sg_index].addr\n\t\t\t\t\t  + scb->sg_list[sg_index].len - 1;\n\t\t\t\t\n\t\t\t\t/*\n\t\t\t\t * The physical address base points to the\n\t\t\t\t * second entry as it is always used for\n\t\t\t\t * calculating the \"next S/G pointer\".\n\t\t\t\t */\n\t\t\t\tsg_addr = scb->sg_list_phys\n\t\t\t\t\t+ (sg_index* sizeof(*scb->sg_list));\n\t\t\t\tahc_outb(ahc, SG_NEXT + 3, sg_addr >> 24);\n\t\t\t\tahc_outb(ahc, SG_NEXT + 2, sg_addr >> 16);\n\t\t\t\tahc_outb(ahc, SG_NEXT + 1, sg_addr >> 8);\n\t\t\t\tahc_outb(ahc, SG_NEXT, sg_addr);\n\t\t\t}\n\n\t\t\tahc_outb(ahc, SCB_RESID_DCNT + 2, data_cnt >> 16);\n\t\t\tahc_outb(ahc, SCB_RESID_DCNT + 1, data_cnt >> 8);\n\t\t\tahc_outb(ahc, SCB_RESID_DCNT, data_cnt);\n\n\t\t\tahc_outb(ahc, SHADDR + 3, data_addr >> 24);\n\t\t\tahc_outb(ahc, SHADDR + 2, data_addr >> 16);\n\t\t\tahc_outb(ahc, SHADDR + 1, data_addr >> 8);\n\t\t\tahc_outb(ahc, SHADDR, data_addr);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_handle_msg_reject",
          "args": [
            "ahc",
            "devinfo"
          ],
          "line": 3019
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_handle_msg_reject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "2573-2678",
          "snippet": "STATIC int\nahc_handle_msg_reject(ahc, devinfo)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n{\n\t/*\n\t * What we care about here is if we had an\n\t * outstanding SDTR or WDTR message for this\n\t * target.  If we did, this is a signal that\n\t * the target is refusing negotiation.\n\t */\n\tstruct scb *scb;\n\tu_int scb_index;\n\tu_int last_msg;\n\tint   response = 0;\n\n\tscb_index = ahc_inb(ahc, SCB_TAG);\n\tscb = &ahc->scb_data->scbarray[scb_index];\n\n\t/* Might be necessary */\n\tlast_msg = ahc_inb(ahc, LAST_MSG);\n\n\tif (ahc_sent_msg(ahc, MSG_EXT_WDTR, /*full*/FALSE)) {\n\t\tstruct ahc_initiator_tinfo *tinfo;\n\t\tstruct tmode_tstate *tstate;\n\n\t\t/* note 8bit xfers */\n\t\tif (bootverbose)\n\t\t\tprintf(\"%s:%c:%d: refuses WIDE negotiation.  Using \"\n\t\t\t       \"8bit transfers\\n\", ahc_name(ahc),\n\t\t\t       devinfo->channel, devinfo->target);\n\t\tahc_set_width(ahc, devinfo,\n\t\t\t      MSG_EXT_WDTR_BUS_8_BIT,\n\t\t\t      AHC_TRANS_ACTIVE|AHC_TRANS_GOAL,\n\t\t\t      /*paused*/TRUE, /*done*/TRUE);\n\t\t/*\n\t\t * No need to clear the sync rate.  If the target\n\t\t * did not accept the command, our syncrate is\n\t\t * unaffected.  If the target started the negotiation,\n\t\t * but rejected our response, we already cleared the\n\t\t * sync rate before sending our WDTR.\n\t\t */\n\t\ttinfo = ahc_fetch_transinfo(ahc, devinfo->channel,\n\t\t\t\t\t    devinfo->our_scsiid,\n\t\t\t\t\t    devinfo->target, &tstate);\n\t\tif (tinfo->goal.period) {\n\t\t\tu_int period;\n\n\t\t\t/* Start the sync negotiation */\n\t\t\tperiod = tinfo->goal.period;\n\t\t\tahc_devlimited_syncrate(ahc, &period);\n\t\t\tahc->msgout_index = 0;\n\t\t\tahc->msgout_len = 0;\n\t\t\tahc_construct_sdtr(ahc, period, tinfo->goal.offset);\n\t\t\tahc->msgout_index = 0;\n\t\t\tresponse = 1;\n\t\t}\n\t} else if (ahc_sent_msg(ahc, MSG_EXT_SDTR, /*full*/FALSE)) {\n\t\t/* note asynch xfers and clear flag */\n\t\tahc_set_syncrate(ahc, devinfo, /*syncrate*/NULL, /*period*/0,\n\t\t\t\t /*offset*/0,\n\t\t\t\t AHC_TRANS_ACTIVE|AHC_TRANS_GOAL,\n\t\t\t\t /*paused*/TRUE,\n\t\t\t\t /*done*/TRUE);\n\t\tif (bootverbose)\n\t\t\tprintf(\"%s:%c:%d: refuses synchronous negotiation. \"\n\t\t\t       \"Using asynchronous transfers\\n\",\n\t\t\t       ahc_name(ahc),\n\t\t\t       devinfo->channel, devinfo->target);\n\t} else if ((scb->hscb->control & MSG_SIMPLE_Q_TAG) != 0) {\n\t\tif (bootverbose)\n\t\t\tprintf(\"%s:%c:%d: refuses tagged commands.  Performing \"\n\t\t\t       \"non-tagged I/O\\n\", ahc_name(ahc),\n\t\t\t       devinfo->channel, devinfo->target);\n\t\t\t\n\t\tahc_set_tags(ahc, devinfo, FALSE);\n\n\t\t/*\n\t\t * Resend the identify for this CCB as the target\n\t\t * may believe that the selection is invalid otherwise.\n\t\t */\n\t\tahc_outb(ahc, SCB_CONTROL, ahc_inb(ahc, SCB_CONTROL)\n\t\t\t\t\t  & ~MSG_SIMPLE_Q_TAG);\n\t \tscb->hscb->control &= ~MSG_SIMPLE_Q_TAG;\n\t\tahc_outb(ahc, MSG_OUT, MSG_IDENTIFYFLAG);\n\t\tahc_outb(ahc, SCSISIGO, ahc_inb(ahc, SCSISIGO) | ATNO);\n\n\t\t/*\n\t\t * Requeue all tagged commands for this target\n\t\t * currently in our posession so they can be\n\t\t * converted to untagged commands.\n\t\t */\n\t\tahc_search_qinfifo(ahc, SCB_TARGET(scb), SCB_CHANNEL(scb),\n\t\t\t\t   SCB_LUN(scb), /*tag*/SCB_LIST_NULL,\n\t\t\t\t   ROLE_INITIATOR, SCB_REQUEUE,\n\t\t\t\t   SEARCH_COMPLETE);\n\t} else {\n\t\t/*\n\t\t * Otherwise, we ignore it.\n\t\t */\n\t\tprintf(\"%s:%c:%d: Message reject for %x -- ignored\\n\",\n\t\t       ahc_name(ahc), devinfo->channel, devinfo->target,\n\t\t       last_msg);\n\t}\n\treturn (response);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define bootverbose\t0",
            "#define STATIC",
            "#define bootverbose\t1"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
            "STATIC void",
            "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC int",
            "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "ahc_sent_msg __P((struct ahc_softc *ahc, u_int msgtype,\n\t\t\t\t  int full));",
            "STATIC int",
            "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "ahc_update_target_msg_request __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t\t      struct ahc_initiator_tinfo *tinfo,\n\t\t\t\t\t      int force, int paused));",
            "STATIC void",
            "ahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));",
            "STATIC void",
            "ahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));",
            "STATIC void",
            "STATIC void",
            "ahc_calc_residual __P((struct scb *scb));",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "static __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo",
            "STATIC void",
            "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct tmode_tstate **tstate;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "u_int *period;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "u_int *period;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define bootverbose\t0\n#define STATIC\n#define bootverbose\t1\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nahc_sent_msg __P((struct ahc_softc *ahc, u_int msgtype,\n\t\t\t\t  int full));\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nahc_update_target_msg_request __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t\t      struct ahc_initiator_tinfo *tinfo,\n\t\t\t\t\t      int force, int paused));\nSTATIC void;\nahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));\nSTATIC void;\nahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));\nSTATIC void;\nSTATIC void;\nahc_calc_residual __P((struct scb *scb));\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo;\nSTATIC void;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct tmode_tstate **tstate;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC int\nahc_handle_msg_reject(ahc, devinfo)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n{\n\t/*\n\t * What we care about here is if we had an\n\t * outstanding SDTR or WDTR message for this\n\t * target.  If we did, this is a signal that\n\t * the target is refusing negotiation.\n\t */\n\tstruct scb *scb;\n\tu_int scb_index;\n\tu_int last_msg;\n\tint   response = 0;\n\n\tscb_index = ahc_inb(ahc, SCB_TAG);\n\tscb = &ahc->scb_data->scbarray[scb_index];\n\n\t/* Might be necessary */\n\tlast_msg = ahc_inb(ahc, LAST_MSG);\n\n\tif (ahc_sent_msg(ahc, MSG_EXT_WDTR, /*full*/FALSE)) {\n\t\tstruct ahc_initiator_tinfo *tinfo;\n\t\tstruct tmode_tstate *tstate;\n\n\t\t/* note 8bit xfers */\n\t\tif (bootverbose)\n\t\t\tprintf(\"%s:%c:%d: refuses WIDE negotiation.  Using \"\n\t\t\t       \"8bit transfers\\n\", ahc_name(ahc),\n\t\t\t       devinfo->channel, devinfo->target);\n\t\tahc_set_width(ahc, devinfo,\n\t\t\t      MSG_EXT_WDTR_BUS_8_BIT,\n\t\t\t      AHC_TRANS_ACTIVE|AHC_TRANS_GOAL,\n\t\t\t      /*paused*/TRUE, /*done*/TRUE);\n\t\t/*\n\t\t * No need to clear the sync rate.  If the target\n\t\t * did not accept the command, our syncrate is\n\t\t * unaffected.  If the target started the negotiation,\n\t\t * but rejected our response, we already cleared the\n\t\t * sync rate before sending our WDTR.\n\t\t */\n\t\ttinfo = ahc_fetch_transinfo(ahc, devinfo->channel,\n\t\t\t\t\t    devinfo->our_scsiid,\n\t\t\t\t\t    devinfo->target, &tstate);\n\t\tif (tinfo->goal.period) {\n\t\t\tu_int period;\n\n\t\t\t/* Start the sync negotiation */\n\t\t\tperiod = tinfo->goal.period;\n\t\t\tahc_devlimited_syncrate(ahc, &period);\n\t\t\tahc->msgout_index = 0;\n\t\t\tahc->msgout_len = 0;\n\t\t\tahc_construct_sdtr(ahc, period, tinfo->goal.offset);\n\t\t\tahc->msgout_index = 0;\n\t\t\tresponse = 1;\n\t\t}\n\t} else if (ahc_sent_msg(ahc, MSG_EXT_SDTR, /*full*/FALSE)) {\n\t\t/* note asynch xfers and clear flag */\n\t\tahc_set_syncrate(ahc, devinfo, /*syncrate*/NULL, /*period*/0,\n\t\t\t\t /*offset*/0,\n\t\t\t\t AHC_TRANS_ACTIVE|AHC_TRANS_GOAL,\n\t\t\t\t /*paused*/TRUE,\n\t\t\t\t /*done*/TRUE);\n\t\tif (bootverbose)\n\t\t\tprintf(\"%s:%c:%d: refuses synchronous negotiation. \"\n\t\t\t       \"Using asynchronous transfers\\n\",\n\t\t\t       ahc_name(ahc),\n\t\t\t       devinfo->channel, devinfo->target);\n\t} else if ((scb->hscb->control & MSG_SIMPLE_Q_TAG) != 0) {\n\t\tif (bootverbose)\n\t\t\tprintf(\"%s:%c:%d: refuses tagged commands.  Performing \"\n\t\t\t       \"non-tagged I/O\\n\", ahc_name(ahc),\n\t\t\t       devinfo->channel, devinfo->target);\n\t\t\t\n\t\tahc_set_tags(ahc, devinfo, FALSE);\n\n\t\t/*\n\t\t * Resend the identify for this CCB as the target\n\t\t * may believe that the selection is invalid otherwise.\n\t\t */\n\t\tahc_outb(ahc, SCB_CONTROL, ahc_inb(ahc, SCB_CONTROL)\n\t\t\t\t\t  & ~MSG_SIMPLE_Q_TAG);\n\t \tscb->hscb->control &= ~MSG_SIMPLE_Q_TAG;\n\t\tahc_outb(ahc, MSG_OUT, MSG_IDENTIFYFLAG);\n\t\tahc_outb(ahc, SCSISIGO, ahc_inb(ahc, SCSISIGO) | ATNO);\n\n\t\t/*\n\t\t * Requeue all tagged commands for this target\n\t\t * currently in our posession so they can be\n\t\t * converted to untagged commands.\n\t\t */\n\t\tahc_search_qinfifo(ahc, SCB_TARGET(scb), SCB_CHANNEL(scb),\n\t\t\t\t   SCB_LUN(scb), /*tag*/SCB_LIST_NULL,\n\t\t\t\t   ROLE_INITIATOR, SCB_REQUEUE,\n\t\t\t\t   SEARCH_COMPLETE);\n\t} else {\n\t\t/*\n\t\t * Otherwise, we ignore it.\n\t\t */\n\t\tprintf(\"%s:%c:%d: Message reject for %x -- ignored\\n\",\n\t\t       ahc_name(ahc), devinfo->channel, devinfo->target,\n\t\t       last_msg);\n\t}\n\treturn (response);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_fetch_transinfo",
          "args": [
            "ahc",
            "devinfo->channel",
            "devinfo->our_scsiid",
            "devinfo->target",
            "&tstate"
          ],
          "line": 3002
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define bootverbose\t0\n#define STATIC\n#define bootverbose\t1\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nahc_shutdown __P((void *arg));\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));\nSTATIC int;\nahc_sent_msg __P((struct ahc_softc *ahc, u_int msgtype,\n\t\t\t\t  int full));\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_devreset __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct ahc_devinfo *devinfo,\n\t\t\t\t\t int status, char *message,\n\t\t\t\t\t int verbose_level));\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nahc_validate_offset __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct ahc_syncrate *syncrate,\n\t\t\t\t\t u_int *offset, int wide));\nSTATIC void;\nahc_update_target_msg_request __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t\t      struct ahc_initiator_tinfo *tinfo,\n\t\t\t\t\t      int force, int paused));\nSTATIC void;\nahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));\nSTATIC void;\nahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));\nSTATIC void;\nahc_construct_wdtr __P((struct ahc_softc *ahc, u_int bus_width));\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct tmode_tstate **tstate;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC int\nahc_parse_msg(ahc, sc_link, devinfo)\n\tstruct ahc_softc *ahc;\n\tstruct scsi_link *sc_link;\n\tstruct ahc_devinfo *devinfo;\n{\n\tstruct\tahc_initiator_tinfo *tinfo;\n\tstruct\ttmode_tstate *tstate;\n\tint\treject;\n\tint\tdone;\n\tint\tresponse;\n\tu_int\ttarg_scsirate;\n\n\tdone = MSGLOOP_IN_PROG;\n\tresponse = FALSE;\n\treject = FALSE;\n\ttinfo = ahc_fetch_transinfo(ahc, devinfo->channel, devinfo->our_scsiid,\n\t\t\t\t    devinfo->target, &tstate);\n\ttarg_scsirate = tinfo->scsirate;\n\n\t/*\n\t * Parse as much of the message as is availible,\n\t * rejecting it if we don't support it.  When\n\t * the entire message is availible and has been\n\t * handled, return MSGLOOP_MSGCOMPLETE, indicating\n\t * that we have parsed an entire message.\n\t *\n\t * In the case of extended messages, we accept the length\n\t * byte outright and perform more checking once we know the\n\t * extended message type.\n\t */\n\tswitch (ahc->msgin_buf[0]) {\n\tcase MSG_MESSAGE_REJECT:\n\t\tresponse = ahc_handle_msg_reject(ahc, devinfo);\n\t\t/* FALLTHROUGH */\n\tcase MSG_NOOP:\n\t\tdone = MSGLOOP_MSGCOMPLETE;\n\t\tbreak;\n\tcase MSG_IGN_WIDE_RESIDUE:\n\t{\n\t\t/* Wait for the whole message */\n\t\tif (ahc->msgin_index >= 1) {\n\t\t\tif (ahc->msgin_buf[1] != 1\n\t\t\t || tinfo->current.width == MSG_EXT_WDTR_BUS_8_BIT) {\n\t\t\t\treject = TRUE;\n\t\t\t\tdone = MSGLOOP_MSGCOMPLETE;\n\t\t\t} else\n\t\t\t\tahc_handle_ign_wide_residue(ahc, devinfo);\n\t\t}\n\t\tbreak;\n\t}\n\tcase MSG_EXTENDED:\n\t{\n\t\t/* Wait for enough of the message to begin validation */\n\t\tif (ahc->msgin_index < 2)\n\t\t\tbreak;\n\t\tswitch (ahc->msgin_buf[2]) {\n\t\tcase MSG_EXT_SDTR:\n\t\t{\n\t\t\tstruct\t ahc_syncrate *syncrate;\n\t\t\tu_int\t period;\n\t\t\tu_int\t offset;\n\t\t\tu_int\t saved_offset;\n\t\t\t\n\t\t\tif (ahc->msgin_buf[1] != MSG_EXT_SDTR_LEN) {\n\t\t\t\treject = TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Wait until we have both args before validating\n\t\t\t * and acting on this message.\n\t\t\t *\n\t\t\t * Add one to MSG_EXT_SDTR_LEN to account for\n\t\t\t * the extended message preamble.\n\t\t\t */\n\t\t\tif (ahc->msgin_index < (MSG_EXT_SDTR_LEN + 1))\n\t\t\t\tbreak;\n\n\t\t\tperiod = ahc->msgin_buf[3];\n\t\t\tsaved_offset = offset = ahc->msgin_buf[4];\n\t\t\tsyncrate = ahc_devlimited_syncrate(ahc, &period);\n\t\t\tahc_validate_offset(ahc, syncrate, &offset,\n\t\t\t\t\t    targ_scsirate & WIDEXFER);\n\t\t\tahc_set_syncrate(ahc, devinfo,\n\t\t\t\t\t syncrate, period, offset,\n\t\t\t\t\t AHC_TRANS_ACTIVE|AHC_TRANS_GOAL,\n\t\t\t\t\t /*paused*/TRUE, /*done*/TRUE);\n\n\t\t\t/*\n\t\t\t * See if we initiated Sync Negotiation\n\t\t\t * and didn't have to fall down to async\n\t\t\t * transfers.\n\t\t\t */\n\t\t\tif (ahc_sent_msg(ahc, MSG_EXT_SDTR, /*full*/TRUE)) {\n\t\t\t\t/* We started it */\n\t\t\t\tif (saved_offset != offset) {\n\t\t\t\t\t/* Went too low - force async */\n\t\t\t\t\treject = TRUE;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Send our own SDTR in reply\n\t\t\t\t */\n\t\t\t\tif (bootverbose)\n\t\t\t\t\tprintf(\"Sending SDTR!\\n\");\n\t\t\t\tahc->msgout_index = 0;\n\t\t\t\tahc->msgout_len = 0;\n\t\t\t\tahc_construct_sdtr(ahc, period, offset);\n\t\t\t\tahc->msgout_index = 0;\n\t\t\t\tresponse = TRUE;\n\t\t\t}\n\t\t\tdone = MSGLOOP_MSGCOMPLETE;\n\t\t\tbreak;\n\t\t}\n\t\tcase MSG_EXT_WDTR:\n\t\t{\n\t\t\tu_int\tbus_width;\n\t\t\tu_int\tsending_reply;\n\n\t\t\tsending_reply = FALSE;\n\t\t\tif (ahc->msgin_buf[1] != MSG_EXT_WDTR_LEN) {\n\t\t\t\treject = TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Wait until we have our arg before validating\n\t\t\t * and acting on this message.\n\t\t\t *\n\t\t\t * Add one to MSG_EXT_WDTR_LEN to account for\n\t\t\t * the extended message preamble.\n\t\t\t */\n\t\t\tif (ahc->msgin_index < (MSG_EXT_WDTR_LEN + 1))\n\t\t\t\tbreak;\n\n\t\t\tbus_width = ahc->msgin_buf[3];\n\t\t\tif (ahc_sent_msg(ahc, MSG_EXT_WDTR, /*full*/TRUE)) {\n\t\t\t\t/*\n\t\t\t\t * Don't send a WDTR back to the\n\t\t\t\t * target, since we asked first.\n\t\t\t\t */\n\t\t\t\tswitch (bus_width){\n\t\t\t\tdefault:\n\t\t\t\t\t/*\n\t\t\t\t\t * How can we do anything greater\n\t\t\t\t\t * than 16bit transfers on a 16bit\n\t\t\t\t\t * bus?\n\t\t\t\t\t */\n\t\t\t\t\treject = TRUE;\n\t\t\t\t\tprintf(\"%s: target %d requested %dBit \"\n\t\t\t\t\t       \"transfers.  Rejecting...\\n\",\n\t\t\t\t\t       ahc_name(ahc), devinfo->target,\n\t\t\t\t\t       8 * (0x01 << bus_width));\n\t\t\t\t\t/* FALLTHROUGH */\n\t\t\t\tcase MSG_EXT_WDTR_BUS_8_BIT:\n\t\t\t\t\tbus_width = MSG_EXT_WDTR_BUS_8_BIT;\n\t\t\t\t\tbreak;\n\t\t\t\tcase MSG_EXT_WDTR_BUS_16_BIT:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Send our own WDTR in reply\n\t\t\t\t */\n\t\t\t\tif (bootverbose)\n\t\t\t\t\tprintf(\"Sending WDTR!\\n\");\n\t\t\t\tswitch (bus_width) {\n\t\t\t\tdefault:\n\t\t\t\t\tif (ahc->features & AHC_WIDE) {\n\t\t\t\t\t\t/* Respond Wide */\n\t\t\t\t\t\tbus_width =\n\t\t\t\t\t\t    MSG_EXT_WDTR_BUS_16_BIT;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t/* FALLTHROUGH */\n\t\t\t\tcase MSG_EXT_WDTR_BUS_8_BIT:\n\t\t\t\t\tbus_width = MSG_EXT_WDTR_BUS_8_BIT;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tahc->msgout_index = 0;\n\t\t\t\tahc->msgout_len = 0;\n\t\t\t\tahc_construct_wdtr(ahc, bus_width);\n\t\t\t\tahc->msgout_index = 0;\n\t\t\t\tresponse = TRUE;\n\t\t\t\tsending_reply = TRUE;\n\t\t\t}\n\t\t\tahc_set_width(ahc, devinfo, bus_width,\n\t\t\t\t      AHC_TRANS_ACTIVE|AHC_TRANS_GOAL,\n\t\t\t\t      /*paused*/TRUE, /*done*/TRUE);\n\n\t\t\t/* After a wide message, we are async */\n\t\t\tahc_set_syncrate(ahc, devinfo,\n\t\t\t\t\t /*syncrate*/NULL, /*period*/0,\n\t\t\t\t\t /*offset*/0, AHC_TRANS_ACTIVE,\n\t\t\t\t\t /*paused*/TRUE, /*done*/FALSE);\n\t\t\tif (sending_reply == FALSE && reject == FALSE) {\n\n\t\t\t\tif (tinfo->goal.period) {\n\t\t\t\t\tstruct\tahc_syncrate *rate;\n\t\t\t\t\tu_int\tperiod;\n\t\t\t\t\tu_int\toffset;\n\n\t\t\t\t\t/* Start the sync negotiation */\n\t\t\t\t\tperiod = tinfo->goal.period;\n\t\t\t\t\trate = ahc_devlimited_syncrate(ahc,\n\t\t\t\t\t\t\t\t       &period);\n\t\t\t\t\toffset = tinfo->goal.offset;\n\t\t\t\t\tahc_validate_offset(ahc, rate, &offset,\n\t\t\t\t\t\t\t  tinfo->current.width);\n\t\t\t\t\tahc->msgout_index = 0;\n\t\t\t\t\tahc->msgout_len = 0;\n\t\t\t\t\tahc_construct_sdtr(ahc, period, offset);\n\t\t\t\t\tahc->msgout_index = 0;\n\t\t\t\t\tresponse = TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdone = MSGLOOP_MSGCOMPLETE;\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\t/* Unknown extended message.  Reject it. */\n\t\t\treject = TRUE;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\tcase MSG_BUS_DEV_RESET:\n\t\tahc_handle_devreset(ahc, devinfo,\n\t\t\t\t    XS_RESET, \"Bus Device Reset Received\",\n\t\t\t\t    /*verbose_level*/0);\n\t\trestart_sequencer(ahc);\n\t\tdone = MSGLOOP_TERMINATED;\n\t\tbreak;\n\tcase MSG_ABORT_TAG:\n\tcase MSG_ABORT:\n\tcase MSG_CLEAR_QUEUE:\n\t\t/* Target mode messages */\n\t\tif (devinfo->role != ROLE_TARGET) {\n\t\t\treject = TRUE;\n\t\t\tbreak;\n\t\t}\n#if AHC_TARGET_MODE\n\t\tahc_abort_scbs(ahc, devinfo->target, devinfo->channel,\n\t\t\t       devinfo->lun,\n\t\t\t       ahc->msgin_buf[0] == MSG_ABORT_TAG ? SCB_LIST_NULL\n\t\t\t       : ahc_inb(ahc, INITIATOR_TAG),\n\t\t\t\tROLE_TARGET, XS_DRIVER_STUFFUP);\n\n\t\ttstate = ahc->enabled_targets[devinfo->our_scsiid];\n\t\tif (tstate != NULL) {\n\t\t\tstruct tmode_lstate* lstate;\n\n\t\t\tlstate = tstate->enabled_luns[devinfo->lun];\n\t\t\tif (lstate != NULL) {\n\t\t\t\tahc_queue_lstate_event(ahc, lstate,\n\t\t\t\t\t\t       devinfo->our_scsiid,\n\t\t\t\t\t\t       ahc->msgin_buf[0],\n\t\t\t\t\t\t       /*arg*/0);\n\t\t\t\tahc_send_lstate_events(ahc, lstate);\n\t\t\t}\n\t\t}\n\t\tdone = MSGLOOP_MSGCOMPLETE;\n#else\n\t\tpanic(\"ahc: got target mode message\");\n#endif\n\t\tbreak;\n\tcase MSG_TERM_IO_PROC:\n\tdefault:\n\t\treject = TRUE;\n\t\tbreak;\n\t}\n\n\tif (reject) {\n\t\t/*\n\t\t * Setup to reject the message.\n\t\t */\n\t\tahc->msgout_index = 0;\n\t\tahc->msgout_len = 1;\n\t\tahc->msgout_buf[0] = MSG_MESSAGE_REJECT;\n\t\tdone = MSGLOOP_MSGCOMPLETE;\n\t\tresponse = TRUE;\n\t}\n\n\tif (done != MSGLOOP_IN_PROG && !response)\n\t\t/* Clear the outgoing message buffer */\n\t\tahc->msgout_len = 0;\n\n\treturn (done);\n}"
  },
  {
    "function_name": "ahc_sent_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "2945-2984",
    "snippet": "STATIC int\nahc_sent_msg(ahc, msgtype, full)\n\tstruct ahc_softc *ahc;\n\tu_int msgtype;\n\tint full;\n{\n\tint found;\n\tint index;\n\n\tfound = FALSE;\n\tindex = 0;\n\n\twhile (index < ahc->msgout_len) {\n\t\tif (ahc->msgout_buf[index] == MSG_EXTENDED) {\n\n\t\t\t/* Found a candidate */\n\t\t\tif (ahc->msgout_buf[index+2] == msgtype) {\n\t\t\t\tu_int end_index;\n\n\t\t\t\tend_index = index + 1\n\t\t\t\t\t  + ahc->msgout_buf[index + 1];\n\t\t\t\tif (full) {\n\t\t\t\t\tif (ahc->msgout_index > end_index)\n\t\t\t\t\t\tfound = TRUE;\n\t\t\t\t} else if (ahc->msgout_index > index)\n\t\t\t\t\tfound = TRUE;\n\t\t\t}\n\t\t\tbreak;\n\t\t} else if (ahc->msgout_buf[index] >= MSG_SIMPLE_Q_TAG\n\t\t\t&& ahc->msgout_buf[index] <= MSG_IGN_WIDE_RESIDUE) {\n\n\t\t\t/* Skip tag type and tag id or residue param*/\n\t\t\tindex += 2;\n\t\t} else {\n\t\t\t/* Single byte message */\n\t\t\tindex++;\n\t\t}\n\t}\n\treturn (found);\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define STATIC\tstatic",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC u_int",
      "STATIC void",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC int",
      "ahc_sent_msg __P((struct ahc_softc *ahc, u_int msgtype,\n\t\t\t\t  int full));",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC u_int",
      "STATIC void",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "STATIC u_int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nahc_sent_msg __P((struct ahc_softc *ahc, u_int msgtype,\n\t\t\t\t  int full));\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC int\nahc_sent_msg(ahc, msgtype, full)\n\tstruct ahc_softc *ahc;\n\tu_int msgtype;\n\tint full;\n{\n\tint found;\n\tint index;\n\n\tfound = FALSE;\n\tindex = 0;\n\n\twhile (index < ahc->msgout_len) {\n\t\tif (ahc->msgout_buf[index] == MSG_EXTENDED) {\n\n\t\t\t/* Found a candidate */\n\t\t\tif (ahc->msgout_buf[index+2] == msgtype) {\n\t\t\t\tu_int end_index;\n\n\t\t\t\tend_index = index + 1\n\t\t\t\t\t  + ahc->msgout_buf[index + 1];\n\t\t\t\tif (full) {\n\t\t\t\t\tif (ahc->msgout_index > end_index)\n\t\t\t\t\t\tfound = TRUE;\n\t\t\t\t} else if (ahc->msgout_index > index)\n\t\t\t\t\tfound = TRUE;\n\t\t\t}\n\t\t\tbreak;\n\t\t} else if (ahc->msgout_buf[index] >= MSG_SIMPLE_Q_TAG\n\t\t\t&& ahc->msgout_buf[index] <= MSG_IGN_WIDE_RESIDUE) {\n\n\t\t\t/* Skip tag type and tag id or residue param*/\n\t\t\tindex += 2;\n\t\t} else {\n\t\t\t/* Single byte message */\n\t\t\tindex++;\n\t\t}\n\t}\n\treturn (found);\n}"
  },
  {
    "function_name": "ahc_handle_message_phase",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "2690-2937",
    "snippet": "STATIC void\nahc_handle_message_phase(ahc, sc_link)\n\tstruct ahc_softc *ahc;\n\tstruct scsi_link *sc_link;\n{ \n\tstruct\tahc_devinfo devinfo;\n\tu_int\tbus_phase;\n\tint\tend_session;\n\n\tahc_fetch_devinfo(ahc, &devinfo);\n\tend_session = FALSE;\n\tbus_phase = ahc_inb(ahc, SCSISIGI) & PHASE_MASK;\n\nreswitch:\n\tswitch (ahc->msg_type) {\n\tcase MSG_TYPE_INITIATOR_MSGOUT:\n\t{\n\t\tint lastbyte;\n\t\tint phasemis;\n\t\tint msgdone;\n\n\t\tif (ahc->msgout_len == 0)\n\t\t\tpanic(\"REQINIT interrupt with no active message\");\n\n\t\tphasemis = bus_phase != P_MESGOUT;\n\t\tif (phasemis) {\n\t\t\tif (bus_phase == P_MESGIN) {\n\t\t\t\t/*\n\t\t\t\t * Change gears and see if\n\t\t\t\t * this messages is of interest to\n\t\t\t\t * us or should be passed back to\n\t\t\t\t * the sequencer.\n\t\t\t\t */\n\t\t\t\tahc_outb(ahc, CLRSINT1, CLRATNO);\n\t\t\t\tahc->send_msg_perror = FALSE;\n\t\t\t\tahc->msg_type = MSG_TYPE_INITIATOR_MSGIN;\n\t\t\t\tahc->msgin_index = 0;\n\t\t\t\tgoto reswitch;\n\t\t\t}\n\t\t\tend_session = TRUE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ahc->send_msg_perror) {\n\t\t\tahc_outb(ahc, CLRSINT1, CLRATNO);\n\t\t\tahc_outb(ahc, CLRSINT1, CLRREQINIT);\n\t\t\tahc_outb(ahc, SCSIDATL, MSG_PARITY_ERROR);\n\t\t\tbreak;\n\t\t}\n\n\t\tmsgdone\t= ahc->msgout_index == ahc->msgout_len;\n\t\tif (msgdone) {\n\t\t\t/*\n\t\t\t * The target has requested a retry.\n\t\t\t * Re-assert ATN, reset our message index to\n\t\t\t * 0, and try again.\n\t\t\t */\n\t\t\tahc->msgout_index = 0;\n\t\t\tahc_outb(ahc, SCSISIGO, ahc_inb(ahc, SCSISIGO) | ATNO);\n\t\t}\n\n\t\tlastbyte = ahc->msgout_index == (ahc->msgout_len - 1);\n\t\tif (lastbyte) {\n\t\t\t/* Last byte is signified by dropping ATN */\n\t\t\tahc_outb(ahc, CLRSINT1, CLRATNO);\n\t\t}\n\n\t\t/*\n\t\t * Clear our interrupt status and present\n\t\t * the next byte on the bus.\n\t\t */\n\t\tahc_outb(ahc, CLRSINT1, CLRREQINIT);\n\t\tahc_outb(ahc, SCSIDATL, ahc->msgout_buf[ahc->msgout_index++]);\n\t\tbreak;\n\t}\n\tcase MSG_TYPE_INITIATOR_MSGIN:\n\t{\n\t\tint phasemis;\n\t\tint message_done;\n\n\t\tphasemis = bus_phase != P_MESGIN;\n\n\t\tif (phasemis) {\n\t\t\tahc->msgin_index = 0;\n\t\t\tif (bus_phase == P_MESGOUT\n\t\t\t && (ahc->send_msg_perror == TRUE\n\t\t\t  || (ahc->msgout_len != 0\n\t\t\t   && ahc->msgout_index == 0))) {\n\t\t\t\tahc->msg_type = MSG_TYPE_INITIATOR_MSGOUT;\n\t\t\t\tgoto reswitch;\n\t\t\t}\n\t\t\tend_session = TRUE;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Pull the byte in without acking it */\n\t\tahc->msgin_buf[ahc->msgin_index] = ahc_inb(ahc, SCSIBUSL);\n\n\t\tmessage_done = ahc_parse_msg(ahc, sc_link, &devinfo);\n\n\t\tif (message_done) {\n\t\t\t/*\n\t\t\t * Clear our incoming message buffer in case there\n\t\t\t * is another message following this one.\n\t\t\t */\n\t\t\tahc->msgin_index = 0;\n\n\t\t\t/*\n\t\t\t * If this message illicited a response,\n\t\t\t * assert ATN so the target takes us to the\n\t\t\t * message out phase.\n\t\t\t */\n\t\t\tif (ahc->msgout_len != 0)\n\t\t\t\tahc_outb(ahc, SCSISIGO,\n\t\t\t\t\t ahc_inb(ahc, SCSISIGO) | ATNO);\n\t\t} else \n\t\t\tahc->msgin_index++;\n\n\t\t/* Ack the byte */\n\t\tahc_outb(ahc, CLRSINT1, CLRREQINIT);\n\t\tahc_inb(ahc, SCSIDATL);\n\t\tbreak;\n\t}\n\tcase MSG_TYPE_TARGET_MSGIN:\n\t{\n\t\tint msgdone;\n\t\tint msgout_request;\n\n\t\tif (ahc->msgout_len == 0)\n\t\t\tpanic(\"Target MSGIN with no active message\");\n\n\t\t/*\n\t\t * If we interrupted a mesgout session, the initiator\n\t\t * will not know this until our first REQ.  So, we\n\t\t * only honor mesgout requests after we've sent our\n\t\t * first byte.\n\t\t */\n\t\tif ((ahc_inb(ahc, SCSISIGI) & ATNI) != 0\n\t\t && ahc->msgout_index > 0)\n\t\t\tmsgout_request = TRUE;\n\t\telse\n\t\t\tmsgout_request = FALSE;\n\n\t\tif (msgout_request) {\n\n\t\t\t/*\n\t\t\t * Change gears and see if\n\t\t\t * this messages is of interest to\n\t\t\t * us or should be passed back to\n\t\t\t * the sequencer.\n\t\t\t */\n\t\t\tahc->msg_type = MSG_TYPE_TARGET_MSGOUT;\n\t\t\tahc_outb(ahc, SCSISIGO, P_MESGOUT | BSYO);\n\t\t\tahc->msgin_index = 0;\n\t\t\t/* Dummy read to REQ for first byte */\n\t\t\tahc_inb(ahc, SCSIDATL);\n\t\t\tahc_outb(ahc, SXFRCTL0,\n\t\t\t\t ahc_inb(ahc, SXFRCTL0) | SPIOEN);\n\t\t\tbreak;\n\t\t}\n\n\t\tmsgdone = ahc->msgout_index == ahc->msgout_len;\n\t\tif (msgdone) {\n\t\t\tahc_outb(ahc, SXFRCTL0,\n\t\t\t\t ahc_inb(ahc, SXFRCTL0) & ~SPIOEN);\n\t\t\tend_session = TRUE;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Present the next byte on the bus.\n\t\t */\n\t\tahc_outb(ahc, SXFRCTL0, ahc_inb(ahc, SXFRCTL0) | SPIOEN);\n\t\tahc_outb(ahc, SCSIDATL, ahc->msgout_buf[ahc->msgout_index++]);\n\t\tbreak;\n\t}\n\tcase MSG_TYPE_TARGET_MSGOUT:\n\t{\n\t\tint lastbyte;\n\t\tint msgdone;\n\n\t\t/*\n\t\t * The initiator signals that this is\n\t\t * the last byte by dropping ATN.\n\t\t */\n\t\tlastbyte = (ahc_inb(ahc, SCSISIGI) & ATNI) == 0;\n\n\t\t/*\n\t\t * Read the latched byte, but turn off SPIOEN first\n\t\t * so that we don't inadvertantly cause a REQ for the\n\t\t * next byte.\n\t\t */\n\t\tahc_outb(ahc, SXFRCTL0, ahc_inb(ahc, SXFRCTL0) & ~SPIOEN);\n\t\tahc->msgin_buf[ahc->msgin_index] = ahc_inb(ahc, SCSIDATL);\n\t\tmsgdone = ahc_parse_msg(ahc, sc_link, &devinfo);\n\t\tif (msgdone == MSGLOOP_TERMINATED) {\n\t\t\t/*\n\t\t\t * The message is *really* done in that it caused\n\t\t\t * us to go to bus free.  The sequencer has already\n\t\t\t * been reset at this point, so pull the ejection\n\t\t\t * handle.\n\t\t\t */\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tahc->msgin_index++;\n\n\t\t/*\n\t\t * XXX Read spec about initiator dropping ATN too soon\n\t\t *     and use msgdone to detect it.\n\t\t */\n\t\tif (msgdone == MSGLOOP_MSGCOMPLETE) {\n\t\t\tahc->msgin_index = 0;\n\n\t\t\t/*\n\t\t\t * If this message illicited a response, transition\n\t\t\t * to the Message in phase and send it.\n\t\t\t */\n\t\t\tif (ahc->msgout_len != 0) {\n\t\t\t\tahc_outb(ahc, SCSISIGO, P_MESGIN | BSYO);\n\t\t\t\tahc_outb(ahc, SXFRCTL0,\n\t\t\t\t\t ahc_inb(ahc, SXFRCTL0) | SPIOEN);\n\t\t\t\tahc->msg_type = MSG_TYPE_TARGET_MSGIN;\n\t\t\t\tahc->msgin_index = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (lastbyte)\n\t\t\tend_session = TRUE;\n\t\telse {\n\t\t\t/* Ask for the next byte. */\n\t\t\tahc_outb(ahc, SXFRCTL0,\n\t\t\t\t ahc_inb(ahc, SXFRCTL0) | SPIOEN);\n\t\t}\n\n\t\tbreak;\n\t}\n\tdefault:\n\t\tpanic(\"Unknown REQINIT message type\");\n\t}\n\n\tif (end_session) {\n\t\tahc_clear_msg_state(ahc);\n\t\tahc_outb(ahc, RETURN_1, EXIT_MSG_LOOP);\n\t} else\n\t\tahc_outb(ahc, RETURN_1, CONT_MSG_LOOP);\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define STATIC\tstatic",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "ahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));",
      "STATIC void",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
      "STATIC void",
      "STATIC u_int",
      "STATIC void",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
      "STATIC void",
      "STATIC void",
      "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
      "STATIC int",
      "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
      "STATIC void",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));",
      "STATIC int",
      "STATIC int",
      "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
      "STATIC void",
      "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
      "STATIC void",
      "STATIC void",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "ahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));",
      "STATIC int",
      "STATIC u_int",
      "STATIC void",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "STATIC u_int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));",
      "STATIC void",
      "ahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "RETURN_1",
            "CONT_MSG_LOOP"
          ],
          "line": 2936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "RETURN_1",
            "EXIT_MSG_LOOP"
          ],
          "line": 2934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_clear_msg_state",
          "args": [
            "ahc"
          ],
          "line": 2933
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_clear_msg_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "2680-2688",
          "snippet": "STATIC void\nahc_clear_msg_state(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tahc->msgout_len = 0;\n\tahc->msgin_index = 0;\n\tahc->msg_type = MSG_TYPE_NONE;\n\tahc_outb(ahc, MSG_OUT, MSG_NOOP);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_clear_msg_state(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tahc->msgout_len = 0;\n\tahc->msgin_index = 0;\n\tahc->msg_type = MSG_TYPE_NONE;\n\tahc_outb(ahc, MSG_OUT, MSG_NOOP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"Unknown REQINIT message type\""
          ],
          "line": 2929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SXFRCTL0",
            "ahc_inb(ahc, SXFRCTL0) | SPIOEN"
          ],
          "line": 2922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SXFRCTL0"
          ],
          "line": 2923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SXFRCTL0",
            "ahc_inb(ahc, SXFRCTL0) | SPIOEN"
          ],
          "line": 2910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SXFRCTL0"
          ],
          "line": 2911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCSISIGO",
            "P_MESGIN | BSYO"
          ],
          "line": 2909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_parse_msg",
          "args": [
            "ahc",
            "sc_link",
            "&devinfo"
          ],
          "line": 2884
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_parse_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "2986-3275",
          "snippet": "STATIC int\nahc_parse_msg(ahc, sc_link, devinfo)\n\tstruct ahc_softc *ahc;\n\tstruct scsi_link *sc_link;\n\tstruct ahc_devinfo *devinfo;\n{\n\tstruct\tahc_initiator_tinfo *tinfo;\n\tstruct\ttmode_tstate *tstate;\n\tint\treject;\n\tint\tdone;\n\tint\tresponse;\n\tu_int\ttarg_scsirate;\n\n\tdone = MSGLOOP_IN_PROG;\n\tresponse = FALSE;\n\treject = FALSE;\n\ttinfo = ahc_fetch_transinfo(ahc, devinfo->channel, devinfo->our_scsiid,\n\t\t\t\t    devinfo->target, &tstate);\n\ttarg_scsirate = tinfo->scsirate;\n\n\t/*\n\t * Parse as much of the message as is availible,\n\t * rejecting it if we don't support it.  When\n\t * the entire message is availible and has been\n\t * handled, return MSGLOOP_MSGCOMPLETE, indicating\n\t * that we have parsed an entire message.\n\t *\n\t * In the case of extended messages, we accept the length\n\t * byte outright and perform more checking once we know the\n\t * extended message type.\n\t */\n\tswitch (ahc->msgin_buf[0]) {\n\tcase MSG_MESSAGE_REJECT:\n\t\tresponse = ahc_handle_msg_reject(ahc, devinfo);\n\t\t/* FALLTHROUGH */\n\tcase MSG_NOOP:\n\t\tdone = MSGLOOP_MSGCOMPLETE;\n\t\tbreak;\n\tcase MSG_IGN_WIDE_RESIDUE:\n\t{\n\t\t/* Wait for the whole message */\n\t\tif (ahc->msgin_index >= 1) {\n\t\t\tif (ahc->msgin_buf[1] != 1\n\t\t\t || tinfo->current.width == MSG_EXT_WDTR_BUS_8_BIT) {\n\t\t\t\treject = TRUE;\n\t\t\t\tdone = MSGLOOP_MSGCOMPLETE;\n\t\t\t} else\n\t\t\t\tahc_handle_ign_wide_residue(ahc, devinfo);\n\t\t}\n\t\tbreak;\n\t}\n\tcase MSG_EXTENDED:\n\t{\n\t\t/* Wait for enough of the message to begin validation */\n\t\tif (ahc->msgin_index < 2)\n\t\t\tbreak;\n\t\tswitch (ahc->msgin_buf[2]) {\n\t\tcase MSG_EXT_SDTR:\n\t\t{\n\t\t\tstruct\t ahc_syncrate *syncrate;\n\t\t\tu_int\t period;\n\t\t\tu_int\t offset;\n\t\t\tu_int\t saved_offset;\n\t\t\t\n\t\t\tif (ahc->msgin_buf[1] != MSG_EXT_SDTR_LEN) {\n\t\t\t\treject = TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Wait until we have both args before validating\n\t\t\t * and acting on this message.\n\t\t\t *\n\t\t\t * Add one to MSG_EXT_SDTR_LEN to account for\n\t\t\t * the extended message preamble.\n\t\t\t */\n\t\t\tif (ahc->msgin_index < (MSG_EXT_SDTR_LEN + 1))\n\t\t\t\tbreak;\n\n\t\t\tperiod = ahc->msgin_buf[3];\n\t\t\tsaved_offset = offset = ahc->msgin_buf[4];\n\t\t\tsyncrate = ahc_devlimited_syncrate(ahc, &period);\n\t\t\tahc_validate_offset(ahc, syncrate, &offset,\n\t\t\t\t\t    targ_scsirate & WIDEXFER);\n\t\t\tahc_set_syncrate(ahc, devinfo,\n\t\t\t\t\t syncrate, period, offset,\n\t\t\t\t\t AHC_TRANS_ACTIVE|AHC_TRANS_GOAL,\n\t\t\t\t\t /*paused*/TRUE, /*done*/TRUE);\n\n\t\t\t/*\n\t\t\t * See if we initiated Sync Negotiation\n\t\t\t * and didn't have to fall down to async\n\t\t\t * transfers.\n\t\t\t */\n\t\t\tif (ahc_sent_msg(ahc, MSG_EXT_SDTR, /*full*/TRUE)) {\n\t\t\t\t/* We started it */\n\t\t\t\tif (saved_offset != offset) {\n\t\t\t\t\t/* Went too low - force async */\n\t\t\t\t\treject = TRUE;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Send our own SDTR in reply\n\t\t\t\t */\n\t\t\t\tif (bootverbose)\n\t\t\t\t\tprintf(\"Sending SDTR!\\n\");\n\t\t\t\tahc->msgout_index = 0;\n\t\t\t\tahc->msgout_len = 0;\n\t\t\t\tahc_construct_sdtr(ahc, period, offset);\n\t\t\t\tahc->msgout_index = 0;\n\t\t\t\tresponse = TRUE;\n\t\t\t}\n\t\t\tdone = MSGLOOP_MSGCOMPLETE;\n\t\t\tbreak;\n\t\t}\n\t\tcase MSG_EXT_WDTR:\n\t\t{\n\t\t\tu_int\tbus_width;\n\t\t\tu_int\tsending_reply;\n\n\t\t\tsending_reply = FALSE;\n\t\t\tif (ahc->msgin_buf[1] != MSG_EXT_WDTR_LEN) {\n\t\t\t\treject = TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Wait until we have our arg before validating\n\t\t\t * and acting on this message.\n\t\t\t *\n\t\t\t * Add one to MSG_EXT_WDTR_LEN to account for\n\t\t\t * the extended message preamble.\n\t\t\t */\n\t\t\tif (ahc->msgin_index < (MSG_EXT_WDTR_LEN + 1))\n\t\t\t\tbreak;\n\n\t\t\tbus_width = ahc->msgin_buf[3];\n\t\t\tif (ahc_sent_msg(ahc, MSG_EXT_WDTR, /*full*/TRUE)) {\n\t\t\t\t/*\n\t\t\t\t * Don't send a WDTR back to the\n\t\t\t\t * target, since we asked first.\n\t\t\t\t */\n\t\t\t\tswitch (bus_width){\n\t\t\t\tdefault:\n\t\t\t\t\t/*\n\t\t\t\t\t * How can we do anything greater\n\t\t\t\t\t * than 16bit transfers on a 16bit\n\t\t\t\t\t * bus?\n\t\t\t\t\t */\n\t\t\t\t\treject = TRUE;\n\t\t\t\t\tprintf(\"%s: target %d requested %dBit \"\n\t\t\t\t\t       \"transfers.  Rejecting...\\n\",\n\t\t\t\t\t       ahc_name(ahc), devinfo->target,\n\t\t\t\t\t       8 * (0x01 << bus_width));\n\t\t\t\t\t/* FALLTHROUGH */\n\t\t\t\tcase MSG_EXT_WDTR_BUS_8_BIT:\n\t\t\t\t\tbus_width = MSG_EXT_WDTR_BUS_8_BIT;\n\t\t\t\t\tbreak;\n\t\t\t\tcase MSG_EXT_WDTR_BUS_16_BIT:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Send our own WDTR in reply\n\t\t\t\t */\n\t\t\t\tif (bootverbose)\n\t\t\t\t\tprintf(\"Sending WDTR!\\n\");\n\t\t\t\tswitch (bus_width) {\n\t\t\t\tdefault:\n\t\t\t\t\tif (ahc->features & AHC_WIDE) {\n\t\t\t\t\t\t/* Respond Wide */\n\t\t\t\t\t\tbus_width =\n\t\t\t\t\t\t    MSG_EXT_WDTR_BUS_16_BIT;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t/* FALLTHROUGH */\n\t\t\t\tcase MSG_EXT_WDTR_BUS_8_BIT:\n\t\t\t\t\tbus_width = MSG_EXT_WDTR_BUS_8_BIT;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tahc->msgout_index = 0;\n\t\t\t\tahc->msgout_len = 0;\n\t\t\t\tahc_construct_wdtr(ahc, bus_width);\n\t\t\t\tahc->msgout_index = 0;\n\t\t\t\tresponse = TRUE;\n\t\t\t\tsending_reply = TRUE;\n\t\t\t}\n\t\t\tahc_set_width(ahc, devinfo, bus_width,\n\t\t\t\t      AHC_TRANS_ACTIVE|AHC_TRANS_GOAL,\n\t\t\t\t      /*paused*/TRUE, /*done*/TRUE);\n\n\t\t\t/* After a wide message, we are async */\n\t\t\tahc_set_syncrate(ahc, devinfo,\n\t\t\t\t\t /*syncrate*/NULL, /*period*/0,\n\t\t\t\t\t /*offset*/0, AHC_TRANS_ACTIVE,\n\t\t\t\t\t /*paused*/TRUE, /*done*/FALSE);\n\t\t\tif (sending_reply == FALSE && reject == FALSE) {\n\n\t\t\t\tif (tinfo->goal.period) {\n\t\t\t\t\tstruct\tahc_syncrate *rate;\n\t\t\t\t\tu_int\tperiod;\n\t\t\t\t\tu_int\toffset;\n\n\t\t\t\t\t/* Start the sync negotiation */\n\t\t\t\t\tperiod = tinfo->goal.period;\n\t\t\t\t\trate = ahc_devlimited_syncrate(ahc,\n\t\t\t\t\t\t\t\t       &period);\n\t\t\t\t\toffset = tinfo->goal.offset;\n\t\t\t\t\tahc_validate_offset(ahc, rate, &offset,\n\t\t\t\t\t\t\t  tinfo->current.width);\n\t\t\t\t\tahc->msgout_index = 0;\n\t\t\t\t\tahc->msgout_len = 0;\n\t\t\t\t\tahc_construct_sdtr(ahc, period, offset);\n\t\t\t\t\tahc->msgout_index = 0;\n\t\t\t\t\tresponse = TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdone = MSGLOOP_MSGCOMPLETE;\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\t/* Unknown extended message.  Reject it. */\n\t\t\treject = TRUE;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\tcase MSG_BUS_DEV_RESET:\n\t\tahc_handle_devreset(ahc, devinfo,\n\t\t\t\t    XS_RESET, \"Bus Device Reset Received\",\n\t\t\t\t    /*verbose_level*/0);\n\t\trestart_sequencer(ahc);\n\t\tdone = MSGLOOP_TERMINATED;\n\t\tbreak;\n\tcase MSG_ABORT_TAG:\n\tcase MSG_ABORT:\n\tcase MSG_CLEAR_QUEUE:\n\t\t/* Target mode messages */\n\t\tif (devinfo->role != ROLE_TARGET) {\n\t\t\treject = TRUE;\n\t\t\tbreak;\n\t\t}\n#if AHC_TARGET_MODE\n\t\tahc_abort_scbs(ahc, devinfo->target, devinfo->channel,\n\t\t\t       devinfo->lun,\n\t\t\t       ahc->msgin_buf[0] == MSG_ABORT_TAG ? SCB_LIST_NULL\n\t\t\t       : ahc_inb(ahc, INITIATOR_TAG),\n\t\t\t\tROLE_TARGET, XS_DRIVER_STUFFUP);\n\n\t\ttstate = ahc->enabled_targets[devinfo->our_scsiid];\n\t\tif (tstate != NULL) {\n\t\t\tstruct tmode_lstate* lstate;\n\n\t\t\tlstate = tstate->enabled_luns[devinfo->lun];\n\t\t\tif (lstate != NULL) {\n\t\t\t\tahc_queue_lstate_event(ahc, lstate,\n\t\t\t\t\t\t       devinfo->our_scsiid,\n\t\t\t\t\t\t       ahc->msgin_buf[0],\n\t\t\t\t\t\t       /*arg*/0);\n\t\t\t\tahc_send_lstate_events(ahc, lstate);\n\t\t\t}\n\t\t}\n\t\tdone = MSGLOOP_MSGCOMPLETE;\n#else\n\t\tpanic(\"ahc: got target mode message\");\n#endif\n\t\tbreak;\n\tcase MSG_TERM_IO_PROC:\n\tdefault:\n\t\treject = TRUE;\n\t\tbreak;\n\t}\n\n\tif (reject) {\n\t\t/*\n\t\t * Setup to reject the message.\n\t\t */\n\t\tahc->msgout_index = 0;\n\t\tahc->msgout_len = 1;\n\t\tahc->msgout_buf[0] = MSG_MESSAGE_REJECT;\n\t\tdone = MSGLOOP_MSGCOMPLETE;\n\t\tresponse = TRUE;\n\t}\n\n\tif (done != MSGLOOP_IN_PROG && !response)\n\t\t/* Clear the outgoing message buffer */\n\t\tahc->msgout_len = 0;\n\n\treturn (done);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define bootverbose\t0",
            "#define STATIC",
            "#define bootverbose\t1"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "ahc_shutdown __P((void *arg));",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "ahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC int",
            "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));",
            "STATIC int",
            "ahc_sent_msg __P((struct ahc_softc *ahc, u_int msgtype,\n\t\t\t\t  int full));",
            "STATIC int",
            "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_handle_devreset __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct ahc_devinfo *devinfo,\n\t\t\t\t\t int status, char *message,\n\t\t\t\t\t int verbose_level));",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "ahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "ahc_validate_offset __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct ahc_syncrate *syncrate,\n\t\t\t\t\t u_int *offset, int wide));",
            "STATIC void",
            "ahc_update_target_msg_request __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t\t      struct ahc_initiator_tinfo *tinfo,\n\t\t\t\t\t      int force, int paused));",
            "STATIC void",
            "ahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));",
            "STATIC void",
            "ahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));",
            "STATIC void",
            "ahc_construct_wdtr __P((struct ahc_softc *ahc, u_int bus_width));",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "static __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct tmode_tstate **tstate;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "u_int *period;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "u_int *period;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define bootverbose\t0\n#define STATIC\n#define bootverbose\t1\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nahc_shutdown __P((void *arg));\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));\nSTATIC int;\nahc_sent_msg __P((struct ahc_softc *ahc, u_int msgtype,\n\t\t\t\t  int full));\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_devreset __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct ahc_devinfo *devinfo,\n\t\t\t\t\t int status, char *message,\n\t\t\t\t\t int verbose_level));\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nahc_validate_offset __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct ahc_syncrate *syncrate,\n\t\t\t\t\t u_int *offset, int wide));\nSTATIC void;\nahc_update_target_msg_request __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t\t      struct ahc_initiator_tinfo *tinfo,\n\t\t\t\t\t      int force, int paused));\nSTATIC void;\nahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));\nSTATIC void;\nahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));\nSTATIC void;\nahc_construct_wdtr __P((struct ahc_softc *ahc, u_int bus_width));\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct tmode_tstate **tstate;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC int\nahc_parse_msg(ahc, sc_link, devinfo)\n\tstruct ahc_softc *ahc;\n\tstruct scsi_link *sc_link;\n\tstruct ahc_devinfo *devinfo;\n{\n\tstruct\tahc_initiator_tinfo *tinfo;\n\tstruct\ttmode_tstate *tstate;\n\tint\treject;\n\tint\tdone;\n\tint\tresponse;\n\tu_int\ttarg_scsirate;\n\n\tdone = MSGLOOP_IN_PROG;\n\tresponse = FALSE;\n\treject = FALSE;\n\ttinfo = ahc_fetch_transinfo(ahc, devinfo->channel, devinfo->our_scsiid,\n\t\t\t\t    devinfo->target, &tstate);\n\ttarg_scsirate = tinfo->scsirate;\n\n\t/*\n\t * Parse as much of the message as is availible,\n\t * rejecting it if we don't support it.  When\n\t * the entire message is availible and has been\n\t * handled, return MSGLOOP_MSGCOMPLETE, indicating\n\t * that we have parsed an entire message.\n\t *\n\t * In the case of extended messages, we accept the length\n\t * byte outright and perform more checking once we know the\n\t * extended message type.\n\t */\n\tswitch (ahc->msgin_buf[0]) {\n\tcase MSG_MESSAGE_REJECT:\n\t\tresponse = ahc_handle_msg_reject(ahc, devinfo);\n\t\t/* FALLTHROUGH */\n\tcase MSG_NOOP:\n\t\tdone = MSGLOOP_MSGCOMPLETE;\n\t\tbreak;\n\tcase MSG_IGN_WIDE_RESIDUE:\n\t{\n\t\t/* Wait for the whole message */\n\t\tif (ahc->msgin_index >= 1) {\n\t\t\tif (ahc->msgin_buf[1] != 1\n\t\t\t || tinfo->current.width == MSG_EXT_WDTR_BUS_8_BIT) {\n\t\t\t\treject = TRUE;\n\t\t\t\tdone = MSGLOOP_MSGCOMPLETE;\n\t\t\t} else\n\t\t\t\tahc_handle_ign_wide_residue(ahc, devinfo);\n\t\t}\n\t\tbreak;\n\t}\n\tcase MSG_EXTENDED:\n\t{\n\t\t/* Wait for enough of the message to begin validation */\n\t\tif (ahc->msgin_index < 2)\n\t\t\tbreak;\n\t\tswitch (ahc->msgin_buf[2]) {\n\t\tcase MSG_EXT_SDTR:\n\t\t{\n\t\t\tstruct\t ahc_syncrate *syncrate;\n\t\t\tu_int\t period;\n\t\t\tu_int\t offset;\n\t\t\tu_int\t saved_offset;\n\t\t\t\n\t\t\tif (ahc->msgin_buf[1] != MSG_EXT_SDTR_LEN) {\n\t\t\t\treject = TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Wait until we have both args before validating\n\t\t\t * and acting on this message.\n\t\t\t *\n\t\t\t * Add one to MSG_EXT_SDTR_LEN to account for\n\t\t\t * the extended message preamble.\n\t\t\t */\n\t\t\tif (ahc->msgin_index < (MSG_EXT_SDTR_LEN + 1))\n\t\t\t\tbreak;\n\n\t\t\tperiod = ahc->msgin_buf[3];\n\t\t\tsaved_offset = offset = ahc->msgin_buf[4];\n\t\t\tsyncrate = ahc_devlimited_syncrate(ahc, &period);\n\t\t\tahc_validate_offset(ahc, syncrate, &offset,\n\t\t\t\t\t    targ_scsirate & WIDEXFER);\n\t\t\tahc_set_syncrate(ahc, devinfo,\n\t\t\t\t\t syncrate, period, offset,\n\t\t\t\t\t AHC_TRANS_ACTIVE|AHC_TRANS_GOAL,\n\t\t\t\t\t /*paused*/TRUE, /*done*/TRUE);\n\n\t\t\t/*\n\t\t\t * See if we initiated Sync Negotiation\n\t\t\t * and didn't have to fall down to async\n\t\t\t * transfers.\n\t\t\t */\n\t\t\tif (ahc_sent_msg(ahc, MSG_EXT_SDTR, /*full*/TRUE)) {\n\t\t\t\t/* We started it */\n\t\t\t\tif (saved_offset != offset) {\n\t\t\t\t\t/* Went too low - force async */\n\t\t\t\t\treject = TRUE;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Send our own SDTR in reply\n\t\t\t\t */\n\t\t\t\tif (bootverbose)\n\t\t\t\t\tprintf(\"Sending SDTR!\\n\");\n\t\t\t\tahc->msgout_index = 0;\n\t\t\t\tahc->msgout_len = 0;\n\t\t\t\tahc_construct_sdtr(ahc, period, offset);\n\t\t\t\tahc->msgout_index = 0;\n\t\t\t\tresponse = TRUE;\n\t\t\t}\n\t\t\tdone = MSGLOOP_MSGCOMPLETE;\n\t\t\tbreak;\n\t\t}\n\t\tcase MSG_EXT_WDTR:\n\t\t{\n\t\t\tu_int\tbus_width;\n\t\t\tu_int\tsending_reply;\n\n\t\t\tsending_reply = FALSE;\n\t\t\tif (ahc->msgin_buf[1] != MSG_EXT_WDTR_LEN) {\n\t\t\t\treject = TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Wait until we have our arg before validating\n\t\t\t * and acting on this message.\n\t\t\t *\n\t\t\t * Add one to MSG_EXT_WDTR_LEN to account for\n\t\t\t * the extended message preamble.\n\t\t\t */\n\t\t\tif (ahc->msgin_index < (MSG_EXT_WDTR_LEN + 1))\n\t\t\t\tbreak;\n\n\t\t\tbus_width = ahc->msgin_buf[3];\n\t\t\tif (ahc_sent_msg(ahc, MSG_EXT_WDTR, /*full*/TRUE)) {\n\t\t\t\t/*\n\t\t\t\t * Don't send a WDTR back to the\n\t\t\t\t * target, since we asked first.\n\t\t\t\t */\n\t\t\t\tswitch (bus_width){\n\t\t\t\tdefault:\n\t\t\t\t\t/*\n\t\t\t\t\t * How can we do anything greater\n\t\t\t\t\t * than 16bit transfers on a 16bit\n\t\t\t\t\t * bus?\n\t\t\t\t\t */\n\t\t\t\t\treject = TRUE;\n\t\t\t\t\tprintf(\"%s: target %d requested %dBit \"\n\t\t\t\t\t       \"transfers.  Rejecting...\\n\",\n\t\t\t\t\t       ahc_name(ahc), devinfo->target,\n\t\t\t\t\t       8 * (0x01 << bus_width));\n\t\t\t\t\t/* FALLTHROUGH */\n\t\t\t\tcase MSG_EXT_WDTR_BUS_8_BIT:\n\t\t\t\t\tbus_width = MSG_EXT_WDTR_BUS_8_BIT;\n\t\t\t\t\tbreak;\n\t\t\t\tcase MSG_EXT_WDTR_BUS_16_BIT:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Send our own WDTR in reply\n\t\t\t\t */\n\t\t\t\tif (bootverbose)\n\t\t\t\t\tprintf(\"Sending WDTR!\\n\");\n\t\t\t\tswitch (bus_width) {\n\t\t\t\tdefault:\n\t\t\t\t\tif (ahc->features & AHC_WIDE) {\n\t\t\t\t\t\t/* Respond Wide */\n\t\t\t\t\t\tbus_width =\n\t\t\t\t\t\t    MSG_EXT_WDTR_BUS_16_BIT;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t/* FALLTHROUGH */\n\t\t\t\tcase MSG_EXT_WDTR_BUS_8_BIT:\n\t\t\t\t\tbus_width = MSG_EXT_WDTR_BUS_8_BIT;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tahc->msgout_index = 0;\n\t\t\t\tahc->msgout_len = 0;\n\t\t\t\tahc_construct_wdtr(ahc, bus_width);\n\t\t\t\tahc->msgout_index = 0;\n\t\t\t\tresponse = TRUE;\n\t\t\t\tsending_reply = TRUE;\n\t\t\t}\n\t\t\tahc_set_width(ahc, devinfo, bus_width,\n\t\t\t\t      AHC_TRANS_ACTIVE|AHC_TRANS_GOAL,\n\t\t\t\t      /*paused*/TRUE, /*done*/TRUE);\n\n\t\t\t/* After a wide message, we are async */\n\t\t\tahc_set_syncrate(ahc, devinfo,\n\t\t\t\t\t /*syncrate*/NULL, /*period*/0,\n\t\t\t\t\t /*offset*/0, AHC_TRANS_ACTIVE,\n\t\t\t\t\t /*paused*/TRUE, /*done*/FALSE);\n\t\t\tif (sending_reply == FALSE && reject == FALSE) {\n\n\t\t\t\tif (tinfo->goal.period) {\n\t\t\t\t\tstruct\tahc_syncrate *rate;\n\t\t\t\t\tu_int\tperiod;\n\t\t\t\t\tu_int\toffset;\n\n\t\t\t\t\t/* Start the sync negotiation */\n\t\t\t\t\tperiod = tinfo->goal.period;\n\t\t\t\t\trate = ahc_devlimited_syncrate(ahc,\n\t\t\t\t\t\t\t\t       &period);\n\t\t\t\t\toffset = tinfo->goal.offset;\n\t\t\t\t\tahc_validate_offset(ahc, rate, &offset,\n\t\t\t\t\t\t\t  tinfo->current.width);\n\t\t\t\t\tahc->msgout_index = 0;\n\t\t\t\t\tahc->msgout_len = 0;\n\t\t\t\t\tahc_construct_sdtr(ahc, period, offset);\n\t\t\t\t\tahc->msgout_index = 0;\n\t\t\t\t\tresponse = TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdone = MSGLOOP_MSGCOMPLETE;\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\t/* Unknown extended message.  Reject it. */\n\t\t\treject = TRUE;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\tcase MSG_BUS_DEV_RESET:\n\t\tahc_handle_devreset(ahc, devinfo,\n\t\t\t\t    XS_RESET, \"Bus Device Reset Received\",\n\t\t\t\t    /*verbose_level*/0);\n\t\trestart_sequencer(ahc);\n\t\tdone = MSGLOOP_TERMINATED;\n\t\tbreak;\n\tcase MSG_ABORT_TAG:\n\tcase MSG_ABORT:\n\tcase MSG_CLEAR_QUEUE:\n\t\t/* Target mode messages */\n\t\tif (devinfo->role != ROLE_TARGET) {\n\t\t\treject = TRUE;\n\t\t\tbreak;\n\t\t}\n#if AHC_TARGET_MODE\n\t\tahc_abort_scbs(ahc, devinfo->target, devinfo->channel,\n\t\t\t       devinfo->lun,\n\t\t\t       ahc->msgin_buf[0] == MSG_ABORT_TAG ? SCB_LIST_NULL\n\t\t\t       : ahc_inb(ahc, INITIATOR_TAG),\n\t\t\t\tROLE_TARGET, XS_DRIVER_STUFFUP);\n\n\t\ttstate = ahc->enabled_targets[devinfo->our_scsiid];\n\t\tif (tstate != NULL) {\n\t\t\tstruct tmode_lstate* lstate;\n\n\t\t\tlstate = tstate->enabled_luns[devinfo->lun];\n\t\t\tif (lstate != NULL) {\n\t\t\t\tahc_queue_lstate_event(ahc, lstate,\n\t\t\t\t\t\t       devinfo->our_scsiid,\n\t\t\t\t\t\t       ahc->msgin_buf[0],\n\t\t\t\t\t\t       /*arg*/0);\n\t\t\t\tahc_send_lstate_events(ahc, lstate);\n\t\t\t}\n\t\t}\n\t\tdone = MSGLOOP_MSGCOMPLETE;\n#else\n\t\tpanic(\"ahc: got target mode message\");\n#endif\n\t\tbreak;\n\tcase MSG_TERM_IO_PROC:\n\tdefault:\n\t\treject = TRUE;\n\t\tbreak;\n\t}\n\n\tif (reject) {\n\t\t/*\n\t\t * Setup to reject the message.\n\t\t */\n\t\tahc->msgout_index = 0;\n\t\tahc->msgout_len = 1;\n\t\tahc->msgout_buf[0] = MSG_MESSAGE_REJECT;\n\t\tdone = MSGLOOP_MSGCOMPLETE;\n\t\tresponse = TRUE;\n\t}\n\n\tif (done != MSGLOOP_IN_PROG && !response)\n\t\t/* Clear the outgoing message buffer */\n\t\tahc->msgout_len = 0;\n\n\treturn (done);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCSIDATL"
          ],
          "line": 2883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SXFRCTL0",
            "ahc_inb(ahc, SXFRCTL0) & ~SPIOEN"
          ],
          "line": 2882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SXFRCTL0"
          ],
          "line": 2882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCSISIGI"
          ],
          "line": 2875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCSIDATL",
            "ahc->msgout_buf[ahc->msgout_index++]"
          ],
          "line": 2863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SXFRCTL0",
            "ahc_inb(ahc, SXFRCTL0) | SPIOEN"
          ],
          "line": 2862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SXFRCTL0"
          ],
          "line": 2862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SXFRCTL0",
            "ahc_inb(ahc, SXFRCTL0) & ~SPIOEN"
          ],
          "line": 2853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SXFRCTL0"
          ],
          "line": 2854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SXFRCTL0",
            "ahc_inb(ahc, SXFRCTL0) | SPIOEN"
          ],
          "line": 2846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SXFRCTL0"
          ],
          "line": 2847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCSIDATL"
          ],
          "line": 2845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCSISIGO",
            "P_MESGOUT | BSYO"
          ],
          "line": 2842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCSISIGI"
          ],
          "line": 2827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"Target MSGIN with no active message\""
          ],
          "line": 2819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCSIDATL"
          ],
          "line": 2810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "CLRSINT1",
            "CLRREQINIT"
          ],
          "line": 2809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCSISIGO",
            "ahc_inb(ahc, SCSISIGO) | ATNO"
          ],
          "line": 2803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCSISIGO"
          ],
          "line": 2804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCSIBUSL"
          ],
          "line": 2786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCSIDATL",
            "ahc->msgout_buf[ahc->msgout_index++]"
          ],
          "line": 2762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "CLRSINT1",
            "CLRREQINIT"
          ],
          "line": 2761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "CLRSINT1",
            "CLRATNO"
          ],
          "line": 2754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCSISIGO",
            "ahc_inb(ahc, SCSISIGO) | ATNO"
          ],
          "line": 2748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCSISIGO"
          ],
          "line": 2748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCSIDATL",
            "MSG_PARITY_ERROR"
          ],
          "line": 2736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "CLRSINT1",
            "CLRREQINIT"
          ],
          "line": 2735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "CLRSINT1",
            "CLRATNO"
          ],
          "line": 2734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "CLRSINT1",
            "CLRATNO"
          ],
          "line": 2723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"REQINIT interrupt with no active message\""
          ],
          "line": 2712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCSISIGI"
          ],
          "line": 2701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_fetch_devinfo",
          "args": [
            "ahc",
            "&devinfo"
          ],
          "line": 2699
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_fetch_devinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "1538-1566",
          "snippet": "STATIC void\nahc_fetch_devinfo(ahc, devinfo)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n{\n\tu_int\tsaved_tcl;\n\trole_t\trole;\n\tint\tour_id;\n\n\tif (ahc_inb(ahc, SSTAT0) & TARGET)\n\t\trole = ROLE_TARGET;\n\telse\n\t\trole = ROLE_INITIATOR;\n\n\tif (role == ROLE_TARGET\n\t && (ahc->features & AHC_MULTI_TID) != 0\n\t && (ahc_inb(ahc, SEQ_FLAGS) & CMDPHASE_PENDING) != 0) {\n\t\t/* We were selected, so pull our id from TARGIDIN */\n\t\tour_id = ahc_inb(ahc, TARGIDIN) & OID;\n\t} else if ((ahc->features & AHC_ULTRA2) != 0)\n\t\tour_id = ahc_inb(ahc, SCSIID_ULTRA2) & OID;\n\telse\n\t\tour_id = ahc_inb(ahc, SCSIID) & OID;\n\n\tsaved_tcl = ahc_inb(ahc, SAVED_TCL);\n\tahc_compile_devinfo(devinfo, our_id, TCL_TARGET(saved_tcl),\n\t\t\t    TCL_LUN(saved_tcl), TCL_CHANNEL(ahc, saved_tcl),\n\t\t\t    role);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC int",
            "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "ahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "u_int our_id;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nu_int our_id;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_fetch_devinfo(ahc, devinfo)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n{\n\tu_int\tsaved_tcl;\n\trole_t\trole;\n\tint\tour_id;\n\n\tif (ahc_inb(ahc, SSTAT0) & TARGET)\n\t\trole = ROLE_TARGET;\n\telse\n\t\trole = ROLE_INITIATOR;\n\n\tif (role == ROLE_TARGET\n\t && (ahc->features & AHC_MULTI_TID) != 0\n\t && (ahc_inb(ahc, SEQ_FLAGS) & CMDPHASE_PENDING) != 0) {\n\t\t/* We were selected, so pull our id from TARGIDIN */\n\t\tour_id = ahc_inb(ahc, TARGIDIN) & OID;\n\t} else if ((ahc->features & AHC_ULTRA2) != 0)\n\t\tour_id = ahc_inb(ahc, SCSIID_ULTRA2) & OID;\n\telse\n\t\tour_id = ahc_inb(ahc, SCSIID) & OID;\n\n\tsaved_tcl = ahc_inb(ahc, SAVED_TCL);\n\tahc_compile_devinfo(devinfo, our_id, TCL_TARGET(saved_tcl),\n\t\t\t    TCL_LUN(saved_tcl), TCL_CHANNEL(ahc, saved_tcl),\n\t\t\t    role);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));\nSTATIC int;\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));\nSTATIC void;\nahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_handle_message_phase(ahc, sc_link)\n\tstruct ahc_softc *ahc;\n\tstruct scsi_link *sc_link;\n{ \n\tstruct\tahc_devinfo devinfo;\n\tu_int\tbus_phase;\n\tint\tend_session;\n\n\tahc_fetch_devinfo(ahc, &devinfo);\n\tend_session = FALSE;\n\tbus_phase = ahc_inb(ahc, SCSISIGI) & PHASE_MASK;\n\nreswitch:\n\tswitch (ahc->msg_type) {\n\tcase MSG_TYPE_INITIATOR_MSGOUT:\n\t{\n\t\tint lastbyte;\n\t\tint phasemis;\n\t\tint msgdone;\n\n\t\tif (ahc->msgout_len == 0)\n\t\t\tpanic(\"REQINIT interrupt with no active message\");\n\n\t\tphasemis = bus_phase != P_MESGOUT;\n\t\tif (phasemis) {\n\t\t\tif (bus_phase == P_MESGIN) {\n\t\t\t\t/*\n\t\t\t\t * Change gears and see if\n\t\t\t\t * this messages is of interest to\n\t\t\t\t * us or should be passed back to\n\t\t\t\t * the sequencer.\n\t\t\t\t */\n\t\t\t\tahc_outb(ahc, CLRSINT1, CLRATNO);\n\t\t\t\tahc->send_msg_perror = FALSE;\n\t\t\t\tahc->msg_type = MSG_TYPE_INITIATOR_MSGIN;\n\t\t\t\tahc->msgin_index = 0;\n\t\t\t\tgoto reswitch;\n\t\t\t}\n\t\t\tend_session = TRUE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ahc->send_msg_perror) {\n\t\t\tahc_outb(ahc, CLRSINT1, CLRATNO);\n\t\t\tahc_outb(ahc, CLRSINT1, CLRREQINIT);\n\t\t\tahc_outb(ahc, SCSIDATL, MSG_PARITY_ERROR);\n\t\t\tbreak;\n\t\t}\n\n\t\tmsgdone\t= ahc->msgout_index == ahc->msgout_len;\n\t\tif (msgdone) {\n\t\t\t/*\n\t\t\t * The target has requested a retry.\n\t\t\t * Re-assert ATN, reset our message index to\n\t\t\t * 0, and try again.\n\t\t\t */\n\t\t\tahc->msgout_index = 0;\n\t\t\tahc_outb(ahc, SCSISIGO, ahc_inb(ahc, SCSISIGO) | ATNO);\n\t\t}\n\n\t\tlastbyte = ahc->msgout_index == (ahc->msgout_len - 1);\n\t\tif (lastbyte) {\n\t\t\t/* Last byte is signified by dropping ATN */\n\t\t\tahc_outb(ahc, CLRSINT1, CLRATNO);\n\t\t}\n\n\t\t/*\n\t\t * Clear our interrupt status and present\n\t\t * the next byte on the bus.\n\t\t */\n\t\tahc_outb(ahc, CLRSINT1, CLRREQINIT);\n\t\tahc_outb(ahc, SCSIDATL, ahc->msgout_buf[ahc->msgout_index++]);\n\t\tbreak;\n\t}\n\tcase MSG_TYPE_INITIATOR_MSGIN:\n\t{\n\t\tint phasemis;\n\t\tint message_done;\n\n\t\tphasemis = bus_phase != P_MESGIN;\n\n\t\tif (phasemis) {\n\t\t\tahc->msgin_index = 0;\n\t\t\tif (bus_phase == P_MESGOUT\n\t\t\t && (ahc->send_msg_perror == TRUE\n\t\t\t  || (ahc->msgout_len != 0\n\t\t\t   && ahc->msgout_index == 0))) {\n\t\t\t\tahc->msg_type = MSG_TYPE_INITIATOR_MSGOUT;\n\t\t\t\tgoto reswitch;\n\t\t\t}\n\t\t\tend_session = TRUE;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Pull the byte in without acking it */\n\t\tahc->msgin_buf[ahc->msgin_index] = ahc_inb(ahc, SCSIBUSL);\n\n\t\tmessage_done = ahc_parse_msg(ahc, sc_link, &devinfo);\n\n\t\tif (message_done) {\n\t\t\t/*\n\t\t\t * Clear our incoming message buffer in case there\n\t\t\t * is another message following this one.\n\t\t\t */\n\t\t\tahc->msgin_index = 0;\n\n\t\t\t/*\n\t\t\t * If this message illicited a response,\n\t\t\t * assert ATN so the target takes us to the\n\t\t\t * message out phase.\n\t\t\t */\n\t\t\tif (ahc->msgout_len != 0)\n\t\t\t\tahc_outb(ahc, SCSISIGO,\n\t\t\t\t\t ahc_inb(ahc, SCSISIGO) | ATNO);\n\t\t} else \n\t\t\tahc->msgin_index++;\n\n\t\t/* Ack the byte */\n\t\tahc_outb(ahc, CLRSINT1, CLRREQINIT);\n\t\tahc_inb(ahc, SCSIDATL);\n\t\tbreak;\n\t}\n\tcase MSG_TYPE_TARGET_MSGIN:\n\t{\n\t\tint msgdone;\n\t\tint msgout_request;\n\n\t\tif (ahc->msgout_len == 0)\n\t\t\tpanic(\"Target MSGIN with no active message\");\n\n\t\t/*\n\t\t * If we interrupted a mesgout session, the initiator\n\t\t * will not know this until our first REQ.  So, we\n\t\t * only honor mesgout requests after we've sent our\n\t\t * first byte.\n\t\t */\n\t\tif ((ahc_inb(ahc, SCSISIGI) & ATNI) != 0\n\t\t && ahc->msgout_index > 0)\n\t\t\tmsgout_request = TRUE;\n\t\telse\n\t\t\tmsgout_request = FALSE;\n\n\t\tif (msgout_request) {\n\n\t\t\t/*\n\t\t\t * Change gears and see if\n\t\t\t * this messages is of interest to\n\t\t\t * us or should be passed back to\n\t\t\t * the sequencer.\n\t\t\t */\n\t\t\tahc->msg_type = MSG_TYPE_TARGET_MSGOUT;\n\t\t\tahc_outb(ahc, SCSISIGO, P_MESGOUT | BSYO);\n\t\t\tahc->msgin_index = 0;\n\t\t\t/* Dummy read to REQ for first byte */\n\t\t\tahc_inb(ahc, SCSIDATL);\n\t\t\tahc_outb(ahc, SXFRCTL0,\n\t\t\t\t ahc_inb(ahc, SXFRCTL0) | SPIOEN);\n\t\t\tbreak;\n\t\t}\n\n\t\tmsgdone = ahc->msgout_index == ahc->msgout_len;\n\t\tif (msgdone) {\n\t\t\tahc_outb(ahc, SXFRCTL0,\n\t\t\t\t ahc_inb(ahc, SXFRCTL0) & ~SPIOEN);\n\t\t\tend_session = TRUE;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Present the next byte on the bus.\n\t\t */\n\t\tahc_outb(ahc, SXFRCTL0, ahc_inb(ahc, SXFRCTL0) | SPIOEN);\n\t\tahc_outb(ahc, SCSIDATL, ahc->msgout_buf[ahc->msgout_index++]);\n\t\tbreak;\n\t}\n\tcase MSG_TYPE_TARGET_MSGOUT:\n\t{\n\t\tint lastbyte;\n\t\tint msgdone;\n\n\t\t/*\n\t\t * The initiator signals that this is\n\t\t * the last byte by dropping ATN.\n\t\t */\n\t\tlastbyte = (ahc_inb(ahc, SCSISIGI) & ATNI) == 0;\n\n\t\t/*\n\t\t * Read the latched byte, but turn off SPIOEN first\n\t\t * so that we don't inadvertantly cause a REQ for the\n\t\t * next byte.\n\t\t */\n\t\tahc_outb(ahc, SXFRCTL0, ahc_inb(ahc, SXFRCTL0) & ~SPIOEN);\n\t\tahc->msgin_buf[ahc->msgin_index] = ahc_inb(ahc, SCSIDATL);\n\t\tmsgdone = ahc_parse_msg(ahc, sc_link, &devinfo);\n\t\tif (msgdone == MSGLOOP_TERMINATED) {\n\t\t\t/*\n\t\t\t * The message is *really* done in that it caused\n\t\t\t * us to go to bus free.  The sequencer has already\n\t\t\t * been reset at this point, so pull the ejection\n\t\t\t * handle.\n\t\t\t */\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tahc->msgin_index++;\n\n\t\t/*\n\t\t * XXX Read spec about initiator dropping ATN too soon\n\t\t *     and use msgdone to detect it.\n\t\t */\n\t\tif (msgdone == MSGLOOP_MSGCOMPLETE) {\n\t\t\tahc->msgin_index = 0;\n\n\t\t\t/*\n\t\t\t * If this message illicited a response, transition\n\t\t\t * to the Message in phase and send it.\n\t\t\t */\n\t\t\tif (ahc->msgout_len != 0) {\n\t\t\t\tahc_outb(ahc, SCSISIGO, P_MESGIN | BSYO);\n\t\t\t\tahc_outb(ahc, SXFRCTL0,\n\t\t\t\t\t ahc_inb(ahc, SXFRCTL0) | SPIOEN);\n\t\t\t\tahc->msg_type = MSG_TYPE_TARGET_MSGIN;\n\t\t\t\tahc->msgin_index = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (lastbyte)\n\t\t\tend_session = TRUE;\n\t\telse {\n\t\t\t/* Ask for the next byte. */\n\t\t\tahc_outb(ahc, SXFRCTL0,\n\t\t\t\t ahc_inb(ahc, SXFRCTL0) | SPIOEN);\n\t\t}\n\n\t\tbreak;\n\t}\n\tdefault:\n\t\tpanic(\"Unknown REQINIT message type\");\n\t}\n\n\tif (end_session) {\n\t\tahc_clear_msg_state(ahc);\n\t\tahc_outb(ahc, RETURN_1, EXIT_MSG_LOOP);\n\t} else\n\t\tahc_outb(ahc, RETURN_1, CONT_MSG_LOOP);\n}"
  },
  {
    "function_name": "ahc_clear_msg_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "2680-2688",
    "snippet": "STATIC void\nahc_clear_msg_state(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tahc->msgout_len = 0;\n\tahc->msgin_index = 0;\n\tahc->msg_type = MSG_TYPE_NONE;\n\tahc_outb(ahc, MSG_OUT, MSG_NOOP);\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define STATIC\tstatic",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "MSG_OUT",
            "MSG_NOOP"
          ],
          "line": 2687
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_clear_msg_state(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tahc->msgout_len = 0;\n\tahc->msgin_index = 0;\n\tahc->msg_type = MSG_TYPE_NONE;\n\tahc_outb(ahc, MSG_OUT, MSG_NOOP);\n}"
  },
  {
    "function_name": "ahc_handle_msg_reject",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "2573-2678",
    "snippet": "STATIC int\nahc_handle_msg_reject(ahc, devinfo)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n{\n\t/*\n\t * What we care about here is if we had an\n\t * outstanding SDTR or WDTR message for this\n\t * target.  If we did, this is a signal that\n\t * the target is refusing negotiation.\n\t */\n\tstruct scb *scb;\n\tu_int scb_index;\n\tu_int last_msg;\n\tint   response = 0;\n\n\tscb_index = ahc_inb(ahc, SCB_TAG);\n\tscb = &ahc->scb_data->scbarray[scb_index];\n\n\t/* Might be necessary */\n\tlast_msg = ahc_inb(ahc, LAST_MSG);\n\n\tif (ahc_sent_msg(ahc, MSG_EXT_WDTR, /*full*/FALSE)) {\n\t\tstruct ahc_initiator_tinfo *tinfo;\n\t\tstruct tmode_tstate *tstate;\n\n\t\t/* note 8bit xfers */\n\t\tif (bootverbose)\n\t\t\tprintf(\"%s:%c:%d: refuses WIDE negotiation.  Using \"\n\t\t\t       \"8bit transfers\\n\", ahc_name(ahc),\n\t\t\t       devinfo->channel, devinfo->target);\n\t\tahc_set_width(ahc, devinfo,\n\t\t\t      MSG_EXT_WDTR_BUS_8_BIT,\n\t\t\t      AHC_TRANS_ACTIVE|AHC_TRANS_GOAL,\n\t\t\t      /*paused*/TRUE, /*done*/TRUE);\n\t\t/*\n\t\t * No need to clear the sync rate.  If the target\n\t\t * did not accept the command, our syncrate is\n\t\t * unaffected.  If the target started the negotiation,\n\t\t * but rejected our response, we already cleared the\n\t\t * sync rate before sending our WDTR.\n\t\t */\n\t\ttinfo = ahc_fetch_transinfo(ahc, devinfo->channel,\n\t\t\t\t\t    devinfo->our_scsiid,\n\t\t\t\t\t    devinfo->target, &tstate);\n\t\tif (tinfo->goal.period) {\n\t\t\tu_int period;\n\n\t\t\t/* Start the sync negotiation */\n\t\t\tperiod = tinfo->goal.period;\n\t\t\tahc_devlimited_syncrate(ahc, &period);\n\t\t\tahc->msgout_index = 0;\n\t\t\tahc->msgout_len = 0;\n\t\t\tahc_construct_sdtr(ahc, period, tinfo->goal.offset);\n\t\t\tahc->msgout_index = 0;\n\t\t\tresponse = 1;\n\t\t}\n\t} else if (ahc_sent_msg(ahc, MSG_EXT_SDTR, /*full*/FALSE)) {\n\t\t/* note asynch xfers and clear flag */\n\t\tahc_set_syncrate(ahc, devinfo, /*syncrate*/NULL, /*period*/0,\n\t\t\t\t /*offset*/0,\n\t\t\t\t AHC_TRANS_ACTIVE|AHC_TRANS_GOAL,\n\t\t\t\t /*paused*/TRUE,\n\t\t\t\t /*done*/TRUE);\n\t\tif (bootverbose)\n\t\t\tprintf(\"%s:%c:%d: refuses synchronous negotiation. \"\n\t\t\t       \"Using asynchronous transfers\\n\",\n\t\t\t       ahc_name(ahc),\n\t\t\t       devinfo->channel, devinfo->target);\n\t} else if ((scb->hscb->control & MSG_SIMPLE_Q_TAG) != 0) {\n\t\tif (bootverbose)\n\t\t\tprintf(\"%s:%c:%d: refuses tagged commands.  Performing \"\n\t\t\t       \"non-tagged I/O\\n\", ahc_name(ahc),\n\t\t\t       devinfo->channel, devinfo->target);\n\t\t\t\n\t\tahc_set_tags(ahc, devinfo, FALSE);\n\n\t\t/*\n\t\t * Resend the identify for this CCB as the target\n\t\t * may believe that the selection is invalid otherwise.\n\t\t */\n\t\tahc_outb(ahc, SCB_CONTROL, ahc_inb(ahc, SCB_CONTROL)\n\t\t\t\t\t  & ~MSG_SIMPLE_Q_TAG);\n\t \tscb->hscb->control &= ~MSG_SIMPLE_Q_TAG;\n\t\tahc_outb(ahc, MSG_OUT, MSG_IDENTIFYFLAG);\n\t\tahc_outb(ahc, SCSISIGO, ahc_inb(ahc, SCSISIGO) | ATNO);\n\n\t\t/*\n\t\t * Requeue all tagged commands for this target\n\t\t * currently in our posession so they can be\n\t\t * converted to untagged commands.\n\t\t */\n\t\tahc_search_qinfifo(ahc, SCB_TARGET(scb), SCB_CHANNEL(scb),\n\t\t\t\t   SCB_LUN(scb), /*tag*/SCB_LIST_NULL,\n\t\t\t\t   ROLE_INITIATOR, SCB_REQUEUE,\n\t\t\t\t   SEARCH_COMPLETE);\n\t} else {\n\t\t/*\n\t\t * Otherwise, we ignore it.\n\t\t */\n\t\tprintf(\"%s:%c:%d: Message reject for %x -- ignored\\n\",\n\t\t       ahc_name(ahc), devinfo->channel, devinfo->target,\n\t\t       last_msg);\n\t}\n\treturn (response);\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define STATIC\tstatic",
      "#define bootverbose\t0",
      "#define STATIC",
      "#define bootverbose\t1"
    ],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
      "STATIC void",
      "STATIC void",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
      "STATIC void",
      "STATIC u_int",
      "STATIC void",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
      "STATIC void",
      "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
      "STATIC void",
      "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
      "STATIC int",
      "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
      "STATIC void",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC int",
      "ahc_sent_msg __P((struct ahc_softc *ahc, u_int msgtype,\n\t\t\t\t  int full));",
      "STATIC int",
      "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
      "STATIC void",
      "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
      "STATIC void",
      "STATIC void",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC u_int",
      "STATIC void",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "STATIC u_int",
      "STATIC void",
      "STATIC void",
      "ahc_update_target_msg_request __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t\t      struct ahc_initiator_tinfo *tinfo,\n\t\t\t\t\t      int force, int paused));",
      "STATIC void",
      "ahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));",
      "STATIC void",
      "ahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "ahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));",
      "STATIC void",
      "STATIC void",
      "ahc_calc_residual __P((struct scb *scb));",
      "STATIC void",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
      "STATIC void",
      "STATIC void",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "static __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo",
      "STATIC void",
      "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
      "STATIC void",
      "STATIC void",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "char channel;",
      "struct tmode_tstate **tstate;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "u_int *period;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "u_int *period;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "char channel;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s:%c:%d: Message reject for %x -- ignored\\n\"",
            "ahc_name(ahc)",
            "devinfo->channel",
            "devinfo->target",
            "last_msg"
          ],
          "line": 2673
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 2674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_search_qinfifo",
          "args": [
            "ahc",
            "SCB_TARGET(scb)",
            "SCB_CHANNEL(scb)",
            "SCB_LUN(scb)",
            "/*tag*/SCB_LIST_NULL",
            "ROLE_INITIATOR",
            "SCB_REQUEUE",
            "SEARCH_COMPLETE"
          ],
          "line": 2665
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_search_qinfifo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "5055-5121",
          "snippet": "STATIC int\nahc_search_qinfifo(ahc, target, channel, lun, tag, role, status, action)\n\tstruct ahc_softc *ahc;\n\tint target;\n\tchar channel;\n\tint lun;\n\tu_int tag;\n\trole_t role;\n\tu_int32_t status;\n\tahc_search_action action;\n{\n\tstruct\t scb *scbp;\n\tu_int8_t qinpos;\n\tu_int8_t qintail;\n\tint\t found;\n\n\tqinpos = ahc_inb(ahc, QINPOS);\n\tqintail = ahc->qinfifonext;\n\tfound = 0;\n\n\t/*\n\t * Start with an empty queue.  Entries that are not chosen\n\t * for removal will be re-added to the queue as we go.\n\t */\n\tahc->qinfifonext = qinpos;\n\tbus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, \n\t\t\tBUS_DMASYNC_POSTREAD);\n\n\twhile (qinpos != qintail) {\n\t\tscbp = &ahc->scb_data->scbarray[ahc->qinfifo[qinpos]];\n\t\tif (ahc_match_scb(scbp, target, channel, lun, tag, role)) {\n\t\t\t/*\n\t\t\t * We found an scb that needs to be removed.\n\t\t\t */\n\t\t\tswitch (action) {\n\t\t\tcase SEARCH_COMPLETE:\n\t\t\t\tif (!(scbp->xs->flags & ITSDONE)) {\n\t\t\t\t\tscbp->flags |= status;\n\t\t\t\t\tscbp->xs->error = XS_NOERROR;\n\t\t\t\t}\n\t\t\t\tahc_freeze_ccb(scbp);\n\t\t\t\tahc_done(ahc, scbp);\n\t\t\t\tbreak;\n\t\t\tcase SEARCH_COUNT:\n\t\t\t\tahc->qinfifo[ahc->qinfifonext++] =\n\t\t\t\t    scbp->hscb->tag;\n\t\t\t\tbreak;\n\t\t\tcase SEARCH_REMOVE:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfound++;\n\t\t} else {\n\t\t\tahc->qinfifo[ahc->qinfifonext++] = scbp->hscb->tag;\n\t\t}\n\t\tqinpos++;\n\t}\n\tbus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, \n\t\t\tBUS_DMASYNC_PREWRITE);\n\t\n\tif ((ahc->features & AHC_QUEUE_REGS) != 0) {\n\t\tahc_outb(ahc, HNSCB_QOFF, ahc->qinfifonext);\n\t} else {\n\t\tahc_outb(ahc, KERNEL_QINPOS, ahc->qinfifonext);\n\t}\n\n\treturn (found);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "ahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));",
            "STATIC u_int",
            "STATIC void",
            "ahc_done __P((struct ahc_softc *ahc, struct scb *scbp));",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "ahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));",
            "STATIC int",
            "ahc_search_qinfifo __P((struct ahc_softc *ahc, int target,\n\t\t\t\t\tchar channel, int lun, u_int tag,\n\t\t\t\t\trole_t role, u_int32_t status,\n\t\t\t\t\tahc_search_action action));",
            "STATIC int",
            "STATIC int",
            "ahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
            "STATIC void",
            "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_calc_residual __P((struct scb *scb));",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "static __inline void ahc_freeze_ccb",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *xs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));\nSTATIC u_int;\nSTATIC void;\nahc_done __P((struct ahc_softc *ahc, struct scb *scbp));\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));\nSTATIC int;\nahc_search_qinfifo __P((struct ahc_softc *ahc, int target,\n\t\t\t\t\tchar channel, int lun, u_int tag,\n\t\t\t\t\trole_t role, u_int32_t status,\n\t\t\t\t\tahc_search_action action));\nSTATIC int;\nSTATIC int;\nahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nSTATIC void;\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_calc_residual __P((struct scb *scb));\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nstatic __inline void ahc_freeze_ccb;\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n\nSTATIC int\nahc_search_qinfifo(ahc, target, channel, lun, tag, role, status, action)\n\tstruct ahc_softc *ahc;\n\tint target;\n\tchar channel;\n\tint lun;\n\tu_int tag;\n\trole_t role;\n\tu_int32_t status;\n\tahc_search_action action;\n{\n\tstruct\t scb *scbp;\n\tu_int8_t qinpos;\n\tu_int8_t qintail;\n\tint\t found;\n\n\tqinpos = ahc_inb(ahc, QINPOS);\n\tqintail = ahc->qinfifonext;\n\tfound = 0;\n\n\t/*\n\t * Start with an empty queue.  Entries that are not chosen\n\t * for removal will be re-added to the queue as we go.\n\t */\n\tahc->qinfifonext = qinpos;\n\tbus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, \n\t\t\tBUS_DMASYNC_POSTREAD);\n\n\twhile (qinpos != qintail) {\n\t\tscbp = &ahc->scb_data->scbarray[ahc->qinfifo[qinpos]];\n\t\tif (ahc_match_scb(scbp, target, channel, lun, tag, role)) {\n\t\t\t/*\n\t\t\t * We found an scb that needs to be removed.\n\t\t\t */\n\t\t\tswitch (action) {\n\t\t\tcase SEARCH_COMPLETE:\n\t\t\t\tif (!(scbp->xs->flags & ITSDONE)) {\n\t\t\t\t\tscbp->flags |= status;\n\t\t\t\t\tscbp->xs->error = XS_NOERROR;\n\t\t\t\t}\n\t\t\t\tahc_freeze_ccb(scbp);\n\t\t\t\tahc_done(ahc, scbp);\n\t\t\t\tbreak;\n\t\t\tcase SEARCH_COUNT:\n\t\t\t\tahc->qinfifo[ahc->qinfifonext++] =\n\t\t\t\t    scbp->hscb->tag;\n\t\t\t\tbreak;\n\t\t\tcase SEARCH_REMOVE:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfound++;\n\t\t} else {\n\t\t\tahc->qinfifo[ahc->qinfifonext++] = scbp->hscb->tag;\n\t\t}\n\t\tqinpos++;\n\t}\n\tbus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, \n\t\t\tBUS_DMASYNC_PREWRITE);\n\t\n\tif ((ahc->features & AHC_QUEUE_REGS) != 0) {\n\t\tahc_outb(ahc, HNSCB_QOFF, ahc->qinfifonext);\n\t} else {\n\t\tahc_outb(ahc, KERNEL_QINPOS, ahc->qinfifonext);\n\t}\n\n\treturn (found);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SCB_LUN",
          "args": [
            "scb"
          ],
          "line": 2666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCB_CHANNEL",
          "args": [
            "scb"
          ],
          "line": 2665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCB_TARGET",
          "args": [
            "scb"
          ],
          "line": 2665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCSISIGO",
            "ahc_inb(ahc, SCSISIGO) | ATNO"
          ],
          "line": 2658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCSISIGO"
          ],
          "line": 2658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "MSG_OUT",
            "MSG_IDENTIFYFLAG"
          ],
          "line": 2657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCB_CONTROL",
            "ahc_inb(ahc, SCB_CONTROL)\n\t\t\t\t\t  & ~MSG_SIMPLE_Q_TAG"
          ],
          "line": 2654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCB_CONTROL"
          ],
          "line": 2654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_set_tags",
          "args": [
            "ahc",
            "devinfo",
            "FALSE"
          ],
          "line": 2648
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_set_tags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "1459-1476",
          "snippet": "STATIC void\nahc_set_tags(ahc, devinfo, enable)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n\tint enable;\n{\n\tstruct ahc_initiator_tinfo *tinfo;\n\tstruct tmode_tstate *tstate;\n\n\ttinfo = ahc_fetch_transinfo(ahc, devinfo->channel,\n\t\t\t\t    devinfo->our_scsiid,\n\t\t\t\t    devinfo->target,\n\t\t\t\t    &tstate);\n\tif (enable)\n\t\ttstate->tagenable |= devinfo->target_mask;\n\telse\n\t\ttstate->tagenable &= ~devinfo->target_mask;\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC int",
            "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_set_tags __P((struct ahc_softc *ahc,\n\t\t\t\t  struct ahc_devinfo *devinfo,int enable));",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "static __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct tmode_tstate **tstate;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_set_tags __P((struct ahc_softc *ahc,\n\t\t\t\t  struct ahc_devinfo *devinfo,int enable));\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct tmode_tstate **tstate;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_set_tags(ahc, devinfo, enable)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n\tint enable;\n{\n\tstruct ahc_initiator_tinfo *tinfo;\n\tstruct tmode_tstate *tstate;\n\n\ttinfo = ahc_fetch_transinfo(ahc, devinfo->channel,\n\t\t\t\t    devinfo->our_scsiid,\n\t\t\t\t    devinfo->target,\n\t\t\t\t    &tstate);\n\tif (enable)\n\t\ttstate->tagenable |= devinfo->target_mask;\n\telse\n\t\ttstate->tagenable &= ~devinfo->target_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 2645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 2640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_set_syncrate",
          "args": [
            "ahc",
            "devinfo",
            "/*syncrate*/NULL",
            "/*period*/0",
            "/*offset*/0",
            "AHC_TRANS_ACTIVE|AHC_TRANS_GOAL",
            "/*paused*/TRUE",
            "/*done*/TRUE"
          ],
          "line": 2632
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_set_syncrate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "1297-1406",
          "snippet": "STATIC void\nahc_set_syncrate(ahc, devinfo, syncrate, period, offset, type, paused, done)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n\tstruct ahc_syncrate *syncrate;\n\tu_int period;\n\tu_int offset;\n\tu_int type;\n\tint paused;\n\tint done;\n{\n\tstruct\tahc_initiator_tinfo *tinfo;\n\tstruct\ttmode_tstate *tstate;\n\tu_int\told_period;\n\tu_int\told_offset;\n\tint\tactive = (type & AHC_TRANS_ACTIVE) == AHC_TRANS_ACTIVE;\n\n\tif (syncrate == NULL) {\n\t\tperiod = 0;\n\t\toffset = 0;\n\t}\n\n\ttinfo = ahc_fetch_transinfo(ahc, devinfo->channel,\n\t\t\t\t    devinfo->our_scsiid,\n\t\t\t\t    devinfo->target, &tstate);\n\told_period = tinfo->current.period;\n\told_offset = tinfo->current.offset;\n\n\tif ((type & AHC_TRANS_CUR) != 0\n\t && (old_period != period || old_offset != offset)) {\n\t\tu_int\tscsirate;\n\n\t\tscsirate = tinfo->scsirate;\n\t\tif ((ahc->features & AHC_ULTRA2) != 0) {\n\n\t\t\t/* XXX */\n\t\t\t/* Force single edge until DT is fully implemented */\n\t\t\tscsirate &= ~(SXFR_ULTRA2|SINGLE_EDGE|ENABLE_CRC);\n\t\t\tif (syncrate != NULL)\n\t\t\t\tscsirate |= syncrate->sxfr_u2|SINGLE_EDGE;\n\n\t\t\tif (active)\n\t\t\t\tahc_outb(ahc, SCSIOFFSET, offset);\n\t\t} else {\n\n\t\t\tscsirate &= ~(SXFR|SOFS);\n\t\t\t/*\n\t\t\t * Ensure Ultra mode is set properly for\n\t\t\t * this target.\n\t\t\t */\n\t\t\ttstate->ultraenb &= ~devinfo->target_mask;\n\t\t\tif (syncrate != NULL) {\n\t\t\t\tif (syncrate->sxfr & ULTRA_SXFR) {\n\t\t\t\t\ttstate->ultraenb |=\n\t\t\t\t\t\tdevinfo->target_mask;\n\t\t\t\t}\n\t\t\t\tscsirate |= syncrate->sxfr & SXFR;\n\t\t\t\tscsirate |= offset & SOFS;\n\t\t\t}\n\t\t\tif (active) {\n\t\t\t\tu_int sxfrctl0;\n\n\t\t\t\tsxfrctl0 = ahc_inb(ahc, SXFRCTL0);\n\t\t\t\tsxfrctl0 &= ~FAST20;\n\t\t\t\tif (tstate->ultraenb & devinfo->target_mask)\n\t\t\t\t\tsxfrctl0 |= FAST20;\n\t\t\t\tahc_outb(ahc, SXFRCTL0, sxfrctl0);\n\t\t\t}\n\t\t}\n\t\tif (active)\n\t\t\tahc_outb(ahc, SCSIRATE, scsirate);\n\n\t\ttinfo->scsirate = scsirate;\n\t\ttinfo->current.period = period;\n\t\ttinfo->current.offset = offset;\n\n\t\t/* Update the syncrates in any pending scbs */\n\t\tahc_update_pending_syncrates(ahc);\n\t}\n\n\t/*\n\t * Print messages if we're verbose and at the end of a negotiation\n\t * cycle.\n\t */\n\tif (done) {\n\t\tif (offset != 0) {\n\t\t\tprintf(\"%s: target %d synchronous at %sMHz, \"\n\t\t\t       \"offset = 0x%x\\n\", ahc_name(ahc),\n\t\t\t       devinfo->target, syncrate->rate, offset);\n\t\t} else {\n\t\t\tprintf(\"%s: target %d using \"\n\t\t\t       \"asynchronous transfers\\n\",\n\t\t\t       ahc_name(ahc), devinfo->target);\n\t\t}\n\t}\n\n\tif ((type & AHC_TRANS_GOAL) != 0) {\n\t\ttinfo->goal.period = period;\n\t\ttinfo->goal.offset = offset;\n\t}\n\n\tif ((type & AHC_TRANS_USER) != 0) {\n\t\ttinfo->user.period = period;\n\t\ttinfo->user.offset = offset;\n\t}\n\n\tahc_update_target_msg_request(ahc, devinfo, tinfo,\n\t\t\t\t      /*force*/FALSE,\n\t\t\t\t      paused);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC int",
            "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "ahc_update_target_msg_request __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t\t      struct ahc_initiator_tinfo *tinfo,\n\t\t\t\t\t      int force, int paused));",
            "STATIC void",
            "ahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));",
            "STATIC void",
            "ahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "static __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct tmode_tstate **tstate;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "u_int *period;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "u_int *period;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nahc_update_target_msg_request __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t\t      struct ahc_initiator_tinfo *tinfo,\n\t\t\t\t\t      int force, int paused));\nSTATIC void;\nahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));\nSTATIC void;\nahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct tmode_tstate **tstate;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_set_syncrate(ahc, devinfo, syncrate, period, offset, type, paused, done)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n\tstruct ahc_syncrate *syncrate;\n\tu_int period;\n\tu_int offset;\n\tu_int type;\n\tint paused;\n\tint done;\n{\n\tstruct\tahc_initiator_tinfo *tinfo;\n\tstruct\ttmode_tstate *tstate;\n\tu_int\told_period;\n\tu_int\told_offset;\n\tint\tactive = (type & AHC_TRANS_ACTIVE) == AHC_TRANS_ACTIVE;\n\n\tif (syncrate == NULL) {\n\t\tperiod = 0;\n\t\toffset = 0;\n\t}\n\n\ttinfo = ahc_fetch_transinfo(ahc, devinfo->channel,\n\t\t\t\t    devinfo->our_scsiid,\n\t\t\t\t    devinfo->target, &tstate);\n\told_period = tinfo->current.period;\n\told_offset = tinfo->current.offset;\n\n\tif ((type & AHC_TRANS_CUR) != 0\n\t && (old_period != period || old_offset != offset)) {\n\t\tu_int\tscsirate;\n\n\t\tscsirate = tinfo->scsirate;\n\t\tif ((ahc->features & AHC_ULTRA2) != 0) {\n\n\t\t\t/* XXX */\n\t\t\t/* Force single edge until DT is fully implemented */\n\t\t\tscsirate &= ~(SXFR_ULTRA2|SINGLE_EDGE|ENABLE_CRC);\n\t\t\tif (syncrate != NULL)\n\t\t\t\tscsirate |= syncrate->sxfr_u2|SINGLE_EDGE;\n\n\t\t\tif (active)\n\t\t\t\tahc_outb(ahc, SCSIOFFSET, offset);\n\t\t} else {\n\n\t\t\tscsirate &= ~(SXFR|SOFS);\n\t\t\t/*\n\t\t\t * Ensure Ultra mode is set properly for\n\t\t\t * this target.\n\t\t\t */\n\t\t\ttstate->ultraenb &= ~devinfo->target_mask;\n\t\t\tif (syncrate != NULL) {\n\t\t\t\tif (syncrate->sxfr & ULTRA_SXFR) {\n\t\t\t\t\ttstate->ultraenb |=\n\t\t\t\t\t\tdevinfo->target_mask;\n\t\t\t\t}\n\t\t\t\tscsirate |= syncrate->sxfr & SXFR;\n\t\t\t\tscsirate |= offset & SOFS;\n\t\t\t}\n\t\t\tif (active) {\n\t\t\t\tu_int sxfrctl0;\n\n\t\t\t\tsxfrctl0 = ahc_inb(ahc, SXFRCTL0);\n\t\t\t\tsxfrctl0 &= ~FAST20;\n\t\t\t\tif (tstate->ultraenb & devinfo->target_mask)\n\t\t\t\t\tsxfrctl0 |= FAST20;\n\t\t\t\tahc_outb(ahc, SXFRCTL0, sxfrctl0);\n\t\t\t}\n\t\t}\n\t\tif (active)\n\t\t\tahc_outb(ahc, SCSIRATE, scsirate);\n\n\t\ttinfo->scsirate = scsirate;\n\t\ttinfo->current.period = period;\n\t\ttinfo->current.offset = offset;\n\n\t\t/* Update the syncrates in any pending scbs */\n\t\tahc_update_pending_syncrates(ahc);\n\t}\n\n\t/*\n\t * Print messages if we're verbose and at the end of a negotiation\n\t * cycle.\n\t */\n\tif (done) {\n\t\tif (offset != 0) {\n\t\t\tprintf(\"%s: target %d synchronous at %sMHz, \"\n\t\t\t       \"offset = 0x%x\\n\", ahc_name(ahc),\n\t\t\t       devinfo->target, syncrate->rate, offset);\n\t\t} else {\n\t\t\tprintf(\"%s: target %d using \"\n\t\t\t       \"asynchronous transfers\\n\",\n\t\t\t       ahc_name(ahc), devinfo->target);\n\t\t}\n\t}\n\n\tif ((type & AHC_TRANS_GOAL) != 0) {\n\t\ttinfo->goal.period = period;\n\t\ttinfo->goal.offset = offset;\n\t}\n\n\tif ((type & AHC_TRANS_USER) != 0) {\n\t\ttinfo->user.period = period;\n\t\ttinfo->user.offset = offset;\n\t}\n\n\tahc_update_target_msg_request(ahc, devinfo, tinfo,\n\t\t\t\t      /*force*/FALSE,\n\t\t\t\t      paused);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_sent_msg",
          "args": [
            "ahc",
            "MSG_EXT_SDTR",
            "/*full*/FALSE"
          ],
          "line": 2630
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_sent_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "2945-2984",
          "snippet": "STATIC int\nahc_sent_msg(ahc, msgtype, full)\n\tstruct ahc_softc *ahc;\n\tu_int msgtype;\n\tint full;\n{\n\tint found;\n\tint index;\n\n\tfound = FALSE;\n\tindex = 0;\n\n\twhile (index < ahc->msgout_len) {\n\t\tif (ahc->msgout_buf[index] == MSG_EXTENDED) {\n\n\t\t\t/* Found a candidate */\n\t\t\tif (ahc->msgout_buf[index+2] == msgtype) {\n\t\t\t\tu_int end_index;\n\n\t\t\t\tend_index = index + 1\n\t\t\t\t\t  + ahc->msgout_buf[index + 1];\n\t\t\t\tif (full) {\n\t\t\t\t\tif (ahc->msgout_index > end_index)\n\t\t\t\t\t\tfound = TRUE;\n\t\t\t\t} else if (ahc->msgout_index > index)\n\t\t\t\t\tfound = TRUE;\n\t\t\t}\n\t\t\tbreak;\n\t\t} else if (ahc->msgout_buf[index] >= MSG_SIMPLE_Q_TAG\n\t\t\t&& ahc->msgout_buf[index] <= MSG_IGN_WIDE_RESIDUE) {\n\n\t\t\t/* Skip tag type and tag id or residue param*/\n\t\t\tindex += 2;\n\t\t} else {\n\t\t\t/* Single byte message */\n\t\t\tindex++;\n\t\t}\n\t}\n\treturn (found);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "ahc_sent_msg __P((struct ahc_softc *ahc, u_int msgtype,\n\t\t\t\t  int full));",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nahc_sent_msg __P((struct ahc_softc *ahc, u_int msgtype,\n\t\t\t\t  int full));\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC int\nahc_sent_msg(ahc, msgtype, full)\n\tstruct ahc_softc *ahc;\n\tu_int msgtype;\n\tint full;\n{\n\tint found;\n\tint index;\n\n\tfound = FALSE;\n\tindex = 0;\n\n\twhile (index < ahc->msgout_len) {\n\t\tif (ahc->msgout_buf[index] == MSG_EXTENDED) {\n\n\t\t\t/* Found a candidate */\n\t\t\tif (ahc->msgout_buf[index+2] == msgtype) {\n\t\t\t\tu_int end_index;\n\n\t\t\t\tend_index = index + 1\n\t\t\t\t\t  + ahc->msgout_buf[index + 1];\n\t\t\t\tif (full) {\n\t\t\t\t\tif (ahc->msgout_index > end_index)\n\t\t\t\t\t\tfound = TRUE;\n\t\t\t\t} else if (ahc->msgout_index > index)\n\t\t\t\t\tfound = TRUE;\n\t\t\t}\n\t\t\tbreak;\n\t\t} else if (ahc->msgout_buf[index] >= MSG_SIMPLE_Q_TAG\n\t\t\t&& ahc->msgout_buf[index] <= MSG_IGN_WIDE_RESIDUE) {\n\n\t\t\t/* Skip tag type and tag id or residue param*/\n\t\t\tindex += 2;\n\t\t} else {\n\t\t\t/* Single byte message */\n\t\t\tindex++;\n\t\t}\n\t}\n\treturn (found);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_construct_sdtr",
          "args": [
            "ahc",
            "period",
            "tinfo->goal.offset"
          ],
          "line": 2626
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_construct_sdtr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "5551-5563",
          "snippet": "STATIC void\nahc_construct_sdtr(ahc, period, offset)\n\tstruct ahc_softc *ahc;\n\tu_int period;\n\tu_int offset;\n{\n\tahc->msgout_buf[ahc->msgout_index++] = MSG_EXTENDED;\n\tahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_SDTR_LEN;\n\tahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_SDTR;\n\tahc->msgout_buf[ahc->msgout_index++] = period;\n\tahc->msgout_buf[ahc->msgout_index++] = offset;\n\tahc->msgout_len += 5;\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "u_int *period;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "u_int *period;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_construct_sdtr(ahc, period, offset)\n\tstruct ahc_softc *ahc;\n\tu_int period;\n\tu_int offset;\n{\n\tahc->msgout_buf[ahc->msgout_index++] = MSG_EXTENDED;\n\tahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_SDTR_LEN;\n\tahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_SDTR;\n\tahc->msgout_buf[ahc->msgout_index++] = period;\n\tahc->msgout_buf[ahc->msgout_index++] = offset;\n\tahc->msgout_len += 5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_devlimited_syncrate",
          "args": [
            "ahc",
            "&period"
          ],
          "line": 2623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_fetch_transinfo",
          "args": [
            "ahc",
            "devinfo->channel",
            "devinfo->our_scsiid",
            "devinfo->target",
            "&tstate"
          ],
          "line": 2615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_set_width",
          "args": [
            "ahc",
            "devinfo",
            "MSG_EXT_WDTR_BUS_8_BIT",
            "AHC_TRANS_ACTIVE|AHC_TRANS_GOAL",
            "/*paused*/TRUE",
            "/*done*/TRUE"
          ],
          "line": 2604
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_set_width",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "1408-1457",
          "snippet": "STATIC void\nahc_set_width(ahc, devinfo, width, type, paused, done)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n\tu_int width;\n\tu_int type;\n\tint paused;\n\tint done;\n{\n\tstruct ahc_initiator_tinfo *tinfo;\n\tstruct tmode_tstate *tstate;\n\tu_int  oldwidth;\n\tint    active = (type & AHC_TRANS_ACTIVE) == AHC_TRANS_ACTIVE;\n\n\ttinfo = ahc_fetch_transinfo(ahc, devinfo->channel,\n\t\t\t\t    devinfo->our_scsiid,\n\t\t\t\t    devinfo->target,\n\t\t\t\t    &tstate);\n\toldwidth = tinfo->current.width;\n\n\tif ((type & AHC_TRANS_CUR) != 0 && oldwidth != width) {\n\t\tu_int\tscsirate;\n\n\t\tscsirate =  tinfo->scsirate;\n\t\tscsirate &= ~WIDEXFER;\n\t\tif (width == MSG_EXT_WDTR_BUS_16_BIT)\n\t\t\tscsirate |= WIDEXFER;\n\n\t\ttinfo->scsirate = scsirate;\n\n\t\tif (active)\n\t\t\tahc_outb(ahc, SCSIRATE, scsirate);\n\n\t\ttinfo->current.width = width;\n\t}\n\n\tif (done) {\n\t\tprintf(\"%s: target %d using %dbit transfers\\n\",\n\t\t       ahc_name(ahc), devinfo->target,\n\t\t       8 * (0x01 << width));\n\t}\n\n\tif ((type & AHC_TRANS_GOAL) != 0)\n\t\ttinfo->goal.width = width;\n\tif ((type & AHC_TRANS_USER) != 0)\n\t\ttinfo->user.width = width;\n\n\tahc_update_target_msg_request(ahc, devinfo, tinfo,\n\t\t\t\t      /*force*/FALSE, paused);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC int",
            "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "ahc_update_target_msg_request __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t\t      struct ahc_initiator_tinfo *tinfo,\n\t\t\t\t\t      int force, int paused));",
            "STATIC void",
            "ahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));",
            "STATIC void",
            "ahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "static __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct tmode_tstate **tstate;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nahc_update_target_msg_request __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t\t      struct ahc_initiator_tinfo *tinfo,\n\t\t\t\t\t      int force, int paused));\nSTATIC void;\nahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));\nSTATIC void;\nahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct tmode_tstate **tstate;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_set_width(ahc, devinfo, width, type, paused, done)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n\tu_int width;\n\tu_int type;\n\tint paused;\n\tint done;\n{\n\tstruct ahc_initiator_tinfo *tinfo;\n\tstruct tmode_tstate *tstate;\n\tu_int  oldwidth;\n\tint    active = (type & AHC_TRANS_ACTIVE) == AHC_TRANS_ACTIVE;\n\n\ttinfo = ahc_fetch_transinfo(ahc, devinfo->channel,\n\t\t\t\t    devinfo->our_scsiid,\n\t\t\t\t    devinfo->target,\n\t\t\t\t    &tstate);\n\toldwidth = tinfo->current.width;\n\n\tif ((type & AHC_TRANS_CUR) != 0 && oldwidth != width) {\n\t\tu_int\tscsirate;\n\n\t\tscsirate =  tinfo->scsirate;\n\t\tscsirate &= ~WIDEXFER;\n\t\tif (width == MSG_EXT_WDTR_BUS_16_BIT)\n\t\t\tscsirate |= WIDEXFER;\n\n\t\ttinfo->scsirate = scsirate;\n\n\t\tif (active)\n\t\t\tahc_outb(ahc, SCSIRATE, scsirate);\n\n\t\ttinfo->current.width = width;\n\t}\n\n\tif (done) {\n\t\tprintf(\"%s: target %d using %dbit transfers\\n\",\n\t\t       ahc_name(ahc), devinfo->target,\n\t\t       8 * (0x01 << width));\n\t}\n\n\tif ((type & AHC_TRANS_GOAL) != 0)\n\t\ttinfo->goal.width = width;\n\tif ((type & AHC_TRANS_USER) != 0)\n\t\ttinfo->user.width = width;\n\n\tahc_update_target_msg_request(ahc, devinfo, tinfo,\n\t\t\t\t      /*force*/FALSE, paused);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 2602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "LAST_MSG"
          ],
          "line": 2593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCB_TAG"
          ],
          "line": 2589
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define bootverbose\t0\n#define STATIC\n#define bootverbose\t1\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nahc_sent_msg __P((struct ahc_softc *ahc, u_int msgtype,\n\t\t\t\t  int full));\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nahc_update_target_msg_request __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t\t      struct ahc_initiator_tinfo *tinfo,\n\t\t\t\t\t      int force, int paused));\nSTATIC void;\nahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));\nSTATIC void;\nahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));\nSTATIC void;\nSTATIC void;\nahc_calc_residual __P((struct scb *scb));\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo;\nSTATIC void;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct tmode_tstate **tstate;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC int\nahc_handle_msg_reject(ahc, devinfo)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n{\n\t/*\n\t * What we care about here is if we had an\n\t * outstanding SDTR or WDTR message for this\n\t * target.  If we did, this is a signal that\n\t * the target is refusing negotiation.\n\t */\n\tstruct scb *scb;\n\tu_int scb_index;\n\tu_int last_msg;\n\tint   response = 0;\n\n\tscb_index = ahc_inb(ahc, SCB_TAG);\n\tscb = &ahc->scb_data->scbarray[scb_index];\n\n\t/* Might be necessary */\n\tlast_msg = ahc_inb(ahc, LAST_MSG);\n\n\tif (ahc_sent_msg(ahc, MSG_EXT_WDTR, /*full*/FALSE)) {\n\t\tstruct ahc_initiator_tinfo *tinfo;\n\t\tstruct tmode_tstate *tstate;\n\n\t\t/* note 8bit xfers */\n\t\tif (bootverbose)\n\t\t\tprintf(\"%s:%c:%d: refuses WIDE negotiation.  Using \"\n\t\t\t       \"8bit transfers\\n\", ahc_name(ahc),\n\t\t\t       devinfo->channel, devinfo->target);\n\t\tahc_set_width(ahc, devinfo,\n\t\t\t      MSG_EXT_WDTR_BUS_8_BIT,\n\t\t\t      AHC_TRANS_ACTIVE|AHC_TRANS_GOAL,\n\t\t\t      /*paused*/TRUE, /*done*/TRUE);\n\t\t/*\n\t\t * No need to clear the sync rate.  If the target\n\t\t * did not accept the command, our syncrate is\n\t\t * unaffected.  If the target started the negotiation,\n\t\t * but rejected our response, we already cleared the\n\t\t * sync rate before sending our WDTR.\n\t\t */\n\t\ttinfo = ahc_fetch_transinfo(ahc, devinfo->channel,\n\t\t\t\t\t    devinfo->our_scsiid,\n\t\t\t\t\t    devinfo->target, &tstate);\n\t\tif (tinfo->goal.period) {\n\t\t\tu_int period;\n\n\t\t\t/* Start the sync negotiation */\n\t\t\tperiod = tinfo->goal.period;\n\t\t\tahc_devlimited_syncrate(ahc, &period);\n\t\t\tahc->msgout_index = 0;\n\t\t\tahc->msgout_len = 0;\n\t\t\tahc_construct_sdtr(ahc, period, tinfo->goal.offset);\n\t\t\tahc->msgout_index = 0;\n\t\t\tresponse = 1;\n\t\t}\n\t} else if (ahc_sent_msg(ahc, MSG_EXT_SDTR, /*full*/FALSE)) {\n\t\t/* note asynch xfers and clear flag */\n\t\tahc_set_syncrate(ahc, devinfo, /*syncrate*/NULL, /*period*/0,\n\t\t\t\t /*offset*/0,\n\t\t\t\t AHC_TRANS_ACTIVE|AHC_TRANS_GOAL,\n\t\t\t\t /*paused*/TRUE,\n\t\t\t\t /*done*/TRUE);\n\t\tif (bootverbose)\n\t\t\tprintf(\"%s:%c:%d: refuses synchronous negotiation. \"\n\t\t\t       \"Using asynchronous transfers\\n\",\n\t\t\t       ahc_name(ahc),\n\t\t\t       devinfo->channel, devinfo->target);\n\t} else if ((scb->hscb->control & MSG_SIMPLE_Q_TAG) != 0) {\n\t\tif (bootverbose)\n\t\t\tprintf(\"%s:%c:%d: refuses tagged commands.  Performing \"\n\t\t\t       \"non-tagged I/O\\n\", ahc_name(ahc),\n\t\t\t       devinfo->channel, devinfo->target);\n\t\t\t\n\t\tahc_set_tags(ahc, devinfo, FALSE);\n\n\t\t/*\n\t\t * Resend the identify for this CCB as the target\n\t\t * may believe that the selection is invalid otherwise.\n\t\t */\n\t\tahc_outb(ahc, SCB_CONTROL, ahc_inb(ahc, SCB_CONTROL)\n\t\t\t\t\t  & ~MSG_SIMPLE_Q_TAG);\n\t \tscb->hscb->control &= ~MSG_SIMPLE_Q_TAG;\n\t\tahc_outb(ahc, MSG_OUT, MSG_IDENTIFYFLAG);\n\t\tahc_outb(ahc, SCSISIGO, ahc_inb(ahc, SCSISIGO) | ATNO);\n\n\t\t/*\n\t\t * Requeue all tagged commands for this target\n\t\t * currently in our posession so they can be\n\t\t * converted to untagged commands.\n\t\t */\n\t\tahc_search_qinfifo(ahc, SCB_TARGET(scb), SCB_CHANNEL(scb),\n\t\t\t\t   SCB_LUN(scb), /*tag*/SCB_LIST_NULL,\n\t\t\t\t   ROLE_INITIATOR, SCB_REQUEUE,\n\t\t\t\t   SEARCH_COMPLETE);\n\t} else {\n\t\t/*\n\t\t * Otherwise, we ignore it.\n\t\t */\n\t\tprintf(\"%s:%c:%d: Message reject for %x -- ignored\\n\",\n\t\t       ahc_name(ahc), devinfo->channel, devinfo->target,\n\t\t       last_msg);\n\t}\n\treturn (response);\n}"
  },
  {
    "function_name": "ahc_setup_target_msgin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "2551-2571",
    "snippet": "STATIC void\nahc_setup_target_msgin(ahc, devinfo)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n{\n\t/*              \n\t * To facilitate adding multiple messages together,\n\t * each routine should increment the index and len\n\t * variables instead of setting them explicitly.\n\t */             \n\tahc->msgout_index = 0;\n\tahc->msgout_len = 0;\n\n\tif ((ahc->targ_msg_req & devinfo->target_mask) != 0)\n\t\tahc_build_transfer_msg(ahc, devinfo);\n\telse\n\t\tpanic(\"ahc_intr: AWAITING target message with no message\");\n\n\tahc->msgout_index = 0;\n\tahc->msg_type = MSG_TYPE_TARGET_MSGIN;\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define STATIC\tstatic",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
      "STATIC void",
      "STATIC void",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
      "STATIC void",
      "STATIC void",
      "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
      "STATIC int",
      "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
      "STATIC void",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
      "STATIC void",
      "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
      "STATIC void",
      "STATIC void",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"ahc_intr: AWAITING target message with no message\""
          ],
          "line": 2567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_build_transfer_msg",
          "args": [
            "ahc",
            "devinfo"
          ],
          "line": 2565
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_build_transfer_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "2441-2484",
          "snippet": "STATIC void\nahc_build_transfer_msg(ahc, devinfo)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n{\n\t/*\n\t * We need to initiate transfer negotiations.\n\t * If our current and goal settings are identical,\n\t * we want to renegotiate due to a check condition.\n\t */\n\tstruct\tahc_initiator_tinfo *tinfo;\n\tstruct\ttmode_tstate *tstate;\n\tint\tdowide;\n\tint\tdosync;\n\n\ttinfo = ahc_fetch_transinfo(ahc, devinfo->channel,\n\t\t\t\t    devinfo->our_scsiid,\n\t\t\t\t    devinfo->target, &tstate);\n\tdowide = tinfo->current.width != tinfo->goal.width;\n\tdosync = tinfo->current.period != tinfo->goal.period;\n\n\tif (!dowide && !dosync) {\n\t\tdowide = tinfo->goal.width != MSG_EXT_WDTR_BUS_8_BIT;\n\t\tdosync = tinfo->goal.period != 0;\n\t}\n\n\tif (dowide) {\n\t\tahc_construct_wdtr(ahc, tinfo->goal.width);\n\t} else if (dosync) {\n\t\tstruct\tahc_syncrate *rate;\n\t\tu_int\tperiod;\n\t\tu_int\toffset;\n\n\t\tperiod = tinfo->goal.period;\n\t\trate = ahc_devlimited_syncrate(ahc, &period);\n\t\toffset = tinfo->goal.offset;\n\t\tahc_validate_offset(ahc, rate, &offset,\n\t\t\t\t    tinfo->current.width);\n\t\tahc_construct_sdtr(ahc, period, offset);\n\t} else {\n\t\tpanic(\"ahc_intr: AWAITING_MSG for negotiation, \"\n\t\t      \"but no negotiation needed\\n\");\t\n\t}\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC int",
            "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "static __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct tmode_tstate **tstate;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "u_int *period;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "u_int *period;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct tmode_tstate **tstate;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_build_transfer_msg(ahc, devinfo)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n{\n\t/*\n\t * We need to initiate transfer negotiations.\n\t * If our current and goal settings are identical,\n\t * we want to renegotiate due to a check condition.\n\t */\n\tstruct\tahc_initiator_tinfo *tinfo;\n\tstruct\ttmode_tstate *tstate;\n\tint\tdowide;\n\tint\tdosync;\n\n\ttinfo = ahc_fetch_transinfo(ahc, devinfo->channel,\n\t\t\t\t    devinfo->our_scsiid,\n\t\t\t\t    devinfo->target, &tstate);\n\tdowide = tinfo->current.width != tinfo->goal.width;\n\tdosync = tinfo->current.period != tinfo->goal.period;\n\n\tif (!dowide && !dosync) {\n\t\tdowide = tinfo->goal.width != MSG_EXT_WDTR_BUS_8_BIT;\n\t\tdosync = tinfo->goal.period != 0;\n\t}\n\n\tif (dowide) {\n\t\tahc_construct_wdtr(ahc, tinfo->goal.width);\n\t} else if (dosync) {\n\t\tstruct\tahc_syncrate *rate;\n\t\tu_int\tperiod;\n\t\tu_int\toffset;\n\n\t\tperiod = tinfo->goal.period;\n\t\trate = ahc_devlimited_syncrate(ahc, &period);\n\t\toffset = tinfo->goal.offset;\n\t\tahc_validate_offset(ahc, rate, &offset,\n\t\t\t\t    tinfo->current.width);\n\t\tahc_construct_sdtr(ahc, period, offset);\n\t} else {\n\t\tpanic(\"ahc_intr: AWAITING_MSG for negotiation, \"\n\t\t      \"but no negotiation needed\\n\");\t\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_setup_target_msgin(ahc, devinfo)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n{\n\t/*              \n\t * To facilitate adding multiple messages together,\n\t * each routine should increment the index and len\n\t * variables instead of setting them explicitly.\n\t */             \n\tahc->msgout_index = 0;\n\tahc->msgout_len = 0;\n\n\tif ((ahc->targ_msg_req & devinfo->target_mask) != 0)\n\t\tahc_build_transfer_msg(ahc, devinfo);\n\telse\n\t\tpanic(\"ahc_intr: AWAITING target message with no message\");\n\n\tahc->msgout_index = 0;\n\tahc->msg_type = MSG_TYPE_TARGET_MSGIN;\n}"
  },
  {
    "function_name": "ahc_setup_initiator_msgout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "2486-2549",
    "snippet": "STATIC void\nahc_setup_initiator_msgout(ahc, devinfo, scb)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n\tstruct scb *scb;\n{\n\t/*              \n\t * To facilitate adding multiple messages together,\n\t * each routine should increment the index and len\n\t * variables instead of setting them explicitly.\n\t */             \n\tahc->msgout_index = 0;\n\tahc->msgout_len = 0;\n\n\tif ((scb->flags & SCB_DEVICE_RESET) == 0\n\t && ahc_inb(ahc, MSG_OUT) == MSG_IDENTIFYFLAG) {\n\t\tu_int identify_msg;\n\n\t\tidentify_msg = MSG_IDENTIFYFLAG | SCB_LUN(scb);\n\t\tif ((scb->hscb->control & DISCENB) != 0)\n\t\t\tidentify_msg |= MSG_IDENTIFY_DISCFLAG;\n\t\tahc->msgout_buf[ahc->msgout_index++] = identify_msg;\n\t\tahc->msgout_len++;\n\n\t\tif ((scb->hscb->control & TAG_ENB) != 0) {\n\t\t\t/* XXX fvdl FreeBSD has tag action passed down */\n\t\t\tahc->msgout_buf[ahc->msgout_index++] = MSG_SIMPLE_Q_TAG;\n\t\t\tahc->msgout_buf[ahc->msgout_index++] = scb->hscb->tag;\n\t\t\tahc->msgout_len += 2;\n\t\t}\n\t}\n\n\tif (scb->flags & SCB_DEVICE_RESET) {\n\t\tahc->msgout_buf[ahc->msgout_index++] = MSG_BUS_DEV_RESET;\n\t\tahc->msgout_len++;\n\t\t\n\t\tsc_print_addr(scb->xs->sc_link);\n\t\tprintf(\"Bus Device Reset Message Sent\\n\");\n\t} else if (scb->flags & SCB_ABORT) {\n\t\tif ((scb->hscb->control & TAG_ENB) != 0)\n\t\t\tahc->msgout_buf[ahc->msgout_index++] = MSG_ABORT_TAG;\n\t\telse\n\t\t\tahc->msgout_buf[ahc->msgout_index++] = MSG_ABORT;\n\t\tahc->msgout_len++;\n\t\tsc_print_addr(scb->xs->sc_link);\n\t\tprintf(\"Abort Message Sent\\n\");\n\t} else if ((ahc->targ_msg_req & devinfo->target_mask) != 0) {\n\t\tahc_build_transfer_msg(ahc, devinfo);\n\t} else {\n\t\tprintf(\"ahc_intr: AWAITING_MSG for an SCB that \"\n\t\t       \"does not have a waiting message\");\n\t\tpanic(\"SCB = %d, SCB Control = %x, MSG_OUT = %x \"\n\t\t      \"SCB flags = %x\", scb->hscb->tag, scb->hscb->control,\n\t\t      ahc_inb(ahc, MSG_OUT), scb->flags);\n\t}\n\n\t/*\n\t * Clear the MK_MESSAGE flag from the SCB so we aren't\n\t * asked to send this message again.\n\t */\n\tahc_outb(ahc, SCB_CONTROL, ahc_inb(ahc, SCB_CONTROL) & ~MK_MESSAGE);\n\tahc->msgout_index = 0;\n\tahc->msg_type = MSG_TYPE_INITIATOR_MSGOUT;\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define STATIC\tstatic",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
      "STATIC void",
      "ahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));",
      "STATIC void",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
      "STATIC void",
      "STATIC u_int",
      "STATIC void",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
      "STATIC void",
      "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
      "STATIC void",
      "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
      "STATIC int",
      "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
      "STATIC void",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));",
      "STATIC int",
      "STATIC int",
      "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
      "STATIC void",
      "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
      "STATIC void",
      "STATIC void",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "ahc_search_qinfifo __P((struct ahc_softc *ahc, int target,\n\t\t\t\t\tchar channel, int lun, u_int tag,\n\t\t\t\t\trole_t role, u_int32_t status,\n\t\t\t\t\tahc_search_action action));",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC u_int",
      "STATIC void",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "STATIC u_int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
      "STATIC void",
      "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_calc_residual __P((struct scb *scb));",
      "STATIC void",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
      "STATIC void",
      "STATIC void",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
      "STATIC void",
      "STATIC void",
      "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *xs;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCB_CONTROL",
            "ahc_inb(ahc, SCB_CONTROL) & ~MK_MESSAGE"
          ],
          "line": 2546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCB_CONTROL"
          ],
          "line": 2546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"SCB = %d, SCB Control = %x, MSG_OUT = %x \"\n\t\t      \"SCB flags = %x\"",
            "scb->hscb->tag",
            "scb->hscb->control",
            "ahc_inb(ahc, MSG_OUT)",
            "scb->flags"
          ],
          "line": 2537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "MSG_OUT"
          ],
          "line": 2539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ahc_intr: AWAITING_MSG for an SCB that \"\n\t\t       \"does not have a waiting message\""
          ],
          "line": 2535
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_build_transfer_msg",
          "args": [
            "ahc",
            "devinfo"
          ],
          "line": 2533
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_build_transfer_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "2441-2484",
          "snippet": "STATIC void\nahc_build_transfer_msg(ahc, devinfo)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n{\n\t/*\n\t * We need to initiate transfer negotiations.\n\t * If our current and goal settings are identical,\n\t * we want to renegotiate due to a check condition.\n\t */\n\tstruct\tahc_initiator_tinfo *tinfo;\n\tstruct\ttmode_tstate *tstate;\n\tint\tdowide;\n\tint\tdosync;\n\n\ttinfo = ahc_fetch_transinfo(ahc, devinfo->channel,\n\t\t\t\t    devinfo->our_scsiid,\n\t\t\t\t    devinfo->target, &tstate);\n\tdowide = tinfo->current.width != tinfo->goal.width;\n\tdosync = tinfo->current.period != tinfo->goal.period;\n\n\tif (!dowide && !dosync) {\n\t\tdowide = tinfo->goal.width != MSG_EXT_WDTR_BUS_8_BIT;\n\t\tdosync = tinfo->goal.period != 0;\n\t}\n\n\tif (dowide) {\n\t\tahc_construct_wdtr(ahc, tinfo->goal.width);\n\t} else if (dosync) {\n\t\tstruct\tahc_syncrate *rate;\n\t\tu_int\tperiod;\n\t\tu_int\toffset;\n\n\t\tperiod = tinfo->goal.period;\n\t\trate = ahc_devlimited_syncrate(ahc, &period);\n\t\toffset = tinfo->goal.offset;\n\t\tahc_validate_offset(ahc, rate, &offset,\n\t\t\t\t    tinfo->current.width);\n\t\tahc_construct_sdtr(ahc, period, offset);\n\t} else {\n\t\tpanic(\"ahc_intr: AWAITING_MSG for negotiation, \"\n\t\t      \"but no negotiation needed\\n\");\t\n\t}\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC int",
            "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "static __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct tmode_tstate **tstate;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "u_int *period;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "u_int *period;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct tmode_tstate **tstate;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_build_transfer_msg(ahc, devinfo)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n{\n\t/*\n\t * We need to initiate transfer negotiations.\n\t * If our current and goal settings are identical,\n\t * we want to renegotiate due to a check condition.\n\t */\n\tstruct\tahc_initiator_tinfo *tinfo;\n\tstruct\ttmode_tstate *tstate;\n\tint\tdowide;\n\tint\tdosync;\n\n\ttinfo = ahc_fetch_transinfo(ahc, devinfo->channel,\n\t\t\t\t    devinfo->our_scsiid,\n\t\t\t\t    devinfo->target, &tstate);\n\tdowide = tinfo->current.width != tinfo->goal.width;\n\tdosync = tinfo->current.period != tinfo->goal.period;\n\n\tif (!dowide && !dosync) {\n\t\tdowide = tinfo->goal.width != MSG_EXT_WDTR_BUS_8_BIT;\n\t\tdosync = tinfo->goal.period != 0;\n\t}\n\n\tif (dowide) {\n\t\tahc_construct_wdtr(ahc, tinfo->goal.width);\n\t} else if (dosync) {\n\t\tstruct\tahc_syncrate *rate;\n\t\tu_int\tperiod;\n\t\tu_int\toffset;\n\n\t\tperiod = tinfo->goal.period;\n\t\trate = ahc_devlimited_syncrate(ahc, &period);\n\t\toffset = tinfo->goal.offset;\n\t\tahc_validate_offset(ahc, rate, &offset,\n\t\t\t\t    tinfo->current.width);\n\t\tahc_construct_sdtr(ahc, period, offset);\n\t} else {\n\t\tpanic(\"ahc_intr: AWAITING_MSG for negotiation, \"\n\t\t      \"but no negotiation needed\\n\");\t\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sc_print_addr",
          "args": [
            "scb->xs->sc_link"
          ],
          "line": 2530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc_print_addr",
          "args": [
            "scb->xs->sc_link"
          ],
          "line": 2522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCB_LUN",
          "args": [
            "scb"
          ],
          "line": 2504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "MSG_OUT"
          ],
          "line": 2501
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nSTATIC void;\nahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));\nSTATIC int;\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_search_qinfifo __P((struct ahc_softc *ahc, int target,\n\t\t\t\t\tchar channel, int lun, u_int tag,\n\t\t\t\t\trole_t role, u_int32_t status,\n\t\t\t\t\tahc_search_action action));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nSTATIC void;\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_calc_residual __P((struct scb *scb));\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n\nSTATIC void\nahc_setup_initiator_msgout(ahc, devinfo, scb)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n\tstruct scb *scb;\n{\n\t/*              \n\t * To facilitate adding multiple messages together,\n\t * each routine should increment the index and len\n\t * variables instead of setting them explicitly.\n\t */             \n\tahc->msgout_index = 0;\n\tahc->msgout_len = 0;\n\n\tif ((scb->flags & SCB_DEVICE_RESET) == 0\n\t && ahc_inb(ahc, MSG_OUT) == MSG_IDENTIFYFLAG) {\n\t\tu_int identify_msg;\n\n\t\tidentify_msg = MSG_IDENTIFYFLAG | SCB_LUN(scb);\n\t\tif ((scb->hscb->control & DISCENB) != 0)\n\t\t\tidentify_msg |= MSG_IDENTIFY_DISCFLAG;\n\t\tahc->msgout_buf[ahc->msgout_index++] = identify_msg;\n\t\tahc->msgout_len++;\n\n\t\tif ((scb->hscb->control & TAG_ENB) != 0) {\n\t\t\t/* XXX fvdl FreeBSD has tag action passed down */\n\t\t\tahc->msgout_buf[ahc->msgout_index++] = MSG_SIMPLE_Q_TAG;\n\t\t\tahc->msgout_buf[ahc->msgout_index++] = scb->hscb->tag;\n\t\t\tahc->msgout_len += 2;\n\t\t}\n\t}\n\n\tif (scb->flags & SCB_DEVICE_RESET) {\n\t\tahc->msgout_buf[ahc->msgout_index++] = MSG_BUS_DEV_RESET;\n\t\tahc->msgout_len++;\n\t\t\n\t\tsc_print_addr(scb->xs->sc_link);\n\t\tprintf(\"Bus Device Reset Message Sent\\n\");\n\t} else if (scb->flags & SCB_ABORT) {\n\t\tif ((scb->hscb->control & TAG_ENB) != 0)\n\t\t\tahc->msgout_buf[ahc->msgout_index++] = MSG_ABORT_TAG;\n\t\telse\n\t\t\tahc->msgout_buf[ahc->msgout_index++] = MSG_ABORT;\n\t\tahc->msgout_len++;\n\t\tsc_print_addr(scb->xs->sc_link);\n\t\tprintf(\"Abort Message Sent\\n\");\n\t} else if ((ahc->targ_msg_req & devinfo->target_mask) != 0) {\n\t\tahc_build_transfer_msg(ahc, devinfo);\n\t} else {\n\t\tprintf(\"ahc_intr: AWAITING_MSG for an SCB that \"\n\t\t       \"does not have a waiting message\");\n\t\tpanic(\"SCB = %d, SCB Control = %x, MSG_OUT = %x \"\n\t\t      \"SCB flags = %x\", scb->hscb->tag, scb->hscb->control,\n\t\t      ahc_inb(ahc, MSG_OUT), scb->flags);\n\t}\n\n\t/*\n\t * Clear the MK_MESSAGE flag from the SCB so we aren't\n\t * asked to send this message again.\n\t */\n\tahc_outb(ahc, SCB_CONTROL, ahc_inb(ahc, SCB_CONTROL) & ~MK_MESSAGE);\n\tahc->msgout_index = 0;\n\tahc->msg_type = MSG_TYPE_INITIATOR_MSGOUT;\n}"
  },
  {
    "function_name": "ahc_build_transfer_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "2441-2484",
    "snippet": "STATIC void\nahc_build_transfer_msg(ahc, devinfo)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n{\n\t/*\n\t * We need to initiate transfer negotiations.\n\t * If our current and goal settings are identical,\n\t * we want to renegotiate due to a check condition.\n\t */\n\tstruct\tahc_initiator_tinfo *tinfo;\n\tstruct\ttmode_tstate *tstate;\n\tint\tdowide;\n\tint\tdosync;\n\n\ttinfo = ahc_fetch_transinfo(ahc, devinfo->channel,\n\t\t\t\t    devinfo->our_scsiid,\n\t\t\t\t    devinfo->target, &tstate);\n\tdowide = tinfo->current.width != tinfo->goal.width;\n\tdosync = tinfo->current.period != tinfo->goal.period;\n\n\tif (!dowide && !dosync) {\n\t\tdowide = tinfo->goal.width != MSG_EXT_WDTR_BUS_8_BIT;\n\t\tdosync = tinfo->goal.period != 0;\n\t}\n\n\tif (dowide) {\n\t\tahc_construct_wdtr(ahc, tinfo->goal.width);\n\t} else if (dosync) {\n\t\tstruct\tahc_syncrate *rate;\n\t\tu_int\tperiod;\n\t\tu_int\toffset;\n\n\t\tperiod = tinfo->goal.period;\n\t\trate = ahc_devlimited_syncrate(ahc, &period);\n\t\toffset = tinfo->goal.offset;\n\t\tahc_validate_offset(ahc, rate, &offset,\n\t\t\t\t    tinfo->current.width);\n\t\tahc_construct_sdtr(ahc, period, offset);\n\t} else {\n\t\tpanic(\"ahc_intr: AWAITING_MSG for negotiation, \"\n\t\t      \"but no negotiation needed\\n\");\t\n\t}\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define STATIC\tstatic",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
      "STATIC void",
      "STATIC u_int",
      "STATIC void",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
      "STATIC void",
      "STATIC void",
      "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
      "STATIC int",
      "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
      "STATIC void",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
      "STATIC void",
      "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
      "STATIC void",
      "STATIC void",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC u_int",
      "STATIC void",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "STATIC u_int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "ahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "static __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "char channel;",
      "struct tmode_tstate **tstate;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "u_int *period;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "u_int *period;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "char channel;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"ahc_intr: AWAITING_MSG for negotiation, \"\n\t\t      \"but no negotiation needed\\n\""
          ],
          "line": 2481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_construct_sdtr",
          "args": [
            "ahc",
            "period",
            "offset"
          ],
          "line": 2479
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_construct_sdtr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "5551-5563",
          "snippet": "STATIC void\nahc_construct_sdtr(ahc, period, offset)\n\tstruct ahc_softc *ahc;\n\tu_int period;\n\tu_int offset;\n{\n\tahc->msgout_buf[ahc->msgout_index++] = MSG_EXTENDED;\n\tahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_SDTR_LEN;\n\tahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_SDTR;\n\tahc->msgout_buf[ahc->msgout_index++] = period;\n\tahc->msgout_buf[ahc->msgout_index++] = offset;\n\tahc->msgout_len += 5;\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "u_int *period;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "u_int *period;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_construct_sdtr(ahc, period, offset)\n\tstruct ahc_softc *ahc;\n\tu_int period;\n\tu_int offset;\n{\n\tahc->msgout_buf[ahc->msgout_index++] = MSG_EXTENDED;\n\tahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_SDTR_LEN;\n\tahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_SDTR;\n\tahc->msgout_buf[ahc->msgout_index++] = period;\n\tahc->msgout_buf[ahc->msgout_index++] = offset;\n\tahc->msgout_len += 5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_validate_offset",
          "args": [
            "ahc",
            "rate",
            "&offset",
            "tinfo->current.width"
          ],
          "line": 2477
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_validate_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "1227-1248",
          "snippet": "STATIC void\nahc_validate_offset(ahc, syncrate, offset, wide)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_syncrate *syncrate;\n\tu_int *offset;\n\tint wide;\n{\n\tu_int maxoffset;\n\n\t/* Limit offset to what we can do */\n\tif (syncrate == NULL) {\n\t\tmaxoffset = 0;\n\t} else if ((ahc->features & AHC_ULTRA2) != 0) {\n\t\tmaxoffset = MAX_OFFSET_ULTRA2;\n\t} else {\n\t\tif (wide)\n\t\t\tmaxoffset = MAX_OFFSET_16BIT;\n\t\telse\n\t\t\tmaxoffset = MAX_OFFSET_8BIT;\n\t}\n\t*offset = MIN(*offset, maxoffset);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "ahc_validate_offset __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct ahc_syncrate *syncrate,\n\t\t\t\t\t u_int *offset, int wide));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nahc_validate_offset __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct ahc_syncrate *syncrate,\n\t\t\t\t\t u_int *offset, int wide));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_validate_offset(ahc, syncrate, offset, wide)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_syncrate *syncrate;\n\tu_int *offset;\n\tint wide;\n{\n\tu_int maxoffset;\n\n\t/* Limit offset to what we can do */\n\tif (syncrate == NULL) {\n\t\tmaxoffset = 0;\n\t} else if ((ahc->features & AHC_ULTRA2) != 0) {\n\t\tmaxoffset = MAX_OFFSET_ULTRA2;\n\t} else {\n\t\tif (wide)\n\t\t\tmaxoffset = MAX_OFFSET_16BIT;\n\t\telse\n\t\t\tmaxoffset = MAX_OFFSET_8BIT;\n\t}\n\t*offset = MIN(*offset, maxoffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_devlimited_syncrate",
          "args": [
            "ahc",
            "&period"
          ],
          "line": 2475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_construct_wdtr",
          "args": [
            "ahc",
            "tinfo->goal.width"
          ],
          "line": 2468
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_construct_wdtr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "5565-5575",
          "snippet": "STATIC void\nahc_construct_wdtr(ahc, bus_width)\n\tstruct ahc_softc *ahc;\n\tu_int bus_width;\n{\n\tahc->msgout_buf[ahc->msgout_index++] = MSG_EXTENDED;\n\tahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_WDTR_LEN;\n\tahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_WDTR;\n\tahc->msgout_buf[ahc->msgout_index++] = bus_width;\n\tahc->msgout_len += 4;\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_construct_wdtr __P((struct ahc_softc *ahc, u_int bus_width));",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_construct_wdtr __P((struct ahc_softc *ahc, u_int bus_width));\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_construct_wdtr(ahc, bus_width)\n\tstruct ahc_softc *ahc;\n\tu_int bus_width;\n{\n\tahc->msgout_buf[ahc->msgout_index++] = MSG_EXTENDED;\n\tahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_WDTR_LEN;\n\tahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_WDTR;\n\tahc->msgout_buf[ahc->msgout_index++] = bus_width;\n\tahc->msgout_len += 4;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_fetch_transinfo",
          "args": [
            "ahc",
            "devinfo->channel",
            "devinfo->our_scsiid",
            "devinfo->target",
            "&tstate"
          ],
          "line": 2456
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct tmode_tstate **tstate;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_build_transfer_msg(ahc, devinfo)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n{\n\t/*\n\t * We need to initiate transfer negotiations.\n\t * If our current and goal settings are identical,\n\t * we want to renegotiate due to a check condition.\n\t */\n\tstruct\tahc_initiator_tinfo *tinfo;\n\tstruct\ttmode_tstate *tstate;\n\tint\tdowide;\n\tint\tdosync;\n\n\ttinfo = ahc_fetch_transinfo(ahc, devinfo->channel,\n\t\t\t\t    devinfo->our_scsiid,\n\t\t\t\t    devinfo->target, &tstate);\n\tdowide = tinfo->current.width != tinfo->goal.width;\n\tdosync = tinfo->current.period != tinfo->goal.period;\n\n\tif (!dowide && !dosync) {\n\t\tdowide = tinfo->goal.width != MSG_EXT_WDTR_BUS_8_BIT;\n\t\tdosync = tinfo->goal.period != 0;\n\t}\n\n\tif (dowide) {\n\t\tahc_construct_wdtr(ahc, tinfo->goal.width);\n\t} else if (dosync) {\n\t\tstruct\tahc_syncrate *rate;\n\t\tu_int\tperiod;\n\t\tu_int\toffset;\n\n\t\tperiod = tinfo->goal.period;\n\t\trate = ahc_devlimited_syncrate(ahc, &period);\n\t\toffset = tinfo->goal.offset;\n\t\tahc_validate_offset(ahc, rate, &offset,\n\t\t\t\t    tinfo->current.width);\n\t\tahc_construct_sdtr(ahc, period, offset);\n\t} else {\n\t\tpanic(\"ahc_intr: AWAITING_MSG for negotiation, \"\n\t\t      \"but no negotiation needed\\n\");\t\n\t}\n}"
  },
  {
    "function_name": "ahc_handle_scsiint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "2164-2439",
    "snippet": "STATIC void\nahc_handle_scsiint(ahc, intstat)\n\tstruct ahc_softc *ahc;\n\tu_int intstat;\n{\n\tu_int\tscb_index;\n\tu_int\tstatus;\n\tstruct\tscb *scb;\n\tchar\tcur_channel;\n\tchar\tintr_channel;\n\n\tif ((ahc->features & AHC_TWIN) != 0\n\t && ((ahc_inb(ahc, SBLKCTL) & SELBUSB) != 0))\n\t\tcur_channel = 'B';\n\telse\n\t\tcur_channel = 'A';\n\tintr_channel = cur_channel;\n\n\tstatus = ahc_inb(ahc, SSTAT1);\n\tif (status == 0) {\n\t\tif ((ahc->features & AHC_TWIN) != 0) {\n\t\t\t/* Try the other channel */\n\t\t \tahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) ^ SELBUSB);\n\t\t\tstatus = ahc_inb(ahc, SSTAT1);\n\t\t \tahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) ^ SELBUSB);\n\t\t\tintr_channel = (cur_channel == 'A') ? 'B' : 'A';\n\t\t}\n\t\tif (status == 0) {\n\t\t\tprintf(\"%s: Spurious SCSI interrupt\\n\", ahc_name(ahc));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tscb_index = ahc_inb(ahc, SCB_TAG);\n\tif (scb_index < ahc->scb_data->numscbs) {\n\t\tscb = &ahc->scb_data->scbarray[scb_index];\n\t\tif ((scb->flags & SCB_ACTIVE) == 0\n\t\t || (ahc_inb(ahc, SEQ_FLAGS) & IDENTIFY_SEEN) == 0)\n\t\t\tscb = NULL;\n\t} else\n\t\tscb = NULL;\n\n\tif ((status & SCSIRSTI) != 0) {\n\t\tprintf(\"%s: Someone reset channel %c\\n\",\n\t\t\tahc_name(ahc), intr_channel);\n\t\tahc_reset_channel(ahc, intr_channel, /* Initiate Reset */FALSE);\n\t} else if ((status & SCSIPERR) != 0) {\n\t\t/*\n\t\t * Determine the bus phase and queue an appropriate message.\n\t\t * SCSIPERR is latched true as soon as a parity error\n\t\t * occurs.  If the sequencer acked the transfer that\n\t\t * caused the parity error and the currently presented\n\t\t * transfer on the bus has correct parity, SCSIPERR will\n\t\t * be cleared by CLRSCSIPERR.  Use this to determine if\n\t\t * we should look at the last phase the sequencer recorded,\n\t\t * or the current phase presented on the bus.\n\t\t */\n\t\tu_int mesg_out;\n\t\tu_int curphase;\n\t\tu_int errorphase;\n\t\tu_int lastphase;\n\t\tint   i;\n\n\t\tlastphase = ahc_inb(ahc, LASTPHASE);\n\t\tcurphase = ahc_inb(ahc, SCSISIGI) & PHASE_MASK;\n\t\tahc_outb(ahc, CLRSINT1, CLRSCSIPERR);\n\t\t/*\n\t\t * For all phases save DATA, the sequencer won't\n\t\t * automatically ack a byte that has a parity error\n\t\t * in it.  So the only way that the current phase\n\t\t * could be 'data-in' is if the parity error is for\n\t\t * an already acked byte in the data phase.  During\n\t\t * synchronous data-in transfers, we may actually\n\t\t * ack bytes before latching the current phase in\n\t\t * LASTPHASE, leading to the discrepancy between\n\t\t * curphase and lastphase.\n\t\t */\n\t\tif ((ahc_inb(ahc, SSTAT1) & SCSIPERR) != 0\n\t\t || curphase == P_DATAIN)\n\t\t\terrorphase = curphase;\n\t\telse\n\t\t\terrorphase = lastphase;\n\n\t\tfor (i = 0; i < num_phases; i++) {\n\t\t\tif (errorphase == phase_table[i].phase)\n\t\t\t\tbreak;\n\t\t}\n\t\tmesg_out = phase_table[i].mesg_out;\n\t\tif (scb != NULL)\n\t\t\tsc_print_addr(scb->xs->sc_link);\n\t\telse\n\t\t\tprintf(\"%s:%c:%d: \", ahc_name(ahc),\n\t\t\t       intr_channel,\n\t\t\t       TCL_TARGET(ahc_inb(ahc, SAVED_TCL)));\n\t\t\n\t\tprintf(\"parity error detected %s. \"\n\t\t       \"SEQADDR(0x%x) SCSIRATE(0x%x)\\n\",\n\t\t       phase_table[i].phasemsg,\n\t\t       ahc_inb(ahc, SEQADDR0) | (ahc_inb(ahc, SEQADDR1) << 8),\n\t\t       ahc_inb(ahc, SCSIRATE));\n\n\t\t/*\n\t\t * We've set the hardware to assert ATN if we   \n\t\t * get a parity error on \"in\" phases, so all we  \n\t\t * need to do is stuff the message buffer with\n\t\t * the appropriate message.  \"In\" phases have set\n\t\t * mesg_out to something other than MSG_NOP.\n\t\t */\n\t\tif (mesg_out != MSG_NOOP) {\n\t\t\tif (ahc->msg_type != MSG_TYPE_NONE)\n\t\t\t\tahc->send_msg_perror = TRUE;\n\t\t\telse\n\t\t\t\tahc_outb(ahc, MSG_OUT, mesg_out);\n\t\t}\n\t\tahc_outb(ahc, CLRINT, CLRSCSIINT);\n\t\tunpause_sequencer(ahc);\n\t} else if ((status & BUSFREE) != 0\n\t\t&& (ahc_inb(ahc, SIMODE1) & ENBUSFREE) != 0) {\n\t\t/*\n\t\t * First look at what phase we were last in.\n\t\t * If its message out, chances are pretty good\n\t\t * that the busfree was in response to one of\n\t\t * our abort requests.\n\t\t */\n\t\tu_int lastphase = ahc_inb(ahc, LASTPHASE);\n\t\tu_int saved_tcl = ahc_inb(ahc, SAVED_TCL);\n\t\tu_int target = TCL_TARGET(saved_tcl);\n\t\tu_int initiator_role_id = TCL_SCSI_ID(ahc, saved_tcl);\n\t\tchar channel = TCL_CHANNEL(ahc, saved_tcl);\n\t\tint printerror = 1;\n\n\t\tahc_outb(ahc, SCSISEQ,\n\t\t\t ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP));\n\t\tif (lastphase == P_MESGOUT) {\n\t\t\tu_int message;\n\t\t\tu_int tag;\n\n\t\t\tmessage = ahc->msgout_buf[ahc->msgout_index - 1];\n\t\t\ttag = SCB_LIST_NULL;\n\t\t\tswitch (message) {\n\t\t\tcase MSG_ABORT_TAG:\n\t\t\t\ttag = scb->hscb->tag;\n\t\t\t\t/* FALLTRHOUGH */\n\t\t\tcase MSG_ABORT:\n\t\t\t\tsc_print_addr(scb->xs->sc_link);\n\t\t\t\tprintf(\"SCB %d - Abort %s Completed.\\n\",\n\t\t\t\t       scb->hscb->tag, tag == SCB_LIST_NULL ?\n\t\t\t\t       \"\" : \"Tag\");\n\t\t\t\tahc_abort_scbs(ahc, target, channel,\n\t\t\t\t\t       TCL_LUN(saved_tcl), tag,\n\t\t\t\t\t       ROLE_INITIATOR,\n\t\t\t\t\t       XS_DRIVER_STUFFUP);\n\t\t\t\tprinterror = 0;\n\t\t\t\tbreak;\n\t\t\tcase MSG_BUS_DEV_RESET:\n\t\t\t{\n\t\t\t\tstruct ahc_devinfo devinfo;\n\n\t\t\t\tif (scb != NULL &&\n\t\t\t\t    (scb->xs->flags & SCSI_RESET)\n\t\t\t\t && ahc_match_scb(scb, target, channel,\n\t\t\t\t\t\t  TCL_LUN(saved_tcl),\n\t\t\t\t\t\t  SCB_LIST_NULL,\n\t\t\t\t\t\t  ROLE_INITIATOR)) {\n\t\t\t\t\tahcsetccbstatus(scb->xs, XS_NOERROR);\n\t\t\t\t}\n\t\t\t\tahc_compile_devinfo(&devinfo,\n\t\t\t\t\t\t    initiator_role_id,\n\t\t\t\t\t\t    target,\n\t\t\t\t\t\t    TCL_LUN(saved_tcl),\n\t\t\t\t\t\t    channel,\n\t\t\t\t\t\t    ROLE_INITIATOR);\n\t\t\t\tahc_handle_devreset(ahc, &devinfo,\n\t\t\t\t\t\t    XS_RESET,\n\t\t\t\t\t\t    \"Bus Device Reset\",\n\t\t\t\t\t\t    /*verbose_level*/0);\n\t\t\t\tprinterror = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (printerror != 0) {\n\t\t\tint i;\n\n\t\t\tif (scb != NULL) {\n\t\t\t\tu_int tag;\n\n\t\t\t\tif ((scb->hscb->control & TAG_ENB) != 0)\n\t\t\t\t\ttag = scb->hscb->tag;\n\t\t\t\telse\n\t\t\t\t\ttag = SCB_LIST_NULL;\n\t\t\t\tahc_abort_scbs(ahc, target, channel,\n\t\t\t\t\t       SCB_LUN(scb), tag,\n\t\t\t\t\t       ROLE_INITIATOR,\n\t\t\t\t\t       XS_DRIVER_STUFFUP);\n\t\t\t\tsc_print_addr(scb->xs->sc_link);\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * We had not fully identified this connection,\n\t\t\t\t * so we cannot abort anything.\n\t\t\t\t */\n\t\t\t\tprintf(\"%s: \", ahc_name(ahc));\n\t\t\t}\n\t\t\tfor (i = 0; i < num_phases; i++) {\n\t\t\t\tif (lastphase == phase_table[i].phase)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tprintf(\"Unexpected busfree %s\\n\"\n\t\t\t       \"SEQADDR == 0x%x\\n\",\n\t\t\t       phase_table[i].phasemsg, ahc_inb(ahc, SEQADDR0)\n\t\t\t\t| (ahc_inb(ahc, SEQADDR1) << 8));\n\t\t}\n\t\tahc_clear_msg_state(ahc);\n\t\tahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENBUSFREE);\n\t\tahc_outb(ahc, CLRSINT1, CLRBUSFREE|CLRSCSIPERR);\n\t\tahc_outb(ahc, CLRINT, CLRSCSIINT);\n\t\trestart_sequencer(ahc);\n\t} else if ((status & SELTO) != 0) {\n\t\tu_int scbptr;\n\n\t\tscbptr = ahc_inb(ahc, WAITING_SCBH);\n\t\tahc_outb(ahc, SCBPTR, scbptr);\n\t\tscb_index = ahc_inb(ahc, SCB_TAG);\n\n\t\tif (scb_index < ahc->scb_data->numscbs) {\n\t\t\tscb = &ahc->scb_data->scbarray[scb_index];\n\t\t\tif ((scb->flags & SCB_ACTIVE) == 0)\n\t\t\t\tscb = NULL;\n\t\t} else\n\t\t\tscb = NULL;\n\n\t\tif (scb == NULL) {\n\t\t\tprintf(\"%s: ahc_intr - referenced scb not \"\n\t\t\t       \"valid during SELTO scb(%d, %d)\\n\",\n\t\t\t       ahc_name(ahc), scbptr, scb_index);\n\t\t} else {\n\t\t\tu_int tag;\n\n\t\t\ttag = SCB_LIST_NULL;\n\t\t\tif ((scb->hscb->control & MSG_SIMPLE_Q_TAG) != 0)\n\t\t\t\ttag = scb->hscb->tag;\n\n\t\t\tahc_abort_scbs(ahc, SCB_TARGET(scb), SCB_CHANNEL(scb),\n\t\t\t\t       SCB_LUN(scb), tag,\n\t\t\t\t       ROLE_INITIATOR, XS_SELTIMEOUT);\n\t\t}\n\t\t/* Stop the selection */\n\t\tahc_outb(ahc, SCSISEQ, 0);\n\n\t\t/* No more pending messages */\n\t\tahc_clear_msg_state(ahc);\n\n\t\t/*\n\t\t * Although the driver does not care about the\n\t\t * 'Selection in Progress' status bit, the busy\n\t\t * LED does.  SELINGO is only cleared by a sucessful\n\t\t * selection, so we must manually clear it to ensure\n\t\t * the LED turns off just incase no future successful\n\t\t * selections occur (e.g. no devices on the bus).\n\t\t */\n\t\tahc_outb(ahc, CLRSINT0, CLRSELINGO);\n\n\t\t/* Clear interrupt state */\n\t\tahc_outb(ahc, CLRSINT1, CLRSELTIMEO|CLRBUSFREE|CLRSCSIPERR);\n\t\tahc_outb(ahc, CLRINT, CLRSCSIINT);\n\t\trestart_sequencer(ahc);\n\t} else {\n\t\tsc_print_addr(scb->xs->sc_link);\n\t\tprintf(\"Unknown SCSIINT. Status = 0x%x\\n\", status);\n\t\tahc_outb(ahc, CLRSINT1, status);\n\t\tahc_outb(ahc, CLRINT, CLRSCSIINT);\n\t\tunpause_sequencer(ahc);\n\t}\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define STATIC\tstatic",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
      "STATIC void",
      "ahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));",
      "STATIC void",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
      "STATIC void",
      "STATIC u_int",
      "STATIC void",
      "STATIC struct",
      "STATIC void",
      "ahc_handle_seqint __P((struct ahc_softc *ahc, u_int intstat));",
      "STATIC void",
      "ahc_handle_scsiint __P((struct ahc_softc *ahc, u_int intstat));",
      "STATIC void",
      "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
      "STATIC void",
      "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
      "STATIC void",
      "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
      "STATIC int",
      "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
      "STATIC void",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));",
      "STATIC int",
      "STATIC int",
      "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
      "STATIC void",
      "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
      "STATIC void",
      "ahc_handle_devreset __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct ahc_devinfo *devinfo,\n\t\t\t\t\t int status, char *message,\n\t\t\t\t\t int verbose_level));",
      "STATIC void",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "ahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));",
      "STATIC int",
      "STATIC u_int",
      "ahc_rem_scb_from_disc_list __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tu_int prev, u_int scbptr));",
      "STATIC void",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "STATIC u_int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
      "STATIC void",
      "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_calc_residual __P((struct scb *scb));",
      "STATIC void",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
      "STATIC void",
      "static __inline void unpause_sequencer",
      "STATIC void",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "static __inline void ahcsetccbstatus",
      "STATIC void",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
      "STATIC void",
      "STATIC void",
      "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "char channel;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "static struct {\n        u_int8_t phase;\n        u_int8_t mesg_out; /* Message response to parity errors */\n\tchar *phasemsg;\n} phase_table[] = {\n\t{ P_DATAOUT,\tMSG_NOOP,\t\t\"in Data-out phase\"\t},\n\t{ P_DATAIN,\tMSG_INITIATOR_DET_ERR,\t\"in Data-in phase\"\t},\n\t{ P_COMMAND,\tMSG_NOOP,\t\t\"in Command phase\"\t},\n\t{ P_MESGOUT,\tMSG_NOOP,\t\t\"in Message-out phase\"\t},\n\t{ P_STATUS,\tMSG_INITIATOR_DET_ERR,\t\"in Status phase\"\t},\n\t{ P_MESGIN,\tMSG_PARITY_ERROR,\t\"in Message-in phase\"\t},\n\t{ P_BUSFREE,\tMSG_NOOP,\t\t\"while idle\"\t\t},\n\t{ 0,\t\tMSG_NOOP,\t\t\"in unknown phase\"\t}\n};",
      "static const int num_phases = (sizeof(phase_table)/sizeof(phase_table[0])) - 1;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "char channel;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *xs;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unpause_sequencer",
          "args": [
            "ahc"
          ],
          "line": 2437
        },
        "resolved": true,
        "details": {
          "function_name": "unpause_sequencer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "456-462",
          "snippet": "static __inline void\nunpause_sequencer(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tif ((ahc_inb(ahc, INTSTAT) & (SCSIINT | SEQINT | BRKADRINT)) == 0)\n\t\tahc_outb(ahc, HCNTRL, ahc->unpause);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "static __inline void unpause_sequencer",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC struct;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nahc_loadseq __P((struct ahc_softc *ahc));\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nahc_clear_intstat __P((struct ahc_softc *ahc));\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nstatic __inline void unpause_sequencer;\nrestart_sequencer __P((struct ahc_softc *ahc));\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nstatic __inline void\nunpause_sequencer(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tif ((ahc_inb(ahc, INTSTAT) & (SCSIINT | SEQINT | BRKADRINT)) == 0)\n\t\tahc_outb(ahc, HCNTRL, ahc->unpause);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "CLRINT",
            "CLRSCSIINT"
          ],
          "line": 2436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "CLRSINT1",
            "status"
          ],
          "line": 2435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Unknown SCSIINT. Status = 0x%x\\n\"",
            "status"
          ],
          "line": 2434
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sc_print_addr",
          "args": [
            "scb->xs->sc_link"
          ],
          "line": 2433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "restart_sequencer",
          "args": [
            "ahc"
          ],
          "line": 2431
        },
        "resolved": true,
        "details": {
          "function_name": "restart_sequencer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "467-495",
          "snippet": "STATIC void\nrestart_sequencer(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tu_int i;\n\n\tpause_sequencer(ahc);\n\n\t/*\n\t * Everytime we restart the sequencer, there\n\t * is the possiblitity that we have restarted\n\t * within a three instruction window where an\n\t * SCB has been marked free but has not made it\n\t * onto the free list.  Since SCSI events(bus reset,\n\t * unexpected bus free) will always freeze the\n\t * sequencer, we cannot close this window.  To\n\t * avoid losing an SCB, we reconsitute the free\n\t * list every time we restart the sequencer.\n\t */\n\tahc_outb(ahc, FREE_SCBH, SCB_LIST_NULL);\n\tfor (i = 0; i < ahc->scb_data->maxhscbs; i++) {\n\t\t\n\t\tahc_outb(ahc, SCBPTR, i);\n\t\tif (ahc_inb(ahc, SCB_TAG) == SCB_LIST_NULL)\n\t\t\tahc_add_curscb_to_free_list(ahc);\n\t}\n\tahc_outb(ahc, SEQCTL, FASTMODE|SEQRESET);\n\tunpause_sequencer(ahc);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "static __inline void pause_sequencer",
            "static __inline void unpause_sequencer",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nstatic __inline void pause_sequencer;\nstatic __inline void unpause_sequencer;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nrestart_sequencer(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tu_int i;\n\n\tpause_sequencer(ahc);\n\n\t/*\n\t * Everytime we restart the sequencer, there\n\t * is the possiblitity that we have restarted\n\t * within a three instruction window where an\n\t * SCB has been marked free but has not made it\n\t * onto the free list.  Since SCSI events(bus reset,\n\t * unexpected bus free) will always freeze the\n\t * sequencer, we cannot close this window.  To\n\t * avoid losing an SCB, we reconsitute the free\n\t * list every time we restart the sequencer.\n\t */\n\tahc_outb(ahc, FREE_SCBH, SCB_LIST_NULL);\n\tfor (i = 0; i < ahc->scb_data->maxhscbs; i++) {\n\t\t\n\t\tahc_outb(ahc, SCBPTR, i);\n\t\tif (ahc_inb(ahc, SCB_TAG) == SCB_LIST_NULL)\n\t\t\tahc_add_curscb_to_free_list(ahc);\n\t}\n\tahc_outb(ahc, SEQCTL, FASTMODE|SEQRESET);\n\tunpause_sequencer(ahc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "CLRINT",
            "CLRSCSIINT"
          ],
          "line": 2430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "CLRSINT1",
            "CLRSELTIMEO|CLRBUSFREE|CLRSCSIPERR"
          ],
          "line": 2429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "CLRSINT0",
            "CLRSELINGO"
          ],
          "line": 2426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_clear_msg_state",
          "args": [
            "ahc"
          ],
          "line": 2416
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_clear_msg_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "2680-2688",
          "snippet": "STATIC void\nahc_clear_msg_state(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tahc->msgout_len = 0;\n\tahc->msgin_index = 0;\n\tahc->msg_type = MSG_TYPE_NONE;\n\tahc_outb(ahc, MSG_OUT, MSG_NOOP);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_clear_msg_state(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tahc->msgout_len = 0;\n\tahc->msgin_index = 0;\n\tahc->msg_type = MSG_TYPE_NONE;\n\tahc_outb(ahc, MSG_OUT, MSG_NOOP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCSISEQ",
            "0"
          ],
          "line": 2413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_abort_scbs",
          "args": [
            "ahc",
            "SCB_TARGET(scb)",
            "SCB_CHANNEL(scb)",
            "SCB_LUN(scb)",
            "tag",
            "ROLE_INITIATOR",
            "XS_SELTIMEOUT"
          ],
          "line": 2408
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_abort_scbs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "5129-5231",
          "snippet": "STATIC int\nahc_abort_scbs(ahc, target, channel, lun, tag, role, status)\n\tstruct ahc_softc *ahc;\n\tint target;\n\tchar channel;\n\tint lun;\n\tu_int tag;\n\trole_t role;\n\tu_int32_t status;\n{\n\tstruct\tscb *scbp;\n\tu_int\tactive_scb;\n\tint\ti;\n\tint\tfound;\n\n\t/* restore this when we're done */\n\tactive_scb = ahc_inb(ahc, SCBPTR);\n\n\tfound = ahc_search_qinfifo(ahc, target, channel, lun, SCB_LIST_NULL,\n\t\t\t\t   role, SCB_REQUEUE, SEARCH_COMPLETE);\n\n\t/*\n\t * Search waiting for selection list.\n\t */\n\t{\n\t\tu_int8_t next, prev;\n                /* Start at head of list. */\n\t\tnext = ahc_inb(ahc, WAITING_SCBH);\n\t\tprev = SCB_LIST_NULL;\n\n\t\twhile (next != SCB_LIST_NULL) {\n\t\t\tu_int8_t scb_index;\n\n\t\t\tahc_outb(ahc, SCBPTR, next);\n\t\t\tscb_index = ahc_inb(ahc, SCB_TAG);\n\t\t\tif (scb_index >= ahc->scb_data->numscbs) {\n\t\t\t\tpanic(\"Waiting List inconsistency. \"\n\t\t\t\t      \"SCB index == %d, yet numscbs == %d.\",\n\t\t\t\t      scb_index, ahc->scb_data->numscbs);\n\t\t\t}\n\t\t\tscbp = &ahc->scb_data->scbarray[scb_index];\n\t\t\tif (ahc_match_scb(scbp, target, channel,\n\t\t\t\t\t  lun, SCB_LIST_NULL, role)) {\n\n\t\t\t\tnext = ahc_abort_wscb(ahc, next, prev);\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tprev = next;\n\t\t\t\tnext = ahc_inb(ahc, SCB_NEXT);\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\t * Go through the disconnected list and remove any entries we\n\t * have queued for completion, 0'ing their control byte too.\n\t * We save the active SCB and restore it ourselves, so there\n\t * is no reason for this search to restore it too.\n\t */\n\tahc_search_disc_list(ahc, target, channel, lun, tag,\n\t\t\t     /*stop_on_first*/FALSE, /*remove*/TRUE,\n\t\t\t     /*save_state*/FALSE);\n\n\t/*\n\t * Go through the hardware SCB array looking for commands that\n\t * were active but not on any list.\n\t */\n\tfor(i = 0; i < ahc->scb_data->maxhscbs; i++) {\n\t\tu_int scbid;\n\n\t\tahc_outb(ahc, SCBPTR, i);\n\t\tscbid = ahc_inb(ahc, SCB_TAG);\n\t\tscbp = &ahc->scb_data->scbarray[scbid];\n\t\tif (scbid < ahc->scb_data->numscbs && \n\t\t\t ahc_match_scb(scbp, target, channel, lun, tag, role))\n\t\t\t\tahc_add_curscb_to_free_list(ahc);\n\t}\n\n\t/*\n\t * Go through the pending CCB list and look for\n\t * commands for this target that are still active.\n\t * These are other tagged commands that were\n\t * disconnected when the reset occured.\n\t */\n\t{\n\t\tstruct scb *scb;\n\n\t\tscb = ahc->pending_scbs.lh_first;\n\t\twhile (scb != NULL) {\n\t\t\tscbp = scb;\n\t\t\tscb = scb->pend_links.le_next;\n\t\t\tif (ahc_match_scb(scbp, target, channel,\n\t\t\t\t\t  lun, tag, role)) {\n\t\t\t\tif (!(scbp->xs->flags & ITSDONE))\n\t\t\t\t\tahcsetccbstatus(scbp->xs, status);\n\t\t\t\tahc_freeze_ccb(scbp);\n\t\t\t\tahc_done(ahc, scbp);\n\t\t\t\tfound++;\n\t\t\t}\n\t\t}\n\t}\n\tahc_outb(ahc, SCBPTR, active_scb);\n\treturn found;\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "ahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));",
            "STATIC u_int",
            "ahc_abort_wscb __P((struct ahc_softc *ahc,\n\t\t\t\t    u_int scbpos, u_int prev));",
            "STATIC void",
            "ahc_done __P((struct ahc_softc *ahc, struct scb *scbp));",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "ahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "ahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));",
            "STATIC int",
            "ahc_search_disc_list __P((struct ahc_softc *ahc, int target,\n\t\t\t\t\t  char channel, int lun, u_int tag,\n\t\t\t\t\t  int stop_on_first, int remove,\n\t\t\t\t\t  int save_state));",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));",
            "STATIC void",
            "ahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));",
            "STATIC void",
            "STATIC int",
            "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
            "STATIC void",
            "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_calc_residual __P((struct scb *scb));",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "static __inline void ahc_freeze_ccb",
            "static __inline void ahcsetccbstatus",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *xs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));\nSTATIC u_int;\nahc_abort_wscb __P((struct ahc_softc *ahc,\n\t\t\t\t    u_int scbpos, u_int prev));\nSTATIC void;\nahc_done __P((struct ahc_softc *ahc, struct scb *scbp));\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));\nSTATIC int;\nahc_search_disc_list __P((struct ahc_softc *ahc, int target,\n\t\t\t\t\t  char channel, int lun, u_int tag,\n\t\t\t\t\t  int stop_on_first, int remove,\n\t\t\t\t\t  int save_state));\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));\nSTATIC void;\nahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));\nSTATIC void;\nSTATIC int;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nSTATIC void;\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_calc_residual __P((struct scb *scb));\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nstatic __inline void ahc_freeze_ccb;\nstatic __inline void ahcsetccbstatus;\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n\nSTATIC int\nahc_abort_scbs(ahc, target, channel, lun, tag, role, status)\n\tstruct ahc_softc *ahc;\n\tint target;\n\tchar channel;\n\tint lun;\n\tu_int tag;\n\trole_t role;\n\tu_int32_t status;\n{\n\tstruct\tscb *scbp;\n\tu_int\tactive_scb;\n\tint\ti;\n\tint\tfound;\n\n\t/* restore this when we're done */\n\tactive_scb = ahc_inb(ahc, SCBPTR);\n\n\tfound = ahc_search_qinfifo(ahc, target, channel, lun, SCB_LIST_NULL,\n\t\t\t\t   role, SCB_REQUEUE, SEARCH_COMPLETE);\n\n\t/*\n\t * Search waiting for selection list.\n\t */\n\t{\n\t\tu_int8_t next, prev;\n                /* Start at head of list. */\n\t\tnext = ahc_inb(ahc, WAITING_SCBH);\n\t\tprev = SCB_LIST_NULL;\n\n\t\twhile (next != SCB_LIST_NULL) {\n\t\t\tu_int8_t scb_index;\n\n\t\t\tahc_outb(ahc, SCBPTR, next);\n\t\t\tscb_index = ahc_inb(ahc, SCB_TAG);\n\t\t\tif (scb_index >= ahc->scb_data->numscbs) {\n\t\t\t\tpanic(\"Waiting List inconsistency. \"\n\t\t\t\t      \"SCB index == %d, yet numscbs == %d.\",\n\t\t\t\t      scb_index, ahc->scb_data->numscbs);\n\t\t\t}\n\t\t\tscbp = &ahc->scb_data->scbarray[scb_index];\n\t\t\tif (ahc_match_scb(scbp, target, channel,\n\t\t\t\t\t  lun, SCB_LIST_NULL, role)) {\n\n\t\t\t\tnext = ahc_abort_wscb(ahc, next, prev);\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tprev = next;\n\t\t\t\tnext = ahc_inb(ahc, SCB_NEXT);\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\t * Go through the disconnected list and remove any entries we\n\t * have queued for completion, 0'ing their control byte too.\n\t * We save the active SCB and restore it ourselves, so there\n\t * is no reason for this search to restore it too.\n\t */\n\tahc_search_disc_list(ahc, target, channel, lun, tag,\n\t\t\t     /*stop_on_first*/FALSE, /*remove*/TRUE,\n\t\t\t     /*save_state*/FALSE);\n\n\t/*\n\t * Go through the hardware SCB array looking for commands that\n\t * were active but not on any list.\n\t */\n\tfor(i = 0; i < ahc->scb_data->maxhscbs; i++) {\n\t\tu_int scbid;\n\n\t\tahc_outb(ahc, SCBPTR, i);\n\t\tscbid = ahc_inb(ahc, SCB_TAG);\n\t\tscbp = &ahc->scb_data->scbarray[scbid];\n\t\tif (scbid < ahc->scb_data->numscbs && \n\t\t\t ahc_match_scb(scbp, target, channel, lun, tag, role))\n\t\t\t\tahc_add_curscb_to_free_list(ahc);\n\t}\n\n\t/*\n\t * Go through the pending CCB list and look for\n\t * commands for this target that are still active.\n\t * These are other tagged commands that were\n\t * disconnected when the reset occured.\n\t */\n\t{\n\t\tstruct scb *scb;\n\n\t\tscb = ahc->pending_scbs.lh_first;\n\t\twhile (scb != NULL) {\n\t\t\tscbp = scb;\n\t\t\tscb = scb->pend_links.le_next;\n\t\t\tif (ahc_match_scb(scbp, target, channel,\n\t\t\t\t\t  lun, tag, role)) {\n\t\t\t\tif (!(scbp->xs->flags & ITSDONE))\n\t\t\t\t\tahcsetccbstatus(scbp->xs, status);\n\t\t\t\tahc_freeze_ccb(scbp);\n\t\t\t\tahc_done(ahc, scbp);\n\t\t\t\tfound++;\n\t\t\t}\n\t\t}\n\t}\n\tahc_outb(ahc, SCBPTR, active_scb);\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SCB_LUN",
          "args": [
            "scb"
          ],
          "line": 2409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCB_CHANNEL",
          "args": [
            "scb"
          ],
          "line": 2408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCB_TARGET",
          "args": [
            "scb"
          ],
          "line": 2408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 2400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCB_TAG"
          ],
          "line": 2388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCBPTR",
            "scbptr"
          ],
          "line": 2387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "WAITING_SCBH"
          ],
          "line": 2386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "CLRINT",
            "CLRSCSIINT"
          ],
          "line": 2381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "CLRSINT1",
            "CLRBUSFREE|CLRSCSIPERR"
          ],
          "line": 2380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SIMODE1",
            "ahc_inb(ahc, SIMODE1) & ~ENBUSFREE"
          ],
          "line": 2379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SIMODE1"
          ],
          "line": 2379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SEQADDR1"
          ],
          "line": 2376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SEQADDR0"
          ],
          "line": 2375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 2367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc_print_addr",
          "args": [
            "scb->xs->sc_link"
          ],
          "line": 2361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCB_LUN",
          "args": [
            "scb"
          ],
          "line": 2358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_handle_devreset",
          "args": [
            "ahc",
            "&devinfo",
            "XS_RESET",
            "\"Bus Device Reset\"",
            "/*verbose_level*/0"
          ],
          "line": 2336
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_handle_devreset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "3365-3394",
          "snippet": "STATIC void\nahc_handle_devreset(ahc, devinfo, status, message, verbose_level)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n\tint status;\n\tchar *message;\n\tint verbose_level;\n{\n\tint found;\n\n\tfound = ahc_abort_scbs(ahc, devinfo->target, devinfo->channel,\n\t\t\t       ALL_LUNS, SCB_LIST_NULL, devinfo->role,\n\t\t\t       status);\n\t\n\t/*\n\t * Go back to async/narrow transfers and renegotiate.\n\t * ahc_set_width and ahc_set_syncrate can cope with NULL\n\t * paths.\n\t */\n\tahc_set_width(ahc, devinfo, MSG_EXT_WDTR_BUS_8_BIT,\n\t\t      AHC_TRANS_CUR, /*paused*/TRUE, /*done*/FALSE);\n\tahc_set_syncrate(ahc, devinfo, /*syncrate*/NULL,\n\t\t\t /*period*/0, /*offset*/0, AHC_TRANS_CUR,\n\t\t\t /*paused*/TRUE, /*done*/FALSE);\n\t\n\tif (message != NULL\n\t && (verbose_level <= bootverbose))\n\t\tprintf(\"%s: %s on %c:%d. %d SCBs aborted\\n\", ahc_name(ahc),\n\t\t       message, devinfo->channel, devinfo->target, found);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define bootverbose\t0",
            "#define STATIC",
            "#define bootverbose\t1"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC int",
            "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_handle_devreset __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct ahc_devinfo *devinfo,\n\t\t\t\t\t int status, char *message,\n\t\t\t\t\t int verbose_level));",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "ahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "ahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));",
            "STATIC int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "ahc_update_target_msg_request __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t\t      struct ahc_initiator_tinfo *tinfo,\n\t\t\t\t\t      int force, int paused));",
            "STATIC void",
            "ahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));",
            "STATIC void",
            "ahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "u_int *period;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "u_int *period;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define bootverbose\t0\n#define STATIC\n#define bootverbose\t1\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_devreset __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct ahc_devinfo *devinfo,\n\t\t\t\t\t int status, char *message,\n\t\t\t\t\t int verbose_level));\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));\nSTATIC int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nahc_update_target_msg_request __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t\t      struct ahc_initiator_tinfo *tinfo,\n\t\t\t\t\t      int force, int paused));\nSTATIC void;\nahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));\nSTATIC void;\nahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_handle_devreset(ahc, devinfo, status, message, verbose_level)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n\tint status;\n\tchar *message;\n\tint verbose_level;\n{\n\tint found;\n\n\tfound = ahc_abort_scbs(ahc, devinfo->target, devinfo->channel,\n\t\t\t       ALL_LUNS, SCB_LIST_NULL, devinfo->role,\n\t\t\t       status);\n\t\n\t/*\n\t * Go back to async/narrow transfers and renegotiate.\n\t * ahc_set_width and ahc_set_syncrate can cope with NULL\n\t * paths.\n\t */\n\tahc_set_width(ahc, devinfo, MSG_EXT_WDTR_BUS_8_BIT,\n\t\t      AHC_TRANS_CUR, /*paused*/TRUE, /*done*/FALSE);\n\tahc_set_syncrate(ahc, devinfo, /*syncrate*/NULL,\n\t\t\t /*period*/0, /*offset*/0, AHC_TRANS_CUR,\n\t\t\t /*paused*/TRUE, /*done*/FALSE);\n\t\n\tif (message != NULL\n\t && (verbose_level <= bootverbose))\n\t\tprintf(\"%s: %s on %c:%d. %d SCBs aborted\\n\", ahc_name(ahc),\n\t\t       message, devinfo->channel, devinfo->target, found);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_compile_devinfo",
          "args": [
            "&devinfo",
            "initiator_role_id",
            "target",
            "TCL_LUN(saved_tcl)",
            "channel",
            "ROLE_INITIATOR"
          ],
          "line": 2330
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_compile_devinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "1568-1586",
          "snippet": "STATIC void\nahc_compile_devinfo(devinfo, our_id, target, lun, channel, role)\n\tstruct ahc_devinfo *devinfo;\n\tu_int our_id;\n\tu_int target;\n\tu_int lun;\n\tchar channel;\n\trole_t role;\n{\n\tdevinfo->our_scsiid = our_id;\n\tdevinfo->target = target;\n\tdevinfo->lun = lun;\n\tdevinfo->target_offset = target;\n\tdevinfo->channel = channel;\n\tdevinfo->role = role;\n\tif (channel == 'B')\n\t\tdevinfo->target_offset += 8;\n\tdevinfo->target_mask = (0x01 << devinfo->target_offset);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC int",
            "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "ahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "char channel;",
            "u_int our_id;",
            "STATIC struct",
            "STATIC struct",
            "STATIC struct",
            "char channel;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nchar channel;\nu_int our_id;\nSTATIC struct;\nSTATIC struct;\nSTATIC struct;\nchar channel;\n\nSTATIC void\nahc_compile_devinfo(devinfo, our_id, target, lun, channel, role)\n\tstruct ahc_devinfo *devinfo;\n\tu_int our_id;\n\tu_int target;\n\tu_int lun;\n\tchar channel;\n\trole_t role;\n{\n\tdevinfo->our_scsiid = our_id;\n\tdevinfo->target = target;\n\tdevinfo->lun = lun;\n\tdevinfo->target_offset = target;\n\tdevinfo->channel = channel;\n\tdevinfo->role = role;\n\tif (channel == 'B')\n\t\tdevinfo->target_offset += 8;\n\tdevinfo->target_mask = (0x01 << devinfo->target_offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TCL_LUN",
          "args": [
            "saved_tcl"
          ],
          "line": 2333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahcsetccbstatus",
          "args": [
            "scb->xs",
            "XS_NOERROR"
          ],
          "line": 2328
        },
        "resolved": true,
        "details": {
          "function_name": "ahcsetccbstatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "548-554",
          "snippet": "static __inline void\nahcsetccbstatus(xs, status)\n\tstruct scsi_xfer *xs;\n\tint status;\n{\n\txs->error = status;\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "ahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));",
            "STATIC struct",
            "STATIC struct",
            "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
            "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
            "static __inline void ahcsetccbstatus",
            "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
            "STATIC struct",
            "STATIC struct",
            "STATIC struct",
            "struct scsi_xfer *xs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nSTATIC struct;\nahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));\nSTATIC struct;\nSTATIC struct;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nstatic __inline void ahcsetccbstatus;\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nSTATIC struct;\nSTATIC struct;\nSTATIC struct;\nstruct scsi_xfer *xs;\n\nstatic __inline void\nahcsetccbstatus(xs, status)\n\tstruct scsi_xfer *xs;\n\tint status;\n{\n\txs->error = status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_match_scb",
          "args": [
            "scb",
            "target",
            "channel",
            "TCL_LUN(saved_tcl)",
            "SCB_LIST_NULL",
            "ROLE_INITIATOR"
          ],
          "line": 2324
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_match_scb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "5529-5549",
          "snippet": "STATIC int\nahc_match_scb(scb, target, channel, lun, role, tag)\n\tstruct scb *scb;\n\tint target;\n\tchar channel;\n\tint lun;\n\trole_t role;\n\tu_int tag;\n{\n\tint targ = SCB_TARGET(scb);\n\tchar chan = SCB_CHANNEL(scb);\n\tint slun = SCB_LUN(scb);\n\tint match;\n\n\tmatch = ((chan == channel) || (channel == ALL_CHANNELS));\n\tif (match != 0)\n\t\tmatch = ((targ == target) || (target == ALL_TARGETS));\n\tif (match != 0)\n\t\tmatch = ((lun == slun) || (lun == ALL_LUNS));\n\treturn match;\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC",
            "#define ALL_CHANNELS '\\0'"
          ],
          "globals_used": [
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "ahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_calc_residual __P((struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "char channel;",
            "STATIC struct",
            "STATIC struct",
            "STATIC struct",
            "char channel;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n#define ALL_CHANNELS '\\0'\n\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_calc_residual __P((struct scb *scb));\nSTATIC void;\nSTATIC void;\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nSTATIC void;\nSTATIC void;\nchar channel;\nSTATIC struct;\nSTATIC struct;\nSTATIC struct;\nchar channel;\n\nSTATIC int\nahc_match_scb(scb, target, channel, lun, role, tag)\n\tstruct scb *scb;\n\tint target;\n\tchar channel;\n\tint lun;\n\trole_t role;\n\tu_int tag;\n{\n\tint targ = SCB_TARGET(scb);\n\tchar chan = SCB_CHANNEL(scb);\n\tint slun = SCB_LUN(scb);\n\tint match;\n\n\tmatch = ((chan == channel) || (channel == ALL_CHANNELS));\n\tif (match != 0)\n\t\tmatch = ((targ == target) || (target == ALL_TARGETS));\n\tif (match != 0)\n\t\tmatch = ((lun == slun) || (lun == ALL_LUNS));\n\treturn match;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TCL_LUN",
          "args": [
            "saved_tcl"
          ],
          "line": 2325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TCL_LUN",
          "args": [
            "saved_tcl"
          ],
          "line": 2313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc_print_addr",
          "args": [
            "scb->xs->sc_link"
          ],
          "line": 2308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCSISEQ",
            "ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP)"
          ],
          "line": 2295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCSISEQ"
          ],
          "line": 2296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TCL_CHANNEL",
          "args": [
            "ahc",
            "saved_tcl"
          ],
          "line": 2292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TCL_SCSI_ID",
          "args": [
            "ahc",
            "saved_tcl"
          ],
          "line": 2291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TCL_TARGET",
          "args": [
            "saved_tcl"
          ],
          "line": 2290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SAVED_TCL"
          ],
          "line": 2289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "LASTPHASE"
          ],
          "line": 2288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SIMODE1"
          ],
          "line": 2281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "CLRINT",
            "CLRSCSIINT"
          ],
          "line": 2278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "MSG_OUT",
            "mesg_out"
          ],
          "line": 2276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCSIRATE"
          ],
          "line": 2263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SEQADDR1"
          ],
          "line": 2262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SEQADDR0"
          ],
          "line": 2262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TCL_TARGET",
          "args": [
            "ahc_inb(ahc, SAVED_TCL)"
          ],
          "line": 2257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SAVED_TCL"
          ],
          "line": 2257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 2255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc_print_addr",
          "args": [
            "scb->xs->sc_link"
          ],
          "line": 2253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SSTAT1"
          ],
          "line": 2241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "CLRSINT1",
            "CLRSCSIPERR"
          ],
          "line": 2229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCSISIGI"
          ],
          "line": 2228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "LASTPHASE"
          ],
          "line": 2227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_reset_channel",
          "args": [
            "ahc",
            "intr_channel",
            "/* Initiate Reset */FALSE"
          ],
          "line": 2209
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_reset_channel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "5412-5527",
          "snippet": "STATIC int\nahc_reset_channel(ahc, channel, initiate_reset)\n\tstruct ahc_softc *ahc;\n\tchar channel;\n\tint initiate_reset;\n{\n\tu_int\tinitiator, target, max_scsiid;\n\tu_int\tsblkctl;\n\tu_int\tour_id;\n\tint\tfound;\n\tint\trestart_needed;\n\tchar\tcur_channel;\n\n\tahc->pending_device = NULL;\n\n\tpause_sequencer(ahc);\n\n\t/*\n\t * Run our command complete fifos to ensure that we perform\n\t * completion processing on any commands that 'completed'\n\t * before the reset occurred.\n\t */\n\tahc_run_qoutfifo(ahc);\n\n\t/*\n\t * Reset the bus if we are initiating this reset\n\t */\n\tsblkctl = ahc_inb(ahc, SBLKCTL);\n\tcur_channel = 'A';\n\tif ((ahc->features & AHC_TWIN) != 0\n\t && ((sblkctl & SELBUSB) != 0))\n\t    cur_channel = 'B';\n\tif (cur_channel != channel) {\n\t\t/* Case 1: Command for another bus is active\n\t\t * Stealthily reset the other bus without\n\t\t * upsetting the current bus.\n\t\t */\n\t\tahc_outb(ahc, SBLKCTL, sblkctl ^ SELBUSB);\n\t\tahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENBUSFREE);\n\t\tahc_outb(ahc, SCSISEQ,\n\t\t\t ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP));\n\t\tif (initiate_reset)\n\t\t\tahc_reset_current_bus(ahc);\n\t\tahc_clear_intstat(ahc);\n\t\tahc_outb(ahc, SBLKCTL, sblkctl);\n\t\trestart_needed = FALSE;\n\t} else {\n\t\t/* Case 2: A command from this bus is active or we're idle */\n\t\tahc_clear_msg_state(ahc);\n\t\tahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENBUSFREE);\n\t\tahc_outb(ahc, SCSISEQ,\n\t\t\t ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP));\n\t\tif (initiate_reset)\n\t\t\tahc_reset_current_bus(ahc);\n\t\tahc_clear_intstat(ahc);\n\n\t\t/*\n\t\t * Since we are going to restart the sequencer, avoid\n\t\t * a race in the sequencer that could cause corruption\n\t\t * of our Q pointers by starting over from index 0.\n\t\t */\n\t\tahc->qoutfifonext = 0;\n\t\tif ((ahc->features & AHC_QUEUE_REGS) != 0)\n\t\t\tahc_outb(ahc, SDSCB_QOFF, 0);\n\t\telse\n\t\t\tahc_outb(ahc, QOUTPOS, 0);\n\t\trestart_needed = TRUE;\n\t}\n\n\t/*\n\t * Clean up all the state information for the\n\t * pending transactions on this bus.\n\t */\n\tfound = ahc_abort_scbs(ahc, ALL_TARGETS, channel,\n\t\t\t       ALL_LUNS, SCB_LIST_NULL,\n\t\t\t       ROLE_UNKNOWN, XS_RESET);\n\tif (channel == 'B') {\n\t\tour_id = ahc->our_id_b;\n\t} else {\n\t\tour_id = ahc->our_id;\n\t}\n\n\tmax_scsiid = (ahc->features & AHC_WIDE) ? 15 : 7;\n\t\n\t/*\n\t * Revert to async/narrow transfers until we renegotiate.\n\t */\n\tfor (target = 0; target <= max_scsiid; target++) {\n\n\t\tif (ahc->enabled_targets[target] == NULL)\n\t\t\tcontinue;\n\t\tfor (initiator = 0; initiator <= max_scsiid; initiator++) {\n\t\t\tstruct ahc_devinfo devinfo;\n\n\t\t\tahc_compile_devinfo(&devinfo, target, initiator,\n\t\t\t\t\t    ALL_LUNS,\n\t\t\t\t\t    channel, ROLE_UNKNOWN);\n\t\t\tahc_set_width(ahc, &devinfo,\n\t\t\t\t      MSG_EXT_WDTR_BUS_8_BIT,\n\t\t\t\t      AHC_TRANS_CUR,\n\t\t\t\t      /*paused*/TRUE,\n\t\t\t\t      /*done*/FALSE);\n\t\t\tahc_set_syncrate(ahc, &devinfo,\n\t\t\t\t\t /*syncrate*/NULL, /*period*/0,\n\t\t\t\t\t /*offset*/0, AHC_TRANS_CUR,\n\t\t\t\t\t /*paused*/TRUE,\n\t\t\t\t\t /*done*/FALSE);\n\t\t}\n\t}\n\n\tif (restart_needed)\n\t\trestart_sequencer(ahc);\n\telse\n\t\tunpause_sequencer(ahc);\n\treturn found;\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC int",
            "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "ahc_reset_channel __P((struct ahc_softc *ahc, char channel,\n\t\t\t\t       int initiate_reset));",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "ahc_update_target_msg_request __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t\t      struct ahc_initiator_tinfo *tinfo,\n\t\t\t\t\t      int force, int paused));",
            "STATIC void",
            "ahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));",
            "STATIC void",
            "ahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "static __inline void pause_sequencer",
            "static __inline void unpause_sequencer",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "u_int our_id;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "u_int *period;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "u_int *period;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nahc_reset_channel __P((struct ahc_softc *ahc, char channel,\n\t\t\t\t       int initiate_reset));\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nahc_update_target_msg_request __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t\t      struct ahc_initiator_tinfo *tinfo,\n\t\t\t\t\t      int force, int paused));\nSTATIC void;\nahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));\nSTATIC void;\nahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nstatic __inline void pause_sequencer;\nstatic __inline void unpause_sequencer;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nu_int our_id;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC int\nahc_reset_channel(ahc, channel, initiate_reset)\n\tstruct ahc_softc *ahc;\n\tchar channel;\n\tint initiate_reset;\n{\n\tu_int\tinitiator, target, max_scsiid;\n\tu_int\tsblkctl;\n\tu_int\tour_id;\n\tint\tfound;\n\tint\trestart_needed;\n\tchar\tcur_channel;\n\n\tahc->pending_device = NULL;\n\n\tpause_sequencer(ahc);\n\n\t/*\n\t * Run our command complete fifos to ensure that we perform\n\t * completion processing on any commands that 'completed'\n\t * before the reset occurred.\n\t */\n\tahc_run_qoutfifo(ahc);\n\n\t/*\n\t * Reset the bus if we are initiating this reset\n\t */\n\tsblkctl = ahc_inb(ahc, SBLKCTL);\n\tcur_channel = 'A';\n\tif ((ahc->features & AHC_TWIN) != 0\n\t && ((sblkctl & SELBUSB) != 0))\n\t    cur_channel = 'B';\n\tif (cur_channel != channel) {\n\t\t/* Case 1: Command for another bus is active\n\t\t * Stealthily reset the other bus without\n\t\t * upsetting the current bus.\n\t\t */\n\t\tahc_outb(ahc, SBLKCTL, sblkctl ^ SELBUSB);\n\t\tahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENBUSFREE);\n\t\tahc_outb(ahc, SCSISEQ,\n\t\t\t ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP));\n\t\tif (initiate_reset)\n\t\t\tahc_reset_current_bus(ahc);\n\t\tahc_clear_intstat(ahc);\n\t\tahc_outb(ahc, SBLKCTL, sblkctl);\n\t\trestart_needed = FALSE;\n\t} else {\n\t\t/* Case 2: A command from this bus is active or we're idle */\n\t\tahc_clear_msg_state(ahc);\n\t\tahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENBUSFREE);\n\t\tahc_outb(ahc, SCSISEQ,\n\t\t\t ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP));\n\t\tif (initiate_reset)\n\t\t\tahc_reset_current_bus(ahc);\n\t\tahc_clear_intstat(ahc);\n\n\t\t/*\n\t\t * Since we are going to restart the sequencer, avoid\n\t\t * a race in the sequencer that could cause corruption\n\t\t * of our Q pointers by starting over from index 0.\n\t\t */\n\t\tahc->qoutfifonext = 0;\n\t\tif ((ahc->features & AHC_QUEUE_REGS) != 0)\n\t\t\tahc_outb(ahc, SDSCB_QOFF, 0);\n\t\telse\n\t\t\tahc_outb(ahc, QOUTPOS, 0);\n\t\trestart_needed = TRUE;\n\t}\n\n\t/*\n\t * Clean up all the state information for the\n\t * pending transactions on this bus.\n\t */\n\tfound = ahc_abort_scbs(ahc, ALL_TARGETS, channel,\n\t\t\t       ALL_LUNS, SCB_LIST_NULL,\n\t\t\t       ROLE_UNKNOWN, XS_RESET);\n\tif (channel == 'B') {\n\t\tour_id = ahc->our_id_b;\n\t} else {\n\t\tour_id = ahc->our_id;\n\t}\n\n\tmax_scsiid = (ahc->features & AHC_WIDE) ? 15 : 7;\n\t\n\t/*\n\t * Revert to async/narrow transfers until we renegotiate.\n\t */\n\tfor (target = 0; target <= max_scsiid; target++) {\n\n\t\tif (ahc->enabled_targets[target] == NULL)\n\t\t\tcontinue;\n\t\tfor (initiator = 0; initiator <= max_scsiid; initiator++) {\n\t\t\tstruct ahc_devinfo devinfo;\n\n\t\t\tahc_compile_devinfo(&devinfo, target, initiator,\n\t\t\t\t\t    ALL_LUNS,\n\t\t\t\t\t    channel, ROLE_UNKNOWN);\n\t\t\tahc_set_width(ahc, &devinfo,\n\t\t\t\t      MSG_EXT_WDTR_BUS_8_BIT,\n\t\t\t\t      AHC_TRANS_CUR,\n\t\t\t\t      /*paused*/TRUE,\n\t\t\t\t      /*done*/FALSE);\n\t\t\tahc_set_syncrate(ahc, &devinfo,\n\t\t\t\t\t /*syncrate*/NULL, /*period*/0,\n\t\t\t\t\t /*offset*/0, AHC_TRANS_CUR,\n\t\t\t\t\t /*paused*/TRUE,\n\t\t\t\t\t /*done*/FALSE);\n\t\t}\n\t}\n\n\tif (restart_needed)\n\t\trestart_sequencer(ahc);\n\telse\n\t\tunpause_sequencer(ahc);\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 2208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SEQ_FLAGS"
          ],
          "line": 2201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCB_TAG"
          ],
          "line": 2197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 2192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SBLKCTL",
            "ahc_inb(ahc, SBLKCTL) ^ SELBUSB"
          ],
          "line": 2188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SBLKCTL"
          ],
          "line": 2188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SSTAT1"
          ],
          "line": 2187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SBLKCTL",
            "ahc_inb(ahc, SBLKCTL) ^ SELBUSB"
          ],
          "line": 2186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SBLKCTL"
          ],
          "line": 2186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SSTAT1"
          ],
          "line": 2182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SBLKCTL"
          ],
          "line": 2176
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nSTATIC void;\nahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nahc_handle_seqint __P((struct ahc_softc *ahc, u_int intstat));\nSTATIC void;\nahc_handle_scsiint __P((struct ahc_softc *ahc, u_int intstat));\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));\nSTATIC int;\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_devreset __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct ahc_devinfo *devinfo,\n\t\t\t\t\t int status, char *message,\n\t\t\t\t\t int verbose_level));\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));\nSTATIC int;\nSTATIC u_int;\nahc_rem_scb_from_disc_list __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tu_int prev, u_int scbptr));\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nSTATIC void;\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_calc_residual __P((struct scb *scb));\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nSTATIC void;\nstatic __inline void unpause_sequencer;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nstatic __inline void ahcsetccbstatus;\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nstatic struct {\n        u_int8_t phase;\n        u_int8_t mesg_out; /* Message response to parity errors */\n\tchar *phasemsg;\n} phase_table[] = {\n\t{ P_DATAOUT,\tMSG_NOOP,\t\t\"in Data-out phase\"\t},\n\t{ P_DATAIN,\tMSG_INITIATOR_DET_ERR,\t\"in Data-in phase\"\t},\n\t{ P_COMMAND,\tMSG_NOOP,\t\t\"in Command phase\"\t},\n\t{ P_MESGOUT,\tMSG_NOOP,\t\t\"in Message-out phase\"\t},\n\t{ P_STATUS,\tMSG_INITIATOR_DET_ERR,\t\"in Status phase\"\t},\n\t{ P_MESGIN,\tMSG_PARITY_ERROR,\t\"in Message-in phase\"\t},\n\t{ P_BUSFREE,\tMSG_NOOP,\t\t\"while idle\"\t\t},\n\t{ 0,\t\tMSG_NOOP,\t\t\"in unknown phase\"\t}\n};\nstatic const int num_phases = (sizeof(phase_table)/sizeof(phase_table[0])) - 1;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n\nSTATIC void\nahc_handle_scsiint(ahc, intstat)\n\tstruct ahc_softc *ahc;\n\tu_int intstat;\n{\n\tu_int\tscb_index;\n\tu_int\tstatus;\n\tstruct\tscb *scb;\n\tchar\tcur_channel;\n\tchar\tintr_channel;\n\n\tif ((ahc->features & AHC_TWIN) != 0\n\t && ((ahc_inb(ahc, SBLKCTL) & SELBUSB) != 0))\n\t\tcur_channel = 'B';\n\telse\n\t\tcur_channel = 'A';\n\tintr_channel = cur_channel;\n\n\tstatus = ahc_inb(ahc, SSTAT1);\n\tif (status == 0) {\n\t\tif ((ahc->features & AHC_TWIN) != 0) {\n\t\t\t/* Try the other channel */\n\t\t \tahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) ^ SELBUSB);\n\t\t\tstatus = ahc_inb(ahc, SSTAT1);\n\t\t \tahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) ^ SELBUSB);\n\t\t\tintr_channel = (cur_channel == 'A') ? 'B' : 'A';\n\t\t}\n\t\tif (status == 0) {\n\t\t\tprintf(\"%s: Spurious SCSI interrupt\\n\", ahc_name(ahc));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tscb_index = ahc_inb(ahc, SCB_TAG);\n\tif (scb_index < ahc->scb_data->numscbs) {\n\t\tscb = &ahc->scb_data->scbarray[scb_index];\n\t\tif ((scb->flags & SCB_ACTIVE) == 0\n\t\t || (ahc_inb(ahc, SEQ_FLAGS) & IDENTIFY_SEEN) == 0)\n\t\t\tscb = NULL;\n\t} else\n\t\tscb = NULL;\n\n\tif ((status & SCSIRSTI) != 0) {\n\t\tprintf(\"%s: Someone reset channel %c\\n\",\n\t\t\tahc_name(ahc), intr_channel);\n\t\tahc_reset_channel(ahc, intr_channel, /* Initiate Reset */FALSE);\n\t} else if ((status & SCSIPERR) != 0) {\n\t\t/*\n\t\t * Determine the bus phase and queue an appropriate message.\n\t\t * SCSIPERR is latched true as soon as a parity error\n\t\t * occurs.  If the sequencer acked the transfer that\n\t\t * caused the parity error and the currently presented\n\t\t * transfer on the bus has correct parity, SCSIPERR will\n\t\t * be cleared by CLRSCSIPERR.  Use this to determine if\n\t\t * we should look at the last phase the sequencer recorded,\n\t\t * or the current phase presented on the bus.\n\t\t */\n\t\tu_int mesg_out;\n\t\tu_int curphase;\n\t\tu_int errorphase;\n\t\tu_int lastphase;\n\t\tint   i;\n\n\t\tlastphase = ahc_inb(ahc, LASTPHASE);\n\t\tcurphase = ahc_inb(ahc, SCSISIGI) & PHASE_MASK;\n\t\tahc_outb(ahc, CLRSINT1, CLRSCSIPERR);\n\t\t/*\n\t\t * For all phases save DATA, the sequencer won't\n\t\t * automatically ack a byte that has a parity error\n\t\t * in it.  So the only way that the current phase\n\t\t * could be 'data-in' is if the parity error is for\n\t\t * an already acked byte in the data phase.  During\n\t\t * synchronous data-in transfers, we may actually\n\t\t * ack bytes before latching the current phase in\n\t\t * LASTPHASE, leading to the discrepancy between\n\t\t * curphase and lastphase.\n\t\t */\n\t\tif ((ahc_inb(ahc, SSTAT1) & SCSIPERR) != 0\n\t\t || curphase == P_DATAIN)\n\t\t\terrorphase = curphase;\n\t\telse\n\t\t\terrorphase = lastphase;\n\n\t\tfor (i = 0; i < num_phases; i++) {\n\t\t\tif (errorphase == phase_table[i].phase)\n\t\t\t\tbreak;\n\t\t}\n\t\tmesg_out = phase_table[i].mesg_out;\n\t\tif (scb != NULL)\n\t\t\tsc_print_addr(scb->xs->sc_link);\n\t\telse\n\t\t\tprintf(\"%s:%c:%d: \", ahc_name(ahc),\n\t\t\t       intr_channel,\n\t\t\t       TCL_TARGET(ahc_inb(ahc, SAVED_TCL)));\n\t\t\n\t\tprintf(\"parity error detected %s. \"\n\t\t       \"SEQADDR(0x%x) SCSIRATE(0x%x)\\n\",\n\t\t       phase_table[i].phasemsg,\n\t\t       ahc_inb(ahc, SEQADDR0) | (ahc_inb(ahc, SEQADDR1) << 8),\n\t\t       ahc_inb(ahc, SCSIRATE));\n\n\t\t/*\n\t\t * We've set the hardware to assert ATN if we   \n\t\t * get a parity error on \"in\" phases, so all we  \n\t\t * need to do is stuff the message buffer with\n\t\t * the appropriate message.  \"In\" phases have set\n\t\t * mesg_out to something other than MSG_NOP.\n\t\t */\n\t\tif (mesg_out != MSG_NOOP) {\n\t\t\tif (ahc->msg_type != MSG_TYPE_NONE)\n\t\t\t\tahc->send_msg_perror = TRUE;\n\t\t\telse\n\t\t\t\tahc_outb(ahc, MSG_OUT, mesg_out);\n\t\t}\n\t\tahc_outb(ahc, CLRINT, CLRSCSIINT);\n\t\tunpause_sequencer(ahc);\n\t} else if ((status & BUSFREE) != 0\n\t\t&& (ahc_inb(ahc, SIMODE1) & ENBUSFREE) != 0) {\n\t\t/*\n\t\t * First look at what phase we were last in.\n\t\t * If its message out, chances are pretty good\n\t\t * that the busfree was in response to one of\n\t\t * our abort requests.\n\t\t */\n\t\tu_int lastphase = ahc_inb(ahc, LASTPHASE);\n\t\tu_int saved_tcl = ahc_inb(ahc, SAVED_TCL);\n\t\tu_int target = TCL_TARGET(saved_tcl);\n\t\tu_int initiator_role_id = TCL_SCSI_ID(ahc, saved_tcl);\n\t\tchar channel = TCL_CHANNEL(ahc, saved_tcl);\n\t\tint printerror = 1;\n\n\t\tahc_outb(ahc, SCSISEQ,\n\t\t\t ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP));\n\t\tif (lastphase == P_MESGOUT) {\n\t\t\tu_int message;\n\t\t\tu_int tag;\n\n\t\t\tmessage = ahc->msgout_buf[ahc->msgout_index - 1];\n\t\t\ttag = SCB_LIST_NULL;\n\t\t\tswitch (message) {\n\t\t\tcase MSG_ABORT_TAG:\n\t\t\t\ttag = scb->hscb->tag;\n\t\t\t\t/* FALLTRHOUGH */\n\t\t\tcase MSG_ABORT:\n\t\t\t\tsc_print_addr(scb->xs->sc_link);\n\t\t\t\tprintf(\"SCB %d - Abort %s Completed.\\n\",\n\t\t\t\t       scb->hscb->tag, tag == SCB_LIST_NULL ?\n\t\t\t\t       \"\" : \"Tag\");\n\t\t\t\tahc_abort_scbs(ahc, target, channel,\n\t\t\t\t\t       TCL_LUN(saved_tcl), tag,\n\t\t\t\t\t       ROLE_INITIATOR,\n\t\t\t\t\t       XS_DRIVER_STUFFUP);\n\t\t\t\tprinterror = 0;\n\t\t\t\tbreak;\n\t\t\tcase MSG_BUS_DEV_RESET:\n\t\t\t{\n\t\t\t\tstruct ahc_devinfo devinfo;\n\n\t\t\t\tif (scb != NULL &&\n\t\t\t\t    (scb->xs->flags & SCSI_RESET)\n\t\t\t\t && ahc_match_scb(scb, target, channel,\n\t\t\t\t\t\t  TCL_LUN(saved_tcl),\n\t\t\t\t\t\t  SCB_LIST_NULL,\n\t\t\t\t\t\t  ROLE_INITIATOR)) {\n\t\t\t\t\tahcsetccbstatus(scb->xs, XS_NOERROR);\n\t\t\t\t}\n\t\t\t\tahc_compile_devinfo(&devinfo,\n\t\t\t\t\t\t    initiator_role_id,\n\t\t\t\t\t\t    target,\n\t\t\t\t\t\t    TCL_LUN(saved_tcl),\n\t\t\t\t\t\t    channel,\n\t\t\t\t\t\t    ROLE_INITIATOR);\n\t\t\t\tahc_handle_devreset(ahc, &devinfo,\n\t\t\t\t\t\t    XS_RESET,\n\t\t\t\t\t\t    \"Bus Device Reset\",\n\t\t\t\t\t\t    /*verbose_level*/0);\n\t\t\t\tprinterror = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (printerror != 0) {\n\t\t\tint i;\n\n\t\t\tif (scb != NULL) {\n\t\t\t\tu_int tag;\n\n\t\t\t\tif ((scb->hscb->control & TAG_ENB) != 0)\n\t\t\t\t\ttag = scb->hscb->tag;\n\t\t\t\telse\n\t\t\t\t\ttag = SCB_LIST_NULL;\n\t\t\t\tahc_abort_scbs(ahc, target, channel,\n\t\t\t\t\t       SCB_LUN(scb), tag,\n\t\t\t\t\t       ROLE_INITIATOR,\n\t\t\t\t\t       XS_DRIVER_STUFFUP);\n\t\t\t\tsc_print_addr(scb->xs->sc_link);\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * We had not fully identified this connection,\n\t\t\t\t * so we cannot abort anything.\n\t\t\t\t */\n\t\t\t\tprintf(\"%s: \", ahc_name(ahc));\n\t\t\t}\n\t\t\tfor (i = 0; i < num_phases; i++) {\n\t\t\t\tif (lastphase == phase_table[i].phase)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tprintf(\"Unexpected busfree %s\\n\"\n\t\t\t       \"SEQADDR == 0x%x\\n\",\n\t\t\t       phase_table[i].phasemsg, ahc_inb(ahc, SEQADDR0)\n\t\t\t\t| (ahc_inb(ahc, SEQADDR1) << 8));\n\t\t}\n\t\tahc_clear_msg_state(ahc);\n\t\tahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENBUSFREE);\n\t\tahc_outb(ahc, CLRSINT1, CLRBUSFREE|CLRSCSIPERR);\n\t\tahc_outb(ahc, CLRINT, CLRSCSIINT);\n\t\trestart_sequencer(ahc);\n\t} else if ((status & SELTO) != 0) {\n\t\tu_int scbptr;\n\n\t\tscbptr = ahc_inb(ahc, WAITING_SCBH);\n\t\tahc_outb(ahc, SCBPTR, scbptr);\n\t\tscb_index = ahc_inb(ahc, SCB_TAG);\n\n\t\tif (scb_index < ahc->scb_data->numscbs) {\n\t\t\tscb = &ahc->scb_data->scbarray[scb_index];\n\t\t\tif ((scb->flags & SCB_ACTIVE) == 0)\n\t\t\t\tscb = NULL;\n\t\t} else\n\t\t\tscb = NULL;\n\n\t\tif (scb == NULL) {\n\t\t\tprintf(\"%s: ahc_intr - referenced scb not \"\n\t\t\t       \"valid during SELTO scb(%d, %d)\\n\",\n\t\t\t       ahc_name(ahc), scbptr, scb_index);\n\t\t} else {\n\t\t\tu_int tag;\n\n\t\t\ttag = SCB_LIST_NULL;\n\t\t\tif ((scb->hscb->control & MSG_SIMPLE_Q_TAG) != 0)\n\t\t\t\ttag = scb->hscb->tag;\n\n\t\t\tahc_abort_scbs(ahc, SCB_TARGET(scb), SCB_CHANNEL(scb),\n\t\t\t\t       SCB_LUN(scb), tag,\n\t\t\t\t       ROLE_INITIATOR, XS_SELTIMEOUT);\n\t\t}\n\t\t/* Stop the selection */\n\t\tahc_outb(ahc, SCSISEQ, 0);\n\n\t\t/* No more pending messages */\n\t\tahc_clear_msg_state(ahc);\n\n\t\t/*\n\t\t * Although the driver does not care about the\n\t\t * 'Selection in Progress' status bit, the busy\n\t\t * LED does.  SELINGO is only cleared by a sucessful\n\t\t * selection, so we must manually clear it to ensure\n\t\t * the LED turns off just incase no future successful\n\t\t * selections occur (e.g. no devices on the bus).\n\t\t */\n\t\tahc_outb(ahc, CLRSINT0, CLRSELINGO);\n\n\t\t/* Clear interrupt state */\n\t\tahc_outb(ahc, CLRSINT1, CLRSELTIMEO|CLRBUSFREE|CLRSCSIPERR);\n\t\tahc_outb(ahc, CLRINT, CLRSCSIINT);\n\t\trestart_sequencer(ahc);\n\t} else {\n\t\tsc_print_addr(scb->xs->sc_link);\n\t\tprintf(\"Unknown SCSIINT. Status = 0x%x\\n\", status);\n\t\tahc_outb(ahc, CLRSINT1, status);\n\t\tahc_outb(ahc, CLRINT, CLRSCSIINT);\n\t\tunpause_sequencer(ahc);\n\t}\n}"
  },
  {
    "function_name": "ahc_handle_seqint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "1703-2162",
    "snippet": "STATIC void\nahc_handle_seqint(ahc, intstat)\n\tstruct ahc_softc *ahc;\n\tu_int intstat;\n{\n\tstruct scb *scb;\n\tstruct ahc_devinfo devinfo;\n\t\n\tahc_fetch_devinfo(ahc, &devinfo);\n\n\t/*\n\t * Clear the upper byte that holds SEQINT status\n\t * codes and clear the SEQINT bit. We will unpause\n\t * the sequencer, if appropriate, after servicing\n\t * the request.\n\t */\n\tahc_outb(ahc, CLRINT, CLRSEQINT);\n\tswitch (intstat & SEQINT_MASK) {\n\tcase NO_MATCH:\n\t{\n\t\t/* Ensure we don't leave the selection hardware on */\n\t\tahc_outb(ahc, SCSISEQ,\n\t\t\t ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP));\n\n\t\tprintf(\"%s:%c:%d: no active SCB for reconnecting \"\n\t\t       \"target - issuing BUS DEVICE RESET\\n\",\n\t\t       ahc_name(ahc), devinfo.channel, devinfo.target);\n\t\tprintf(\"SAVED_TCL == 0x%x, ARG_1 == 0x%x, SEQ_FLAGS == 0x%x\\n\",\n\t\t       ahc_inb(ahc, SAVED_TCL), ahc_inb(ahc, ARG_1),\n\t\t       ahc_inb(ahc, SEQ_FLAGS));\n\t\tahc->msgout_buf[0] = MSG_BUS_DEV_RESET;\n\t\tahc->msgout_len = 1;\n\t\tahc->msgout_index = 0;\n\t\tahc->msg_type = MSG_TYPE_INITIATOR_MSGOUT;\n\t\tahc_outb(ahc, MSG_OUT, HOST_MSG);\n\t\tahc_outb(ahc, SCSISIGO, ahc_inb(ahc, LASTPHASE) | ATNO);\n\t\tbreak;\n\t}\n\tcase UPDATE_TMSG_REQ:\n\t\tahc_outb(ahc, TARGET_MSG_REQUEST, ahc->targ_msg_req & 0xFF);\n\t\tahc_outb(ahc, TARGET_MSG_REQUEST + 1,\n\t\t\t (ahc->targ_msg_req >> 8) & 0xFF);\n\t\tahc_outb(ahc, HS_MAILBOX, 0);\n\t\tbreak;\n\tcase SEND_REJECT: \n\t{\n\t\tu_int rejbyte = ahc_inb(ahc, ACCUM);\n\t\tprintf(\"%s:%c:%d: Warning - unknown message received from \"\n\t\t       \"target (0x%x).  Rejecting\\n\", \n\t\t       ahc_name(ahc), devinfo.channel, devinfo.target, rejbyte);\n\t\tbreak; \n\t}\n\tcase NO_IDENT: \n\t{\n\t\t/*\n\t\t * The reconnecting target either did not send an identify\n\t\t * message, or did, but we didn't find and SCB to match and\n\t\t * before it could respond to our ATN/abort, it hit a dataphase.\n\t\t * The only safe thing to do is to blow it away with a bus\n\t\t * reset.\n\t\t */\n\t\tint found;\n\n\t\tprintf(\"%s:%c:%d: Target did not send an IDENTIFY message. \"\n\t\t       \"LASTPHASE = 0x%x, SAVED_TCL == 0x%x\\n\",\n\t\t       ahc_name(ahc), devinfo.channel, devinfo.target,\n\t\t       ahc_inb(ahc, LASTPHASE), ahc_inb(ahc, SAVED_TCL));\n\t\tfound = ahc_reset_channel(ahc, devinfo.channel, \n\t\t\t\t\t  /*initiate reset*/TRUE);\n\t\tprintf(\"%s: Issued Channel %c Bus Reset. \"\n\t\t       \"%d SCBs aborted\\n\", ahc_name(ahc), devinfo.channel,\n\t\t       found);\n\t\treturn;\n\t}\n\tcase BAD_PHASE:\n\t{\n\t\tu_int lastphase;\n\n\t\tlastphase = ahc_inb(ahc, LASTPHASE);\n\t\tif (lastphase == P_BUSFREE) {\n\t\t\tprintf(\"%s:%c:%d: Missed busfree.  Curphase = 0x%x\\n\",\n\t\t\t       ahc_name(ahc), devinfo.channel, devinfo.target,\n\t\t\t       ahc_inb(ahc, SCSISIGI));\n\t\t\trestart_sequencer(ahc);\n\t\t\treturn;\n\t\t} else {\n\t\t\tprintf(\"%s:%c:%d: unknown scsi bus phase %x.  \"\n\t\t\t       \"Attempting to continue\\n\",\n\t\t\t       ahc_name(ahc), devinfo.channel, devinfo.target,\n\t\t\t       ahc_inb(ahc, SCSISIGI));\n\t\t}\n\t\tbreak; \n\t}\n\tcase BAD_STATUS:\n\t{\n\t\tu_int  scb_index;\n\t\tstruct hardware_scb *hscb;\n\t\tstruct scsi_xfer *xs;\n\t\t/*\n\t\t * The sequencer will notify us when a command\n\t\t * has an error that would be of interest to\n\t\t * the kernel.  This allows us to leave the sequencer\n\t\t * running in the common case of command completes\n\t\t * without error.  The sequencer will already have\n\t\t * dma'd the SCB back up to us, so we can reference\n\t\t * the in kernel copy directly.\n\t\t */\n\t\tscb_index = ahc_inb(ahc, SCB_TAG);\n\t\tscb = &ahc->scb_data->scbarray[scb_index];\n\n\t\t/*\n\t\t * Set the default return value to 0 (don't\n\t\t * send sense).  The sense code will change\n\t\t * this if needed.\n\t\t */\n\t\tahc_outb(ahc, RETURN_1, 0);\n\t\tif (!(scb_index < ahc->scb_data->numscbs\n\t\t   && (scb->flags & SCB_ACTIVE) != 0)) {\n\t\t\tprintf(\"%s:%c:%d: ahc_intr - referenced scb \"\n\t\t\t       \"not valid during seqint 0x%x scb(%d)\\n\",\n\t\t\t       ahc_name(ahc), devinfo.channel,\n\t\t\t       devinfo.target, intstat, scb_index);\n\t\t\tgoto unpause;\n\t\t}\n\n\t\thscb = scb->hscb; \n\t\txs = scb->xs;\n\n\t\t/* Don't want to clobber the original sense code */\n\t\tif ((scb->flags & SCB_SENSE) != 0) {\n\t\t\t/*\n\t\t\t * Clear the SCB_SENSE Flag and have\n\t\t\t * the sequencer do a normal command\n\t\t\t * complete.\n\t\t\t */\n\t\t\tscb->flags &= ~SCB_SENSE;\n\t\t\tahcsetccbstatus(xs, XS_DRIVER_STUFFUP);\n\t\t\tbreak;\n\t\t}\n\t\t/* Freeze the queue unit the client sees the error. */\n\t\tahc_freeze_devq(ahc, xs->sc_link);\n\t\tahc_freeze_ccb(scb);\n\t\txs->status = hscb->status;\n\t\tswitch (hscb->status) {\n\t\tcase SCSI_OK:\n\t\t\tprintf(\"%s: Interrupted for staus of 0???\\n\",\n\t\t\t       ahc_name(ahc));\n\t\t\tbreak;\n\t\tcase SCSI_CHECK:\n#ifdef AHC_DEBUG\n\t\t\tif (ahc_debug & AHC_SHOWSENSE) {\n\t\t\t\tsc_print_addr(scb->xs->sc_link);\n\t\t\t\tprintf(\"SCB %d: requests Check Status\\n\",\n\t\t\t\t       scb->hscb->tag);\n\t\t\t}\n#endif\n\t\t\t\t\n\t\t\tif (xs->error == XS_NOERROR &&\n\t\t\t    !(scb->flags & SCB_SENSE)) {\n\t\t\t\tstruct ahc_dma_seg *sg;\n\t\t\t\tstruct scsi_sense *sc;\n\t\t\t\tstruct ahc_initiator_tinfo *tinfo;\n\t\t\t\tstruct tmode_tstate *tstate;\n\n\t\t\t\tsg = scb->sg_list;\n\t\t\t\tsc = (struct scsi_sense *)(&hscb->cmdstore); \n\t\t\t\t/*\n\t\t\t\t * Save off the residual if there is one.\n\t\t\t\t */\n\t\t\t\tif (hscb->residual_SG_count != 0)\n\t\t\t\t\tahc_calc_residual(scb);\n\t\t\t\telse\n\t\t\t\t\txs->resid = 0;\n\n#ifdef AHC_DEBUG\n\t\t\t\tif (ahc_debug & AHC_SHOWSENSE) {\n\t\t\t\t\tsc_print_addr(scb->xs->sc_link);\n\t\t\t\t\tprintf(\"Sending Sense\\n\");\n\t\t\t\t}\n#endif\n\t\t\t\tsg->addr = ahc->scb_data->sense_busaddr +\n\t\t\t\t\t(hscb->tag*sizeof(struct scsi_sense_data));\n\t\t\t\t\n\t\t\t\tsg->len = sizeof(struct scsi_sense_data);\n\n\t\t\t\tsc->opcode = REQUEST_SENSE;\n\t\t\t\tsc->byte2 =  SCB_LUN(scb) << 5;\n\t\t\t\tsc->unused[0] = 0;\n\t\t\t\tsc->unused[1] = 0;\n\t\t\t\tsc->length = sg->len;\n\t\t\t\tsc->control = 0;\n\n\t\t\t\t/*\n\t\t\t\t * Would be nice to preserve DISCENB here,\n\t\t\t\t * but due to the way we page SCBs, we can't.\n\t\t\t\t */\n\t\t\t\thscb->control = 0;\n\n\t\t\t\t/*\n\t\t\t\t * This request sense could be because the\n\t\t\t\t * the device lost power or in some other\n\t\t\t\t * way has lost our transfer negotiations.\n\t\t\t\t * Renegotiate if appropriate.\n\t\t\t\t */\n\t\t\t\tahc_calc_residual(scb);\n#ifdef AHC_DEBUG\n\t\t\t\tif (ahc_debug & AHC_SHOWSENSE) {\n\t\t\t\t\tsc_print_addr(xs->sc_link);\n\t\t\t\t\tprintf(\"Sense: datalen %d resid %d\"\n\t\t\t\t\t       \"chan %d id %d targ %d\\n\",\n\t\t\t\t\t       xs->datalen, xs->resid,\n\t\t\t\t\t       devinfo.channel,\n\t\t\t\t\t       devinfo.our_scsiid,\n\t\t\t\t\t       devinfo.target);\n\t\t\t\t}\n#endif\n\t\t\t\tif (xs->datalen > 0 &&\n\t\t\t\t    xs->resid == xs->datalen) {\n\t\t\t\ttinfo = ahc_fetch_transinfo(ahc,\n\t\t\t\t\t\t\t    devinfo.channel,\n\t\t\t\t\t\t\t    devinfo.our_scsiid,\n\t\t\t\t\t\t\t    devinfo.target,\n\t\t\t\t\t\t\t    &tstate);\n\t\t\t\t\tahc_update_target_msg_request(ahc,\n\t\t\t\t\t\t\t      &devinfo,\n\t\t\t\t\t\t\t      tinfo,\n\t\t\t\t\t\t\t      /*force*/TRUE,\n\t\t\t\t\t\t\t      /*paused*/TRUE);\n\t\t\t\t}\n\t\t\t\thscb->status = 0;\n\t\t\t\thscb->SG_count = 1;\n\t\t\t\thscb->SG_pointer = scb->sg_list_phys;\n\t\t\t\thscb->data = sg->addr; \n\t\t\t\thscb->datalen = sg->len;\n\t\t\t\thscb->cmdpointer = hscb->cmdstore_busaddr;\n\t\t\t\thscb->cmdlen = sizeof(*sc);\n\t\t\t\tscb->sg_count = hscb->SG_count;\n\t\t\t\tscb->flags |= SCB_SENSE;\n\t\t\t\t/*\n\t\t\t\t * Ensure the target is busy since this\n\t\t\t\t * will be an untagged request.\n\t\t\t\t */\n\t\t\t\tahc_busy_tcl(ahc, scb);\n\t\t\t\tahc_outb(ahc, RETURN_1, SEND_SENSE);\n\n\t\t\t\t/*\n\t\t\t\t * Ensure we have enough time to actually\n\t\t\t\t * retrieve the sense.\n\t\t\t\t */\n\t\t\t\tif (!(scb->xs->flags & SCSI_POLL)) {\n\t\t\t\tuntimeout(ahc_timeout, (caddr_t)scb);\n\t\t\t\t\ttimeout(ahc_timeout, (caddr_t)scb,\n\t\t\t\t\t    5 * hz);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SCSI_BUSY:\n\t\t\t/*\n\t\t\t * Requeue any transactions that haven't been\n\t\t\t * sent yet.\n\t\t\t */\n\t\t\tahc_freeze_devq(ahc, xs->sc_link);\n\t\t\tahc_freeze_ccb(scb);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\tcase TRACE_POINT:\n\t{\n\t\tprintf(\"SSTAT2 = 0x%x DFCNTRL = 0x%x\\n\", ahc_inb(ahc, SSTAT2),\n\t\t       ahc_inb(ahc, DFCNTRL));\n\t\tprintf(\"SSTAT3 = 0x%x DSTATUS = 0x%x\\n\", ahc_inb(ahc, SSTAT3),\n\t\t       ahc_inb(ahc, DFSTATUS));\n\t\tprintf(\"SSTAT0 = 0x%x, SCB_DATACNT = 0x%x\\n\",\n\t\t       ahc_inb(ahc, SSTAT0),\n\t\t       ahc_inb(ahc, SCB_DATACNT));\n\t\tbreak;\n\t}\n\tcase HOST_MSG_LOOP:\n\t{\n\t\t/*\n\t\t * The sequencer has encountered a message phase\n\t\t * that requires host assistance for completion.\n\t\t * While handling the message phase(s), we will be\n\t\t * notified by the sequencer after each byte is\n\t\t * transfered so we can track bus phases.\n\t\t *\n\t\t * If this is the first time we've seen a HOST_MSG_LOOP,\n\t\t * initialize the state of the host message loop.\n\t\t */\n\t\tif (ahc->msg_type == MSG_TYPE_NONE) {\n\t\t\tu_int bus_phase;\n\n\t\t\tbus_phase = ahc_inb(ahc, SCSISIGI) & PHASE_MASK;\n\t\t\tif (bus_phase != P_MESGIN\n\t\t\t && bus_phase != P_MESGOUT) {\n\t\t\t\tprintf(\"ahc_intr: HOST_MSG_LOOP bad \"\n\t\t\t\t       \"phase 0x%x\\n\",\n\t\t\t\t      bus_phase);\n\t\t\t\t/*\n\t\t\t\t * Probably transitioned to bus free before\n\t\t\t\t * we got here.  Just punt the message.\n\t\t\t\t */\n\t\t\t\tahc_clear_intstat(ahc);\n\t\t\t\trestart_sequencer(ahc);\n\t\t\t}\n\n\t\t\tif (devinfo.role == ROLE_INITIATOR) {\n\t\t\t\tstruct scb *scb;\n\t\t\t\tu_int scb_index;\n\n\t\t\t\tscb_index = ahc_inb(ahc, SCB_TAG);\n\t\t\t\tscb = &ahc->scb_data->scbarray[scb_index];\n\n\t\t\t\tif (bus_phase == P_MESGOUT)\n\t\t\t\t\tahc_setup_initiator_msgout(ahc,\n\t\t\t\t\t\t\t\t   &devinfo,\n\t\t\t\t\t\t\t\t   scb);\n\t\t\t\telse {\n\t\t\t\t\tahc->msg_type =\n\t\t\t\t\t    MSG_TYPE_INITIATOR_MSGIN;\n\t\t\t\t\tahc->msgin_index = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (bus_phase == P_MESGOUT) {\n\t\t\t\t\tahc->msg_type =\n\t\t\t\t\t    MSG_TYPE_TARGET_MSGOUT;\n\t\t\t\t\tahc->msgin_index = 0;\n\t\t\t\t} else \n\t\t\t\t\t/* XXX Ever executed??? */\n\t\t\t\t\tahc_setup_target_msgin(ahc, &devinfo);\n\t\t\t}\n\t\t}\n\n\t\t/* Pass a NULL path so that handlers generate their own */\n\t\tahc_handle_message_phase(ahc, /*path*/NULL);\n\t\tbreak;\n\t}\n\tcase PERR_DETECTED:\n\t{\n\t\t/*\n\t\t * If we've cleared the parity error interrupt\n\t\t * but the sequencer still believes that SCSIPERR\n\t\t * is true, it must be that the parity error is\n\t\t * for the currently presented byte on the bus,\n\t\t * and we are not in a phase (data-in) where we will\n\t\t * eventually ack this byte.  Ack the byte and\n\t\t * throw it away in the hope that the target will\n\t\t * take us to message out to deliver the appropriate\n\t\t * error message.\n\t\t */\n\t\tif ((intstat & SCSIINT) == 0\n\t\t && (ahc_inb(ahc, SSTAT1) & SCSIPERR) != 0) {\n\t\t\tu_int curphase;\n\n\t\t\t/*\n\t\t\t * The hardware will only let you ack bytes\n\t\t\t * if the expected phase in SCSISIGO matches\n\t\t\t * the current phase.  Make sure this is\n\t\t\t * currently the case.\n\t\t\t */\n\t\t\tcurphase = ahc_inb(ahc, SCSISIGI) & PHASE_MASK;\n\t\t\tahc_outb(ahc, LASTPHASE, curphase);\n\t\t\tahc_outb(ahc, SCSISIGO, curphase);\n\t\t\tahc_inb(ahc, SCSIDATL);\n\t\t}\n\t\tbreak;\n\t}\n\tcase DATA_OVERRUN:\n\t{\n\t\t/*\n\t\t * When the sequencer detects an overrun, it\n\t\t * places the controller in \"BITBUCKET\" mode\n\t\t * and allows the target to complete its transfer.\n\t\t * Unfortunately, none of the counters get updated\n\t\t * when the controller is in this mode, so we have\n\t\t * no way of knowing how large the overrun was.\n\t\t */\n\t\tu_int scbindex = ahc_inb(ahc, SCB_TAG);\n\t\tu_int lastphase = ahc_inb(ahc, LASTPHASE);\n\t\tint i;\n\n\t\tscb = &ahc->scb_data->scbarray[scbindex];\n\t\tfor (i = 0; i < num_phases; i++) {\n\t\t\tif (lastphase == phase_table[i].phase)\n\t\t\t\tbreak;\n\t\t}\n\t\tsc_print_addr(scb->xs->sc_link);\n\t\tprintf(\"data overrun detected %s.\"\n\t\t       \"  Tag == 0x%x.\\n\",\n\t\t       phase_table[i].phasemsg,\n  \t\t       scb->hscb->tag);\n\t\tsc_print_addr(scb->xs->sc_link);\n\t\tprintf(\"%s seen Data Phase.  Length = %d.  NumSGs = %d.\\n\",\n\t\t       ahc_inb(ahc, SEQ_FLAGS) & DPHASE ? \"Have\" : \"Haven't\",\n\t\t       scb->xs->datalen, scb->sg_count);\n\t\tif (scb->sg_count > 0) {\n\t\t\tfor (i = 0; i < scb->sg_count; i++) {\n\t\t\t\tprintf(\"sg[%d] - Addr 0x%x : Length %d\\n\",\n\t\t\t\t       i,\n\t\t\t\t       scb->sg_list[i].addr,\n\t\t\t\t       scb->sg_list[i].len);\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Set this and it will take affect when the\n\t\t * target does a command complete.\n\t\t */\n\t\tahc_freeze_devq(ahc, scb->xs->sc_link);\n\t\tahcsetccbstatus(scb->xs, XS_DRIVER_STUFFUP);\n\t\tahc_freeze_ccb(scb);\n\t\tbreak;\n\t}\n\tcase TRACEPOINT:\n\t{\n\t\tprintf(\"TRACEPOINT: RETURN_2 = %d\\n\", ahc_inb(ahc, RETURN_2));\n#if 0\n\t\tprintf(\"SSTAT1 == 0x%x\\n\", ahc_inb(ahc, SSTAT1));\n\t\tprintf(\"SSTAT0 == 0x%x\\n\", ahc_inb(ahc, SSTAT0));\n\t\tprintf(\", SCSISIGI == 0x%x\\n\", ahc_inb(ahc, SCSISIGI));\n\t\tprintf(\"TRACEPOINT: CCHCNT = %d, SG_COUNT = %d\\n\",\n\t\t       ahc_inb(ahc, CCHCNT), ahc_inb(ahc, SG_COUNT));\n\t\tprintf(\"TRACEPOINT: SCB_TAG = %d\\n\", ahc_inb(ahc, SCB_TAG));\n\t\tprintf(\"TRACEPOINT1: CCHADDR = %d, CCHCNT = %d, SCBPTR = %d\\n\",\n\t\t       ahc_inb(ahc, CCHADDR)\n\t\t    | (ahc_inb(ahc, CCHADDR+1) << 8)\n\t\t    | (ahc_inb(ahc, CCHADDR+2) << 16)\n\t\t    | (ahc_inb(ahc, CCHADDR+3) << 24),\n\t\t       ahc_inb(ahc, CCHCNT)\n\t\t    | (ahc_inb(ahc, CCHCNT+1) << 8)\n\t\t    | (ahc_inb(ahc, CCHCNT+2) << 16),\n\t\t       ahc_inb(ahc, SCBPTR));\n\t\tprintf(\"TRACEPOINT: WAITING_SCBH = %d\\n\", \n\t\t       ahc_inb(ahc, WAITING_SCBH));\n\t\tprintf(\"TRACEPOINT: SCB_TAG = %d\\n\", ahc_inb(ahc, SCB_TAG));\n#endif\n\t\tbreak;\n\t}\n#if NOT_YET\n\t/* XXX Fill these in later */\n\tcase MESG_BUFFER_BUSY:\n\t\tbreak;\n\tcase MSGIN_PHASEMIS:\n\t\tbreak;\n#endif\n\tdefault:\n\t\tprintf(\"ahc_intr: seqint, \"\n\t\t       \"intstat == 0x%x, scsisigi = 0x%x\\n\",\n\t\t       intstat, ahc_inb(ahc, SCSISIGI));\n\t\tbreak;\n\t}\n\t\nunpause:\n\t/*\n\t *  The sequencer is paused immediately on\n\t *  a SEQINT, so we should restart it when\n\t *  we're done.\n\t */\n\tunpause_sequencer(ahc);\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define STATIC\tstatic",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
      "STATIC void",
      "ahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));",
      "STATIC void",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
      "STATIC void",
      "ahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));",
      "STATIC u_int",
      "STATIC void",
      "STATIC struct",
      "STATIC void",
      "ahc_handle_seqint __P((struct ahc_softc *ahc, u_int intstat));",
      "STATIC void",
      "ahc_handle_scsiint __P((struct ahc_softc *ahc, u_int intstat));",
      "STATIC void",
      "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
      "STATIC void",
      "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
      "STATIC void",
      "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
      "STATIC int",
      "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
      "STATIC void",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));",
      "STATIC int",
      "STATIC int",
      "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
      "STATIC void",
      "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
      "STATIC void",
      "STATIC void",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "ahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "ahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));",
      "STATIC int",
      "STATIC u_int",
      "STATIC void",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "STATIC u_int",
      "STATIC void",
      "STATIC void",
      "ahc_update_target_msg_request __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t\t      struct ahc_initiator_tinfo *tinfo,\n\t\t\t\t\t      int force, int paused));",
      "STATIC void",
      "ahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));",
      "STATIC void",
      "ahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));",
      "STATIC void",
      "STATIC int",
      "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
      "STATIC void",
      "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_calc_residual __P((struct scb *scb));",
      "STATIC void",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
      "STATIC void",
      "static __inline void unpause_sequencer",
      "STATIC void",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "static __inline void\tahc_busy_tcl",
      "static __inline void ahc_freeze_ccb",
      "static __inline void ahcsetccbstatus",
      "STATIC void",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "static __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo",
      "STATIC void",
      "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
      "STATIC void",
      "STATIC void",
      "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "char channel;",
      "struct tmode_tstate **tstate;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "static struct {\n        u_int8_t phase;\n        u_int8_t mesg_out; /* Message response to parity errors */\n\tchar *phasemsg;\n} phase_table[] = {\n\t{ P_DATAOUT,\tMSG_NOOP,\t\t\"in Data-out phase\"\t},\n\t{ P_DATAIN,\tMSG_INITIATOR_DET_ERR,\t\"in Data-in phase\"\t},\n\t{ P_COMMAND,\tMSG_NOOP,\t\t\"in Command phase\"\t},\n\t{ P_MESGOUT,\tMSG_NOOP,\t\t\"in Message-out phase\"\t},\n\t{ P_STATUS,\tMSG_INITIATOR_DET_ERR,\t\"in Status phase\"\t},\n\t{ P_MESGIN,\tMSG_PARITY_ERROR,\t\"in Message-in phase\"\t},\n\t{ P_BUSFREE,\tMSG_NOOP,\t\t\"while idle\"\t\t},\n\t{ 0,\t\tMSG_NOOP,\t\t\"in unknown phase\"\t}\n};",
      "static const int num_phases = (sizeof(phase_table)/sizeof(phase_table[0])) - 1;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "char channel;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *xs;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unpause_sequencer",
          "args": [
            "ahc"
          ],
          "line": 2161
        },
        "resolved": true,
        "details": {
          "function_name": "unpause_sequencer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "456-462",
          "snippet": "static __inline void\nunpause_sequencer(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tif ((ahc_inb(ahc, INTSTAT) & (SCSIINT | SEQINT | BRKADRINT)) == 0)\n\t\tahc_outb(ahc, HCNTRL, ahc->unpause);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "static __inline void unpause_sequencer",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC struct;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nahc_loadseq __P((struct ahc_softc *ahc));\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nahc_clear_intstat __P((struct ahc_softc *ahc));\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nstatic __inline void unpause_sequencer;\nrestart_sequencer __P((struct ahc_softc *ahc));\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nstatic __inline void\nunpause_sequencer(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tif ((ahc_inb(ahc, INTSTAT) & (SCSIINT | SEQINT | BRKADRINT)) == 0)\n\t\tahc_outb(ahc, HCNTRL, ahc->unpause);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ahc_intr: seqint, \"\n\t\t       \"intstat == 0x%x, scsisigi = 0x%x\\n\"",
            "intstat",
            "ahc_inb(ahc, SCSISIGI)"
          ],
          "line": 2149
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCSISIGI"
          ],
          "line": 2151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCB_TAG"
          ],
          "line": 2137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "WAITING_SCBH"
          ],
          "line": 2136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCBPTR"
          ],
          "line": 2134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "CCHCNT+2"
          ],
          "line": 2133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "CCHCNT+1"
          ],
          "line": 2132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "CCHCNT"
          ],
          "line": 2131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "CCHADDR+3"
          ],
          "line": 2130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "CCHADDR+2"
          ],
          "line": 2129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "CCHADDR+1"
          ],
          "line": 2128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "CCHADDR"
          ],
          "line": 2127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCB_TAG"
          ],
          "line": 2125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SG_COUNT"
          ],
          "line": 2124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "CCHCNT"
          ],
          "line": 2124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCSISIGI"
          ],
          "line": 2122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SSTAT0"
          ],
          "line": 2121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SSTAT1"
          ],
          "line": 2120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "RETURN_2"
          ],
          "line": 2118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_freeze_ccb",
          "args": [
            "scb"
          ],
          "line": 2113
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_freeze_ccb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "533-546",
          "snippet": "static __inline void\nahc_freeze_ccb(scb)\n\tstruct scb *scb;\n{\n\tstruct scsi_xfer *xs = scb->xs;\n\tstruct ahc_softc *ahc = (struct ahc_softc *)xs->sc_link->adapter_softc;\n\tint target;\n\n\ttarget = xs->sc_link->target;\n\tif (!(scb->flags & SCB_FREEZE_QUEUE)) {\n\t\tahc->devqueue_blocked[target]++;\n\t\tscb->flags |= SCB_FREEZE_QUEUE;\n\t}\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
            "ahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "ahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
            "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
            "ahc_calc_residual __P((struct scb *scb));",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "static __inline void ahc_freeze_ccb",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
            "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *xs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC struct;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));\nahc_loadseq __P((struct ahc_softc *ahc));\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nahc_clear_intstat __P((struct ahc_softc *ahc));\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nahc_calc_residual __P((struct scb *scb));\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nrestart_sequencer __P((struct ahc_softc *ahc));\nstatic __inline void ahc_freeze_ccb;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n\nstatic __inline void\nahc_freeze_ccb(scb)\n\tstruct scb *scb;\n{\n\tstruct scsi_xfer *xs = scb->xs;\n\tstruct ahc_softc *ahc = (struct ahc_softc *)xs->sc_link->adapter_softc;\n\tint target;\n\n\ttarget = xs->sc_link->target;\n\tif (!(scb->flags & SCB_FREEZE_QUEUE)) {\n\t\tahc->devqueue_blocked[target]++;\n\t\tscb->flags |= SCB_FREEZE_QUEUE;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahcsetccbstatus",
          "args": [
            "scb->xs",
            "XS_DRIVER_STUFFUP"
          ],
          "line": 2112
        },
        "resolved": true,
        "details": {
          "function_name": "ahcsetccbstatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "548-554",
          "snippet": "static __inline void\nahcsetccbstatus(xs, status)\n\tstruct scsi_xfer *xs;\n\tint status;\n{\n\txs->error = status;\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "ahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));",
            "STATIC struct",
            "STATIC struct",
            "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
            "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
            "static __inline void ahcsetccbstatus",
            "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
            "STATIC struct",
            "STATIC struct",
            "STATIC struct",
            "struct scsi_xfer *xs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nSTATIC struct;\nahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));\nSTATIC struct;\nSTATIC struct;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nstatic __inline void ahcsetccbstatus;\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nSTATIC struct;\nSTATIC struct;\nSTATIC struct;\nstruct scsi_xfer *xs;\n\nstatic __inline void\nahcsetccbstatus(xs, status)\n\tstruct scsi_xfer *xs;\n\tint status;\n{\n\txs->error = status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_freeze_devq",
          "args": [
            "ahc",
            "scb->xs->sc_link"
          ],
          "line": 2111
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_freeze_devq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "4434-4450",
          "snippet": "STATIC void\nahc_freeze_devq(ahc, sc_link)\n\tstruct ahc_softc *ahc;\n\tstruct scsi_link *sc_link;\n{\n\tint\ttarget;\n\tchar\tchannel;\n\tint\tlun;\n\n\ttarget = sc_link->target;\n\tlun = sc_link->lun;\n\tchannel = SIM_CHANNEL(ahc, sc_link);\n\t\n\tahc_search_qinfifo(ahc, target, channel, lun,\n\t\t\t   /*tag*/SCB_LIST_NULL, ROLE_UNKNOWN,\n\t\t\t   SCB_REQUEUE, SEARCH_COMPLETE);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "ahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_freeze_devq(ahc, sc_link)\n\tstruct ahc_softc *ahc;\n\tstruct scsi_link *sc_link;\n{\n\tint\ttarget;\n\tchar\tchannel;\n\tint\tlun;\n\n\ttarget = sc_link->target;\n\tlun = sc_link->lun;\n\tchannel = SIM_CHANNEL(ahc, sc_link);\n\t\n\tahc_search_qinfifo(ahc, target, channel, lun,\n\t\t\t   /*tag*/SCB_LIST_NULL, ROLE_UNKNOWN,\n\t\t\t   SCB_REQUEUE, SEARCH_COMPLETE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SEQ_FLAGS"
          ],
          "line": 2097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc_print_addr",
          "args": [
            "scb->xs->sc_link"
          ],
          "line": 2095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc_print_addr",
          "args": [
            "scb->xs->sc_link"
          ],
          "line": 2090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "LASTPHASE"
          ],
          "line": 2082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCB_TAG"
          ],
          "line": 2081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCSIDATL"
          ],
          "line": 2067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCSISIGO",
            "curphase"
          ],
          "line": 2066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "LASTPHASE",
            "curphase"
          ],
          "line": 2065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCSISIGI"
          ],
          "line": 2064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SSTAT1"
          ],
          "line": 2055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_handle_message_phase",
          "args": [
            "ahc",
            "/*path*/NULL"
          ],
          "line": 2038
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_handle_message_phase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "2690-2937",
          "snippet": "STATIC void\nahc_handle_message_phase(ahc, sc_link)\n\tstruct ahc_softc *ahc;\n\tstruct scsi_link *sc_link;\n{ \n\tstruct\tahc_devinfo devinfo;\n\tu_int\tbus_phase;\n\tint\tend_session;\n\n\tahc_fetch_devinfo(ahc, &devinfo);\n\tend_session = FALSE;\n\tbus_phase = ahc_inb(ahc, SCSISIGI) & PHASE_MASK;\n\nreswitch:\n\tswitch (ahc->msg_type) {\n\tcase MSG_TYPE_INITIATOR_MSGOUT:\n\t{\n\t\tint lastbyte;\n\t\tint phasemis;\n\t\tint msgdone;\n\n\t\tif (ahc->msgout_len == 0)\n\t\t\tpanic(\"REQINIT interrupt with no active message\");\n\n\t\tphasemis = bus_phase != P_MESGOUT;\n\t\tif (phasemis) {\n\t\t\tif (bus_phase == P_MESGIN) {\n\t\t\t\t/*\n\t\t\t\t * Change gears and see if\n\t\t\t\t * this messages is of interest to\n\t\t\t\t * us or should be passed back to\n\t\t\t\t * the sequencer.\n\t\t\t\t */\n\t\t\t\tahc_outb(ahc, CLRSINT1, CLRATNO);\n\t\t\t\tahc->send_msg_perror = FALSE;\n\t\t\t\tahc->msg_type = MSG_TYPE_INITIATOR_MSGIN;\n\t\t\t\tahc->msgin_index = 0;\n\t\t\t\tgoto reswitch;\n\t\t\t}\n\t\t\tend_session = TRUE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ahc->send_msg_perror) {\n\t\t\tahc_outb(ahc, CLRSINT1, CLRATNO);\n\t\t\tahc_outb(ahc, CLRSINT1, CLRREQINIT);\n\t\t\tahc_outb(ahc, SCSIDATL, MSG_PARITY_ERROR);\n\t\t\tbreak;\n\t\t}\n\n\t\tmsgdone\t= ahc->msgout_index == ahc->msgout_len;\n\t\tif (msgdone) {\n\t\t\t/*\n\t\t\t * The target has requested a retry.\n\t\t\t * Re-assert ATN, reset our message index to\n\t\t\t * 0, and try again.\n\t\t\t */\n\t\t\tahc->msgout_index = 0;\n\t\t\tahc_outb(ahc, SCSISIGO, ahc_inb(ahc, SCSISIGO) | ATNO);\n\t\t}\n\n\t\tlastbyte = ahc->msgout_index == (ahc->msgout_len - 1);\n\t\tif (lastbyte) {\n\t\t\t/* Last byte is signified by dropping ATN */\n\t\t\tahc_outb(ahc, CLRSINT1, CLRATNO);\n\t\t}\n\n\t\t/*\n\t\t * Clear our interrupt status and present\n\t\t * the next byte on the bus.\n\t\t */\n\t\tahc_outb(ahc, CLRSINT1, CLRREQINIT);\n\t\tahc_outb(ahc, SCSIDATL, ahc->msgout_buf[ahc->msgout_index++]);\n\t\tbreak;\n\t}\n\tcase MSG_TYPE_INITIATOR_MSGIN:\n\t{\n\t\tint phasemis;\n\t\tint message_done;\n\n\t\tphasemis = bus_phase != P_MESGIN;\n\n\t\tif (phasemis) {\n\t\t\tahc->msgin_index = 0;\n\t\t\tif (bus_phase == P_MESGOUT\n\t\t\t && (ahc->send_msg_perror == TRUE\n\t\t\t  || (ahc->msgout_len != 0\n\t\t\t   && ahc->msgout_index == 0))) {\n\t\t\t\tahc->msg_type = MSG_TYPE_INITIATOR_MSGOUT;\n\t\t\t\tgoto reswitch;\n\t\t\t}\n\t\t\tend_session = TRUE;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Pull the byte in without acking it */\n\t\tahc->msgin_buf[ahc->msgin_index] = ahc_inb(ahc, SCSIBUSL);\n\n\t\tmessage_done = ahc_parse_msg(ahc, sc_link, &devinfo);\n\n\t\tif (message_done) {\n\t\t\t/*\n\t\t\t * Clear our incoming message buffer in case there\n\t\t\t * is another message following this one.\n\t\t\t */\n\t\t\tahc->msgin_index = 0;\n\n\t\t\t/*\n\t\t\t * If this message illicited a response,\n\t\t\t * assert ATN so the target takes us to the\n\t\t\t * message out phase.\n\t\t\t */\n\t\t\tif (ahc->msgout_len != 0)\n\t\t\t\tahc_outb(ahc, SCSISIGO,\n\t\t\t\t\t ahc_inb(ahc, SCSISIGO) | ATNO);\n\t\t} else \n\t\t\tahc->msgin_index++;\n\n\t\t/* Ack the byte */\n\t\tahc_outb(ahc, CLRSINT1, CLRREQINIT);\n\t\tahc_inb(ahc, SCSIDATL);\n\t\tbreak;\n\t}\n\tcase MSG_TYPE_TARGET_MSGIN:\n\t{\n\t\tint msgdone;\n\t\tint msgout_request;\n\n\t\tif (ahc->msgout_len == 0)\n\t\t\tpanic(\"Target MSGIN with no active message\");\n\n\t\t/*\n\t\t * If we interrupted a mesgout session, the initiator\n\t\t * will not know this until our first REQ.  So, we\n\t\t * only honor mesgout requests after we've sent our\n\t\t * first byte.\n\t\t */\n\t\tif ((ahc_inb(ahc, SCSISIGI) & ATNI) != 0\n\t\t && ahc->msgout_index > 0)\n\t\t\tmsgout_request = TRUE;\n\t\telse\n\t\t\tmsgout_request = FALSE;\n\n\t\tif (msgout_request) {\n\n\t\t\t/*\n\t\t\t * Change gears and see if\n\t\t\t * this messages is of interest to\n\t\t\t * us or should be passed back to\n\t\t\t * the sequencer.\n\t\t\t */\n\t\t\tahc->msg_type = MSG_TYPE_TARGET_MSGOUT;\n\t\t\tahc_outb(ahc, SCSISIGO, P_MESGOUT | BSYO);\n\t\t\tahc->msgin_index = 0;\n\t\t\t/* Dummy read to REQ for first byte */\n\t\t\tahc_inb(ahc, SCSIDATL);\n\t\t\tahc_outb(ahc, SXFRCTL0,\n\t\t\t\t ahc_inb(ahc, SXFRCTL0) | SPIOEN);\n\t\t\tbreak;\n\t\t}\n\n\t\tmsgdone = ahc->msgout_index == ahc->msgout_len;\n\t\tif (msgdone) {\n\t\t\tahc_outb(ahc, SXFRCTL0,\n\t\t\t\t ahc_inb(ahc, SXFRCTL0) & ~SPIOEN);\n\t\t\tend_session = TRUE;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Present the next byte on the bus.\n\t\t */\n\t\tahc_outb(ahc, SXFRCTL0, ahc_inb(ahc, SXFRCTL0) | SPIOEN);\n\t\tahc_outb(ahc, SCSIDATL, ahc->msgout_buf[ahc->msgout_index++]);\n\t\tbreak;\n\t}\n\tcase MSG_TYPE_TARGET_MSGOUT:\n\t{\n\t\tint lastbyte;\n\t\tint msgdone;\n\n\t\t/*\n\t\t * The initiator signals that this is\n\t\t * the last byte by dropping ATN.\n\t\t */\n\t\tlastbyte = (ahc_inb(ahc, SCSISIGI) & ATNI) == 0;\n\n\t\t/*\n\t\t * Read the latched byte, but turn off SPIOEN first\n\t\t * so that we don't inadvertantly cause a REQ for the\n\t\t * next byte.\n\t\t */\n\t\tahc_outb(ahc, SXFRCTL0, ahc_inb(ahc, SXFRCTL0) & ~SPIOEN);\n\t\tahc->msgin_buf[ahc->msgin_index] = ahc_inb(ahc, SCSIDATL);\n\t\tmsgdone = ahc_parse_msg(ahc, sc_link, &devinfo);\n\t\tif (msgdone == MSGLOOP_TERMINATED) {\n\t\t\t/*\n\t\t\t * The message is *really* done in that it caused\n\t\t\t * us to go to bus free.  The sequencer has already\n\t\t\t * been reset at this point, so pull the ejection\n\t\t\t * handle.\n\t\t\t */\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tahc->msgin_index++;\n\n\t\t/*\n\t\t * XXX Read spec about initiator dropping ATN too soon\n\t\t *     and use msgdone to detect it.\n\t\t */\n\t\tif (msgdone == MSGLOOP_MSGCOMPLETE) {\n\t\t\tahc->msgin_index = 0;\n\n\t\t\t/*\n\t\t\t * If this message illicited a response, transition\n\t\t\t * to the Message in phase and send it.\n\t\t\t */\n\t\t\tif (ahc->msgout_len != 0) {\n\t\t\t\tahc_outb(ahc, SCSISIGO, P_MESGIN | BSYO);\n\t\t\t\tahc_outb(ahc, SXFRCTL0,\n\t\t\t\t\t ahc_inb(ahc, SXFRCTL0) | SPIOEN);\n\t\t\t\tahc->msg_type = MSG_TYPE_TARGET_MSGIN;\n\t\t\t\tahc->msgin_index = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (lastbyte)\n\t\t\tend_session = TRUE;\n\t\telse {\n\t\t\t/* Ask for the next byte. */\n\t\t\tahc_outb(ahc, SXFRCTL0,\n\t\t\t\t ahc_inb(ahc, SXFRCTL0) | SPIOEN);\n\t\t}\n\n\t\tbreak;\n\t}\n\tdefault:\n\t\tpanic(\"Unknown REQINIT message type\");\n\t}\n\n\tif (end_session) {\n\t\tahc_clear_msg_state(ahc);\n\t\tahc_outb(ahc, RETURN_1, EXIT_MSG_LOOP);\n\t} else\n\t\tahc_outb(ahc, RETURN_1, CONT_MSG_LOOP);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "ahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC int",
            "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));",
            "STATIC int",
            "STATIC int",
            "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "ahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));",
            "STATIC void",
            "ahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));\nSTATIC int;\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));\nSTATIC void;\nahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_handle_message_phase(ahc, sc_link)\n\tstruct ahc_softc *ahc;\n\tstruct scsi_link *sc_link;\n{ \n\tstruct\tahc_devinfo devinfo;\n\tu_int\tbus_phase;\n\tint\tend_session;\n\n\tahc_fetch_devinfo(ahc, &devinfo);\n\tend_session = FALSE;\n\tbus_phase = ahc_inb(ahc, SCSISIGI) & PHASE_MASK;\n\nreswitch:\n\tswitch (ahc->msg_type) {\n\tcase MSG_TYPE_INITIATOR_MSGOUT:\n\t{\n\t\tint lastbyte;\n\t\tint phasemis;\n\t\tint msgdone;\n\n\t\tif (ahc->msgout_len == 0)\n\t\t\tpanic(\"REQINIT interrupt with no active message\");\n\n\t\tphasemis = bus_phase != P_MESGOUT;\n\t\tif (phasemis) {\n\t\t\tif (bus_phase == P_MESGIN) {\n\t\t\t\t/*\n\t\t\t\t * Change gears and see if\n\t\t\t\t * this messages is of interest to\n\t\t\t\t * us or should be passed back to\n\t\t\t\t * the sequencer.\n\t\t\t\t */\n\t\t\t\tahc_outb(ahc, CLRSINT1, CLRATNO);\n\t\t\t\tahc->send_msg_perror = FALSE;\n\t\t\t\tahc->msg_type = MSG_TYPE_INITIATOR_MSGIN;\n\t\t\t\tahc->msgin_index = 0;\n\t\t\t\tgoto reswitch;\n\t\t\t}\n\t\t\tend_session = TRUE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ahc->send_msg_perror) {\n\t\t\tahc_outb(ahc, CLRSINT1, CLRATNO);\n\t\t\tahc_outb(ahc, CLRSINT1, CLRREQINIT);\n\t\t\tahc_outb(ahc, SCSIDATL, MSG_PARITY_ERROR);\n\t\t\tbreak;\n\t\t}\n\n\t\tmsgdone\t= ahc->msgout_index == ahc->msgout_len;\n\t\tif (msgdone) {\n\t\t\t/*\n\t\t\t * The target has requested a retry.\n\t\t\t * Re-assert ATN, reset our message index to\n\t\t\t * 0, and try again.\n\t\t\t */\n\t\t\tahc->msgout_index = 0;\n\t\t\tahc_outb(ahc, SCSISIGO, ahc_inb(ahc, SCSISIGO) | ATNO);\n\t\t}\n\n\t\tlastbyte = ahc->msgout_index == (ahc->msgout_len - 1);\n\t\tif (lastbyte) {\n\t\t\t/* Last byte is signified by dropping ATN */\n\t\t\tahc_outb(ahc, CLRSINT1, CLRATNO);\n\t\t}\n\n\t\t/*\n\t\t * Clear our interrupt status and present\n\t\t * the next byte on the bus.\n\t\t */\n\t\tahc_outb(ahc, CLRSINT1, CLRREQINIT);\n\t\tahc_outb(ahc, SCSIDATL, ahc->msgout_buf[ahc->msgout_index++]);\n\t\tbreak;\n\t}\n\tcase MSG_TYPE_INITIATOR_MSGIN:\n\t{\n\t\tint phasemis;\n\t\tint message_done;\n\n\t\tphasemis = bus_phase != P_MESGIN;\n\n\t\tif (phasemis) {\n\t\t\tahc->msgin_index = 0;\n\t\t\tif (bus_phase == P_MESGOUT\n\t\t\t && (ahc->send_msg_perror == TRUE\n\t\t\t  || (ahc->msgout_len != 0\n\t\t\t   && ahc->msgout_index == 0))) {\n\t\t\t\tahc->msg_type = MSG_TYPE_INITIATOR_MSGOUT;\n\t\t\t\tgoto reswitch;\n\t\t\t}\n\t\t\tend_session = TRUE;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Pull the byte in without acking it */\n\t\tahc->msgin_buf[ahc->msgin_index] = ahc_inb(ahc, SCSIBUSL);\n\n\t\tmessage_done = ahc_parse_msg(ahc, sc_link, &devinfo);\n\n\t\tif (message_done) {\n\t\t\t/*\n\t\t\t * Clear our incoming message buffer in case there\n\t\t\t * is another message following this one.\n\t\t\t */\n\t\t\tahc->msgin_index = 0;\n\n\t\t\t/*\n\t\t\t * If this message illicited a response,\n\t\t\t * assert ATN so the target takes us to the\n\t\t\t * message out phase.\n\t\t\t */\n\t\t\tif (ahc->msgout_len != 0)\n\t\t\t\tahc_outb(ahc, SCSISIGO,\n\t\t\t\t\t ahc_inb(ahc, SCSISIGO) | ATNO);\n\t\t} else \n\t\t\tahc->msgin_index++;\n\n\t\t/* Ack the byte */\n\t\tahc_outb(ahc, CLRSINT1, CLRREQINIT);\n\t\tahc_inb(ahc, SCSIDATL);\n\t\tbreak;\n\t}\n\tcase MSG_TYPE_TARGET_MSGIN:\n\t{\n\t\tint msgdone;\n\t\tint msgout_request;\n\n\t\tif (ahc->msgout_len == 0)\n\t\t\tpanic(\"Target MSGIN with no active message\");\n\n\t\t/*\n\t\t * If we interrupted a mesgout session, the initiator\n\t\t * will not know this until our first REQ.  So, we\n\t\t * only honor mesgout requests after we've sent our\n\t\t * first byte.\n\t\t */\n\t\tif ((ahc_inb(ahc, SCSISIGI) & ATNI) != 0\n\t\t && ahc->msgout_index > 0)\n\t\t\tmsgout_request = TRUE;\n\t\telse\n\t\t\tmsgout_request = FALSE;\n\n\t\tif (msgout_request) {\n\n\t\t\t/*\n\t\t\t * Change gears and see if\n\t\t\t * this messages is of interest to\n\t\t\t * us or should be passed back to\n\t\t\t * the sequencer.\n\t\t\t */\n\t\t\tahc->msg_type = MSG_TYPE_TARGET_MSGOUT;\n\t\t\tahc_outb(ahc, SCSISIGO, P_MESGOUT | BSYO);\n\t\t\tahc->msgin_index = 0;\n\t\t\t/* Dummy read to REQ for first byte */\n\t\t\tahc_inb(ahc, SCSIDATL);\n\t\t\tahc_outb(ahc, SXFRCTL0,\n\t\t\t\t ahc_inb(ahc, SXFRCTL0) | SPIOEN);\n\t\t\tbreak;\n\t\t}\n\n\t\tmsgdone = ahc->msgout_index == ahc->msgout_len;\n\t\tif (msgdone) {\n\t\t\tahc_outb(ahc, SXFRCTL0,\n\t\t\t\t ahc_inb(ahc, SXFRCTL0) & ~SPIOEN);\n\t\t\tend_session = TRUE;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Present the next byte on the bus.\n\t\t */\n\t\tahc_outb(ahc, SXFRCTL0, ahc_inb(ahc, SXFRCTL0) | SPIOEN);\n\t\tahc_outb(ahc, SCSIDATL, ahc->msgout_buf[ahc->msgout_index++]);\n\t\tbreak;\n\t}\n\tcase MSG_TYPE_TARGET_MSGOUT:\n\t{\n\t\tint lastbyte;\n\t\tint msgdone;\n\n\t\t/*\n\t\t * The initiator signals that this is\n\t\t * the last byte by dropping ATN.\n\t\t */\n\t\tlastbyte = (ahc_inb(ahc, SCSISIGI) & ATNI) == 0;\n\n\t\t/*\n\t\t * Read the latched byte, but turn off SPIOEN first\n\t\t * so that we don't inadvertantly cause a REQ for the\n\t\t * next byte.\n\t\t */\n\t\tahc_outb(ahc, SXFRCTL0, ahc_inb(ahc, SXFRCTL0) & ~SPIOEN);\n\t\tahc->msgin_buf[ahc->msgin_index] = ahc_inb(ahc, SCSIDATL);\n\t\tmsgdone = ahc_parse_msg(ahc, sc_link, &devinfo);\n\t\tif (msgdone == MSGLOOP_TERMINATED) {\n\t\t\t/*\n\t\t\t * The message is *really* done in that it caused\n\t\t\t * us to go to bus free.  The sequencer has already\n\t\t\t * been reset at this point, so pull the ejection\n\t\t\t * handle.\n\t\t\t */\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tahc->msgin_index++;\n\n\t\t/*\n\t\t * XXX Read spec about initiator dropping ATN too soon\n\t\t *     and use msgdone to detect it.\n\t\t */\n\t\tif (msgdone == MSGLOOP_MSGCOMPLETE) {\n\t\t\tahc->msgin_index = 0;\n\n\t\t\t/*\n\t\t\t * If this message illicited a response, transition\n\t\t\t * to the Message in phase and send it.\n\t\t\t */\n\t\t\tif (ahc->msgout_len != 0) {\n\t\t\t\tahc_outb(ahc, SCSISIGO, P_MESGIN | BSYO);\n\t\t\t\tahc_outb(ahc, SXFRCTL0,\n\t\t\t\t\t ahc_inb(ahc, SXFRCTL0) | SPIOEN);\n\t\t\t\tahc->msg_type = MSG_TYPE_TARGET_MSGIN;\n\t\t\t\tahc->msgin_index = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (lastbyte)\n\t\t\tend_session = TRUE;\n\t\telse {\n\t\t\t/* Ask for the next byte. */\n\t\t\tahc_outb(ahc, SXFRCTL0,\n\t\t\t\t ahc_inb(ahc, SXFRCTL0) | SPIOEN);\n\t\t}\n\n\t\tbreak;\n\t}\n\tdefault:\n\t\tpanic(\"Unknown REQINIT message type\");\n\t}\n\n\tif (end_session) {\n\t\tahc_clear_msg_state(ahc);\n\t\tahc_outb(ahc, RETURN_1, EXIT_MSG_LOOP);\n\t} else\n\t\tahc_outb(ahc, RETURN_1, CONT_MSG_LOOP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_setup_target_msgin",
          "args": [
            "ahc",
            "&devinfo"
          ],
          "line": 2033
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_setup_target_msgin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "2551-2571",
          "snippet": "STATIC void\nahc_setup_target_msgin(ahc, devinfo)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n{\n\t/*              \n\t * To facilitate adding multiple messages together,\n\t * each routine should increment the index and len\n\t * variables instead of setting them explicitly.\n\t */             \n\tahc->msgout_index = 0;\n\tahc->msgout_len = 0;\n\n\tif ((ahc->targ_msg_req & devinfo->target_mask) != 0)\n\t\tahc_build_transfer_msg(ahc, devinfo);\n\telse\n\t\tpanic(\"ahc_intr: AWAITING target message with no message\");\n\n\tahc->msgout_index = 0;\n\tahc->msg_type = MSG_TYPE_TARGET_MSGIN;\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC int",
            "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_setup_target_msgin(ahc, devinfo)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n{\n\t/*              \n\t * To facilitate adding multiple messages together,\n\t * each routine should increment the index and len\n\t * variables instead of setting them explicitly.\n\t */             \n\tahc->msgout_index = 0;\n\tahc->msgout_len = 0;\n\n\tif ((ahc->targ_msg_req & devinfo->target_mask) != 0)\n\t\tahc_build_transfer_msg(ahc, devinfo);\n\telse\n\t\tpanic(\"ahc_intr: AWAITING target message with no message\");\n\n\tahc->msgout_index = 0;\n\tahc->msg_type = MSG_TYPE_TARGET_MSGIN;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_setup_initiator_msgout",
          "args": [
            "ahc",
            "&devinfo",
            "scb"
          ],
          "line": 2018
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_setup_initiator_msgout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "2486-2549",
          "snippet": "STATIC void\nahc_setup_initiator_msgout(ahc, devinfo, scb)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n\tstruct scb *scb;\n{\n\t/*              \n\t * To facilitate adding multiple messages together,\n\t * each routine should increment the index and len\n\t * variables instead of setting them explicitly.\n\t */             \n\tahc->msgout_index = 0;\n\tahc->msgout_len = 0;\n\n\tif ((scb->flags & SCB_DEVICE_RESET) == 0\n\t && ahc_inb(ahc, MSG_OUT) == MSG_IDENTIFYFLAG) {\n\t\tu_int identify_msg;\n\n\t\tidentify_msg = MSG_IDENTIFYFLAG | SCB_LUN(scb);\n\t\tif ((scb->hscb->control & DISCENB) != 0)\n\t\t\tidentify_msg |= MSG_IDENTIFY_DISCFLAG;\n\t\tahc->msgout_buf[ahc->msgout_index++] = identify_msg;\n\t\tahc->msgout_len++;\n\n\t\tif ((scb->hscb->control & TAG_ENB) != 0) {\n\t\t\t/* XXX fvdl FreeBSD has tag action passed down */\n\t\t\tahc->msgout_buf[ahc->msgout_index++] = MSG_SIMPLE_Q_TAG;\n\t\t\tahc->msgout_buf[ahc->msgout_index++] = scb->hscb->tag;\n\t\t\tahc->msgout_len += 2;\n\t\t}\n\t}\n\n\tif (scb->flags & SCB_DEVICE_RESET) {\n\t\tahc->msgout_buf[ahc->msgout_index++] = MSG_BUS_DEV_RESET;\n\t\tahc->msgout_len++;\n\t\t\n\t\tsc_print_addr(scb->xs->sc_link);\n\t\tprintf(\"Bus Device Reset Message Sent\\n\");\n\t} else if (scb->flags & SCB_ABORT) {\n\t\tif ((scb->hscb->control & TAG_ENB) != 0)\n\t\t\tahc->msgout_buf[ahc->msgout_index++] = MSG_ABORT_TAG;\n\t\telse\n\t\t\tahc->msgout_buf[ahc->msgout_index++] = MSG_ABORT;\n\t\tahc->msgout_len++;\n\t\tsc_print_addr(scb->xs->sc_link);\n\t\tprintf(\"Abort Message Sent\\n\");\n\t} else if ((ahc->targ_msg_req & devinfo->target_mask) != 0) {\n\t\tahc_build_transfer_msg(ahc, devinfo);\n\t} else {\n\t\tprintf(\"ahc_intr: AWAITING_MSG for an SCB that \"\n\t\t       \"does not have a waiting message\");\n\t\tpanic(\"SCB = %d, SCB Control = %x, MSG_OUT = %x \"\n\t\t      \"SCB flags = %x\", scb->hscb->tag, scb->hscb->control,\n\t\t      ahc_inb(ahc, MSG_OUT), scb->flags);\n\t}\n\n\t/*\n\t * Clear the MK_MESSAGE flag from the SCB so we aren't\n\t * asked to send this message again.\n\t */\n\tahc_outb(ahc, SCB_CONTROL, ahc_inb(ahc, SCB_CONTROL) & ~MK_MESSAGE);\n\tahc->msgout_index = 0;\n\tahc->msg_type = MSG_TYPE_INITIATOR_MSGOUT;\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
            "STATIC void",
            "ahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
            "STATIC void",
            "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC int",
            "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));",
            "STATIC int",
            "STATIC int",
            "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_search_qinfifo __P((struct ahc_softc *ahc, int target,\n\t\t\t\t\tchar channel, int lun, u_int tag,\n\t\t\t\t\trole_t role, u_int32_t status,\n\t\t\t\t\tahc_search_action action));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
            "STATIC void",
            "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_calc_residual __P((struct scb *scb));",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *xs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nSTATIC void;\nahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));\nSTATIC int;\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_search_qinfifo __P((struct ahc_softc *ahc, int target,\n\t\t\t\t\tchar channel, int lun, u_int tag,\n\t\t\t\t\trole_t role, u_int32_t status,\n\t\t\t\t\tahc_search_action action));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nSTATIC void;\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_calc_residual __P((struct scb *scb));\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n\nSTATIC void\nahc_setup_initiator_msgout(ahc, devinfo, scb)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n\tstruct scb *scb;\n{\n\t/*              \n\t * To facilitate adding multiple messages together,\n\t * each routine should increment the index and len\n\t * variables instead of setting them explicitly.\n\t */             \n\tahc->msgout_index = 0;\n\tahc->msgout_len = 0;\n\n\tif ((scb->flags & SCB_DEVICE_RESET) == 0\n\t && ahc_inb(ahc, MSG_OUT) == MSG_IDENTIFYFLAG) {\n\t\tu_int identify_msg;\n\n\t\tidentify_msg = MSG_IDENTIFYFLAG | SCB_LUN(scb);\n\t\tif ((scb->hscb->control & DISCENB) != 0)\n\t\t\tidentify_msg |= MSG_IDENTIFY_DISCFLAG;\n\t\tahc->msgout_buf[ahc->msgout_index++] = identify_msg;\n\t\tahc->msgout_len++;\n\n\t\tif ((scb->hscb->control & TAG_ENB) != 0) {\n\t\t\t/* XXX fvdl FreeBSD has tag action passed down */\n\t\t\tahc->msgout_buf[ahc->msgout_index++] = MSG_SIMPLE_Q_TAG;\n\t\t\tahc->msgout_buf[ahc->msgout_index++] = scb->hscb->tag;\n\t\t\tahc->msgout_len += 2;\n\t\t}\n\t}\n\n\tif (scb->flags & SCB_DEVICE_RESET) {\n\t\tahc->msgout_buf[ahc->msgout_index++] = MSG_BUS_DEV_RESET;\n\t\tahc->msgout_len++;\n\t\t\n\t\tsc_print_addr(scb->xs->sc_link);\n\t\tprintf(\"Bus Device Reset Message Sent\\n\");\n\t} else if (scb->flags & SCB_ABORT) {\n\t\tif ((scb->hscb->control & TAG_ENB) != 0)\n\t\t\tahc->msgout_buf[ahc->msgout_index++] = MSG_ABORT_TAG;\n\t\telse\n\t\t\tahc->msgout_buf[ahc->msgout_index++] = MSG_ABORT;\n\t\tahc->msgout_len++;\n\t\tsc_print_addr(scb->xs->sc_link);\n\t\tprintf(\"Abort Message Sent\\n\");\n\t} else if ((ahc->targ_msg_req & devinfo->target_mask) != 0) {\n\t\tahc_build_transfer_msg(ahc, devinfo);\n\t} else {\n\t\tprintf(\"ahc_intr: AWAITING_MSG for an SCB that \"\n\t\t       \"does not have a waiting message\");\n\t\tpanic(\"SCB = %d, SCB Control = %x, MSG_OUT = %x \"\n\t\t      \"SCB flags = %x\", scb->hscb->tag, scb->hscb->control,\n\t\t      ahc_inb(ahc, MSG_OUT), scb->flags);\n\t}\n\n\t/*\n\t * Clear the MK_MESSAGE flag from the SCB so we aren't\n\t * asked to send this message again.\n\t */\n\tahc_outb(ahc, SCB_CONTROL, ahc_inb(ahc, SCB_CONTROL) & ~MK_MESSAGE);\n\tahc->msgout_index = 0;\n\tahc->msg_type = MSG_TYPE_INITIATOR_MSGOUT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCB_TAG"
          ],
          "line": 2014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "restart_sequencer",
          "args": [
            "ahc"
          ],
          "line": 2007
        },
        "resolved": true,
        "details": {
          "function_name": "restart_sequencer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "467-495",
          "snippet": "STATIC void\nrestart_sequencer(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tu_int i;\n\n\tpause_sequencer(ahc);\n\n\t/*\n\t * Everytime we restart the sequencer, there\n\t * is the possiblitity that we have restarted\n\t * within a three instruction window where an\n\t * SCB has been marked free but has not made it\n\t * onto the free list.  Since SCSI events(bus reset,\n\t * unexpected bus free) will always freeze the\n\t * sequencer, we cannot close this window.  To\n\t * avoid losing an SCB, we reconsitute the free\n\t * list every time we restart the sequencer.\n\t */\n\tahc_outb(ahc, FREE_SCBH, SCB_LIST_NULL);\n\tfor (i = 0; i < ahc->scb_data->maxhscbs; i++) {\n\t\t\n\t\tahc_outb(ahc, SCBPTR, i);\n\t\tif (ahc_inb(ahc, SCB_TAG) == SCB_LIST_NULL)\n\t\t\tahc_add_curscb_to_free_list(ahc);\n\t}\n\tahc_outb(ahc, SEQCTL, FASTMODE|SEQRESET);\n\tunpause_sequencer(ahc);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "static __inline void pause_sequencer",
            "static __inline void unpause_sequencer",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nstatic __inline void pause_sequencer;\nstatic __inline void unpause_sequencer;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nrestart_sequencer(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tu_int i;\n\n\tpause_sequencer(ahc);\n\n\t/*\n\t * Everytime we restart the sequencer, there\n\t * is the possiblitity that we have restarted\n\t * within a three instruction window where an\n\t * SCB has been marked free but has not made it\n\t * onto the free list.  Since SCSI events(bus reset,\n\t * unexpected bus free) will always freeze the\n\t * sequencer, we cannot close this window.  To\n\t * avoid losing an SCB, we reconsitute the free\n\t * list every time we restart the sequencer.\n\t */\n\tahc_outb(ahc, FREE_SCBH, SCB_LIST_NULL);\n\tfor (i = 0; i < ahc->scb_data->maxhscbs; i++) {\n\t\t\n\t\tahc_outb(ahc, SCBPTR, i);\n\t\tif (ahc_inb(ahc, SCB_TAG) == SCB_LIST_NULL)\n\t\t\tahc_add_curscb_to_free_list(ahc);\n\t}\n\tahc_outb(ahc, SEQCTL, FASTMODE|SEQRESET);\n\tunpause_sequencer(ahc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_clear_intstat",
          "args": [
            "ahc"
          ],
          "line": 2006
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_clear_intstat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "5381-5391",
          "snippet": "STATIC void\nahc_clear_intstat(ahc)\n\tstruct ahc_softc *ahc;\n{\n\t/* Clear any interrupt conditions this may have caused */\n\tahc_outb(ahc, CLRSINT0, CLRSELDO|CLRSELDI|CLRSELINGO);\n\tahc_outb(ahc, CLRSINT1, CLRSELTIMEO|CLRATNO|CLRSCSIRSTI\n\t\t\t\t|CLRBUSFREE|CLRSCSIPERR|CLRPHASECHG|\n\t\t\t\tCLRREQINIT);\n\tahc_outb(ahc, CLRINT, CLRSCSIINT);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_clear_intstat(ahc)\n\tstruct ahc_softc *ahc;\n{\n\t/* Clear any interrupt conditions this may have caused */\n\tahc_outb(ahc, CLRSINT0, CLRSELDO|CLRSELDI|CLRSELINGO);\n\tahc_outb(ahc, CLRSINT1, CLRSELTIMEO|CLRATNO|CLRSCSIRSTI\n\t\t\t\t|CLRBUSFREE|CLRSCSIPERR|CLRPHASECHG|\n\t\t\t\tCLRREQINIT);\n\tahc_outb(ahc, CLRINT, CLRSCSIINT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCSISIGI"
          ],
          "line": 1996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCB_DATACNT"
          ],
          "line": 1978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SSTAT0"
          ],
          "line": 1977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "DFSTATUS"
          ],
          "line": 1975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SSTAT3"
          ],
          "line": 1974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "DFCNTRL"
          ],
          "line": 1973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SSTAT2"
          ],
          "line": 1972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "ahc_timeout",
            "(caddr_t)scb",
            "5 * hz"
          ],
          "line": 1954
        },
        "resolved": true,
        "details": {
          "function_name": "wdctimeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "952-980",
          "snippet": "void\nwdctimeout(arg)\n\tvoid *arg;\n{\n\tstruct channel_softc *chp = (struct channel_softc *)arg;\n\tstruct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;\n\tint s;\n\n\tWDCDEBUG_PRINT((\"wdctimeout\\n\"), DEBUG_FUNCS);\n\n\ts = splbio();\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) != 0) {\n\t\t__wdcerror(chp, \"timeout\");\n\t\tprintf(\"\\ttype: %s\\n\", (xfer->c_flags & C_ATAPI) ?\n\t\t    \"atapi\":\"ata\");\n\t\tprintf(\"\\tc_bcount: %d\\n\", xfer->c_bcount);\n\t\tprintf(\"\\tc_skip: %d\\n\", xfer->c_skip);\n\t\t/*\n\t\t * Call the interrupt routine. If we just missed and interrupt,\n\t\t * it will do what's needed. Else, it will take the needed\n\t\t * action (reset the device).\n\t\t */\n\t\txfer->c_flags |= C_TIMEOU;\n\t\tchp->ch_flags &= ~WDCF_IRQ_WAIT;\n\t\txfer->c_intr(chp, xfer, 1);\n\t} else\n\t\t__wdcerror(chp, \"missing untimeout\");\n\tsplx(s);\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_FUNCS  0x08"
          ],
          "globals_used": [
            "static void  __wdcerror"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_FUNCS  0x08\n\nstatic void  __wdcerror;\n\nvoid\nwdctimeout(arg)\n\tvoid *arg;\n{\n\tstruct channel_softc *chp = (struct channel_softc *)arg;\n\tstruct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;\n\tint s;\n\n\tWDCDEBUG_PRINT((\"wdctimeout\\n\"), DEBUG_FUNCS);\n\n\ts = splbio();\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) != 0) {\n\t\t__wdcerror(chp, \"timeout\");\n\t\tprintf(\"\\ttype: %s\\n\", (xfer->c_flags & C_ATAPI) ?\n\t\t    \"atapi\":\"ata\");\n\t\tprintf(\"\\tc_bcount: %d\\n\", xfer->c_bcount);\n\t\tprintf(\"\\tc_skip: %d\\n\", xfer->c_skip);\n\t\t/*\n\t\t * Call the interrupt routine. If we just missed and interrupt,\n\t\t * it will do what's needed. Else, it will take the needed\n\t\t * action (reset the device).\n\t\t */\n\t\txfer->c_flags |= C_TIMEOU;\n\t\tchp->ch_flags &= ~WDCF_IRQ_WAIT;\n\t\txfer->c_intr(chp, xfer, 1);\n\t} else\n\t\t__wdcerror(chp, \"missing untimeout\");\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "untimeout",
          "args": [
            "ahc_timeout",
            "(caddr_t)scb"
          ],
          "line": 1953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "RETURN_1",
            "SEND_SENSE"
          ],
          "line": 1946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_busy_tcl",
          "args": [
            "ahc",
            "scb"
          ],
          "line": 1945
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_busy_tcl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "515-523",
          "snippet": "static __inline void\nahc_busy_tcl(ahc, scb)\n\tstruct ahc_softc *ahc;\n\tstruct scb *scb;\n{\n\tahc->untagged_scbs[scb->hscb->tcl] = scb->hscb->tag;\n\tbus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, \n\t\t\tBUS_DMASYNC_PREWRITE);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "ahc_calc_residual __P((struct scb *scb));",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "static __inline void\tahc_busy_tcl",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC struct;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nahc_loadseq __P((struct ahc_softc *ahc));\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nahc_clear_intstat __P((struct ahc_softc *ahc));\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nahc_calc_residual __P((struct scb *scb));\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nrestart_sequencer __P((struct ahc_softc *ahc));\nstatic __inline void\tahc_busy_tcl;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nstatic __inline void\nahc_busy_tcl(ahc, scb)\n\tstruct ahc_softc *ahc;\n\tstruct scb *scb;\n{\n\tahc->untagged_scbs[scb->hscb->tcl] = scb->hscb->tag;\n\tbus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, \n\t\t\tBUS_DMASYNC_PREWRITE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_update_target_msg_request",
          "args": [
            "ahc",
            "&devinfo",
            "tinfo",
            "/*force*/TRUE",
            "/*paused*/TRUE"
          ],
          "line": 1926
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_update_target_msg_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "1250-1295",
          "snippet": "STATIC void\nahc_update_target_msg_request(ahc, devinfo, tinfo, force, paused)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n\tstruct ahc_initiator_tinfo *tinfo;\n\tint force;\n\tint paused;\n{\n\tu_int targ_msg_req_orig;\n\n\ttarg_msg_req_orig = ahc->targ_msg_req;\n\tif (tinfo->current.period != tinfo->goal.period\n\t    || tinfo->current.width != tinfo->goal.width\n\t    || tinfo->current.offset != tinfo->goal.offset\n\t    || (force && (tinfo->goal.period != 0\n\t    || tinfo->goal.width != MSG_EXT_WDTR_BUS_8_BIT)))\n\t\tahc->targ_msg_req |= devinfo->target_mask;\n\telse\n\t\tahc->targ_msg_req &= ~devinfo->target_mask;\n\n\tif (ahc->targ_msg_req != targ_msg_req_orig) {\n\t\t/* Update the message request bit for this target */\n\t\tif ((ahc->features & AHC_HS_MAILBOX) != 0) {\n\t\t\tif (paused) {\n\t\t\t\tahc_outb(ahc, TARGET_MSG_REQUEST,\n\t\t\t\t\t ahc->targ_msg_req & 0xFF);\n\t\t\t\tahc_outb(ahc, TARGET_MSG_REQUEST + 1,\n\t\t\t\t\t (ahc->targ_msg_req >> 8) & 0xFF);\n\t\t\t} else {\n\t\t\t\tahc_outb(ahc, HS_MAILBOX,\n\t\t\t\t\t 0x01 << HOST_MAILBOX_SHIFT);\n\t\t\t}\n\t\t} else {\n\t\t\tif (!paused)\n\t\t\t\tpause_sequencer(ahc);\n\n\t\t\tahc_outb(ahc, TARGET_MSG_REQUEST,\n\t\t\t\t ahc->targ_msg_req & 0xFF);\n\t\t\tahc_outb(ahc, TARGET_MSG_REQUEST + 1,\n\t\t\t\t (ahc->targ_msg_req >> 8) & 0xFF);\n\n\t\t\tif (!paused)\n\t\t\t\tunpause_sequencer(ahc);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC int",
            "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "ahc_update_target_msg_request __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t\t      struct ahc_initiator_tinfo *tinfo,\n\t\t\t\t\t      int force, int paused));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "static __inline void pause_sequencer",
            "static __inline void unpause_sequencer",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "u_int *period;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "u_int *period;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nahc_update_target_msg_request __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t\t      struct ahc_initiator_tinfo *tinfo,\n\t\t\t\t\t      int force, int paused));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nstatic __inline void pause_sequencer;\nstatic __inline void unpause_sequencer;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_update_target_msg_request(ahc, devinfo, tinfo, force, paused)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n\tstruct ahc_initiator_tinfo *tinfo;\n\tint force;\n\tint paused;\n{\n\tu_int targ_msg_req_orig;\n\n\ttarg_msg_req_orig = ahc->targ_msg_req;\n\tif (tinfo->current.period != tinfo->goal.period\n\t    || tinfo->current.width != tinfo->goal.width\n\t    || tinfo->current.offset != tinfo->goal.offset\n\t    || (force && (tinfo->goal.period != 0\n\t    || tinfo->goal.width != MSG_EXT_WDTR_BUS_8_BIT)))\n\t\tahc->targ_msg_req |= devinfo->target_mask;\n\telse\n\t\tahc->targ_msg_req &= ~devinfo->target_mask;\n\n\tif (ahc->targ_msg_req != targ_msg_req_orig) {\n\t\t/* Update the message request bit for this target */\n\t\tif ((ahc->features & AHC_HS_MAILBOX) != 0) {\n\t\t\tif (paused) {\n\t\t\t\tahc_outb(ahc, TARGET_MSG_REQUEST,\n\t\t\t\t\t ahc->targ_msg_req & 0xFF);\n\t\t\t\tahc_outb(ahc, TARGET_MSG_REQUEST + 1,\n\t\t\t\t\t (ahc->targ_msg_req >> 8) & 0xFF);\n\t\t\t} else {\n\t\t\t\tahc_outb(ahc, HS_MAILBOX,\n\t\t\t\t\t 0x01 << HOST_MAILBOX_SHIFT);\n\t\t\t}\n\t\t} else {\n\t\t\tif (!paused)\n\t\t\t\tpause_sequencer(ahc);\n\n\t\t\tahc_outb(ahc, TARGET_MSG_REQUEST,\n\t\t\t\t ahc->targ_msg_req & 0xFF);\n\t\t\tahc_outb(ahc, TARGET_MSG_REQUEST + 1,\n\t\t\t\t (ahc->targ_msg_req >> 8) & 0xFF);\n\n\t\t\tif (!paused)\n\t\t\t\tunpause_sequencer(ahc);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_fetch_transinfo",
          "args": [
            "ahc",
            "devinfo.channel",
            "devinfo.our_scsiid",
            "devinfo.target",
            "&tstate"
          ],
          "line": 1921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc_print_addr",
          "args": [
            "xs->sc_link"
          ],
          "line": 1910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_calc_residual",
          "args": [
            "scb"
          ],
          "line": 1907
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_calc_residual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "5577-5631",
          "snippet": "STATIC void\nahc_calc_residual(scb)\n\tstruct scb *scb;\n{\n\tstruct\thardware_scb *hscb;\n\n\thscb = scb->hscb;\n\n\t/*\n\t * If the disconnected flag is still set, this is bogus\n\t * residual information left over from a sequencer\n\t * pagin/pageout, so ignore this case.\n\t */\n\tif ((scb->hscb->control & DISCONNECTED) == 0) {\n\t\tu_int32_t resid;\n\t\tint\t  resid_sgs;\n\t\tint\t  sg;\n\t\t\n\t\t/*\n\t\t * Remainder of the SG where the transfer\n\t\t * stopped.\n\t\t */\n\t\tresid = (hscb->residual_data_count[2] << 16)\n\t\t      |\t(hscb->residual_data_count[1] <<8)\n\t\t      |\t(hscb->residual_data_count[0]);\n\n\t\t/*\n\t\t * Add up the contents of all residual\n\t\t * SG segments that are after the SG where\n\t\t * the transfer stopped.\n\t\t */\n\t\tresid_sgs = scb->hscb->residual_SG_count - 1/*current*/;\n\t\tsg = scb->sg_count - resid_sgs;\n\t\twhile (resid_sgs > 0) {\n\n\t\t\tresid += scb->sg_list[sg].len;\n\t\t\tsg++;\n\t\t\tresid_sgs--;\n\t\t}\n\t\tscb->xs->resid = resid;\n\t}\n\n\t/*\n\t * Clean out the residual information in this SCB for its\n\t * next consumer.\n\t */\n\thscb->residual_SG_count = 0;\n\n#ifdef AHC_DEBUG\n\tif (ahc_debug & AHC_SHOWMISC) {\n\t\tsc_print_addr(scb->xs->sc_link);\n\t\tprintf(\"Handled Residual of %ld bytes\\n\" ,scb->xs->resid);\n\t}\n#endif\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
            "STATIC void",
            "ahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC struct",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
            "STATIC void",
            "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_calc_residual __P((struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
            "STATIC struct",
            "STATIC struct",
            "STATIC struct",
            "struct scsi_xfer *xs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nSTATIC void;\nahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nSTATIC void;\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_calc_residual __P((struct scb *scb));\nSTATIC void;\nSTATIC void;\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nSTATIC struct;\nSTATIC struct;\nSTATIC struct;\nstruct scsi_xfer *xs;\n\nSTATIC void\nahc_calc_residual(scb)\n\tstruct scb *scb;\n{\n\tstruct\thardware_scb *hscb;\n\n\thscb = scb->hscb;\n\n\t/*\n\t * If the disconnected flag is still set, this is bogus\n\t * residual information left over from a sequencer\n\t * pagin/pageout, so ignore this case.\n\t */\n\tif ((scb->hscb->control & DISCONNECTED) == 0) {\n\t\tu_int32_t resid;\n\t\tint\t  resid_sgs;\n\t\tint\t  sg;\n\t\t\n\t\t/*\n\t\t * Remainder of the SG where the transfer\n\t\t * stopped.\n\t\t */\n\t\tresid = (hscb->residual_data_count[2] << 16)\n\t\t      |\t(hscb->residual_data_count[1] <<8)\n\t\t      |\t(hscb->residual_data_count[0]);\n\n\t\t/*\n\t\t * Add up the contents of all residual\n\t\t * SG segments that are after the SG where\n\t\t * the transfer stopped.\n\t\t */\n\t\tresid_sgs = scb->hscb->residual_SG_count - 1/*current*/;\n\t\tsg = scb->sg_count - resid_sgs;\n\t\twhile (resid_sgs > 0) {\n\n\t\t\tresid += scb->sg_list[sg].len;\n\t\t\tsg++;\n\t\t\tresid_sgs--;\n\t\t}\n\t\tscb->xs->resid = resid;\n\t}\n\n\t/*\n\t * Clean out the residual information in this SCB for its\n\t * next consumer.\n\t */\n\thscb->residual_SG_count = 0;\n\n#ifdef AHC_DEBUG\n\tif (ahc_debug & AHC_SHOWMISC) {\n\t\tsc_print_addr(scb->xs->sc_link);\n\t\tprintf(\"Handled Residual of %ld bytes\\n\" ,scb->xs->resid);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "SCB_LUN",
          "args": [
            "scb"
          ],
          "line": 1889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc_print_addr",
          "args": [
            "scb->xs->sc_link"
          ],
          "line": 1879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc_print_addr",
          "args": [
            "scb->xs->sc_link"
          ],
          "line": 1854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 1849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 1823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "RETURN_1",
            "0"
          ],
          "line": 1818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCB_TAG"
          ],
          "line": 1810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCSISIGI"
          ],
          "line": 1792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 1791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCSISIGI"
          ],
          "line": 1785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 1784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "LASTPHASE"
          ],
          "line": 1781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 1773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_reset_channel",
          "args": [
            "ahc",
            "devinfo.channel",
            "/*initiate reset*/TRUE"
          ],
          "line": 1770
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_reset_channel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "5412-5527",
          "snippet": "STATIC int\nahc_reset_channel(ahc, channel, initiate_reset)\n\tstruct ahc_softc *ahc;\n\tchar channel;\n\tint initiate_reset;\n{\n\tu_int\tinitiator, target, max_scsiid;\n\tu_int\tsblkctl;\n\tu_int\tour_id;\n\tint\tfound;\n\tint\trestart_needed;\n\tchar\tcur_channel;\n\n\tahc->pending_device = NULL;\n\n\tpause_sequencer(ahc);\n\n\t/*\n\t * Run our command complete fifos to ensure that we perform\n\t * completion processing on any commands that 'completed'\n\t * before the reset occurred.\n\t */\n\tahc_run_qoutfifo(ahc);\n\n\t/*\n\t * Reset the bus if we are initiating this reset\n\t */\n\tsblkctl = ahc_inb(ahc, SBLKCTL);\n\tcur_channel = 'A';\n\tif ((ahc->features & AHC_TWIN) != 0\n\t && ((sblkctl & SELBUSB) != 0))\n\t    cur_channel = 'B';\n\tif (cur_channel != channel) {\n\t\t/* Case 1: Command for another bus is active\n\t\t * Stealthily reset the other bus without\n\t\t * upsetting the current bus.\n\t\t */\n\t\tahc_outb(ahc, SBLKCTL, sblkctl ^ SELBUSB);\n\t\tahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENBUSFREE);\n\t\tahc_outb(ahc, SCSISEQ,\n\t\t\t ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP));\n\t\tif (initiate_reset)\n\t\t\tahc_reset_current_bus(ahc);\n\t\tahc_clear_intstat(ahc);\n\t\tahc_outb(ahc, SBLKCTL, sblkctl);\n\t\trestart_needed = FALSE;\n\t} else {\n\t\t/* Case 2: A command from this bus is active or we're idle */\n\t\tahc_clear_msg_state(ahc);\n\t\tahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENBUSFREE);\n\t\tahc_outb(ahc, SCSISEQ,\n\t\t\t ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP));\n\t\tif (initiate_reset)\n\t\t\tahc_reset_current_bus(ahc);\n\t\tahc_clear_intstat(ahc);\n\n\t\t/*\n\t\t * Since we are going to restart the sequencer, avoid\n\t\t * a race in the sequencer that could cause corruption\n\t\t * of our Q pointers by starting over from index 0.\n\t\t */\n\t\tahc->qoutfifonext = 0;\n\t\tif ((ahc->features & AHC_QUEUE_REGS) != 0)\n\t\t\tahc_outb(ahc, SDSCB_QOFF, 0);\n\t\telse\n\t\t\tahc_outb(ahc, QOUTPOS, 0);\n\t\trestart_needed = TRUE;\n\t}\n\n\t/*\n\t * Clean up all the state information for the\n\t * pending transactions on this bus.\n\t */\n\tfound = ahc_abort_scbs(ahc, ALL_TARGETS, channel,\n\t\t\t       ALL_LUNS, SCB_LIST_NULL,\n\t\t\t       ROLE_UNKNOWN, XS_RESET);\n\tif (channel == 'B') {\n\t\tour_id = ahc->our_id_b;\n\t} else {\n\t\tour_id = ahc->our_id;\n\t}\n\n\tmax_scsiid = (ahc->features & AHC_WIDE) ? 15 : 7;\n\t\n\t/*\n\t * Revert to async/narrow transfers until we renegotiate.\n\t */\n\tfor (target = 0; target <= max_scsiid; target++) {\n\n\t\tif (ahc->enabled_targets[target] == NULL)\n\t\t\tcontinue;\n\t\tfor (initiator = 0; initiator <= max_scsiid; initiator++) {\n\t\t\tstruct ahc_devinfo devinfo;\n\n\t\t\tahc_compile_devinfo(&devinfo, target, initiator,\n\t\t\t\t\t    ALL_LUNS,\n\t\t\t\t\t    channel, ROLE_UNKNOWN);\n\t\t\tahc_set_width(ahc, &devinfo,\n\t\t\t\t      MSG_EXT_WDTR_BUS_8_BIT,\n\t\t\t\t      AHC_TRANS_CUR,\n\t\t\t\t      /*paused*/TRUE,\n\t\t\t\t      /*done*/FALSE);\n\t\t\tahc_set_syncrate(ahc, &devinfo,\n\t\t\t\t\t /*syncrate*/NULL, /*period*/0,\n\t\t\t\t\t /*offset*/0, AHC_TRANS_CUR,\n\t\t\t\t\t /*paused*/TRUE,\n\t\t\t\t\t /*done*/FALSE);\n\t\t}\n\t}\n\n\tif (restart_needed)\n\t\trestart_sequencer(ahc);\n\telse\n\t\tunpause_sequencer(ahc);\n\treturn found;\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC int",
            "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "ahc_reset_channel __P((struct ahc_softc *ahc, char channel,\n\t\t\t\t       int initiate_reset));",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "ahc_update_target_msg_request __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t\t      struct ahc_initiator_tinfo *tinfo,\n\t\t\t\t\t      int force, int paused));",
            "STATIC void",
            "ahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));",
            "STATIC void",
            "ahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "static __inline void pause_sequencer",
            "static __inline void unpause_sequencer",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "u_int our_id;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "u_int *period;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "u_int *period;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nahc_reset_channel __P((struct ahc_softc *ahc, char channel,\n\t\t\t\t       int initiate_reset));\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nahc_update_target_msg_request __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t\t      struct ahc_initiator_tinfo *tinfo,\n\t\t\t\t\t      int force, int paused));\nSTATIC void;\nahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));\nSTATIC void;\nahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nstatic __inline void pause_sequencer;\nstatic __inline void unpause_sequencer;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nu_int our_id;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC int\nahc_reset_channel(ahc, channel, initiate_reset)\n\tstruct ahc_softc *ahc;\n\tchar channel;\n\tint initiate_reset;\n{\n\tu_int\tinitiator, target, max_scsiid;\n\tu_int\tsblkctl;\n\tu_int\tour_id;\n\tint\tfound;\n\tint\trestart_needed;\n\tchar\tcur_channel;\n\n\tahc->pending_device = NULL;\n\n\tpause_sequencer(ahc);\n\n\t/*\n\t * Run our command complete fifos to ensure that we perform\n\t * completion processing on any commands that 'completed'\n\t * before the reset occurred.\n\t */\n\tahc_run_qoutfifo(ahc);\n\n\t/*\n\t * Reset the bus if we are initiating this reset\n\t */\n\tsblkctl = ahc_inb(ahc, SBLKCTL);\n\tcur_channel = 'A';\n\tif ((ahc->features & AHC_TWIN) != 0\n\t && ((sblkctl & SELBUSB) != 0))\n\t    cur_channel = 'B';\n\tif (cur_channel != channel) {\n\t\t/* Case 1: Command for another bus is active\n\t\t * Stealthily reset the other bus without\n\t\t * upsetting the current bus.\n\t\t */\n\t\tahc_outb(ahc, SBLKCTL, sblkctl ^ SELBUSB);\n\t\tahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENBUSFREE);\n\t\tahc_outb(ahc, SCSISEQ,\n\t\t\t ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP));\n\t\tif (initiate_reset)\n\t\t\tahc_reset_current_bus(ahc);\n\t\tahc_clear_intstat(ahc);\n\t\tahc_outb(ahc, SBLKCTL, sblkctl);\n\t\trestart_needed = FALSE;\n\t} else {\n\t\t/* Case 2: A command from this bus is active or we're idle */\n\t\tahc_clear_msg_state(ahc);\n\t\tahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENBUSFREE);\n\t\tahc_outb(ahc, SCSISEQ,\n\t\t\t ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP));\n\t\tif (initiate_reset)\n\t\t\tahc_reset_current_bus(ahc);\n\t\tahc_clear_intstat(ahc);\n\n\t\t/*\n\t\t * Since we are going to restart the sequencer, avoid\n\t\t * a race in the sequencer that could cause corruption\n\t\t * of our Q pointers by starting over from index 0.\n\t\t */\n\t\tahc->qoutfifonext = 0;\n\t\tif ((ahc->features & AHC_QUEUE_REGS) != 0)\n\t\t\tahc_outb(ahc, SDSCB_QOFF, 0);\n\t\telse\n\t\t\tahc_outb(ahc, QOUTPOS, 0);\n\t\trestart_needed = TRUE;\n\t}\n\n\t/*\n\t * Clean up all the state information for the\n\t * pending transactions on this bus.\n\t */\n\tfound = ahc_abort_scbs(ahc, ALL_TARGETS, channel,\n\t\t\t       ALL_LUNS, SCB_LIST_NULL,\n\t\t\t       ROLE_UNKNOWN, XS_RESET);\n\tif (channel == 'B') {\n\t\tour_id = ahc->our_id_b;\n\t} else {\n\t\tour_id = ahc->our_id;\n\t}\n\n\tmax_scsiid = (ahc->features & AHC_WIDE) ? 15 : 7;\n\t\n\t/*\n\t * Revert to async/narrow transfers until we renegotiate.\n\t */\n\tfor (target = 0; target <= max_scsiid; target++) {\n\n\t\tif (ahc->enabled_targets[target] == NULL)\n\t\t\tcontinue;\n\t\tfor (initiator = 0; initiator <= max_scsiid; initiator++) {\n\t\t\tstruct ahc_devinfo devinfo;\n\n\t\t\tahc_compile_devinfo(&devinfo, target, initiator,\n\t\t\t\t\t    ALL_LUNS,\n\t\t\t\t\t    channel, ROLE_UNKNOWN);\n\t\t\tahc_set_width(ahc, &devinfo,\n\t\t\t\t      MSG_EXT_WDTR_BUS_8_BIT,\n\t\t\t\t      AHC_TRANS_CUR,\n\t\t\t\t      /*paused*/TRUE,\n\t\t\t\t      /*done*/FALSE);\n\t\t\tahc_set_syncrate(ahc, &devinfo,\n\t\t\t\t\t /*syncrate*/NULL, /*period*/0,\n\t\t\t\t\t /*offset*/0, AHC_TRANS_CUR,\n\t\t\t\t\t /*paused*/TRUE,\n\t\t\t\t\t /*done*/FALSE);\n\t\t}\n\t}\n\n\tif (restart_needed)\n\t\trestart_sequencer(ahc);\n\telse\n\t\tunpause_sequencer(ahc);\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SAVED_TCL"
          ],
          "line": 1769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "LASTPHASE"
          ],
          "line": 1769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 1768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 1752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "ACCUM"
          ],
          "line": 1749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "HS_MAILBOX",
            "0"
          ],
          "line": 1745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "TARGET_MSG_REQUEST + 1",
            "(ahc->targ_msg_req >> 8) & 0xFF"
          ],
          "line": 1743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "TARGET_MSG_REQUEST",
            "ahc->targ_msg_req & 0xFF"
          ],
          "line": 1742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCSISIGO",
            "ahc_inb(ahc, LASTPHASE) | ATNO"
          ],
          "line": 1738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "LASTPHASE"
          ],
          "line": 1738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "MSG_OUT",
            "HOST_MSG"
          ],
          "line": 1737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SEQ_FLAGS"
          ],
          "line": 1732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "ARG_1"
          ],
          "line": 1731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SAVED_TCL"
          ],
          "line": 1731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 1729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCSISEQ",
            "ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP)"
          ],
          "line": 1724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCSISEQ"
          ],
          "line": 1725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "CLRINT",
            "CLRSEQINT"
          ],
          "line": 1719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_fetch_devinfo",
          "args": [
            "ahc",
            "&devinfo"
          ],
          "line": 1711
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_fetch_devinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "1538-1566",
          "snippet": "STATIC void\nahc_fetch_devinfo(ahc, devinfo)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n{\n\tu_int\tsaved_tcl;\n\trole_t\trole;\n\tint\tour_id;\n\n\tif (ahc_inb(ahc, SSTAT0) & TARGET)\n\t\trole = ROLE_TARGET;\n\telse\n\t\trole = ROLE_INITIATOR;\n\n\tif (role == ROLE_TARGET\n\t && (ahc->features & AHC_MULTI_TID) != 0\n\t && (ahc_inb(ahc, SEQ_FLAGS) & CMDPHASE_PENDING) != 0) {\n\t\t/* We were selected, so pull our id from TARGIDIN */\n\t\tour_id = ahc_inb(ahc, TARGIDIN) & OID;\n\t} else if ((ahc->features & AHC_ULTRA2) != 0)\n\t\tour_id = ahc_inb(ahc, SCSIID_ULTRA2) & OID;\n\telse\n\t\tour_id = ahc_inb(ahc, SCSIID) & OID;\n\n\tsaved_tcl = ahc_inb(ahc, SAVED_TCL);\n\tahc_compile_devinfo(devinfo, our_id, TCL_TARGET(saved_tcl),\n\t\t\t    TCL_LUN(saved_tcl), TCL_CHANNEL(ahc, saved_tcl),\n\t\t\t    role);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC int",
            "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "ahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "u_int our_id;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nu_int our_id;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_fetch_devinfo(ahc, devinfo)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n{\n\tu_int\tsaved_tcl;\n\trole_t\trole;\n\tint\tour_id;\n\n\tif (ahc_inb(ahc, SSTAT0) & TARGET)\n\t\trole = ROLE_TARGET;\n\telse\n\t\trole = ROLE_INITIATOR;\n\n\tif (role == ROLE_TARGET\n\t && (ahc->features & AHC_MULTI_TID) != 0\n\t && (ahc_inb(ahc, SEQ_FLAGS) & CMDPHASE_PENDING) != 0) {\n\t\t/* We were selected, so pull our id from TARGIDIN */\n\t\tour_id = ahc_inb(ahc, TARGIDIN) & OID;\n\t} else if ((ahc->features & AHC_ULTRA2) != 0)\n\t\tour_id = ahc_inb(ahc, SCSIID_ULTRA2) & OID;\n\telse\n\t\tour_id = ahc_inb(ahc, SCSIID) & OID;\n\n\tsaved_tcl = ahc_inb(ahc, SAVED_TCL);\n\tahc_compile_devinfo(devinfo, our_id, TCL_TARGET(saved_tcl),\n\t\t\t    TCL_LUN(saved_tcl), TCL_CHANNEL(ahc, saved_tcl),\n\t\t\t    role);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nSTATIC void;\nahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nahc_handle_seqint __P((struct ahc_softc *ahc, u_int intstat));\nSTATIC void;\nahc_handle_scsiint __P((struct ahc_softc *ahc, u_int intstat));\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));\nSTATIC int;\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nahc_update_target_msg_request __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t\t      struct ahc_initiator_tinfo *tinfo,\n\t\t\t\t\t      int force, int paused));\nSTATIC void;\nahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));\nSTATIC void;\nahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));\nSTATIC void;\nSTATIC int;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nSTATIC void;\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_calc_residual __P((struct scb *scb));\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nSTATIC void;\nstatic __inline void unpause_sequencer;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nstatic __inline void\tahc_busy_tcl;\nstatic __inline void ahc_freeze_ccb;\nstatic __inline void ahcsetccbstatus;\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo;\nSTATIC void;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct tmode_tstate **tstate;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nstatic struct {\n        u_int8_t phase;\n        u_int8_t mesg_out; /* Message response to parity errors */\n\tchar *phasemsg;\n} phase_table[] = {\n\t{ P_DATAOUT,\tMSG_NOOP,\t\t\"in Data-out phase\"\t},\n\t{ P_DATAIN,\tMSG_INITIATOR_DET_ERR,\t\"in Data-in phase\"\t},\n\t{ P_COMMAND,\tMSG_NOOP,\t\t\"in Command phase\"\t},\n\t{ P_MESGOUT,\tMSG_NOOP,\t\t\"in Message-out phase\"\t},\n\t{ P_STATUS,\tMSG_INITIATOR_DET_ERR,\t\"in Status phase\"\t},\n\t{ P_MESGIN,\tMSG_PARITY_ERROR,\t\"in Message-in phase\"\t},\n\t{ P_BUSFREE,\tMSG_NOOP,\t\t\"while idle\"\t\t},\n\t{ 0,\t\tMSG_NOOP,\t\t\"in unknown phase\"\t}\n};\nstatic const int num_phases = (sizeof(phase_table)/sizeof(phase_table[0])) - 1;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n\nSTATIC void\nahc_handle_seqint(ahc, intstat)\n\tstruct ahc_softc *ahc;\n\tu_int intstat;\n{\n\tstruct scb *scb;\n\tstruct ahc_devinfo devinfo;\n\t\n\tahc_fetch_devinfo(ahc, &devinfo);\n\n\t/*\n\t * Clear the upper byte that holds SEQINT status\n\t * codes and clear the SEQINT bit. We will unpause\n\t * the sequencer, if appropriate, after servicing\n\t * the request.\n\t */\n\tahc_outb(ahc, CLRINT, CLRSEQINT);\n\tswitch (intstat & SEQINT_MASK) {\n\tcase NO_MATCH:\n\t{\n\t\t/* Ensure we don't leave the selection hardware on */\n\t\tahc_outb(ahc, SCSISEQ,\n\t\t\t ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP));\n\n\t\tprintf(\"%s:%c:%d: no active SCB for reconnecting \"\n\t\t       \"target - issuing BUS DEVICE RESET\\n\",\n\t\t       ahc_name(ahc), devinfo.channel, devinfo.target);\n\t\tprintf(\"SAVED_TCL == 0x%x, ARG_1 == 0x%x, SEQ_FLAGS == 0x%x\\n\",\n\t\t       ahc_inb(ahc, SAVED_TCL), ahc_inb(ahc, ARG_1),\n\t\t       ahc_inb(ahc, SEQ_FLAGS));\n\t\tahc->msgout_buf[0] = MSG_BUS_DEV_RESET;\n\t\tahc->msgout_len = 1;\n\t\tahc->msgout_index = 0;\n\t\tahc->msg_type = MSG_TYPE_INITIATOR_MSGOUT;\n\t\tahc_outb(ahc, MSG_OUT, HOST_MSG);\n\t\tahc_outb(ahc, SCSISIGO, ahc_inb(ahc, LASTPHASE) | ATNO);\n\t\tbreak;\n\t}\n\tcase UPDATE_TMSG_REQ:\n\t\tahc_outb(ahc, TARGET_MSG_REQUEST, ahc->targ_msg_req & 0xFF);\n\t\tahc_outb(ahc, TARGET_MSG_REQUEST + 1,\n\t\t\t (ahc->targ_msg_req >> 8) & 0xFF);\n\t\tahc_outb(ahc, HS_MAILBOX, 0);\n\t\tbreak;\n\tcase SEND_REJECT: \n\t{\n\t\tu_int rejbyte = ahc_inb(ahc, ACCUM);\n\t\tprintf(\"%s:%c:%d: Warning - unknown message received from \"\n\t\t       \"target (0x%x).  Rejecting\\n\", \n\t\t       ahc_name(ahc), devinfo.channel, devinfo.target, rejbyte);\n\t\tbreak; \n\t}\n\tcase NO_IDENT: \n\t{\n\t\t/*\n\t\t * The reconnecting target either did not send an identify\n\t\t * message, or did, but we didn't find and SCB to match and\n\t\t * before it could respond to our ATN/abort, it hit a dataphase.\n\t\t * The only safe thing to do is to blow it away with a bus\n\t\t * reset.\n\t\t */\n\t\tint found;\n\n\t\tprintf(\"%s:%c:%d: Target did not send an IDENTIFY message. \"\n\t\t       \"LASTPHASE = 0x%x, SAVED_TCL == 0x%x\\n\",\n\t\t       ahc_name(ahc), devinfo.channel, devinfo.target,\n\t\t       ahc_inb(ahc, LASTPHASE), ahc_inb(ahc, SAVED_TCL));\n\t\tfound = ahc_reset_channel(ahc, devinfo.channel, \n\t\t\t\t\t  /*initiate reset*/TRUE);\n\t\tprintf(\"%s: Issued Channel %c Bus Reset. \"\n\t\t       \"%d SCBs aborted\\n\", ahc_name(ahc), devinfo.channel,\n\t\t       found);\n\t\treturn;\n\t}\n\tcase BAD_PHASE:\n\t{\n\t\tu_int lastphase;\n\n\t\tlastphase = ahc_inb(ahc, LASTPHASE);\n\t\tif (lastphase == P_BUSFREE) {\n\t\t\tprintf(\"%s:%c:%d: Missed busfree.  Curphase = 0x%x\\n\",\n\t\t\t       ahc_name(ahc), devinfo.channel, devinfo.target,\n\t\t\t       ahc_inb(ahc, SCSISIGI));\n\t\t\trestart_sequencer(ahc);\n\t\t\treturn;\n\t\t} else {\n\t\t\tprintf(\"%s:%c:%d: unknown scsi bus phase %x.  \"\n\t\t\t       \"Attempting to continue\\n\",\n\t\t\t       ahc_name(ahc), devinfo.channel, devinfo.target,\n\t\t\t       ahc_inb(ahc, SCSISIGI));\n\t\t}\n\t\tbreak; \n\t}\n\tcase BAD_STATUS:\n\t{\n\t\tu_int  scb_index;\n\t\tstruct hardware_scb *hscb;\n\t\tstruct scsi_xfer *xs;\n\t\t/*\n\t\t * The sequencer will notify us when a command\n\t\t * has an error that would be of interest to\n\t\t * the kernel.  This allows us to leave the sequencer\n\t\t * running in the common case of command completes\n\t\t * without error.  The sequencer will already have\n\t\t * dma'd the SCB back up to us, so we can reference\n\t\t * the in kernel copy directly.\n\t\t */\n\t\tscb_index = ahc_inb(ahc, SCB_TAG);\n\t\tscb = &ahc->scb_data->scbarray[scb_index];\n\n\t\t/*\n\t\t * Set the default return value to 0 (don't\n\t\t * send sense).  The sense code will change\n\t\t * this if needed.\n\t\t */\n\t\tahc_outb(ahc, RETURN_1, 0);\n\t\tif (!(scb_index < ahc->scb_data->numscbs\n\t\t   && (scb->flags & SCB_ACTIVE) != 0)) {\n\t\t\tprintf(\"%s:%c:%d: ahc_intr - referenced scb \"\n\t\t\t       \"not valid during seqint 0x%x scb(%d)\\n\",\n\t\t\t       ahc_name(ahc), devinfo.channel,\n\t\t\t       devinfo.target, intstat, scb_index);\n\t\t\tgoto unpause;\n\t\t}\n\n\t\thscb = scb->hscb; \n\t\txs = scb->xs;\n\n\t\t/* Don't want to clobber the original sense code */\n\t\tif ((scb->flags & SCB_SENSE) != 0) {\n\t\t\t/*\n\t\t\t * Clear the SCB_SENSE Flag and have\n\t\t\t * the sequencer do a normal command\n\t\t\t * complete.\n\t\t\t */\n\t\t\tscb->flags &= ~SCB_SENSE;\n\t\t\tahcsetccbstatus(xs, XS_DRIVER_STUFFUP);\n\t\t\tbreak;\n\t\t}\n\t\t/* Freeze the queue unit the client sees the error. */\n\t\tahc_freeze_devq(ahc, xs->sc_link);\n\t\tahc_freeze_ccb(scb);\n\t\txs->status = hscb->status;\n\t\tswitch (hscb->status) {\n\t\tcase SCSI_OK:\n\t\t\tprintf(\"%s: Interrupted for staus of 0???\\n\",\n\t\t\t       ahc_name(ahc));\n\t\t\tbreak;\n\t\tcase SCSI_CHECK:\n#ifdef AHC_DEBUG\n\t\t\tif (ahc_debug & AHC_SHOWSENSE) {\n\t\t\t\tsc_print_addr(scb->xs->sc_link);\n\t\t\t\tprintf(\"SCB %d: requests Check Status\\n\",\n\t\t\t\t       scb->hscb->tag);\n\t\t\t}\n#endif\n\t\t\t\t\n\t\t\tif (xs->error == XS_NOERROR &&\n\t\t\t    !(scb->flags & SCB_SENSE)) {\n\t\t\t\tstruct ahc_dma_seg *sg;\n\t\t\t\tstruct scsi_sense *sc;\n\t\t\t\tstruct ahc_initiator_tinfo *tinfo;\n\t\t\t\tstruct tmode_tstate *tstate;\n\n\t\t\t\tsg = scb->sg_list;\n\t\t\t\tsc = (struct scsi_sense *)(&hscb->cmdstore); \n\t\t\t\t/*\n\t\t\t\t * Save off the residual if there is one.\n\t\t\t\t */\n\t\t\t\tif (hscb->residual_SG_count != 0)\n\t\t\t\t\tahc_calc_residual(scb);\n\t\t\t\telse\n\t\t\t\t\txs->resid = 0;\n\n#ifdef AHC_DEBUG\n\t\t\t\tif (ahc_debug & AHC_SHOWSENSE) {\n\t\t\t\t\tsc_print_addr(scb->xs->sc_link);\n\t\t\t\t\tprintf(\"Sending Sense\\n\");\n\t\t\t\t}\n#endif\n\t\t\t\tsg->addr = ahc->scb_data->sense_busaddr +\n\t\t\t\t\t(hscb->tag*sizeof(struct scsi_sense_data));\n\t\t\t\t\n\t\t\t\tsg->len = sizeof(struct scsi_sense_data);\n\n\t\t\t\tsc->opcode = REQUEST_SENSE;\n\t\t\t\tsc->byte2 =  SCB_LUN(scb) << 5;\n\t\t\t\tsc->unused[0] = 0;\n\t\t\t\tsc->unused[1] = 0;\n\t\t\t\tsc->length = sg->len;\n\t\t\t\tsc->control = 0;\n\n\t\t\t\t/*\n\t\t\t\t * Would be nice to preserve DISCENB here,\n\t\t\t\t * but due to the way we page SCBs, we can't.\n\t\t\t\t */\n\t\t\t\thscb->control = 0;\n\n\t\t\t\t/*\n\t\t\t\t * This request sense could be because the\n\t\t\t\t * the device lost power or in some other\n\t\t\t\t * way has lost our transfer negotiations.\n\t\t\t\t * Renegotiate if appropriate.\n\t\t\t\t */\n\t\t\t\tahc_calc_residual(scb);\n#ifdef AHC_DEBUG\n\t\t\t\tif (ahc_debug & AHC_SHOWSENSE) {\n\t\t\t\t\tsc_print_addr(xs->sc_link);\n\t\t\t\t\tprintf(\"Sense: datalen %d resid %d\"\n\t\t\t\t\t       \"chan %d id %d targ %d\\n\",\n\t\t\t\t\t       xs->datalen, xs->resid,\n\t\t\t\t\t       devinfo.channel,\n\t\t\t\t\t       devinfo.our_scsiid,\n\t\t\t\t\t       devinfo.target);\n\t\t\t\t}\n#endif\n\t\t\t\tif (xs->datalen > 0 &&\n\t\t\t\t    xs->resid == xs->datalen) {\n\t\t\t\ttinfo = ahc_fetch_transinfo(ahc,\n\t\t\t\t\t\t\t    devinfo.channel,\n\t\t\t\t\t\t\t    devinfo.our_scsiid,\n\t\t\t\t\t\t\t    devinfo.target,\n\t\t\t\t\t\t\t    &tstate);\n\t\t\t\t\tahc_update_target_msg_request(ahc,\n\t\t\t\t\t\t\t      &devinfo,\n\t\t\t\t\t\t\t      tinfo,\n\t\t\t\t\t\t\t      /*force*/TRUE,\n\t\t\t\t\t\t\t      /*paused*/TRUE);\n\t\t\t\t}\n\t\t\t\thscb->status = 0;\n\t\t\t\thscb->SG_count = 1;\n\t\t\t\thscb->SG_pointer = scb->sg_list_phys;\n\t\t\t\thscb->data = sg->addr; \n\t\t\t\thscb->datalen = sg->len;\n\t\t\t\thscb->cmdpointer = hscb->cmdstore_busaddr;\n\t\t\t\thscb->cmdlen = sizeof(*sc);\n\t\t\t\tscb->sg_count = hscb->SG_count;\n\t\t\t\tscb->flags |= SCB_SENSE;\n\t\t\t\t/*\n\t\t\t\t * Ensure the target is busy since this\n\t\t\t\t * will be an untagged request.\n\t\t\t\t */\n\t\t\t\tahc_busy_tcl(ahc, scb);\n\t\t\t\tahc_outb(ahc, RETURN_1, SEND_SENSE);\n\n\t\t\t\t/*\n\t\t\t\t * Ensure we have enough time to actually\n\t\t\t\t * retrieve the sense.\n\t\t\t\t */\n\t\t\t\tif (!(scb->xs->flags & SCSI_POLL)) {\n\t\t\t\tuntimeout(ahc_timeout, (caddr_t)scb);\n\t\t\t\t\ttimeout(ahc_timeout, (caddr_t)scb,\n\t\t\t\t\t    5 * hz);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SCSI_BUSY:\n\t\t\t/*\n\t\t\t * Requeue any transactions that haven't been\n\t\t\t * sent yet.\n\t\t\t */\n\t\t\tahc_freeze_devq(ahc, xs->sc_link);\n\t\t\tahc_freeze_ccb(scb);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\tcase TRACE_POINT:\n\t{\n\t\tprintf(\"SSTAT2 = 0x%x DFCNTRL = 0x%x\\n\", ahc_inb(ahc, SSTAT2),\n\t\t       ahc_inb(ahc, DFCNTRL));\n\t\tprintf(\"SSTAT3 = 0x%x DSTATUS = 0x%x\\n\", ahc_inb(ahc, SSTAT3),\n\t\t       ahc_inb(ahc, DFSTATUS));\n\t\tprintf(\"SSTAT0 = 0x%x, SCB_DATACNT = 0x%x\\n\",\n\t\t       ahc_inb(ahc, SSTAT0),\n\t\t       ahc_inb(ahc, SCB_DATACNT));\n\t\tbreak;\n\t}\n\tcase HOST_MSG_LOOP:\n\t{\n\t\t/*\n\t\t * The sequencer has encountered a message phase\n\t\t * that requires host assistance for completion.\n\t\t * While handling the message phase(s), we will be\n\t\t * notified by the sequencer after each byte is\n\t\t * transfered so we can track bus phases.\n\t\t *\n\t\t * If this is the first time we've seen a HOST_MSG_LOOP,\n\t\t * initialize the state of the host message loop.\n\t\t */\n\t\tif (ahc->msg_type == MSG_TYPE_NONE) {\n\t\t\tu_int bus_phase;\n\n\t\t\tbus_phase = ahc_inb(ahc, SCSISIGI) & PHASE_MASK;\n\t\t\tif (bus_phase != P_MESGIN\n\t\t\t && bus_phase != P_MESGOUT) {\n\t\t\t\tprintf(\"ahc_intr: HOST_MSG_LOOP bad \"\n\t\t\t\t       \"phase 0x%x\\n\",\n\t\t\t\t      bus_phase);\n\t\t\t\t/*\n\t\t\t\t * Probably transitioned to bus free before\n\t\t\t\t * we got here.  Just punt the message.\n\t\t\t\t */\n\t\t\t\tahc_clear_intstat(ahc);\n\t\t\t\trestart_sequencer(ahc);\n\t\t\t}\n\n\t\t\tif (devinfo.role == ROLE_INITIATOR) {\n\t\t\t\tstruct scb *scb;\n\t\t\t\tu_int scb_index;\n\n\t\t\t\tscb_index = ahc_inb(ahc, SCB_TAG);\n\t\t\t\tscb = &ahc->scb_data->scbarray[scb_index];\n\n\t\t\t\tif (bus_phase == P_MESGOUT)\n\t\t\t\t\tahc_setup_initiator_msgout(ahc,\n\t\t\t\t\t\t\t\t   &devinfo,\n\t\t\t\t\t\t\t\t   scb);\n\t\t\t\telse {\n\t\t\t\t\tahc->msg_type =\n\t\t\t\t\t    MSG_TYPE_INITIATOR_MSGIN;\n\t\t\t\t\tahc->msgin_index = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (bus_phase == P_MESGOUT) {\n\t\t\t\t\tahc->msg_type =\n\t\t\t\t\t    MSG_TYPE_TARGET_MSGOUT;\n\t\t\t\t\tahc->msgin_index = 0;\n\t\t\t\t} else \n\t\t\t\t\t/* XXX Ever executed??? */\n\t\t\t\t\tahc_setup_target_msgin(ahc, &devinfo);\n\t\t\t}\n\t\t}\n\n\t\t/* Pass a NULL path so that handlers generate their own */\n\t\tahc_handle_message_phase(ahc, /*path*/NULL);\n\t\tbreak;\n\t}\n\tcase PERR_DETECTED:\n\t{\n\t\t/*\n\t\t * If we've cleared the parity error interrupt\n\t\t * but the sequencer still believes that SCSIPERR\n\t\t * is true, it must be that the parity error is\n\t\t * for the currently presented byte on the bus,\n\t\t * and we are not in a phase (data-in) where we will\n\t\t * eventually ack this byte.  Ack the byte and\n\t\t * throw it away in the hope that the target will\n\t\t * take us to message out to deliver the appropriate\n\t\t * error message.\n\t\t */\n\t\tif ((intstat & SCSIINT) == 0\n\t\t && (ahc_inb(ahc, SSTAT1) & SCSIPERR) != 0) {\n\t\t\tu_int curphase;\n\n\t\t\t/*\n\t\t\t * The hardware will only let you ack bytes\n\t\t\t * if the expected phase in SCSISIGO matches\n\t\t\t * the current phase.  Make sure this is\n\t\t\t * currently the case.\n\t\t\t */\n\t\t\tcurphase = ahc_inb(ahc, SCSISIGI) & PHASE_MASK;\n\t\t\tahc_outb(ahc, LASTPHASE, curphase);\n\t\t\tahc_outb(ahc, SCSISIGO, curphase);\n\t\t\tahc_inb(ahc, SCSIDATL);\n\t\t}\n\t\tbreak;\n\t}\n\tcase DATA_OVERRUN:\n\t{\n\t\t/*\n\t\t * When the sequencer detects an overrun, it\n\t\t * places the controller in \"BITBUCKET\" mode\n\t\t * and allows the target to complete its transfer.\n\t\t * Unfortunately, none of the counters get updated\n\t\t * when the controller is in this mode, so we have\n\t\t * no way of knowing how large the overrun was.\n\t\t */\n\t\tu_int scbindex = ahc_inb(ahc, SCB_TAG);\n\t\tu_int lastphase = ahc_inb(ahc, LASTPHASE);\n\t\tint i;\n\n\t\tscb = &ahc->scb_data->scbarray[scbindex];\n\t\tfor (i = 0; i < num_phases; i++) {\n\t\t\tif (lastphase == phase_table[i].phase)\n\t\t\t\tbreak;\n\t\t}\n\t\tsc_print_addr(scb->xs->sc_link);\n\t\tprintf(\"data overrun detected %s.\"\n\t\t       \"  Tag == 0x%x.\\n\",\n\t\t       phase_table[i].phasemsg,\n  \t\t       scb->hscb->tag);\n\t\tsc_print_addr(scb->xs->sc_link);\n\t\tprintf(\"%s seen Data Phase.  Length = %d.  NumSGs = %d.\\n\",\n\t\t       ahc_inb(ahc, SEQ_FLAGS) & DPHASE ? \"Have\" : \"Haven't\",\n\t\t       scb->xs->datalen, scb->sg_count);\n\t\tif (scb->sg_count > 0) {\n\t\t\tfor (i = 0; i < scb->sg_count; i++) {\n\t\t\t\tprintf(\"sg[%d] - Addr 0x%x : Length %d\\n\",\n\t\t\t\t       i,\n\t\t\t\t       scb->sg_list[i].addr,\n\t\t\t\t       scb->sg_list[i].len);\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Set this and it will take affect when the\n\t\t * target does a command complete.\n\t\t */\n\t\tahc_freeze_devq(ahc, scb->xs->sc_link);\n\t\tahcsetccbstatus(scb->xs, XS_DRIVER_STUFFUP);\n\t\tahc_freeze_ccb(scb);\n\t\tbreak;\n\t}\n\tcase TRACEPOINT:\n\t{\n\t\tprintf(\"TRACEPOINT: RETURN_2 = %d\\n\", ahc_inb(ahc, RETURN_2));\n#if 0\n\t\tprintf(\"SSTAT1 == 0x%x\\n\", ahc_inb(ahc, SSTAT1));\n\t\tprintf(\"SSTAT0 == 0x%x\\n\", ahc_inb(ahc, SSTAT0));\n\t\tprintf(\", SCSISIGI == 0x%x\\n\", ahc_inb(ahc, SCSISIGI));\n\t\tprintf(\"TRACEPOINT: CCHCNT = %d, SG_COUNT = %d\\n\",\n\t\t       ahc_inb(ahc, CCHCNT), ahc_inb(ahc, SG_COUNT));\n\t\tprintf(\"TRACEPOINT: SCB_TAG = %d\\n\", ahc_inb(ahc, SCB_TAG));\n\t\tprintf(\"TRACEPOINT1: CCHADDR = %d, CCHCNT = %d, SCBPTR = %d\\n\",\n\t\t       ahc_inb(ahc, CCHADDR)\n\t\t    | (ahc_inb(ahc, CCHADDR+1) << 8)\n\t\t    | (ahc_inb(ahc, CCHADDR+2) << 16)\n\t\t    | (ahc_inb(ahc, CCHADDR+3) << 24),\n\t\t       ahc_inb(ahc, CCHCNT)\n\t\t    | (ahc_inb(ahc, CCHCNT+1) << 8)\n\t\t    | (ahc_inb(ahc, CCHCNT+2) << 16),\n\t\t       ahc_inb(ahc, SCBPTR));\n\t\tprintf(\"TRACEPOINT: WAITING_SCBH = %d\\n\", \n\t\t       ahc_inb(ahc, WAITING_SCBH));\n\t\tprintf(\"TRACEPOINT: SCB_TAG = %d\\n\", ahc_inb(ahc, SCB_TAG));\n#endif\n\t\tbreak;\n\t}\n#if NOT_YET\n\t/* XXX Fill these in later */\n\tcase MESG_BUFFER_BUSY:\n\t\tbreak;\n\tcase MSGIN_PHASEMIS:\n\t\tbreak;\n#endif\n\tdefault:\n\t\tprintf(\"ahc_intr: seqint, \"\n\t\t       \"intstat == 0x%x, scsisigi = 0x%x\\n\",\n\t\t       intstat, ahc_inb(ahc, SCSISIGI));\n\t\tbreak;\n\t}\n\t\nunpause:\n\t/*\n\t *  The sequencer is paused immediately on\n\t *  a SEQINT, so we should restart it when\n\t *  we're done.\n\t */\n\tunpause_sequencer(ahc);\n}"
  },
  {
    "function_name": "ahc_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "1591-1655",
    "snippet": "int\nahc_intr(void *arg)\n{\n\tstruct\tahc_softc *ahc;\n\tu_int\tintstat;\n\n\tahc = (struct ahc_softc *)arg; \n\n\tintstat = ahc_inb(ahc, INTSTAT);\n\n\t/*\n\t * Any interrupts to process?\n\t */\n\tif ((intstat & INT_PEND) == 0) {\n\t\tif (ahc->pci_intr_func && ahc->pci_intr_func(ahc)) {\n#ifdef AHC_DEBUG\n\t\t\tprintf(\"%s: bus intr: CCHADDR %x HADDR %x SEQADDR %x\\n\",\n\t\t\t    ahc_name(ahc),\n\t\t\t    ahc_inb(ahc, CCHADDR) |\n\t\t\t    (ahc_inb(ahc, CCHADDR+1) << 8)\n\t\t\t    | (ahc_inb(ahc, CCHADDR+2) << 16)\n\t\t\t    | (ahc_inb(ahc, CCHADDR+3) << 24),\n\t\t\t    ahc_inb(ahc, HADDR) | (ahc_inb(ahc, HADDR+1) << 8)\n\t\t\t    | (ahc_inb(ahc, HADDR+2) << 16)\n\t\t\t    | (ahc_inb(ahc, HADDR+3) << 24),\n\t\t\t    ahc_inb(ahc, SEQADDR0) |\n\t\t\t    (ahc_inb(ahc, SEQADDR1) << 8));\n#endif\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (intstat & CMDCMPLT) {\n\t\tahc_outb(ahc, CLRINT, CLRCMDINT);\n\t\tahc_run_qoutfifo(ahc);\n\t}\n\tif (intstat & BRKADRINT) {\n\t\t/*\n\t\t * We upset the sequencer :-(\n\t\t * Lookup the error message\n\t\t */\n\t\tint i, error, num_errors;\n\n\t\terror = ahc_inb(ahc, ERROR);\n\t\tnum_errors =  sizeof(hard_error)/sizeof(hard_error[0]);\n\t\tfor (i = 0; error != 1 && i < num_errors; i++)\n\t\t\terror >>= 1;\n\t\tpanic(\"%s: brkadrint, %s at seqaddr = 0x%x\\n\",\n\t\t      ahc_name(ahc), hard_error[i].errmesg,\n\t\t      ahc_inb(ahc, SEQADDR0) |\n\t\t      (ahc_inb(ahc, SEQADDR1) << 8));\n\n\t\t/* Tell everyone that this HBA is no longer availible */\n\t\tahc_abort_scbs(ahc, ALL_TARGETS, ALL_CHANNELS,\n\t\t\t       ALL_LUNS, SCB_LIST_NULL, ROLE_UNKNOWN,\n\t\t\t       XS_DRIVER_STUFFUP);\n\t}\n\tif (intstat & SEQINT)\n\t\tahc_handle_seqint(ahc, intstat);\n\n\tif (intstat & SCSIINT)\n\t\tahc_handle_scsiint(ahc, intstat);\n\treturn(1);\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define ALL_CHANNELS '\\0'"
    ],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "ahc_shutdown __P((void *arg));",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC u_int",
      "STATIC struct",
      "ahc_handle_seqint __P((struct ahc_softc *ahc, u_int intstat));",
      "ahc_handle_scsiint __P((struct ahc_softc *ahc, u_int intstat));",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "STATIC u_int",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "STATIC u_int",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "static struct {\n        u_int8_t errno;\n\tchar *errmesg;\n} hard_error[] = {\n\t{ ILLHADDR,\t\"Illegal Host Access\" },\n\t{ ILLSADDR,\t\"Illegal Sequencer Address referrenced\" },\n\t{ ILLOPCODE,\t\"Illegal Opcode in sequencer program\" },\n\t{ SQPARERR,\t\"Sequencer Parity Error\" },\n\t{ DPARERR,\t\"Data-path Parity Error\" },\n\t{ MPARERR,\t\"Scratch or SCB Memory Parity Error\" },\n\t{ PCIERRSTAT,\t\"PCI Error detected\" },\n\t{ CIOPARERR,\t\"CIOBUS Parity Error\" },\n};",
      "static const int num_errors = sizeof(hard_error)/sizeof(hard_error[0]);",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ahc_handle_scsiint",
          "args": [
            "ahc",
            "intstat"
          ],
          "line": 1653
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_handle_scsiint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "2164-2439",
          "snippet": "STATIC void\nahc_handle_scsiint(ahc, intstat)\n\tstruct ahc_softc *ahc;\n\tu_int intstat;\n{\n\tu_int\tscb_index;\n\tu_int\tstatus;\n\tstruct\tscb *scb;\n\tchar\tcur_channel;\n\tchar\tintr_channel;\n\n\tif ((ahc->features & AHC_TWIN) != 0\n\t && ((ahc_inb(ahc, SBLKCTL) & SELBUSB) != 0))\n\t\tcur_channel = 'B';\n\telse\n\t\tcur_channel = 'A';\n\tintr_channel = cur_channel;\n\n\tstatus = ahc_inb(ahc, SSTAT1);\n\tif (status == 0) {\n\t\tif ((ahc->features & AHC_TWIN) != 0) {\n\t\t\t/* Try the other channel */\n\t\t \tahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) ^ SELBUSB);\n\t\t\tstatus = ahc_inb(ahc, SSTAT1);\n\t\t \tahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) ^ SELBUSB);\n\t\t\tintr_channel = (cur_channel == 'A') ? 'B' : 'A';\n\t\t}\n\t\tif (status == 0) {\n\t\t\tprintf(\"%s: Spurious SCSI interrupt\\n\", ahc_name(ahc));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tscb_index = ahc_inb(ahc, SCB_TAG);\n\tif (scb_index < ahc->scb_data->numscbs) {\n\t\tscb = &ahc->scb_data->scbarray[scb_index];\n\t\tif ((scb->flags & SCB_ACTIVE) == 0\n\t\t || (ahc_inb(ahc, SEQ_FLAGS) & IDENTIFY_SEEN) == 0)\n\t\t\tscb = NULL;\n\t} else\n\t\tscb = NULL;\n\n\tif ((status & SCSIRSTI) != 0) {\n\t\tprintf(\"%s: Someone reset channel %c\\n\",\n\t\t\tahc_name(ahc), intr_channel);\n\t\tahc_reset_channel(ahc, intr_channel, /* Initiate Reset */FALSE);\n\t} else if ((status & SCSIPERR) != 0) {\n\t\t/*\n\t\t * Determine the bus phase and queue an appropriate message.\n\t\t * SCSIPERR is latched true as soon as a parity error\n\t\t * occurs.  If the sequencer acked the transfer that\n\t\t * caused the parity error and the currently presented\n\t\t * transfer on the bus has correct parity, SCSIPERR will\n\t\t * be cleared by CLRSCSIPERR.  Use this to determine if\n\t\t * we should look at the last phase the sequencer recorded,\n\t\t * or the current phase presented on the bus.\n\t\t */\n\t\tu_int mesg_out;\n\t\tu_int curphase;\n\t\tu_int errorphase;\n\t\tu_int lastphase;\n\t\tint   i;\n\n\t\tlastphase = ahc_inb(ahc, LASTPHASE);\n\t\tcurphase = ahc_inb(ahc, SCSISIGI) & PHASE_MASK;\n\t\tahc_outb(ahc, CLRSINT1, CLRSCSIPERR);\n\t\t/*\n\t\t * For all phases save DATA, the sequencer won't\n\t\t * automatically ack a byte that has a parity error\n\t\t * in it.  So the only way that the current phase\n\t\t * could be 'data-in' is if the parity error is for\n\t\t * an already acked byte in the data phase.  During\n\t\t * synchronous data-in transfers, we may actually\n\t\t * ack bytes before latching the current phase in\n\t\t * LASTPHASE, leading to the discrepancy between\n\t\t * curphase and lastphase.\n\t\t */\n\t\tif ((ahc_inb(ahc, SSTAT1) & SCSIPERR) != 0\n\t\t || curphase == P_DATAIN)\n\t\t\terrorphase = curphase;\n\t\telse\n\t\t\terrorphase = lastphase;\n\n\t\tfor (i = 0; i < num_phases; i++) {\n\t\t\tif (errorphase == phase_table[i].phase)\n\t\t\t\tbreak;\n\t\t}\n\t\tmesg_out = phase_table[i].mesg_out;\n\t\tif (scb != NULL)\n\t\t\tsc_print_addr(scb->xs->sc_link);\n\t\telse\n\t\t\tprintf(\"%s:%c:%d: \", ahc_name(ahc),\n\t\t\t       intr_channel,\n\t\t\t       TCL_TARGET(ahc_inb(ahc, SAVED_TCL)));\n\t\t\n\t\tprintf(\"parity error detected %s. \"\n\t\t       \"SEQADDR(0x%x) SCSIRATE(0x%x)\\n\",\n\t\t       phase_table[i].phasemsg,\n\t\t       ahc_inb(ahc, SEQADDR0) | (ahc_inb(ahc, SEQADDR1) << 8),\n\t\t       ahc_inb(ahc, SCSIRATE));\n\n\t\t/*\n\t\t * We've set the hardware to assert ATN if we   \n\t\t * get a parity error on \"in\" phases, so all we  \n\t\t * need to do is stuff the message buffer with\n\t\t * the appropriate message.  \"In\" phases have set\n\t\t * mesg_out to something other than MSG_NOP.\n\t\t */\n\t\tif (mesg_out != MSG_NOOP) {\n\t\t\tif (ahc->msg_type != MSG_TYPE_NONE)\n\t\t\t\tahc->send_msg_perror = TRUE;\n\t\t\telse\n\t\t\t\tahc_outb(ahc, MSG_OUT, mesg_out);\n\t\t}\n\t\tahc_outb(ahc, CLRINT, CLRSCSIINT);\n\t\tunpause_sequencer(ahc);\n\t} else if ((status & BUSFREE) != 0\n\t\t&& (ahc_inb(ahc, SIMODE1) & ENBUSFREE) != 0) {\n\t\t/*\n\t\t * First look at what phase we were last in.\n\t\t * If its message out, chances are pretty good\n\t\t * that the busfree was in response to one of\n\t\t * our abort requests.\n\t\t */\n\t\tu_int lastphase = ahc_inb(ahc, LASTPHASE);\n\t\tu_int saved_tcl = ahc_inb(ahc, SAVED_TCL);\n\t\tu_int target = TCL_TARGET(saved_tcl);\n\t\tu_int initiator_role_id = TCL_SCSI_ID(ahc, saved_tcl);\n\t\tchar channel = TCL_CHANNEL(ahc, saved_tcl);\n\t\tint printerror = 1;\n\n\t\tahc_outb(ahc, SCSISEQ,\n\t\t\t ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP));\n\t\tif (lastphase == P_MESGOUT) {\n\t\t\tu_int message;\n\t\t\tu_int tag;\n\n\t\t\tmessage = ahc->msgout_buf[ahc->msgout_index - 1];\n\t\t\ttag = SCB_LIST_NULL;\n\t\t\tswitch (message) {\n\t\t\tcase MSG_ABORT_TAG:\n\t\t\t\ttag = scb->hscb->tag;\n\t\t\t\t/* FALLTRHOUGH */\n\t\t\tcase MSG_ABORT:\n\t\t\t\tsc_print_addr(scb->xs->sc_link);\n\t\t\t\tprintf(\"SCB %d - Abort %s Completed.\\n\",\n\t\t\t\t       scb->hscb->tag, tag == SCB_LIST_NULL ?\n\t\t\t\t       \"\" : \"Tag\");\n\t\t\t\tahc_abort_scbs(ahc, target, channel,\n\t\t\t\t\t       TCL_LUN(saved_tcl), tag,\n\t\t\t\t\t       ROLE_INITIATOR,\n\t\t\t\t\t       XS_DRIVER_STUFFUP);\n\t\t\t\tprinterror = 0;\n\t\t\t\tbreak;\n\t\t\tcase MSG_BUS_DEV_RESET:\n\t\t\t{\n\t\t\t\tstruct ahc_devinfo devinfo;\n\n\t\t\t\tif (scb != NULL &&\n\t\t\t\t    (scb->xs->flags & SCSI_RESET)\n\t\t\t\t && ahc_match_scb(scb, target, channel,\n\t\t\t\t\t\t  TCL_LUN(saved_tcl),\n\t\t\t\t\t\t  SCB_LIST_NULL,\n\t\t\t\t\t\t  ROLE_INITIATOR)) {\n\t\t\t\t\tahcsetccbstatus(scb->xs, XS_NOERROR);\n\t\t\t\t}\n\t\t\t\tahc_compile_devinfo(&devinfo,\n\t\t\t\t\t\t    initiator_role_id,\n\t\t\t\t\t\t    target,\n\t\t\t\t\t\t    TCL_LUN(saved_tcl),\n\t\t\t\t\t\t    channel,\n\t\t\t\t\t\t    ROLE_INITIATOR);\n\t\t\t\tahc_handle_devreset(ahc, &devinfo,\n\t\t\t\t\t\t    XS_RESET,\n\t\t\t\t\t\t    \"Bus Device Reset\",\n\t\t\t\t\t\t    /*verbose_level*/0);\n\t\t\t\tprinterror = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (printerror != 0) {\n\t\t\tint i;\n\n\t\t\tif (scb != NULL) {\n\t\t\t\tu_int tag;\n\n\t\t\t\tif ((scb->hscb->control & TAG_ENB) != 0)\n\t\t\t\t\ttag = scb->hscb->tag;\n\t\t\t\telse\n\t\t\t\t\ttag = SCB_LIST_NULL;\n\t\t\t\tahc_abort_scbs(ahc, target, channel,\n\t\t\t\t\t       SCB_LUN(scb), tag,\n\t\t\t\t\t       ROLE_INITIATOR,\n\t\t\t\t\t       XS_DRIVER_STUFFUP);\n\t\t\t\tsc_print_addr(scb->xs->sc_link);\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * We had not fully identified this connection,\n\t\t\t\t * so we cannot abort anything.\n\t\t\t\t */\n\t\t\t\tprintf(\"%s: \", ahc_name(ahc));\n\t\t\t}\n\t\t\tfor (i = 0; i < num_phases; i++) {\n\t\t\t\tif (lastphase == phase_table[i].phase)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tprintf(\"Unexpected busfree %s\\n\"\n\t\t\t       \"SEQADDR == 0x%x\\n\",\n\t\t\t       phase_table[i].phasemsg, ahc_inb(ahc, SEQADDR0)\n\t\t\t\t| (ahc_inb(ahc, SEQADDR1) << 8));\n\t\t}\n\t\tahc_clear_msg_state(ahc);\n\t\tahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENBUSFREE);\n\t\tahc_outb(ahc, CLRSINT1, CLRBUSFREE|CLRSCSIPERR);\n\t\tahc_outb(ahc, CLRINT, CLRSCSIINT);\n\t\trestart_sequencer(ahc);\n\t} else if ((status & SELTO) != 0) {\n\t\tu_int scbptr;\n\n\t\tscbptr = ahc_inb(ahc, WAITING_SCBH);\n\t\tahc_outb(ahc, SCBPTR, scbptr);\n\t\tscb_index = ahc_inb(ahc, SCB_TAG);\n\n\t\tif (scb_index < ahc->scb_data->numscbs) {\n\t\t\tscb = &ahc->scb_data->scbarray[scb_index];\n\t\t\tif ((scb->flags & SCB_ACTIVE) == 0)\n\t\t\t\tscb = NULL;\n\t\t} else\n\t\t\tscb = NULL;\n\n\t\tif (scb == NULL) {\n\t\t\tprintf(\"%s: ahc_intr - referenced scb not \"\n\t\t\t       \"valid during SELTO scb(%d, %d)\\n\",\n\t\t\t       ahc_name(ahc), scbptr, scb_index);\n\t\t} else {\n\t\t\tu_int tag;\n\n\t\t\ttag = SCB_LIST_NULL;\n\t\t\tif ((scb->hscb->control & MSG_SIMPLE_Q_TAG) != 0)\n\t\t\t\ttag = scb->hscb->tag;\n\n\t\t\tahc_abort_scbs(ahc, SCB_TARGET(scb), SCB_CHANNEL(scb),\n\t\t\t\t       SCB_LUN(scb), tag,\n\t\t\t\t       ROLE_INITIATOR, XS_SELTIMEOUT);\n\t\t}\n\t\t/* Stop the selection */\n\t\tahc_outb(ahc, SCSISEQ, 0);\n\n\t\t/* No more pending messages */\n\t\tahc_clear_msg_state(ahc);\n\n\t\t/*\n\t\t * Although the driver does not care about the\n\t\t * 'Selection in Progress' status bit, the busy\n\t\t * LED does.  SELINGO is only cleared by a sucessful\n\t\t * selection, so we must manually clear it to ensure\n\t\t * the LED turns off just incase no future successful\n\t\t * selections occur (e.g. no devices on the bus).\n\t\t */\n\t\tahc_outb(ahc, CLRSINT0, CLRSELINGO);\n\n\t\t/* Clear interrupt state */\n\t\tahc_outb(ahc, CLRSINT1, CLRSELTIMEO|CLRBUSFREE|CLRSCSIPERR);\n\t\tahc_outb(ahc, CLRINT, CLRSCSIINT);\n\t\trestart_sequencer(ahc);\n\t} else {\n\t\tsc_print_addr(scb->xs->sc_link);\n\t\tprintf(\"Unknown SCSIINT. Status = 0x%x\\n\", status);\n\t\tahc_outb(ahc, CLRSINT1, status);\n\t\tahc_outb(ahc, CLRINT, CLRSCSIINT);\n\t\tunpause_sequencer(ahc);\n\t}\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
            "STATIC void",
            "ahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "ahc_handle_seqint __P((struct ahc_softc *ahc, u_int intstat));",
            "STATIC void",
            "ahc_handle_scsiint __P((struct ahc_softc *ahc, u_int intstat));",
            "STATIC void",
            "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
            "STATIC void",
            "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC int",
            "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));",
            "STATIC int",
            "STATIC int",
            "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_handle_devreset __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct ahc_devinfo *devinfo,\n\t\t\t\t\t int status, char *message,\n\t\t\t\t\t int verbose_level));",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "ahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));",
            "STATIC int",
            "STATIC u_int",
            "ahc_rem_scb_from_disc_list __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tu_int prev, u_int scbptr));",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
            "STATIC void",
            "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_calc_residual __P((struct scb *scb));",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
            "STATIC void",
            "static __inline void unpause_sequencer",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "static __inline void ahcsetccbstatus",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "static struct {\n        u_int8_t phase;\n        u_int8_t mesg_out; /* Message response to parity errors */\n\tchar *phasemsg;\n} phase_table[] = {\n\t{ P_DATAOUT,\tMSG_NOOP,\t\t\"in Data-out phase\"\t},\n\t{ P_DATAIN,\tMSG_INITIATOR_DET_ERR,\t\"in Data-in phase\"\t},\n\t{ P_COMMAND,\tMSG_NOOP,\t\t\"in Command phase\"\t},\n\t{ P_MESGOUT,\tMSG_NOOP,\t\t\"in Message-out phase\"\t},\n\t{ P_STATUS,\tMSG_INITIATOR_DET_ERR,\t\"in Status phase\"\t},\n\t{ P_MESGIN,\tMSG_PARITY_ERROR,\t\"in Message-in phase\"\t},\n\t{ P_BUSFREE,\tMSG_NOOP,\t\t\"while idle\"\t\t},\n\t{ 0,\t\tMSG_NOOP,\t\t\"in unknown phase\"\t}\n};",
            "static const int num_phases = (sizeof(phase_table)/sizeof(phase_table[0])) - 1;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *xs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nSTATIC void;\nahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nahc_handle_seqint __P((struct ahc_softc *ahc, u_int intstat));\nSTATIC void;\nahc_handle_scsiint __P((struct ahc_softc *ahc, u_int intstat));\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));\nSTATIC int;\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_devreset __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct ahc_devinfo *devinfo,\n\t\t\t\t\t int status, char *message,\n\t\t\t\t\t int verbose_level));\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));\nSTATIC int;\nSTATIC u_int;\nahc_rem_scb_from_disc_list __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tu_int prev, u_int scbptr));\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nSTATIC void;\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_calc_residual __P((struct scb *scb));\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nSTATIC void;\nstatic __inline void unpause_sequencer;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nstatic __inline void ahcsetccbstatus;\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nstatic struct {\n        u_int8_t phase;\n        u_int8_t mesg_out; /* Message response to parity errors */\n\tchar *phasemsg;\n} phase_table[] = {\n\t{ P_DATAOUT,\tMSG_NOOP,\t\t\"in Data-out phase\"\t},\n\t{ P_DATAIN,\tMSG_INITIATOR_DET_ERR,\t\"in Data-in phase\"\t},\n\t{ P_COMMAND,\tMSG_NOOP,\t\t\"in Command phase\"\t},\n\t{ P_MESGOUT,\tMSG_NOOP,\t\t\"in Message-out phase\"\t},\n\t{ P_STATUS,\tMSG_INITIATOR_DET_ERR,\t\"in Status phase\"\t},\n\t{ P_MESGIN,\tMSG_PARITY_ERROR,\t\"in Message-in phase\"\t},\n\t{ P_BUSFREE,\tMSG_NOOP,\t\t\"while idle\"\t\t},\n\t{ 0,\t\tMSG_NOOP,\t\t\"in unknown phase\"\t}\n};\nstatic const int num_phases = (sizeof(phase_table)/sizeof(phase_table[0])) - 1;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n\nSTATIC void\nahc_handle_scsiint(ahc, intstat)\n\tstruct ahc_softc *ahc;\n\tu_int intstat;\n{\n\tu_int\tscb_index;\n\tu_int\tstatus;\n\tstruct\tscb *scb;\n\tchar\tcur_channel;\n\tchar\tintr_channel;\n\n\tif ((ahc->features & AHC_TWIN) != 0\n\t && ((ahc_inb(ahc, SBLKCTL) & SELBUSB) != 0))\n\t\tcur_channel = 'B';\n\telse\n\t\tcur_channel = 'A';\n\tintr_channel = cur_channel;\n\n\tstatus = ahc_inb(ahc, SSTAT1);\n\tif (status == 0) {\n\t\tif ((ahc->features & AHC_TWIN) != 0) {\n\t\t\t/* Try the other channel */\n\t\t \tahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) ^ SELBUSB);\n\t\t\tstatus = ahc_inb(ahc, SSTAT1);\n\t\t \tahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) ^ SELBUSB);\n\t\t\tintr_channel = (cur_channel == 'A') ? 'B' : 'A';\n\t\t}\n\t\tif (status == 0) {\n\t\t\tprintf(\"%s: Spurious SCSI interrupt\\n\", ahc_name(ahc));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tscb_index = ahc_inb(ahc, SCB_TAG);\n\tif (scb_index < ahc->scb_data->numscbs) {\n\t\tscb = &ahc->scb_data->scbarray[scb_index];\n\t\tif ((scb->flags & SCB_ACTIVE) == 0\n\t\t || (ahc_inb(ahc, SEQ_FLAGS) & IDENTIFY_SEEN) == 0)\n\t\t\tscb = NULL;\n\t} else\n\t\tscb = NULL;\n\n\tif ((status & SCSIRSTI) != 0) {\n\t\tprintf(\"%s: Someone reset channel %c\\n\",\n\t\t\tahc_name(ahc), intr_channel);\n\t\tahc_reset_channel(ahc, intr_channel, /* Initiate Reset */FALSE);\n\t} else if ((status & SCSIPERR) != 0) {\n\t\t/*\n\t\t * Determine the bus phase and queue an appropriate message.\n\t\t * SCSIPERR is latched true as soon as a parity error\n\t\t * occurs.  If the sequencer acked the transfer that\n\t\t * caused the parity error and the currently presented\n\t\t * transfer on the bus has correct parity, SCSIPERR will\n\t\t * be cleared by CLRSCSIPERR.  Use this to determine if\n\t\t * we should look at the last phase the sequencer recorded,\n\t\t * or the current phase presented on the bus.\n\t\t */\n\t\tu_int mesg_out;\n\t\tu_int curphase;\n\t\tu_int errorphase;\n\t\tu_int lastphase;\n\t\tint   i;\n\n\t\tlastphase = ahc_inb(ahc, LASTPHASE);\n\t\tcurphase = ahc_inb(ahc, SCSISIGI) & PHASE_MASK;\n\t\tahc_outb(ahc, CLRSINT1, CLRSCSIPERR);\n\t\t/*\n\t\t * For all phases save DATA, the sequencer won't\n\t\t * automatically ack a byte that has a parity error\n\t\t * in it.  So the only way that the current phase\n\t\t * could be 'data-in' is if the parity error is for\n\t\t * an already acked byte in the data phase.  During\n\t\t * synchronous data-in transfers, we may actually\n\t\t * ack bytes before latching the current phase in\n\t\t * LASTPHASE, leading to the discrepancy between\n\t\t * curphase and lastphase.\n\t\t */\n\t\tif ((ahc_inb(ahc, SSTAT1) & SCSIPERR) != 0\n\t\t || curphase == P_DATAIN)\n\t\t\terrorphase = curphase;\n\t\telse\n\t\t\terrorphase = lastphase;\n\n\t\tfor (i = 0; i < num_phases; i++) {\n\t\t\tif (errorphase == phase_table[i].phase)\n\t\t\t\tbreak;\n\t\t}\n\t\tmesg_out = phase_table[i].mesg_out;\n\t\tif (scb != NULL)\n\t\t\tsc_print_addr(scb->xs->sc_link);\n\t\telse\n\t\t\tprintf(\"%s:%c:%d: \", ahc_name(ahc),\n\t\t\t       intr_channel,\n\t\t\t       TCL_TARGET(ahc_inb(ahc, SAVED_TCL)));\n\t\t\n\t\tprintf(\"parity error detected %s. \"\n\t\t       \"SEQADDR(0x%x) SCSIRATE(0x%x)\\n\",\n\t\t       phase_table[i].phasemsg,\n\t\t       ahc_inb(ahc, SEQADDR0) | (ahc_inb(ahc, SEQADDR1) << 8),\n\t\t       ahc_inb(ahc, SCSIRATE));\n\n\t\t/*\n\t\t * We've set the hardware to assert ATN if we   \n\t\t * get a parity error on \"in\" phases, so all we  \n\t\t * need to do is stuff the message buffer with\n\t\t * the appropriate message.  \"In\" phases have set\n\t\t * mesg_out to something other than MSG_NOP.\n\t\t */\n\t\tif (mesg_out != MSG_NOOP) {\n\t\t\tif (ahc->msg_type != MSG_TYPE_NONE)\n\t\t\t\tahc->send_msg_perror = TRUE;\n\t\t\telse\n\t\t\t\tahc_outb(ahc, MSG_OUT, mesg_out);\n\t\t}\n\t\tahc_outb(ahc, CLRINT, CLRSCSIINT);\n\t\tunpause_sequencer(ahc);\n\t} else if ((status & BUSFREE) != 0\n\t\t&& (ahc_inb(ahc, SIMODE1) & ENBUSFREE) != 0) {\n\t\t/*\n\t\t * First look at what phase we were last in.\n\t\t * If its message out, chances are pretty good\n\t\t * that the busfree was in response to one of\n\t\t * our abort requests.\n\t\t */\n\t\tu_int lastphase = ahc_inb(ahc, LASTPHASE);\n\t\tu_int saved_tcl = ahc_inb(ahc, SAVED_TCL);\n\t\tu_int target = TCL_TARGET(saved_tcl);\n\t\tu_int initiator_role_id = TCL_SCSI_ID(ahc, saved_tcl);\n\t\tchar channel = TCL_CHANNEL(ahc, saved_tcl);\n\t\tint printerror = 1;\n\n\t\tahc_outb(ahc, SCSISEQ,\n\t\t\t ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP));\n\t\tif (lastphase == P_MESGOUT) {\n\t\t\tu_int message;\n\t\t\tu_int tag;\n\n\t\t\tmessage = ahc->msgout_buf[ahc->msgout_index - 1];\n\t\t\ttag = SCB_LIST_NULL;\n\t\t\tswitch (message) {\n\t\t\tcase MSG_ABORT_TAG:\n\t\t\t\ttag = scb->hscb->tag;\n\t\t\t\t/* FALLTRHOUGH */\n\t\t\tcase MSG_ABORT:\n\t\t\t\tsc_print_addr(scb->xs->sc_link);\n\t\t\t\tprintf(\"SCB %d - Abort %s Completed.\\n\",\n\t\t\t\t       scb->hscb->tag, tag == SCB_LIST_NULL ?\n\t\t\t\t       \"\" : \"Tag\");\n\t\t\t\tahc_abort_scbs(ahc, target, channel,\n\t\t\t\t\t       TCL_LUN(saved_tcl), tag,\n\t\t\t\t\t       ROLE_INITIATOR,\n\t\t\t\t\t       XS_DRIVER_STUFFUP);\n\t\t\t\tprinterror = 0;\n\t\t\t\tbreak;\n\t\t\tcase MSG_BUS_DEV_RESET:\n\t\t\t{\n\t\t\t\tstruct ahc_devinfo devinfo;\n\n\t\t\t\tif (scb != NULL &&\n\t\t\t\t    (scb->xs->flags & SCSI_RESET)\n\t\t\t\t && ahc_match_scb(scb, target, channel,\n\t\t\t\t\t\t  TCL_LUN(saved_tcl),\n\t\t\t\t\t\t  SCB_LIST_NULL,\n\t\t\t\t\t\t  ROLE_INITIATOR)) {\n\t\t\t\t\tahcsetccbstatus(scb->xs, XS_NOERROR);\n\t\t\t\t}\n\t\t\t\tahc_compile_devinfo(&devinfo,\n\t\t\t\t\t\t    initiator_role_id,\n\t\t\t\t\t\t    target,\n\t\t\t\t\t\t    TCL_LUN(saved_tcl),\n\t\t\t\t\t\t    channel,\n\t\t\t\t\t\t    ROLE_INITIATOR);\n\t\t\t\tahc_handle_devreset(ahc, &devinfo,\n\t\t\t\t\t\t    XS_RESET,\n\t\t\t\t\t\t    \"Bus Device Reset\",\n\t\t\t\t\t\t    /*verbose_level*/0);\n\t\t\t\tprinterror = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (printerror != 0) {\n\t\t\tint i;\n\n\t\t\tif (scb != NULL) {\n\t\t\t\tu_int tag;\n\n\t\t\t\tif ((scb->hscb->control & TAG_ENB) != 0)\n\t\t\t\t\ttag = scb->hscb->tag;\n\t\t\t\telse\n\t\t\t\t\ttag = SCB_LIST_NULL;\n\t\t\t\tahc_abort_scbs(ahc, target, channel,\n\t\t\t\t\t       SCB_LUN(scb), tag,\n\t\t\t\t\t       ROLE_INITIATOR,\n\t\t\t\t\t       XS_DRIVER_STUFFUP);\n\t\t\t\tsc_print_addr(scb->xs->sc_link);\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * We had not fully identified this connection,\n\t\t\t\t * so we cannot abort anything.\n\t\t\t\t */\n\t\t\t\tprintf(\"%s: \", ahc_name(ahc));\n\t\t\t}\n\t\t\tfor (i = 0; i < num_phases; i++) {\n\t\t\t\tif (lastphase == phase_table[i].phase)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tprintf(\"Unexpected busfree %s\\n\"\n\t\t\t       \"SEQADDR == 0x%x\\n\",\n\t\t\t       phase_table[i].phasemsg, ahc_inb(ahc, SEQADDR0)\n\t\t\t\t| (ahc_inb(ahc, SEQADDR1) << 8));\n\t\t}\n\t\tahc_clear_msg_state(ahc);\n\t\tahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENBUSFREE);\n\t\tahc_outb(ahc, CLRSINT1, CLRBUSFREE|CLRSCSIPERR);\n\t\tahc_outb(ahc, CLRINT, CLRSCSIINT);\n\t\trestart_sequencer(ahc);\n\t} else if ((status & SELTO) != 0) {\n\t\tu_int scbptr;\n\n\t\tscbptr = ahc_inb(ahc, WAITING_SCBH);\n\t\tahc_outb(ahc, SCBPTR, scbptr);\n\t\tscb_index = ahc_inb(ahc, SCB_TAG);\n\n\t\tif (scb_index < ahc->scb_data->numscbs) {\n\t\t\tscb = &ahc->scb_data->scbarray[scb_index];\n\t\t\tif ((scb->flags & SCB_ACTIVE) == 0)\n\t\t\t\tscb = NULL;\n\t\t} else\n\t\t\tscb = NULL;\n\n\t\tif (scb == NULL) {\n\t\t\tprintf(\"%s: ahc_intr - referenced scb not \"\n\t\t\t       \"valid during SELTO scb(%d, %d)\\n\",\n\t\t\t       ahc_name(ahc), scbptr, scb_index);\n\t\t} else {\n\t\t\tu_int tag;\n\n\t\t\ttag = SCB_LIST_NULL;\n\t\t\tif ((scb->hscb->control & MSG_SIMPLE_Q_TAG) != 0)\n\t\t\t\ttag = scb->hscb->tag;\n\n\t\t\tahc_abort_scbs(ahc, SCB_TARGET(scb), SCB_CHANNEL(scb),\n\t\t\t\t       SCB_LUN(scb), tag,\n\t\t\t\t       ROLE_INITIATOR, XS_SELTIMEOUT);\n\t\t}\n\t\t/* Stop the selection */\n\t\tahc_outb(ahc, SCSISEQ, 0);\n\n\t\t/* No more pending messages */\n\t\tahc_clear_msg_state(ahc);\n\n\t\t/*\n\t\t * Although the driver does not care about the\n\t\t * 'Selection in Progress' status bit, the busy\n\t\t * LED does.  SELINGO is only cleared by a sucessful\n\t\t * selection, so we must manually clear it to ensure\n\t\t * the LED turns off just incase no future successful\n\t\t * selections occur (e.g. no devices on the bus).\n\t\t */\n\t\tahc_outb(ahc, CLRSINT0, CLRSELINGO);\n\n\t\t/* Clear interrupt state */\n\t\tahc_outb(ahc, CLRSINT1, CLRSELTIMEO|CLRBUSFREE|CLRSCSIPERR);\n\t\tahc_outb(ahc, CLRINT, CLRSCSIINT);\n\t\trestart_sequencer(ahc);\n\t} else {\n\t\tsc_print_addr(scb->xs->sc_link);\n\t\tprintf(\"Unknown SCSIINT. Status = 0x%x\\n\", status);\n\t\tahc_outb(ahc, CLRSINT1, status);\n\t\tahc_outb(ahc, CLRINT, CLRSCSIINT);\n\t\tunpause_sequencer(ahc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_handle_seqint",
          "args": [
            "ahc",
            "intstat"
          ],
          "line": 1650
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_handle_seqint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "1703-2162",
          "snippet": "STATIC void\nahc_handle_seqint(ahc, intstat)\n\tstruct ahc_softc *ahc;\n\tu_int intstat;\n{\n\tstruct scb *scb;\n\tstruct ahc_devinfo devinfo;\n\t\n\tahc_fetch_devinfo(ahc, &devinfo);\n\n\t/*\n\t * Clear the upper byte that holds SEQINT status\n\t * codes and clear the SEQINT bit. We will unpause\n\t * the sequencer, if appropriate, after servicing\n\t * the request.\n\t */\n\tahc_outb(ahc, CLRINT, CLRSEQINT);\n\tswitch (intstat & SEQINT_MASK) {\n\tcase NO_MATCH:\n\t{\n\t\t/* Ensure we don't leave the selection hardware on */\n\t\tahc_outb(ahc, SCSISEQ,\n\t\t\t ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP));\n\n\t\tprintf(\"%s:%c:%d: no active SCB for reconnecting \"\n\t\t       \"target - issuing BUS DEVICE RESET\\n\",\n\t\t       ahc_name(ahc), devinfo.channel, devinfo.target);\n\t\tprintf(\"SAVED_TCL == 0x%x, ARG_1 == 0x%x, SEQ_FLAGS == 0x%x\\n\",\n\t\t       ahc_inb(ahc, SAVED_TCL), ahc_inb(ahc, ARG_1),\n\t\t       ahc_inb(ahc, SEQ_FLAGS));\n\t\tahc->msgout_buf[0] = MSG_BUS_DEV_RESET;\n\t\tahc->msgout_len = 1;\n\t\tahc->msgout_index = 0;\n\t\tahc->msg_type = MSG_TYPE_INITIATOR_MSGOUT;\n\t\tahc_outb(ahc, MSG_OUT, HOST_MSG);\n\t\tahc_outb(ahc, SCSISIGO, ahc_inb(ahc, LASTPHASE) | ATNO);\n\t\tbreak;\n\t}\n\tcase UPDATE_TMSG_REQ:\n\t\tahc_outb(ahc, TARGET_MSG_REQUEST, ahc->targ_msg_req & 0xFF);\n\t\tahc_outb(ahc, TARGET_MSG_REQUEST + 1,\n\t\t\t (ahc->targ_msg_req >> 8) & 0xFF);\n\t\tahc_outb(ahc, HS_MAILBOX, 0);\n\t\tbreak;\n\tcase SEND_REJECT: \n\t{\n\t\tu_int rejbyte = ahc_inb(ahc, ACCUM);\n\t\tprintf(\"%s:%c:%d: Warning - unknown message received from \"\n\t\t       \"target (0x%x).  Rejecting\\n\", \n\t\t       ahc_name(ahc), devinfo.channel, devinfo.target, rejbyte);\n\t\tbreak; \n\t}\n\tcase NO_IDENT: \n\t{\n\t\t/*\n\t\t * The reconnecting target either did not send an identify\n\t\t * message, or did, but we didn't find and SCB to match and\n\t\t * before it could respond to our ATN/abort, it hit a dataphase.\n\t\t * The only safe thing to do is to blow it away with a bus\n\t\t * reset.\n\t\t */\n\t\tint found;\n\n\t\tprintf(\"%s:%c:%d: Target did not send an IDENTIFY message. \"\n\t\t       \"LASTPHASE = 0x%x, SAVED_TCL == 0x%x\\n\",\n\t\t       ahc_name(ahc), devinfo.channel, devinfo.target,\n\t\t       ahc_inb(ahc, LASTPHASE), ahc_inb(ahc, SAVED_TCL));\n\t\tfound = ahc_reset_channel(ahc, devinfo.channel, \n\t\t\t\t\t  /*initiate reset*/TRUE);\n\t\tprintf(\"%s: Issued Channel %c Bus Reset. \"\n\t\t       \"%d SCBs aborted\\n\", ahc_name(ahc), devinfo.channel,\n\t\t       found);\n\t\treturn;\n\t}\n\tcase BAD_PHASE:\n\t{\n\t\tu_int lastphase;\n\n\t\tlastphase = ahc_inb(ahc, LASTPHASE);\n\t\tif (lastphase == P_BUSFREE) {\n\t\t\tprintf(\"%s:%c:%d: Missed busfree.  Curphase = 0x%x\\n\",\n\t\t\t       ahc_name(ahc), devinfo.channel, devinfo.target,\n\t\t\t       ahc_inb(ahc, SCSISIGI));\n\t\t\trestart_sequencer(ahc);\n\t\t\treturn;\n\t\t} else {\n\t\t\tprintf(\"%s:%c:%d: unknown scsi bus phase %x.  \"\n\t\t\t       \"Attempting to continue\\n\",\n\t\t\t       ahc_name(ahc), devinfo.channel, devinfo.target,\n\t\t\t       ahc_inb(ahc, SCSISIGI));\n\t\t}\n\t\tbreak; \n\t}\n\tcase BAD_STATUS:\n\t{\n\t\tu_int  scb_index;\n\t\tstruct hardware_scb *hscb;\n\t\tstruct scsi_xfer *xs;\n\t\t/*\n\t\t * The sequencer will notify us when a command\n\t\t * has an error that would be of interest to\n\t\t * the kernel.  This allows us to leave the sequencer\n\t\t * running in the common case of command completes\n\t\t * without error.  The sequencer will already have\n\t\t * dma'd the SCB back up to us, so we can reference\n\t\t * the in kernel copy directly.\n\t\t */\n\t\tscb_index = ahc_inb(ahc, SCB_TAG);\n\t\tscb = &ahc->scb_data->scbarray[scb_index];\n\n\t\t/*\n\t\t * Set the default return value to 0 (don't\n\t\t * send sense).  The sense code will change\n\t\t * this if needed.\n\t\t */\n\t\tahc_outb(ahc, RETURN_1, 0);\n\t\tif (!(scb_index < ahc->scb_data->numscbs\n\t\t   && (scb->flags & SCB_ACTIVE) != 0)) {\n\t\t\tprintf(\"%s:%c:%d: ahc_intr - referenced scb \"\n\t\t\t       \"not valid during seqint 0x%x scb(%d)\\n\",\n\t\t\t       ahc_name(ahc), devinfo.channel,\n\t\t\t       devinfo.target, intstat, scb_index);\n\t\t\tgoto unpause;\n\t\t}\n\n\t\thscb = scb->hscb; \n\t\txs = scb->xs;\n\n\t\t/* Don't want to clobber the original sense code */\n\t\tif ((scb->flags & SCB_SENSE) != 0) {\n\t\t\t/*\n\t\t\t * Clear the SCB_SENSE Flag and have\n\t\t\t * the sequencer do a normal command\n\t\t\t * complete.\n\t\t\t */\n\t\t\tscb->flags &= ~SCB_SENSE;\n\t\t\tahcsetccbstatus(xs, XS_DRIVER_STUFFUP);\n\t\t\tbreak;\n\t\t}\n\t\t/* Freeze the queue unit the client sees the error. */\n\t\tahc_freeze_devq(ahc, xs->sc_link);\n\t\tahc_freeze_ccb(scb);\n\t\txs->status = hscb->status;\n\t\tswitch (hscb->status) {\n\t\tcase SCSI_OK:\n\t\t\tprintf(\"%s: Interrupted for staus of 0???\\n\",\n\t\t\t       ahc_name(ahc));\n\t\t\tbreak;\n\t\tcase SCSI_CHECK:\n#ifdef AHC_DEBUG\n\t\t\tif (ahc_debug & AHC_SHOWSENSE) {\n\t\t\t\tsc_print_addr(scb->xs->sc_link);\n\t\t\t\tprintf(\"SCB %d: requests Check Status\\n\",\n\t\t\t\t       scb->hscb->tag);\n\t\t\t}\n#endif\n\t\t\t\t\n\t\t\tif (xs->error == XS_NOERROR &&\n\t\t\t    !(scb->flags & SCB_SENSE)) {\n\t\t\t\tstruct ahc_dma_seg *sg;\n\t\t\t\tstruct scsi_sense *sc;\n\t\t\t\tstruct ahc_initiator_tinfo *tinfo;\n\t\t\t\tstruct tmode_tstate *tstate;\n\n\t\t\t\tsg = scb->sg_list;\n\t\t\t\tsc = (struct scsi_sense *)(&hscb->cmdstore); \n\t\t\t\t/*\n\t\t\t\t * Save off the residual if there is one.\n\t\t\t\t */\n\t\t\t\tif (hscb->residual_SG_count != 0)\n\t\t\t\t\tahc_calc_residual(scb);\n\t\t\t\telse\n\t\t\t\t\txs->resid = 0;\n\n#ifdef AHC_DEBUG\n\t\t\t\tif (ahc_debug & AHC_SHOWSENSE) {\n\t\t\t\t\tsc_print_addr(scb->xs->sc_link);\n\t\t\t\t\tprintf(\"Sending Sense\\n\");\n\t\t\t\t}\n#endif\n\t\t\t\tsg->addr = ahc->scb_data->sense_busaddr +\n\t\t\t\t\t(hscb->tag*sizeof(struct scsi_sense_data));\n\t\t\t\t\n\t\t\t\tsg->len = sizeof(struct scsi_sense_data);\n\n\t\t\t\tsc->opcode = REQUEST_SENSE;\n\t\t\t\tsc->byte2 =  SCB_LUN(scb) << 5;\n\t\t\t\tsc->unused[0] = 0;\n\t\t\t\tsc->unused[1] = 0;\n\t\t\t\tsc->length = sg->len;\n\t\t\t\tsc->control = 0;\n\n\t\t\t\t/*\n\t\t\t\t * Would be nice to preserve DISCENB here,\n\t\t\t\t * but due to the way we page SCBs, we can't.\n\t\t\t\t */\n\t\t\t\thscb->control = 0;\n\n\t\t\t\t/*\n\t\t\t\t * This request sense could be because the\n\t\t\t\t * the device lost power or in some other\n\t\t\t\t * way has lost our transfer negotiations.\n\t\t\t\t * Renegotiate if appropriate.\n\t\t\t\t */\n\t\t\t\tahc_calc_residual(scb);\n#ifdef AHC_DEBUG\n\t\t\t\tif (ahc_debug & AHC_SHOWSENSE) {\n\t\t\t\t\tsc_print_addr(xs->sc_link);\n\t\t\t\t\tprintf(\"Sense: datalen %d resid %d\"\n\t\t\t\t\t       \"chan %d id %d targ %d\\n\",\n\t\t\t\t\t       xs->datalen, xs->resid,\n\t\t\t\t\t       devinfo.channel,\n\t\t\t\t\t       devinfo.our_scsiid,\n\t\t\t\t\t       devinfo.target);\n\t\t\t\t}\n#endif\n\t\t\t\tif (xs->datalen > 0 &&\n\t\t\t\t    xs->resid == xs->datalen) {\n\t\t\t\ttinfo = ahc_fetch_transinfo(ahc,\n\t\t\t\t\t\t\t    devinfo.channel,\n\t\t\t\t\t\t\t    devinfo.our_scsiid,\n\t\t\t\t\t\t\t    devinfo.target,\n\t\t\t\t\t\t\t    &tstate);\n\t\t\t\t\tahc_update_target_msg_request(ahc,\n\t\t\t\t\t\t\t      &devinfo,\n\t\t\t\t\t\t\t      tinfo,\n\t\t\t\t\t\t\t      /*force*/TRUE,\n\t\t\t\t\t\t\t      /*paused*/TRUE);\n\t\t\t\t}\n\t\t\t\thscb->status = 0;\n\t\t\t\thscb->SG_count = 1;\n\t\t\t\thscb->SG_pointer = scb->sg_list_phys;\n\t\t\t\thscb->data = sg->addr; \n\t\t\t\thscb->datalen = sg->len;\n\t\t\t\thscb->cmdpointer = hscb->cmdstore_busaddr;\n\t\t\t\thscb->cmdlen = sizeof(*sc);\n\t\t\t\tscb->sg_count = hscb->SG_count;\n\t\t\t\tscb->flags |= SCB_SENSE;\n\t\t\t\t/*\n\t\t\t\t * Ensure the target is busy since this\n\t\t\t\t * will be an untagged request.\n\t\t\t\t */\n\t\t\t\tahc_busy_tcl(ahc, scb);\n\t\t\t\tahc_outb(ahc, RETURN_1, SEND_SENSE);\n\n\t\t\t\t/*\n\t\t\t\t * Ensure we have enough time to actually\n\t\t\t\t * retrieve the sense.\n\t\t\t\t */\n\t\t\t\tif (!(scb->xs->flags & SCSI_POLL)) {\n\t\t\t\tuntimeout(ahc_timeout, (caddr_t)scb);\n\t\t\t\t\ttimeout(ahc_timeout, (caddr_t)scb,\n\t\t\t\t\t    5 * hz);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SCSI_BUSY:\n\t\t\t/*\n\t\t\t * Requeue any transactions that haven't been\n\t\t\t * sent yet.\n\t\t\t */\n\t\t\tahc_freeze_devq(ahc, xs->sc_link);\n\t\t\tahc_freeze_ccb(scb);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\tcase TRACE_POINT:\n\t{\n\t\tprintf(\"SSTAT2 = 0x%x DFCNTRL = 0x%x\\n\", ahc_inb(ahc, SSTAT2),\n\t\t       ahc_inb(ahc, DFCNTRL));\n\t\tprintf(\"SSTAT3 = 0x%x DSTATUS = 0x%x\\n\", ahc_inb(ahc, SSTAT3),\n\t\t       ahc_inb(ahc, DFSTATUS));\n\t\tprintf(\"SSTAT0 = 0x%x, SCB_DATACNT = 0x%x\\n\",\n\t\t       ahc_inb(ahc, SSTAT0),\n\t\t       ahc_inb(ahc, SCB_DATACNT));\n\t\tbreak;\n\t}\n\tcase HOST_MSG_LOOP:\n\t{\n\t\t/*\n\t\t * The sequencer has encountered a message phase\n\t\t * that requires host assistance for completion.\n\t\t * While handling the message phase(s), we will be\n\t\t * notified by the sequencer after each byte is\n\t\t * transfered so we can track bus phases.\n\t\t *\n\t\t * If this is the first time we've seen a HOST_MSG_LOOP,\n\t\t * initialize the state of the host message loop.\n\t\t */\n\t\tif (ahc->msg_type == MSG_TYPE_NONE) {\n\t\t\tu_int bus_phase;\n\n\t\t\tbus_phase = ahc_inb(ahc, SCSISIGI) & PHASE_MASK;\n\t\t\tif (bus_phase != P_MESGIN\n\t\t\t && bus_phase != P_MESGOUT) {\n\t\t\t\tprintf(\"ahc_intr: HOST_MSG_LOOP bad \"\n\t\t\t\t       \"phase 0x%x\\n\",\n\t\t\t\t      bus_phase);\n\t\t\t\t/*\n\t\t\t\t * Probably transitioned to bus free before\n\t\t\t\t * we got here.  Just punt the message.\n\t\t\t\t */\n\t\t\t\tahc_clear_intstat(ahc);\n\t\t\t\trestart_sequencer(ahc);\n\t\t\t}\n\n\t\t\tif (devinfo.role == ROLE_INITIATOR) {\n\t\t\t\tstruct scb *scb;\n\t\t\t\tu_int scb_index;\n\n\t\t\t\tscb_index = ahc_inb(ahc, SCB_TAG);\n\t\t\t\tscb = &ahc->scb_data->scbarray[scb_index];\n\n\t\t\t\tif (bus_phase == P_MESGOUT)\n\t\t\t\t\tahc_setup_initiator_msgout(ahc,\n\t\t\t\t\t\t\t\t   &devinfo,\n\t\t\t\t\t\t\t\t   scb);\n\t\t\t\telse {\n\t\t\t\t\tahc->msg_type =\n\t\t\t\t\t    MSG_TYPE_INITIATOR_MSGIN;\n\t\t\t\t\tahc->msgin_index = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (bus_phase == P_MESGOUT) {\n\t\t\t\t\tahc->msg_type =\n\t\t\t\t\t    MSG_TYPE_TARGET_MSGOUT;\n\t\t\t\t\tahc->msgin_index = 0;\n\t\t\t\t} else \n\t\t\t\t\t/* XXX Ever executed??? */\n\t\t\t\t\tahc_setup_target_msgin(ahc, &devinfo);\n\t\t\t}\n\t\t}\n\n\t\t/* Pass a NULL path so that handlers generate their own */\n\t\tahc_handle_message_phase(ahc, /*path*/NULL);\n\t\tbreak;\n\t}\n\tcase PERR_DETECTED:\n\t{\n\t\t/*\n\t\t * If we've cleared the parity error interrupt\n\t\t * but the sequencer still believes that SCSIPERR\n\t\t * is true, it must be that the parity error is\n\t\t * for the currently presented byte on the bus,\n\t\t * and we are not in a phase (data-in) where we will\n\t\t * eventually ack this byte.  Ack the byte and\n\t\t * throw it away in the hope that the target will\n\t\t * take us to message out to deliver the appropriate\n\t\t * error message.\n\t\t */\n\t\tif ((intstat & SCSIINT) == 0\n\t\t && (ahc_inb(ahc, SSTAT1) & SCSIPERR) != 0) {\n\t\t\tu_int curphase;\n\n\t\t\t/*\n\t\t\t * The hardware will only let you ack bytes\n\t\t\t * if the expected phase in SCSISIGO matches\n\t\t\t * the current phase.  Make sure this is\n\t\t\t * currently the case.\n\t\t\t */\n\t\t\tcurphase = ahc_inb(ahc, SCSISIGI) & PHASE_MASK;\n\t\t\tahc_outb(ahc, LASTPHASE, curphase);\n\t\t\tahc_outb(ahc, SCSISIGO, curphase);\n\t\t\tahc_inb(ahc, SCSIDATL);\n\t\t}\n\t\tbreak;\n\t}\n\tcase DATA_OVERRUN:\n\t{\n\t\t/*\n\t\t * When the sequencer detects an overrun, it\n\t\t * places the controller in \"BITBUCKET\" mode\n\t\t * and allows the target to complete its transfer.\n\t\t * Unfortunately, none of the counters get updated\n\t\t * when the controller is in this mode, so we have\n\t\t * no way of knowing how large the overrun was.\n\t\t */\n\t\tu_int scbindex = ahc_inb(ahc, SCB_TAG);\n\t\tu_int lastphase = ahc_inb(ahc, LASTPHASE);\n\t\tint i;\n\n\t\tscb = &ahc->scb_data->scbarray[scbindex];\n\t\tfor (i = 0; i < num_phases; i++) {\n\t\t\tif (lastphase == phase_table[i].phase)\n\t\t\t\tbreak;\n\t\t}\n\t\tsc_print_addr(scb->xs->sc_link);\n\t\tprintf(\"data overrun detected %s.\"\n\t\t       \"  Tag == 0x%x.\\n\",\n\t\t       phase_table[i].phasemsg,\n  \t\t       scb->hscb->tag);\n\t\tsc_print_addr(scb->xs->sc_link);\n\t\tprintf(\"%s seen Data Phase.  Length = %d.  NumSGs = %d.\\n\",\n\t\t       ahc_inb(ahc, SEQ_FLAGS) & DPHASE ? \"Have\" : \"Haven't\",\n\t\t       scb->xs->datalen, scb->sg_count);\n\t\tif (scb->sg_count > 0) {\n\t\t\tfor (i = 0; i < scb->sg_count; i++) {\n\t\t\t\tprintf(\"sg[%d] - Addr 0x%x : Length %d\\n\",\n\t\t\t\t       i,\n\t\t\t\t       scb->sg_list[i].addr,\n\t\t\t\t       scb->sg_list[i].len);\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Set this and it will take affect when the\n\t\t * target does a command complete.\n\t\t */\n\t\tahc_freeze_devq(ahc, scb->xs->sc_link);\n\t\tahcsetccbstatus(scb->xs, XS_DRIVER_STUFFUP);\n\t\tahc_freeze_ccb(scb);\n\t\tbreak;\n\t}\n\tcase TRACEPOINT:\n\t{\n\t\tprintf(\"TRACEPOINT: RETURN_2 = %d\\n\", ahc_inb(ahc, RETURN_2));\n#if 0\n\t\tprintf(\"SSTAT1 == 0x%x\\n\", ahc_inb(ahc, SSTAT1));\n\t\tprintf(\"SSTAT0 == 0x%x\\n\", ahc_inb(ahc, SSTAT0));\n\t\tprintf(\", SCSISIGI == 0x%x\\n\", ahc_inb(ahc, SCSISIGI));\n\t\tprintf(\"TRACEPOINT: CCHCNT = %d, SG_COUNT = %d\\n\",\n\t\t       ahc_inb(ahc, CCHCNT), ahc_inb(ahc, SG_COUNT));\n\t\tprintf(\"TRACEPOINT: SCB_TAG = %d\\n\", ahc_inb(ahc, SCB_TAG));\n\t\tprintf(\"TRACEPOINT1: CCHADDR = %d, CCHCNT = %d, SCBPTR = %d\\n\",\n\t\t       ahc_inb(ahc, CCHADDR)\n\t\t    | (ahc_inb(ahc, CCHADDR+1) << 8)\n\t\t    | (ahc_inb(ahc, CCHADDR+2) << 16)\n\t\t    | (ahc_inb(ahc, CCHADDR+3) << 24),\n\t\t       ahc_inb(ahc, CCHCNT)\n\t\t    | (ahc_inb(ahc, CCHCNT+1) << 8)\n\t\t    | (ahc_inb(ahc, CCHCNT+2) << 16),\n\t\t       ahc_inb(ahc, SCBPTR));\n\t\tprintf(\"TRACEPOINT: WAITING_SCBH = %d\\n\", \n\t\t       ahc_inb(ahc, WAITING_SCBH));\n\t\tprintf(\"TRACEPOINT: SCB_TAG = %d\\n\", ahc_inb(ahc, SCB_TAG));\n#endif\n\t\tbreak;\n\t}\n#if NOT_YET\n\t/* XXX Fill these in later */\n\tcase MESG_BUFFER_BUSY:\n\t\tbreak;\n\tcase MSGIN_PHASEMIS:\n\t\tbreak;\n#endif\n\tdefault:\n\t\tprintf(\"ahc_intr: seqint, \"\n\t\t       \"intstat == 0x%x, scsisigi = 0x%x\\n\",\n\t\t       intstat, ahc_inb(ahc, SCSISIGI));\n\t\tbreak;\n\t}\n\t\nunpause:\n\t/*\n\t *  The sequencer is paused immediately on\n\t *  a SEQINT, so we should restart it when\n\t *  we're done.\n\t */\n\tunpause_sequencer(ahc);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
            "STATIC void",
            "ahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "ahc_handle_seqint __P((struct ahc_softc *ahc, u_int intstat));",
            "STATIC void",
            "ahc_handle_scsiint __P((struct ahc_softc *ahc, u_int intstat));",
            "STATIC void",
            "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
            "STATIC void",
            "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC int",
            "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));",
            "STATIC int",
            "STATIC int",
            "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "ahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "ahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "ahc_update_target_msg_request __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t\t      struct ahc_initiator_tinfo *tinfo,\n\t\t\t\t\t      int force, int paused));",
            "STATIC void",
            "ahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));",
            "STATIC void",
            "ahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));",
            "STATIC void",
            "STATIC int",
            "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
            "STATIC void",
            "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_calc_residual __P((struct scb *scb));",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
            "STATIC void",
            "static __inline void unpause_sequencer",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "static __inline void\tahc_busy_tcl",
            "static __inline void ahc_freeze_ccb",
            "static __inline void ahcsetccbstatus",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "static __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo",
            "STATIC void",
            "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct tmode_tstate **tstate;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "static struct {\n        u_int8_t phase;\n        u_int8_t mesg_out; /* Message response to parity errors */\n\tchar *phasemsg;\n} phase_table[] = {\n\t{ P_DATAOUT,\tMSG_NOOP,\t\t\"in Data-out phase\"\t},\n\t{ P_DATAIN,\tMSG_INITIATOR_DET_ERR,\t\"in Data-in phase\"\t},\n\t{ P_COMMAND,\tMSG_NOOP,\t\t\"in Command phase\"\t},\n\t{ P_MESGOUT,\tMSG_NOOP,\t\t\"in Message-out phase\"\t},\n\t{ P_STATUS,\tMSG_INITIATOR_DET_ERR,\t\"in Status phase\"\t},\n\t{ P_MESGIN,\tMSG_PARITY_ERROR,\t\"in Message-in phase\"\t},\n\t{ P_BUSFREE,\tMSG_NOOP,\t\t\"while idle\"\t\t},\n\t{ 0,\t\tMSG_NOOP,\t\t\"in unknown phase\"\t}\n};",
            "static const int num_phases = (sizeof(phase_table)/sizeof(phase_table[0])) - 1;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *xs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nSTATIC void;\nahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nahc_handle_seqint __P((struct ahc_softc *ahc, u_int intstat));\nSTATIC void;\nahc_handle_scsiint __P((struct ahc_softc *ahc, u_int intstat));\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));\nSTATIC int;\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nahc_update_target_msg_request __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t\t      struct ahc_initiator_tinfo *tinfo,\n\t\t\t\t\t      int force, int paused));\nSTATIC void;\nahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));\nSTATIC void;\nahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));\nSTATIC void;\nSTATIC int;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nSTATIC void;\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_calc_residual __P((struct scb *scb));\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nSTATIC void;\nstatic __inline void unpause_sequencer;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nstatic __inline void\tahc_busy_tcl;\nstatic __inline void ahc_freeze_ccb;\nstatic __inline void ahcsetccbstatus;\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo;\nSTATIC void;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct tmode_tstate **tstate;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nstatic struct {\n        u_int8_t phase;\n        u_int8_t mesg_out; /* Message response to parity errors */\n\tchar *phasemsg;\n} phase_table[] = {\n\t{ P_DATAOUT,\tMSG_NOOP,\t\t\"in Data-out phase\"\t},\n\t{ P_DATAIN,\tMSG_INITIATOR_DET_ERR,\t\"in Data-in phase\"\t},\n\t{ P_COMMAND,\tMSG_NOOP,\t\t\"in Command phase\"\t},\n\t{ P_MESGOUT,\tMSG_NOOP,\t\t\"in Message-out phase\"\t},\n\t{ P_STATUS,\tMSG_INITIATOR_DET_ERR,\t\"in Status phase\"\t},\n\t{ P_MESGIN,\tMSG_PARITY_ERROR,\t\"in Message-in phase\"\t},\n\t{ P_BUSFREE,\tMSG_NOOP,\t\t\"while idle\"\t\t},\n\t{ 0,\t\tMSG_NOOP,\t\t\"in unknown phase\"\t}\n};\nstatic const int num_phases = (sizeof(phase_table)/sizeof(phase_table[0])) - 1;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n\nSTATIC void\nahc_handle_seqint(ahc, intstat)\n\tstruct ahc_softc *ahc;\n\tu_int intstat;\n{\n\tstruct scb *scb;\n\tstruct ahc_devinfo devinfo;\n\t\n\tahc_fetch_devinfo(ahc, &devinfo);\n\n\t/*\n\t * Clear the upper byte that holds SEQINT status\n\t * codes and clear the SEQINT bit. We will unpause\n\t * the sequencer, if appropriate, after servicing\n\t * the request.\n\t */\n\tahc_outb(ahc, CLRINT, CLRSEQINT);\n\tswitch (intstat & SEQINT_MASK) {\n\tcase NO_MATCH:\n\t{\n\t\t/* Ensure we don't leave the selection hardware on */\n\t\tahc_outb(ahc, SCSISEQ,\n\t\t\t ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP));\n\n\t\tprintf(\"%s:%c:%d: no active SCB for reconnecting \"\n\t\t       \"target - issuing BUS DEVICE RESET\\n\",\n\t\t       ahc_name(ahc), devinfo.channel, devinfo.target);\n\t\tprintf(\"SAVED_TCL == 0x%x, ARG_1 == 0x%x, SEQ_FLAGS == 0x%x\\n\",\n\t\t       ahc_inb(ahc, SAVED_TCL), ahc_inb(ahc, ARG_1),\n\t\t       ahc_inb(ahc, SEQ_FLAGS));\n\t\tahc->msgout_buf[0] = MSG_BUS_DEV_RESET;\n\t\tahc->msgout_len = 1;\n\t\tahc->msgout_index = 0;\n\t\tahc->msg_type = MSG_TYPE_INITIATOR_MSGOUT;\n\t\tahc_outb(ahc, MSG_OUT, HOST_MSG);\n\t\tahc_outb(ahc, SCSISIGO, ahc_inb(ahc, LASTPHASE) | ATNO);\n\t\tbreak;\n\t}\n\tcase UPDATE_TMSG_REQ:\n\t\tahc_outb(ahc, TARGET_MSG_REQUEST, ahc->targ_msg_req & 0xFF);\n\t\tahc_outb(ahc, TARGET_MSG_REQUEST + 1,\n\t\t\t (ahc->targ_msg_req >> 8) & 0xFF);\n\t\tahc_outb(ahc, HS_MAILBOX, 0);\n\t\tbreak;\n\tcase SEND_REJECT: \n\t{\n\t\tu_int rejbyte = ahc_inb(ahc, ACCUM);\n\t\tprintf(\"%s:%c:%d: Warning - unknown message received from \"\n\t\t       \"target (0x%x).  Rejecting\\n\", \n\t\t       ahc_name(ahc), devinfo.channel, devinfo.target, rejbyte);\n\t\tbreak; \n\t}\n\tcase NO_IDENT: \n\t{\n\t\t/*\n\t\t * The reconnecting target either did not send an identify\n\t\t * message, or did, but we didn't find and SCB to match and\n\t\t * before it could respond to our ATN/abort, it hit a dataphase.\n\t\t * The only safe thing to do is to blow it away with a bus\n\t\t * reset.\n\t\t */\n\t\tint found;\n\n\t\tprintf(\"%s:%c:%d: Target did not send an IDENTIFY message. \"\n\t\t       \"LASTPHASE = 0x%x, SAVED_TCL == 0x%x\\n\",\n\t\t       ahc_name(ahc), devinfo.channel, devinfo.target,\n\t\t       ahc_inb(ahc, LASTPHASE), ahc_inb(ahc, SAVED_TCL));\n\t\tfound = ahc_reset_channel(ahc, devinfo.channel, \n\t\t\t\t\t  /*initiate reset*/TRUE);\n\t\tprintf(\"%s: Issued Channel %c Bus Reset. \"\n\t\t       \"%d SCBs aborted\\n\", ahc_name(ahc), devinfo.channel,\n\t\t       found);\n\t\treturn;\n\t}\n\tcase BAD_PHASE:\n\t{\n\t\tu_int lastphase;\n\n\t\tlastphase = ahc_inb(ahc, LASTPHASE);\n\t\tif (lastphase == P_BUSFREE) {\n\t\t\tprintf(\"%s:%c:%d: Missed busfree.  Curphase = 0x%x\\n\",\n\t\t\t       ahc_name(ahc), devinfo.channel, devinfo.target,\n\t\t\t       ahc_inb(ahc, SCSISIGI));\n\t\t\trestart_sequencer(ahc);\n\t\t\treturn;\n\t\t} else {\n\t\t\tprintf(\"%s:%c:%d: unknown scsi bus phase %x.  \"\n\t\t\t       \"Attempting to continue\\n\",\n\t\t\t       ahc_name(ahc), devinfo.channel, devinfo.target,\n\t\t\t       ahc_inb(ahc, SCSISIGI));\n\t\t}\n\t\tbreak; \n\t}\n\tcase BAD_STATUS:\n\t{\n\t\tu_int  scb_index;\n\t\tstruct hardware_scb *hscb;\n\t\tstruct scsi_xfer *xs;\n\t\t/*\n\t\t * The sequencer will notify us when a command\n\t\t * has an error that would be of interest to\n\t\t * the kernel.  This allows us to leave the sequencer\n\t\t * running in the common case of command completes\n\t\t * without error.  The sequencer will already have\n\t\t * dma'd the SCB back up to us, so we can reference\n\t\t * the in kernel copy directly.\n\t\t */\n\t\tscb_index = ahc_inb(ahc, SCB_TAG);\n\t\tscb = &ahc->scb_data->scbarray[scb_index];\n\n\t\t/*\n\t\t * Set the default return value to 0 (don't\n\t\t * send sense).  The sense code will change\n\t\t * this if needed.\n\t\t */\n\t\tahc_outb(ahc, RETURN_1, 0);\n\t\tif (!(scb_index < ahc->scb_data->numscbs\n\t\t   && (scb->flags & SCB_ACTIVE) != 0)) {\n\t\t\tprintf(\"%s:%c:%d: ahc_intr - referenced scb \"\n\t\t\t       \"not valid during seqint 0x%x scb(%d)\\n\",\n\t\t\t       ahc_name(ahc), devinfo.channel,\n\t\t\t       devinfo.target, intstat, scb_index);\n\t\t\tgoto unpause;\n\t\t}\n\n\t\thscb = scb->hscb; \n\t\txs = scb->xs;\n\n\t\t/* Don't want to clobber the original sense code */\n\t\tif ((scb->flags & SCB_SENSE) != 0) {\n\t\t\t/*\n\t\t\t * Clear the SCB_SENSE Flag and have\n\t\t\t * the sequencer do a normal command\n\t\t\t * complete.\n\t\t\t */\n\t\t\tscb->flags &= ~SCB_SENSE;\n\t\t\tahcsetccbstatus(xs, XS_DRIVER_STUFFUP);\n\t\t\tbreak;\n\t\t}\n\t\t/* Freeze the queue unit the client sees the error. */\n\t\tahc_freeze_devq(ahc, xs->sc_link);\n\t\tahc_freeze_ccb(scb);\n\t\txs->status = hscb->status;\n\t\tswitch (hscb->status) {\n\t\tcase SCSI_OK:\n\t\t\tprintf(\"%s: Interrupted for staus of 0???\\n\",\n\t\t\t       ahc_name(ahc));\n\t\t\tbreak;\n\t\tcase SCSI_CHECK:\n#ifdef AHC_DEBUG\n\t\t\tif (ahc_debug & AHC_SHOWSENSE) {\n\t\t\t\tsc_print_addr(scb->xs->sc_link);\n\t\t\t\tprintf(\"SCB %d: requests Check Status\\n\",\n\t\t\t\t       scb->hscb->tag);\n\t\t\t}\n#endif\n\t\t\t\t\n\t\t\tif (xs->error == XS_NOERROR &&\n\t\t\t    !(scb->flags & SCB_SENSE)) {\n\t\t\t\tstruct ahc_dma_seg *sg;\n\t\t\t\tstruct scsi_sense *sc;\n\t\t\t\tstruct ahc_initiator_tinfo *tinfo;\n\t\t\t\tstruct tmode_tstate *tstate;\n\n\t\t\t\tsg = scb->sg_list;\n\t\t\t\tsc = (struct scsi_sense *)(&hscb->cmdstore); \n\t\t\t\t/*\n\t\t\t\t * Save off the residual if there is one.\n\t\t\t\t */\n\t\t\t\tif (hscb->residual_SG_count != 0)\n\t\t\t\t\tahc_calc_residual(scb);\n\t\t\t\telse\n\t\t\t\t\txs->resid = 0;\n\n#ifdef AHC_DEBUG\n\t\t\t\tif (ahc_debug & AHC_SHOWSENSE) {\n\t\t\t\t\tsc_print_addr(scb->xs->sc_link);\n\t\t\t\t\tprintf(\"Sending Sense\\n\");\n\t\t\t\t}\n#endif\n\t\t\t\tsg->addr = ahc->scb_data->sense_busaddr +\n\t\t\t\t\t(hscb->tag*sizeof(struct scsi_sense_data));\n\t\t\t\t\n\t\t\t\tsg->len = sizeof(struct scsi_sense_data);\n\n\t\t\t\tsc->opcode = REQUEST_SENSE;\n\t\t\t\tsc->byte2 =  SCB_LUN(scb) << 5;\n\t\t\t\tsc->unused[0] = 0;\n\t\t\t\tsc->unused[1] = 0;\n\t\t\t\tsc->length = sg->len;\n\t\t\t\tsc->control = 0;\n\n\t\t\t\t/*\n\t\t\t\t * Would be nice to preserve DISCENB here,\n\t\t\t\t * but due to the way we page SCBs, we can't.\n\t\t\t\t */\n\t\t\t\thscb->control = 0;\n\n\t\t\t\t/*\n\t\t\t\t * This request sense could be because the\n\t\t\t\t * the device lost power or in some other\n\t\t\t\t * way has lost our transfer negotiations.\n\t\t\t\t * Renegotiate if appropriate.\n\t\t\t\t */\n\t\t\t\tahc_calc_residual(scb);\n#ifdef AHC_DEBUG\n\t\t\t\tif (ahc_debug & AHC_SHOWSENSE) {\n\t\t\t\t\tsc_print_addr(xs->sc_link);\n\t\t\t\t\tprintf(\"Sense: datalen %d resid %d\"\n\t\t\t\t\t       \"chan %d id %d targ %d\\n\",\n\t\t\t\t\t       xs->datalen, xs->resid,\n\t\t\t\t\t       devinfo.channel,\n\t\t\t\t\t       devinfo.our_scsiid,\n\t\t\t\t\t       devinfo.target);\n\t\t\t\t}\n#endif\n\t\t\t\tif (xs->datalen > 0 &&\n\t\t\t\t    xs->resid == xs->datalen) {\n\t\t\t\ttinfo = ahc_fetch_transinfo(ahc,\n\t\t\t\t\t\t\t    devinfo.channel,\n\t\t\t\t\t\t\t    devinfo.our_scsiid,\n\t\t\t\t\t\t\t    devinfo.target,\n\t\t\t\t\t\t\t    &tstate);\n\t\t\t\t\tahc_update_target_msg_request(ahc,\n\t\t\t\t\t\t\t      &devinfo,\n\t\t\t\t\t\t\t      tinfo,\n\t\t\t\t\t\t\t      /*force*/TRUE,\n\t\t\t\t\t\t\t      /*paused*/TRUE);\n\t\t\t\t}\n\t\t\t\thscb->status = 0;\n\t\t\t\thscb->SG_count = 1;\n\t\t\t\thscb->SG_pointer = scb->sg_list_phys;\n\t\t\t\thscb->data = sg->addr; \n\t\t\t\thscb->datalen = sg->len;\n\t\t\t\thscb->cmdpointer = hscb->cmdstore_busaddr;\n\t\t\t\thscb->cmdlen = sizeof(*sc);\n\t\t\t\tscb->sg_count = hscb->SG_count;\n\t\t\t\tscb->flags |= SCB_SENSE;\n\t\t\t\t/*\n\t\t\t\t * Ensure the target is busy since this\n\t\t\t\t * will be an untagged request.\n\t\t\t\t */\n\t\t\t\tahc_busy_tcl(ahc, scb);\n\t\t\t\tahc_outb(ahc, RETURN_1, SEND_SENSE);\n\n\t\t\t\t/*\n\t\t\t\t * Ensure we have enough time to actually\n\t\t\t\t * retrieve the sense.\n\t\t\t\t */\n\t\t\t\tif (!(scb->xs->flags & SCSI_POLL)) {\n\t\t\t\tuntimeout(ahc_timeout, (caddr_t)scb);\n\t\t\t\t\ttimeout(ahc_timeout, (caddr_t)scb,\n\t\t\t\t\t    5 * hz);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SCSI_BUSY:\n\t\t\t/*\n\t\t\t * Requeue any transactions that haven't been\n\t\t\t * sent yet.\n\t\t\t */\n\t\t\tahc_freeze_devq(ahc, xs->sc_link);\n\t\t\tahc_freeze_ccb(scb);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\tcase TRACE_POINT:\n\t{\n\t\tprintf(\"SSTAT2 = 0x%x DFCNTRL = 0x%x\\n\", ahc_inb(ahc, SSTAT2),\n\t\t       ahc_inb(ahc, DFCNTRL));\n\t\tprintf(\"SSTAT3 = 0x%x DSTATUS = 0x%x\\n\", ahc_inb(ahc, SSTAT3),\n\t\t       ahc_inb(ahc, DFSTATUS));\n\t\tprintf(\"SSTAT0 = 0x%x, SCB_DATACNT = 0x%x\\n\",\n\t\t       ahc_inb(ahc, SSTAT0),\n\t\t       ahc_inb(ahc, SCB_DATACNT));\n\t\tbreak;\n\t}\n\tcase HOST_MSG_LOOP:\n\t{\n\t\t/*\n\t\t * The sequencer has encountered a message phase\n\t\t * that requires host assistance for completion.\n\t\t * While handling the message phase(s), we will be\n\t\t * notified by the sequencer after each byte is\n\t\t * transfered so we can track bus phases.\n\t\t *\n\t\t * If this is the first time we've seen a HOST_MSG_LOOP,\n\t\t * initialize the state of the host message loop.\n\t\t */\n\t\tif (ahc->msg_type == MSG_TYPE_NONE) {\n\t\t\tu_int bus_phase;\n\n\t\t\tbus_phase = ahc_inb(ahc, SCSISIGI) & PHASE_MASK;\n\t\t\tif (bus_phase != P_MESGIN\n\t\t\t && bus_phase != P_MESGOUT) {\n\t\t\t\tprintf(\"ahc_intr: HOST_MSG_LOOP bad \"\n\t\t\t\t       \"phase 0x%x\\n\",\n\t\t\t\t      bus_phase);\n\t\t\t\t/*\n\t\t\t\t * Probably transitioned to bus free before\n\t\t\t\t * we got here.  Just punt the message.\n\t\t\t\t */\n\t\t\t\tahc_clear_intstat(ahc);\n\t\t\t\trestart_sequencer(ahc);\n\t\t\t}\n\n\t\t\tif (devinfo.role == ROLE_INITIATOR) {\n\t\t\t\tstruct scb *scb;\n\t\t\t\tu_int scb_index;\n\n\t\t\t\tscb_index = ahc_inb(ahc, SCB_TAG);\n\t\t\t\tscb = &ahc->scb_data->scbarray[scb_index];\n\n\t\t\t\tif (bus_phase == P_MESGOUT)\n\t\t\t\t\tahc_setup_initiator_msgout(ahc,\n\t\t\t\t\t\t\t\t   &devinfo,\n\t\t\t\t\t\t\t\t   scb);\n\t\t\t\telse {\n\t\t\t\t\tahc->msg_type =\n\t\t\t\t\t    MSG_TYPE_INITIATOR_MSGIN;\n\t\t\t\t\tahc->msgin_index = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (bus_phase == P_MESGOUT) {\n\t\t\t\t\tahc->msg_type =\n\t\t\t\t\t    MSG_TYPE_TARGET_MSGOUT;\n\t\t\t\t\tahc->msgin_index = 0;\n\t\t\t\t} else \n\t\t\t\t\t/* XXX Ever executed??? */\n\t\t\t\t\tahc_setup_target_msgin(ahc, &devinfo);\n\t\t\t}\n\t\t}\n\n\t\t/* Pass a NULL path so that handlers generate their own */\n\t\tahc_handle_message_phase(ahc, /*path*/NULL);\n\t\tbreak;\n\t}\n\tcase PERR_DETECTED:\n\t{\n\t\t/*\n\t\t * If we've cleared the parity error interrupt\n\t\t * but the sequencer still believes that SCSIPERR\n\t\t * is true, it must be that the parity error is\n\t\t * for the currently presented byte on the bus,\n\t\t * and we are not in a phase (data-in) where we will\n\t\t * eventually ack this byte.  Ack the byte and\n\t\t * throw it away in the hope that the target will\n\t\t * take us to message out to deliver the appropriate\n\t\t * error message.\n\t\t */\n\t\tif ((intstat & SCSIINT) == 0\n\t\t && (ahc_inb(ahc, SSTAT1) & SCSIPERR) != 0) {\n\t\t\tu_int curphase;\n\n\t\t\t/*\n\t\t\t * The hardware will only let you ack bytes\n\t\t\t * if the expected phase in SCSISIGO matches\n\t\t\t * the current phase.  Make sure this is\n\t\t\t * currently the case.\n\t\t\t */\n\t\t\tcurphase = ahc_inb(ahc, SCSISIGI) & PHASE_MASK;\n\t\t\tahc_outb(ahc, LASTPHASE, curphase);\n\t\t\tahc_outb(ahc, SCSISIGO, curphase);\n\t\t\tahc_inb(ahc, SCSIDATL);\n\t\t}\n\t\tbreak;\n\t}\n\tcase DATA_OVERRUN:\n\t{\n\t\t/*\n\t\t * When the sequencer detects an overrun, it\n\t\t * places the controller in \"BITBUCKET\" mode\n\t\t * and allows the target to complete its transfer.\n\t\t * Unfortunately, none of the counters get updated\n\t\t * when the controller is in this mode, so we have\n\t\t * no way of knowing how large the overrun was.\n\t\t */\n\t\tu_int scbindex = ahc_inb(ahc, SCB_TAG);\n\t\tu_int lastphase = ahc_inb(ahc, LASTPHASE);\n\t\tint i;\n\n\t\tscb = &ahc->scb_data->scbarray[scbindex];\n\t\tfor (i = 0; i < num_phases; i++) {\n\t\t\tif (lastphase == phase_table[i].phase)\n\t\t\t\tbreak;\n\t\t}\n\t\tsc_print_addr(scb->xs->sc_link);\n\t\tprintf(\"data overrun detected %s.\"\n\t\t       \"  Tag == 0x%x.\\n\",\n\t\t       phase_table[i].phasemsg,\n  \t\t       scb->hscb->tag);\n\t\tsc_print_addr(scb->xs->sc_link);\n\t\tprintf(\"%s seen Data Phase.  Length = %d.  NumSGs = %d.\\n\",\n\t\t       ahc_inb(ahc, SEQ_FLAGS) & DPHASE ? \"Have\" : \"Haven't\",\n\t\t       scb->xs->datalen, scb->sg_count);\n\t\tif (scb->sg_count > 0) {\n\t\t\tfor (i = 0; i < scb->sg_count; i++) {\n\t\t\t\tprintf(\"sg[%d] - Addr 0x%x : Length %d\\n\",\n\t\t\t\t       i,\n\t\t\t\t       scb->sg_list[i].addr,\n\t\t\t\t       scb->sg_list[i].len);\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Set this and it will take affect when the\n\t\t * target does a command complete.\n\t\t */\n\t\tahc_freeze_devq(ahc, scb->xs->sc_link);\n\t\tahcsetccbstatus(scb->xs, XS_DRIVER_STUFFUP);\n\t\tahc_freeze_ccb(scb);\n\t\tbreak;\n\t}\n\tcase TRACEPOINT:\n\t{\n\t\tprintf(\"TRACEPOINT: RETURN_2 = %d\\n\", ahc_inb(ahc, RETURN_2));\n#if 0\n\t\tprintf(\"SSTAT1 == 0x%x\\n\", ahc_inb(ahc, SSTAT1));\n\t\tprintf(\"SSTAT0 == 0x%x\\n\", ahc_inb(ahc, SSTAT0));\n\t\tprintf(\", SCSISIGI == 0x%x\\n\", ahc_inb(ahc, SCSISIGI));\n\t\tprintf(\"TRACEPOINT: CCHCNT = %d, SG_COUNT = %d\\n\",\n\t\t       ahc_inb(ahc, CCHCNT), ahc_inb(ahc, SG_COUNT));\n\t\tprintf(\"TRACEPOINT: SCB_TAG = %d\\n\", ahc_inb(ahc, SCB_TAG));\n\t\tprintf(\"TRACEPOINT1: CCHADDR = %d, CCHCNT = %d, SCBPTR = %d\\n\",\n\t\t       ahc_inb(ahc, CCHADDR)\n\t\t    | (ahc_inb(ahc, CCHADDR+1) << 8)\n\t\t    | (ahc_inb(ahc, CCHADDR+2) << 16)\n\t\t    | (ahc_inb(ahc, CCHADDR+3) << 24),\n\t\t       ahc_inb(ahc, CCHCNT)\n\t\t    | (ahc_inb(ahc, CCHCNT+1) << 8)\n\t\t    | (ahc_inb(ahc, CCHCNT+2) << 16),\n\t\t       ahc_inb(ahc, SCBPTR));\n\t\tprintf(\"TRACEPOINT: WAITING_SCBH = %d\\n\", \n\t\t       ahc_inb(ahc, WAITING_SCBH));\n\t\tprintf(\"TRACEPOINT: SCB_TAG = %d\\n\", ahc_inb(ahc, SCB_TAG));\n#endif\n\t\tbreak;\n\t}\n#if NOT_YET\n\t/* XXX Fill these in later */\n\tcase MESG_BUFFER_BUSY:\n\t\tbreak;\n\tcase MSGIN_PHASEMIS:\n\t\tbreak;\n#endif\n\tdefault:\n\t\tprintf(\"ahc_intr: seqint, \"\n\t\t       \"intstat == 0x%x, scsisigi = 0x%x\\n\",\n\t\t       intstat, ahc_inb(ahc, SCSISIGI));\n\t\tbreak;\n\t}\n\t\nunpause:\n\t/*\n\t *  The sequencer is paused immediately on\n\t *  a SEQINT, so we should restart it when\n\t *  we're done.\n\t */\n\tunpause_sequencer(ahc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_abort_scbs",
          "args": [
            "ahc",
            "ALL_TARGETS",
            "ALL_CHANNELS",
            "ALL_LUNS",
            "SCB_LIST_NULL",
            "ROLE_UNKNOWN",
            "XS_DRIVER_STUFFUP"
          ],
          "line": 1645
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_abort_scbs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "5129-5231",
          "snippet": "STATIC int\nahc_abort_scbs(ahc, target, channel, lun, tag, role, status)\n\tstruct ahc_softc *ahc;\n\tint target;\n\tchar channel;\n\tint lun;\n\tu_int tag;\n\trole_t role;\n\tu_int32_t status;\n{\n\tstruct\tscb *scbp;\n\tu_int\tactive_scb;\n\tint\ti;\n\tint\tfound;\n\n\t/* restore this when we're done */\n\tactive_scb = ahc_inb(ahc, SCBPTR);\n\n\tfound = ahc_search_qinfifo(ahc, target, channel, lun, SCB_LIST_NULL,\n\t\t\t\t   role, SCB_REQUEUE, SEARCH_COMPLETE);\n\n\t/*\n\t * Search waiting for selection list.\n\t */\n\t{\n\t\tu_int8_t next, prev;\n                /* Start at head of list. */\n\t\tnext = ahc_inb(ahc, WAITING_SCBH);\n\t\tprev = SCB_LIST_NULL;\n\n\t\twhile (next != SCB_LIST_NULL) {\n\t\t\tu_int8_t scb_index;\n\n\t\t\tahc_outb(ahc, SCBPTR, next);\n\t\t\tscb_index = ahc_inb(ahc, SCB_TAG);\n\t\t\tif (scb_index >= ahc->scb_data->numscbs) {\n\t\t\t\tpanic(\"Waiting List inconsistency. \"\n\t\t\t\t      \"SCB index == %d, yet numscbs == %d.\",\n\t\t\t\t      scb_index, ahc->scb_data->numscbs);\n\t\t\t}\n\t\t\tscbp = &ahc->scb_data->scbarray[scb_index];\n\t\t\tif (ahc_match_scb(scbp, target, channel,\n\t\t\t\t\t  lun, SCB_LIST_NULL, role)) {\n\n\t\t\t\tnext = ahc_abort_wscb(ahc, next, prev);\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tprev = next;\n\t\t\t\tnext = ahc_inb(ahc, SCB_NEXT);\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\t * Go through the disconnected list and remove any entries we\n\t * have queued for completion, 0'ing their control byte too.\n\t * We save the active SCB and restore it ourselves, so there\n\t * is no reason for this search to restore it too.\n\t */\n\tahc_search_disc_list(ahc, target, channel, lun, tag,\n\t\t\t     /*stop_on_first*/FALSE, /*remove*/TRUE,\n\t\t\t     /*save_state*/FALSE);\n\n\t/*\n\t * Go through the hardware SCB array looking for commands that\n\t * were active but not on any list.\n\t */\n\tfor(i = 0; i < ahc->scb_data->maxhscbs; i++) {\n\t\tu_int scbid;\n\n\t\tahc_outb(ahc, SCBPTR, i);\n\t\tscbid = ahc_inb(ahc, SCB_TAG);\n\t\tscbp = &ahc->scb_data->scbarray[scbid];\n\t\tif (scbid < ahc->scb_data->numscbs && \n\t\t\t ahc_match_scb(scbp, target, channel, lun, tag, role))\n\t\t\t\tahc_add_curscb_to_free_list(ahc);\n\t}\n\n\t/*\n\t * Go through the pending CCB list and look for\n\t * commands for this target that are still active.\n\t * These are other tagged commands that were\n\t * disconnected when the reset occured.\n\t */\n\t{\n\t\tstruct scb *scb;\n\n\t\tscb = ahc->pending_scbs.lh_first;\n\t\twhile (scb != NULL) {\n\t\t\tscbp = scb;\n\t\t\tscb = scb->pend_links.le_next;\n\t\t\tif (ahc_match_scb(scbp, target, channel,\n\t\t\t\t\t  lun, tag, role)) {\n\t\t\t\tif (!(scbp->xs->flags & ITSDONE))\n\t\t\t\t\tahcsetccbstatus(scbp->xs, status);\n\t\t\t\tahc_freeze_ccb(scbp);\n\t\t\t\tahc_done(ahc, scbp);\n\t\t\t\tfound++;\n\t\t\t}\n\t\t}\n\t}\n\tahc_outb(ahc, SCBPTR, active_scb);\n\treturn found;\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "ahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));",
            "STATIC u_int",
            "ahc_abort_wscb __P((struct ahc_softc *ahc,\n\t\t\t\t    u_int scbpos, u_int prev));",
            "STATIC void",
            "ahc_done __P((struct ahc_softc *ahc, struct scb *scbp));",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "ahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "ahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));",
            "STATIC int",
            "ahc_search_disc_list __P((struct ahc_softc *ahc, int target,\n\t\t\t\t\t  char channel, int lun, u_int tag,\n\t\t\t\t\t  int stop_on_first, int remove,\n\t\t\t\t\t  int save_state));",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));",
            "STATIC void",
            "ahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));",
            "STATIC void",
            "STATIC int",
            "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
            "STATIC void",
            "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_calc_residual __P((struct scb *scb));",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "static __inline void ahc_freeze_ccb",
            "static __inline void ahcsetccbstatus",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *xs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));\nSTATIC u_int;\nahc_abort_wscb __P((struct ahc_softc *ahc,\n\t\t\t\t    u_int scbpos, u_int prev));\nSTATIC void;\nahc_done __P((struct ahc_softc *ahc, struct scb *scbp));\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));\nSTATIC int;\nahc_search_disc_list __P((struct ahc_softc *ahc, int target,\n\t\t\t\t\t  char channel, int lun, u_int tag,\n\t\t\t\t\t  int stop_on_first, int remove,\n\t\t\t\t\t  int save_state));\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));\nSTATIC void;\nahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));\nSTATIC void;\nSTATIC int;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nSTATIC void;\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_calc_residual __P((struct scb *scb));\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nstatic __inline void ahc_freeze_ccb;\nstatic __inline void ahcsetccbstatus;\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n\nSTATIC int\nahc_abort_scbs(ahc, target, channel, lun, tag, role, status)\n\tstruct ahc_softc *ahc;\n\tint target;\n\tchar channel;\n\tint lun;\n\tu_int tag;\n\trole_t role;\n\tu_int32_t status;\n{\n\tstruct\tscb *scbp;\n\tu_int\tactive_scb;\n\tint\ti;\n\tint\tfound;\n\n\t/* restore this when we're done */\n\tactive_scb = ahc_inb(ahc, SCBPTR);\n\n\tfound = ahc_search_qinfifo(ahc, target, channel, lun, SCB_LIST_NULL,\n\t\t\t\t   role, SCB_REQUEUE, SEARCH_COMPLETE);\n\n\t/*\n\t * Search waiting for selection list.\n\t */\n\t{\n\t\tu_int8_t next, prev;\n                /* Start at head of list. */\n\t\tnext = ahc_inb(ahc, WAITING_SCBH);\n\t\tprev = SCB_LIST_NULL;\n\n\t\twhile (next != SCB_LIST_NULL) {\n\t\t\tu_int8_t scb_index;\n\n\t\t\tahc_outb(ahc, SCBPTR, next);\n\t\t\tscb_index = ahc_inb(ahc, SCB_TAG);\n\t\t\tif (scb_index >= ahc->scb_data->numscbs) {\n\t\t\t\tpanic(\"Waiting List inconsistency. \"\n\t\t\t\t      \"SCB index == %d, yet numscbs == %d.\",\n\t\t\t\t      scb_index, ahc->scb_data->numscbs);\n\t\t\t}\n\t\t\tscbp = &ahc->scb_data->scbarray[scb_index];\n\t\t\tif (ahc_match_scb(scbp, target, channel,\n\t\t\t\t\t  lun, SCB_LIST_NULL, role)) {\n\n\t\t\t\tnext = ahc_abort_wscb(ahc, next, prev);\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tprev = next;\n\t\t\t\tnext = ahc_inb(ahc, SCB_NEXT);\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\t * Go through the disconnected list and remove any entries we\n\t * have queued for completion, 0'ing their control byte too.\n\t * We save the active SCB and restore it ourselves, so there\n\t * is no reason for this search to restore it too.\n\t */\n\tahc_search_disc_list(ahc, target, channel, lun, tag,\n\t\t\t     /*stop_on_first*/FALSE, /*remove*/TRUE,\n\t\t\t     /*save_state*/FALSE);\n\n\t/*\n\t * Go through the hardware SCB array looking for commands that\n\t * were active but not on any list.\n\t */\n\tfor(i = 0; i < ahc->scb_data->maxhscbs; i++) {\n\t\tu_int scbid;\n\n\t\tahc_outb(ahc, SCBPTR, i);\n\t\tscbid = ahc_inb(ahc, SCB_TAG);\n\t\tscbp = &ahc->scb_data->scbarray[scbid];\n\t\tif (scbid < ahc->scb_data->numscbs && \n\t\t\t ahc_match_scb(scbp, target, channel, lun, tag, role))\n\t\t\t\tahc_add_curscb_to_free_list(ahc);\n\t}\n\n\t/*\n\t * Go through the pending CCB list and look for\n\t * commands for this target that are still active.\n\t * These are other tagged commands that were\n\t * disconnected when the reset occured.\n\t */\n\t{\n\t\tstruct scb *scb;\n\n\t\tscb = ahc->pending_scbs.lh_first;\n\t\twhile (scb != NULL) {\n\t\t\tscbp = scb;\n\t\t\tscb = scb->pend_links.le_next;\n\t\t\tif (ahc_match_scb(scbp, target, channel,\n\t\t\t\t\t  lun, tag, role)) {\n\t\t\t\tif (!(scbp->xs->flags & ITSDONE))\n\t\t\t\t\tahcsetccbstatus(scbp->xs, status);\n\t\t\t\tahc_freeze_ccb(scbp);\n\t\t\t\tahc_done(ahc, scbp);\n\t\t\t\tfound++;\n\t\t\t}\n\t\t}\n\t}\n\tahc_outb(ahc, SCBPTR, active_scb);\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"%s: brkadrint, %s at seqaddr = 0x%x\\n\"",
            "ahc_name(ahc)",
            "hard_error[i].errmesg",
            "ahc_inb(ahc, SEQADDR0) |\n\t\t      (ahc_inb(ahc, SEQADDR1) << 8)"
          ],
          "line": 1639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SEQADDR1"
          ],
          "line": 1642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SEQADDR0"
          ],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 1640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "ERROR"
          ],
          "line": 1635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_run_qoutfifo",
          "args": [
            "ahc"
          ],
          "line": 1626
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_run_qoutfifo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "576-610",
          "snippet": "STATIC void\nahc_run_qoutfifo(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tstruct scb *scb;\n\tu_int  scb_index;\n\n\tbus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, \n\t\t\tBUS_DMASYNC_POSTREAD);\n\n\twhile (ahc->qoutfifo[ahc->qoutfifonext] != SCB_LIST_NULL) {\n\t\tscb_index = ahc->qoutfifo[ahc->qoutfifonext];\n\t\tahc->qoutfifo[ahc->qoutfifonext++] = SCB_LIST_NULL;\n\n\t\tscb = &ahc->scb_data->scbarray[scb_index];\n\t\tif (scb_index >= ahc->scb_data->numscbs\n\t\t  || (scb->flags & SCB_ACTIVE) == 0) {\n\t\t\tprintf(\"%s: WARNING no command for scb %d \"\n\t\t\t       \"(cmdcmplt)\\nQOUTPOS = %d\\n\",\n\t\t\t       ahc_name(ahc), scb_index,\n\t\t\t       ahc->qoutfifonext - 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Save off the residual\n\t\t * if there is one.\n\t\t */\n\t\tif (scb->hscb->residual_SG_count != 0)\n\t\t\tahc_calc_residual(scb);\n\t\telse\n\t\t\tscb->xs->resid = 0;\n\t\tahc_done(ahc, scb);\n\t}\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
            "STATIC void",
            "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_calc_residual __P((struct scb *scb));",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *xs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nSTATIC void;\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_calc_residual __P((struct scb *scb));\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n\nSTATIC void\nahc_run_qoutfifo(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tstruct scb *scb;\n\tu_int  scb_index;\n\n\tbus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, \n\t\t\tBUS_DMASYNC_POSTREAD);\n\n\twhile (ahc->qoutfifo[ahc->qoutfifonext] != SCB_LIST_NULL) {\n\t\tscb_index = ahc->qoutfifo[ahc->qoutfifonext];\n\t\tahc->qoutfifo[ahc->qoutfifonext++] = SCB_LIST_NULL;\n\n\t\tscb = &ahc->scb_data->scbarray[scb_index];\n\t\tif (scb_index >= ahc->scb_data->numscbs\n\t\t  || (scb->flags & SCB_ACTIVE) == 0) {\n\t\t\tprintf(\"%s: WARNING no command for scb %d \"\n\t\t\t       \"(cmdcmplt)\\nQOUTPOS = %d\\n\",\n\t\t\t       ahc_name(ahc), scb_index,\n\t\t\t       ahc->qoutfifonext - 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Save off the residual\n\t\t * if there is one.\n\t\t */\n\t\tif (scb->hscb->residual_SG_count != 0)\n\t\t\tahc_calc_residual(scb);\n\t\telse\n\t\t\tscb->xs->resid = 0;\n\t\tahc_done(ahc, scb);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "CLRINT",
            "CLRCMDINT"
          ],
          "line": 1625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: bus intr: CCHADDR %x HADDR %x SEQADDR %x\\n\"",
            "ahc_name(ahc)",
            "ahc_inb(ahc, CCHADDR) |\n\t\t\t    (ahc_inb(ahc, CCHADDR+1) << 8)\n\t\t\t    | (ahc_inb(ahc, CCHADDR+2) << 16)\n\t\t\t    | (ahc_inb(ahc, CCHADDR+3) << 24)",
            "ahc_inb(ahc, HADDR) | (ahc_inb(ahc, HADDR+1) << 8)\n\t\t\t    | (ahc_inb(ahc, HADDR+2) << 16)\n\t\t\t    | (ahc_inb(ahc, HADDR+3) << 24)",
            "ahc_inb(ahc, SEQADDR0) |\n\t\t\t    (ahc_inb(ahc, SEQADDR1) << 8)"
          ],
          "line": 1607
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SEQADDR1"
          ],
          "line": 1617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SEQADDR0"
          ],
          "line": 1616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "HADDR+3"
          ],
          "line": 1615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "HADDR+2"
          ],
          "line": 1614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "HADDR+1"
          ],
          "line": 1613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "HADDR"
          ],
          "line": 1613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "CCHADDR+3"
          ],
          "line": 1612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "CCHADDR+2"
          ],
          "line": 1611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "CCHADDR+1"
          ],
          "line": 1610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "CCHADDR"
          ],
          "line": 1609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 1608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc->pci_intr_func",
          "args": [
            "ahc"
          ],
          "line": 1605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "INTSTAT"
          ],
          "line": 1599
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define ALL_CHANNELS '\\0'\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nahc_shutdown __P((void *arg));\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC u_int;\nSTATIC struct;\nahc_handle_seqint __P((struct ahc_softc *ahc, u_int intstat));\nahc_handle_scsiint __P((struct ahc_softc *ahc, u_int intstat));\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC u_int;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nahc_clear_intstat __P((struct ahc_softc *ahc));\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nrestart_sequencer __P((struct ahc_softc *ahc));\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nstatic struct {\n        u_int8_t errno;\n\tchar *errmesg;\n} hard_error[] = {\n\t{ ILLHADDR,\t\"Illegal Host Access\" },\n\t{ ILLSADDR,\t\"Illegal Sequencer Address referrenced\" },\n\t{ ILLOPCODE,\t\"Illegal Opcode in sequencer program\" },\n\t{ SQPARERR,\t\"Sequencer Parity Error\" },\n\t{ DPARERR,\t\"Data-path Parity Error\" },\n\t{ MPARERR,\t\"Scratch or SCB Memory Parity Error\" },\n\t{ PCIERRSTAT,\t\"PCI Error detected\" },\n\t{ CIOPARERR,\t\"CIOBUS Parity Error\" },\n};\nstatic const int num_errors = sizeof(hard_error)/sizeof(hard_error[0]);\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nint\nahc_intr(void *arg)\n{\n\tstruct\tahc_softc *ahc;\n\tu_int\tintstat;\n\n\tahc = (struct ahc_softc *)arg; \n\n\tintstat = ahc_inb(ahc, INTSTAT);\n\n\t/*\n\t * Any interrupts to process?\n\t */\n\tif ((intstat & INT_PEND) == 0) {\n\t\tif (ahc->pci_intr_func && ahc->pci_intr_func(ahc)) {\n#ifdef AHC_DEBUG\n\t\t\tprintf(\"%s: bus intr: CCHADDR %x HADDR %x SEQADDR %x\\n\",\n\t\t\t    ahc_name(ahc),\n\t\t\t    ahc_inb(ahc, CCHADDR) |\n\t\t\t    (ahc_inb(ahc, CCHADDR+1) << 8)\n\t\t\t    | (ahc_inb(ahc, CCHADDR+2) << 16)\n\t\t\t    | (ahc_inb(ahc, CCHADDR+3) << 24),\n\t\t\t    ahc_inb(ahc, HADDR) | (ahc_inb(ahc, HADDR+1) << 8)\n\t\t\t    | (ahc_inb(ahc, HADDR+2) << 16)\n\t\t\t    | (ahc_inb(ahc, HADDR+3) << 24),\n\t\t\t    ahc_inb(ahc, SEQADDR0) |\n\t\t\t    (ahc_inb(ahc, SEQADDR1) << 8));\n#endif\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (intstat & CMDCMPLT) {\n\t\tahc_outb(ahc, CLRINT, CLRCMDINT);\n\t\tahc_run_qoutfifo(ahc);\n\t}\n\tif (intstat & BRKADRINT) {\n\t\t/*\n\t\t * We upset the sequencer :-(\n\t\t * Lookup the error message\n\t\t */\n\t\tint i, error, num_errors;\n\n\t\terror = ahc_inb(ahc, ERROR);\n\t\tnum_errors =  sizeof(hard_error)/sizeof(hard_error[0]);\n\t\tfor (i = 0; error != 1 && i < num_errors; i++)\n\t\t\terror >>= 1;\n\t\tpanic(\"%s: brkadrint, %s at seqaddr = 0x%x\\n\",\n\t\t      ahc_name(ahc), hard_error[i].errmesg,\n\t\t      ahc_inb(ahc, SEQADDR0) |\n\t\t      (ahc_inb(ahc, SEQADDR1) << 8));\n\n\t\t/* Tell everyone that this HBA is no longer availible */\n\t\tahc_abort_scbs(ahc, ALL_TARGETS, ALL_CHANNELS,\n\t\t\t       ALL_LUNS, SCB_LIST_NULL, ROLE_UNKNOWN,\n\t\t\t       XS_DRIVER_STUFFUP);\n\t}\n\tif (intstat & SEQINT)\n\t\tahc_handle_seqint(ahc, intstat);\n\n\tif (intstat & SCSIINT)\n\t\tahc_handle_scsiint(ahc, intstat);\n\treturn(1);\n}"
  },
  {
    "function_name": "ahc_compile_devinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "1568-1586",
    "snippet": "STATIC void\nahc_compile_devinfo(devinfo, our_id, target, lun, channel, role)\n\tstruct ahc_devinfo *devinfo;\n\tu_int our_id;\n\tu_int target;\n\tu_int lun;\n\tchar channel;\n\trole_t role;\n{\n\tdevinfo->our_scsiid = our_id;\n\tdevinfo->target = target;\n\tdevinfo->lun = lun;\n\tdevinfo->target_offset = target;\n\tdevinfo->channel = channel;\n\tdevinfo->role = role;\n\tif (channel == 'B')\n\t\tdevinfo->target_offset += 8;\n\tdevinfo->target_mask = (0x01 << devinfo->target_offset);\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define STATIC\tstatic",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
      "STATIC void",
      "ahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));",
      "STATIC u_int",
      "STATIC void",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
      "STATIC void",
      "STATIC void",
      "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
      "STATIC int",
      "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
      "STATIC void",
      "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "ahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC u_int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC struct",
      "STATIC struct",
      "STATIC u_int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "char channel;",
      "u_int our_id;",
      "STATIC struct",
      "STATIC struct",
      "STATIC struct",
      "char channel;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nchar channel;\nu_int our_id;\nSTATIC struct;\nSTATIC struct;\nSTATIC struct;\nchar channel;\n\nSTATIC void\nahc_compile_devinfo(devinfo, our_id, target, lun, channel, role)\n\tstruct ahc_devinfo *devinfo;\n\tu_int our_id;\n\tu_int target;\n\tu_int lun;\n\tchar channel;\n\trole_t role;\n{\n\tdevinfo->our_scsiid = our_id;\n\tdevinfo->target = target;\n\tdevinfo->lun = lun;\n\tdevinfo->target_offset = target;\n\tdevinfo->channel = channel;\n\tdevinfo->role = role;\n\tif (channel == 'B')\n\t\tdevinfo->target_offset += 8;\n\tdevinfo->target_mask = (0x01 << devinfo->target_offset);\n}"
  },
  {
    "function_name": "ahc_fetch_devinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "1538-1566",
    "snippet": "STATIC void\nahc_fetch_devinfo(ahc, devinfo)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n{\n\tu_int\tsaved_tcl;\n\trole_t\trole;\n\tint\tour_id;\n\n\tif (ahc_inb(ahc, SSTAT0) & TARGET)\n\t\trole = ROLE_TARGET;\n\telse\n\t\trole = ROLE_INITIATOR;\n\n\tif (role == ROLE_TARGET\n\t && (ahc->features & AHC_MULTI_TID) != 0\n\t && (ahc_inb(ahc, SEQ_FLAGS) & CMDPHASE_PENDING) != 0) {\n\t\t/* We were selected, so pull our id from TARGIDIN */\n\t\tour_id = ahc_inb(ahc, TARGIDIN) & OID;\n\t} else if ((ahc->features & AHC_ULTRA2) != 0)\n\t\tour_id = ahc_inb(ahc, SCSIID_ULTRA2) & OID;\n\telse\n\t\tour_id = ahc_inb(ahc, SCSIID) & OID;\n\n\tsaved_tcl = ahc_inb(ahc, SAVED_TCL);\n\tahc_compile_devinfo(devinfo, our_id, TCL_TARGET(saved_tcl),\n\t\t\t    TCL_LUN(saved_tcl), TCL_CHANNEL(ahc, saved_tcl),\n\t\t\t    role);\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define STATIC\tstatic",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
      "STATIC void",
      "ahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));",
      "STATIC u_int",
      "STATIC void",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
      "STATIC void",
      "STATIC void",
      "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
      "STATIC int",
      "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
      "STATIC void",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
      "STATIC void",
      "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
      "STATIC void",
      "STATIC void",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "ahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC u_int",
      "STATIC void",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "STATIC u_int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "u_int our_id;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ahc_compile_devinfo",
          "args": [
            "devinfo",
            "our_id",
            "TCL_TARGET(saved_tcl)",
            "TCL_LUN(saved_tcl)",
            "TCL_CHANNEL(ahc, saved_tcl)",
            "role"
          ],
          "line": 1563
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_compile_devinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "1568-1586",
          "snippet": "STATIC void\nahc_compile_devinfo(devinfo, our_id, target, lun, channel, role)\n\tstruct ahc_devinfo *devinfo;\n\tu_int our_id;\n\tu_int target;\n\tu_int lun;\n\tchar channel;\n\trole_t role;\n{\n\tdevinfo->our_scsiid = our_id;\n\tdevinfo->target = target;\n\tdevinfo->lun = lun;\n\tdevinfo->target_offset = target;\n\tdevinfo->channel = channel;\n\tdevinfo->role = role;\n\tif (channel == 'B')\n\t\tdevinfo->target_offset += 8;\n\tdevinfo->target_mask = (0x01 << devinfo->target_offset);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC int",
            "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "ahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "char channel;",
            "u_int our_id;",
            "STATIC struct",
            "STATIC struct",
            "STATIC struct",
            "char channel;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nchar channel;\nu_int our_id;\nSTATIC struct;\nSTATIC struct;\nSTATIC struct;\nchar channel;\n\nSTATIC void\nahc_compile_devinfo(devinfo, our_id, target, lun, channel, role)\n\tstruct ahc_devinfo *devinfo;\n\tu_int our_id;\n\tu_int target;\n\tu_int lun;\n\tchar channel;\n\trole_t role;\n{\n\tdevinfo->our_scsiid = our_id;\n\tdevinfo->target = target;\n\tdevinfo->lun = lun;\n\tdevinfo->target_offset = target;\n\tdevinfo->channel = channel;\n\tdevinfo->role = role;\n\tif (channel == 'B')\n\t\tdevinfo->target_offset += 8;\n\tdevinfo->target_mask = (0x01 << devinfo->target_offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TCL_CHANNEL",
          "args": [
            "ahc",
            "saved_tcl"
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TCL_LUN",
          "args": [
            "saved_tcl"
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TCL_TARGET",
          "args": [
            "saved_tcl"
          ],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SAVED_TCL"
          ],
          "line": 1562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCSIID"
          ],
          "line": 1560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCSIID_ULTRA2"
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "TARGIDIN"
          ],
          "line": 1556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SEQ_FLAGS"
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SSTAT0"
          ],
          "line": 1547
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nu_int our_id;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_fetch_devinfo(ahc, devinfo)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n{\n\tu_int\tsaved_tcl;\n\trole_t\trole;\n\tint\tour_id;\n\n\tif (ahc_inb(ahc, SSTAT0) & TARGET)\n\t\trole = ROLE_TARGET;\n\telse\n\t\trole = ROLE_INITIATOR;\n\n\tif (role == ROLE_TARGET\n\t && (ahc->features & AHC_MULTI_TID) != 0\n\t && (ahc_inb(ahc, SEQ_FLAGS) & CMDPHASE_PENDING) != 0) {\n\t\t/* We were selected, so pull our id from TARGIDIN */\n\t\tour_id = ahc_inb(ahc, TARGIDIN) & OID;\n\t} else if ((ahc->features & AHC_ULTRA2) != 0)\n\t\tour_id = ahc_inb(ahc, SCSIID_ULTRA2) & OID;\n\telse\n\t\tour_id = ahc_inb(ahc, SCSIID) & OID;\n\n\tsaved_tcl = ahc_inb(ahc, SAVED_TCL);\n\tahc_compile_devinfo(devinfo, our_id, TCL_TARGET(saved_tcl),\n\t\t\t    TCL_LUN(saved_tcl), TCL_CHANNEL(ahc, saved_tcl),\n\t\t\t    role);\n}"
  },
  {
    "function_name": "ahc_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "1481-1536",
    "snippet": "int\nahc_attach(ahc)\n\tstruct ahc_softc *ahc;\n{\n\t/*\n\t * Initialize the software queue.\n\t */\n\tLIST_INIT(&ahc->sc_xxxq);\n\n#ifdef AHC_BROKEN_CACHE\n\tif (cpu_class == CPUCLASS_386)\t/* doesn't have \"wbinvd\" instruction */\n\t\tahc_broken_cache = 0;\n#endif\n\t/*\n\t * fill in the prototype scsi_links.\n\t */\n\tahc->sc_link.adapter_target = ahc->our_id;\n\tif (ahc->features & AHC_WIDE)\n\t\tahc->sc_link.adapter_buswidth = 16;\n\tahc->sc_link.adapter_softc = ahc;\n\tahc->sc_link.adapter = &ahc_switch;\n\tahc->sc_link.openings = 2;\n\tahc->sc_link.device = &ahc_dev;\n\tahc->sc_link.flags = SCSIDEBUG_LEVEL;\n\t\n\tif (ahc->features & AHC_TWIN) {\n\t\t/* Configure the second scsi bus */\n\t\tahc->sc_link_b = ahc->sc_link;\n\t\tahc->sc_link_b.adapter_target = ahc->our_id_b;\n\t\tif (ahc->features & AHC_WIDE)\n\t\t\tahc->sc_link.adapter_buswidth = 16;\n\t}\n\n\t/*\n\t * ask the adapter what subunits are present\n\t */\n\tif ((ahc->flags & AHC_CHANNEL_B_PRIMARY) == 0) {\n\t\t/* make IS_SCSIBUS_B() == false, while probing channel A */\n\t\tahc->sc_link_b.scsibus = 0xff;\n\n\t\tconfig_found((void *)ahc, &ahc->sc_link, scsiprint);\n\t\tif (ahc->features & AHC_TWIN)\n\t\t\tconfig_found((void *)ahc, &ahc->sc_link_b, scsiprint);\n\t} else {\n\t\t/*\n\t\t * if implementation of IS_SCSIBUS_B() is changed to use\n\t\t * ahc->sc_link.scsibus, then \"ahc->sc_link.scsibus = 0xff;\"\n\t\t * is needed, here.\n\t\t */\n\n\t\t/* assert(ahc->features & AHC_TWIN); */\n\t\tconfig_found((void *)ahc, &ahc->sc_link_b, scsiprint);\n\t\tconfig_found((void *)ahc, &ahc->sc_link, scsiprint);\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "ahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "ahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "static struct scsi_adapter ahc_switch =\n{\n\tahc_scsi_cmd,\n\tahcminphys,\n\t0,\n\t0,\n};",
      "static struct scsi_device ahc_dev =\n{\n\tNULL, /* Use default error handler */\n\tNULL, /* have a queue, served by this */\n\tNULL, /* have no async handler */\n\tNULL, /* Use default 'done' routine */\n};",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "char channel;",
      "u_int our_id;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "char channel;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "config_found",
          "args": [
            "(void *)ahc",
            "&ahc->sc_link",
            "scsiprint"
          ],
          "line": 1533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "config_found",
          "args": [
            "(void *)ahc",
            "&ahc->sc_link_b",
            "scsiprint"
          ],
          "line": 1532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "config_found",
          "args": [
            "(void *)ahc",
            "&ahc->sc_link_b",
            "scsiprint"
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "config_found",
          "args": [
            "(void *)ahc",
            "&ahc->sc_link",
            "scsiprint"
          ],
          "line": 1521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_INIT",
          "args": [
            "&ahc->sc_xxxq"
          ],
          "line": 1488
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC struct;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));\nahc_loadseq __P((struct ahc_softc *ahc));\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nahc_clear_intstat __P((struct ahc_softc *ahc));\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nrestart_sequencer __P((struct ahc_softc *ahc));\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic struct scsi_adapter ahc_switch =\n{\n\tahc_scsi_cmd,\n\tahcminphys,\n\t0,\n\t0,\n};\nstatic struct scsi_device ahc_dev =\n{\n\tNULL, /* Use default error handler */\n\tNULL, /* have a queue, served by this */\n\tNULL, /* have no async handler */\n\tNULL, /* Use default 'done' routine */\n};\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nu_int our_id;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nint\nahc_attach(ahc)\n\tstruct ahc_softc *ahc;\n{\n\t/*\n\t * Initialize the software queue.\n\t */\n\tLIST_INIT(&ahc->sc_xxxq);\n\n#ifdef AHC_BROKEN_CACHE\n\tif (cpu_class == CPUCLASS_386)\t/* doesn't have \"wbinvd\" instruction */\n\t\tahc_broken_cache = 0;\n#endif\n\t/*\n\t * fill in the prototype scsi_links.\n\t */\n\tahc->sc_link.adapter_target = ahc->our_id;\n\tif (ahc->features & AHC_WIDE)\n\t\tahc->sc_link.adapter_buswidth = 16;\n\tahc->sc_link.adapter_softc = ahc;\n\tahc->sc_link.adapter = &ahc_switch;\n\tahc->sc_link.openings = 2;\n\tahc->sc_link.device = &ahc_dev;\n\tahc->sc_link.flags = SCSIDEBUG_LEVEL;\n\t\n\tif (ahc->features & AHC_TWIN) {\n\t\t/* Configure the second scsi bus */\n\t\tahc->sc_link_b = ahc->sc_link;\n\t\tahc->sc_link_b.adapter_target = ahc->our_id_b;\n\t\tif (ahc->features & AHC_WIDE)\n\t\t\tahc->sc_link.adapter_buswidth = 16;\n\t}\n\n\t/*\n\t * ask the adapter what subunits are present\n\t */\n\tif ((ahc->flags & AHC_CHANNEL_B_PRIMARY) == 0) {\n\t\t/* make IS_SCSIBUS_B() == false, while probing channel A */\n\t\tahc->sc_link_b.scsibus = 0xff;\n\n\t\tconfig_found((void *)ahc, &ahc->sc_link, scsiprint);\n\t\tif (ahc->features & AHC_TWIN)\n\t\t\tconfig_found((void *)ahc, &ahc->sc_link_b, scsiprint);\n\t} else {\n\t\t/*\n\t\t * if implementation of IS_SCSIBUS_B() is changed to use\n\t\t * ahc->sc_link.scsibus, then \"ahc->sc_link.scsibus = 0xff;\"\n\t\t * is needed, here.\n\t\t */\n\n\t\t/* assert(ahc->features & AHC_TWIN); */\n\t\tconfig_found((void *)ahc, &ahc->sc_link_b, scsiprint);\n\t\tconfig_found((void *)ahc, &ahc->sc_link, scsiprint);\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "ahc_set_tags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "1459-1476",
    "snippet": "STATIC void\nahc_set_tags(ahc, devinfo, enable)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n\tint enable;\n{\n\tstruct ahc_initiator_tinfo *tinfo;\n\tstruct tmode_tstate *tstate;\n\n\ttinfo = ahc_fetch_transinfo(ahc, devinfo->channel,\n\t\t\t\t    devinfo->our_scsiid,\n\t\t\t\t    devinfo->target,\n\t\t\t\t    &tstate);\n\tif (enable)\n\t\ttstate->tagenable |= devinfo->target_mask;\n\telse\n\t\ttstate->tagenable &= ~devinfo->target_mask;\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define STATIC\tstatic",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
      "STATIC void",
      "STATIC void",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
      "STATIC void",
      "STATIC void",
      "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
      "STATIC int",
      "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
      "STATIC void",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
      "STATIC void",
      "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
      "STATIC void",
      "STATIC void",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_set_tags __P((struct ahc_softc *ahc,\n\t\t\t\t  struct ahc_devinfo *devinfo,int enable));",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "static __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "char channel;",
      "struct tmode_tstate **tstate;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "char channel;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ahc_fetch_transinfo",
          "args": [
            "ahc",
            "devinfo->channel",
            "devinfo->our_scsiid",
            "devinfo->target",
            "&tstate"
          ],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_set_tags __P((struct ahc_softc *ahc,\n\t\t\t\t  struct ahc_devinfo *devinfo,int enable));\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct tmode_tstate **tstate;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_set_tags(ahc, devinfo, enable)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n\tint enable;\n{\n\tstruct ahc_initiator_tinfo *tinfo;\n\tstruct tmode_tstate *tstate;\n\n\ttinfo = ahc_fetch_transinfo(ahc, devinfo->channel,\n\t\t\t\t    devinfo->our_scsiid,\n\t\t\t\t    devinfo->target,\n\t\t\t\t    &tstate);\n\tif (enable)\n\t\ttstate->tagenable |= devinfo->target_mask;\n\telse\n\t\ttstate->tagenable &= ~devinfo->target_mask;\n}"
  },
  {
    "function_name": "ahc_set_width",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "1408-1457",
    "snippet": "STATIC void\nahc_set_width(ahc, devinfo, width, type, paused, done)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n\tu_int width;\n\tu_int type;\n\tint paused;\n\tint done;\n{\n\tstruct ahc_initiator_tinfo *tinfo;\n\tstruct tmode_tstate *tstate;\n\tu_int  oldwidth;\n\tint    active = (type & AHC_TRANS_ACTIVE) == AHC_TRANS_ACTIVE;\n\n\ttinfo = ahc_fetch_transinfo(ahc, devinfo->channel,\n\t\t\t\t    devinfo->our_scsiid,\n\t\t\t\t    devinfo->target,\n\t\t\t\t    &tstate);\n\toldwidth = tinfo->current.width;\n\n\tif ((type & AHC_TRANS_CUR) != 0 && oldwidth != width) {\n\t\tu_int\tscsirate;\n\n\t\tscsirate =  tinfo->scsirate;\n\t\tscsirate &= ~WIDEXFER;\n\t\tif (width == MSG_EXT_WDTR_BUS_16_BIT)\n\t\t\tscsirate |= WIDEXFER;\n\n\t\ttinfo->scsirate = scsirate;\n\n\t\tif (active)\n\t\t\tahc_outb(ahc, SCSIRATE, scsirate);\n\n\t\ttinfo->current.width = width;\n\t}\n\n\tif (done) {\n\t\tprintf(\"%s: target %d using %dbit transfers\\n\",\n\t\t       ahc_name(ahc), devinfo->target,\n\t\t       8 * (0x01 << width));\n\t}\n\n\tif ((type & AHC_TRANS_GOAL) != 0)\n\t\ttinfo->goal.width = width;\n\tif ((type & AHC_TRANS_USER) != 0)\n\t\ttinfo->user.width = width;\n\n\tahc_update_target_msg_request(ahc, devinfo, tinfo,\n\t\t\t\t      /*force*/FALSE, paused);\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define STATIC\tstatic",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
      "STATIC void",
      "STATIC u_int",
      "STATIC void",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
      "STATIC void",
      "STATIC void",
      "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
      "STATIC int",
      "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
      "STATIC void",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
      "STATIC void",
      "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
      "STATIC void",
      "STATIC void",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC u_int",
      "STATIC void",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "STATIC u_int",
      "STATIC void",
      "STATIC void",
      "ahc_update_target_msg_request __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t\t      struct ahc_initiator_tinfo *tinfo,\n\t\t\t\t\t      int force, int paused));",
      "STATIC void",
      "ahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));",
      "STATIC void",
      "ahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "static __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "char channel;",
      "struct tmode_tstate **tstate;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "char channel;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ahc_update_target_msg_request",
          "args": [
            "ahc",
            "devinfo",
            "tinfo",
            "/*force*/FALSE",
            "paused"
          ],
          "line": 1455
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_update_target_msg_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "1250-1295",
          "snippet": "STATIC void\nahc_update_target_msg_request(ahc, devinfo, tinfo, force, paused)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n\tstruct ahc_initiator_tinfo *tinfo;\n\tint force;\n\tint paused;\n{\n\tu_int targ_msg_req_orig;\n\n\ttarg_msg_req_orig = ahc->targ_msg_req;\n\tif (tinfo->current.period != tinfo->goal.period\n\t    || tinfo->current.width != tinfo->goal.width\n\t    || tinfo->current.offset != tinfo->goal.offset\n\t    || (force && (tinfo->goal.period != 0\n\t    || tinfo->goal.width != MSG_EXT_WDTR_BUS_8_BIT)))\n\t\tahc->targ_msg_req |= devinfo->target_mask;\n\telse\n\t\tahc->targ_msg_req &= ~devinfo->target_mask;\n\n\tif (ahc->targ_msg_req != targ_msg_req_orig) {\n\t\t/* Update the message request bit for this target */\n\t\tif ((ahc->features & AHC_HS_MAILBOX) != 0) {\n\t\t\tif (paused) {\n\t\t\t\tahc_outb(ahc, TARGET_MSG_REQUEST,\n\t\t\t\t\t ahc->targ_msg_req & 0xFF);\n\t\t\t\tahc_outb(ahc, TARGET_MSG_REQUEST + 1,\n\t\t\t\t\t (ahc->targ_msg_req >> 8) & 0xFF);\n\t\t\t} else {\n\t\t\t\tahc_outb(ahc, HS_MAILBOX,\n\t\t\t\t\t 0x01 << HOST_MAILBOX_SHIFT);\n\t\t\t}\n\t\t} else {\n\t\t\tif (!paused)\n\t\t\t\tpause_sequencer(ahc);\n\n\t\t\tahc_outb(ahc, TARGET_MSG_REQUEST,\n\t\t\t\t ahc->targ_msg_req & 0xFF);\n\t\t\tahc_outb(ahc, TARGET_MSG_REQUEST + 1,\n\t\t\t\t (ahc->targ_msg_req >> 8) & 0xFF);\n\n\t\t\tif (!paused)\n\t\t\t\tunpause_sequencer(ahc);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC int",
            "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "ahc_update_target_msg_request __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t\t      struct ahc_initiator_tinfo *tinfo,\n\t\t\t\t\t      int force, int paused));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "static __inline void pause_sequencer",
            "static __inline void unpause_sequencer",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "u_int *period;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "u_int *period;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nahc_update_target_msg_request __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t\t      struct ahc_initiator_tinfo *tinfo,\n\t\t\t\t\t      int force, int paused));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nstatic __inline void pause_sequencer;\nstatic __inline void unpause_sequencer;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_update_target_msg_request(ahc, devinfo, tinfo, force, paused)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n\tstruct ahc_initiator_tinfo *tinfo;\n\tint force;\n\tint paused;\n{\n\tu_int targ_msg_req_orig;\n\n\ttarg_msg_req_orig = ahc->targ_msg_req;\n\tif (tinfo->current.period != tinfo->goal.period\n\t    || tinfo->current.width != tinfo->goal.width\n\t    || tinfo->current.offset != tinfo->goal.offset\n\t    || (force && (tinfo->goal.period != 0\n\t    || tinfo->goal.width != MSG_EXT_WDTR_BUS_8_BIT)))\n\t\tahc->targ_msg_req |= devinfo->target_mask;\n\telse\n\t\tahc->targ_msg_req &= ~devinfo->target_mask;\n\n\tif (ahc->targ_msg_req != targ_msg_req_orig) {\n\t\t/* Update the message request bit for this target */\n\t\tif ((ahc->features & AHC_HS_MAILBOX) != 0) {\n\t\t\tif (paused) {\n\t\t\t\tahc_outb(ahc, TARGET_MSG_REQUEST,\n\t\t\t\t\t ahc->targ_msg_req & 0xFF);\n\t\t\t\tahc_outb(ahc, TARGET_MSG_REQUEST + 1,\n\t\t\t\t\t (ahc->targ_msg_req >> 8) & 0xFF);\n\t\t\t} else {\n\t\t\t\tahc_outb(ahc, HS_MAILBOX,\n\t\t\t\t\t 0x01 << HOST_MAILBOX_SHIFT);\n\t\t\t}\n\t\t} else {\n\t\t\tif (!paused)\n\t\t\t\tpause_sequencer(ahc);\n\n\t\t\tahc_outb(ahc, TARGET_MSG_REQUEST,\n\t\t\t\t ahc->targ_msg_req & 0xFF);\n\t\t\tahc_outb(ahc, TARGET_MSG_REQUEST + 1,\n\t\t\t\t (ahc->targ_msg_req >> 8) & 0xFF);\n\n\t\t\tif (!paused)\n\t\t\t\tunpause_sequencer(ahc);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: target %d using %dbit transfers\\n\"",
            "ahc_name(ahc)",
            "devinfo->target",
            "8 * (0x01 << width)"
          ],
          "line": 1445
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 1446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCSIRATE",
            "scsirate"
          ],
          "line": 1439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_fetch_transinfo",
          "args": [
            "ahc",
            "devinfo->channel",
            "devinfo->our_scsiid",
            "devinfo->target",
            "&tstate"
          ],
          "line": 1422
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nahc_update_target_msg_request __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t\t      struct ahc_initiator_tinfo *tinfo,\n\t\t\t\t\t      int force, int paused));\nSTATIC void;\nahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));\nSTATIC void;\nahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct tmode_tstate **tstate;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_set_width(ahc, devinfo, width, type, paused, done)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n\tu_int width;\n\tu_int type;\n\tint paused;\n\tint done;\n{\n\tstruct ahc_initiator_tinfo *tinfo;\n\tstruct tmode_tstate *tstate;\n\tu_int  oldwidth;\n\tint    active = (type & AHC_TRANS_ACTIVE) == AHC_TRANS_ACTIVE;\n\n\ttinfo = ahc_fetch_transinfo(ahc, devinfo->channel,\n\t\t\t\t    devinfo->our_scsiid,\n\t\t\t\t    devinfo->target,\n\t\t\t\t    &tstate);\n\toldwidth = tinfo->current.width;\n\n\tif ((type & AHC_TRANS_CUR) != 0 && oldwidth != width) {\n\t\tu_int\tscsirate;\n\n\t\tscsirate =  tinfo->scsirate;\n\t\tscsirate &= ~WIDEXFER;\n\t\tif (width == MSG_EXT_WDTR_BUS_16_BIT)\n\t\t\tscsirate |= WIDEXFER;\n\n\t\ttinfo->scsirate = scsirate;\n\n\t\tif (active)\n\t\t\tahc_outb(ahc, SCSIRATE, scsirate);\n\n\t\ttinfo->current.width = width;\n\t}\n\n\tif (done) {\n\t\tprintf(\"%s: target %d using %dbit transfers\\n\",\n\t\t       ahc_name(ahc), devinfo->target,\n\t\t       8 * (0x01 << width));\n\t}\n\n\tif ((type & AHC_TRANS_GOAL) != 0)\n\t\ttinfo->goal.width = width;\n\tif ((type & AHC_TRANS_USER) != 0)\n\t\ttinfo->user.width = width;\n\n\tahc_update_target_msg_request(ahc, devinfo, tinfo,\n\t\t\t\t      /*force*/FALSE, paused);\n}"
  },
  {
    "function_name": "ahc_set_syncrate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "1297-1406",
    "snippet": "STATIC void\nahc_set_syncrate(ahc, devinfo, syncrate, period, offset, type, paused, done)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n\tstruct ahc_syncrate *syncrate;\n\tu_int period;\n\tu_int offset;\n\tu_int type;\n\tint paused;\n\tint done;\n{\n\tstruct\tahc_initiator_tinfo *tinfo;\n\tstruct\ttmode_tstate *tstate;\n\tu_int\told_period;\n\tu_int\told_offset;\n\tint\tactive = (type & AHC_TRANS_ACTIVE) == AHC_TRANS_ACTIVE;\n\n\tif (syncrate == NULL) {\n\t\tperiod = 0;\n\t\toffset = 0;\n\t}\n\n\ttinfo = ahc_fetch_transinfo(ahc, devinfo->channel,\n\t\t\t\t    devinfo->our_scsiid,\n\t\t\t\t    devinfo->target, &tstate);\n\told_period = tinfo->current.period;\n\told_offset = tinfo->current.offset;\n\n\tif ((type & AHC_TRANS_CUR) != 0\n\t && (old_period != period || old_offset != offset)) {\n\t\tu_int\tscsirate;\n\n\t\tscsirate = tinfo->scsirate;\n\t\tif ((ahc->features & AHC_ULTRA2) != 0) {\n\n\t\t\t/* XXX */\n\t\t\t/* Force single edge until DT is fully implemented */\n\t\t\tscsirate &= ~(SXFR_ULTRA2|SINGLE_EDGE|ENABLE_CRC);\n\t\t\tif (syncrate != NULL)\n\t\t\t\tscsirate |= syncrate->sxfr_u2|SINGLE_EDGE;\n\n\t\t\tif (active)\n\t\t\t\tahc_outb(ahc, SCSIOFFSET, offset);\n\t\t} else {\n\n\t\t\tscsirate &= ~(SXFR|SOFS);\n\t\t\t/*\n\t\t\t * Ensure Ultra mode is set properly for\n\t\t\t * this target.\n\t\t\t */\n\t\t\ttstate->ultraenb &= ~devinfo->target_mask;\n\t\t\tif (syncrate != NULL) {\n\t\t\t\tif (syncrate->sxfr & ULTRA_SXFR) {\n\t\t\t\t\ttstate->ultraenb |=\n\t\t\t\t\t\tdevinfo->target_mask;\n\t\t\t\t}\n\t\t\t\tscsirate |= syncrate->sxfr & SXFR;\n\t\t\t\tscsirate |= offset & SOFS;\n\t\t\t}\n\t\t\tif (active) {\n\t\t\t\tu_int sxfrctl0;\n\n\t\t\t\tsxfrctl0 = ahc_inb(ahc, SXFRCTL0);\n\t\t\t\tsxfrctl0 &= ~FAST20;\n\t\t\t\tif (tstate->ultraenb & devinfo->target_mask)\n\t\t\t\t\tsxfrctl0 |= FAST20;\n\t\t\t\tahc_outb(ahc, SXFRCTL0, sxfrctl0);\n\t\t\t}\n\t\t}\n\t\tif (active)\n\t\t\tahc_outb(ahc, SCSIRATE, scsirate);\n\n\t\ttinfo->scsirate = scsirate;\n\t\ttinfo->current.period = period;\n\t\ttinfo->current.offset = offset;\n\n\t\t/* Update the syncrates in any pending scbs */\n\t\tahc_update_pending_syncrates(ahc);\n\t}\n\n\t/*\n\t * Print messages if we're verbose and at the end of a negotiation\n\t * cycle.\n\t */\n\tif (done) {\n\t\tif (offset != 0) {\n\t\t\tprintf(\"%s: target %d synchronous at %sMHz, \"\n\t\t\t       \"offset = 0x%x\\n\", ahc_name(ahc),\n\t\t\t       devinfo->target, syncrate->rate, offset);\n\t\t} else {\n\t\t\tprintf(\"%s: target %d using \"\n\t\t\t       \"asynchronous transfers\\n\",\n\t\t\t       ahc_name(ahc), devinfo->target);\n\t\t}\n\t}\n\n\tif ((type & AHC_TRANS_GOAL) != 0) {\n\t\ttinfo->goal.period = period;\n\t\ttinfo->goal.offset = offset;\n\t}\n\n\tif ((type & AHC_TRANS_USER) != 0) {\n\t\ttinfo->user.period = period;\n\t\ttinfo->user.offset = offset;\n\t}\n\n\tahc_update_target_msg_request(ahc, devinfo, tinfo,\n\t\t\t\t      /*force*/FALSE,\n\t\t\t\t      paused);\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define STATIC\tstatic",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
      "STATIC void",
      "STATIC u_int",
      "STATIC void",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
      "STATIC void",
      "STATIC void",
      "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
      "STATIC int",
      "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
      "STATIC void",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
      "STATIC void",
      "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
      "STATIC void",
      "STATIC void",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC u_int",
      "STATIC void",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "STATIC u_int",
      "STATIC void",
      "STATIC void",
      "ahc_update_target_msg_request __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t\t      struct ahc_initiator_tinfo *tinfo,\n\t\t\t\t\t      int force, int paused));",
      "STATIC void",
      "ahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));",
      "STATIC void",
      "ahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "ahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "static __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "char channel;",
      "struct tmode_tstate **tstate;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "u_int *period;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "u_int *period;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "char channel;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ahc_update_target_msg_request",
          "args": [
            "ahc",
            "devinfo",
            "tinfo",
            "/*force*/FALSE",
            "paused"
          ],
          "line": 1403
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_update_target_msg_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "1250-1295",
          "snippet": "STATIC void\nahc_update_target_msg_request(ahc, devinfo, tinfo, force, paused)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n\tstruct ahc_initiator_tinfo *tinfo;\n\tint force;\n\tint paused;\n{\n\tu_int targ_msg_req_orig;\n\n\ttarg_msg_req_orig = ahc->targ_msg_req;\n\tif (tinfo->current.period != tinfo->goal.period\n\t    || tinfo->current.width != tinfo->goal.width\n\t    || tinfo->current.offset != tinfo->goal.offset\n\t    || (force && (tinfo->goal.period != 0\n\t    || tinfo->goal.width != MSG_EXT_WDTR_BUS_8_BIT)))\n\t\tahc->targ_msg_req |= devinfo->target_mask;\n\telse\n\t\tahc->targ_msg_req &= ~devinfo->target_mask;\n\n\tif (ahc->targ_msg_req != targ_msg_req_orig) {\n\t\t/* Update the message request bit for this target */\n\t\tif ((ahc->features & AHC_HS_MAILBOX) != 0) {\n\t\t\tif (paused) {\n\t\t\t\tahc_outb(ahc, TARGET_MSG_REQUEST,\n\t\t\t\t\t ahc->targ_msg_req & 0xFF);\n\t\t\t\tahc_outb(ahc, TARGET_MSG_REQUEST + 1,\n\t\t\t\t\t (ahc->targ_msg_req >> 8) & 0xFF);\n\t\t\t} else {\n\t\t\t\tahc_outb(ahc, HS_MAILBOX,\n\t\t\t\t\t 0x01 << HOST_MAILBOX_SHIFT);\n\t\t\t}\n\t\t} else {\n\t\t\tif (!paused)\n\t\t\t\tpause_sequencer(ahc);\n\n\t\t\tahc_outb(ahc, TARGET_MSG_REQUEST,\n\t\t\t\t ahc->targ_msg_req & 0xFF);\n\t\t\tahc_outb(ahc, TARGET_MSG_REQUEST + 1,\n\t\t\t\t (ahc->targ_msg_req >> 8) & 0xFF);\n\n\t\t\tif (!paused)\n\t\t\t\tunpause_sequencer(ahc);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC int",
            "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "ahc_update_target_msg_request __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t\t      struct ahc_initiator_tinfo *tinfo,\n\t\t\t\t\t      int force, int paused));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "static __inline void pause_sequencer",
            "static __inline void unpause_sequencer",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "u_int *period;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "u_int *period;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nahc_update_target_msg_request __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t\t      struct ahc_initiator_tinfo *tinfo,\n\t\t\t\t\t      int force, int paused));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nstatic __inline void pause_sequencer;\nstatic __inline void unpause_sequencer;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_update_target_msg_request(ahc, devinfo, tinfo, force, paused)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n\tstruct ahc_initiator_tinfo *tinfo;\n\tint force;\n\tint paused;\n{\n\tu_int targ_msg_req_orig;\n\n\ttarg_msg_req_orig = ahc->targ_msg_req;\n\tif (tinfo->current.period != tinfo->goal.period\n\t    || tinfo->current.width != tinfo->goal.width\n\t    || tinfo->current.offset != tinfo->goal.offset\n\t    || (force && (tinfo->goal.period != 0\n\t    || tinfo->goal.width != MSG_EXT_WDTR_BUS_8_BIT)))\n\t\tahc->targ_msg_req |= devinfo->target_mask;\n\telse\n\t\tahc->targ_msg_req &= ~devinfo->target_mask;\n\n\tif (ahc->targ_msg_req != targ_msg_req_orig) {\n\t\t/* Update the message request bit for this target */\n\t\tif ((ahc->features & AHC_HS_MAILBOX) != 0) {\n\t\t\tif (paused) {\n\t\t\t\tahc_outb(ahc, TARGET_MSG_REQUEST,\n\t\t\t\t\t ahc->targ_msg_req & 0xFF);\n\t\t\t\tahc_outb(ahc, TARGET_MSG_REQUEST + 1,\n\t\t\t\t\t (ahc->targ_msg_req >> 8) & 0xFF);\n\t\t\t} else {\n\t\t\t\tahc_outb(ahc, HS_MAILBOX,\n\t\t\t\t\t 0x01 << HOST_MAILBOX_SHIFT);\n\t\t\t}\n\t\t} else {\n\t\t\tif (!paused)\n\t\t\t\tpause_sequencer(ahc);\n\n\t\t\tahc_outb(ahc, TARGET_MSG_REQUEST,\n\t\t\t\t ahc->targ_msg_req & 0xFF);\n\t\t\tahc_outb(ahc, TARGET_MSG_REQUEST + 1,\n\t\t\t\t (ahc->targ_msg_req >> 8) & 0xFF);\n\n\t\t\tif (!paused)\n\t\t\t\tunpause_sequencer(ahc);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: target %d using \"\n\t\t\t       \"asynchronous transfers\\n\"",
            "ahc_name(ahc)",
            "devinfo->target"
          ],
          "line": 1387
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_update_pending_syncrates",
          "args": [
            "ahc"
          ],
          "line": 1374
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_update_pending_syncrates",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "5633-5722",
          "snippet": "STATIC void\nahc_update_pending_syncrates(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tstruct\tscb *scb;\n\tint\tpending_scb_count;\n\tint\ti;\n\tu_int\tsaved_scbptr;\n\n\t/*\n\t * Traverse the pending SCB list and ensure that all of the\n\t * SCBs there have the proper settings.\n\t */\n\tscb = LIST_FIRST(&ahc->pending_scbs);\n\tpending_scb_count = 0;\n\twhile (scb != NULL) {\n\t\tstruct ahc_devinfo devinfo;\n\t\tstruct scsi_xfer *xs;\n\t\tstruct scb *pending_scb;\n\t\tstruct hardware_scb *pending_hscb;\n\t\tstruct ahc_initiator_tinfo *tinfo;\n\t\tstruct tmode_tstate *tstate;\n\t\tu_int  our_id, remote_id;\n\t\t\n\t\txs = scb->xs;\n\t\tpending_scb = scb;\n\t\tpending_hscb = pending_scb->hscb;\n\t\tour_id = SCB_IS_SCSIBUS_B(pending_scb)\n\t\t       ? ahc->our_id_b : ahc->our_id;\n\t\tremote_id = xs->sc_link->target;\n\t\tahc_compile_devinfo(&devinfo, our_id, remote_id,\n\t\t\t\t    SCB_LUN(pending_scb),\n\t\t\t\t    SCB_CHANNEL(pending_scb),\n\t\t\t\t    ROLE_UNKNOWN);\n\t\ttinfo = ahc_fetch_transinfo(ahc, devinfo.channel,\n\t\t\t\t\t    our_id, remote_id, &tstate);\n\t\tpending_hscb->control &= ~ULTRAENB;\n\t\tif ((tstate->ultraenb & devinfo.target_mask) != 0)\n\t\t\tpending_hscb->control |= ULTRAENB;\n\t\tpending_hscb->scsirate = tinfo->scsirate;\n\t\tpending_hscb->scsioffset = tinfo->current.offset;\n\t\tpending_scb_count++;\n\t\tscb = LIST_NEXT(scb, pend_links);\n\t}\n\n\tif (pending_scb_count == 0)\n\t\treturn;\n\n\tsaved_scbptr = ahc_inb(ahc, SCBPTR);\n\t/* Ensure that the hscbs down on the card match the new information */\n\tfor (i = 0; i < ahc->scb_data->maxhscbs; i++) {\n\t\tu_int scb_tag;\n\n\t\tahc_outb(ahc, SCBPTR, i);\n\t\tscb_tag = ahc_inb(ahc, SCB_TAG);\n\t\tif (scb_tag != SCB_LIST_NULL) {\n\t\t\tstruct\tahc_devinfo devinfo;\n\t\t\tstruct\tscb *pending_scb;\n\t\t\tstruct scsi_xfer *xs;\n\t\t\tstruct\thardware_scb *pending_hscb;\n\t\t\tstruct\tahc_initiator_tinfo *tinfo;\n\t\t\tstruct\ttmode_tstate *tstate;\n\t\t\tu_int\tour_id, remote_id;\n\t\t\tu_int\tcontrol;\n\n\t\t\tpending_scb = &ahc->scb_data->scbarray[scb_tag];\n\t\t\tif (pending_scb->flags == SCB_FREE)\n\t\t\t\tcontinue;\n\t\t\tpending_hscb = pending_scb->hscb;\n\t\t\txs = pending_scb->xs;\n\t\t\tour_id = SCB_IS_SCSIBUS_B(pending_scb)\n\t\t\t       ? ahc->our_id_b : ahc->our_id;\n\t\t\tremote_id = xs->sc_link->target;\n\t\t\tahc_compile_devinfo(&devinfo, our_id, remote_id,\n\t\t\t\t\t    SCB_LUN(pending_scb),\n\t\t\t\t\t    SCB_CHANNEL(pending_scb),\n\t\t\t\t\t    ROLE_UNKNOWN);\n\t\t\ttinfo = ahc_fetch_transinfo(ahc, devinfo.channel,\n\t\t\t\t\t\t    our_id, remote_id, &tstate);\n\t\t\tcontrol = ahc_inb(ahc, SCB_CONTROL);\n\t\t\tcontrol &= ~ULTRAENB;\n\t\t\tif ((tstate->ultraenb & devinfo.target_mask) != 0)\n\t\t\t\tcontrol |= ULTRAENB;\n\t\t\tahc_outb(ahc, SCB_CONTROL, control);\n\t\t\tahc_outb(ahc, SCB_SCSIRATE, tinfo->scsirate);\n\t\t\tahc_outb(ahc, SCB_SCSIOFFSET, tinfo->current.offset);\n\t\t}\n\t}\n\tahc_outb(ahc, SCBPTR, saved_scbptr);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
            "STATIC void",
            "ahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
            "STATIC void",
            "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC int",
            "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));",
            "STATIC int",
            "STATIC int",
            "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
            "STATIC void",
            "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
            "STATIC void",
            "ahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));",
            "STATIC void",
            "STATIC void",
            "ahc_calc_residual __P((struct scb *scb));",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "static __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo",
            "STATIC void",
            "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "u_int our_id;",
            "u_int remote_id;",
            "struct tmode_tstate **tstate;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *xs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nSTATIC void;\nahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));\nSTATIC int;\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nSTATIC void;\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nSTATIC void;\nahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));\nSTATIC void;\nSTATIC void;\nahc_calc_residual __P((struct scb *scb));\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo;\nSTATIC void;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nu_int our_id;\nu_int remote_id;\nstruct tmode_tstate **tstate;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n\nSTATIC void\nahc_update_pending_syncrates(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tstruct\tscb *scb;\n\tint\tpending_scb_count;\n\tint\ti;\n\tu_int\tsaved_scbptr;\n\n\t/*\n\t * Traverse the pending SCB list and ensure that all of the\n\t * SCBs there have the proper settings.\n\t */\n\tscb = LIST_FIRST(&ahc->pending_scbs);\n\tpending_scb_count = 0;\n\twhile (scb != NULL) {\n\t\tstruct ahc_devinfo devinfo;\n\t\tstruct scsi_xfer *xs;\n\t\tstruct scb *pending_scb;\n\t\tstruct hardware_scb *pending_hscb;\n\t\tstruct ahc_initiator_tinfo *tinfo;\n\t\tstruct tmode_tstate *tstate;\n\t\tu_int  our_id, remote_id;\n\t\t\n\t\txs = scb->xs;\n\t\tpending_scb = scb;\n\t\tpending_hscb = pending_scb->hscb;\n\t\tour_id = SCB_IS_SCSIBUS_B(pending_scb)\n\t\t       ? ahc->our_id_b : ahc->our_id;\n\t\tremote_id = xs->sc_link->target;\n\t\tahc_compile_devinfo(&devinfo, our_id, remote_id,\n\t\t\t\t    SCB_LUN(pending_scb),\n\t\t\t\t    SCB_CHANNEL(pending_scb),\n\t\t\t\t    ROLE_UNKNOWN);\n\t\ttinfo = ahc_fetch_transinfo(ahc, devinfo.channel,\n\t\t\t\t\t    our_id, remote_id, &tstate);\n\t\tpending_hscb->control &= ~ULTRAENB;\n\t\tif ((tstate->ultraenb & devinfo.target_mask) != 0)\n\t\t\tpending_hscb->control |= ULTRAENB;\n\t\tpending_hscb->scsirate = tinfo->scsirate;\n\t\tpending_hscb->scsioffset = tinfo->current.offset;\n\t\tpending_scb_count++;\n\t\tscb = LIST_NEXT(scb, pend_links);\n\t}\n\n\tif (pending_scb_count == 0)\n\t\treturn;\n\n\tsaved_scbptr = ahc_inb(ahc, SCBPTR);\n\t/* Ensure that the hscbs down on the card match the new information */\n\tfor (i = 0; i < ahc->scb_data->maxhscbs; i++) {\n\t\tu_int scb_tag;\n\n\t\tahc_outb(ahc, SCBPTR, i);\n\t\tscb_tag = ahc_inb(ahc, SCB_TAG);\n\t\tif (scb_tag != SCB_LIST_NULL) {\n\t\t\tstruct\tahc_devinfo devinfo;\n\t\t\tstruct\tscb *pending_scb;\n\t\t\tstruct scsi_xfer *xs;\n\t\t\tstruct\thardware_scb *pending_hscb;\n\t\t\tstruct\tahc_initiator_tinfo *tinfo;\n\t\t\tstruct\ttmode_tstate *tstate;\n\t\t\tu_int\tour_id, remote_id;\n\t\t\tu_int\tcontrol;\n\n\t\t\tpending_scb = &ahc->scb_data->scbarray[scb_tag];\n\t\t\tif (pending_scb->flags == SCB_FREE)\n\t\t\t\tcontinue;\n\t\t\tpending_hscb = pending_scb->hscb;\n\t\t\txs = pending_scb->xs;\n\t\t\tour_id = SCB_IS_SCSIBUS_B(pending_scb)\n\t\t\t       ? ahc->our_id_b : ahc->our_id;\n\t\t\tremote_id = xs->sc_link->target;\n\t\t\tahc_compile_devinfo(&devinfo, our_id, remote_id,\n\t\t\t\t\t    SCB_LUN(pending_scb),\n\t\t\t\t\t    SCB_CHANNEL(pending_scb),\n\t\t\t\t\t    ROLE_UNKNOWN);\n\t\t\ttinfo = ahc_fetch_transinfo(ahc, devinfo.channel,\n\t\t\t\t\t\t    our_id, remote_id, &tstate);\n\t\t\tcontrol = ahc_inb(ahc, SCB_CONTROL);\n\t\t\tcontrol &= ~ULTRAENB;\n\t\t\tif ((tstate->ultraenb & devinfo.target_mask) != 0)\n\t\t\t\tcontrol |= ULTRAENB;\n\t\t\tahc_outb(ahc, SCB_CONTROL, control);\n\t\t\tahc_outb(ahc, SCB_SCSIRATE, tinfo->scsirate);\n\t\t\tahc_outb(ahc, SCB_SCSIOFFSET, tinfo->current.offset);\n\t\t}\n\t}\n\tahc_outb(ahc, SCBPTR, saved_scbptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCSIRATE",
            "scsirate"
          ],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SXFRCTL0",
            "sxfrctl0"
          ],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SXFRCTL0"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCSIOFFSET",
            "offset"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_fetch_transinfo",
          "args": [
            "ahc",
            "devinfo->channel",
            "devinfo->our_scsiid",
            "devinfo->target",
            "&tstate"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nahc_update_target_msg_request __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t\t      struct ahc_initiator_tinfo *tinfo,\n\t\t\t\t\t      int force, int paused));\nSTATIC void;\nahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));\nSTATIC void;\nahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct tmode_tstate **tstate;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_set_syncrate(ahc, devinfo, syncrate, period, offset, type, paused, done)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n\tstruct ahc_syncrate *syncrate;\n\tu_int period;\n\tu_int offset;\n\tu_int type;\n\tint paused;\n\tint done;\n{\n\tstruct\tahc_initiator_tinfo *tinfo;\n\tstruct\ttmode_tstate *tstate;\n\tu_int\told_period;\n\tu_int\told_offset;\n\tint\tactive = (type & AHC_TRANS_ACTIVE) == AHC_TRANS_ACTIVE;\n\n\tif (syncrate == NULL) {\n\t\tperiod = 0;\n\t\toffset = 0;\n\t}\n\n\ttinfo = ahc_fetch_transinfo(ahc, devinfo->channel,\n\t\t\t\t    devinfo->our_scsiid,\n\t\t\t\t    devinfo->target, &tstate);\n\told_period = tinfo->current.period;\n\told_offset = tinfo->current.offset;\n\n\tif ((type & AHC_TRANS_CUR) != 0\n\t && (old_period != period || old_offset != offset)) {\n\t\tu_int\tscsirate;\n\n\t\tscsirate = tinfo->scsirate;\n\t\tif ((ahc->features & AHC_ULTRA2) != 0) {\n\n\t\t\t/* XXX */\n\t\t\t/* Force single edge until DT is fully implemented */\n\t\t\tscsirate &= ~(SXFR_ULTRA2|SINGLE_EDGE|ENABLE_CRC);\n\t\t\tif (syncrate != NULL)\n\t\t\t\tscsirate |= syncrate->sxfr_u2|SINGLE_EDGE;\n\n\t\t\tif (active)\n\t\t\t\tahc_outb(ahc, SCSIOFFSET, offset);\n\t\t} else {\n\n\t\t\tscsirate &= ~(SXFR|SOFS);\n\t\t\t/*\n\t\t\t * Ensure Ultra mode is set properly for\n\t\t\t * this target.\n\t\t\t */\n\t\t\ttstate->ultraenb &= ~devinfo->target_mask;\n\t\t\tif (syncrate != NULL) {\n\t\t\t\tif (syncrate->sxfr & ULTRA_SXFR) {\n\t\t\t\t\ttstate->ultraenb |=\n\t\t\t\t\t\tdevinfo->target_mask;\n\t\t\t\t}\n\t\t\t\tscsirate |= syncrate->sxfr & SXFR;\n\t\t\t\tscsirate |= offset & SOFS;\n\t\t\t}\n\t\t\tif (active) {\n\t\t\t\tu_int sxfrctl0;\n\n\t\t\t\tsxfrctl0 = ahc_inb(ahc, SXFRCTL0);\n\t\t\t\tsxfrctl0 &= ~FAST20;\n\t\t\t\tif (tstate->ultraenb & devinfo->target_mask)\n\t\t\t\t\tsxfrctl0 |= FAST20;\n\t\t\t\tahc_outb(ahc, SXFRCTL0, sxfrctl0);\n\t\t\t}\n\t\t}\n\t\tif (active)\n\t\t\tahc_outb(ahc, SCSIRATE, scsirate);\n\n\t\ttinfo->scsirate = scsirate;\n\t\ttinfo->current.period = period;\n\t\ttinfo->current.offset = offset;\n\n\t\t/* Update the syncrates in any pending scbs */\n\t\tahc_update_pending_syncrates(ahc);\n\t}\n\n\t/*\n\t * Print messages if we're verbose and at the end of a negotiation\n\t * cycle.\n\t */\n\tif (done) {\n\t\tif (offset != 0) {\n\t\t\tprintf(\"%s: target %d synchronous at %sMHz, \"\n\t\t\t       \"offset = 0x%x\\n\", ahc_name(ahc),\n\t\t\t       devinfo->target, syncrate->rate, offset);\n\t\t} else {\n\t\t\tprintf(\"%s: target %d using \"\n\t\t\t       \"asynchronous transfers\\n\",\n\t\t\t       ahc_name(ahc), devinfo->target);\n\t\t}\n\t}\n\n\tif ((type & AHC_TRANS_GOAL) != 0) {\n\t\ttinfo->goal.period = period;\n\t\ttinfo->goal.offset = offset;\n\t}\n\n\tif ((type & AHC_TRANS_USER) != 0) {\n\t\ttinfo->user.period = period;\n\t\ttinfo->user.offset = offset;\n\t}\n\n\tahc_update_target_msg_request(ahc, devinfo, tinfo,\n\t\t\t\t      /*force*/FALSE,\n\t\t\t\t      paused);\n}"
  },
  {
    "function_name": "ahc_update_target_msg_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "1250-1295",
    "snippet": "STATIC void\nahc_update_target_msg_request(ahc, devinfo, tinfo, force, paused)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n\tstruct ahc_initiator_tinfo *tinfo;\n\tint force;\n\tint paused;\n{\n\tu_int targ_msg_req_orig;\n\n\ttarg_msg_req_orig = ahc->targ_msg_req;\n\tif (tinfo->current.period != tinfo->goal.period\n\t    || tinfo->current.width != tinfo->goal.width\n\t    || tinfo->current.offset != tinfo->goal.offset\n\t    || (force && (tinfo->goal.period != 0\n\t    || tinfo->goal.width != MSG_EXT_WDTR_BUS_8_BIT)))\n\t\tahc->targ_msg_req |= devinfo->target_mask;\n\telse\n\t\tahc->targ_msg_req &= ~devinfo->target_mask;\n\n\tif (ahc->targ_msg_req != targ_msg_req_orig) {\n\t\t/* Update the message request bit for this target */\n\t\tif ((ahc->features & AHC_HS_MAILBOX) != 0) {\n\t\t\tif (paused) {\n\t\t\t\tahc_outb(ahc, TARGET_MSG_REQUEST,\n\t\t\t\t\t ahc->targ_msg_req & 0xFF);\n\t\t\t\tahc_outb(ahc, TARGET_MSG_REQUEST + 1,\n\t\t\t\t\t (ahc->targ_msg_req >> 8) & 0xFF);\n\t\t\t} else {\n\t\t\t\tahc_outb(ahc, HS_MAILBOX,\n\t\t\t\t\t 0x01 << HOST_MAILBOX_SHIFT);\n\t\t\t}\n\t\t} else {\n\t\t\tif (!paused)\n\t\t\t\tpause_sequencer(ahc);\n\n\t\t\tahc_outb(ahc, TARGET_MSG_REQUEST,\n\t\t\t\t ahc->targ_msg_req & 0xFF);\n\t\t\tahc_outb(ahc, TARGET_MSG_REQUEST + 1,\n\t\t\t\t (ahc->targ_msg_req >> 8) & 0xFF);\n\n\t\t\tif (!paused)\n\t\t\t\tunpause_sequencer(ahc);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define STATIC\tstatic",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
      "STATIC void",
      "STATIC u_int",
      "STATIC void",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
      "STATIC void",
      "STATIC void",
      "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
      "STATIC int",
      "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
      "STATIC void",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
      "STATIC void",
      "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
      "STATIC void",
      "STATIC void",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC u_int",
      "STATIC void",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "STATIC u_int",
      "STATIC void",
      "STATIC void",
      "ahc_update_target_msg_request __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t\t      struct ahc_initiator_tinfo *tinfo,\n\t\t\t\t\t      int force, int paused));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "ahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "static __inline void pause_sequencer",
      "static __inline void unpause_sequencer",
      "STATIC void",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "u_int *period;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "u_int *period;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unpause_sequencer",
          "args": [
            "ahc"
          ],
          "line": 1292
        },
        "resolved": true,
        "details": {
          "function_name": "unpause_sequencer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "456-462",
          "snippet": "static __inline void\nunpause_sequencer(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tif ((ahc_inb(ahc, INTSTAT) & (SCSIINT | SEQINT | BRKADRINT)) == 0)\n\t\tahc_outb(ahc, HCNTRL, ahc->unpause);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "static __inline void unpause_sequencer",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC struct;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nahc_loadseq __P((struct ahc_softc *ahc));\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nahc_clear_intstat __P((struct ahc_softc *ahc));\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nstatic __inline void unpause_sequencer;\nrestart_sequencer __P((struct ahc_softc *ahc));\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nstatic __inline void\nunpause_sequencer(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tif ((ahc_inb(ahc, INTSTAT) & (SCSIINT | SEQINT | BRKADRINT)) == 0)\n\t\tahc_outb(ahc, HCNTRL, ahc->unpause);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "TARGET_MSG_REQUEST + 1",
            "(ahc->targ_msg_req >> 8) & 0xFF"
          ],
          "line": 1288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "TARGET_MSG_REQUEST",
            "ahc->targ_msg_req & 0xFF"
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "HS_MAILBOX",
            "0x01 << HOST_MAILBOX_SHIFT"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "TARGET_MSG_REQUEST + 1",
            "(ahc->targ_msg_req >> 8) & 0xFF"
          ],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "TARGET_MSG_REQUEST",
            "ahc->targ_msg_req & 0xFF"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nahc_update_target_msg_request __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t\t      struct ahc_initiator_tinfo *tinfo,\n\t\t\t\t\t      int force, int paused));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nstatic __inline void pause_sequencer;\nstatic __inline void unpause_sequencer;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_update_target_msg_request(ahc, devinfo, tinfo, force, paused)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_devinfo *devinfo;\n\tstruct ahc_initiator_tinfo *tinfo;\n\tint force;\n\tint paused;\n{\n\tu_int targ_msg_req_orig;\n\n\ttarg_msg_req_orig = ahc->targ_msg_req;\n\tif (tinfo->current.period != tinfo->goal.period\n\t    || tinfo->current.width != tinfo->goal.width\n\t    || tinfo->current.offset != tinfo->goal.offset\n\t    || (force && (tinfo->goal.period != 0\n\t    || tinfo->goal.width != MSG_EXT_WDTR_BUS_8_BIT)))\n\t\tahc->targ_msg_req |= devinfo->target_mask;\n\telse\n\t\tahc->targ_msg_req &= ~devinfo->target_mask;\n\n\tif (ahc->targ_msg_req != targ_msg_req_orig) {\n\t\t/* Update the message request bit for this target */\n\t\tif ((ahc->features & AHC_HS_MAILBOX) != 0) {\n\t\t\tif (paused) {\n\t\t\t\tahc_outb(ahc, TARGET_MSG_REQUEST,\n\t\t\t\t\t ahc->targ_msg_req & 0xFF);\n\t\t\t\tahc_outb(ahc, TARGET_MSG_REQUEST + 1,\n\t\t\t\t\t (ahc->targ_msg_req >> 8) & 0xFF);\n\t\t\t} else {\n\t\t\t\tahc_outb(ahc, HS_MAILBOX,\n\t\t\t\t\t 0x01 << HOST_MAILBOX_SHIFT);\n\t\t\t}\n\t\t} else {\n\t\t\tif (!paused)\n\t\t\t\tpause_sequencer(ahc);\n\n\t\t\tahc_outb(ahc, TARGET_MSG_REQUEST,\n\t\t\t\t ahc->targ_msg_req & 0xFF);\n\t\t\tahc_outb(ahc, TARGET_MSG_REQUEST + 1,\n\t\t\t\t (ahc->targ_msg_req >> 8) & 0xFF);\n\n\t\t\tif (!paused)\n\t\t\t\tunpause_sequencer(ahc);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "ahc_validate_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "1227-1248",
    "snippet": "STATIC void\nahc_validate_offset(ahc, syncrate, offset, wide)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_syncrate *syncrate;\n\tu_int *offset;\n\tint wide;\n{\n\tu_int maxoffset;\n\n\t/* Limit offset to what we can do */\n\tif (syncrate == NULL) {\n\t\tmaxoffset = 0;\n\t} else if ((ahc->features & AHC_ULTRA2) != 0) {\n\t\tmaxoffset = MAX_OFFSET_ULTRA2;\n\t} else {\n\t\tif (wide)\n\t\t\tmaxoffset = MAX_OFFSET_16BIT;\n\t\telse\n\t\t\tmaxoffset = MAX_OFFSET_8BIT;\n\t}\n\t*offset = MIN(*offset, maxoffset);\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define STATIC\tstatic",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC u_int",
      "STATIC void",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC u_int",
      "STATIC void",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "STATIC u_int",
      "STATIC void",
      "ahc_validate_offset __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct ahc_syncrate *syncrate,\n\t\t\t\t\t u_int *offset, int wide));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "ahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MIN",
          "args": [
            "*offset",
            "maxoffset"
          ],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nahc_validate_offset __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct ahc_syncrate *syncrate,\n\t\t\t\t\t u_int *offset, int wide));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_validate_offset(ahc, syncrate, offset, wide)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_syncrate *syncrate;\n\tu_int *offset;\n\tint wide;\n{\n\tu_int maxoffset;\n\n\t/* Limit offset to what we can do */\n\tif (syncrate == NULL) {\n\t\tmaxoffset = 0;\n\t} else if ((ahc->features & AHC_ULTRA2) != 0) {\n\t\tmaxoffset = MAX_OFFSET_ULTRA2;\n\t} else {\n\t\tif (wide)\n\t\t\tmaxoffset = MAX_OFFSET_16BIT;\n\t\telse\n\t\t\tmaxoffset = MAX_OFFSET_8BIT;\n\t}\n\t*offset = MIN(*offset, maxoffset);\n}"
  },
  {
    "function_name": "ahc_find_period",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "1198-1225",
    "snippet": "STATIC u_int\nahc_find_period(ahc, scsirate, maxsync)\n\tstruct ahc_softc *ahc;\n\tu_int scsirate;\n\tu_int maxsync;\n{\n\tstruct ahc_syncrate *syncrate;\n\n\tif ((ahc->features & AHC_ULTRA2) != 0)\n\t\tscsirate &= SXFR_ULTRA2;\n\telse\n\t\tscsirate &= SXFR;\n\n\tsyncrate = &ahc_syncrates[maxsync];\n\twhile (syncrate->rate != NULL) {\n\n\t\tif ((ahc->features & AHC_ULTRA2) != 0) {\n\t\t\tif (syncrate->sxfr_u2 == 0)\n\t\t\t\tbreak;\n\t\t\telse if (scsirate == (syncrate->sxfr_u2 & SXFR_ULTRA2))\n\t\t\t\treturn (syncrate->period);\n\t\t} else if (scsirate == (syncrate->sxfr & SXFR)) {\n\t\t\t\treturn (syncrate->period);\n\t\t}\n\t\tsyncrate++;\n\t}\n\treturn (0); /* async */\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define STATIC\tstatic",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC u_int",
      "STATIC void",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC u_int",
      "STATIC void",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "STATIC u_int",
      "ahc_find_period __P((struct ahc_softc *ahc, u_int scsirate,\n\t\t\t\t  u_int maxsync));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "static struct ahc_syncrate ahc_syncrates[] = {\n      /* ultra2    fast/ultra  period     rate */\n\t{ 0x42,      0x000,      9,      \"80.0\" },\n\t{ 0x03,      0x000,     10,      \"40.0\" },\n\t{ 0x04,      0x000,     11,      \"33.0\" },\n\t{ 0x05,      0x100,     12,      \"20.0\" },\n\t{ 0x06,      0x110,     15,      \"16.0\" },\n\t{ 0x07,      0x120,     18,      \"13.4\" },\n\t{ 0x08,      0x000,     25,      \"10.0\" },\n\t{ 0x19,      0x010,     31,      \"8.0\"  },\n\t{ 0x1a,      0x020,     37,      \"6.67\" },\n\t{ 0x1b,      0x030,     43,      \"5.7\"  },\n\t{ 0x1c,      0x040,     50,      \"5.0\"  },\n\t{ 0x00,      0x050,     56,      \"4.4\"  },\n\t{ 0x00,      0x060,     62,      \"4.0\"  },\n\t{ 0x00,      0x070,     68,      \"3.6\"  },\n\t{ 0x00,      0x000,      0,      NULL   }\n};",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "u_int *period;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "u_int *period;",
      "u_int maxsync;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nahc_find_period __P((struct ahc_softc *ahc, u_int scsirate,\n\t\t\t\t  u_int maxsync));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nstatic struct ahc_syncrate ahc_syncrates[] = {\n      /* ultra2    fast/ultra  period     rate */\n\t{ 0x42,      0x000,      9,      \"80.0\" },\n\t{ 0x03,      0x000,     10,      \"40.0\" },\n\t{ 0x04,      0x000,     11,      \"33.0\" },\n\t{ 0x05,      0x100,     12,      \"20.0\" },\n\t{ 0x06,      0x110,     15,      \"16.0\" },\n\t{ 0x07,      0x120,     18,      \"13.4\" },\n\t{ 0x08,      0x000,     25,      \"10.0\" },\n\t{ 0x19,      0x010,     31,      \"8.0\"  },\n\t{ 0x1a,      0x020,     37,      \"6.67\" },\n\t{ 0x1b,      0x030,     43,      \"5.7\"  },\n\t{ 0x1c,      0x040,     50,      \"5.0\"  },\n\t{ 0x00,      0x050,     56,      \"4.4\"  },\n\t{ 0x00,      0x060,     62,      \"4.0\"  },\n\t{ 0x00,      0x070,     68,      \"3.6\"  },\n\t{ 0x00,      0x000,      0,      NULL   }\n};\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nu_int *period;\nu_int maxsync;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC u_int\nahc_find_period(ahc, scsirate, maxsync)\n\tstruct ahc_softc *ahc;\n\tu_int scsirate;\n\tu_int maxsync;\n{\n\tstruct ahc_syncrate *syncrate;\n\n\tif ((ahc->features & AHC_ULTRA2) != 0)\n\t\tscsirate &= SXFR_ULTRA2;\n\telse\n\t\tscsirate &= SXFR;\n\n\tsyncrate = &ahc_syncrates[maxsync];\n\twhile (syncrate->rate != NULL) {\n\n\t\tif ((ahc->features & AHC_ULTRA2) != 0) {\n\t\t\tif (syncrate->sxfr_u2 == 0)\n\t\t\t\tbreak;\n\t\t\telse if (scsirate == (syncrate->sxfr_u2 & SXFR_ULTRA2))\n\t\t\t\treturn (syncrate->period);\n\t\t} else if (scsirate == (syncrate->sxfr & SXFR)) {\n\t\t\t\treturn (syncrate->period);\n\t\t}\n\t\tsyncrate++;\n\t}\n\treturn (0); /* async */\n}"
  },
  {
    "function_name": "ahc_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "1073-1121",
    "snippet": "int\nahc_reset(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tu_int\tsblkctl;\n\tint\twait;\n\t\n#ifdef AHC_DUMP_SEQ\n\tif (ahc->init_level == 0)\n\t\tahc_dumpseq(ahc);\n#endif\n\tahc_outb(ahc, HCNTRL, CHIPRST | ahc->pause);\n\t/*\n\t * Ensure that the reset has finished\n\t */\n\twait = 1000;\n\tdo {\n\t\tDELAY(1000);\n\t} while (--wait && !(ahc_inb(ahc, HCNTRL) & CHIPRSTACK));\n\n\tif (wait == 0) {\n\t\tprintf(\"%s: WARNING - Failed chip reset!  \"\n\t\t       \"Trying to initialize anyway.\\n\", ahc_name(ahc));\n\t}\n\tahc_outb(ahc, HCNTRL, ahc->pause);\n\n\t/* Determine channel configuration */\n\tsblkctl = ahc_inb(ahc, SBLKCTL) & (SELBUSB|SELWIDE);\n\t/* No Twin Channel PCI cards */\n\tif ((ahc->chip & AHC_PCI) != 0)\n\t\tsblkctl &= ~SELBUSB;\n\tswitch (sblkctl) {\n\tcase 0:\n\t\t/* Single Narrow Channel */\n\t\tbreak;\n\tcase 2:\n\t\t/* Wide Channel */\n\t\tahc->features |= AHC_WIDE;\n\t\tbreak;\n\tcase 8:\n\t\t/* Twin Channel */\n\t\tahc->features |= AHC_TWIN;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\" Unsupported adapter type.  Ignoring\\n\");\n\t\treturn(-1);\n\t}\n\treturn (0);\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "ahc_poll __P((struct ahc_softc *ahc, int wait));",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC u_int",
      "STATIC struct",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "STATIC u_int",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "STATIC u_int",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "char channel;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "char channel;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" Unsupported adapter type.  Ignoring\\n\""
          ],
          "line": 1117
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SBLKCTL"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "HCNTRL",
            "ahc->pause"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "HCNTRL"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1000"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "HCNTRL",
            "CHIPRST | ahc->pause"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_dumpseq",
          "args": [
            "ahc"
          ],
          "line": 1082
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_dumpseq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "4528-4554",
          "snippet": "STATIC void\nahc_dumpseq(ahc)\n\tstruct ahc_softc* ahc;\n{\n\tint i;\n\tint max_prog;\n\n\tif ((ahc->chip & AHC_BUS_MASK) < AHC_PCI)\n\t\tmax_prog = 448;\n\telse if ((ahc->features & AHC_ULTRA2) != 0)\n\t\tmax_prog = 768;\n\telse\n\t\tmax_prog = 512;\n\n\tahc_outb(ahc, SEQCTL, PERRORDIS|FAILDIS|FASTMODE|LOADRAM);\n\tahc_outb(ahc, SEQADDR0, 0);\n\tahc_outb(ahc, SEQADDR1, 0);\n\tfor (i = 0; i < max_prog; i++) {\n\t\tu_int8_t ins_bytes[4];\n\n\t\tahc_insb(ahc, SEQRAM, ins_bytes, 4);\n\t\tprintf(\"0x%08x\\n\", ins_bytes[0] << 24\n\t\t\t\t | ins_bytes[1] << 16\n\t\t\t\t | ins_bytes[2] << 8\n\t\t\t\t | ins_bytes[3]);\n\t}\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_dumpseq(ahc)\n\tstruct ahc_softc* ahc;\n{\n\tint i;\n\tint max_prog;\n\n\tif ((ahc->chip & AHC_BUS_MASK) < AHC_PCI)\n\t\tmax_prog = 448;\n\telse if ((ahc->features & AHC_ULTRA2) != 0)\n\t\tmax_prog = 768;\n\telse\n\t\tmax_prog = 512;\n\n\tahc_outb(ahc, SEQCTL, PERRORDIS|FAILDIS|FASTMODE|LOADRAM);\n\tahc_outb(ahc, SEQADDR0, 0);\n\tahc_outb(ahc, SEQADDR1, 0);\n\tfor (i = 0; i < max_prog; i++) {\n\t\tu_int8_t ins_bytes[4];\n\n\t\tahc_insb(ahc, SEQRAM, ins_bytes, 4);\n\t\tprintf(\"0x%08x\\n\", ins_bytes[0] << 24\n\t\t\t\t | ins_bytes[1] << 16\n\t\t\t\t | ins_bytes[2] << 8\n\t\t\t\t | ins_bytes[3]);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nahc_poll __P((struct ahc_softc *ahc, int wait));\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC u_int;\nSTATIC struct;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC u_int;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nahc_clear_intstat __P((struct ahc_softc *ahc));\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nrestart_sequencer __P((struct ahc_softc *ahc));\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nint\nahc_reset(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tu_int\tsblkctl;\n\tint\twait;\n\t\n#ifdef AHC_DUMP_SEQ\n\tif (ahc->init_level == 0)\n\t\tahc_dumpseq(ahc);\n#endif\n\tahc_outb(ahc, HCNTRL, CHIPRST | ahc->pause);\n\t/*\n\t * Ensure that the reset has finished\n\t */\n\twait = 1000;\n\tdo {\n\t\tDELAY(1000);\n\t} while (--wait && !(ahc_inb(ahc, HCNTRL) & CHIPRSTACK));\n\n\tif (wait == 0) {\n\t\tprintf(\"%s: WARNING - Failed chip reset!  \"\n\t\t       \"Trying to initialize anyway.\\n\", ahc_name(ahc));\n\t}\n\tahc_outb(ahc, HCNTRL, ahc->pause);\n\n\t/* Determine channel configuration */\n\tsblkctl = ahc_inb(ahc, SBLKCTL) & (SELBUSB|SELWIDE);\n\t/* No Twin Channel PCI cards */\n\tif ((ahc->chip & AHC_PCI) != 0)\n\t\tsblkctl &= ~SELBUSB;\n\tswitch (sblkctl) {\n\tcase 0:\n\t\t/* Single Narrow Channel */\n\t\tbreak;\n\tcase 2:\n\t\t/* Wide Channel */\n\t\tahc->features |= AHC_WIDE;\n\t\tbreak;\n\tcase 8:\n\t\t/* Twin Channel */\n\t\tahc->features |= AHC_TWIN;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\" Unsupported adapter type.  Ignoring\\n\");\n\t\treturn(-1);\n\t}\n\treturn (0);\n}"
  },
  {
    "function_name": "ahc_xxx_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "1044-1071",
    "snippet": "void\nahc_xxx_reset(devname, iot, ioh)\n\tchar *devname;\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n{\n\tu_char hcntrl;\n\tint wait;\n\n#ifdef AHC_DUMP_SEQ\n\tahc_dumpseq(ahc);\n#endif\n\t/* Retain the IRQ type accross the chip reset */\n\thcntrl = (bus_space_read_1(iot, ioh, HCNTRL) & IRQMS) | INTEN;\n\n\tbus_space_write_1(iot, ioh, HCNTRL, CHIPRST | PAUSE);\n\t/*\n\t * Ensure that the reset has finished\n\t */\n\twait = 1000;\n\twhile (--wait && !(bus_space_read_1(iot, ioh, HCNTRL) & CHIPRSTACK))\n\t\tDELAY(1000);\n\tif (wait == 0) {\n\t\tprintf(\"%s: WARNING - Failed chip reset!  \"\n\t\t\t\t \"Trying to initialize anyway.\\n\", devname);\n\t}\n\tbus_space_write_1(iot, ioh, HCNTRL, hcntrl | PAUSE);\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "ahc_poll __P((struct ahc_softc *ahc, int wait));",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "HCNTRL",
            "hcntrl | PAUSE"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: WARNING - Failed chip reset!  \"\n\t\t\t\t \"Trying to initialize anyway.\\n\"",
            "devname"
          ],
          "line": 1067
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1000"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "HCNTRL"
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "HCNTRL",
            "CHIPRST | PAUSE"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "HCNTRL"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_dumpseq",
          "args": [
            "ahc"
          ],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_dumpseq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "4528-4554",
          "snippet": "STATIC void\nahc_dumpseq(ahc)\n\tstruct ahc_softc* ahc;\n{\n\tint i;\n\tint max_prog;\n\n\tif ((ahc->chip & AHC_BUS_MASK) < AHC_PCI)\n\t\tmax_prog = 448;\n\telse if ((ahc->features & AHC_ULTRA2) != 0)\n\t\tmax_prog = 768;\n\telse\n\t\tmax_prog = 512;\n\n\tahc_outb(ahc, SEQCTL, PERRORDIS|FAILDIS|FASTMODE|LOADRAM);\n\tahc_outb(ahc, SEQADDR0, 0);\n\tahc_outb(ahc, SEQADDR1, 0);\n\tfor (i = 0; i < max_prog; i++) {\n\t\tu_int8_t ins_bytes[4];\n\n\t\tahc_insb(ahc, SEQRAM, ins_bytes, 4);\n\t\tprintf(\"0x%08x\\n\", ins_bytes[0] << 24\n\t\t\t\t | ins_bytes[1] << 16\n\t\t\t\t | ins_bytes[2] << 8\n\t\t\t\t | ins_bytes[3]);\n\t}\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_dumpseq(ahc)\n\tstruct ahc_softc* ahc;\n{\n\tint i;\n\tint max_prog;\n\n\tif ((ahc->chip & AHC_BUS_MASK) < AHC_PCI)\n\t\tmax_prog = 448;\n\telse if ((ahc->features & AHC_ULTRA2) != 0)\n\t\tmax_prog = 768;\n\telse\n\t\tmax_prog = 512;\n\n\tahc_outb(ahc, SEQCTL, PERRORDIS|FAILDIS|FASTMODE|LOADRAM);\n\tahc_outb(ahc, SEQADDR0, 0);\n\tahc_outb(ahc, SEQADDR1, 0);\n\tfor (i = 0; i < max_prog; i++) {\n\t\tu_int8_t ins_bytes[4];\n\n\t\tahc_insb(ahc, SEQRAM, ins_bytes, 4);\n\t\tprintf(\"0x%08x\\n\", ins_bytes[0] << 24\n\t\t\t\t | ins_bytes[1] << 16\n\t\t\t\t | ins_bytes[2] << 8\n\t\t\t\t | ins_bytes[3]);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nahc_poll __P((struct ahc_softc *ahc, int wait));\nahcallocscbs __P((struct ahc_softc *ahc));\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nahc_loadseq __P((struct ahc_softc *ahc));\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nahc_clear_intstat __P((struct ahc_softc *ahc));\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nrestart_sequencer __P((struct ahc_softc *ahc));\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nvoid\nahc_xxx_reset(devname, iot, ioh)\n\tchar *devname;\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n{\n\tu_char hcntrl;\n\tint wait;\n\n#ifdef AHC_DUMP_SEQ\n\tahc_dumpseq(ahc);\n#endif\n\t/* Retain the IRQ type accross the chip reset */\n\thcntrl = (bus_space_read_1(iot, ioh, HCNTRL) & IRQMS) | INTEN;\n\n\tbus_space_write_1(iot, ioh, HCNTRL, CHIPRST | PAUSE);\n\t/*\n\t * Ensure that the reset has finished\n\t */\n\twait = 1000;\n\twhile (--wait && !(bus_space_read_1(iot, ioh, HCNTRL) & CHIPRSTACK))\n\t\tDELAY(1000);\n\tif (wait == 0) {\n\t\tprintf(\"%s: WARNING - Failed chip reset!  \"\n\t\t\t\t \"Trying to initialize anyway.\\n\", devname);\n\t}\n\tbus_space_write_1(iot, ioh, HCNTRL, hcntrl | PAUSE);\n}"
  },
  {
    "function_name": "ahcfiniscbdata",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "1004-1042",
    "snippet": "STATIC void\nahcfiniscbdata(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tstruct scb_data *scb_data;\n\n\tscb_data = ahc->scb_data;\n\n\tswitch (scb_data->init_level) {\n\tdefault:\n\tcase 3:\n\t{\n\t\tstruct sg_map_node *sg_map;\n\n\t\twhile ((sg_map = SLIST_FIRST(&scb_data->sg_maps))!= NULL) {\n\t\t\tSLIST_REMOVE_HEAD(&scb_data->sg_maps, links);\n\t\t\tahc_freedmamem(ahc->sc_dmat, PAGE_SIZE,\n\t\t\t    sg_map->sg_dmamap, (caddr_t)sg_map->sg_vaddr,\n\t\t\t    &sg_map->sg_dmasegs, sg_map->sg_nseg);\n\t\t\tfree(sg_map, M_DEVBUF);\n\t\t}\n\t}\n\t/*FALLTHROUGH*/\n\tcase 2:\n\t\tahc_freedmamem(ahc->sc_dmat,\n\t\t    AHC_SCB_MAX * sizeof(struct scsi_sense_data),\n\t\t    scb_data->sense_dmamap, (caddr_t)scb_data->sense,\n\t\t    &scb_data->sense_seg, scb_data->sense_nseg);\n\t/*FALLTHROUGH*/\n\tcase 1:\n\t\tahc_freedmamem(ahc->sc_dmat,\n\t\t    AHC_SCB_MAX * sizeof(struct hardware_scb), \n\t\t    scb_data->hscb_dmamap, (caddr_t)scb_data->hscbs,\n\t\t    &scb_data->hscb_seg, scb_data->hscb_nseg);\n\t/*FALLTHROUGH*/\n\t}\n\tif (scb_data->scbarray != NULL)\n\t\tfree(scb_data->scbarray, M_DEVBUF);\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define STATIC\tstatic",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "scb_data->scbarray",
            "M_DEVBUF"
          ],
          "line": 1041
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_add_curscb_to_free_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "5319-5328",
          "snippet": "STATIC void\nahc_add_curscb_to_free_list(ahc)\n\tstruct ahc_softc *ahc;\n{\n\t/* Invalidate the tag so that ahc_find_scb doesn't think it's active */\n\tahc_outb(ahc, SCB_TAG, SCB_LIST_NULL);\n\n\tahc_outb(ahc, SCB_NEXT, ahc_inb(ahc, FREE_SCBH));\n\tahc_outb(ahc, FREE_SCBH, ahc_inb(ahc, SCBPTR));\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_add_curscb_to_free_list(ahc)\n\tstruct ahc_softc *ahc;\n{\n\t/* Invalidate the tag so that ahc_find_scb doesn't think it's active */\n\tahc_outb(ahc, SCB_TAG, SCB_LIST_NULL);\n\n\tahc_outb(ahc, SCB_NEXT, ahc_inb(ahc, FREE_SCBH));\n\tahc_outb(ahc, FREE_SCBH, ahc_inb(ahc, SCBPTR));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_freedmamem",
          "args": [
            "ahc->sc_dmat",
            "AHC_SCB_MAX * sizeof(struct hardware_scb)",
            "scb_data->hscb_dmamap",
            "(caddr_t)scb_data->hscbs",
            "&scb_data->hscb_seg",
            "scb_data->hscb_nseg"
          ],
          "line": 1034
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_freedmamem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "747-761",
          "snippet": "STATIC void\nahc_freedmamem(tag, size, map, vaddr, seg, nseg)\n\tbus_dma_tag_t tag;\n\tint size;\n\tbus_dmamap_t map;\n\tcaddr_t vaddr;\n\tbus_dma_segment_t *seg;\n\tint nseg;\n{\n\n\tbus_dmamap_unload(tag, map);\n\tbus_dmamap_destroy(tag, map);\n\tbus_dmamem_unmap(tag, vaddr, size);\n\tbus_dmamem_free(tag, seg, nseg);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_freedmamem __P((bus_dma_tag_t tag, int size,\n\t\t\t\tbus_dmamap_t map, caddr_t vaddr,\n\t\t\t\tbus_dma_segment_t *seg, int nseg));",
            "STATIC void"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_freedmamem __P((bus_dma_tag_t tag, int size,\n\t\t\t\tbus_dmamap_t map, caddr_t vaddr,\n\t\t\t\tbus_dma_segment_t *seg, int nseg));\nSTATIC void;\n\nSTATIC void\nahc_freedmamem(tag, size, map, vaddr, seg, nseg)\n\tbus_dma_tag_t tag;\n\tint size;\n\tbus_dmamap_t map;\n\tcaddr_t vaddr;\n\tbus_dma_segment_t *seg;\n\tint nseg;\n{\n\n\tbus_dmamap_unload(tag, map);\n\tbus_dmamap_destroy(tag, map);\n\tbus_dmamem_unmap(tag, vaddr, size);\n\tbus_dmamem_free(tag, seg, nseg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SLIST_REMOVE_HEAD",
          "args": [
            "&scb_data->sg_maps",
            "links"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SLIST_FIRST",
          "args": [
            "&scb_data->sg_maps"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahcfiniscbdata(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tstruct scb_data *scb_data;\n\n\tscb_data = ahc->scb_data;\n\n\tswitch (scb_data->init_level) {\n\tdefault:\n\tcase 3:\n\t{\n\t\tstruct sg_map_node *sg_map;\n\n\t\twhile ((sg_map = SLIST_FIRST(&scb_data->sg_maps))!= NULL) {\n\t\t\tSLIST_REMOVE_HEAD(&scb_data->sg_maps, links);\n\t\t\tahc_freedmamem(ahc->sc_dmat, PAGE_SIZE,\n\t\t\t    sg_map->sg_dmamap, (caddr_t)sg_map->sg_vaddr,\n\t\t\t    &sg_map->sg_dmasegs, sg_map->sg_nseg);\n\t\t\tfree(sg_map, M_DEVBUF);\n\t\t}\n\t}\n\t/*FALLTHROUGH*/\n\tcase 2:\n\t\tahc_freedmamem(ahc->sc_dmat,\n\t\t    AHC_SCB_MAX * sizeof(struct scsi_sense_data),\n\t\t    scb_data->sense_dmamap, (caddr_t)scb_data->sense,\n\t\t    &scb_data->sense_seg, scb_data->sense_nseg);\n\t/*FALLTHROUGH*/\n\tcase 1:\n\t\tahc_freedmamem(ahc->sc_dmat,\n\t\t    AHC_SCB_MAX * sizeof(struct hardware_scb), \n\t\t    scb_data->hscb_dmamap, (caddr_t)scb_data->hscbs,\n\t\t    &scb_data->hscb_seg, scb_data->hscb_nseg);\n\t/*FALLTHROUGH*/\n\t}\n\tif (scb_data->scbarray != NULL)\n\t\tfree(scb_data->scbarray, M_DEVBUF);\n}"
  },
  {
    "function_name": "ahcinitscbdata",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "903-1002",
    "snippet": "STATIC int\nahcinitscbdata(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tstruct scb_data *scb_data;\n\tint i;\n\t\n\tscb_data = ahc->scb_data;\n\tSLIST_INIT(&scb_data->free_scbs);\n\tSLIST_INIT(&scb_data->sg_maps);\n\n\t/* Allocate SCB resources */\n\tscb_data->scbarray =\n\t    (struct scb *)malloc(sizeof(struct scb) * AHC_SCB_MAX,\n\t\t\t\t M_DEVBUF, M_NOWAIT);\n\tif (scb_data->scbarray == NULL)\n\t\treturn (ENOMEM);\n\tbzero(scb_data->scbarray, sizeof(struct scb) * AHC_SCB_MAX);\n\n\t/* Determine the number of hardware SCBs and initialize them */\n\n\tscb_data->maxhscbs = ahc_probe_scbs(ahc);\n\t/* SCB 0 heads the free list */\n\tahc_outb(ahc, FREE_SCBH, 0);\n\tfor (i = 0; i < ahc->scb_data->maxhscbs; i++) {\n\t\tahc_outb(ahc, SCBPTR, i);\n\n\t\t/* Clear the control byte. */\n\t\tahc_outb(ahc, SCB_CONTROL, 0);\n\n\t\t/* Set the next pointer */\n\t\tahc_outb(ahc, SCB_NEXT, i+1);\n\n\t\t/* Make the tag number invalid */\n\t\tahc_outb(ahc, SCB_TAG, SCB_LIST_NULL);\n\t}\n\n\t/* Make sure that the last SCB terminates the free list */\n\tahc_outb(ahc, SCBPTR, i-1);\n\tahc_outb(ahc, SCB_NEXT, SCB_LIST_NULL);\n\n\t/* Ensure we clear the 0 SCB's control byte. */\n\tahc_outb(ahc, SCBPTR, 0);\n\tahc_outb(ahc, SCB_CONTROL, 0);\n\n\tscb_data->maxhscbs = i;\n\n\tif (ahc->scb_data->maxhscbs == 0)\n\t\tpanic(\"%s: No SCB space found\", ahc_name(ahc));\n\n\t/*\n\t * Create our DMA tags.  These tags define the kinds of device\n\t * accessable memory allocations and memory mappings we will\n\t * need to perform during normal operation.\n\t *\n\t * Unless we need to further restrict the allocation, we rely\n\t * on the restrictions of the parent dmat, hence the common\n\t * use of MAXADDR and MAXSIZE.\n\t */\n\n\tif (ahc_createdmamem(ahc,\n\t    AHC_SCB_MAX * sizeof(struct hardware_scb), \n\t    &scb_data->hscb_dmamap, (caddr_t *)&scb_data->hscbs, \n\t    &scb_data->hscb_busaddr, &scb_data->hscb_seg,\n\t    &scb_data->hscb_nseg, \"hardware SCB structures\") < 0)\n\t\tgoto error_exit;\n\n\tscb_data->init_level++;\n\n\tif (ahc_createdmamem(ahc,\n\t    AHC_SCB_MAX * sizeof(struct scsi_sense_data),\n\t    &scb_data->sense_dmamap, (caddr_t *)&scb_data->sense,\n\t    &scb_data->sense_busaddr, &scb_data->sense_seg,\n\t    &scb_data->sense_nseg, \"sense buffers\") < 0)\n\t\tgoto error_exit;\n\n\tscb_data->init_level++;\n\n\t/* Perform initial CCB allocation */\n\tbzero(scb_data->hscbs, AHC_SCB_MAX * sizeof(struct hardware_scb));\n\tahcallocscbs(ahc);\n\n\tif (scb_data->numscbs == 0) {\n\t\tprintf(\"%s: ahc_init_scb_data - \"\n\t\t       \"Unable to allocate initial scbs\\n\",\n\t\t       ahc_name(ahc));\n\t\tgoto error_exit;\n\t}\n\n\tscb_data->init_level++;\n\n\t/*\n\t * Note that we were successfull\n\t */\n\treturn 0; \n\nerror_exit:\n\n\treturn ENOMEM;\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define STATIC\tstatic",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
      "STATIC void",
      "STATIC void",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_calc_residual __P((struct scb *scb));",
      "STATIC void",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
      "STATIC void",
      "STATIC void",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
      "int    ahc_createdmamem",
      "STATIC void",
      "STATIC void",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: ahc_init_scb_data - \"\n\t\t       \"Unable to allocate initial scbs\\n\"",
            "ahc_name(ahc)"
          ],
          "line": 986
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahcallocscbs",
          "args": [
            "ahc"
          ],
          "line": 983
        },
        "resolved": true,
        "details": {
          "function_name": "ahcallocscbs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "4452-4525",
          "snippet": "STATIC void\nahcallocscbs(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tstruct scb_data *scb_data;\n\tstruct scb *next_scb;\n\tstruct sg_map_node *sg_map;\n\tbus_addr_t physaddr;\n\tstruct ahc_dma_seg *segs;\n\tint newcount;\n\tint i;\n\tint dma_flags = 0;\n\n\tscb_data = ahc->scb_data;\n\tif (scb_data->numscbs >= AHC_SCB_MAX)\n\t\t/* Can't allocate any more */\n\t\treturn;\n\n\tnext_scb = &scb_data->scbarray[scb_data->numscbs];\n\n\tsg_map = malloc(sizeof(*sg_map), M_DEVBUF, M_NOWAIT);\n\n\tif (sg_map == NULL)\n\t\treturn;\n\tbzero(sg_map, sizeof(struct sg_map_node));\n\t\n\tif (ahc_createdmamem(ahc, PAGE_SIZE, &sg_map->sg_dmamap,\n\t    (caddr_t *)&sg_map->sg_vaddr, &sg_map->sg_physaddr,\n\t    &sg_map->sg_dmasegs, &sg_map->sg_nseg, \"SG space\") < 0) {\n\t\tfree(sg_map, M_DEVBUF);\n\t\treturn;\n\t}\n\t\n\tSLIST_INSERT_HEAD(&scb_data->sg_maps, sg_map, links);\n\n\tsegs = sg_map->sg_vaddr;\n\tphysaddr = sg_map->sg_physaddr;\n\n\tnewcount = (PAGE_SIZE / (AHC_NSEG * sizeof(struct ahc_dma_seg)));\n\n\tfor (i = 0; scb_data->numscbs < AHC_SCB_MAX && i < newcount; i++) {\n\t\tint error;\n\n\t\tnext_scb->sg_list = segs;\n\t\t/*\n\t\t * The sequencer always starts with the second entry.\n\t\t * The first entry is embedded in the scb.\n\t\t */\n\t\tnext_scb->sg_list_phys = physaddr + sizeof(struct ahc_dma_seg);\n\t\tnext_scb->flags = SCB_FREE;\n\t\t\n\t\t/* set up AHA-284x right. */\n\t\tdma_flags = ((ahc->chip & AHC_VL) !=0) ? \n\t\t\tBUS_DMA_NOWAIT|ISABUS_DMA_32BIT :\n\t\t\tBUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW;\n\t\t\n\t\terror = bus_dmamap_create(ahc->sc_dmat,\n\t\t\t\t AHC_MAXTRANSFER_SIZE, AHC_NSEG, MAXBSIZE, 0,\n\t\t\t\t dma_flags, &next_scb->dmamap);\n\t\tif (error !=0) \n\t\t\tbreak;\n\n\t\tnext_scb->hscb = &scb_data->hscbs[scb_data->numscbs];\n\t\tnext_scb->hscb->tag = ahc->scb_data->numscbs;\n\t\tnext_scb->hscb->cmdstore_busaddr = \n\t\t\tahc_hscb_busaddr(ahc, next_scb->hscb->tag) + \n\t\t\toffsetof(struct hardware_scb, cmdstore);\t\n\t\tSLIST_INSERT_HEAD(&ahc->scb_data->free_scbs, next_scb, links);\n\t\tsegs += AHC_NSEG;\n\t\tphysaddr += (AHC_NSEG * sizeof(struct ahc_dma_seg));\n\t\tnext_scb++;\n\t\tahc->scb_data->numscbs++;\n\t}\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC",
            "#define ISABUS_DMA_32BIT\tBUS_DMA_BUS1"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_calc_residual __P((struct scb *scb));",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
            "int    ahc_createdmamem",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n#define ISABUS_DMA_32BIT\tBUS_DMA_BUS1\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_calc_residual __P((struct scb *scb));\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nint    ahc_createdmamem;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahcallocscbs(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tstruct scb_data *scb_data;\n\tstruct scb *next_scb;\n\tstruct sg_map_node *sg_map;\n\tbus_addr_t physaddr;\n\tstruct ahc_dma_seg *segs;\n\tint newcount;\n\tint i;\n\tint dma_flags = 0;\n\n\tscb_data = ahc->scb_data;\n\tif (scb_data->numscbs >= AHC_SCB_MAX)\n\t\t/* Can't allocate any more */\n\t\treturn;\n\n\tnext_scb = &scb_data->scbarray[scb_data->numscbs];\n\n\tsg_map = malloc(sizeof(*sg_map), M_DEVBUF, M_NOWAIT);\n\n\tif (sg_map == NULL)\n\t\treturn;\n\tbzero(sg_map, sizeof(struct sg_map_node));\n\t\n\tif (ahc_createdmamem(ahc, PAGE_SIZE, &sg_map->sg_dmamap,\n\t    (caddr_t *)&sg_map->sg_vaddr, &sg_map->sg_physaddr,\n\t    &sg_map->sg_dmasegs, &sg_map->sg_nseg, \"SG space\") < 0) {\n\t\tfree(sg_map, M_DEVBUF);\n\t\treturn;\n\t}\n\t\n\tSLIST_INSERT_HEAD(&scb_data->sg_maps, sg_map, links);\n\n\tsegs = sg_map->sg_vaddr;\n\tphysaddr = sg_map->sg_physaddr;\n\n\tnewcount = (PAGE_SIZE / (AHC_NSEG * sizeof(struct ahc_dma_seg)));\n\n\tfor (i = 0; scb_data->numscbs < AHC_SCB_MAX && i < newcount; i++) {\n\t\tint error;\n\n\t\tnext_scb->sg_list = segs;\n\t\t/*\n\t\t * The sequencer always starts with the second entry.\n\t\t * The first entry is embedded in the scb.\n\t\t */\n\t\tnext_scb->sg_list_phys = physaddr + sizeof(struct ahc_dma_seg);\n\t\tnext_scb->flags = SCB_FREE;\n\t\t\n\t\t/* set up AHA-284x right. */\n\t\tdma_flags = ((ahc->chip & AHC_VL) !=0) ? \n\t\t\tBUS_DMA_NOWAIT|ISABUS_DMA_32BIT :\n\t\t\tBUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW;\n\t\t\n\t\terror = bus_dmamap_create(ahc->sc_dmat,\n\t\t\t\t AHC_MAXTRANSFER_SIZE, AHC_NSEG, MAXBSIZE, 0,\n\t\t\t\t dma_flags, &next_scb->dmamap);\n\t\tif (error !=0) \n\t\t\tbreak;\n\n\t\tnext_scb->hscb = &scb_data->hscbs[scb_data->numscbs];\n\t\tnext_scb->hscb->tag = ahc->scb_data->numscbs;\n\t\tnext_scb->hscb->cmdstore_busaddr = \n\t\t\tahc_hscb_busaddr(ahc, next_scb->hscb->tag) + \n\t\t\toffsetof(struct hardware_scb, cmdstore);\t\n\t\tSLIST_INSERT_HEAD(&ahc->scb_data->free_scbs, next_scb, links);\n\t\tsegs += AHC_NSEG;\n\t\tphysaddr += (AHC_NSEG * sizeof(struct ahc_dma_seg));\n\t\tnext_scb++;\n\t\tahc->scb_data->numscbs++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "scb_data->hscbs",
            "AHC_SCB_MAX * sizeof(struct hardware_scb)"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_createdmamem",
          "args": [
            "ahc",
            "AHC_SCB_MAX * sizeof(struct scsi_sense_data)",
            "&scb_data->sense_dmamap",
            "(caddr_t *)&scb_data->sense",
            "&scb_data->sense_busaddr",
            "&scb_data->sense_seg",
            "&scb_data->sense_nseg",
            "\"sense buffers\""
          ],
          "line": 972
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_createdmamem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "678-745",
          "snippet": "int\nahc_createdmamem(ahc, size, mapp, vaddr, baddr, seg, nseg, what)\n\tstruct ahc_softc *ahc;\n\tint size;\n\tbus_dmamap_t *mapp;\n\tcaddr_t *vaddr;\n\tbus_addr_t *baddr;\n\tbus_dma_segment_t *seg;\n\tint *nseg;\n\tconst char *what;\n{\n\tint error, level = 0;\n\tint dma_flags = BUS_DMA_NOWAIT;\n\tbus_dma_tag_t tag = ahc->sc_dmat;\n\tconst char *myname = ahc_name(ahc);\n\tif ((ahc->chip & AHC_VL) !=0)\n\t\tdma_flags |= ISABUS_DMA_32BIT;\n\t\n\tif ((error = bus_dmamem_alloc(tag, size, NBPG, 0,\n\t\t\tseg, 1, nseg, BUS_DMA_NOWAIT)) != 0) {\n\t\tprintf(\"%s: failed to allocate DMA mem for %s, error = %d\\n\",\n\t\t\tmyname, what, error);\n\t\tgoto out;\n\t}\n\tlevel++;\n\n\tif ((error = bus_dmamem_map(tag, seg, *nseg, size, vaddr,\n\t\t\tBUS_DMA_NOWAIT|BUS_DMA_COHERENT)) != 0) {\n\t\tprintf(\"%s: failed to map DMA mem for %s, error = %d\\n\",\n\t\t\tmyname, what, error);\n\t\tgoto out;\n\t}\n\tlevel++;\n\n\tif ((error = bus_dmamap_create(tag, size, 1, size, 0,\n\t\t\tdma_flags, mapp)) != 0) {\n\t\tprintf(\"%s: failed to create DMA map for %s, error = %d\\n\",\n\t\t\tmyname, what, error);\n\t\tgoto out;\n        }\n\tlevel++;\n\n\tif ((error = bus_dmamap_load(tag, *mapp, *vaddr, size, NULL,\n\t\t\tBUS_DMA_NOWAIT)) != 0) {\n\t\tprintf(\"%s: failed to load DMA map for %s, error = %d\\n\",\n\t\t\tmyname, what, error);\n\t\tgoto out;\n        }\n\n\t*baddr = (*mapp)->dm_segs[0].ds_addr;\n\treturn 0;\nout:\n\tswitch (level) {\n\tcase 3:\n\t\tbus_dmamap_destroy(tag, *mapp);\n\t\t/* FALLTHROUGH */\n\tcase 2:\n\t\tbus_dmamem_unmap(tag, *vaddr, size);\n\t\t/* FALLTHROUGH */\n\tcase 1:\n\t\tbus_dmamem_free(tag, seg, *nseg);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define ISABUS_DMA_32BIT\tBUS_DMA_BUS1"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "int    ahc_createdmamem",
            "ahc_freedmamem __P((bus_dma_tag_t tag, int size,\n\t\t\t\tbus_dmamap_t map, caddr_t vaddr,\n\t\t\t\tbus_dma_segment_t *seg, int nseg));",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define ISABUS_DMA_32BIT\tBUS_DMA_BUS1\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC struct;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nahc_loadseq __P((struct ahc_softc *ahc));\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nahc_clear_intstat __P((struct ahc_softc *ahc));\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nrestart_sequencer __P((struct ahc_softc *ahc));\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nint    ahc_createdmamem;\nahc_freedmamem __P((bus_dma_tag_t tag, int size,\n\t\t\t\tbus_dmamap_t map, caddr_t vaddr,\n\t\t\t\tbus_dma_segment_t *seg, int nseg));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nint\nahc_createdmamem(ahc, size, mapp, vaddr, baddr, seg, nseg, what)\n\tstruct ahc_softc *ahc;\n\tint size;\n\tbus_dmamap_t *mapp;\n\tcaddr_t *vaddr;\n\tbus_addr_t *baddr;\n\tbus_dma_segment_t *seg;\n\tint *nseg;\n\tconst char *what;\n{\n\tint error, level = 0;\n\tint dma_flags = BUS_DMA_NOWAIT;\n\tbus_dma_tag_t tag = ahc->sc_dmat;\n\tconst char *myname = ahc_name(ahc);\n\tif ((ahc->chip & AHC_VL) !=0)\n\t\tdma_flags |= ISABUS_DMA_32BIT;\n\t\n\tif ((error = bus_dmamem_alloc(tag, size, NBPG, 0,\n\t\t\tseg, 1, nseg, BUS_DMA_NOWAIT)) != 0) {\n\t\tprintf(\"%s: failed to allocate DMA mem for %s, error = %d\\n\",\n\t\t\tmyname, what, error);\n\t\tgoto out;\n\t}\n\tlevel++;\n\n\tif ((error = bus_dmamem_map(tag, seg, *nseg, size, vaddr,\n\t\t\tBUS_DMA_NOWAIT|BUS_DMA_COHERENT)) != 0) {\n\t\tprintf(\"%s: failed to map DMA mem for %s, error = %d\\n\",\n\t\t\tmyname, what, error);\n\t\tgoto out;\n\t}\n\tlevel++;\n\n\tif ((error = bus_dmamap_create(tag, size, 1, size, 0,\n\t\t\tdma_flags, mapp)) != 0) {\n\t\tprintf(\"%s: failed to create DMA map for %s, error = %d\\n\",\n\t\t\tmyname, what, error);\n\t\tgoto out;\n        }\n\tlevel++;\n\n\tif ((error = bus_dmamap_load(tag, *mapp, *vaddr, size, NULL,\n\t\t\tBUS_DMA_NOWAIT)) != 0) {\n\t\tprintf(\"%s: failed to load DMA map for %s, error = %d\\n\",\n\t\t\tmyname, what, error);\n\t\tgoto out;\n        }\n\n\t*baddr = (*mapp)->dm_segs[0].ds_addr;\n\treturn 0;\nout:\n\tswitch (level) {\n\tcase 3:\n\t\tbus_dmamap_destroy(tag, *mapp);\n\t\t/* FALLTHROUGH */\n\tcase 2:\n\t\tbus_dmamem_unmap(tag, *vaddr, size);\n\t\t/* FALLTHROUGH */\n\tcase 1:\n\t\tbus_dmamem_free(tag, seg, *nseg);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"%s: No SCB space found\"",
            "ahc_name(ahc)"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCB_CONTROL",
            "0"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCBPTR",
            "0"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCB_NEXT",
            "SCB_LIST_NULL"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCBPTR",
            "i-1"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCB_TAG",
            "SCB_LIST_NULL"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCB_NEXT",
            "i+1"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCB_CONTROL",
            "0"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCBPTR",
            "i"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "FREE_SCBH",
            "0"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_probe_scbs",
          "args": [
            "ahc"
          ],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_probe_scbs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "3542-3559",
          "snippet": "int\nahc_probe_scbs(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tint i;\n\n\tfor (i = 0; i < AHC_SCB_MAX; i++) {\n\t\tahc_outb(ahc, SCBPTR, i);\n\t\tahc_outb(ahc, SCB_CONTROL, i);\n\t\tif (ahc_inb(ahc, SCB_CONTROL) != i)\n\t\t\tbreak;\n\t\tahc_outb(ahc, SCBPTR, 0);\n\t\tif (ahc_inb(ahc, SCB_CONTROL) != 0)\n\t\t\tbreak;\n\t}\n\t\n\treturn (i);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC struct;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nahc_loadseq __P((struct ahc_softc *ahc));\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nahc_clear_intstat __P((struct ahc_softc *ahc));\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nrestart_sequencer __P((struct ahc_softc *ahc));\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nint\nahc_probe_scbs(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tint i;\n\n\tfor (i = 0; i < AHC_SCB_MAX; i++) {\n\t\tahc_outb(ahc, SCBPTR, i);\n\t\tahc_outb(ahc, SCB_CONTROL, i);\n\t\tif (ahc_inb(ahc, SCB_CONTROL) != i)\n\t\t\tbreak;\n\t\tahc_outb(ahc, SCBPTR, 0);\n\t\tif (ahc_inb(ahc, SCB_CONTROL) != 0)\n\t\t\tbreak;\n\t}\n\t\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "scb_data->scbarray",
            "sizeof(struct scb) * AHC_SCB_MAX"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(struct scb) * AHC_SCB_MAX",
            "M_DEVBUF",
            "M_NOWAIT"
          ],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "SLIST_INIT",
          "args": [
            "&scb_data->sg_maps"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SLIST_INIT",
          "args": [
            "&scb_data->free_scbs"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_calc_residual __P((struct scb *scb));\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nint    ahc_createdmamem;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC int\nahcinitscbdata(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tstruct scb_data *scb_data;\n\tint i;\n\t\n\tscb_data = ahc->scb_data;\n\tSLIST_INIT(&scb_data->free_scbs);\n\tSLIST_INIT(&scb_data->sg_maps);\n\n\t/* Allocate SCB resources */\n\tscb_data->scbarray =\n\t    (struct scb *)malloc(sizeof(struct scb) * AHC_SCB_MAX,\n\t\t\t\t M_DEVBUF, M_NOWAIT);\n\tif (scb_data->scbarray == NULL)\n\t\treturn (ENOMEM);\n\tbzero(scb_data->scbarray, sizeof(struct scb) * AHC_SCB_MAX);\n\n\t/* Determine the number of hardware SCBs and initialize them */\n\n\tscb_data->maxhscbs = ahc_probe_scbs(ahc);\n\t/* SCB 0 heads the free list */\n\tahc_outb(ahc, FREE_SCBH, 0);\n\tfor (i = 0; i < ahc->scb_data->maxhscbs; i++) {\n\t\tahc_outb(ahc, SCBPTR, i);\n\n\t\t/* Clear the control byte. */\n\t\tahc_outb(ahc, SCB_CONTROL, 0);\n\n\t\t/* Set the next pointer */\n\t\tahc_outb(ahc, SCB_NEXT, i+1);\n\n\t\t/* Make the tag number invalid */\n\t\tahc_outb(ahc, SCB_TAG, SCB_LIST_NULL);\n\t}\n\n\t/* Make sure that the last SCB terminates the free list */\n\tahc_outb(ahc, SCBPTR, i-1);\n\tahc_outb(ahc, SCB_NEXT, SCB_LIST_NULL);\n\n\t/* Ensure we clear the 0 SCB's control byte. */\n\tahc_outb(ahc, SCBPTR, 0);\n\tahc_outb(ahc, SCB_CONTROL, 0);\n\n\tscb_data->maxhscbs = i;\n\n\tif (ahc->scb_data->maxhscbs == 0)\n\t\tpanic(\"%s: No SCB space found\", ahc_name(ahc));\n\n\t/*\n\t * Create our DMA tags.  These tags define the kinds of device\n\t * accessable memory allocations and memory mappings we will\n\t * need to perform during normal operation.\n\t *\n\t * Unless we need to further restrict the allocation, we rely\n\t * on the restrictions of the parent dmat, hence the common\n\t * use of MAXADDR and MAXSIZE.\n\t */\n\n\tif (ahc_createdmamem(ahc,\n\t    AHC_SCB_MAX * sizeof(struct hardware_scb), \n\t    &scb_data->hscb_dmamap, (caddr_t *)&scb_data->hscbs, \n\t    &scb_data->hscb_busaddr, &scb_data->hscb_seg,\n\t    &scb_data->hscb_nseg, \"hardware SCB structures\") < 0)\n\t\tgoto error_exit;\n\n\tscb_data->init_level++;\n\n\tif (ahc_createdmamem(ahc,\n\t    AHC_SCB_MAX * sizeof(struct scsi_sense_data),\n\t    &scb_data->sense_dmamap, (caddr_t *)&scb_data->sense,\n\t    &scb_data->sense_busaddr, &scb_data->sense_seg,\n\t    &scb_data->sense_nseg, \"sense buffers\") < 0)\n\t\tgoto error_exit;\n\n\tscb_data->init_level++;\n\n\t/* Perform initial CCB allocation */\n\tbzero(scb_data->hscbs, AHC_SCB_MAX * sizeof(struct hardware_scb));\n\tahcallocscbs(ahc);\n\n\tif (scb_data->numscbs == 0) {\n\t\tprintf(\"%s: ahc_init_scb_data - \"\n\t\t       \"Unable to allocate initial scbs\\n\",\n\t\t       ahc_name(ahc));\n\t\tgoto error_exit;\n\t}\n\n\tscb_data->init_level++;\n\n\t/*\n\t * Note that we were successfull\n\t */\n\treturn 0; \n\nerror_exit:\n\n\treturn ENOMEM;\n}"
  },
  {
    "function_name": "ahc_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "886-901",
    "snippet": "void\nahc_free(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tahcfiniscbdata(ahc);\n\tif (ahc->init_level != 0)\n\t\tahc_freedmamem(ahc->sc_dmat, ahc->shared_data_size,\n\t\t    ahc->shared_data_dmamap, ahc->qoutfifo,\n\t\t    &ahc->shared_data_seg, ahc->shared_data_nseg);\n\n\tif (ahc->scb_data != NULL)\n\t\tfree(ahc->scb_data, M_DEVBUF);\n\tif (ahc->pci_data != NULL)\n\t\tfree(ahc->pci_data, M_DEVBUF);\n\treturn;\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ahc->pci_data",
            "M_DEVBUF"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_add_curscb_to_free_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "5319-5328",
          "snippet": "STATIC void\nahc_add_curscb_to_free_list(ahc)\n\tstruct ahc_softc *ahc;\n{\n\t/* Invalidate the tag so that ahc_find_scb doesn't think it's active */\n\tahc_outb(ahc, SCB_TAG, SCB_LIST_NULL);\n\n\tahc_outb(ahc, SCB_NEXT, ahc_inb(ahc, FREE_SCBH));\n\tahc_outb(ahc, FREE_SCBH, ahc_inb(ahc, SCBPTR));\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_add_curscb_to_free_list(ahc)\n\tstruct ahc_softc *ahc;\n{\n\t/* Invalidate the tag so that ahc_find_scb doesn't think it's active */\n\tahc_outb(ahc, SCB_TAG, SCB_LIST_NULL);\n\n\tahc_outb(ahc, SCB_NEXT, ahc_inb(ahc, FREE_SCBH));\n\tahc_outb(ahc, FREE_SCBH, ahc_inb(ahc, SCBPTR));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_freedmamem",
          "args": [
            "ahc->sc_dmat",
            "ahc->shared_data_size",
            "ahc->shared_data_dmamap",
            "ahc->qoutfifo",
            "&ahc->shared_data_seg",
            "ahc->shared_data_nseg"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_freedmamem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "747-761",
          "snippet": "STATIC void\nahc_freedmamem(tag, size, map, vaddr, seg, nseg)\n\tbus_dma_tag_t tag;\n\tint size;\n\tbus_dmamap_t map;\n\tcaddr_t vaddr;\n\tbus_dma_segment_t *seg;\n\tint nseg;\n{\n\n\tbus_dmamap_unload(tag, map);\n\tbus_dmamap_destroy(tag, map);\n\tbus_dmamem_unmap(tag, vaddr, size);\n\tbus_dmamem_free(tag, seg, nseg);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_freedmamem __P((bus_dma_tag_t tag, int size,\n\t\t\t\tbus_dmamap_t map, caddr_t vaddr,\n\t\t\t\tbus_dma_segment_t *seg, int nseg));",
            "STATIC void"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_freedmamem __P((bus_dma_tag_t tag, int size,\n\t\t\t\tbus_dmamap_t map, caddr_t vaddr,\n\t\t\t\tbus_dma_segment_t *seg, int nseg));\nSTATIC void;\n\nSTATIC void\nahc_freedmamem(tag, size, map, vaddr, seg, nseg)\n\tbus_dma_tag_t tag;\n\tint size;\n\tbus_dmamap_t map;\n\tcaddr_t vaddr;\n\tbus_dma_segment_t *seg;\n\tint nseg;\n{\n\n\tbus_dmamap_unload(tag, map);\n\tbus_dmamap_destroy(tag, map);\n\tbus_dmamem_unmap(tag, vaddr, size);\n\tbus_dmamem_free(tag, seg, nseg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahcfiniscbdata",
          "args": [
            "ahc"
          ],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "ahcfiniscbdata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "1004-1042",
          "snippet": "STATIC void\nahcfiniscbdata(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tstruct scb_data *scb_data;\n\n\tscb_data = ahc->scb_data;\n\n\tswitch (scb_data->init_level) {\n\tdefault:\n\tcase 3:\n\t{\n\t\tstruct sg_map_node *sg_map;\n\n\t\twhile ((sg_map = SLIST_FIRST(&scb_data->sg_maps))!= NULL) {\n\t\t\tSLIST_REMOVE_HEAD(&scb_data->sg_maps, links);\n\t\t\tahc_freedmamem(ahc->sc_dmat, PAGE_SIZE,\n\t\t\t    sg_map->sg_dmamap, (caddr_t)sg_map->sg_vaddr,\n\t\t\t    &sg_map->sg_dmasegs, sg_map->sg_nseg);\n\t\t\tfree(sg_map, M_DEVBUF);\n\t\t}\n\t}\n\t/*FALLTHROUGH*/\n\tcase 2:\n\t\tahc_freedmamem(ahc->sc_dmat,\n\t\t    AHC_SCB_MAX * sizeof(struct scsi_sense_data),\n\t\t    scb_data->sense_dmamap, (caddr_t)scb_data->sense,\n\t\t    &scb_data->sense_seg, scb_data->sense_nseg);\n\t/*FALLTHROUGH*/\n\tcase 1:\n\t\tahc_freedmamem(ahc->sc_dmat,\n\t\t    AHC_SCB_MAX * sizeof(struct hardware_scb), \n\t\t    scb_data->hscb_dmamap, (caddr_t)scb_data->hscbs,\n\t\t    &scb_data->hscb_seg, scb_data->hscb_nseg);\n\t/*FALLTHROUGH*/\n\t}\n\tif (scb_data->scbarray != NULL)\n\t\tfree(scb_data->scbarray, M_DEVBUF);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahcfiniscbdata(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tstruct scb_data *scb_data;\n\n\tscb_data = ahc->scb_data;\n\n\tswitch (scb_data->init_level) {\n\tdefault:\n\tcase 3:\n\t{\n\t\tstruct sg_map_node *sg_map;\n\n\t\twhile ((sg_map = SLIST_FIRST(&scb_data->sg_maps))!= NULL) {\n\t\t\tSLIST_REMOVE_HEAD(&scb_data->sg_maps, links);\n\t\t\tahc_freedmamem(ahc->sc_dmat, PAGE_SIZE,\n\t\t\t    sg_map->sg_dmamap, (caddr_t)sg_map->sg_vaddr,\n\t\t\t    &sg_map->sg_dmasegs, sg_map->sg_nseg);\n\t\t\tfree(sg_map, M_DEVBUF);\n\t\t}\n\t}\n\t/*FALLTHROUGH*/\n\tcase 2:\n\t\tahc_freedmamem(ahc->sc_dmat,\n\t\t    AHC_SCB_MAX * sizeof(struct scsi_sense_data),\n\t\t    scb_data->sense_dmamap, (caddr_t)scb_data->sense,\n\t\t    &scb_data->sense_seg, scb_data->sense_nseg);\n\t/*FALLTHROUGH*/\n\tcase 1:\n\t\tahc_freedmamem(ahc->sc_dmat,\n\t\t    AHC_SCB_MAX * sizeof(struct hardware_scb), \n\t\t    scb_data->hscb_dmamap, (caddr_t)scb_data->hscbs,\n\t\t    &scb_data->hscb_seg, scb_data->hscb_nseg);\n\t/*FALLTHROUGH*/\n\t}\n\tif (scb_data->scbarray != NULL)\n\t\tfree(scb_data->scbarray, M_DEVBUF);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC struct;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nahc_loadseq __P((struct ahc_softc *ahc));\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nahc_clear_intstat __P((struct ahc_softc *ahc));\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nrestart_sequencer __P((struct ahc_softc *ahc));\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nvoid\nahc_free(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tahcfiniscbdata(ahc);\n\tif (ahc->init_level != 0)\n\t\tahc_freedmamem(ahc->sc_dmat, ahc->shared_data_size,\n\t\t    ahc->shared_data_dmamap, ahc->qoutfifo,\n\t\t    &ahc->shared_data_seg, ahc->shared_data_nseg);\n\n\tif (ahc->scb_data != NULL)\n\t\tfree(ahc->scb_data, M_DEVBUF);\n\tif (ahc->pci_data != NULL)\n\t\tfree(ahc->pci_data, M_DEVBUF);\n\treturn;\n}"
  },
  {
    "function_name": "ahc_construct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "856-884",
    "snippet": "void\nahc_construct(ahc, iot, ioh, chip, flags, features, channel)\n\tstruct  ahc_softc *ahc;\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tahc_chip chip;\n\tahc_flag flags;\n\tahc_feature features;\n\tu_char channel;\n{\n\t/*\n\t * find unit and check we have that many defined\n\t */\n\tLIST_INIT(&ahc->pending_scbs);\n\tahc->sc_iot = iot;\n\tahc->sc_ioh = ioh;\n\tahc->chip = chip;\n\tahc->flags = flags;\n\tahc->features = features;\n\tahc->channel = channel;\n\tahc->scb_data = NULL;\n\tahc->pci_intr_func = NULL;\n\n\tahc->unpause = (ahc_inb(ahc, HCNTRL) & IRQMS) | INTEN;\n\t/* The IRQMS bit is only valid on VL and EISA chips */\n\tif ((ahc->chip & AHC_PCI) != 0)\n\t\tahc->unpause &= ~IRQMS;\n\tahc->pause = ahc->unpause | PAUSE;\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "char channel;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "char channel;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "HCNTRL"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_INIT",
          "args": [
            "&ahc->pending_scbs"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC struct;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nahc_loadseq __P((struct ahc_softc *ahc));\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nahc_clear_intstat __P((struct ahc_softc *ahc));\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nrestart_sequencer __P((struct ahc_softc *ahc));\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nvoid\nahc_construct(ahc, iot, ioh, chip, flags, features, channel)\n\tstruct  ahc_softc *ahc;\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tahc_chip chip;\n\tahc_flag flags;\n\tahc_feature features;\n\tu_char channel;\n{\n\t/*\n\t * find unit and check we have that many defined\n\t */\n\tLIST_INIT(&ahc->pending_scbs);\n\tahc->sc_iot = iot;\n\tahc->sc_ioh = ioh;\n\tahc->chip = chip;\n\tahc->flags = flags;\n\tahc->features = features;\n\tahc->channel = channel;\n\tahc->scb_data = NULL;\n\tahc->pci_intr_func = NULL;\n\n\tahc->unpause = (ahc_inb(ahc, HCNTRL) & IRQMS) | INTEN;\n\t/* The IRQMS bit is only valid on VL and EISA chips */\n\tif ((ahc->chip & AHC_PCI) != 0)\n\t\tahc->unpause &= ~IRQMS;\n\tahc->pause = ahc->unpause | PAUSE;\n}"
  },
  {
    "function_name": "ahc_print_scb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "764-789",
    "snippet": "STATIC void\nahc_print_scb(scb)\n\tstruct scb *scb;\n{\n\tstruct hardware_scb *hscb = scb->hscb;\n\n\tprintf(\"scb:%p control:0x%x tcl:0x%x cmdlen:%d cmdpointer:0x%lx\\n\",\n\t\tscb,\n\t\thscb->control,\n\t\thscb->tcl,\n\t\thscb->cmdlen,\n\t\thscb->cmdpointer );\n\tprintf(\"        datlen:%d data:0x%lx segs:0x%x segp:0x%lx\\n\",\n\t\thscb->datalen,\n\t\thscb->data,\n\t\thscb->SG_count,\n\t\thscb->SG_pointer);\n\tprintf(\"\tsg_addr:%lx sg_len:%ld\\n\",\n\t\tscb->sg_list[0].addr,\n\t\tscb->sg_list[0].len);\n\tprintf(\"\tcdb:%x %x %x %x %x %x %x %x %x %x %x %x\\n\",\n\t\thscb->cmdstore[0], hscb->cmdstore[1], hscb->cmdstore[2],\n\t\thscb->cmdstore[3], hscb->cmdstore[4], hscb->cmdstore[5],\n\t\thscb->cmdstore[6], hscb->cmdstore[7], hscb->cmdstore[8],\n\t\thscb->cmdstore[9], hscb->cmdstore[10], hscb->cmdstore[11]);\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define STATIC\tstatic",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC struct",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_calc_residual __P((struct scb *scb));",
      "STATIC void",
      "STATIC void",
      "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
      "STATIC void",
      "STATIC void",
      "STATIC struct",
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\tcdb:%x %x %x %x %x %x %x %x %x %x %x %x\\n\"",
            "hscb->cmdstore[0]",
            "hscb->cmdstore[1]",
            "hscb->cmdstore[2]",
            "hscb->cmdstore[3]",
            "hscb->cmdstore[4]",
            "hscb->cmdstore[5]",
            "hscb->cmdstore[6]",
            "hscb->cmdstore[7]",
            "hscb->cmdstore[8]",
            "hscb->cmdstore[9]",
            "hscb->cmdstore[10]",
            "hscb->cmdstore[11]"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_calc_residual __P((struct scb *scb));\nSTATIC void;\nSTATIC void;\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nahc_print_scb(scb)\n\tstruct scb *scb;\n{\n\tstruct hardware_scb *hscb = scb->hscb;\n\n\tprintf(\"scb:%p control:0x%x tcl:0x%x cmdlen:%d cmdpointer:0x%lx\\n\",\n\t\tscb,\n\t\thscb->control,\n\t\thscb->tcl,\n\t\thscb->cmdlen,\n\t\thscb->cmdpointer );\n\tprintf(\"        datlen:%d data:0x%lx segs:0x%x segp:0x%lx\\n\",\n\t\thscb->datalen,\n\t\thscb->data,\n\t\thscb->SG_count,\n\t\thscb->SG_pointer);\n\tprintf(\"\tsg_addr:%lx sg_len:%ld\\n\",\n\t\tscb->sg_list[0].addr,\n\t\tscb->sg_list[0].len);\n\tprintf(\"\tcdb:%x %x %x %x %x %x %x %x %x %x %x %x\\n\",\n\t\thscb->cmdstore[0], hscb->cmdstore[1], hscb->cmdstore[2],\n\t\thscb->cmdstore[3], hscb->cmdstore[4], hscb->cmdstore[5],\n\t\thscb->cmdstore[6], hscb->cmdstore[7], hscb->cmdstore[8],\n\t\thscb->cmdstore[9], hscb->cmdstore[10], hscb->cmdstore[11]);\n}"
  },
  {
    "function_name": "ahc_freedmamem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "747-761",
    "snippet": "STATIC void\nahc_freedmamem(tag, size, map, vaddr, seg, nseg)\n\tbus_dma_tag_t tag;\n\tint size;\n\tbus_dmamap_t map;\n\tcaddr_t vaddr;\n\tbus_dma_segment_t *seg;\n\tint nseg;\n{\n\n\tbus_dmamap_unload(tag, map);\n\tbus_dmamap_destroy(tag, map);\n\tbus_dmamem_unmap(tag, vaddr, size);\n\tbus_dmamem_free(tag, seg, nseg);\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define STATIC\tstatic",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_freedmamem __P((bus_dma_tag_t tag, int size,\n\t\t\t\tbus_dmamap_t map, caddr_t vaddr,\n\t\t\t\tbus_dma_segment_t *seg, int nseg));",
      "STATIC void"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_dmamem_free",
          "args": [
            "tag",
            "seg",
            "nseg"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_unmap",
          "args": [
            "tag",
            "vaddr",
            "size"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_destroy",
          "args": [
            "tag",
            "map"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_unload",
          "args": [
            "tag",
            "map"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_freedmamem __P((bus_dma_tag_t tag, int size,\n\t\t\t\tbus_dmamap_t map, caddr_t vaddr,\n\t\t\t\tbus_dma_segment_t *seg, int nseg));\nSTATIC void;\n\nSTATIC void\nahc_freedmamem(tag, size, map, vaddr, seg, nseg)\n\tbus_dma_tag_t tag;\n\tint size;\n\tbus_dmamap_t map;\n\tcaddr_t vaddr;\n\tbus_dma_segment_t *seg;\n\tint nseg;\n{\n\n\tbus_dmamap_unload(tag, map);\n\tbus_dmamap_destroy(tag, map);\n\tbus_dmamem_unmap(tag, vaddr, size);\n\tbus_dmamem_free(tag, seg, nseg);\n}"
  },
  {
    "function_name": "ahc_createdmamem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "678-745",
    "snippet": "int\nahc_createdmamem(ahc, size, mapp, vaddr, baddr, seg, nseg, what)\n\tstruct ahc_softc *ahc;\n\tint size;\n\tbus_dmamap_t *mapp;\n\tcaddr_t *vaddr;\n\tbus_addr_t *baddr;\n\tbus_dma_segment_t *seg;\n\tint *nseg;\n\tconst char *what;\n{\n\tint error, level = 0;\n\tint dma_flags = BUS_DMA_NOWAIT;\n\tbus_dma_tag_t tag = ahc->sc_dmat;\n\tconst char *myname = ahc_name(ahc);\n\tif ((ahc->chip & AHC_VL) !=0)\n\t\tdma_flags |= ISABUS_DMA_32BIT;\n\t\n\tif ((error = bus_dmamem_alloc(tag, size, NBPG, 0,\n\t\t\tseg, 1, nseg, BUS_DMA_NOWAIT)) != 0) {\n\t\tprintf(\"%s: failed to allocate DMA mem for %s, error = %d\\n\",\n\t\t\tmyname, what, error);\n\t\tgoto out;\n\t}\n\tlevel++;\n\n\tif ((error = bus_dmamem_map(tag, seg, *nseg, size, vaddr,\n\t\t\tBUS_DMA_NOWAIT|BUS_DMA_COHERENT)) != 0) {\n\t\tprintf(\"%s: failed to map DMA mem for %s, error = %d\\n\",\n\t\t\tmyname, what, error);\n\t\tgoto out;\n\t}\n\tlevel++;\n\n\tif ((error = bus_dmamap_create(tag, size, 1, size, 0,\n\t\t\tdma_flags, mapp)) != 0) {\n\t\tprintf(\"%s: failed to create DMA map for %s, error = %d\\n\",\n\t\t\tmyname, what, error);\n\t\tgoto out;\n        }\n\tlevel++;\n\n\tif ((error = bus_dmamap_load(tag, *mapp, *vaddr, size, NULL,\n\t\t\tBUS_DMA_NOWAIT)) != 0) {\n\t\tprintf(\"%s: failed to load DMA map for %s, error = %d\\n\",\n\t\t\tmyname, what, error);\n\t\tgoto out;\n        }\n\n\t*baddr = (*mapp)->dm_segs[0].ds_addr;\n\treturn 0;\nout:\n\tswitch (level) {\n\tcase 3:\n\t\tbus_dmamap_destroy(tag, *mapp);\n\t\t/* FALLTHROUGH */\n\tcase 2:\n\t\tbus_dmamem_unmap(tag, *vaddr, size);\n\t\t/* FALLTHROUGH */\n\tcase 1:\n\t\tbus_dmamem_free(tag, seg, *nseg);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define ISABUS_DMA_32BIT\tBUS_DMA_BUS1"
    ],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "int    ahc_createdmamem",
      "ahc_freedmamem __P((bus_dma_tag_t tag, int size,\n\t\t\t\tbus_dmamap_t map, caddr_t vaddr,\n\t\t\t\tbus_dma_segment_t *seg, int nseg));",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_dmamem_free",
          "args": [
            "tag",
            "seg",
            "*nseg"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_unmap",
          "args": [
            "tag",
            "*vaddr",
            "size"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_destroy",
          "args": [
            "tag",
            "*mapp"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: failed to load DMA map for %s, error = %d\\n\"",
            "myname",
            "what",
            "error"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_dmamap_load",
          "args": [
            "tag",
            "*mapp",
            "*vaddr",
            "size",
            "NULL",
            "BUS_DMA_NOWAIT"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_create",
          "args": [
            "tag",
            "size",
            "1",
            "size",
            "0",
            "dma_flags",
            "mapp"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_map",
          "args": [
            "tag",
            "seg",
            "*nseg",
            "size",
            "vaddr",
            "BUS_DMA_NOWAIT|BUS_DMA_COHERENT"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_alloc",
          "args": [
            "tag",
            "size",
            "NBPG",
            "0",
            "seg",
            "1",
            "nseg",
            "BUS_DMA_NOWAIT"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define ISABUS_DMA_32BIT\tBUS_DMA_BUS1\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC struct;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nahc_loadseq __P((struct ahc_softc *ahc));\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nahc_clear_intstat __P((struct ahc_softc *ahc));\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nrestart_sequencer __P((struct ahc_softc *ahc));\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nint    ahc_createdmamem;\nahc_freedmamem __P((bus_dma_tag_t tag, int size,\n\t\t\t\tbus_dmamap_t map, caddr_t vaddr,\n\t\t\t\tbus_dma_segment_t *seg, int nseg));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nint\nahc_createdmamem(ahc, size, mapp, vaddr, baddr, seg, nseg, what)\n\tstruct ahc_softc *ahc;\n\tint size;\n\tbus_dmamap_t *mapp;\n\tcaddr_t *vaddr;\n\tbus_addr_t *baddr;\n\tbus_dma_segment_t *seg;\n\tint *nseg;\n\tconst char *what;\n{\n\tint error, level = 0;\n\tint dma_flags = BUS_DMA_NOWAIT;\n\tbus_dma_tag_t tag = ahc->sc_dmat;\n\tconst char *myname = ahc_name(ahc);\n\tif ((ahc->chip & AHC_VL) !=0)\n\t\tdma_flags |= ISABUS_DMA_32BIT;\n\t\n\tif ((error = bus_dmamem_alloc(tag, size, NBPG, 0,\n\t\t\tseg, 1, nseg, BUS_DMA_NOWAIT)) != 0) {\n\t\tprintf(\"%s: failed to allocate DMA mem for %s, error = %d\\n\",\n\t\t\tmyname, what, error);\n\t\tgoto out;\n\t}\n\tlevel++;\n\n\tif ((error = bus_dmamem_map(tag, seg, *nseg, size, vaddr,\n\t\t\tBUS_DMA_NOWAIT|BUS_DMA_COHERENT)) != 0) {\n\t\tprintf(\"%s: failed to map DMA mem for %s, error = %d\\n\",\n\t\t\tmyname, what, error);\n\t\tgoto out;\n\t}\n\tlevel++;\n\n\tif ((error = bus_dmamap_create(tag, size, 1, size, 0,\n\t\t\tdma_flags, mapp)) != 0) {\n\t\tprintf(\"%s: failed to create DMA map for %s, error = %d\\n\",\n\t\t\tmyname, what, error);\n\t\tgoto out;\n        }\n\tlevel++;\n\n\tif ((error = bus_dmamap_load(tag, *mapp, *vaddr, size, NULL,\n\t\t\tBUS_DMA_NOWAIT)) != 0) {\n\t\tprintf(\"%s: failed to load DMA map for %s, error = %d\\n\",\n\t\t\tmyname, what, error);\n\t\tgoto out;\n        }\n\n\t*baddr = (*mapp)->dm_segs[0].ds_addr;\n\treturn 0;\nout:\n\tswitch (level) {\n\tcase 3:\n\t\tbus_dmamap_destroy(tag, *mapp);\n\t\t/* FALLTHROUGH */\n\tcase 2:\n\t\tbus_dmamem_unmap(tag, *vaddr, size);\n\t\t/* FALLTHROUGH */\n\tcase 1:\n\t\tbus_dmamem_free(tag, seg, *nseg);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "ahcfreescb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "617-648",
    "snippet": "STATIC void\nahcfreescb(ahc, scb)\n\tstruct ahc_softc *ahc;\n\tstruct scb *scb;\n{       \n\tstruct hardware_scb *hscb;\n\tint opri;\n\n\thscb = scb->hscb;\n\n#ifdef AHC_DEBUG\n\tif (ahc_debug & AHC_SHOWSCBALLOC)\n\t\tprintf(\"%s: free SCB tag %x\\n\", ahc_name(ahc), hscb->tag);\n#endif\n\n\topri = splbio();\n\n\tif ((ahc->flags & AHC_RESOURCE_SHORTAGE) != 0 ||\n\t    (scb->flags & SCB_RECOVERY_SCB) != 0) {\n\t\tahc->flags &= ~AHC_RESOURCE_SHORTAGE;\n\t\tahc->queue_blocked = 0;\n\t}\n\n\t/* Clean up for the next user */\n\tscb->flags = SCB_FREE;\n\thscb->control = 0;\n\thscb->status = 0;\n\n\tSLIST_INSERT_HEAD(&ahc->scb_data->free_scbs, scb, links);\n\n\tsplx(opri);\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define STATIC\tstatic",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
      "STATIC void",
      "STATIC void",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "ahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));",
      "STATIC int",
      "STATIC void",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_calc_residual __P((struct scb *scb));",
      "STATIC void",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
      "STATIC void",
      "STATIC void",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
      "STATIC void",
      "STATIC void",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "opri"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SLIST_INSERT_HEAD",
          "args": [
            "&ahc->scb_data->free_scbs",
            "scb",
            "links"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: free SCB tag %x\\n\"",
            "ahc_name(ahc)",
            "hscb->tag"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));\nSTATIC int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_calc_residual __P((struct scb *scb));\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahcfreescb(ahc, scb)\n\tstruct ahc_softc *ahc;\n\tstruct scb *scb;\n{       \n\tstruct hardware_scb *hscb;\n\tint opri;\n\n\thscb = scb->hscb;\n\n#ifdef AHC_DEBUG\n\tif (ahc_debug & AHC_SHOWSCBALLOC)\n\t\tprintf(\"%s: free SCB tag %x\\n\", ahc_name(ahc), hscb->tag);\n#endif\n\n\topri = splbio();\n\n\tif ((ahc->flags & AHC_RESOURCE_SHORTAGE) != 0 ||\n\t    (scb->flags & SCB_RECOVERY_SCB) != 0) {\n\t\tahc->flags &= ~AHC_RESOURCE_SHORTAGE;\n\t\tahc->queue_blocked = 0;\n\t}\n\n\t/* Clean up for the next user */\n\tscb->flags = SCB_FREE;\n\thscb->control = 0;\n\thscb->status = 0;\n\n\tSLIST_INSERT_HEAD(&ahc->scb_data->free_scbs, scb, links);\n\n\tsplx(opri);\n}"
  },
  {
    "function_name": "ahc_run_qoutfifo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "576-610",
    "snippet": "STATIC void\nahc_run_qoutfifo(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tstruct scb *scb;\n\tu_int  scb_index;\n\n\tbus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, \n\t\t\tBUS_DMASYNC_POSTREAD);\n\n\twhile (ahc->qoutfifo[ahc->qoutfifonext] != SCB_LIST_NULL) {\n\t\tscb_index = ahc->qoutfifo[ahc->qoutfifonext];\n\t\tahc->qoutfifo[ahc->qoutfifonext++] = SCB_LIST_NULL;\n\n\t\tscb = &ahc->scb_data->scbarray[scb_index];\n\t\tif (scb_index >= ahc->scb_data->numscbs\n\t\t  || (scb->flags & SCB_ACTIVE) == 0) {\n\t\t\tprintf(\"%s: WARNING no command for scb %d \"\n\t\t\t       \"(cmdcmplt)\\nQOUTPOS = %d\\n\",\n\t\t\t       ahc_name(ahc), scb_index,\n\t\t\t       ahc->qoutfifonext - 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Save off the residual\n\t\t * if there is one.\n\t\t */\n\t\tif (scb->hscb->residual_SG_count != 0)\n\t\t\tahc_calc_residual(scb);\n\t\telse\n\t\t\tscb->xs->resid = 0;\n\t\tahc_done(ahc, scb);\n\t}\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define STATIC\tstatic",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
      "STATIC void",
      "STATIC void",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC u_int",
      "STATIC void",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC u_int",
      "STATIC void",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "STATIC u_int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
      "STATIC void",
      "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_calc_residual __P((struct scb *scb));",
      "STATIC void",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
      "STATIC void",
      "STATIC void",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
      "STATIC void",
      "STATIC void",
      "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *xs;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ahc_done",
          "args": [
            "ahc",
            "scb"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "3401-3537",
          "snippet": "STATIC void\nahc_done(ahc, scb)\n\tstruct ahc_softc *ahc;\n\tstruct scb *scb;\n{\n\tstruct scsi_xfer *xs = scb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tint requeue = 0;\n\tint target;\n\n\tSC_DEBUG(xs->sc_link, SDEV_DB2, (\"ahc_done\\n\"));\n\t\n\tLIST_REMOVE(scb, pend_links);\n\n\tuntimeout(ahc_timeout, (caddr_t)scb);\n\n#ifdef AHC_DEBUG\n\tif (ahc_debug & AHC_SHOWCMDS) {\n\t\tsc_print_addr(sc_link);\n\t\tprintf(\"ahc_done opcode %d tag %x\\n\", xs->cmdstore.opcode,\n\t\t    scb->hscb->tag);\n\t}\n#endif\n\t\n\ttarget = sc_link->target;\n\t\n\tif (xs->datalen) {\n\t\tbus_dmasync_op_t op;\n\t\n\t\tif ((xs->flags & SCSI_DATA_IN) != 0)\n\t\t\top = BUS_DMASYNC_POSTREAD;\n\t\telse\n\t\t\top = BUS_DMASYNC_POSTWRITE;\n\t\tbus_dmamap_sync(ahc->sc_dmat, scb->dmamap, op);\n\t\tbus_dmamap_unload(ahc->sc_dmat, scb->dmamap);\n\t}\n\n\t/*\n\t * Unbusy this target/channel/lun.\n\t * XXX if we are holding two commands per lun, \n\t *     send the next command.\n\t */\n\tahc_index_busy_tcl(ahc, scb->hscb->tcl, /*unbusy*/TRUE);\n\n\t/*\n\t * If the recovery SCB completes, we have to be\n\t * out of our timeout.\n\t */\n\tif ((scb->flags & SCB_RECOVERY_SCB) != 0) {\n\n\t\tstruct\tscb *scbp;\n\n\t\t/*\n\t\t * We were able to complete the command successfully,\n\t\t * so reinstate the timeouts for all other pending\n\t\t * commands.\n\t\t */\n\t\tscbp = ahc->pending_scbs.lh_first;\n\t\twhile (scbp != NULL) {\n\t\t\tstruct scsi_xfer *txs = scbp->xs;\n\n\t\t\tif (!(txs->flags & SCSI_POLL)) {\n\t\t\t\ttimeout(ahc_timeout, scbp,\n\t\t\t\t    (scbp->xs->timeout * hz)/1000);\n\t\t\t}\n\t\t\tscbp = LIST_NEXT(scbp, pend_links);\n\t\t}\n\n\t\t/*\n\t\t * Ensure that we didn't put a second instance of this\n\t\t * SCB into the QINFIFO.\n\t\t */\n\t\tahc_search_qinfifo(ahc, SCB_TARGET(scb), SCB_CHANNEL(scb),\n\t\t\t\t   SCB_LUN(scb), scb->hscb->tag,\n\t\t\t\t   ROLE_INITIATOR, /*status*/0,\n\t\t\t\t   SEARCH_REMOVE);\n\t\tif (xs->error != XS_NOERROR)\n\t\t\tahcsetccbstatus(xs, XS_TIMEOUT);\n\t\tsc_print_addr(xs->sc_link);\n\t\tprintf(\"no longer in timeout, status = %x\\n\", xs->status);\n\t}\n\n\tif (xs->error != XS_NOERROR) {\n\t\t/* Don't clobber any existing error state */\n\t} else if ((scb->flags & SCB_SENSE) != 0) {\n\t\t/*\n\t\t * We performed autosense retrieval.\n\t\t *\n\t\t * bzero the sense data before having\n\t\t * the drive fill it.  The SCSI spec mandates\n\t\t * that any untransfered data should be\n\t\t * assumed to be zero.  Complete the 'bounce'\n\t\t * of sense information through buffers accessible\n\t\t * via bus-space by copying it into the clients\n\t\t * csio.\n\t\t */\n\t\tbzero(&xs->sense, sizeof(struct scsi_sense));\n\t\tbcopy(&ahc->scb_data->sense[scb->hscb->tag],\n\t\t      &xs->sense, scb->sg_list->len);\n\t\txs->error = XS_SENSE;\n\t}\n\tif (scb->flags & SCB_FREEZE_QUEUE) {\n\t\tahc->devqueue_blocked[target]--;\n\t\tscb->flags &= ~SCB_FREEZE_QUEUE;\n\t}\n\t\n\trequeue = scb->flags & SCB_REQUEUE;\n\tahcfreescb(ahc, scb);\n\n\tif (requeue) {\n\t\t/*\n\t\t * Re-insert at the front of the private queue to\n\t\t * preserve order.\n\t\t */\n\t\tint s;\n\n\t\ts = splbio();\n\t\t/* TAILQ_INSERT_HEAD(&ahc->sc_q, xs, adapter_q); */\n\t\tahc_list_insert_head(ahc, xs);\n\t\tsplx(s);\n\t} else {\n\t\txs->flags |= ITSDONE;\n\t\tahc_check_tags(ahc, xs);\n\t\tscsi_done(xs);\n\t}\n\n\t/*\n\t * If there are entries in the software queue, try to\n\t * run the first one.  We should be more or less guaranteed\n\t * to succeed, since we just freed an SCB.\n\t *\n\t * NOTE: ahc_scsi_cmd() relies on our calling it with\n\t * the first entry in the queue.\n\t */\n\tif ((xs = ahc->sc_xxxq.lh_first) != NULL)\n\t\t(void) ahc_scsi_cmd(xs);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
            "STATIC void",
            "ahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_done __P((struct ahc_softc *ahc, struct scb *scbp));",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "ahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));",
            "STATIC int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
            "STATIC void",
            "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_calc_residual __P((struct scb *scb));",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "static __inline u_int ahc_index_busy_tcl",
            "static __inline void ahcsetccbstatus",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "void   ahc_list_insert_head",
            "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *xs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nSTATIC void;\nahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_done __P((struct ahc_softc *ahc, struct scb *scbp));\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));\nSTATIC int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nSTATIC void;\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_calc_residual __P((struct scb *scb));\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nstatic __inline u_int ahc_index_busy_tcl;\nstatic __inline void ahcsetccbstatus;\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nSTATIC void;\nSTATIC void;\nvoid   ahc_list_insert_head;\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n\nSTATIC void\nahc_done(ahc, scb)\n\tstruct ahc_softc *ahc;\n\tstruct scb *scb;\n{\n\tstruct scsi_xfer *xs = scb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tint requeue = 0;\n\tint target;\n\n\tSC_DEBUG(xs->sc_link, SDEV_DB2, (\"ahc_done\\n\"));\n\t\n\tLIST_REMOVE(scb, pend_links);\n\n\tuntimeout(ahc_timeout, (caddr_t)scb);\n\n#ifdef AHC_DEBUG\n\tif (ahc_debug & AHC_SHOWCMDS) {\n\t\tsc_print_addr(sc_link);\n\t\tprintf(\"ahc_done opcode %d tag %x\\n\", xs->cmdstore.opcode,\n\t\t    scb->hscb->tag);\n\t}\n#endif\n\t\n\ttarget = sc_link->target;\n\t\n\tif (xs->datalen) {\n\t\tbus_dmasync_op_t op;\n\t\n\t\tif ((xs->flags & SCSI_DATA_IN) != 0)\n\t\t\top = BUS_DMASYNC_POSTREAD;\n\t\telse\n\t\t\top = BUS_DMASYNC_POSTWRITE;\n\t\tbus_dmamap_sync(ahc->sc_dmat, scb->dmamap, op);\n\t\tbus_dmamap_unload(ahc->sc_dmat, scb->dmamap);\n\t}\n\n\t/*\n\t * Unbusy this target/channel/lun.\n\t * XXX if we are holding two commands per lun, \n\t *     send the next command.\n\t */\n\tahc_index_busy_tcl(ahc, scb->hscb->tcl, /*unbusy*/TRUE);\n\n\t/*\n\t * If the recovery SCB completes, we have to be\n\t * out of our timeout.\n\t */\n\tif ((scb->flags & SCB_RECOVERY_SCB) != 0) {\n\n\t\tstruct\tscb *scbp;\n\n\t\t/*\n\t\t * We were able to complete the command successfully,\n\t\t * so reinstate the timeouts for all other pending\n\t\t * commands.\n\t\t */\n\t\tscbp = ahc->pending_scbs.lh_first;\n\t\twhile (scbp != NULL) {\n\t\t\tstruct scsi_xfer *txs = scbp->xs;\n\n\t\t\tif (!(txs->flags & SCSI_POLL)) {\n\t\t\t\ttimeout(ahc_timeout, scbp,\n\t\t\t\t    (scbp->xs->timeout * hz)/1000);\n\t\t\t}\n\t\t\tscbp = LIST_NEXT(scbp, pend_links);\n\t\t}\n\n\t\t/*\n\t\t * Ensure that we didn't put a second instance of this\n\t\t * SCB into the QINFIFO.\n\t\t */\n\t\tahc_search_qinfifo(ahc, SCB_TARGET(scb), SCB_CHANNEL(scb),\n\t\t\t\t   SCB_LUN(scb), scb->hscb->tag,\n\t\t\t\t   ROLE_INITIATOR, /*status*/0,\n\t\t\t\t   SEARCH_REMOVE);\n\t\tif (xs->error != XS_NOERROR)\n\t\t\tahcsetccbstatus(xs, XS_TIMEOUT);\n\t\tsc_print_addr(xs->sc_link);\n\t\tprintf(\"no longer in timeout, status = %x\\n\", xs->status);\n\t}\n\n\tif (xs->error != XS_NOERROR) {\n\t\t/* Don't clobber any existing error state */\n\t} else if ((scb->flags & SCB_SENSE) != 0) {\n\t\t/*\n\t\t * We performed autosense retrieval.\n\t\t *\n\t\t * bzero the sense data before having\n\t\t * the drive fill it.  The SCSI spec mandates\n\t\t * that any untransfered data should be\n\t\t * assumed to be zero.  Complete the 'bounce'\n\t\t * of sense information through buffers accessible\n\t\t * via bus-space by copying it into the clients\n\t\t * csio.\n\t\t */\n\t\tbzero(&xs->sense, sizeof(struct scsi_sense));\n\t\tbcopy(&ahc->scb_data->sense[scb->hscb->tag],\n\t\t      &xs->sense, scb->sg_list->len);\n\t\txs->error = XS_SENSE;\n\t}\n\tif (scb->flags & SCB_FREEZE_QUEUE) {\n\t\tahc->devqueue_blocked[target]--;\n\t\tscb->flags &= ~SCB_FREEZE_QUEUE;\n\t}\n\t\n\trequeue = scb->flags & SCB_REQUEUE;\n\tahcfreescb(ahc, scb);\n\n\tif (requeue) {\n\t\t/*\n\t\t * Re-insert at the front of the private queue to\n\t\t * preserve order.\n\t\t */\n\t\tint s;\n\n\t\ts = splbio();\n\t\t/* TAILQ_INSERT_HEAD(&ahc->sc_q, xs, adapter_q); */\n\t\tahc_list_insert_head(ahc, xs);\n\t\tsplx(s);\n\t} else {\n\t\txs->flags |= ITSDONE;\n\t\tahc_check_tags(ahc, xs);\n\t\tscsi_done(xs);\n\t}\n\n\t/*\n\t * If there are entries in the software queue, try to\n\t * run the first one.  We should be more or less guaranteed\n\t * to succeed, since we just freed an SCB.\n\t *\n\t * NOTE: ahc_scsi_cmd() relies on our calling it with\n\t * the first entry in the queue.\n\t */\n\tif ((xs = ahc->sc_xxxq.lh_first) != NULL)\n\t\t(void) ahc_scsi_cmd(xs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_calc_residual",
          "args": [
            "scb"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_calc_residual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "5577-5631",
          "snippet": "STATIC void\nahc_calc_residual(scb)\n\tstruct scb *scb;\n{\n\tstruct\thardware_scb *hscb;\n\n\thscb = scb->hscb;\n\n\t/*\n\t * If the disconnected flag is still set, this is bogus\n\t * residual information left over from a sequencer\n\t * pagin/pageout, so ignore this case.\n\t */\n\tif ((scb->hscb->control & DISCONNECTED) == 0) {\n\t\tu_int32_t resid;\n\t\tint\t  resid_sgs;\n\t\tint\t  sg;\n\t\t\n\t\t/*\n\t\t * Remainder of the SG where the transfer\n\t\t * stopped.\n\t\t */\n\t\tresid = (hscb->residual_data_count[2] << 16)\n\t\t      |\t(hscb->residual_data_count[1] <<8)\n\t\t      |\t(hscb->residual_data_count[0]);\n\n\t\t/*\n\t\t * Add up the contents of all residual\n\t\t * SG segments that are after the SG where\n\t\t * the transfer stopped.\n\t\t */\n\t\tresid_sgs = scb->hscb->residual_SG_count - 1/*current*/;\n\t\tsg = scb->sg_count - resid_sgs;\n\t\twhile (resid_sgs > 0) {\n\n\t\t\tresid += scb->sg_list[sg].len;\n\t\t\tsg++;\n\t\t\tresid_sgs--;\n\t\t}\n\t\tscb->xs->resid = resid;\n\t}\n\n\t/*\n\t * Clean out the residual information in this SCB for its\n\t * next consumer.\n\t */\n\thscb->residual_SG_count = 0;\n\n#ifdef AHC_DEBUG\n\tif (ahc_debug & AHC_SHOWMISC) {\n\t\tsc_print_addr(scb->xs->sc_link);\n\t\tprintf(\"Handled Residual of %ld bytes\\n\" ,scb->xs->resid);\n\t}\n#endif\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
            "STATIC void",
            "ahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC struct",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
            "STATIC void",
            "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_calc_residual __P((struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
            "STATIC void",
            "STATIC void",
            "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
            "STATIC struct",
            "STATIC struct",
            "STATIC struct",
            "struct scsi_xfer *xs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nSTATIC void;\nahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nSTATIC void;\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_calc_residual __P((struct scb *scb));\nSTATIC void;\nSTATIC void;\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nSTATIC struct;\nSTATIC struct;\nSTATIC struct;\nstruct scsi_xfer *xs;\n\nSTATIC void\nahc_calc_residual(scb)\n\tstruct scb *scb;\n{\n\tstruct\thardware_scb *hscb;\n\n\thscb = scb->hscb;\n\n\t/*\n\t * If the disconnected flag is still set, this is bogus\n\t * residual information left over from a sequencer\n\t * pagin/pageout, so ignore this case.\n\t */\n\tif ((scb->hscb->control & DISCONNECTED) == 0) {\n\t\tu_int32_t resid;\n\t\tint\t  resid_sgs;\n\t\tint\t  sg;\n\t\t\n\t\t/*\n\t\t * Remainder of the SG where the transfer\n\t\t * stopped.\n\t\t */\n\t\tresid = (hscb->residual_data_count[2] << 16)\n\t\t      |\t(hscb->residual_data_count[1] <<8)\n\t\t      |\t(hscb->residual_data_count[0]);\n\n\t\t/*\n\t\t * Add up the contents of all residual\n\t\t * SG segments that are after the SG where\n\t\t * the transfer stopped.\n\t\t */\n\t\tresid_sgs = scb->hscb->residual_SG_count - 1/*current*/;\n\t\tsg = scb->sg_count - resid_sgs;\n\t\twhile (resid_sgs > 0) {\n\n\t\t\tresid += scb->sg_list[sg].len;\n\t\t\tsg++;\n\t\t\tresid_sgs--;\n\t\t}\n\t\tscb->xs->resid = resid;\n\t}\n\n\t/*\n\t * Clean out the residual information in this SCB for its\n\t * next consumer.\n\t */\n\thscb->residual_SG_count = 0;\n\n#ifdef AHC_DEBUG\n\tif (ahc_debug & AHC_SHOWMISC) {\n\t\tsc_print_addr(scb->xs->sc_link);\n\t\tprintf(\"Handled Residual of %ld bytes\\n\" ,scb->xs->resid);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: WARNING no command for scb %d \"\n\t\t\t       \"(cmdcmplt)\\nQOUTPOS = %d\\n\"",
            "ahc_name(ahc)",
            "scb_index",
            "ahc->qoutfifonext - 1"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_sync",
          "args": [
            "ahc->sc_dmat",
            "ahc->shared_data_dmamap",
            "BUS_DMASYNC_POSTREAD"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nSTATIC void;\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_calc_residual __P((struct scb *scb));\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nSTATIC void;\nSTATIC void;\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n\nSTATIC void\nahc_run_qoutfifo(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tstruct scb *scb;\n\tu_int  scb_index;\n\n\tbus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, \n\t\t\tBUS_DMASYNC_POSTREAD);\n\n\twhile (ahc->qoutfifo[ahc->qoutfifonext] != SCB_LIST_NULL) {\n\t\tscb_index = ahc->qoutfifo[ahc->qoutfifonext];\n\t\tahc->qoutfifo[ahc->qoutfifonext++] = SCB_LIST_NULL;\n\n\t\tscb = &ahc->scb_data->scbarray[scb_index];\n\t\tif (scb_index >= ahc->scb_data->numscbs\n\t\t  || (scb->flags & SCB_ACTIVE) == 0) {\n\t\t\tprintf(\"%s: WARNING no command for scb %d \"\n\t\t\t       \"(cmdcmplt)\\nQOUTPOS = %d\\n\",\n\t\t\t       ahc_name(ahc), scb_index,\n\t\t\t       ahc->qoutfifonext - 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Save off the residual\n\t\t * if there is one.\n\t\t */\n\t\tif (scb->hscb->residual_SG_count != 0)\n\t\t\tahc_calc_residual(scb);\n\t\telse\n\t\t\tscb->xs->resid = 0;\n\t\tahc_done(ahc, scb);\n\t}\n}"
  },
  {
    "function_name": "ahcsetccbstatus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "548-554",
    "snippet": "static __inline void\nahcsetccbstatus(xs, status)\n\tstruct scsi_xfer *xs;\n\tint status;\n{\n\txs->error = status;\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "ahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));",
      "STATIC struct",
      "STATIC struct",
      "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
      "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
      "static __inline void ahcsetccbstatus",
      "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
      "STATIC struct",
      "STATIC struct",
      "STATIC struct",
      "struct scsi_xfer *xs;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nSTATIC struct;\nahc_abort_scbs __P((struct ahc_softc *ahc, int target,\n\t\t\t\t    char channel, int lun, u_int tag,\n\t\t\t\t    role_t role, u_int32_t status));\nSTATIC struct;\nSTATIC struct;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nstatic __inline void ahcsetccbstatus;\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nSTATIC struct;\nSTATIC struct;\nSTATIC struct;\nstruct scsi_xfer *xs;\n\nstatic __inline void\nahcsetccbstatus(xs, status)\n\tstruct scsi_xfer *xs;\n\tint status;\n{\n\txs->error = status;\n}"
  },
  {
    "function_name": "ahc_freeze_ccb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "533-546",
    "snippet": "static __inline void\nahc_freeze_ccb(scb)\n\tstruct scb *scb;\n{\n\tstruct scsi_xfer *xs = scb->xs;\n\tstruct ahc_softc *ahc = (struct ahc_softc *)xs->sc_link->adapter_softc;\n\tint target;\n\n\ttarget = xs->sc_link->target;\n\tif (!(scb->flags & SCB_FREEZE_QUEUE)) {\n\t\tahc->devqueue_blocked[target]++;\n\t\tscb->flags |= SCB_FREEZE_QUEUE;\n\t}\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
      "ahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "ahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "ahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));",
      "ahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));",
      "ahc_calc_residual __P((struct scb *scb));",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "static __inline void ahc_freeze_ccb",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
      "ahc_scsi_cmd __P((struct scsi_xfer *xs));",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *xs;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC struct;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));\nahc_loadseq __P((struct ahc_softc *ahc));\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nahc_clear_intstat __P((struct ahc_softc *ahc));\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nahc_istagged_device __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scsi_xfer *xs));\nahc_check_tags __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs));\nahc_calc_residual __P((struct scb *scb));\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nrestart_sequencer __P((struct ahc_softc *ahc));\nstatic __inline void ahc_freeze_ccb;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nahc_scsi_cmd __P((struct scsi_xfer *xs));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *xs;\n\nstatic __inline void\nahc_freeze_ccb(scb)\n\tstruct scb *scb;\n{\n\tstruct scsi_xfer *xs = scb->xs;\n\tstruct ahc_softc *ahc = (struct ahc_softc *)xs->sc_link->adapter_softc;\n\tint target;\n\n\ttarget = xs->sc_link->target;\n\tif (!(scb->flags & SCB_FREEZE_QUEUE)) {\n\t\tahc->devqueue_blocked[target]++;\n\t\tscb->flags |= SCB_FREEZE_QUEUE;\n\t}\n}"
  },
  {
    "function_name": "ahc_isbusy_tcl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "525-531",
    "snippet": "static __inline int\nahc_isbusy_tcl(ahc, scb)\n\tstruct ahc_softc *ahc;\n\tstruct scb *scb;\n{\n\treturn ahc->untagged_scbs[scb->hscb->tcl] != SCB_LIST_NULL;\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "ahc_calc_residual __P((struct scb *scb));",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "static __inline int\tahc_isbusy_tcl",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC struct;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nahc_loadseq __P((struct ahc_softc *ahc));\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nahc_clear_intstat __P((struct ahc_softc *ahc));\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nahc_calc_residual __P((struct scb *scb));\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nrestart_sequencer __P((struct ahc_softc *ahc));\nstatic __inline int\tahc_isbusy_tcl;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nstatic __inline int\nahc_isbusy_tcl(ahc, scb)\n\tstruct ahc_softc *ahc;\n\tstruct scb *scb;\n{\n\treturn ahc->untagged_scbs[scb->hscb->tcl] != SCB_LIST_NULL;\n}"
  },
  {
    "function_name": "ahc_busy_tcl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "515-523",
    "snippet": "static __inline void\nahc_busy_tcl(ahc, scb)\n\tstruct ahc_softc *ahc;\n\tstruct scb *scb;\n{\n\tahc->untagged_scbs[scb->hscb->tcl] = scb->hscb->tag;\n\tbus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, \n\t\t\tBUS_DMASYNC_PREWRITE);\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "ahc_calc_residual __P((struct scb *scb));",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "static __inline void\tahc_busy_tcl",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_dmamap_sync",
          "args": [
            "ahc->sc_dmat",
            "ahc->shared_data_dmamap",
            "BUS_DMASYNC_PREWRITE"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC struct;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nahc_loadseq __P((struct ahc_softc *ahc));\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nahc_clear_intstat __P((struct ahc_softc *ahc));\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nahc_calc_residual __P((struct scb *scb));\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nrestart_sequencer __P((struct ahc_softc *ahc));\nstatic __inline void\tahc_busy_tcl;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nstatic __inline void\nahc_busy_tcl(ahc, scb)\n\tstruct ahc_softc *ahc;\n\tstruct scb *scb;\n{\n\tahc->untagged_scbs[scb->hscb->tcl] = scb->hscb->tag;\n\tbus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, \n\t\t\tBUS_DMASYNC_PREWRITE);\n}"
  },
  {
    "function_name": "ahc_index_busy_tcl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "497-513",
    "snippet": "static __inline u_int\nahc_index_busy_tcl(ahc, tcl, unbusy)\n\tstruct ahc_softc *ahc;\n\tu_int tcl;\n\tint unbusy;\n{\n\tu_int scbid;\n\n\tscbid = ahc->untagged_scbs[tcl];\n\tif (unbusy) {\n\t\tahc->untagged_scbs[tcl] = SCB_LIST_NULL;\n\t\tbus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, \n\t\t\t\tBUS_DMASYNC_PREWRITE);\n\t}\n\n\treturn (scbid);\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC u_int",
      "STATIC struct",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "STATIC u_int",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "STATIC u_int",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "static __inline u_int ahc_index_busy_tcl",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_dmamap_sync",
          "args": [
            "ahc->sc_dmat",
            "ahc->shared_data_dmamap",
            "BUS_DMASYNC_PREWRITE"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC u_int;\nSTATIC struct;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC u_int;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nahc_clear_intstat __P((struct ahc_softc *ahc));\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nrestart_sequencer __P((struct ahc_softc *ahc));\nstatic __inline u_int ahc_index_busy_tcl;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nstatic __inline u_int\nahc_index_busy_tcl(ahc, tcl, unbusy)\n\tstruct ahc_softc *ahc;\n\tu_int tcl;\n\tint unbusy;\n{\n\tu_int scbid;\n\n\tscbid = ahc->untagged_scbs[tcl];\n\tif (unbusy) {\n\t\tahc->untagged_scbs[tcl] = SCB_LIST_NULL;\n\t\tbus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, \n\t\t\t\tBUS_DMASYNC_PREWRITE);\n\t}\n\n\treturn (scbid);\n}"
  },
  {
    "function_name": "restart_sequencer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "467-495",
    "snippet": "STATIC void\nrestart_sequencer(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tu_int i;\n\n\tpause_sequencer(ahc);\n\n\t/*\n\t * Everytime we restart the sequencer, there\n\t * is the possiblitity that we have restarted\n\t * within a three instruction window where an\n\t * SCB has been marked free but has not made it\n\t * onto the free list.  Since SCSI events(bus reset,\n\t * unexpected bus free) will always freeze the\n\t * sequencer, we cannot close this window.  To\n\t * avoid losing an SCB, we reconsitute the free\n\t * list every time we restart the sequencer.\n\t */\n\tahc_outb(ahc, FREE_SCBH, SCB_LIST_NULL);\n\tfor (i = 0; i < ahc->scb_data->maxhscbs; i++) {\n\t\t\n\t\tahc_outb(ahc, SCBPTR, i);\n\t\tif (ahc_inb(ahc, SCB_TAG) == SCB_LIST_NULL)\n\t\t\tahc_add_curscb_to_free_list(ahc);\n\t}\n\tahc_outb(ahc, SEQCTL, FASTMODE|SEQRESET);\n\tunpause_sequencer(ahc);\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define STATIC\tstatic",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC u_int",
      "STATIC void",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC u_int",
      "STATIC void",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "STATIC u_int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "static __inline void pause_sequencer",
      "static __inline void unpause_sequencer",
      "STATIC void",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "STATIC void",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unpause_sequencer",
          "args": [
            "ahc"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "unpause_sequencer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "456-462",
          "snippet": "static __inline void\nunpause_sequencer(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tif ((ahc_inb(ahc, INTSTAT) & (SCSIINT | SEQINT | BRKADRINT)) == 0)\n\t\tahc_outb(ahc, HCNTRL, ahc->unpause);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "static __inline void unpause_sequencer",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC struct;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nahc_loadseq __P((struct ahc_softc *ahc));\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nahc_clear_intstat __P((struct ahc_softc *ahc));\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nstatic __inline void unpause_sequencer;\nrestart_sequencer __P((struct ahc_softc *ahc));\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nstatic __inline void\nunpause_sequencer(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tif ((ahc_inb(ahc, INTSTAT) & (SCSIINT | SEQINT | BRKADRINT)) == 0)\n\t\tahc_outb(ahc, HCNTRL, ahc->unpause);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SEQCTL",
            "FASTMODE|SEQRESET"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_add_curscb_to_free_list",
          "args": [
            "ahc"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_add_curscb_to_free_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "5319-5328",
          "snippet": "STATIC void\nahc_add_curscb_to_free_list(ahc)\n\tstruct ahc_softc *ahc;\n{\n\t/* Invalidate the tag so that ahc_find_scb doesn't think it's active */\n\tahc_outb(ahc, SCB_TAG, SCB_LIST_NULL);\n\n\tahc_outb(ahc, SCB_NEXT, ahc_inb(ahc, FREE_SCBH));\n\tahc_outb(ahc, FREE_SCBH, ahc_inb(ahc, SCBPTR));\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_add_curscb_to_free_list(ahc)\n\tstruct ahc_softc *ahc;\n{\n\t/* Invalidate the tag so that ahc_find_scb doesn't think it's active */\n\tahc_outb(ahc, SCB_TAG, SCB_LIST_NULL);\n\n\tahc_outb(ahc, SCB_NEXT, ahc_inb(ahc, FREE_SCBH));\n\tahc_outb(ahc, FREE_SCBH, ahc_inb(ahc, SCBPTR));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCB_TAG"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "SCBPTR",
            "i"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "FREE_SCBH",
            "SCB_LIST_NULL"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nstatic __inline void pause_sequencer;\nstatic __inline void unpause_sequencer;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nrestart_sequencer(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tu_int i;\n\n\tpause_sequencer(ahc);\n\n\t/*\n\t * Everytime we restart the sequencer, there\n\t * is the possiblitity that we have restarted\n\t * within a three instruction window where an\n\t * SCB has been marked free but has not made it\n\t * onto the free list.  Since SCSI events(bus reset,\n\t * unexpected bus free) will always freeze the\n\t * sequencer, we cannot close this window.  To\n\t * avoid losing an SCB, we reconsitute the free\n\t * list every time we restart the sequencer.\n\t */\n\tahc_outb(ahc, FREE_SCBH, SCB_LIST_NULL);\n\tfor (i = 0; i < ahc->scb_data->maxhscbs; i++) {\n\t\t\n\t\tahc_outb(ahc, SCBPTR, i);\n\t\tif (ahc_inb(ahc, SCB_TAG) == SCB_LIST_NULL)\n\t\t\tahc_add_curscb_to_free_list(ahc);\n\t}\n\tahc_outb(ahc, SEQCTL, FASTMODE|SEQRESET);\n\tunpause_sequencer(ahc);\n}"
  },
  {
    "function_name": "unpause_sequencer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "456-462",
    "snippet": "static __inline void\nunpause_sequencer(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tif ((ahc_inb(ahc, INTSTAT) & (SCSIINT | SEQINT | BRKADRINT)) == 0)\n\t\tahc_outb(ahc, HCNTRL, ahc->unpause);\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "static __inline void unpause_sequencer",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "HCNTRL",
            "ahc->unpause"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "INTSTAT"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC struct;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nahc_loadseq __P((struct ahc_softc *ahc));\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nahc_clear_intstat __P((struct ahc_softc *ahc));\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nstatic __inline void unpause_sequencer;\nrestart_sequencer __P((struct ahc_softc *ahc));\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nstatic __inline void\nunpause_sequencer(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tif ((ahc_inb(ahc, INTSTAT) & (SCSIINT | SEQINT | BRKADRINT)) == 0)\n\t\tahc_outb(ahc, HCNTRL, ahc->unpause);\n}"
  },
  {
    "function_name": "pause_sequencer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "442-454",
    "snippet": "static __inline void\npause_sequencer(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tahc_outb(ahc, HCNTRL, ahc->pause);\n\n\t/*\n\t * Since the sequencer can disable pausing in a critical section, we\n\t * must loop until it actually stops.\n\t */\n\twhile (sequencer_paused(ahc) == 0)\n\t\t;\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "static __inline int  sequencer_paused",
      "static __inline void pause_sequencer",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sequencer_paused",
          "args": [
            "ahc"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "sequencer_paused",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "435-440",
          "snippet": "static __inline int\nsequencer_paused(ahc)\n\tstruct ahc_softc *ahc;\n{\n\treturn ((ahc_inb(ahc, HCNTRL) & PAUSE) != 0);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "static __inline int  sequencer_paused",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC struct;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nahc_loadseq __P((struct ahc_softc *ahc));\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nahc_clear_intstat __P((struct ahc_softc *ahc));\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nstatic __inline int  sequencer_paused;\nrestart_sequencer __P((struct ahc_softc *ahc));\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nstatic __inline int\nsequencer_paused(ahc)\n\tstruct ahc_softc *ahc;\n{\n\treturn ((ahc_inb(ahc, HCNTRL) & PAUSE) != 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_outb",
          "args": [
            "ahc",
            "HCNTRL",
            "ahc->pause"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC struct;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nahc_loadseq __P((struct ahc_softc *ahc));\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nahc_clear_intstat __P((struct ahc_softc *ahc));\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nstatic __inline int  sequencer_paused;\nstatic __inline void pause_sequencer;\nrestart_sequencer __P((struct ahc_softc *ahc));\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nstatic __inline void\npause_sequencer(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tahc_outb(ahc, HCNTRL, ahc->pause);\n\n\t/*\n\t * Since the sequencer can disable pausing in a critical section, we\n\t * must loop until it actually stops.\n\t */\n\twhile (sequencer_paused(ahc) == 0)\n\t\t;\n}"
  },
  {
    "function_name": "sequencer_paused",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "435-440",
    "snippet": "static __inline int\nsequencer_paused(ahc)\n\tstruct ahc_softc *ahc;\n{\n\treturn ((ahc_inb(ahc, HCNTRL) & PAUSE) != 0);\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "static __inline int  sequencer_paused",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "HCNTRL"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC struct;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nahc_loadseq __P((struct ahc_softc *ahc));\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nahc_clear_intstat __P((struct ahc_softc *ahc));\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nstatic __inline int  sequencer_paused;\nrestart_sequencer __P((struct ahc_softc *ahc));\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nstatic __inline int\nsequencer_paused(ahc)\n\tstruct ahc_softc *ahc;\n{\n\treturn ((ahc_inb(ahc, HCNTRL) & PAUSE) != 0);\n}"
  },
  {
    "function_name": "ahc_hscb_busaddr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "426-431",
    "snippet": "static __inline u_int32_t\nahc_hscb_busaddr(struct ahc_softc *ahc, u_int index)\n{\n\treturn (ahc->scb_data->hscb_busaddr\n\t\t+ (sizeof(struct hardware_scb) * index));\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
      "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
      "ahcallocscbs __P((struct ahc_softc *ahc));",
      "STATIC u_int",
      "STATIC struct",
      "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
      "ahc_loadseq __P((struct ahc_softc *ahc));",
      "STATIC u_int",
      "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
      "ahc_clear_intstat __P((struct ahc_softc *ahc));",
      "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
      "STATIC struct",
      "STATIC struct",
      "STATIC u_int",
      "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
      "restart_sequencer __P((struct ahc_softc *ahc));",
      "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
      "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
      "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
      "STATIC struct",
      "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
      "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC u_int;\nSTATIC struct;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC u_int;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nahc_clear_intstat __P((struct ahc_softc *ahc));\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nrestart_sequencer __P((struct ahc_softc *ahc));\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nstatic __inline u_int32_t\nahc_hscb_busaddr(struct ahc_softc *ahc, u_int index)\n{\n\treturn (ahc->scb_data->hscb_busaddr\n\t\t+ (sizeof(struct hardware_scb) * index));\n}"
  },
  {
    "function_name": "ahcminphys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
    "lines": "408-423",
    "snippet": "STATIC void\nahcminphys(bp)\n\tstruct buf *bp;\n{\n/*\n * Even though the card can transfer up to 16megs per command\n * we are limited by the number of segments in the dma segment\n * list that we can hold.  The worst case is that all pages are\n * discontinuous physically, hense the \"page per segment\" limit\n * enforced here.\n */\n\tif (bp->b_bcount > ((AHC_NSEG - 1) * PAGE_SIZE)) {\n\t\tbp->b_bcount = ((AHC_NSEG - 1) * PAGE_SIZE);\n\t}\n\tminphys(bp);\n}",
    "includes": [
      "#include <sys/kernel.h>",
      "#include \"pci.h\"",
      "#include <dev/microcode/aic7xxx/sequencer.h>",
      "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define STATIC\tstatic",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC struct",
      "STATIC struct",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "ahcminphys __P((struct buf *bp));",
      "STATIC struct",
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "minphys",
          "args": [
            "bp"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "ahcminphys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "408-423",
          "snippet": "STATIC void\nahcminphys(bp)\n\tstruct buf *bp;\n{\n/*\n * Even though the card can transfer up to 16megs per command\n * we are limited by the number of segments in the dma segment\n * list that we can hold.  The worst case is that all pages are\n * discontinuous physically, hense the \"page per segment\" limit\n * enforced here.\n */\n\tif (bp->b_bcount > ((AHC_NSEG - 1) * PAGE_SIZE)) {\n\t\tbp->b_bcount = ((AHC_NSEG - 1) * PAGE_SIZE);\n\t}\n\tminphys(bp);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahcminphys __P((struct buf *bp));\nSTATIC struct;\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nahcminphys(bp)\n\tstruct buf *bp;\n{\n/*\n * Even though the card can transfer up to 16megs per command\n * we are limited by the number of segments in the dma segment\n * list that we can hold.  The worst case is that all pages are\n * discontinuous physically, hense the \"page per segment\" limit\n * enforced here.\n */\n\tif (bp->b_bcount > ((AHC_NSEG - 1) * PAGE_SIZE)) {\n\t\tbp->b_bcount = ((AHC_NSEG - 1) * PAGE_SIZE);\n\t}\n\tminphys(bp);\n}"
  }
]