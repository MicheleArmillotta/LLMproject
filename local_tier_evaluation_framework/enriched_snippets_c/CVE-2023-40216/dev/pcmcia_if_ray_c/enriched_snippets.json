[
  {
    "function_name": "ray_update_siglev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
    "lines": "3290-3325",
    "snippet": "static void\nray_update_siglev(sc, src, siglev)\n\tstruct ray_softc *sc;\n\tu_int8_t *src;\n\tu_int8_t siglev;\n{\n\tint i, mini;\n\tstruct timeval mint;\n\tstruct ray_siglev *sl;\n\n\t/* try to find host */\n\tfor (i = 0; i < RAY_NSIGLEVRECS; i++) {\n\t\tsl = &sc->sc_siglevs[i];\n\t\tif (memcmp(sl->rsl_host, src, ETHER_ADDR_LEN) == 0)\n\t\t\tgoto found;\n\t}\n\t/* not found, find oldest slot */\n\tmini = 0;\n\tmint.tv_sec = LONG_MAX;\n\tmint.tv_usec = 0;\n\tfor (i = 0; i < RAY_NSIGLEVRECS; i++) {\n\t\tsl = &sc->sc_siglevs[i];\n\t\tif (timercmp(&sl->rsl_time, &mint, <)) {\n\t\t\tmini = i;\n\t\t\tmint = sl->rsl_time;\n\t\t}\n\t}\n\tsl = &sc->sc_siglevs[mini];\n\tmemset(sl->rsl_siglevs, 0, RAY_NSIGLEV);\n\tmemcpy(sl->rsl_host, src, ETHER_ADDR_LEN);\n\n found:\n\tmicrotime(&sl->rsl_time);\n\tmemmove(&sl->rsl_siglevs[1], sl->rsl_siglevs, RAY_NSIGLEV-1);\n\tsl->rsl_siglevs[0] = siglev;\n}",
    "includes": [
      "#include <dev/pcmcia/if_rayreg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_llc.h>",
      "#include <net/if_media.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/timeout.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [
      "#define\tmemmove\t\tmemcpy\t\t/* XXX */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&sl->rsl_siglevs[1]",
            "sl->rsl_siglevs",
            "RAY_NSIGLEV-1"
          ],
          "line": 3323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "microtime",
          "args": [
            "&sl->rsl_time"
          ],
          "line": 3322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sl->rsl_host",
            "src",
            "ETHER_ADDR_LEN"
          ],
          "line": 3319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "sl->rsl_siglevs",
            "0",
            "RAY_NSIGLEV"
          ],
          "line": 3318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timercmp",
          "args": [
            "&sl->rsl_time",
            "&mint, <"
          ],
          "line": 3312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "sl->rsl_host",
            "src",
            "ETHER_ADDR_LEN"
          ],
          "line": 3303
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tmemmove\t\tmemcpy\t\t/* XXX */\n\nstatic void\nray_update_siglev(sc, src, siglev)\n\tstruct ray_softc *sc;\n\tu_int8_t *src;\n\tu_int8_t siglev;\n{\n\tint i, mini;\n\tstruct timeval mint;\n\tstruct ray_siglev *sl;\n\n\t/* try to find host */\n\tfor (i = 0; i < RAY_NSIGLEVRECS; i++) {\n\t\tsl = &sc->sc_siglevs[i];\n\t\tif (memcmp(sl->rsl_host, src, ETHER_ADDR_LEN) == 0)\n\t\t\tgoto found;\n\t}\n\t/* not found, find oldest slot */\n\tmini = 0;\n\tmint.tv_sec = LONG_MAX;\n\tmint.tv_usec = 0;\n\tfor (i = 0; i < RAY_NSIGLEVRECS; i++) {\n\t\tsl = &sc->sc_siglevs[i];\n\t\tif (timercmp(&sl->rsl_time, &mint, <)) {\n\t\t\tmini = i;\n\t\t\tmint = sl->rsl_time;\n\t\t}\n\t}\n\tsl = &sc->sc_siglevs[mini];\n\tmemset(sl->rsl_siglevs, 0, RAY_NSIGLEV);\n\tmemcpy(sl->rsl_host, src, ETHER_ADDR_LEN);\n\n found:\n\tmicrotime(&sl->rsl_time);\n\tmemmove(&sl->rsl_siglevs[1], sl->rsl_siglevs, RAY_NSIGLEV-1);\n\tsl->rsl_siglevs[0] = siglev;\n}"
  },
  {
    "function_name": "ray_dump_mbuf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
    "lines": "3262-3286",
    "snippet": "void\nray_dump_mbuf(sc, m)\n\tstruct ray_softc *sc;\n\tstruct mbuf *m;\n{\n\tu_int8_t *d, *ed;\n\tu_int i;\n\n\tprintf(\"%s: pkt dump:\", sc->sc_xname);\n\ti = 0;\n\tfor (; m; m = m->m_next) {\n\t\td = mtod(m, u_int8_t *);\n\t\ted = d + m->m_len;\n\n\t\tfor (; d < ed; i++, d++) {\n\t\t\tif ((i % 16) == 0)\n\t\t\t\tprintf(\"\\n\\t\");\n\t\t\telse if ((i % 8) == 0)\n\t\t\t\tprintf(\"  \");\n\t\t\tprintf(\" %02x\", *d);\n\t\t}\n\t}\n\tif ((i - 1) % 16)\n\t\tprintf(\"\\n\");\n}",
    "includes": [
      "#include <dev/pcmcia/if_rayreg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_llc.h>",
      "#include <net/if_media.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/timeout.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [
      "#define\tsc_xname\tsc_dev.dv_xname"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 3285
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "u_int8_t*"
          ],
          "line": 3273
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_xname\tsc_dev.dv_xname\n\nvoid\nray_dump_mbuf(sc, m)\n\tstruct ray_softc *sc;\n\tstruct mbuf *m;\n{\n\tu_int8_t *d, *ed;\n\tu_int i;\n\n\tprintf(\"%s: pkt dump:\", sc->sc_xname);\n\ti = 0;\n\tfor (; m; m = m->m_next) {\n\t\td = mtod(m, u_int8_t *);\n\t\ted = d + m->m_len;\n\n\t\tfor (; d < ed; i++, d++) {\n\t\t\tif ((i % 16) == 0)\n\t\t\t\tprintf(\"\\n\\t\");\n\t\t\telse if ((i % 8) == 0)\n\t\t\t\tprintf(\"  \");\n\t\t\tprintf(\" %02x\", *d);\n\t\t}\n\t}\n\tif ((i - 1) % 16)\n\t\tprintf(\"\\n\");\n}"
  },
  {
    "function_name": "hexdump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
    "lines": "3184-3258",
    "snippet": "void\nhexdump(const u_int8_t *d, int len, int br, int div, int fl)\n{\n\tint i, j, offw, first, tlen, ni, nj, sp;\n\n\tsp = br / div;\n\toffw = 0;\n\tif (len && (fl & HEXDF_NOOFFSET) == 0) {\n\t\ttlen = len;\n\t\tdo {\n\t\t\toffw++;\n\t\t} while (tlen /= br);\n\t}\n\tif (offw)\n\t\tprintf(\"%0*x: \", offw, 0);\n\tfor (i = 0; i < len; i++, d++) {\n\t\tif (i && (i % br) == 0) {\n\t\t\tif ((fl & HEXDF_NOASCII) == 0) {\n\t\t\t\tprintf(\"   \");\n\t\t\t\td -= br;\n\t\t\t\tfor (j = 0; j < br; d++, j++) {\n\t\t\t\t\tif (j && (j % sp) == 0)\n\t\t\t\t\t\tprintf(\" \");\n\t\t\t\t\tif (PRINTABLE(*d))\n\t\t\t\t\t\tprintf(\"%c\", (int)*d);\n\t\t\t\t\telse\n\t\t\t\t\t\tprintf(\".\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (offw)\n\t\t\t\tprintf(\"\\n%0*x: \", offw, i);\n\t\t\telse\n\t\t\t\tprintf(\"\\n\");\n\t\t\tif ((fl & HEXDF_NOCOMPRESS) == 0) {\n\t\t\t\tfirst = 1;\n\t\t\t\twhile (len - i >= br) {\n\t\t\t\t\tif (memcmp(d, d - br, br))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\td += br;\n\t\t\t\t\ti += br;\n\t\t\t\t\tif (first) {\n\t\t\t\t\t\tprintf(\"*\");\n\t\t\t\t\t\tfirst = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (len == i) {\n\t\t\t\t\tprintf(\"\\n%0*x\", offw, i);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (i && (i % sp) == 0)\n\t\t\tprintf(\" \");\n\t\tprintf(\"%02x \", *d);\n\t}\n\tif (len && (((i - 1) % br) || i == 1)) {\n\t\tif ((fl & HEXDF_NOASCII) == 0) {\n\t\t\ti = i % br ? i % br : br;\n\t\t\tni = (br - i) % br;\n\t\t\tj = (i - 1) / sp;\n\t\t\tnj = (div - j - 1) % div;\n\t\t\tj = 3 * ni + nj + 3;\n\t\t\tprintf(\"%*s\", j, \"\");\n\t\t\td -= i;\n\t\t\tfor (j = 0; j < i; d++, j++) {\n\t\t\t\tif (j && (j % sp) == 0)\n\t\t\t\t\tprintf(\" \");\n\t\t\t\tif (PRINTABLE(*d))\n\t\t\t\t\tprintf(\"%c\", (int)*d);\n\t\t\t\telse\n\t\t\t\t\tprintf(\".\");\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}",
    "includes": [
      "#include <dev/pcmcia/if_rayreg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_llc.h>",
      "#include <net/if_media.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/timeout.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [
      "#define HEXDF_NOASCII\t\t0x4",
      "#define\tHEXDF_NOOFFSET\t\t0x2",
      "#define\tHEXDF_NOCOMPRESS\t0x1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 3256
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINTABLE",
          "args": [
            "*d"
          ],
          "line": 3250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "d",
            "d - br",
            "br"
          ],
          "line": 3220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTABLE",
          "args": [
            "*d"
          ],
          "line": 3207
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define HEXDF_NOASCII\t\t0x4\n#define\tHEXDF_NOOFFSET\t\t0x2\n#define\tHEXDF_NOCOMPRESS\t0x1\n\nvoid\nhexdump(const u_int8_t *d, int len, int br, int div, int fl)\n{\n\tint i, j, offw, first, tlen, ni, nj, sp;\n\n\tsp = br / div;\n\toffw = 0;\n\tif (len && (fl & HEXDF_NOOFFSET) == 0) {\n\t\ttlen = len;\n\t\tdo {\n\t\t\toffw++;\n\t\t} while (tlen /= br);\n\t}\n\tif (offw)\n\t\tprintf(\"%0*x: \", offw, 0);\n\tfor (i = 0; i < len; i++, d++) {\n\t\tif (i && (i % br) == 0) {\n\t\t\tif ((fl & HEXDF_NOASCII) == 0) {\n\t\t\t\tprintf(\"   \");\n\t\t\t\td -= br;\n\t\t\t\tfor (j = 0; j < br; d++, j++) {\n\t\t\t\t\tif (j && (j % sp) == 0)\n\t\t\t\t\t\tprintf(\" \");\n\t\t\t\t\tif (PRINTABLE(*d))\n\t\t\t\t\t\tprintf(\"%c\", (int)*d);\n\t\t\t\t\telse\n\t\t\t\t\t\tprintf(\".\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (offw)\n\t\t\t\tprintf(\"\\n%0*x: \", offw, i);\n\t\t\telse\n\t\t\t\tprintf(\"\\n\");\n\t\t\tif ((fl & HEXDF_NOCOMPRESS) == 0) {\n\t\t\t\tfirst = 1;\n\t\t\t\twhile (len - i >= br) {\n\t\t\t\t\tif (memcmp(d, d - br, br))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\td += br;\n\t\t\t\t\ti += br;\n\t\t\t\t\tif (first) {\n\t\t\t\t\t\tprintf(\"*\");\n\t\t\t\t\t\tfirst = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (len == i) {\n\t\t\t\t\tprintf(\"\\n%0*x\", offw, i);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (i && (i % sp) == 0)\n\t\t\tprintf(\" \");\n\t\tprintf(\"%02x \", *d);\n\t}\n\tif (len && (((i - 1) % br) || i == 1)) {\n\t\tif ((fl & HEXDF_NOASCII) == 0) {\n\t\t\ti = i % br ? i % br : br;\n\t\t\tni = (br - i) % br;\n\t\t\tj = (i - 1) / sp;\n\t\t\tnj = (div - j - 1) % div;\n\t\t\tj = 3 * ni + nj + 3;\n\t\t\tprintf(\"%*s\", j, \"\");\n\t\t\td -= i;\n\t\t\tfor (j = 0; j < i; d++, j++) {\n\t\t\t\tif (j && (j % sp) == 0)\n\t\t\t\t\tprintf(\" \");\n\t\t\t\tif (PRINTABLE(*d))\n\t\t\t\t\tprintf(\"%c\", (int)*d);\n\t\t\t\telse\n\t\t\t\t\tprintf(\".\");\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "function_name": "ray_write_region",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
    "lines": "3125-3177",
    "snippet": "void\nray_write_region(sc, off, vp, c)\n\tstruct ray_softc *sc;\n\tbus_size_t off;\n\tvoid *vp;\n\tsize_t c;\n{\n#ifdef RAY_USE_OPTIMIZED_COPY\n\tsize_t n2, n4, tmp;\n\tu_int8_t *p;\n\n\tp = vp;\n\t/* XXX we may be making poor assumptions here but lets hope */\n\tswitch ((off|(bus_addr_t)p) & 0x03) {\n\tcase 0:\n\t\tif ((n4 = (c >> 2))) {\n\t\t\tbus_space_write_region_4(sc->sc_memt, sc->sc_memh, off,\n\t\t\t    p, n4);\n\t\t\ttmp = c & ~0x3;\n\t\t\tc &= 0x3;\n\t\t\tp += tmp;\n\t\t\toff += tmp;\n\t\t}\n\t\tswitch (c) {\n\t\tcase 3:\n\t\t\tbus_space_write_1(sc->sc_memt,sc->sc_memh, off, *p);\n\t\t\tp++, off++;\n\t\tcase 2:\n\t\t\tbus_space_write_1(sc->sc_memt,sc->sc_memh, off, *p);\n\t\t\tp++, off++;\n\t\tcase 1:\n\t\t\tbus_space_write_1(sc->sc_memt,sc->sc_memh, off, *p);\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tif ((n2 = (c >> 1)))\n\t\t\tbus_space_write_region_2(sc->sc_memt, sc->sc_memh, off,\n\t\t\t    p, n2);\n\t\tif (c & 0x1) {\n\t\t\tc &= ~0x1;\n\t\t\tbus_space_write_1(sc->sc_memt, sc->sc_memh,\n\t\t\t    off + c, *(p + c));\n\t\t}\n\t\tbreak;\n\tcase 1:\n\tcase 3:\n\t\tbus_space_write_region_1(sc->sc_memt, sc->sc_memh, off, p, c);\n\t\tbreak;\n\t}\n#else\n\tbus_space_write_region_1(sc->sc_memt, sc->sc_memh, off, vp, c);\n#endif\n}",
    "includes": [
      "#include <dev/pcmcia/if_rayreg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_llc.h>",
      "#include <net/if_media.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/timeout.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [
      "#define\tsc_memh\tsc_mem.memh",
      "#define\tsc_memt\tsc_mem.memt"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_region_1",
          "args": [
            "sc->sc_memt",
            "sc->sc_memh",
            "off",
            "vp",
            "c"
          ],
          "line": 3175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_region_1",
          "args": [
            "sc->sc_memt",
            "sc->sc_memh",
            "off",
            "p",
            "c"
          ],
          "line": 3171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->sc_memt",
            "sc->sc_memh",
            "off + c",
            "*(p + c)"
          ],
          "line": 3165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_region_2",
          "args": [
            "sc->sc_memt",
            "sc->sc_memh",
            "off",
            "p",
            "n2"
          ],
          "line": 3161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->sc_memt",
            "sc->sc_memh",
            "off",
            "*p"
          ],
          "line": 3156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->sc_memt",
            "sc->sc_memh",
            "off",
            "*p"
          ],
          "line": 3153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->sc_memt",
            "sc->sc_memh",
            "off",
            "*p"
          ],
          "line": 3150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_region_4",
          "args": [
            "sc->sc_memt",
            "sc->sc_memh",
            "off",
            "p",
            "n4"
          ],
          "line": 3141
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_memh\tsc_mem.memh\n#define\tsc_memt\tsc_mem.memt\n\nvoid\nray_write_region(sc, off, vp, c)\n\tstruct ray_softc *sc;\n\tbus_size_t off;\n\tvoid *vp;\n\tsize_t c;\n{\n#ifdef RAY_USE_OPTIMIZED_COPY\n\tsize_t n2, n4, tmp;\n\tu_int8_t *p;\n\n\tp = vp;\n\t/* XXX we may be making poor assumptions here but lets hope */\n\tswitch ((off|(bus_addr_t)p) & 0x03) {\n\tcase 0:\n\t\tif ((n4 = (c >> 2))) {\n\t\t\tbus_space_write_region_4(sc->sc_memt, sc->sc_memh, off,\n\t\t\t    p, n4);\n\t\t\ttmp = c & ~0x3;\n\t\t\tc &= 0x3;\n\t\t\tp += tmp;\n\t\t\toff += tmp;\n\t\t}\n\t\tswitch (c) {\n\t\tcase 3:\n\t\t\tbus_space_write_1(sc->sc_memt,sc->sc_memh, off, *p);\n\t\t\tp++, off++;\n\t\tcase 2:\n\t\t\tbus_space_write_1(sc->sc_memt,sc->sc_memh, off, *p);\n\t\t\tp++, off++;\n\t\tcase 1:\n\t\t\tbus_space_write_1(sc->sc_memt,sc->sc_memh, off, *p);\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tif ((n2 = (c >> 1)))\n\t\t\tbus_space_write_region_2(sc->sc_memt, sc->sc_memh, off,\n\t\t\t    p, n2);\n\t\tif (c & 0x1) {\n\t\t\tc &= ~0x1;\n\t\t\tbus_space_write_1(sc->sc_memt, sc->sc_memh,\n\t\t\t    off + c, *(p + c));\n\t\t}\n\t\tbreak;\n\tcase 1:\n\tcase 3:\n\t\tbus_space_write_region_1(sc->sc_memt, sc->sc_memh, off, p, c);\n\t\tbreak;\n\t}\n#else\n\tbus_space_write_region_1(sc->sc_memt, sc->sc_memh, off, vp, c);\n#endif\n}"
  },
  {
    "function_name": "ray_read_region",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
    "lines": "3063-3116",
    "snippet": "void\nray_read_region(sc, off, vp, c)\n\tstruct ray_softc *sc;\n\tbus_size_t off;\n\tvoid *vp;\n\tsize_t c;\n{\n#ifdef RAY_USE_OPTIMIZED_COPY\n\tu_int n2, n4, tmp;\n\tu_int8_t *p;\n\n\tp = vp;\n\n\t/* XXX we may be making poor assumptions here but lets hope */\n\tswitch ((off|(bus_addr_t)p) & 0x03) {\n\tcase 0:\n\t\tif ((n4 = c / 4)) {\n\t\t\tbus_space_read_region_4(sc->sc_memt, sc->sc_memh, off,\n\t\t\t    p, n4);\n\t\t\ttmp = c & ~0x3;\n\t\t\tc &= 0x3;\n\t\t\tp += tmp;\n\t\t\toff += tmp;\n\t\t}\n\t\tswitch (c) {\n\t\tcase 3:\n\t\t\t*p = bus_space_read_1(sc->sc_memt,sc->sc_memh, off);\n\t\t\tp++, off++;\n\t\tcase 2:\n\t\t\t*p = bus_space_read_1(sc->sc_memt,sc->sc_memh, off);\n\t\t\tp++, off++;\n\t\tcase 1:\n\t\t\t*p = bus_space_read_1(sc->sc_memt,sc->sc_memh, off);\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tif ((n2 = (c >> 1)))\n\t\t\tbus_space_read_region_2(sc->sc_memt, sc->sc_memh, off,\n\t\t\t    p, n2);\n\t\tif (c & 1) {\n\t\t\tc &= ~0x1;\n\t\t\t*(p + c) = bus_space_read_1(sc->sc_memt, sc->sc_memh,\n\t\t\t    off + c);\n\t\t}\n\t\tbreak;\n\tcase 1:\n\tcase 3:\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_memh, off, p, c);\n\t\tbreak;\n\t}\n#else\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_memh, off, vp, c);\n#endif\n}",
    "includes": [
      "#include <dev/pcmcia/if_rayreg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_llc.h>",
      "#include <net/if_media.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/timeout.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [
      "#define\tsc_memh\tsc_mem.memh",
      "#define\tsc_memt\tsc_mem.memt"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_read_region_1",
          "args": [
            "sc->sc_memt",
            "sc->sc_memh",
            "off",
            "vp",
            "c"
          ],
          "line": 3114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_region_1",
          "args": [
            "sc->sc_memt",
            "sc->sc_memh",
            "off",
            "p",
            "c"
          ],
          "line": 3110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "sc->sc_memt",
            "sc->sc_memh",
            "off + c"
          ],
          "line": 3104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_region_2",
          "args": [
            "sc->sc_memt",
            "sc->sc_memh",
            "off",
            "p",
            "n2"
          ],
          "line": 3100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "sc->sc_memt",
            "sc->sc_memh",
            "off"
          ],
          "line": 3095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "sc->sc_memt",
            "sc->sc_memh",
            "off"
          ],
          "line": 3092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "sc->sc_memt",
            "sc->sc_memh",
            "off"
          ],
          "line": 3089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_region_4",
          "args": [
            "sc->sc_memt",
            "sc->sc_memh",
            "off",
            "p",
            "n4"
          ],
          "line": 3080
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_memh\tsc_mem.memh\n#define\tsc_memt\tsc_mem.memt\n\nvoid\nray_read_region(sc, off, vp, c)\n\tstruct ray_softc *sc;\n\tbus_size_t off;\n\tvoid *vp;\n\tsize_t c;\n{\n#ifdef RAY_USE_OPTIMIZED_COPY\n\tu_int n2, n4, tmp;\n\tu_int8_t *p;\n\n\tp = vp;\n\n\t/* XXX we may be making poor assumptions here but lets hope */\n\tswitch ((off|(bus_addr_t)p) & 0x03) {\n\tcase 0:\n\t\tif ((n4 = c / 4)) {\n\t\t\tbus_space_read_region_4(sc->sc_memt, sc->sc_memh, off,\n\t\t\t    p, n4);\n\t\t\ttmp = c & ~0x3;\n\t\t\tc &= 0x3;\n\t\t\tp += tmp;\n\t\t\toff += tmp;\n\t\t}\n\t\tswitch (c) {\n\t\tcase 3:\n\t\t\t*p = bus_space_read_1(sc->sc_memt,sc->sc_memh, off);\n\t\t\tp++, off++;\n\t\tcase 2:\n\t\t\t*p = bus_space_read_1(sc->sc_memt,sc->sc_memh, off);\n\t\t\tp++, off++;\n\t\tcase 1:\n\t\t\t*p = bus_space_read_1(sc->sc_memt,sc->sc_memh, off);\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tif ((n2 = (c >> 1)))\n\t\t\tbus_space_read_region_2(sc->sc_memt, sc->sc_memh, off,\n\t\t\t    p, n2);\n\t\tif (c & 1) {\n\t\t\tc &= ~0x1;\n\t\t\t*(p + c) = bus_space_read_1(sc->sc_memt, sc->sc_memh,\n\t\t\t    off + c);\n\t\t}\n\t\tbreak;\n\tcase 1:\n\tcase 3:\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_memh, off, p, c);\n\t\tbreak;\n\t}\n#else\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_memh, off, vp, c);\n#endif\n}"
  },
  {
    "function_name": "ray_user_report_params",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
    "lines": "3019-3054",
    "snippet": "int\nray_user_report_params(sc, pr)\n\tstruct ray_softc *sc;\n\tstruct ray_param_req *pr;\n{\n\tint rv;\n\n\tif ((sc->sc_if.if_flags & IFF_RUNNING) == 0) {\n\t\tpr->r_failcause = RAY_FAILCAUSE_EDEVSTOP;\n\t\treturn (EIO);\n\t}\n\n\t/* wait to be able to issue the command */\n\trv = 0;\n\twhile (ray_cmd_is_running(sc, SCP_REPORTPARAMS)\n\t    || ray_cmd_is_scheduled(sc, SCP_REPORTPARAMS)) {\n\t\trv = tsleep(ray_report_params, 0|PCATCH, \"cmd in use\", 0);\n\t\tif (rv)\n\t\t\treturn (rv);\n\t\tif ((sc->sc_if.if_flags & IFF_RUNNING) == 0) {\n\t\t\tpr->r_failcause = RAY_FAILCAUSE_EDEVSTOP;\n\t\t\treturn (EIO);\n\t\t}\n\t}\n\n\tpr->r_failcause = RAY_FAILCAUSE_WAITING;\n\tsc->sc_repreq = pr;\n\tray_cmd_schedule(sc, SCP_REPORTPARAMS);\n\tray_check_scheduled(sc);\n\n\twhile (pr->r_failcause == RAY_FAILCAUSE_WAITING)\n\t\t(void)tsleep(ray_report_params, 0, \"waiting cmd\", 0);\n\twakeup(ray_report_params);\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/pcmcia/if_rayreg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_llc.h>",
      "#include <net/if_media.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/timeout.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [
      "#define\tSCP_REPORTPARAMS\t0x0004",
      "#define\tsc_if\t\tsc_ec.ac_if",
      "#define\tsc_if\t\tsc_ec.ec_if"
    ],
    "globals_used": [
      "void ray_check_scheduled",
      "void ray_cmd_schedule",
      "int ray_cmd_is_running",
      "int ray_cmd_is_scheduled",
      "void ray_report_params",
      "int ray_user_report_params"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "ray_report_params"
          ],
          "line": 3051
        },
        "resolved": true,
        "details": {
          "function_name": "audio_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "765-774",
          "snippet": "static __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nstatic __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tsleep",
          "args": [
            "ray_report_params",
            "0",
            "\"waiting cmd\"",
            "0"
          ],
          "line": 3050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ray_check_scheduled",
          "args": [
            "sc"
          ],
          "line": 3047
        },
        "resolved": true,
        "details": {
          "function_name": "ray_check_scheduled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "1783-1824",
          "snippet": "void\nray_check_scheduled(arg)\n\tvoid *arg;\n{\n\tstruct ray_softc *sc;\n\tint s, i, mask;\n\n\ts = splnet();\n\n\tsc = arg;\n\tRAY_DPRINTF((\n\t    \"%s: ray_check_scheduled enter schd 0x%x running 0x%x ready %d\\n\",\n\t    sc->sc_xname, sc->sc_scheduled, sc->sc_running, RAY_ECF_READY(sc)));\n\n\tif (sc->sc_timoneed) {\n\t\tcallout_stop(&sc->sc_check_scheduled_ch);\n\t\tsc->sc_timoneed = 0;\n\t}\n\n\t/* if update subcmd is running -- clear it in scheduled */\n\tif (sc->sc_running & SCP_UPDATESUBCMD)\n\t\tsc->sc_scheduled &= ~SCP_UPDATESUBCMD;\n\n\tmask = SCP_FIRST;\n\tfor (i = 0; i < ray_ncmdtab; mask <<= 1, i++) {\n\t\tif ((sc->sc_scheduled & ~SCP_UPD_MASK) == 0)\n\t\t\tbreak;\n\t\tif (!RAY_ECF_READY(sc))\n\t\t\tbreak;\n\t\tif (sc->sc_scheduled & mask)\n\t\t\t(*ray_cmdtab[i])(sc);\n\t}\n\n\tRAY_DPRINTF((\n\t    \"%s: ray_check_scheduled exit sched 0x%x running 0x%x ready %d\\n\",\n\t    sc->sc_xname, sc->sc_scheduled, sc->sc_running, RAY_ECF_READY(sc)));\n\n\tif (sc->sc_scheduled & ~SCP_UPD_MASK)\n\t\tray_set_pending(sc, sc->sc_scheduled);\n\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tSCP_UPD_MASK\t\t0xff00",
            "#define\tSCP_UPDATESUBCMD\t0x0001",
            "#define\tSCP_FIRST\t\t0x0001",
            "#define\tsc_xname\tsc_dev.dv_xname",
            "#define\tcallout_stop\ttimeout_del"
          ],
          "globals_used": [
            "void ray_check_scheduled",
            "void ray_set_pending",
            "static const ray_cmd_func_t ray_cmdtab[] = {\n\tray_update_subcmd,\t/* SCP_UPDATESUBCMD */\n\tray_start_assoc,\t/* SCP_STARTASSOC */\n\tray_report_params,\t/* SCP_REPORTPARAMS */\n\tray_intr_start\t\t/* SCP_IFSTART */\n};",
            "static const int ray_ncmdtab = sizeof(ray_cmdtab) / sizeof(*ray_cmdtab);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSCP_UPD_MASK\t\t0xff00\n#define\tSCP_UPDATESUBCMD\t0x0001\n#define\tSCP_FIRST\t\t0x0001\n#define\tsc_xname\tsc_dev.dv_xname\n#define\tcallout_stop\ttimeout_del\n\nvoid ray_check_scheduled;\nvoid ray_set_pending;\nstatic const ray_cmd_func_t ray_cmdtab[] = {\n\tray_update_subcmd,\t/* SCP_UPDATESUBCMD */\n\tray_start_assoc,\t/* SCP_STARTASSOC */\n\tray_report_params,\t/* SCP_REPORTPARAMS */\n\tray_intr_start\t\t/* SCP_IFSTART */\n};\nstatic const int ray_ncmdtab = sizeof(ray_cmdtab) / sizeof(*ray_cmdtab);\n\nvoid\nray_check_scheduled(arg)\n\tvoid *arg;\n{\n\tstruct ray_softc *sc;\n\tint s, i, mask;\n\n\ts = splnet();\n\n\tsc = arg;\n\tRAY_DPRINTF((\n\t    \"%s: ray_check_scheduled enter schd 0x%x running 0x%x ready %d\\n\",\n\t    sc->sc_xname, sc->sc_scheduled, sc->sc_running, RAY_ECF_READY(sc)));\n\n\tif (sc->sc_timoneed) {\n\t\tcallout_stop(&sc->sc_check_scheduled_ch);\n\t\tsc->sc_timoneed = 0;\n\t}\n\n\t/* if update subcmd is running -- clear it in scheduled */\n\tif (sc->sc_running & SCP_UPDATESUBCMD)\n\t\tsc->sc_scheduled &= ~SCP_UPDATESUBCMD;\n\n\tmask = SCP_FIRST;\n\tfor (i = 0; i < ray_ncmdtab; mask <<= 1, i++) {\n\t\tif ((sc->sc_scheduled & ~SCP_UPD_MASK) == 0)\n\t\t\tbreak;\n\t\tif (!RAY_ECF_READY(sc))\n\t\t\tbreak;\n\t\tif (sc->sc_scheduled & mask)\n\t\t\t(*ray_cmdtab[i])(sc);\n\t}\n\n\tRAY_DPRINTF((\n\t    \"%s: ray_check_scheduled exit sched 0x%x running 0x%x ready %d\\n\",\n\t    sc->sc_xname, sc->sc_scheduled, sc->sc_running, RAY_ECF_READY(sc)));\n\n\tif (sc->sc_scheduled & ~SCP_UPD_MASK)\n\t\tray_set_pending(sc, sc->sc_scheduled);\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ray_cmd_schedule",
          "args": [
            "sc",
            "SCP_REPORTPARAMS"
          ],
          "line": 3046
        },
        "resolved": true,
        "details": {
          "function_name": "ray_cmd_schedule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2248-2265",
          "snippet": "void\nray_cmd_schedule(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tint track;\n\n\tRAY_DPRINTF((\"%s: ray_cmd_schedule 0x%x\\n\", sc->sc_xname, cmdf));\n\n\ttrack = cmdf;\n\tif ((cmdf & SCP_UPD_MASK) == 0)\n\t\tray_set_pending(sc, track);\n\telse if (ray_cmd_is_running(sc, SCP_UPDATESUBCMD)) {\n\t\t/* don't do timeout mechaniscm if subcmd already going */\n\t\tsc->sc_scheduled |= cmdf;\n\t} else\n\t\tray_set_pending(sc, cmdf | SCP_UPDATESUBCMD);\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tSCP_UPD_MASK\t\t0xff00",
            "#define\tSCP_UPDATESUBCMD\t0x0001",
            "#define\tsc_xname\tsc_dev.dv_xname"
          ],
          "globals_used": [
            "void ray_cmd_schedule",
            "int ray_cmd_is_running",
            "void ray_set_pending"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSCP_UPD_MASK\t\t0xff00\n#define\tSCP_UPDATESUBCMD\t0x0001\n#define\tsc_xname\tsc_dev.dv_xname\n\nvoid ray_cmd_schedule;\nint ray_cmd_is_running;\nvoid ray_set_pending;\n\nvoid\nray_cmd_schedule(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tint track;\n\n\tRAY_DPRINTF((\"%s: ray_cmd_schedule 0x%x\\n\", sc->sc_xname, cmdf));\n\n\ttrack = cmdf;\n\tif ((cmdf & SCP_UPD_MASK) == 0)\n\t\tray_set_pending(sc, track);\n\telse if (ray_cmd_is_running(sc, SCP_UPDATESUBCMD)) {\n\t\t/* don't do timeout mechaniscm if subcmd already going */\n\t\tsc->sc_scheduled |= cmdf;\n\t} else\n\t\tray_set_pending(sc, cmdf | SCP_UPDATESUBCMD);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tsleep",
          "args": [
            "ray_report_params",
            "0|PCATCH",
            "\"cmd in use\"",
            "0"
          ],
          "line": 3035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ray_cmd_is_scheduled",
          "args": [
            "sc",
            "SCP_REPORTPARAMS"
          ],
          "line": 3034
        },
        "resolved": true,
        "details": {
          "function_name": "ray_cmd_is_scheduled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2270-2278",
          "snippet": "int\nray_cmd_is_scheduled(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_cmd_is_scheduled 0x%x\\n\", sc->sc_xname, cmdf));\n\n\treturn ((sc->sc_scheduled & cmdf) ? 1 : 0);\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tsc_xname\tsc_dev.dv_xname"
          ],
          "globals_used": [
            "int ray_cmd_is_scheduled"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_xname\tsc_dev.dv_xname\n\nint ray_cmd_is_scheduled;\n\nint\nray_cmd_is_scheduled(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_cmd_is_scheduled 0x%x\\n\", sc->sc_xname, cmdf));\n\n\treturn ((sc->sc_scheduled & cmdf) ? 1 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ray_cmd_is_running",
          "args": [
            "sc",
            "SCP_REPORTPARAMS"
          ],
          "line": 3033
        },
        "resolved": true,
        "details": {
          "function_name": "ray_cmd_is_running",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2326-2334",
          "snippet": "int\nray_cmd_is_running(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_cmd_is_running 0x%x\\n\", sc->sc_xname, cmdf));\n\n\treturn ((sc->sc_running & cmdf) ? 1 : 0);\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tsc_xname\tsc_dev.dv_xname"
          ],
          "globals_used": [
            "int ray_cmd_is_running"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_xname\tsc_dev.dv_xname\n\nint ray_cmd_is_running;\n\nint\nray_cmd_is_running(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_cmd_is_running 0x%x\\n\", sc->sc_xname, cmdf));\n\n\treturn ((sc->sc_running & cmdf) ? 1 : 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSCP_REPORTPARAMS\t0x0004\n#define\tsc_if\t\tsc_ec.ac_if\n#define\tsc_if\t\tsc_ec.ec_if\n\nvoid ray_check_scheduled;\nvoid ray_cmd_schedule;\nint ray_cmd_is_running;\nint ray_cmd_is_scheduled;\nvoid ray_report_params;\nint ray_user_report_params;\n\nint\nray_user_report_params(sc, pr)\n\tstruct ray_softc *sc;\n\tstruct ray_param_req *pr;\n{\n\tint rv;\n\n\tif ((sc->sc_if.if_flags & IFF_RUNNING) == 0) {\n\t\tpr->r_failcause = RAY_FAILCAUSE_EDEVSTOP;\n\t\treturn (EIO);\n\t}\n\n\t/* wait to be able to issue the command */\n\trv = 0;\n\twhile (ray_cmd_is_running(sc, SCP_REPORTPARAMS)\n\t    || ray_cmd_is_scheduled(sc, SCP_REPORTPARAMS)) {\n\t\trv = tsleep(ray_report_params, 0|PCATCH, \"cmd in use\", 0);\n\t\tif (rv)\n\t\t\treturn (rv);\n\t\tif ((sc->sc_if.if_flags & IFF_RUNNING) == 0) {\n\t\t\tpr->r_failcause = RAY_FAILCAUSE_EDEVSTOP;\n\t\t\treturn (EIO);\n\t\t}\n\t}\n\n\tpr->r_failcause = RAY_FAILCAUSE_WAITING;\n\tsc->sc_repreq = pr;\n\tray_cmd_schedule(sc, SCP_REPORTPARAMS);\n\tray_check_scheduled(sc);\n\n\twhile (pr->r_failcause == RAY_FAILCAUSE_WAITING)\n\t\t(void)tsleep(ray_report_params, 0, \"waiting cmd\", 0);\n\twakeup(ray_report_params);\n\n\treturn (0);\n}"
  },
  {
    "function_name": "ray_user_update_params",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
    "lines": "2977-3012",
    "snippet": "int\nray_user_update_params(sc, pr)\n\tstruct ray_softc *sc;\n\tstruct ray_param_req *pr;\n{\n\tint rv;\n\n\tif ((sc->sc_if.if_flags & IFF_RUNNING) == 0) {\n\t\tpr->r_failcause = RAY_FAILCAUSE_EDEVSTOP;\n\t\treturn (EIO);\n\t}\n\n\t/* wait to be able to issue the command */\n\trv = 0;\n\twhile (ray_cmd_is_running(sc, SCP_UPD_UPDATEPARAMS) ||\n\t    ray_cmd_is_scheduled(sc, SCP_UPD_UPDATEPARAMS)) {\n\t\trv = tsleep(ray_update_params, 0|PCATCH, \"cmd in use\", 0);\n\t\tif (rv)\n\t\t\treturn (rv);\n\t\tif ((sc->sc_if.if_flags & IFF_RUNNING) == 0) {\n\t\t\tpr->r_failcause = RAY_FAILCAUSE_EDEVSTOP;\n\t\t\treturn (EIO);\n\t\t}\n\t}\n\n\tpr->r_failcause = RAY_FAILCAUSE_WAITING;\n\tsc->sc_updreq = pr;\n\tray_cmd_schedule(sc, SCP_UPD_UPDATEPARAMS);\n\tray_check_scheduled(sc);\n\n\twhile (pr->r_failcause == RAY_FAILCAUSE_WAITING)\n\t\t(void)tsleep(ray_update_params, 0, \"waiting cmd\", 0);\n\twakeup(ray_update_params);\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/pcmcia/if_rayreg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_llc.h>",
      "#include <net/if_media.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/timeout.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [
      "#define\tSCP_UPD_UPDATEPARAMS\t0x1000",
      "#define\tsc_if\t\tsc_ec.ac_if",
      "#define\tsc_if\t\tsc_ec.ec_if"
    ],
    "globals_used": [
      "void ray_check_scheduled",
      "void ray_cmd_schedule",
      "int ray_cmd_is_running",
      "int ray_cmd_is_scheduled",
      "void ray_update_params",
      "int ray_user_update_params"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "ray_update_params"
          ],
          "line": 3009
        },
        "resolved": true,
        "details": {
          "function_name": "audio_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "765-774",
          "snippet": "static __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nstatic __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tsleep",
          "args": [
            "ray_update_params",
            "0",
            "\"waiting cmd\"",
            "0"
          ],
          "line": 3008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ray_check_scheduled",
          "args": [
            "sc"
          ],
          "line": 3005
        },
        "resolved": true,
        "details": {
          "function_name": "ray_check_scheduled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "1783-1824",
          "snippet": "void\nray_check_scheduled(arg)\n\tvoid *arg;\n{\n\tstruct ray_softc *sc;\n\tint s, i, mask;\n\n\ts = splnet();\n\n\tsc = arg;\n\tRAY_DPRINTF((\n\t    \"%s: ray_check_scheduled enter schd 0x%x running 0x%x ready %d\\n\",\n\t    sc->sc_xname, sc->sc_scheduled, sc->sc_running, RAY_ECF_READY(sc)));\n\n\tif (sc->sc_timoneed) {\n\t\tcallout_stop(&sc->sc_check_scheduled_ch);\n\t\tsc->sc_timoneed = 0;\n\t}\n\n\t/* if update subcmd is running -- clear it in scheduled */\n\tif (sc->sc_running & SCP_UPDATESUBCMD)\n\t\tsc->sc_scheduled &= ~SCP_UPDATESUBCMD;\n\n\tmask = SCP_FIRST;\n\tfor (i = 0; i < ray_ncmdtab; mask <<= 1, i++) {\n\t\tif ((sc->sc_scheduled & ~SCP_UPD_MASK) == 0)\n\t\t\tbreak;\n\t\tif (!RAY_ECF_READY(sc))\n\t\t\tbreak;\n\t\tif (sc->sc_scheduled & mask)\n\t\t\t(*ray_cmdtab[i])(sc);\n\t}\n\n\tRAY_DPRINTF((\n\t    \"%s: ray_check_scheduled exit sched 0x%x running 0x%x ready %d\\n\",\n\t    sc->sc_xname, sc->sc_scheduled, sc->sc_running, RAY_ECF_READY(sc)));\n\n\tif (sc->sc_scheduled & ~SCP_UPD_MASK)\n\t\tray_set_pending(sc, sc->sc_scheduled);\n\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tSCP_UPD_MASK\t\t0xff00",
            "#define\tSCP_UPDATESUBCMD\t0x0001",
            "#define\tSCP_FIRST\t\t0x0001",
            "#define\tsc_xname\tsc_dev.dv_xname",
            "#define\tcallout_stop\ttimeout_del"
          ],
          "globals_used": [
            "void ray_check_scheduled",
            "void ray_set_pending",
            "static const ray_cmd_func_t ray_cmdtab[] = {\n\tray_update_subcmd,\t/* SCP_UPDATESUBCMD */\n\tray_start_assoc,\t/* SCP_STARTASSOC */\n\tray_report_params,\t/* SCP_REPORTPARAMS */\n\tray_intr_start\t\t/* SCP_IFSTART */\n};",
            "static const int ray_ncmdtab = sizeof(ray_cmdtab) / sizeof(*ray_cmdtab);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSCP_UPD_MASK\t\t0xff00\n#define\tSCP_UPDATESUBCMD\t0x0001\n#define\tSCP_FIRST\t\t0x0001\n#define\tsc_xname\tsc_dev.dv_xname\n#define\tcallout_stop\ttimeout_del\n\nvoid ray_check_scheduled;\nvoid ray_set_pending;\nstatic const ray_cmd_func_t ray_cmdtab[] = {\n\tray_update_subcmd,\t/* SCP_UPDATESUBCMD */\n\tray_start_assoc,\t/* SCP_STARTASSOC */\n\tray_report_params,\t/* SCP_REPORTPARAMS */\n\tray_intr_start\t\t/* SCP_IFSTART */\n};\nstatic const int ray_ncmdtab = sizeof(ray_cmdtab) / sizeof(*ray_cmdtab);\n\nvoid\nray_check_scheduled(arg)\n\tvoid *arg;\n{\n\tstruct ray_softc *sc;\n\tint s, i, mask;\n\n\ts = splnet();\n\n\tsc = arg;\n\tRAY_DPRINTF((\n\t    \"%s: ray_check_scheduled enter schd 0x%x running 0x%x ready %d\\n\",\n\t    sc->sc_xname, sc->sc_scheduled, sc->sc_running, RAY_ECF_READY(sc)));\n\n\tif (sc->sc_timoneed) {\n\t\tcallout_stop(&sc->sc_check_scheduled_ch);\n\t\tsc->sc_timoneed = 0;\n\t}\n\n\t/* if update subcmd is running -- clear it in scheduled */\n\tif (sc->sc_running & SCP_UPDATESUBCMD)\n\t\tsc->sc_scheduled &= ~SCP_UPDATESUBCMD;\n\n\tmask = SCP_FIRST;\n\tfor (i = 0; i < ray_ncmdtab; mask <<= 1, i++) {\n\t\tif ((sc->sc_scheduled & ~SCP_UPD_MASK) == 0)\n\t\t\tbreak;\n\t\tif (!RAY_ECF_READY(sc))\n\t\t\tbreak;\n\t\tif (sc->sc_scheduled & mask)\n\t\t\t(*ray_cmdtab[i])(sc);\n\t}\n\n\tRAY_DPRINTF((\n\t    \"%s: ray_check_scheduled exit sched 0x%x running 0x%x ready %d\\n\",\n\t    sc->sc_xname, sc->sc_scheduled, sc->sc_running, RAY_ECF_READY(sc)));\n\n\tif (sc->sc_scheduled & ~SCP_UPD_MASK)\n\t\tray_set_pending(sc, sc->sc_scheduled);\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ray_cmd_schedule",
          "args": [
            "sc",
            "SCP_UPD_UPDATEPARAMS"
          ],
          "line": 3004
        },
        "resolved": true,
        "details": {
          "function_name": "ray_cmd_schedule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2248-2265",
          "snippet": "void\nray_cmd_schedule(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tint track;\n\n\tRAY_DPRINTF((\"%s: ray_cmd_schedule 0x%x\\n\", sc->sc_xname, cmdf));\n\n\ttrack = cmdf;\n\tif ((cmdf & SCP_UPD_MASK) == 0)\n\t\tray_set_pending(sc, track);\n\telse if (ray_cmd_is_running(sc, SCP_UPDATESUBCMD)) {\n\t\t/* don't do timeout mechaniscm if subcmd already going */\n\t\tsc->sc_scheduled |= cmdf;\n\t} else\n\t\tray_set_pending(sc, cmdf | SCP_UPDATESUBCMD);\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tSCP_UPD_MASK\t\t0xff00",
            "#define\tSCP_UPDATESUBCMD\t0x0001",
            "#define\tsc_xname\tsc_dev.dv_xname"
          ],
          "globals_used": [
            "void ray_cmd_schedule",
            "int ray_cmd_is_running",
            "void ray_set_pending"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSCP_UPD_MASK\t\t0xff00\n#define\tSCP_UPDATESUBCMD\t0x0001\n#define\tsc_xname\tsc_dev.dv_xname\n\nvoid ray_cmd_schedule;\nint ray_cmd_is_running;\nvoid ray_set_pending;\n\nvoid\nray_cmd_schedule(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tint track;\n\n\tRAY_DPRINTF((\"%s: ray_cmd_schedule 0x%x\\n\", sc->sc_xname, cmdf));\n\n\ttrack = cmdf;\n\tif ((cmdf & SCP_UPD_MASK) == 0)\n\t\tray_set_pending(sc, track);\n\telse if (ray_cmd_is_running(sc, SCP_UPDATESUBCMD)) {\n\t\t/* don't do timeout mechaniscm if subcmd already going */\n\t\tsc->sc_scheduled |= cmdf;\n\t} else\n\t\tray_set_pending(sc, cmdf | SCP_UPDATESUBCMD);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tsleep",
          "args": [
            "ray_update_params",
            "0|PCATCH",
            "\"cmd in use\"",
            "0"
          ],
          "line": 2993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ray_cmd_is_scheduled",
          "args": [
            "sc",
            "SCP_UPD_UPDATEPARAMS"
          ],
          "line": 2992
        },
        "resolved": true,
        "details": {
          "function_name": "ray_cmd_is_scheduled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2270-2278",
          "snippet": "int\nray_cmd_is_scheduled(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_cmd_is_scheduled 0x%x\\n\", sc->sc_xname, cmdf));\n\n\treturn ((sc->sc_scheduled & cmdf) ? 1 : 0);\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tsc_xname\tsc_dev.dv_xname"
          ],
          "globals_used": [
            "int ray_cmd_is_scheduled"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_xname\tsc_dev.dv_xname\n\nint ray_cmd_is_scheduled;\n\nint\nray_cmd_is_scheduled(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_cmd_is_scheduled 0x%x\\n\", sc->sc_xname, cmdf));\n\n\treturn ((sc->sc_scheduled & cmdf) ? 1 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ray_cmd_is_running",
          "args": [
            "sc",
            "SCP_UPD_UPDATEPARAMS"
          ],
          "line": 2991
        },
        "resolved": true,
        "details": {
          "function_name": "ray_cmd_is_running",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2326-2334",
          "snippet": "int\nray_cmd_is_running(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_cmd_is_running 0x%x\\n\", sc->sc_xname, cmdf));\n\n\treturn ((sc->sc_running & cmdf) ? 1 : 0);\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tsc_xname\tsc_dev.dv_xname"
          ],
          "globals_used": [
            "int ray_cmd_is_running"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_xname\tsc_dev.dv_xname\n\nint ray_cmd_is_running;\n\nint\nray_cmd_is_running(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_cmd_is_running 0x%x\\n\", sc->sc_xname, cmdf));\n\n\treturn ((sc->sc_running & cmdf) ? 1 : 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSCP_UPD_UPDATEPARAMS\t0x1000\n#define\tsc_if\t\tsc_ec.ac_if\n#define\tsc_if\t\tsc_ec.ec_if\n\nvoid ray_check_scheduled;\nvoid ray_cmd_schedule;\nint ray_cmd_is_running;\nint ray_cmd_is_scheduled;\nvoid ray_update_params;\nint ray_user_update_params;\n\nint\nray_user_update_params(sc, pr)\n\tstruct ray_softc *sc;\n\tstruct ray_param_req *pr;\n{\n\tint rv;\n\n\tif ((sc->sc_if.if_flags & IFF_RUNNING) == 0) {\n\t\tpr->r_failcause = RAY_FAILCAUSE_EDEVSTOP;\n\t\treturn (EIO);\n\t}\n\n\t/* wait to be able to issue the command */\n\trv = 0;\n\twhile (ray_cmd_is_running(sc, SCP_UPD_UPDATEPARAMS) ||\n\t    ray_cmd_is_scheduled(sc, SCP_UPD_UPDATEPARAMS)) {\n\t\trv = tsleep(ray_update_params, 0|PCATCH, \"cmd in use\", 0);\n\t\tif (rv)\n\t\t\treturn (rv);\n\t\tif ((sc->sc_if.if_flags & IFF_RUNNING) == 0) {\n\t\t\tpr->r_failcause = RAY_FAILCAUSE_EDEVSTOP;\n\t\t\treturn (EIO);\n\t\t}\n\t}\n\n\tpr->r_failcause = RAY_FAILCAUSE_WAITING;\n\tsc->sc_updreq = pr;\n\tray_cmd_schedule(sc, SCP_UPD_UPDATEPARAMS);\n\tray_check_scheduled(sc);\n\n\twhile (pr->r_failcause == RAY_FAILCAUSE_WAITING)\n\t\t(void)tsleep(ray_update_params, 0, \"waiting cmd\", 0);\n\twakeup(ray_update_params);\n\n\treturn (0);\n}"
  },
  {
    "function_name": "ray_update_mcast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
    "lines": "2908-2966",
    "snippet": "void\nray_update_mcast(sc)\n\tstruct ray_softc *sc;\n{\n\tbus_size_t ccs;\n\tstruct ether_multistep step;\n\tstruct ether_multi *enm;\n#ifdef __NetBSD__\n\tstruct ethercom *ec;\n#elif defined(__OpenBSD__)\n\tstruct arpcom *ec;\n#endif\n\tbus_size_t bufp;\n\tint count;\n\n\tec = &sc->sc_ec;\n\tray_cmd_cancel(sc, SCP_UPD_MCAST);\n\n\t/* see if we have any ranges */\n\tif ((count = sc->sc_ec.ec_multicnt) < 17) {\n\t\tETHER_FIRST_MULTI(step, ec, enm);\n\t\twhile (enm) {\n\t\t\t/* see if this is a range */\n\t\t\tif (memcmp(enm->enm_addrlo, enm->enm_addrhi,\n\t\t\t\tETHER_ADDR_LEN)) {\n\t\t\t\tcount = 17;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tETHER_NEXT_MULTI(step, enm);\n\t\t}\n\t}\n\n\t/* track this stuff even when not running */\n\tif (count > 16) {\n\t\tsc->sc_if.if_flags |= IFF_ALLMULTI;\n\t\tray_update_promisc(sc);\n\t\treturn;\n\t} else if (sc->sc_if.if_flags & IFF_ALLMULTI) {\n\t\tsc->sc_if.if_flags &= ~IFF_ALLMULTI;\n\t\tray_update_promisc(sc);\n\t}\n\n\tif ((sc->sc_if.if_flags & IFF_RUNNING) == 0)\n\t\treturn;\n\telse if (ray_cmd_is_running(sc, SCP_UPDATESUBCMD)) {\n\t\tray_cmd_schedule(sc, SCP_UPD_MCAST);\n\t\treturn;\n\t} else if (!ray_alloc_ccs(sc,&ccs, RAY_CMD_UPDATE_MCAST, SCP_UPD_MCAST))\n\t\treturn;\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_update_mcast, c_nmcast, count);\n\tbufp = RAY_HOST_TO_ECF_BASE;\n\tETHER_FIRST_MULTI(step, ec, enm);\n\twhile (enm) {\n\t\tray_write_region(sc, bufp, enm->enm_addrlo, ETHER_ADDR_LEN);\n\t\tbufp += ETHER_ADDR_LEN;\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\t(void)ray_issue_cmd(sc, ccs, SCP_UPD_MCAST);\n}",
    "includes": [
      "#include <dev/pcmcia/if_rayreg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_llc.h>",
      "#include <net/if_media.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/timeout.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [
      "#define\tSCP_UPD_MCAST\t\t0x0800",
      "#define\tSCP_UPDATESUBCMD\t0x0001",
      "#define\tec_multicnt\tac_multicnt",
      "#define\tsc_if\t\tsc_ec.ac_if",
      "#define\tsc_if\t\tsc_ec.ec_if"
    ],
    "globals_used": [
      "int ray_alloc_ccs",
      "void ray_cmd_cancel",
      "void ray_cmd_schedule",
      "int ray_cmd_is_running",
      "int ray_issue_cmd",
      "void ray_update_mcast",
      "void ray_update_promisc"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ray_issue_cmd",
          "args": [
            "sc",
            "ccs",
            "SCP_UPD_MCAST"
          ],
          "line": 2965
        },
        "resolved": true,
        "details": {
          "function_name": "ray_issue_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2362-2391",
          "snippet": "int\nray_issue_cmd(sc, ccs, track)\n\tstruct ray_softc *sc;\n\tbus_size_t ccs;\n\tu_int track;\n{\n\tu_int i;\n\n\tRAY_DPRINTF((\"%s: ray_cmd_issue 0x%x\\n\", sc->sc_xname, track));\n\n\t/*\n\t * XXX other drivers did this, but I think\n\t * what we really want to do is just make sure we don't\n\t * get here or that spinning is ok\n\t */\n\ti = 0;\n\twhile (!RAY_ECF_READY(sc))\n\t\tif (++i > 50) {\n\t\t\tray_free_ccs(sc, ccs);\n\t\t\tif (track)\n\t\t\t\tray_cmd_schedule(sc, track);\n\t\t\treturn (0);\n\t\t}\n\n\tSRAM_WRITE_1(sc, RAY_SCB_CCSI, RAY_GET_INDEX(ccs));\n\tRAY_ECF_START_CMD(sc);\n\tray_cmd_ran(sc, track);\n\n\treturn (1);\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tsc_xname\tsc_dev.dv_xname"
          ],
          "globals_used": [
            "void ray_cmd_schedule",
            "void ray_cmd_ran",
            "u_int8_t ray_free_ccs",
            "int ray_issue_cmd"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_xname\tsc_dev.dv_xname\n\nvoid ray_cmd_schedule;\nvoid ray_cmd_ran;\nu_int8_t ray_free_ccs;\nint ray_issue_cmd;\n\nint\nray_issue_cmd(sc, ccs, track)\n\tstruct ray_softc *sc;\n\tbus_size_t ccs;\n\tu_int track;\n{\n\tu_int i;\n\n\tRAY_DPRINTF((\"%s: ray_cmd_issue 0x%x\\n\", sc->sc_xname, track));\n\n\t/*\n\t * XXX other drivers did this, but I think\n\t * what we really want to do is just make sure we don't\n\t * get here or that spinning is ok\n\t */\n\ti = 0;\n\twhile (!RAY_ECF_READY(sc))\n\t\tif (++i > 50) {\n\t\t\tray_free_ccs(sc, ccs);\n\t\t\tif (track)\n\t\t\t\tray_cmd_schedule(sc, track);\n\t\t\treturn (0);\n\t\t}\n\n\tSRAM_WRITE_1(sc, RAY_SCB_CCSI, RAY_GET_INDEX(ccs));\n\tRAY_ECF_START_CMD(sc);\n\tray_cmd_ran(sc, track);\n\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ETHER_NEXT_MULTI",
          "args": [
            "step",
            "enm"
          ],
          "line": 2963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ray_write_region",
          "args": [
            "sc",
            "bufp",
            "enm->enm_addrlo",
            "ETHER_ADDR_LEN"
          ],
          "line": 2961
        },
        "resolved": true,
        "details": {
          "function_name": "ray_write_region",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "3125-3177",
          "snippet": "void\nray_write_region(sc, off, vp, c)\n\tstruct ray_softc *sc;\n\tbus_size_t off;\n\tvoid *vp;\n\tsize_t c;\n{\n#ifdef RAY_USE_OPTIMIZED_COPY\n\tsize_t n2, n4, tmp;\n\tu_int8_t *p;\n\n\tp = vp;\n\t/* XXX we may be making poor assumptions here but lets hope */\n\tswitch ((off|(bus_addr_t)p) & 0x03) {\n\tcase 0:\n\t\tif ((n4 = (c >> 2))) {\n\t\t\tbus_space_write_region_4(sc->sc_memt, sc->sc_memh, off,\n\t\t\t    p, n4);\n\t\t\ttmp = c & ~0x3;\n\t\t\tc &= 0x3;\n\t\t\tp += tmp;\n\t\t\toff += tmp;\n\t\t}\n\t\tswitch (c) {\n\t\tcase 3:\n\t\t\tbus_space_write_1(sc->sc_memt,sc->sc_memh, off, *p);\n\t\t\tp++, off++;\n\t\tcase 2:\n\t\t\tbus_space_write_1(sc->sc_memt,sc->sc_memh, off, *p);\n\t\t\tp++, off++;\n\t\tcase 1:\n\t\t\tbus_space_write_1(sc->sc_memt,sc->sc_memh, off, *p);\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tif ((n2 = (c >> 1)))\n\t\t\tbus_space_write_region_2(sc->sc_memt, sc->sc_memh, off,\n\t\t\t    p, n2);\n\t\tif (c & 0x1) {\n\t\t\tc &= ~0x1;\n\t\t\tbus_space_write_1(sc->sc_memt, sc->sc_memh,\n\t\t\t    off + c, *(p + c));\n\t\t}\n\t\tbreak;\n\tcase 1:\n\tcase 3:\n\t\tbus_space_write_region_1(sc->sc_memt, sc->sc_memh, off, p, c);\n\t\tbreak;\n\t}\n#else\n\tbus_space_write_region_1(sc->sc_memt, sc->sc_memh, off, vp, c);\n#endif\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tsc_memh\tsc_mem.memh",
            "#define\tsc_memt\tsc_mem.memt"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_memh\tsc_mem.memh\n#define\tsc_memt\tsc_mem.memt\n\nvoid\nray_write_region(sc, off, vp, c)\n\tstruct ray_softc *sc;\n\tbus_size_t off;\n\tvoid *vp;\n\tsize_t c;\n{\n#ifdef RAY_USE_OPTIMIZED_COPY\n\tsize_t n2, n4, tmp;\n\tu_int8_t *p;\n\n\tp = vp;\n\t/* XXX we may be making poor assumptions here but lets hope */\n\tswitch ((off|(bus_addr_t)p) & 0x03) {\n\tcase 0:\n\t\tif ((n4 = (c >> 2))) {\n\t\t\tbus_space_write_region_4(sc->sc_memt, sc->sc_memh, off,\n\t\t\t    p, n4);\n\t\t\ttmp = c & ~0x3;\n\t\t\tc &= 0x3;\n\t\t\tp += tmp;\n\t\t\toff += tmp;\n\t\t}\n\t\tswitch (c) {\n\t\tcase 3:\n\t\t\tbus_space_write_1(sc->sc_memt,sc->sc_memh, off, *p);\n\t\t\tp++, off++;\n\t\tcase 2:\n\t\t\tbus_space_write_1(sc->sc_memt,sc->sc_memh, off, *p);\n\t\t\tp++, off++;\n\t\tcase 1:\n\t\t\tbus_space_write_1(sc->sc_memt,sc->sc_memh, off, *p);\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tif ((n2 = (c >> 1)))\n\t\t\tbus_space_write_region_2(sc->sc_memt, sc->sc_memh, off,\n\t\t\t    p, n2);\n\t\tif (c & 0x1) {\n\t\t\tc &= ~0x1;\n\t\t\tbus_space_write_1(sc->sc_memt, sc->sc_memh,\n\t\t\t    off + c, *(p + c));\n\t\t}\n\t\tbreak;\n\tcase 1:\n\tcase 3:\n\t\tbus_space_write_region_1(sc->sc_memt, sc->sc_memh, off, p, c);\n\t\tbreak;\n\t}\n#else\n\tbus_space_write_region_1(sc->sc_memt, sc->sc_memh, off, vp, c);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "ETHER_FIRST_MULTI",
          "args": [
            "step",
            "ec",
            "enm"
          ],
          "line": 2959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRAM_WRITE_FIELD_1",
          "args": [
            "sc",
            "ccs",
            "ray_cmd_update_mcast",
            "c_nmcast",
            "count"
          ],
          "line": 2957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ray_alloc_ccs",
          "args": [
            "sc",
            "&ccs",
            "RAY_CMD_UPDATE_MCAST",
            "SCP_UPD_MCAST"
          ],
          "line": 2955
        },
        "resolved": true,
        "details": {
          "function_name": "ray_alloc_ccs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2184-2221",
          "snippet": "int\nray_alloc_ccs(sc, ccsp, cmd, track)\n\tstruct ray_softc *sc;\n\tbus_size_t *ccsp;\n\tu_int cmd, track;\n{\n\tbus_size_t ccs;\n\tu_int i;\n\n\tRAY_DPRINTF((\"%s: alloc_ccs cmd %d\\n\", sc->sc_xname, cmd));\n\n\t/* for tracked commands, if not ready just set pending */\n\tif (track && !RAY_ECF_READY(sc)) {\n\t\tray_cmd_schedule(sc, track);\n\t\treturn (0);\n\t}\n\n\t/* first scan our inuse array */\n\tfor (i = RAY_CCS_CMD_FIRST; i <= RAY_CCS_CMD_LAST; i++) {\n\t\t/* XXX wonder if we have to probe here to make the card go */\n\t\t(void)SRAM_READ_FIELD_1(sc, RAY_GET_CCS(i), ray_cmd, c_status);\n\t\tif (!sc->sc_ccsinuse[i])\n\t\t\tbreak;\n\t}\n\tif (i > RAY_CCS_CMD_LAST) {\n\t\tif (track)\n\t\t\tray_cmd_schedule(sc, track);\n\t\treturn (0);\n\t}\n\tsc->sc_ccsinuse[i] = 1;\n\tccs = RAY_GET_CCS(i);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_status, RAY_CCS_STATUS_BUSY);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_cmd, cmd);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_link, RAY_CCS_LINK_NULL);\n\n\t*ccsp = ccs;\n\treturn (1);\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tsc_xname\tsc_dev.dv_xname"
          ],
          "globals_used": [
            "int ray_alloc_ccs",
            "void ray_cmd_schedule"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_xname\tsc_dev.dv_xname\n\nint ray_alloc_ccs;\nvoid ray_cmd_schedule;\n\nint\nray_alloc_ccs(sc, ccsp, cmd, track)\n\tstruct ray_softc *sc;\n\tbus_size_t *ccsp;\n\tu_int cmd, track;\n{\n\tbus_size_t ccs;\n\tu_int i;\n\n\tRAY_DPRINTF((\"%s: alloc_ccs cmd %d\\n\", sc->sc_xname, cmd));\n\n\t/* for tracked commands, if not ready just set pending */\n\tif (track && !RAY_ECF_READY(sc)) {\n\t\tray_cmd_schedule(sc, track);\n\t\treturn (0);\n\t}\n\n\t/* first scan our inuse array */\n\tfor (i = RAY_CCS_CMD_FIRST; i <= RAY_CCS_CMD_LAST; i++) {\n\t\t/* XXX wonder if we have to probe here to make the card go */\n\t\t(void)SRAM_READ_FIELD_1(sc, RAY_GET_CCS(i), ray_cmd, c_status);\n\t\tif (!sc->sc_ccsinuse[i])\n\t\t\tbreak;\n\t}\n\tif (i > RAY_CCS_CMD_LAST) {\n\t\tif (track)\n\t\t\tray_cmd_schedule(sc, track);\n\t\treturn (0);\n\t}\n\tsc->sc_ccsinuse[i] = 1;\n\tccs = RAY_GET_CCS(i);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_status, RAY_CCS_STATUS_BUSY);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_cmd, cmd);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_link, RAY_CCS_LINK_NULL);\n\n\t*ccsp = ccs;\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ray_cmd_schedule",
          "args": [
            "sc",
            "SCP_UPD_MCAST"
          ],
          "line": 2953
        },
        "resolved": true,
        "details": {
          "function_name": "ray_cmd_schedule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2248-2265",
          "snippet": "void\nray_cmd_schedule(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tint track;\n\n\tRAY_DPRINTF((\"%s: ray_cmd_schedule 0x%x\\n\", sc->sc_xname, cmdf));\n\n\ttrack = cmdf;\n\tif ((cmdf & SCP_UPD_MASK) == 0)\n\t\tray_set_pending(sc, track);\n\telse if (ray_cmd_is_running(sc, SCP_UPDATESUBCMD)) {\n\t\t/* don't do timeout mechaniscm if subcmd already going */\n\t\tsc->sc_scheduled |= cmdf;\n\t} else\n\t\tray_set_pending(sc, cmdf | SCP_UPDATESUBCMD);\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tSCP_UPD_MASK\t\t0xff00",
            "#define\tSCP_UPDATESUBCMD\t0x0001",
            "#define\tsc_xname\tsc_dev.dv_xname"
          ],
          "globals_used": [
            "void ray_cmd_schedule",
            "int ray_cmd_is_running",
            "void ray_set_pending"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSCP_UPD_MASK\t\t0xff00\n#define\tSCP_UPDATESUBCMD\t0x0001\n#define\tsc_xname\tsc_dev.dv_xname\n\nvoid ray_cmd_schedule;\nint ray_cmd_is_running;\nvoid ray_set_pending;\n\nvoid\nray_cmd_schedule(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tint track;\n\n\tRAY_DPRINTF((\"%s: ray_cmd_schedule 0x%x\\n\", sc->sc_xname, cmdf));\n\n\ttrack = cmdf;\n\tif ((cmdf & SCP_UPD_MASK) == 0)\n\t\tray_set_pending(sc, track);\n\telse if (ray_cmd_is_running(sc, SCP_UPDATESUBCMD)) {\n\t\t/* don't do timeout mechaniscm if subcmd already going */\n\t\tsc->sc_scheduled |= cmdf;\n\t} else\n\t\tray_set_pending(sc, cmdf | SCP_UPDATESUBCMD);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ray_cmd_is_running",
          "args": [
            "sc",
            "SCP_UPDATESUBCMD"
          ],
          "line": 2952
        },
        "resolved": true,
        "details": {
          "function_name": "ray_cmd_is_running",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2326-2334",
          "snippet": "int\nray_cmd_is_running(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_cmd_is_running 0x%x\\n\", sc->sc_xname, cmdf));\n\n\treturn ((sc->sc_running & cmdf) ? 1 : 0);\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tsc_xname\tsc_dev.dv_xname"
          ],
          "globals_used": [
            "int ray_cmd_is_running"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_xname\tsc_dev.dv_xname\n\nint ray_cmd_is_running;\n\nint\nray_cmd_is_running(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_cmd_is_running 0x%x\\n\", sc->sc_xname, cmdf));\n\n\treturn ((sc->sc_running & cmdf) ? 1 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ray_update_promisc",
          "args": [
            "sc"
          ],
          "line": 2947
        },
        "resolved": true,
        "details": {
          "function_name": "ray_update_promisc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2845-2869",
          "snippet": "void\nray_update_promisc(sc)\n\tstruct ray_softc *sc;\n{\n\tbus_size_t ccs;\n\tint promisc;\n\n\tray_cmd_cancel(sc, SCP_UPD_PROMISC);\n\n\t/* do the issue check before equality check */\n\tpromisc = !!(sc->sc_if.if_flags & (IFF_PROMISC | IFF_ALLMULTI));\n\tif ((sc->sc_if.if_flags & IFF_RUNNING) == 0)\n\t\treturn;\n\telse if (ray_cmd_is_running(sc, SCP_UPDATESUBCMD)) {\n\t\tray_cmd_schedule(sc, SCP_UPD_PROMISC);\n\t\treturn;\n\t} else if (promisc == sc->sc_promisc)\n\t\treturn;\n\telse if (!ray_alloc_ccs(sc,&ccs,RAY_CMD_UPDATE_PARAMS, SCP_UPD_PROMISC))\n\t\treturn;\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_update, c_paramid, RAY_PID_PROMISC);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_update, c_nparam, 1);\n\tSRAM_WRITE_1(sc, RAY_HOST_TO_ECF_BASE, promisc);\n\t(void)ray_issue_cmd(sc, ccs, SCP_UPD_PROMISC);\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tSCP_UPD_PROMISC\t\t0x0400",
            "#define\tSCP_UPDATESUBCMD\t0x0001",
            "#define\tsc_if\t\tsc_ec.ac_if",
            "#define\tsc_if\t\tsc_ec.ec_if"
          ],
          "globals_used": [
            "int ray_alloc_ccs",
            "void ray_cmd_cancel",
            "void ray_cmd_schedule",
            "int ray_cmd_is_running",
            "int ray_issue_cmd",
            "void ray_update_promisc"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSCP_UPD_PROMISC\t\t0x0400\n#define\tSCP_UPDATESUBCMD\t0x0001\n#define\tsc_if\t\tsc_ec.ac_if\n#define\tsc_if\t\tsc_ec.ec_if\n\nint ray_alloc_ccs;\nvoid ray_cmd_cancel;\nvoid ray_cmd_schedule;\nint ray_cmd_is_running;\nint ray_issue_cmd;\nvoid ray_update_promisc;\n\nvoid\nray_update_promisc(sc)\n\tstruct ray_softc *sc;\n{\n\tbus_size_t ccs;\n\tint promisc;\n\n\tray_cmd_cancel(sc, SCP_UPD_PROMISC);\n\n\t/* do the issue check before equality check */\n\tpromisc = !!(sc->sc_if.if_flags & (IFF_PROMISC | IFF_ALLMULTI));\n\tif ((sc->sc_if.if_flags & IFF_RUNNING) == 0)\n\t\treturn;\n\telse if (ray_cmd_is_running(sc, SCP_UPDATESUBCMD)) {\n\t\tray_cmd_schedule(sc, SCP_UPD_PROMISC);\n\t\treturn;\n\t} else if (promisc == sc->sc_promisc)\n\t\treturn;\n\telse if (!ray_alloc_ccs(sc,&ccs,RAY_CMD_UPDATE_PARAMS, SCP_UPD_PROMISC))\n\t\treturn;\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_update, c_paramid, RAY_PID_PROMISC);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_update, c_nparam, 1);\n\tSRAM_WRITE_1(sc, RAY_HOST_TO_ECF_BASE, promisc);\n\t(void)ray_issue_cmd(sc, ccs, SCP_UPD_PROMISC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ETHER_NEXT_MULTI",
          "args": [
            "step",
            "enm"
          ],
          "line": 2936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "enm->enm_addrlo",
            "enm->enm_addrhi",
            "ETHER_ADDR_LEN"
          ],
          "line": 2931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ETHER_FIRST_MULTI",
          "args": [
            "step",
            "ec",
            "enm"
          ],
          "line": 2928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ray_cmd_cancel",
          "args": [
            "sc",
            "SCP_UPD_MCAST"
          ],
          "line": 2924
        },
        "resolved": true,
        "details": {
          "function_name": "ray_cmd_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2283-2299",
          "snippet": "void\nray_cmd_cancel(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_cmd_cancel 0x%x\\n\", sc->sc_xname, cmdf));\n\n\tsc->sc_scheduled &= ~cmdf;\n\tif ((cmdf & SCP_UPD_MASK) && (sc->sc_scheduled & SCP_UPD_MASK) == 0)\n\t\tsc->sc_scheduled &= ~SCP_UPDATESUBCMD;\n\n\t/* if nothing else needed cancel the timer */\n\tif (sc->sc_scheduled == 0 && sc->sc_timoneed) {\n\t\tcallout_stop(&sc->sc_check_scheduled_ch);\n\t\tsc->sc_timoneed = 0;\n\t}\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tSCP_UPD_MASK\t\t0xff00",
            "#define\tSCP_UPDATESUBCMD\t0x0001",
            "#define\tsc_xname\tsc_dev.dv_xname",
            "#define\tcallout_stop\ttimeout_del"
          ],
          "globals_used": [
            "void ray_cmd_cancel"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSCP_UPD_MASK\t\t0xff00\n#define\tSCP_UPDATESUBCMD\t0x0001\n#define\tsc_xname\tsc_dev.dv_xname\n#define\tcallout_stop\ttimeout_del\n\nvoid ray_cmd_cancel;\n\nvoid\nray_cmd_cancel(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_cmd_cancel 0x%x\\n\", sc->sc_xname, cmdf));\n\n\tsc->sc_scheduled &= ~cmdf;\n\tif ((cmdf & SCP_UPD_MASK) && (sc->sc_scheduled & SCP_UPD_MASK) == 0)\n\t\tsc->sc_scheduled &= ~SCP_UPDATESUBCMD;\n\n\t/* if nothing else needed cancel the timer */\n\tif (sc->sc_scheduled == 0 && sc->sc_timoneed) {\n\t\tcallout_stop(&sc->sc_check_scheduled_ch);\n\t\tsc->sc_timoneed = 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSCP_UPD_MCAST\t\t0x0800\n#define\tSCP_UPDATESUBCMD\t0x0001\n#define\tec_multicnt\tac_multicnt\n#define\tsc_if\t\tsc_ec.ac_if\n#define\tsc_if\t\tsc_ec.ec_if\n\nint ray_alloc_ccs;\nvoid ray_cmd_cancel;\nvoid ray_cmd_schedule;\nint ray_cmd_is_running;\nint ray_issue_cmd;\nvoid ray_update_mcast;\nvoid ray_update_promisc;\n\nvoid\nray_update_mcast(sc)\n\tstruct ray_softc *sc;\n{\n\tbus_size_t ccs;\n\tstruct ether_multistep step;\n\tstruct ether_multi *enm;\n#ifdef __NetBSD__\n\tstruct ethercom *ec;\n#elif defined(__OpenBSD__)\n\tstruct arpcom *ec;\n#endif\n\tbus_size_t bufp;\n\tint count;\n\n\tec = &sc->sc_ec;\n\tray_cmd_cancel(sc, SCP_UPD_MCAST);\n\n\t/* see if we have any ranges */\n\tif ((count = sc->sc_ec.ec_multicnt) < 17) {\n\t\tETHER_FIRST_MULTI(step, ec, enm);\n\t\twhile (enm) {\n\t\t\t/* see if this is a range */\n\t\t\tif (memcmp(enm->enm_addrlo, enm->enm_addrhi,\n\t\t\t\tETHER_ADDR_LEN)) {\n\t\t\t\tcount = 17;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tETHER_NEXT_MULTI(step, enm);\n\t\t}\n\t}\n\n\t/* track this stuff even when not running */\n\tif (count > 16) {\n\t\tsc->sc_if.if_flags |= IFF_ALLMULTI;\n\t\tray_update_promisc(sc);\n\t\treturn;\n\t} else if (sc->sc_if.if_flags & IFF_ALLMULTI) {\n\t\tsc->sc_if.if_flags &= ~IFF_ALLMULTI;\n\t\tray_update_promisc(sc);\n\t}\n\n\tif ((sc->sc_if.if_flags & IFF_RUNNING) == 0)\n\t\treturn;\n\telse if (ray_cmd_is_running(sc, SCP_UPDATESUBCMD)) {\n\t\tray_cmd_schedule(sc, SCP_UPD_MCAST);\n\t\treturn;\n\t} else if (!ray_alloc_ccs(sc,&ccs, RAY_CMD_UPDATE_MCAST, SCP_UPD_MCAST))\n\t\treturn;\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_update_mcast, c_nmcast, count);\n\tbufp = RAY_HOST_TO_ECF_BASE;\n\tETHER_FIRST_MULTI(step, ec, enm);\n\twhile (enm) {\n\t\tray_write_region(sc, bufp, enm->enm_addrlo, ETHER_ADDR_LEN);\n\t\tbufp += ETHER_ADDR_LEN;\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\t(void)ray_issue_cmd(sc, ccs, SCP_UPD_MCAST);\n}"
  },
  {
    "function_name": "ray_update_params",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
    "lines": "2874-2903",
    "snippet": "void\nray_update_params(sc)\n\tstruct ray_softc *sc;\n{\n\tbus_size_t ccs;\n\n\tray_cmd_cancel(sc, SCP_UPD_UPDATEPARAMS);\n\tif (!sc->sc_updreq) {\n\t\t/* XXX do we need to wakeup here? */\n\t\treturn;\n\t}\n\n\t/* do the issue check before equality check */\n\tif ((sc->sc_if.if_flags & IFF_RUNNING) == 0)\n\t\treturn;\n\telse if (ray_cmd_is_running(sc, SCP_UPDATESUBCMD)) {\n\t\tray_cmd_schedule(sc, SCP_UPD_UPDATEPARAMS);\n\t\treturn;\n\t} else if (!ray_alloc_ccs(sc, &ccs, RAY_CMD_UPDATE_PARAMS,\n\t    SCP_UPD_UPDATEPARAMS))\n\t\treturn;\n\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_update, c_paramid,\n\t    sc->sc_updreq->r_paramid);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_update, c_nparam, 1);\n\tray_write_region(sc, RAY_HOST_TO_ECF_BASE, sc->sc_updreq->r_data,\n\t    sc->sc_updreq->r_len);\n\n\t(void)ray_issue_cmd(sc, ccs, SCP_UPD_UPDATEPARAMS);\n}",
    "includes": [
      "#include <dev/pcmcia/if_rayreg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_llc.h>",
      "#include <net/if_media.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/timeout.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [
      "#define\tSCP_UPD_UPDATEPARAMS\t0x1000",
      "#define\tSCP_UPDATESUBCMD\t0x0001",
      "#define\tsc_if\t\tsc_ec.ac_if",
      "#define\tsc_if\t\tsc_ec.ec_if"
    ],
    "globals_used": [
      "int ray_alloc_ccs",
      "void ray_cmd_cancel",
      "void ray_cmd_schedule",
      "int ray_cmd_is_running",
      "int ray_issue_cmd",
      "void ray_update_params"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ray_issue_cmd",
          "args": [
            "sc",
            "ccs",
            "SCP_UPD_UPDATEPARAMS"
          ],
          "line": 2902
        },
        "resolved": true,
        "details": {
          "function_name": "ray_issue_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2362-2391",
          "snippet": "int\nray_issue_cmd(sc, ccs, track)\n\tstruct ray_softc *sc;\n\tbus_size_t ccs;\n\tu_int track;\n{\n\tu_int i;\n\n\tRAY_DPRINTF((\"%s: ray_cmd_issue 0x%x\\n\", sc->sc_xname, track));\n\n\t/*\n\t * XXX other drivers did this, but I think\n\t * what we really want to do is just make sure we don't\n\t * get here or that spinning is ok\n\t */\n\ti = 0;\n\twhile (!RAY_ECF_READY(sc))\n\t\tif (++i > 50) {\n\t\t\tray_free_ccs(sc, ccs);\n\t\t\tif (track)\n\t\t\t\tray_cmd_schedule(sc, track);\n\t\t\treturn (0);\n\t\t}\n\n\tSRAM_WRITE_1(sc, RAY_SCB_CCSI, RAY_GET_INDEX(ccs));\n\tRAY_ECF_START_CMD(sc);\n\tray_cmd_ran(sc, track);\n\n\treturn (1);\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tsc_xname\tsc_dev.dv_xname"
          ],
          "globals_used": [
            "void ray_cmd_schedule",
            "void ray_cmd_ran",
            "u_int8_t ray_free_ccs",
            "int ray_issue_cmd"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_xname\tsc_dev.dv_xname\n\nvoid ray_cmd_schedule;\nvoid ray_cmd_ran;\nu_int8_t ray_free_ccs;\nint ray_issue_cmd;\n\nint\nray_issue_cmd(sc, ccs, track)\n\tstruct ray_softc *sc;\n\tbus_size_t ccs;\n\tu_int track;\n{\n\tu_int i;\n\n\tRAY_DPRINTF((\"%s: ray_cmd_issue 0x%x\\n\", sc->sc_xname, track));\n\n\t/*\n\t * XXX other drivers did this, but I think\n\t * what we really want to do is just make sure we don't\n\t * get here or that spinning is ok\n\t */\n\ti = 0;\n\twhile (!RAY_ECF_READY(sc))\n\t\tif (++i > 50) {\n\t\t\tray_free_ccs(sc, ccs);\n\t\t\tif (track)\n\t\t\t\tray_cmd_schedule(sc, track);\n\t\t\treturn (0);\n\t\t}\n\n\tSRAM_WRITE_1(sc, RAY_SCB_CCSI, RAY_GET_INDEX(ccs));\n\tRAY_ECF_START_CMD(sc);\n\tray_cmd_ran(sc, track);\n\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ray_write_region",
          "args": [
            "sc",
            "RAY_HOST_TO_ECF_BASE",
            "sc->sc_updreq->r_data",
            "sc->sc_updreq->r_len"
          ],
          "line": 2899
        },
        "resolved": true,
        "details": {
          "function_name": "ray_write_region",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "3125-3177",
          "snippet": "void\nray_write_region(sc, off, vp, c)\n\tstruct ray_softc *sc;\n\tbus_size_t off;\n\tvoid *vp;\n\tsize_t c;\n{\n#ifdef RAY_USE_OPTIMIZED_COPY\n\tsize_t n2, n4, tmp;\n\tu_int8_t *p;\n\n\tp = vp;\n\t/* XXX we may be making poor assumptions here but lets hope */\n\tswitch ((off|(bus_addr_t)p) & 0x03) {\n\tcase 0:\n\t\tif ((n4 = (c >> 2))) {\n\t\t\tbus_space_write_region_4(sc->sc_memt, sc->sc_memh, off,\n\t\t\t    p, n4);\n\t\t\ttmp = c & ~0x3;\n\t\t\tc &= 0x3;\n\t\t\tp += tmp;\n\t\t\toff += tmp;\n\t\t}\n\t\tswitch (c) {\n\t\tcase 3:\n\t\t\tbus_space_write_1(sc->sc_memt,sc->sc_memh, off, *p);\n\t\t\tp++, off++;\n\t\tcase 2:\n\t\t\tbus_space_write_1(sc->sc_memt,sc->sc_memh, off, *p);\n\t\t\tp++, off++;\n\t\tcase 1:\n\t\t\tbus_space_write_1(sc->sc_memt,sc->sc_memh, off, *p);\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tif ((n2 = (c >> 1)))\n\t\t\tbus_space_write_region_2(sc->sc_memt, sc->sc_memh, off,\n\t\t\t    p, n2);\n\t\tif (c & 0x1) {\n\t\t\tc &= ~0x1;\n\t\t\tbus_space_write_1(sc->sc_memt, sc->sc_memh,\n\t\t\t    off + c, *(p + c));\n\t\t}\n\t\tbreak;\n\tcase 1:\n\tcase 3:\n\t\tbus_space_write_region_1(sc->sc_memt, sc->sc_memh, off, p, c);\n\t\tbreak;\n\t}\n#else\n\tbus_space_write_region_1(sc->sc_memt, sc->sc_memh, off, vp, c);\n#endif\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tsc_memh\tsc_mem.memh",
            "#define\tsc_memt\tsc_mem.memt"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_memh\tsc_mem.memh\n#define\tsc_memt\tsc_mem.memt\n\nvoid\nray_write_region(sc, off, vp, c)\n\tstruct ray_softc *sc;\n\tbus_size_t off;\n\tvoid *vp;\n\tsize_t c;\n{\n#ifdef RAY_USE_OPTIMIZED_COPY\n\tsize_t n2, n4, tmp;\n\tu_int8_t *p;\n\n\tp = vp;\n\t/* XXX we may be making poor assumptions here but lets hope */\n\tswitch ((off|(bus_addr_t)p) & 0x03) {\n\tcase 0:\n\t\tif ((n4 = (c >> 2))) {\n\t\t\tbus_space_write_region_4(sc->sc_memt, sc->sc_memh, off,\n\t\t\t    p, n4);\n\t\t\ttmp = c & ~0x3;\n\t\t\tc &= 0x3;\n\t\t\tp += tmp;\n\t\t\toff += tmp;\n\t\t}\n\t\tswitch (c) {\n\t\tcase 3:\n\t\t\tbus_space_write_1(sc->sc_memt,sc->sc_memh, off, *p);\n\t\t\tp++, off++;\n\t\tcase 2:\n\t\t\tbus_space_write_1(sc->sc_memt,sc->sc_memh, off, *p);\n\t\t\tp++, off++;\n\t\tcase 1:\n\t\t\tbus_space_write_1(sc->sc_memt,sc->sc_memh, off, *p);\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tif ((n2 = (c >> 1)))\n\t\t\tbus_space_write_region_2(sc->sc_memt, sc->sc_memh, off,\n\t\t\t    p, n2);\n\t\tif (c & 0x1) {\n\t\t\tc &= ~0x1;\n\t\t\tbus_space_write_1(sc->sc_memt, sc->sc_memh,\n\t\t\t    off + c, *(p + c));\n\t\t}\n\t\tbreak;\n\tcase 1:\n\tcase 3:\n\t\tbus_space_write_region_1(sc->sc_memt, sc->sc_memh, off, p, c);\n\t\tbreak;\n\t}\n#else\n\tbus_space_write_region_1(sc->sc_memt, sc->sc_memh, off, vp, c);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "SRAM_WRITE_FIELD_1",
          "args": [
            "sc",
            "ccs",
            "ray_cmd_update",
            "c_nparam",
            "1"
          ],
          "line": 2898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRAM_WRITE_FIELD_1",
          "args": [
            "sc",
            "ccs",
            "ray_cmd_update",
            "c_paramid",
            "sc->sc_updreq->r_paramid"
          ],
          "line": 2896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ray_alloc_ccs",
          "args": [
            "sc",
            "&ccs",
            "RAY_CMD_UPDATE_PARAMS",
            "SCP_UPD_UPDATEPARAMS"
          ],
          "line": 2892
        },
        "resolved": true,
        "details": {
          "function_name": "ray_alloc_ccs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2184-2221",
          "snippet": "int\nray_alloc_ccs(sc, ccsp, cmd, track)\n\tstruct ray_softc *sc;\n\tbus_size_t *ccsp;\n\tu_int cmd, track;\n{\n\tbus_size_t ccs;\n\tu_int i;\n\n\tRAY_DPRINTF((\"%s: alloc_ccs cmd %d\\n\", sc->sc_xname, cmd));\n\n\t/* for tracked commands, if not ready just set pending */\n\tif (track && !RAY_ECF_READY(sc)) {\n\t\tray_cmd_schedule(sc, track);\n\t\treturn (0);\n\t}\n\n\t/* first scan our inuse array */\n\tfor (i = RAY_CCS_CMD_FIRST; i <= RAY_CCS_CMD_LAST; i++) {\n\t\t/* XXX wonder if we have to probe here to make the card go */\n\t\t(void)SRAM_READ_FIELD_1(sc, RAY_GET_CCS(i), ray_cmd, c_status);\n\t\tif (!sc->sc_ccsinuse[i])\n\t\t\tbreak;\n\t}\n\tif (i > RAY_CCS_CMD_LAST) {\n\t\tif (track)\n\t\t\tray_cmd_schedule(sc, track);\n\t\treturn (0);\n\t}\n\tsc->sc_ccsinuse[i] = 1;\n\tccs = RAY_GET_CCS(i);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_status, RAY_CCS_STATUS_BUSY);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_cmd, cmd);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_link, RAY_CCS_LINK_NULL);\n\n\t*ccsp = ccs;\n\treturn (1);\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tsc_xname\tsc_dev.dv_xname"
          ],
          "globals_used": [
            "int ray_alloc_ccs",
            "void ray_cmd_schedule"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_xname\tsc_dev.dv_xname\n\nint ray_alloc_ccs;\nvoid ray_cmd_schedule;\n\nint\nray_alloc_ccs(sc, ccsp, cmd, track)\n\tstruct ray_softc *sc;\n\tbus_size_t *ccsp;\n\tu_int cmd, track;\n{\n\tbus_size_t ccs;\n\tu_int i;\n\n\tRAY_DPRINTF((\"%s: alloc_ccs cmd %d\\n\", sc->sc_xname, cmd));\n\n\t/* for tracked commands, if not ready just set pending */\n\tif (track && !RAY_ECF_READY(sc)) {\n\t\tray_cmd_schedule(sc, track);\n\t\treturn (0);\n\t}\n\n\t/* first scan our inuse array */\n\tfor (i = RAY_CCS_CMD_FIRST; i <= RAY_CCS_CMD_LAST; i++) {\n\t\t/* XXX wonder if we have to probe here to make the card go */\n\t\t(void)SRAM_READ_FIELD_1(sc, RAY_GET_CCS(i), ray_cmd, c_status);\n\t\tif (!sc->sc_ccsinuse[i])\n\t\t\tbreak;\n\t}\n\tif (i > RAY_CCS_CMD_LAST) {\n\t\tif (track)\n\t\t\tray_cmd_schedule(sc, track);\n\t\treturn (0);\n\t}\n\tsc->sc_ccsinuse[i] = 1;\n\tccs = RAY_GET_CCS(i);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_status, RAY_CCS_STATUS_BUSY);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_cmd, cmd);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_link, RAY_CCS_LINK_NULL);\n\n\t*ccsp = ccs;\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ray_cmd_schedule",
          "args": [
            "sc",
            "SCP_UPD_UPDATEPARAMS"
          ],
          "line": 2890
        },
        "resolved": true,
        "details": {
          "function_name": "ray_cmd_schedule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2248-2265",
          "snippet": "void\nray_cmd_schedule(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tint track;\n\n\tRAY_DPRINTF((\"%s: ray_cmd_schedule 0x%x\\n\", sc->sc_xname, cmdf));\n\n\ttrack = cmdf;\n\tif ((cmdf & SCP_UPD_MASK) == 0)\n\t\tray_set_pending(sc, track);\n\telse if (ray_cmd_is_running(sc, SCP_UPDATESUBCMD)) {\n\t\t/* don't do timeout mechaniscm if subcmd already going */\n\t\tsc->sc_scheduled |= cmdf;\n\t} else\n\t\tray_set_pending(sc, cmdf | SCP_UPDATESUBCMD);\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tSCP_UPD_MASK\t\t0xff00",
            "#define\tSCP_UPDATESUBCMD\t0x0001",
            "#define\tsc_xname\tsc_dev.dv_xname"
          ],
          "globals_used": [
            "void ray_cmd_schedule",
            "int ray_cmd_is_running",
            "void ray_set_pending"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSCP_UPD_MASK\t\t0xff00\n#define\tSCP_UPDATESUBCMD\t0x0001\n#define\tsc_xname\tsc_dev.dv_xname\n\nvoid ray_cmd_schedule;\nint ray_cmd_is_running;\nvoid ray_set_pending;\n\nvoid\nray_cmd_schedule(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tint track;\n\n\tRAY_DPRINTF((\"%s: ray_cmd_schedule 0x%x\\n\", sc->sc_xname, cmdf));\n\n\ttrack = cmdf;\n\tif ((cmdf & SCP_UPD_MASK) == 0)\n\t\tray_set_pending(sc, track);\n\telse if (ray_cmd_is_running(sc, SCP_UPDATESUBCMD)) {\n\t\t/* don't do timeout mechaniscm if subcmd already going */\n\t\tsc->sc_scheduled |= cmdf;\n\t} else\n\t\tray_set_pending(sc, cmdf | SCP_UPDATESUBCMD);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ray_cmd_is_running",
          "args": [
            "sc",
            "SCP_UPDATESUBCMD"
          ],
          "line": 2889
        },
        "resolved": true,
        "details": {
          "function_name": "ray_cmd_is_running",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2326-2334",
          "snippet": "int\nray_cmd_is_running(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_cmd_is_running 0x%x\\n\", sc->sc_xname, cmdf));\n\n\treturn ((sc->sc_running & cmdf) ? 1 : 0);\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tsc_xname\tsc_dev.dv_xname"
          ],
          "globals_used": [
            "int ray_cmd_is_running"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_xname\tsc_dev.dv_xname\n\nint ray_cmd_is_running;\n\nint\nray_cmd_is_running(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_cmd_is_running 0x%x\\n\", sc->sc_xname, cmdf));\n\n\treturn ((sc->sc_running & cmdf) ? 1 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ray_cmd_cancel",
          "args": [
            "sc",
            "SCP_UPD_UPDATEPARAMS"
          ],
          "line": 2880
        },
        "resolved": true,
        "details": {
          "function_name": "ray_cmd_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2283-2299",
          "snippet": "void\nray_cmd_cancel(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_cmd_cancel 0x%x\\n\", sc->sc_xname, cmdf));\n\n\tsc->sc_scheduled &= ~cmdf;\n\tif ((cmdf & SCP_UPD_MASK) && (sc->sc_scheduled & SCP_UPD_MASK) == 0)\n\t\tsc->sc_scheduled &= ~SCP_UPDATESUBCMD;\n\n\t/* if nothing else needed cancel the timer */\n\tif (sc->sc_scheduled == 0 && sc->sc_timoneed) {\n\t\tcallout_stop(&sc->sc_check_scheduled_ch);\n\t\tsc->sc_timoneed = 0;\n\t}\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tSCP_UPD_MASK\t\t0xff00",
            "#define\tSCP_UPDATESUBCMD\t0x0001",
            "#define\tsc_xname\tsc_dev.dv_xname",
            "#define\tcallout_stop\ttimeout_del"
          ],
          "globals_used": [
            "void ray_cmd_cancel"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSCP_UPD_MASK\t\t0xff00\n#define\tSCP_UPDATESUBCMD\t0x0001\n#define\tsc_xname\tsc_dev.dv_xname\n#define\tcallout_stop\ttimeout_del\n\nvoid ray_cmd_cancel;\n\nvoid\nray_cmd_cancel(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_cmd_cancel 0x%x\\n\", sc->sc_xname, cmdf));\n\n\tsc->sc_scheduled &= ~cmdf;\n\tif ((cmdf & SCP_UPD_MASK) && (sc->sc_scheduled & SCP_UPD_MASK) == 0)\n\t\tsc->sc_scheduled &= ~SCP_UPDATESUBCMD;\n\n\t/* if nothing else needed cancel the timer */\n\tif (sc->sc_scheduled == 0 && sc->sc_timoneed) {\n\t\tcallout_stop(&sc->sc_check_scheduled_ch);\n\t\tsc->sc_timoneed = 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSCP_UPD_UPDATEPARAMS\t0x1000\n#define\tSCP_UPDATESUBCMD\t0x0001\n#define\tsc_if\t\tsc_ec.ac_if\n#define\tsc_if\t\tsc_ec.ec_if\n\nint ray_alloc_ccs;\nvoid ray_cmd_cancel;\nvoid ray_cmd_schedule;\nint ray_cmd_is_running;\nint ray_issue_cmd;\nvoid ray_update_params;\n\nvoid\nray_update_params(sc)\n\tstruct ray_softc *sc;\n{\n\tbus_size_t ccs;\n\n\tray_cmd_cancel(sc, SCP_UPD_UPDATEPARAMS);\n\tif (!sc->sc_updreq) {\n\t\t/* XXX do we need to wakeup here? */\n\t\treturn;\n\t}\n\n\t/* do the issue check before equality check */\n\tif ((sc->sc_if.if_flags & IFF_RUNNING) == 0)\n\t\treturn;\n\telse if (ray_cmd_is_running(sc, SCP_UPDATESUBCMD)) {\n\t\tray_cmd_schedule(sc, SCP_UPD_UPDATEPARAMS);\n\t\treturn;\n\t} else if (!ray_alloc_ccs(sc, &ccs, RAY_CMD_UPDATE_PARAMS,\n\t    SCP_UPD_UPDATEPARAMS))\n\t\treturn;\n\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_update, c_paramid,\n\t    sc->sc_updreq->r_paramid);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_update, c_nparam, 1);\n\tray_write_region(sc, RAY_HOST_TO_ECF_BASE, sc->sc_updreq->r_data,\n\t    sc->sc_updreq->r_len);\n\n\t(void)ray_issue_cmd(sc, ccs, SCP_UPD_UPDATEPARAMS);\n}"
  },
  {
    "function_name": "ray_update_promisc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
    "lines": "2845-2869",
    "snippet": "void\nray_update_promisc(sc)\n\tstruct ray_softc *sc;\n{\n\tbus_size_t ccs;\n\tint promisc;\n\n\tray_cmd_cancel(sc, SCP_UPD_PROMISC);\n\n\t/* do the issue check before equality check */\n\tpromisc = !!(sc->sc_if.if_flags & (IFF_PROMISC | IFF_ALLMULTI));\n\tif ((sc->sc_if.if_flags & IFF_RUNNING) == 0)\n\t\treturn;\n\telse if (ray_cmd_is_running(sc, SCP_UPDATESUBCMD)) {\n\t\tray_cmd_schedule(sc, SCP_UPD_PROMISC);\n\t\treturn;\n\t} else if (promisc == sc->sc_promisc)\n\t\treturn;\n\telse if (!ray_alloc_ccs(sc,&ccs,RAY_CMD_UPDATE_PARAMS, SCP_UPD_PROMISC))\n\t\treturn;\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_update, c_paramid, RAY_PID_PROMISC);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_update, c_nparam, 1);\n\tSRAM_WRITE_1(sc, RAY_HOST_TO_ECF_BASE, promisc);\n\t(void)ray_issue_cmd(sc, ccs, SCP_UPD_PROMISC);\n}",
    "includes": [
      "#include <dev/pcmcia/if_rayreg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_llc.h>",
      "#include <net/if_media.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/timeout.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [
      "#define\tSCP_UPD_PROMISC\t\t0x0400",
      "#define\tSCP_UPDATESUBCMD\t0x0001",
      "#define\tsc_if\t\tsc_ec.ac_if",
      "#define\tsc_if\t\tsc_ec.ec_if"
    ],
    "globals_used": [
      "int ray_alloc_ccs",
      "void ray_cmd_cancel",
      "void ray_cmd_schedule",
      "int ray_cmd_is_running",
      "int ray_issue_cmd",
      "void ray_update_promisc"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ray_issue_cmd",
          "args": [
            "sc",
            "ccs",
            "SCP_UPD_PROMISC"
          ],
          "line": 2868
        },
        "resolved": true,
        "details": {
          "function_name": "ray_issue_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2362-2391",
          "snippet": "int\nray_issue_cmd(sc, ccs, track)\n\tstruct ray_softc *sc;\n\tbus_size_t ccs;\n\tu_int track;\n{\n\tu_int i;\n\n\tRAY_DPRINTF((\"%s: ray_cmd_issue 0x%x\\n\", sc->sc_xname, track));\n\n\t/*\n\t * XXX other drivers did this, but I think\n\t * what we really want to do is just make sure we don't\n\t * get here or that spinning is ok\n\t */\n\ti = 0;\n\twhile (!RAY_ECF_READY(sc))\n\t\tif (++i > 50) {\n\t\t\tray_free_ccs(sc, ccs);\n\t\t\tif (track)\n\t\t\t\tray_cmd_schedule(sc, track);\n\t\t\treturn (0);\n\t\t}\n\n\tSRAM_WRITE_1(sc, RAY_SCB_CCSI, RAY_GET_INDEX(ccs));\n\tRAY_ECF_START_CMD(sc);\n\tray_cmd_ran(sc, track);\n\n\treturn (1);\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tsc_xname\tsc_dev.dv_xname"
          ],
          "globals_used": [
            "void ray_cmd_schedule",
            "void ray_cmd_ran",
            "u_int8_t ray_free_ccs",
            "int ray_issue_cmd"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_xname\tsc_dev.dv_xname\n\nvoid ray_cmd_schedule;\nvoid ray_cmd_ran;\nu_int8_t ray_free_ccs;\nint ray_issue_cmd;\n\nint\nray_issue_cmd(sc, ccs, track)\n\tstruct ray_softc *sc;\n\tbus_size_t ccs;\n\tu_int track;\n{\n\tu_int i;\n\n\tRAY_DPRINTF((\"%s: ray_cmd_issue 0x%x\\n\", sc->sc_xname, track));\n\n\t/*\n\t * XXX other drivers did this, but I think\n\t * what we really want to do is just make sure we don't\n\t * get here or that spinning is ok\n\t */\n\ti = 0;\n\twhile (!RAY_ECF_READY(sc))\n\t\tif (++i > 50) {\n\t\t\tray_free_ccs(sc, ccs);\n\t\t\tif (track)\n\t\t\t\tray_cmd_schedule(sc, track);\n\t\t\treturn (0);\n\t\t}\n\n\tSRAM_WRITE_1(sc, RAY_SCB_CCSI, RAY_GET_INDEX(ccs));\n\tRAY_ECF_START_CMD(sc);\n\tray_cmd_ran(sc, track);\n\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SRAM_WRITE_1",
          "args": [
            "sc",
            "RAY_HOST_TO_ECF_BASE",
            "promisc"
          ],
          "line": 2867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRAM_WRITE_FIELD_1",
          "args": [
            "sc",
            "ccs",
            "ray_cmd_update",
            "c_nparam",
            "1"
          ],
          "line": 2866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRAM_WRITE_FIELD_1",
          "args": [
            "sc",
            "ccs",
            "ray_cmd_update",
            "c_paramid",
            "RAY_PID_PROMISC"
          ],
          "line": 2865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ray_alloc_ccs",
          "args": [
            "sc",
            "&ccs",
            "RAY_CMD_UPDATE_PARAMS",
            "SCP_UPD_PROMISC"
          ],
          "line": 2863
        },
        "resolved": true,
        "details": {
          "function_name": "ray_alloc_ccs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2184-2221",
          "snippet": "int\nray_alloc_ccs(sc, ccsp, cmd, track)\n\tstruct ray_softc *sc;\n\tbus_size_t *ccsp;\n\tu_int cmd, track;\n{\n\tbus_size_t ccs;\n\tu_int i;\n\n\tRAY_DPRINTF((\"%s: alloc_ccs cmd %d\\n\", sc->sc_xname, cmd));\n\n\t/* for tracked commands, if not ready just set pending */\n\tif (track && !RAY_ECF_READY(sc)) {\n\t\tray_cmd_schedule(sc, track);\n\t\treturn (0);\n\t}\n\n\t/* first scan our inuse array */\n\tfor (i = RAY_CCS_CMD_FIRST; i <= RAY_CCS_CMD_LAST; i++) {\n\t\t/* XXX wonder if we have to probe here to make the card go */\n\t\t(void)SRAM_READ_FIELD_1(sc, RAY_GET_CCS(i), ray_cmd, c_status);\n\t\tif (!sc->sc_ccsinuse[i])\n\t\t\tbreak;\n\t}\n\tif (i > RAY_CCS_CMD_LAST) {\n\t\tif (track)\n\t\t\tray_cmd_schedule(sc, track);\n\t\treturn (0);\n\t}\n\tsc->sc_ccsinuse[i] = 1;\n\tccs = RAY_GET_CCS(i);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_status, RAY_CCS_STATUS_BUSY);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_cmd, cmd);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_link, RAY_CCS_LINK_NULL);\n\n\t*ccsp = ccs;\n\treturn (1);\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tsc_xname\tsc_dev.dv_xname"
          ],
          "globals_used": [
            "int ray_alloc_ccs",
            "void ray_cmd_schedule"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_xname\tsc_dev.dv_xname\n\nint ray_alloc_ccs;\nvoid ray_cmd_schedule;\n\nint\nray_alloc_ccs(sc, ccsp, cmd, track)\n\tstruct ray_softc *sc;\n\tbus_size_t *ccsp;\n\tu_int cmd, track;\n{\n\tbus_size_t ccs;\n\tu_int i;\n\n\tRAY_DPRINTF((\"%s: alloc_ccs cmd %d\\n\", sc->sc_xname, cmd));\n\n\t/* for tracked commands, if not ready just set pending */\n\tif (track && !RAY_ECF_READY(sc)) {\n\t\tray_cmd_schedule(sc, track);\n\t\treturn (0);\n\t}\n\n\t/* first scan our inuse array */\n\tfor (i = RAY_CCS_CMD_FIRST; i <= RAY_CCS_CMD_LAST; i++) {\n\t\t/* XXX wonder if we have to probe here to make the card go */\n\t\t(void)SRAM_READ_FIELD_1(sc, RAY_GET_CCS(i), ray_cmd, c_status);\n\t\tif (!sc->sc_ccsinuse[i])\n\t\t\tbreak;\n\t}\n\tif (i > RAY_CCS_CMD_LAST) {\n\t\tif (track)\n\t\t\tray_cmd_schedule(sc, track);\n\t\treturn (0);\n\t}\n\tsc->sc_ccsinuse[i] = 1;\n\tccs = RAY_GET_CCS(i);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_status, RAY_CCS_STATUS_BUSY);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_cmd, cmd);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_link, RAY_CCS_LINK_NULL);\n\n\t*ccsp = ccs;\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ray_cmd_schedule",
          "args": [
            "sc",
            "SCP_UPD_PROMISC"
          ],
          "line": 2859
        },
        "resolved": true,
        "details": {
          "function_name": "ray_cmd_schedule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2248-2265",
          "snippet": "void\nray_cmd_schedule(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tint track;\n\n\tRAY_DPRINTF((\"%s: ray_cmd_schedule 0x%x\\n\", sc->sc_xname, cmdf));\n\n\ttrack = cmdf;\n\tif ((cmdf & SCP_UPD_MASK) == 0)\n\t\tray_set_pending(sc, track);\n\telse if (ray_cmd_is_running(sc, SCP_UPDATESUBCMD)) {\n\t\t/* don't do timeout mechaniscm if subcmd already going */\n\t\tsc->sc_scheduled |= cmdf;\n\t} else\n\t\tray_set_pending(sc, cmdf | SCP_UPDATESUBCMD);\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tSCP_UPD_MASK\t\t0xff00",
            "#define\tSCP_UPDATESUBCMD\t0x0001",
            "#define\tsc_xname\tsc_dev.dv_xname"
          ],
          "globals_used": [
            "void ray_cmd_schedule",
            "int ray_cmd_is_running",
            "void ray_set_pending"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSCP_UPD_MASK\t\t0xff00\n#define\tSCP_UPDATESUBCMD\t0x0001\n#define\tsc_xname\tsc_dev.dv_xname\n\nvoid ray_cmd_schedule;\nint ray_cmd_is_running;\nvoid ray_set_pending;\n\nvoid\nray_cmd_schedule(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tint track;\n\n\tRAY_DPRINTF((\"%s: ray_cmd_schedule 0x%x\\n\", sc->sc_xname, cmdf));\n\n\ttrack = cmdf;\n\tif ((cmdf & SCP_UPD_MASK) == 0)\n\t\tray_set_pending(sc, track);\n\telse if (ray_cmd_is_running(sc, SCP_UPDATESUBCMD)) {\n\t\t/* don't do timeout mechaniscm if subcmd already going */\n\t\tsc->sc_scheduled |= cmdf;\n\t} else\n\t\tray_set_pending(sc, cmdf | SCP_UPDATESUBCMD);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ray_cmd_is_running",
          "args": [
            "sc",
            "SCP_UPDATESUBCMD"
          ],
          "line": 2858
        },
        "resolved": true,
        "details": {
          "function_name": "ray_cmd_is_running",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2326-2334",
          "snippet": "int\nray_cmd_is_running(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_cmd_is_running 0x%x\\n\", sc->sc_xname, cmdf));\n\n\treturn ((sc->sc_running & cmdf) ? 1 : 0);\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tsc_xname\tsc_dev.dv_xname"
          ],
          "globals_used": [
            "int ray_cmd_is_running"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_xname\tsc_dev.dv_xname\n\nint ray_cmd_is_running;\n\nint\nray_cmd_is_running(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_cmd_is_running 0x%x\\n\", sc->sc_xname, cmdf));\n\n\treturn ((sc->sc_running & cmdf) ? 1 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ray_cmd_cancel",
          "args": [
            "sc",
            "SCP_UPD_PROMISC"
          ],
          "line": 2852
        },
        "resolved": true,
        "details": {
          "function_name": "ray_cmd_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2283-2299",
          "snippet": "void\nray_cmd_cancel(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_cmd_cancel 0x%x\\n\", sc->sc_xname, cmdf));\n\n\tsc->sc_scheduled &= ~cmdf;\n\tif ((cmdf & SCP_UPD_MASK) && (sc->sc_scheduled & SCP_UPD_MASK) == 0)\n\t\tsc->sc_scheduled &= ~SCP_UPDATESUBCMD;\n\n\t/* if nothing else needed cancel the timer */\n\tif (sc->sc_scheduled == 0 && sc->sc_timoneed) {\n\t\tcallout_stop(&sc->sc_check_scheduled_ch);\n\t\tsc->sc_timoneed = 0;\n\t}\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tSCP_UPD_MASK\t\t0xff00",
            "#define\tSCP_UPDATESUBCMD\t0x0001",
            "#define\tsc_xname\tsc_dev.dv_xname",
            "#define\tcallout_stop\ttimeout_del"
          ],
          "globals_used": [
            "void ray_cmd_cancel"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSCP_UPD_MASK\t\t0xff00\n#define\tSCP_UPDATESUBCMD\t0x0001\n#define\tsc_xname\tsc_dev.dv_xname\n#define\tcallout_stop\ttimeout_del\n\nvoid ray_cmd_cancel;\n\nvoid\nray_cmd_cancel(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_cmd_cancel 0x%x\\n\", sc->sc_xname, cmdf));\n\n\tsc->sc_scheduled &= ~cmdf;\n\tif ((cmdf & SCP_UPD_MASK) && (sc->sc_scheduled & SCP_UPD_MASK) == 0)\n\t\tsc->sc_scheduled &= ~SCP_UPDATESUBCMD;\n\n\t/* if nothing else needed cancel the timer */\n\tif (sc->sc_scheduled == 0 && sc->sc_timoneed) {\n\t\tcallout_stop(&sc->sc_check_scheduled_ch);\n\t\tsc->sc_timoneed = 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSCP_UPD_PROMISC\t\t0x0400\n#define\tSCP_UPDATESUBCMD\t0x0001\n#define\tsc_if\t\tsc_ec.ac_if\n#define\tsc_if\t\tsc_ec.ec_if\n\nint ray_alloc_ccs;\nvoid ray_cmd_cancel;\nvoid ray_cmd_schedule;\nint ray_cmd_is_running;\nint ray_issue_cmd;\nvoid ray_update_promisc;\n\nvoid\nray_update_promisc(sc)\n\tstruct ray_softc *sc;\n{\n\tbus_size_t ccs;\n\tint promisc;\n\n\tray_cmd_cancel(sc, SCP_UPD_PROMISC);\n\n\t/* do the issue check before equality check */\n\tpromisc = !!(sc->sc_if.if_flags & (IFF_PROMISC | IFF_ALLMULTI));\n\tif ((sc->sc_if.if_flags & IFF_RUNNING) == 0)\n\t\treturn;\n\telse if (ray_cmd_is_running(sc, SCP_UPDATESUBCMD)) {\n\t\tray_cmd_schedule(sc, SCP_UPD_PROMISC);\n\t\treturn;\n\t} else if (promisc == sc->sc_promisc)\n\t\treturn;\n\telse if (!ray_alloc_ccs(sc,&ccs,RAY_CMD_UPDATE_PARAMS, SCP_UPD_PROMISC))\n\t\treturn;\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_update, c_paramid, RAY_PID_PROMISC);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_update, c_nparam, 1);\n\tSRAM_WRITE_1(sc, RAY_HOST_TO_ECF_BASE, promisc);\n\t(void)ray_issue_cmd(sc, ccs, SCP_UPD_PROMISC);\n}"
  },
  {
    "function_name": "ray_start_join_net_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
    "lines": "2754-2840",
    "snippet": "ray_cmd_func_t\nray_start_join_net_done(sc, cmd, ccs, stat)\n\tstruct ray_softc *sc;\n\tu_int cmd;\n\tbus_size_t ccs;\n\tu_int stat;\n{\n\tstruct ray_net_params np;\n\n\tcallout_stop(&sc->sc_start_join_timo_ch);\n\tray_cmd_done(sc, SCP_UPD_STARTJOIN);\n\n\tif (stat == RAY_CCS_STATUS_FAIL) {\n\t\t/* XXX poke ifmedia when it supports this */\n\t\tsc->sc_havenet = 0;\n\t\treturn (ray_start_join_net);\n\t}\n\tif (stat == RAY_CCS_STATUS_BUSY || stat == RAY_CCS_STATUS_FREE) {\n\t\t/* handle the timeout condition */\n\t\tcallout_reset(&sc->sc_start_join_timo_ch, RAY_START_TIMEOUT,\n\t\t    ray_start_join_timo, sc);\n\n\t\t/* be safe -- not a lot occurs with no net though */\n\t\tif (!RAY_ECF_READY(sc))\n\t\t\treturn (0);\n\n\t\t/* see if our nwid is up to date */\n\t\tif (!memcmp(sc->sc_cnwid, sc->sc_dnwid, sizeof(sc->sc_cnwid))\n\t\t    && sc->sc_omode == sc->sc_mode)\n\t\t\tSRAM_WRITE_FIELD_1(sc,ccs, ray_cmd_net, c_upd_param, 0);\n\t\telse {\n\t\t\tmemset(&np, 0, sizeof(np));\n\t\t\tnp.p_net_type = sc->sc_mode;\n\t\t\tmemcpy(np.p_ssid, sc->sc_dnwid, sizeof(np.p_ssid));\n\t\t\tray_write_region(sc, RAY_HOST_TO_ECF_BASE, &np,\n\t\t\t    sizeof(np));\n\t\t\tSRAM_WRITE_FIELD_1(sc,ccs, ray_cmd_net, c_upd_param, 1);\n\t\t}\n\n\t\tif (sc->sc_mode == SC_MODE_ADHOC)\n\t\t\tcmd = RAY_CMD_START_NET;\n\t\telse\n\t\t\tcmd = RAY_CMD_JOIN_NET;\n\t\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_net, c_cmd,\n\t\t    RAY_CCS_STATUS_BUSY);\n\t\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_net, c_status,\n\t\t    RAY_CCS_STATUS_BUSY);\n\n\t\t/* we simply poke the card again issuing the same ccs */\n\t\tSRAM_WRITE_1(sc, RAY_SCB_CCSI, RAY_GET_INDEX(ccs));\n\t\tRAY_ECF_START_CMD(sc);\n\t\tray_cmd_ran(sc, SCP_UPD_STARTJOIN);\n\t\treturn (0);\n\t}\n\t/* get the current ssid */\n\tSRAM_READ_FIELD_N(sc, ccs, ray_cmd_net, c_bss_id, sc->sc_bssid,\n\t    sizeof(sc->sc_bssid));\n\n\tsc->sc_deftxrate = SRAM_READ_FIELD_1(sc, ccs, ray_cmd_net,c_def_txrate);\n\tsc->sc_encrypt = SRAM_READ_FIELD_1(sc, ccs, ray_cmd_net, c_encrypt);\n\n\t/* adjust values for buggy build 4 */\n\tif (sc->sc_deftxrate == 0x55)\n\t\tsc->sc_deftxrate = RAY_PID_BASIC_RATE_1500K;\n\tif (sc->sc_encrypt == 0x55)\n\t\tsc->sc_encrypt = 0;\n\n\tif (SRAM_READ_FIELD_1(sc, ccs, ray_cmd_net, c_upd_param)) {\n\t\tray_read_region(sc, RAY_HOST_TO_ECF_BASE, &np, sizeof(np));\n\t\tmemcpy(sc->sc_cnwid, np.p_ssid, sizeof(sc->sc_cnwid));\n\t\tsc->sc_omode = sc->sc_mode;\n\t\tif (np.p_net_type != sc->sc_mode)\n\t\t\treturn (ray_start_join_net);\n\t}\n\tRAY_DPRINTF((\"%s: net start/join nwid %.32s bssid %s inited %d\\n\",\n\t    sc->sc_xname, sc->sc_cnwid, ether_sprintf(sc->sc_bssid),\n\t\tSRAM_READ_FIELD_1(sc, ccs, ray_cmd_net, c_inited)));\n\n\t/* network is now active */\n\tray_cmd_schedule(sc, SCP_UPD_MCAST|SCP_UPD_PROMISC);\n\tif (cmd == RAY_CMD_JOIN_NET)\n\t\treturn (ray_start_assoc);\n\telse {\n\t\tsc->sc_havenet = 1;\n\t\treturn (ray_intr_start);\n\t}\n}",
    "includes": [
      "#include <dev/pcmcia/if_rayreg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_llc.h>",
      "#include <net/if_media.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/timeout.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [
      "#define\tSCP_UPD_MCAST\t\t0x0800",
      "#define\tSCP_UPD_PROMISC\t\t0x0400",
      "#define\tSCP_UPD_STARTJOIN\t0x0200",
      "#define\tSC_MODE_ADHOC\t0\t/* ad-hoc mode */",
      "#define\tsc_xname\tsc_dev.dv_xname",
      "#define\tcallout_stop\ttimeout_del",
      "#define\tRAY_START_TIMEOUT\t(10 * hz)"
    ],
    "globals_used": [
      "void ray_cmd_schedule",
      "void ray_cmd_ran",
      "void ray_cmd_done",
      "void ray_intr_start",
      "void ray_start_assoc",
      "void ray_start_join_net",
      "ray_cmd_func_t ray_start_join_net_done",
      "void ray_start_join_timo"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ray_cmd_schedule",
          "args": [
            "sc",
            "SCP_UPD_MCAST|SCP_UPD_PROMISC"
          ],
          "line": 2833
        },
        "resolved": true,
        "details": {
          "function_name": "ray_cmd_schedule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2248-2265",
          "snippet": "void\nray_cmd_schedule(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tint track;\n\n\tRAY_DPRINTF((\"%s: ray_cmd_schedule 0x%x\\n\", sc->sc_xname, cmdf));\n\n\ttrack = cmdf;\n\tif ((cmdf & SCP_UPD_MASK) == 0)\n\t\tray_set_pending(sc, track);\n\telse if (ray_cmd_is_running(sc, SCP_UPDATESUBCMD)) {\n\t\t/* don't do timeout mechaniscm if subcmd already going */\n\t\tsc->sc_scheduled |= cmdf;\n\t} else\n\t\tray_set_pending(sc, cmdf | SCP_UPDATESUBCMD);\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tSCP_UPD_MASK\t\t0xff00",
            "#define\tSCP_UPDATESUBCMD\t0x0001",
            "#define\tsc_xname\tsc_dev.dv_xname"
          ],
          "globals_used": [
            "void ray_cmd_schedule",
            "int ray_cmd_is_running",
            "void ray_set_pending"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSCP_UPD_MASK\t\t0xff00\n#define\tSCP_UPDATESUBCMD\t0x0001\n#define\tsc_xname\tsc_dev.dv_xname\n\nvoid ray_cmd_schedule;\nint ray_cmd_is_running;\nvoid ray_set_pending;\n\nvoid\nray_cmd_schedule(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tint track;\n\n\tRAY_DPRINTF((\"%s: ray_cmd_schedule 0x%x\\n\", sc->sc_xname, cmdf));\n\n\ttrack = cmdf;\n\tif ((cmdf & SCP_UPD_MASK) == 0)\n\t\tray_set_pending(sc, track);\n\telse if (ray_cmd_is_running(sc, SCP_UPDATESUBCMD)) {\n\t\t/* don't do timeout mechaniscm if subcmd already going */\n\t\tsc->sc_scheduled |= cmdf;\n\t} else\n\t\tray_set_pending(sc, cmdf | SCP_UPDATESUBCMD);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: net start/join nwid %.32s bssid %s inited %d\\n\",\n\t    sc->sc_xname, sc->sc_cnwid, ether_sprintf(sc->sc_bssid),\n\t\tSRAM_READ_FIELD_1(sc, ccs, ray_cmd_net, c_inited))"
          ],
          "line": 2828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRAM_READ_FIELD_1",
          "args": [
            "sc",
            "ccs",
            "ray_cmd_net",
            "c_inited"
          ],
          "line": 2830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_sprintf",
          "args": [
            "sc->sc_bssid"
          ],
          "line": 2829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sc->sc_cnwid",
            "np.p_ssid",
            "sizeof(sc->sc_cnwid)"
          ],
          "line": 2823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ray_read_region",
          "args": [
            "sc",
            "RAY_HOST_TO_ECF_BASE",
            "&np",
            "sizeof(np)"
          ],
          "line": 2822
        },
        "resolved": true,
        "details": {
          "function_name": "ray_read_region",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "3063-3116",
          "snippet": "void\nray_read_region(sc, off, vp, c)\n\tstruct ray_softc *sc;\n\tbus_size_t off;\n\tvoid *vp;\n\tsize_t c;\n{\n#ifdef RAY_USE_OPTIMIZED_COPY\n\tu_int n2, n4, tmp;\n\tu_int8_t *p;\n\n\tp = vp;\n\n\t/* XXX we may be making poor assumptions here but lets hope */\n\tswitch ((off|(bus_addr_t)p) & 0x03) {\n\tcase 0:\n\t\tif ((n4 = c / 4)) {\n\t\t\tbus_space_read_region_4(sc->sc_memt, sc->sc_memh, off,\n\t\t\t    p, n4);\n\t\t\ttmp = c & ~0x3;\n\t\t\tc &= 0x3;\n\t\t\tp += tmp;\n\t\t\toff += tmp;\n\t\t}\n\t\tswitch (c) {\n\t\tcase 3:\n\t\t\t*p = bus_space_read_1(sc->sc_memt,sc->sc_memh, off);\n\t\t\tp++, off++;\n\t\tcase 2:\n\t\t\t*p = bus_space_read_1(sc->sc_memt,sc->sc_memh, off);\n\t\t\tp++, off++;\n\t\tcase 1:\n\t\t\t*p = bus_space_read_1(sc->sc_memt,sc->sc_memh, off);\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tif ((n2 = (c >> 1)))\n\t\t\tbus_space_read_region_2(sc->sc_memt, sc->sc_memh, off,\n\t\t\t    p, n2);\n\t\tif (c & 1) {\n\t\t\tc &= ~0x1;\n\t\t\t*(p + c) = bus_space_read_1(sc->sc_memt, sc->sc_memh,\n\t\t\t    off + c);\n\t\t}\n\t\tbreak;\n\tcase 1:\n\tcase 3:\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_memh, off, p, c);\n\t\tbreak;\n\t}\n#else\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_memh, off, vp, c);\n#endif\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tsc_memh\tsc_mem.memh",
            "#define\tsc_memt\tsc_mem.memt"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_memh\tsc_mem.memh\n#define\tsc_memt\tsc_mem.memt\n\nvoid\nray_read_region(sc, off, vp, c)\n\tstruct ray_softc *sc;\n\tbus_size_t off;\n\tvoid *vp;\n\tsize_t c;\n{\n#ifdef RAY_USE_OPTIMIZED_COPY\n\tu_int n2, n4, tmp;\n\tu_int8_t *p;\n\n\tp = vp;\n\n\t/* XXX we may be making poor assumptions here but lets hope */\n\tswitch ((off|(bus_addr_t)p) & 0x03) {\n\tcase 0:\n\t\tif ((n4 = c / 4)) {\n\t\t\tbus_space_read_region_4(sc->sc_memt, sc->sc_memh, off,\n\t\t\t    p, n4);\n\t\t\ttmp = c & ~0x3;\n\t\t\tc &= 0x3;\n\t\t\tp += tmp;\n\t\t\toff += tmp;\n\t\t}\n\t\tswitch (c) {\n\t\tcase 3:\n\t\t\t*p = bus_space_read_1(sc->sc_memt,sc->sc_memh, off);\n\t\t\tp++, off++;\n\t\tcase 2:\n\t\t\t*p = bus_space_read_1(sc->sc_memt,sc->sc_memh, off);\n\t\t\tp++, off++;\n\t\tcase 1:\n\t\t\t*p = bus_space_read_1(sc->sc_memt,sc->sc_memh, off);\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tif ((n2 = (c >> 1)))\n\t\t\tbus_space_read_region_2(sc->sc_memt, sc->sc_memh, off,\n\t\t\t    p, n2);\n\t\tif (c & 1) {\n\t\t\tc &= ~0x1;\n\t\t\t*(p + c) = bus_space_read_1(sc->sc_memt, sc->sc_memh,\n\t\t\t    off + c);\n\t\t}\n\t\tbreak;\n\tcase 1:\n\tcase 3:\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_memh, off, p, c);\n\t\tbreak;\n\t}\n#else\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_memh, off, vp, c);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "SRAM_READ_FIELD_1",
          "args": [
            "sc",
            "ccs",
            "ray_cmd_net",
            "c_upd_param"
          ],
          "line": 2821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRAM_READ_FIELD_1",
          "args": [
            "sc",
            "ccs",
            "ray_cmd_net",
            "c_encrypt"
          ],
          "line": 2813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRAM_READ_FIELD_1",
          "args": [
            "sc",
            "ccs",
            "ray_cmd_net",
            "c_def_txrate"
          ],
          "line": 2812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRAM_READ_FIELD_N",
          "args": [
            "sc",
            "ccs",
            "ray_cmd_net",
            "c_bss_id",
            "sc->sc_bssid",
            "sizeof(sc->sc_bssid)"
          ],
          "line": 2809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ray_cmd_ran",
          "args": [
            "sc",
            "SCP_UPD_STARTJOIN"
          ],
          "line": 2805
        },
        "resolved": true,
        "details": {
          "function_name": "ray_cmd_ran",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2304-2321",
          "snippet": "void\nray_cmd_ran(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_cmd_ran 0x%x\\n\", sc->sc_xname, cmdf));\n\n\tif (cmdf & SCP_UPD_MASK)\n\t\tsc->sc_running |= cmdf | SCP_UPDATESUBCMD;\n\telse\n\t\tsc->sc_running |= cmdf;\n\n\tif ((cmdf & SCP_TIMOCHECK_CMD_MASK) && !sc->sc_timocheck) {\n\t\tcallout_reset(&sc->sc_check_ccs_ch, RAY_CHECK_CCS_TIMEOUT,\n\t\t    ray_check_ccs, sc);\n\t\tsc->sc_timocheck = 1;\n\t}\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tSCP_TIMOCHECK_CMD_MASK\t\\\n\t(SCP_UPD_UPDATEPARAMS | SCP_UPD_STARTUP | SCP_UPD_MCAST | \\\n\tSCP_UPD_PROMISC)",
            "#define\tSCP_UPD_MASK\t\t0xff00",
            "#define\tSCP_UPDATESUBCMD\t0x0001",
            "#define\tsc_xname\tsc_dev.dv_xname",
            "#define\tRAY_CHECK_CCS_TIMEOUT\t(hz / 2)"
          ],
          "globals_used": [
            "void ray_check_ccs",
            "void ray_cmd_ran"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSCP_TIMOCHECK_CMD_MASK\t\\\n\t(SCP_UPD_UPDATEPARAMS | SCP_UPD_STARTUP | SCP_UPD_MCAST | \\\n\tSCP_UPD_PROMISC)\n#define\tSCP_UPD_MASK\t\t0xff00\n#define\tSCP_UPDATESUBCMD\t0x0001\n#define\tsc_xname\tsc_dev.dv_xname\n#define\tRAY_CHECK_CCS_TIMEOUT\t(hz / 2)\n\nvoid ray_check_ccs;\nvoid ray_cmd_ran;\n\nvoid\nray_cmd_ran(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_cmd_ran 0x%x\\n\", sc->sc_xname, cmdf));\n\n\tif (cmdf & SCP_UPD_MASK)\n\t\tsc->sc_running |= cmdf | SCP_UPDATESUBCMD;\n\telse\n\t\tsc->sc_running |= cmdf;\n\n\tif ((cmdf & SCP_TIMOCHECK_CMD_MASK) && !sc->sc_timocheck) {\n\t\tcallout_reset(&sc->sc_check_ccs_ch, RAY_CHECK_CCS_TIMEOUT,\n\t\t    ray_check_ccs, sc);\n\t\tsc->sc_timocheck = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RAY_ECF_START_CMD",
          "args": [
            "sc"
          ],
          "line": 2804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRAM_WRITE_1",
          "args": [
            "sc",
            "RAY_SCB_CCSI",
            "RAY_GET_INDEX(ccs)"
          ],
          "line": 2803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_GET_INDEX",
          "args": [
            "ccs"
          ],
          "line": 2803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRAM_WRITE_FIELD_1",
          "args": [
            "sc",
            "ccs",
            "ray_cmd_net",
            "c_status",
            "RAY_CCS_STATUS_BUSY"
          ],
          "line": 2799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRAM_WRITE_FIELD_1",
          "args": [
            "sc",
            "ccs",
            "ray_cmd_net",
            "c_cmd",
            "RAY_CCS_STATUS_BUSY"
          ],
          "line": 2797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRAM_WRITE_FIELD_1",
          "args": [
            "sc",
            "ccs",
            "ray_cmd_net",
            "c_upd_param",
            "1"
          ],
          "line": 2790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ray_write_region",
          "args": [
            "sc",
            "RAY_HOST_TO_ECF_BASE",
            "&np",
            "sizeof(np)"
          ],
          "line": 2788
        },
        "resolved": true,
        "details": {
          "function_name": "ray_write_region",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "3125-3177",
          "snippet": "void\nray_write_region(sc, off, vp, c)\n\tstruct ray_softc *sc;\n\tbus_size_t off;\n\tvoid *vp;\n\tsize_t c;\n{\n#ifdef RAY_USE_OPTIMIZED_COPY\n\tsize_t n2, n4, tmp;\n\tu_int8_t *p;\n\n\tp = vp;\n\t/* XXX we may be making poor assumptions here but lets hope */\n\tswitch ((off|(bus_addr_t)p) & 0x03) {\n\tcase 0:\n\t\tif ((n4 = (c >> 2))) {\n\t\t\tbus_space_write_region_4(sc->sc_memt, sc->sc_memh, off,\n\t\t\t    p, n4);\n\t\t\ttmp = c & ~0x3;\n\t\t\tc &= 0x3;\n\t\t\tp += tmp;\n\t\t\toff += tmp;\n\t\t}\n\t\tswitch (c) {\n\t\tcase 3:\n\t\t\tbus_space_write_1(sc->sc_memt,sc->sc_memh, off, *p);\n\t\t\tp++, off++;\n\t\tcase 2:\n\t\t\tbus_space_write_1(sc->sc_memt,sc->sc_memh, off, *p);\n\t\t\tp++, off++;\n\t\tcase 1:\n\t\t\tbus_space_write_1(sc->sc_memt,sc->sc_memh, off, *p);\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tif ((n2 = (c >> 1)))\n\t\t\tbus_space_write_region_2(sc->sc_memt, sc->sc_memh, off,\n\t\t\t    p, n2);\n\t\tif (c & 0x1) {\n\t\t\tc &= ~0x1;\n\t\t\tbus_space_write_1(sc->sc_memt, sc->sc_memh,\n\t\t\t    off + c, *(p + c));\n\t\t}\n\t\tbreak;\n\tcase 1:\n\tcase 3:\n\t\tbus_space_write_region_1(sc->sc_memt, sc->sc_memh, off, p, c);\n\t\tbreak;\n\t}\n#else\n\tbus_space_write_region_1(sc->sc_memt, sc->sc_memh, off, vp, c);\n#endif\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tsc_memh\tsc_mem.memh",
            "#define\tsc_memt\tsc_mem.memt"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_memh\tsc_mem.memh\n#define\tsc_memt\tsc_mem.memt\n\nvoid\nray_write_region(sc, off, vp, c)\n\tstruct ray_softc *sc;\n\tbus_size_t off;\n\tvoid *vp;\n\tsize_t c;\n{\n#ifdef RAY_USE_OPTIMIZED_COPY\n\tsize_t n2, n4, tmp;\n\tu_int8_t *p;\n\n\tp = vp;\n\t/* XXX we may be making poor assumptions here but lets hope */\n\tswitch ((off|(bus_addr_t)p) & 0x03) {\n\tcase 0:\n\t\tif ((n4 = (c >> 2))) {\n\t\t\tbus_space_write_region_4(sc->sc_memt, sc->sc_memh, off,\n\t\t\t    p, n4);\n\t\t\ttmp = c & ~0x3;\n\t\t\tc &= 0x3;\n\t\t\tp += tmp;\n\t\t\toff += tmp;\n\t\t}\n\t\tswitch (c) {\n\t\tcase 3:\n\t\t\tbus_space_write_1(sc->sc_memt,sc->sc_memh, off, *p);\n\t\t\tp++, off++;\n\t\tcase 2:\n\t\t\tbus_space_write_1(sc->sc_memt,sc->sc_memh, off, *p);\n\t\t\tp++, off++;\n\t\tcase 1:\n\t\t\tbus_space_write_1(sc->sc_memt,sc->sc_memh, off, *p);\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tif ((n2 = (c >> 1)))\n\t\t\tbus_space_write_region_2(sc->sc_memt, sc->sc_memh, off,\n\t\t\t    p, n2);\n\t\tif (c & 0x1) {\n\t\t\tc &= ~0x1;\n\t\t\tbus_space_write_1(sc->sc_memt, sc->sc_memh,\n\t\t\t    off + c, *(p + c));\n\t\t}\n\t\tbreak;\n\tcase 1:\n\tcase 3:\n\t\tbus_space_write_region_1(sc->sc_memt, sc->sc_memh, off, p, c);\n\t\tbreak;\n\t}\n#else\n\tbus_space_write_region_1(sc->sc_memt, sc->sc_memh, off, vp, c);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "np.p_ssid",
            "sc->sc_dnwid",
            "sizeof(np.p_ssid)"
          ],
          "line": 2787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&np",
            "0",
            "sizeof(np)"
          ],
          "line": 2785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRAM_WRITE_FIELD_1",
          "args": [
            "sc",
            "ccs",
            "ray_cmd_net",
            "c_upd_param",
            "0"
          ],
          "line": 2783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "sc->sc_cnwid",
            "sc->sc_dnwid",
            "sizeof(sc->sc_cnwid)"
          ],
          "line": 2781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_ECF_READY",
          "args": [
            "sc"
          ],
          "line": 2777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "callout_reset",
          "args": [
            "&sc->sc_start_join_timo_ch",
            "RAY_START_TIMEOUT",
            "ray_start_join_timo",
            "sc"
          ],
          "line": 2773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ray_cmd_done",
          "args": [
            "sc",
            "SCP_UPD_STARTJOIN"
          ],
          "line": 2764
        },
        "resolved": true,
        "details": {
          "function_name": "ray_cmd_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2339-2356",
          "snippet": "void\nray_cmd_done(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_cmd_done 0x%x\\n\", sc->sc_xname, cmdf));\n\n\tsc->sc_running &= ~cmdf;\n\tif (cmdf & SCP_UPD_MASK) {\n\t\tsc->sc_running &= ~SCP_UPDATESUBCMD;\n\t\tif (sc->sc_scheduled & SCP_UPD_MASK)\n\t\t\tray_cmd_schedule(sc, sc->sc_scheduled & SCP_UPD_MASK);\n\t}\n\tif ((sc->sc_running & SCP_TIMOCHECK_CMD_MASK) == 0 && sc->sc_timocheck){\n\t\tcallout_stop(&sc->sc_check_ccs_ch);\n\t\tsc->sc_timocheck = 0;\n\t}\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tSCP_TIMOCHECK_CMD_MASK\t\\\n\t(SCP_UPD_UPDATEPARAMS | SCP_UPD_STARTUP | SCP_UPD_MCAST | \\\n\tSCP_UPD_PROMISC)",
            "#define\tSCP_UPD_MASK\t\t0xff00",
            "#define\tSCP_UPDATESUBCMD\t0x0001",
            "#define\tsc_xname\tsc_dev.dv_xname",
            "#define\tcallout_stop\ttimeout_del"
          ],
          "globals_used": [
            "void ray_cmd_schedule",
            "void ray_cmd_done"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSCP_TIMOCHECK_CMD_MASK\t\\\n\t(SCP_UPD_UPDATEPARAMS | SCP_UPD_STARTUP | SCP_UPD_MCAST | \\\n\tSCP_UPD_PROMISC)\n#define\tSCP_UPD_MASK\t\t0xff00\n#define\tSCP_UPDATESUBCMD\t0x0001\n#define\tsc_xname\tsc_dev.dv_xname\n#define\tcallout_stop\ttimeout_del\n\nvoid ray_cmd_schedule;\nvoid ray_cmd_done;\n\nvoid\nray_cmd_done(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_cmd_done 0x%x\\n\", sc->sc_xname, cmdf));\n\n\tsc->sc_running &= ~cmdf;\n\tif (cmdf & SCP_UPD_MASK) {\n\t\tsc->sc_running &= ~SCP_UPDATESUBCMD;\n\t\tif (sc->sc_scheduled & SCP_UPD_MASK)\n\t\t\tray_cmd_schedule(sc, sc->sc_scheduled & SCP_UPD_MASK);\n\t}\n\tif ((sc->sc_running & SCP_TIMOCHECK_CMD_MASK) == 0 && sc->sc_timocheck){\n\t\tcallout_stop(&sc->sc_check_ccs_ch);\n\t\tsc->sc_timocheck = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "callout_stop",
          "args": [
            "&sc->sc_start_join_timo_ch"
          ],
          "line": 2763
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSCP_UPD_MCAST\t\t0x0800\n#define\tSCP_UPD_PROMISC\t\t0x0400\n#define\tSCP_UPD_STARTJOIN\t0x0200\n#define\tSC_MODE_ADHOC\t0\t/* ad-hoc mode */\n#define\tsc_xname\tsc_dev.dv_xname\n#define\tcallout_stop\ttimeout_del\n#define\tRAY_START_TIMEOUT\t(10 * hz)\n\nvoid ray_cmd_schedule;\nvoid ray_cmd_ran;\nvoid ray_cmd_done;\nvoid ray_intr_start;\nvoid ray_start_assoc;\nvoid ray_start_join_net;\nray_cmd_func_t ray_start_join_net_done;\nvoid ray_start_join_timo;\n\nray_cmd_func_t\nray_start_join_net_done(sc, cmd, ccs, stat)\n\tstruct ray_softc *sc;\n\tu_int cmd;\n\tbus_size_t ccs;\n\tu_int stat;\n{\n\tstruct ray_net_params np;\n\n\tcallout_stop(&sc->sc_start_join_timo_ch);\n\tray_cmd_done(sc, SCP_UPD_STARTJOIN);\n\n\tif (stat == RAY_CCS_STATUS_FAIL) {\n\t\t/* XXX poke ifmedia when it supports this */\n\t\tsc->sc_havenet = 0;\n\t\treturn (ray_start_join_net);\n\t}\n\tif (stat == RAY_CCS_STATUS_BUSY || stat == RAY_CCS_STATUS_FREE) {\n\t\t/* handle the timeout condition */\n\t\tcallout_reset(&sc->sc_start_join_timo_ch, RAY_START_TIMEOUT,\n\t\t    ray_start_join_timo, sc);\n\n\t\t/* be safe -- not a lot occurs with no net though */\n\t\tif (!RAY_ECF_READY(sc))\n\t\t\treturn (0);\n\n\t\t/* see if our nwid is up to date */\n\t\tif (!memcmp(sc->sc_cnwid, sc->sc_dnwid, sizeof(sc->sc_cnwid))\n\t\t    && sc->sc_omode == sc->sc_mode)\n\t\t\tSRAM_WRITE_FIELD_1(sc,ccs, ray_cmd_net, c_upd_param, 0);\n\t\telse {\n\t\t\tmemset(&np, 0, sizeof(np));\n\t\t\tnp.p_net_type = sc->sc_mode;\n\t\t\tmemcpy(np.p_ssid, sc->sc_dnwid, sizeof(np.p_ssid));\n\t\t\tray_write_region(sc, RAY_HOST_TO_ECF_BASE, &np,\n\t\t\t    sizeof(np));\n\t\t\tSRAM_WRITE_FIELD_1(sc,ccs, ray_cmd_net, c_upd_param, 1);\n\t\t}\n\n\t\tif (sc->sc_mode == SC_MODE_ADHOC)\n\t\t\tcmd = RAY_CMD_START_NET;\n\t\telse\n\t\t\tcmd = RAY_CMD_JOIN_NET;\n\t\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_net, c_cmd,\n\t\t    RAY_CCS_STATUS_BUSY);\n\t\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_net, c_status,\n\t\t    RAY_CCS_STATUS_BUSY);\n\n\t\t/* we simply poke the card again issuing the same ccs */\n\t\tSRAM_WRITE_1(sc, RAY_SCB_CCSI, RAY_GET_INDEX(ccs));\n\t\tRAY_ECF_START_CMD(sc);\n\t\tray_cmd_ran(sc, SCP_UPD_STARTJOIN);\n\t\treturn (0);\n\t}\n\t/* get the current ssid */\n\tSRAM_READ_FIELD_N(sc, ccs, ray_cmd_net, c_bss_id, sc->sc_bssid,\n\t    sizeof(sc->sc_bssid));\n\n\tsc->sc_deftxrate = SRAM_READ_FIELD_1(sc, ccs, ray_cmd_net,c_def_txrate);\n\tsc->sc_encrypt = SRAM_READ_FIELD_1(sc, ccs, ray_cmd_net, c_encrypt);\n\n\t/* adjust values for buggy build 4 */\n\tif (sc->sc_deftxrate == 0x55)\n\t\tsc->sc_deftxrate = RAY_PID_BASIC_RATE_1500K;\n\tif (sc->sc_encrypt == 0x55)\n\t\tsc->sc_encrypt = 0;\n\n\tif (SRAM_READ_FIELD_1(sc, ccs, ray_cmd_net, c_upd_param)) {\n\t\tray_read_region(sc, RAY_HOST_TO_ECF_BASE, &np, sizeof(np));\n\t\tmemcpy(sc->sc_cnwid, np.p_ssid, sizeof(sc->sc_cnwid));\n\t\tsc->sc_omode = sc->sc_mode;\n\t\tif (np.p_net_type != sc->sc_mode)\n\t\t\treturn (ray_start_join_net);\n\t}\n\tRAY_DPRINTF((\"%s: net start/join nwid %.32s bssid %s inited %d\\n\",\n\t    sc->sc_xname, sc->sc_cnwid, ether_sprintf(sc->sc_bssid),\n\t\tSRAM_READ_FIELD_1(sc, ccs, ray_cmd_net, c_inited)));\n\n\t/* network is now active */\n\tray_cmd_schedule(sc, SCP_UPD_MCAST|SCP_UPD_PROMISC);\n\tif (cmd == RAY_CMD_JOIN_NET)\n\t\treturn (ray_start_assoc);\n\telse {\n\t\tsc->sc_havenet = 1;\n\t\treturn (ray_intr_start);\n\t}\n}"
  },
  {
    "function_name": "ray_start_join_timo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
    "lines": "2734-2744",
    "snippet": "void\nray_start_join_timo(arg)\n\tvoid *arg;\n{\n\tstruct ray_softc *sc;\n\tu_int stat;\n\n\tsc = arg;\n\tstat = SRAM_READ_FIELD_1(sc, sc->sc_startccs, ray_cmd, c_status);\n\tray_start_join_net_done(sc, sc->sc_startcmd, sc->sc_startccs, stat);\n}",
    "includes": [
      "#include <dev/pcmcia/if_rayreg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_llc.h>",
      "#include <net/if_media.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/timeout.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "ray_cmd_func_t ray_start_join_net_done",
      "void ray_start_join_timo"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ray_start_join_net_done",
          "args": [
            "sc",
            "sc->sc_startcmd",
            "sc->sc_startccs",
            "stat"
          ],
          "line": 2743
        },
        "resolved": true,
        "details": {
          "function_name": "ray_start_join_net_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2754-2840",
          "snippet": "ray_cmd_func_t\nray_start_join_net_done(sc, cmd, ccs, stat)\n\tstruct ray_softc *sc;\n\tu_int cmd;\n\tbus_size_t ccs;\n\tu_int stat;\n{\n\tstruct ray_net_params np;\n\n\tcallout_stop(&sc->sc_start_join_timo_ch);\n\tray_cmd_done(sc, SCP_UPD_STARTJOIN);\n\n\tif (stat == RAY_CCS_STATUS_FAIL) {\n\t\t/* XXX poke ifmedia when it supports this */\n\t\tsc->sc_havenet = 0;\n\t\treturn (ray_start_join_net);\n\t}\n\tif (stat == RAY_CCS_STATUS_BUSY || stat == RAY_CCS_STATUS_FREE) {\n\t\t/* handle the timeout condition */\n\t\tcallout_reset(&sc->sc_start_join_timo_ch, RAY_START_TIMEOUT,\n\t\t    ray_start_join_timo, sc);\n\n\t\t/* be safe -- not a lot occurs with no net though */\n\t\tif (!RAY_ECF_READY(sc))\n\t\t\treturn (0);\n\n\t\t/* see if our nwid is up to date */\n\t\tif (!memcmp(sc->sc_cnwid, sc->sc_dnwid, sizeof(sc->sc_cnwid))\n\t\t    && sc->sc_omode == sc->sc_mode)\n\t\t\tSRAM_WRITE_FIELD_1(sc,ccs, ray_cmd_net, c_upd_param, 0);\n\t\telse {\n\t\t\tmemset(&np, 0, sizeof(np));\n\t\t\tnp.p_net_type = sc->sc_mode;\n\t\t\tmemcpy(np.p_ssid, sc->sc_dnwid, sizeof(np.p_ssid));\n\t\t\tray_write_region(sc, RAY_HOST_TO_ECF_BASE, &np,\n\t\t\t    sizeof(np));\n\t\t\tSRAM_WRITE_FIELD_1(sc,ccs, ray_cmd_net, c_upd_param, 1);\n\t\t}\n\n\t\tif (sc->sc_mode == SC_MODE_ADHOC)\n\t\t\tcmd = RAY_CMD_START_NET;\n\t\telse\n\t\t\tcmd = RAY_CMD_JOIN_NET;\n\t\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_net, c_cmd,\n\t\t    RAY_CCS_STATUS_BUSY);\n\t\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_net, c_status,\n\t\t    RAY_CCS_STATUS_BUSY);\n\n\t\t/* we simply poke the card again issuing the same ccs */\n\t\tSRAM_WRITE_1(sc, RAY_SCB_CCSI, RAY_GET_INDEX(ccs));\n\t\tRAY_ECF_START_CMD(sc);\n\t\tray_cmd_ran(sc, SCP_UPD_STARTJOIN);\n\t\treturn (0);\n\t}\n\t/* get the current ssid */\n\tSRAM_READ_FIELD_N(sc, ccs, ray_cmd_net, c_bss_id, sc->sc_bssid,\n\t    sizeof(sc->sc_bssid));\n\n\tsc->sc_deftxrate = SRAM_READ_FIELD_1(sc, ccs, ray_cmd_net,c_def_txrate);\n\tsc->sc_encrypt = SRAM_READ_FIELD_1(sc, ccs, ray_cmd_net, c_encrypt);\n\n\t/* adjust values for buggy build 4 */\n\tif (sc->sc_deftxrate == 0x55)\n\t\tsc->sc_deftxrate = RAY_PID_BASIC_RATE_1500K;\n\tif (sc->sc_encrypt == 0x55)\n\t\tsc->sc_encrypt = 0;\n\n\tif (SRAM_READ_FIELD_1(sc, ccs, ray_cmd_net, c_upd_param)) {\n\t\tray_read_region(sc, RAY_HOST_TO_ECF_BASE, &np, sizeof(np));\n\t\tmemcpy(sc->sc_cnwid, np.p_ssid, sizeof(sc->sc_cnwid));\n\t\tsc->sc_omode = sc->sc_mode;\n\t\tif (np.p_net_type != sc->sc_mode)\n\t\t\treturn (ray_start_join_net);\n\t}\n\tRAY_DPRINTF((\"%s: net start/join nwid %.32s bssid %s inited %d\\n\",\n\t    sc->sc_xname, sc->sc_cnwid, ether_sprintf(sc->sc_bssid),\n\t\tSRAM_READ_FIELD_1(sc, ccs, ray_cmd_net, c_inited)));\n\n\t/* network is now active */\n\tray_cmd_schedule(sc, SCP_UPD_MCAST|SCP_UPD_PROMISC);\n\tif (cmd == RAY_CMD_JOIN_NET)\n\t\treturn (ray_start_assoc);\n\telse {\n\t\tsc->sc_havenet = 1;\n\t\treturn (ray_intr_start);\n\t}\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tSCP_UPD_MCAST\t\t0x0800",
            "#define\tSCP_UPD_PROMISC\t\t0x0400",
            "#define\tSCP_UPD_STARTJOIN\t0x0200",
            "#define\tSC_MODE_ADHOC\t0\t/* ad-hoc mode */",
            "#define\tsc_xname\tsc_dev.dv_xname",
            "#define\tcallout_stop\ttimeout_del",
            "#define\tRAY_START_TIMEOUT\t(10 * hz)"
          ],
          "globals_used": [
            "void ray_cmd_schedule",
            "void ray_cmd_ran",
            "void ray_cmd_done",
            "void ray_intr_start",
            "void ray_start_assoc",
            "void ray_start_join_net",
            "ray_cmd_func_t ray_start_join_net_done",
            "void ray_start_join_timo"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSCP_UPD_MCAST\t\t0x0800\n#define\tSCP_UPD_PROMISC\t\t0x0400\n#define\tSCP_UPD_STARTJOIN\t0x0200\n#define\tSC_MODE_ADHOC\t0\t/* ad-hoc mode */\n#define\tsc_xname\tsc_dev.dv_xname\n#define\tcallout_stop\ttimeout_del\n#define\tRAY_START_TIMEOUT\t(10 * hz)\n\nvoid ray_cmd_schedule;\nvoid ray_cmd_ran;\nvoid ray_cmd_done;\nvoid ray_intr_start;\nvoid ray_start_assoc;\nvoid ray_start_join_net;\nray_cmd_func_t ray_start_join_net_done;\nvoid ray_start_join_timo;\n\nray_cmd_func_t\nray_start_join_net_done(sc, cmd, ccs, stat)\n\tstruct ray_softc *sc;\n\tu_int cmd;\n\tbus_size_t ccs;\n\tu_int stat;\n{\n\tstruct ray_net_params np;\n\n\tcallout_stop(&sc->sc_start_join_timo_ch);\n\tray_cmd_done(sc, SCP_UPD_STARTJOIN);\n\n\tif (stat == RAY_CCS_STATUS_FAIL) {\n\t\t/* XXX poke ifmedia when it supports this */\n\t\tsc->sc_havenet = 0;\n\t\treturn (ray_start_join_net);\n\t}\n\tif (stat == RAY_CCS_STATUS_BUSY || stat == RAY_CCS_STATUS_FREE) {\n\t\t/* handle the timeout condition */\n\t\tcallout_reset(&sc->sc_start_join_timo_ch, RAY_START_TIMEOUT,\n\t\t    ray_start_join_timo, sc);\n\n\t\t/* be safe -- not a lot occurs with no net though */\n\t\tif (!RAY_ECF_READY(sc))\n\t\t\treturn (0);\n\n\t\t/* see if our nwid is up to date */\n\t\tif (!memcmp(sc->sc_cnwid, sc->sc_dnwid, sizeof(sc->sc_cnwid))\n\t\t    && sc->sc_omode == sc->sc_mode)\n\t\t\tSRAM_WRITE_FIELD_1(sc,ccs, ray_cmd_net, c_upd_param, 0);\n\t\telse {\n\t\t\tmemset(&np, 0, sizeof(np));\n\t\t\tnp.p_net_type = sc->sc_mode;\n\t\t\tmemcpy(np.p_ssid, sc->sc_dnwid, sizeof(np.p_ssid));\n\t\t\tray_write_region(sc, RAY_HOST_TO_ECF_BASE, &np,\n\t\t\t    sizeof(np));\n\t\t\tSRAM_WRITE_FIELD_1(sc,ccs, ray_cmd_net, c_upd_param, 1);\n\t\t}\n\n\t\tif (sc->sc_mode == SC_MODE_ADHOC)\n\t\t\tcmd = RAY_CMD_START_NET;\n\t\telse\n\t\t\tcmd = RAY_CMD_JOIN_NET;\n\t\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_net, c_cmd,\n\t\t    RAY_CCS_STATUS_BUSY);\n\t\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_net, c_status,\n\t\t    RAY_CCS_STATUS_BUSY);\n\n\t\t/* we simply poke the card again issuing the same ccs */\n\t\tSRAM_WRITE_1(sc, RAY_SCB_CCSI, RAY_GET_INDEX(ccs));\n\t\tRAY_ECF_START_CMD(sc);\n\t\tray_cmd_ran(sc, SCP_UPD_STARTJOIN);\n\t\treturn (0);\n\t}\n\t/* get the current ssid */\n\tSRAM_READ_FIELD_N(sc, ccs, ray_cmd_net, c_bss_id, sc->sc_bssid,\n\t    sizeof(sc->sc_bssid));\n\n\tsc->sc_deftxrate = SRAM_READ_FIELD_1(sc, ccs, ray_cmd_net,c_def_txrate);\n\tsc->sc_encrypt = SRAM_READ_FIELD_1(sc, ccs, ray_cmd_net, c_encrypt);\n\n\t/* adjust values for buggy build 4 */\n\tif (sc->sc_deftxrate == 0x55)\n\t\tsc->sc_deftxrate = RAY_PID_BASIC_RATE_1500K;\n\tif (sc->sc_encrypt == 0x55)\n\t\tsc->sc_encrypt = 0;\n\n\tif (SRAM_READ_FIELD_1(sc, ccs, ray_cmd_net, c_upd_param)) {\n\t\tray_read_region(sc, RAY_HOST_TO_ECF_BASE, &np, sizeof(np));\n\t\tmemcpy(sc->sc_cnwid, np.p_ssid, sizeof(sc->sc_cnwid));\n\t\tsc->sc_omode = sc->sc_mode;\n\t\tif (np.p_net_type != sc->sc_mode)\n\t\t\treturn (ray_start_join_net);\n\t}\n\tRAY_DPRINTF((\"%s: net start/join nwid %.32s bssid %s inited %d\\n\",\n\t    sc->sc_xname, sc->sc_cnwid, ether_sprintf(sc->sc_bssid),\n\t\tSRAM_READ_FIELD_1(sc, ccs, ray_cmd_net, c_inited)));\n\n\t/* network is now active */\n\tray_cmd_schedule(sc, SCP_UPD_MCAST|SCP_UPD_PROMISC);\n\tif (cmd == RAY_CMD_JOIN_NET)\n\t\treturn (ray_start_assoc);\n\telse {\n\t\tsc->sc_havenet = 1;\n\t\treturn (ray_intr_start);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "SRAM_READ_FIELD_1",
          "args": [
            "sc",
            "sc->sc_startccs",
            "ray_cmd",
            "c_status"
          ],
          "line": 2742
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\nray_cmd_func_t ray_start_join_net_done;\nvoid ray_start_join_timo;\n\nvoid\nray_start_join_timo(arg)\n\tvoid *arg;\n{\n\tstruct ray_softc *sc;\n\tu_int stat;\n\n\tsc = arg;\n\tstat = SRAM_READ_FIELD_1(sc, sc->sc_startccs, ray_cmd, c_status);\n\tray_start_join_net_done(sc, sc->sc_startcmd, sc->sc_startccs, stat);\n}"
  },
  {
    "function_name": "ray_start_join_net",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
    "lines": "2691-2732",
    "snippet": "void\nray_start_join_net(sc)\n\tstruct ray_softc *sc;\n{\n\tstruct ray_net_params np;\n\tbus_size_t ccs;\n\tint cmd;\n\n\tray_cmd_cancel(sc, SCP_UPD_STARTJOIN);\n\tif ((sc->sc_if.if_flags & IFF_RUNNING) == 0)\n\t\treturn;\n\n\t/* XXX check we may not want to re-issue */\n\tif (ray_cmd_is_running(sc, SCP_UPDATESUBCMD)) {\n\t\tray_cmd_schedule(sc, SCP_UPD_STARTJOIN);\n\t\treturn;\n\t}\n\n\tif (sc->sc_mode == SC_MODE_ADHOC)\n\t\tcmd = RAY_CMD_START_NET;\n\telse\n\t\tcmd = RAY_CMD_JOIN_NET;\n\n\tif (!ray_alloc_ccs(sc, &ccs, cmd, SCP_UPD_STARTJOIN))\n\t\treturn;\n\tsc->sc_startccs = ccs;\n\tsc->sc_startcmd = cmd;\n\tif (!memcmp(sc->sc_cnwid, sc->sc_dnwid, sizeof(sc->sc_cnwid))\n\t    && sc->sc_omode == sc->sc_mode)\n\t\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_net, c_upd_param, 0);\n\telse {\n\t\tsc->sc_havenet = 0;\n\t\tmemset(&np, 0, sizeof(np));\n\t\tnp.p_net_type = sc->sc_mode;\n\t\tmemcpy(np.p_ssid, sc->sc_dnwid, sizeof(np.p_ssid));\n\t\tray_write_region(sc, RAY_HOST_TO_ECF_BASE, &np, sizeof(np));\n\t\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_net, c_upd_param, 1);\n\t}\n\tif (ray_issue_cmd(sc, ccs, SCP_UPD_STARTJOIN))\n\t\tcallout_reset(&sc->sc_start_join_timo_ch, RAY_START_TIMEOUT,\n\t\t    ray_start_join_timo, sc);\n}",
    "includes": [
      "#include <dev/pcmcia/if_rayreg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_llc.h>",
      "#include <net/if_media.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/timeout.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [
      "#define\tSCP_UPD_STARTJOIN\t0x0200",
      "#define\tSCP_UPDATESUBCMD\t0x0001",
      "#define\tSC_MODE_ADHOC\t0\t/* ad-hoc mode */",
      "#define\tsc_if\t\tsc_ec.ac_if",
      "#define\tsc_if\t\tsc_ec.ec_if",
      "#define\tRAY_START_TIMEOUT\t(10 * hz)"
    ],
    "globals_used": [
      "int ray_alloc_ccs",
      "void ray_cmd_cancel",
      "void ray_cmd_schedule",
      "int ray_cmd_is_running",
      "int ray_issue_cmd",
      "void ray_start_join_net",
      "void ray_start_join_timo"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "callout_reset",
          "args": [
            "&sc->sc_start_join_timo_ch",
            "RAY_START_TIMEOUT",
            "ray_start_join_timo",
            "sc"
          ],
          "line": 2730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ray_issue_cmd",
          "args": [
            "sc",
            "ccs",
            "SCP_UPD_STARTJOIN"
          ],
          "line": 2729
        },
        "resolved": true,
        "details": {
          "function_name": "ray_issue_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2362-2391",
          "snippet": "int\nray_issue_cmd(sc, ccs, track)\n\tstruct ray_softc *sc;\n\tbus_size_t ccs;\n\tu_int track;\n{\n\tu_int i;\n\n\tRAY_DPRINTF((\"%s: ray_cmd_issue 0x%x\\n\", sc->sc_xname, track));\n\n\t/*\n\t * XXX other drivers did this, but I think\n\t * what we really want to do is just make sure we don't\n\t * get here or that spinning is ok\n\t */\n\ti = 0;\n\twhile (!RAY_ECF_READY(sc))\n\t\tif (++i > 50) {\n\t\t\tray_free_ccs(sc, ccs);\n\t\t\tif (track)\n\t\t\t\tray_cmd_schedule(sc, track);\n\t\t\treturn (0);\n\t\t}\n\n\tSRAM_WRITE_1(sc, RAY_SCB_CCSI, RAY_GET_INDEX(ccs));\n\tRAY_ECF_START_CMD(sc);\n\tray_cmd_ran(sc, track);\n\n\treturn (1);\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tsc_xname\tsc_dev.dv_xname"
          ],
          "globals_used": [
            "void ray_cmd_schedule",
            "void ray_cmd_ran",
            "u_int8_t ray_free_ccs",
            "int ray_issue_cmd"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_xname\tsc_dev.dv_xname\n\nvoid ray_cmd_schedule;\nvoid ray_cmd_ran;\nu_int8_t ray_free_ccs;\nint ray_issue_cmd;\n\nint\nray_issue_cmd(sc, ccs, track)\n\tstruct ray_softc *sc;\n\tbus_size_t ccs;\n\tu_int track;\n{\n\tu_int i;\n\n\tRAY_DPRINTF((\"%s: ray_cmd_issue 0x%x\\n\", sc->sc_xname, track));\n\n\t/*\n\t * XXX other drivers did this, but I think\n\t * what we really want to do is just make sure we don't\n\t * get here or that spinning is ok\n\t */\n\ti = 0;\n\twhile (!RAY_ECF_READY(sc))\n\t\tif (++i > 50) {\n\t\t\tray_free_ccs(sc, ccs);\n\t\t\tif (track)\n\t\t\t\tray_cmd_schedule(sc, track);\n\t\t\treturn (0);\n\t\t}\n\n\tSRAM_WRITE_1(sc, RAY_SCB_CCSI, RAY_GET_INDEX(ccs));\n\tRAY_ECF_START_CMD(sc);\n\tray_cmd_ran(sc, track);\n\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SRAM_WRITE_FIELD_1",
          "args": [
            "sc",
            "ccs",
            "ray_cmd_net",
            "c_upd_param",
            "1"
          ],
          "line": 2727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ray_write_region",
          "args": [
            "sc",
            "RAY_HOST_TO_ECF_BASE",
            "&np",
            "sizeof(np)"
          ],
          "line": 2726
        },
        "resolved": true,
        "details": {
          "function_name": "ray_write_region",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "3125-3177",
          "snippet": "void\nray_write_region(sc, off, vp, c)\n\tstruct ray_softc *sc;\n\tbus_size_t off;\n\tvoid *vp;\n\tsize_t c;\n{\n#ifdef RAY_USE_OPTIMIZED_COPY\n\tsize_t n2, n4, tmp;\n\tu_int8_t *p;\n\n\tp = vp;\n\t/* XXX we may be making poor assumptions here but lets hope */\n\tswitch ((off|(bus_addr_t)p) & 0x03) {\n\tcase 0:\n\t\tif ((n4 = (c >> 2))) {\n\t\t\tbus_space_write_region_4(sc->sc_memt, sc->sc_memh, off,\n\t\t\t    p, n4);\n\t\t\ttmp = c & ~0x3;\n\t\t\tc &= 0x3;\n\t\t\tp += tmp;\n\t\t\toff += tmp;\n\t\t}\n\t\tswitch (c) {\n\t\tcase 3:\n\t\t\tbus_space_write_1(sc->sc_memt,sc->sc_memh, off, *p);\n\t\t\tp++, off++;\n\t\tcase 2:\n\t\t\tbus_space_write_1(sc->sc_memt,sc->sc_memh, off, *p);\n\t\t\tp++, off++;\n\t\tcase 1:\n\t\t\tbus_space_write_1(sc->sc_memt,sc->sc_memh, off, *p);\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tif ((n2 = (c >> 1)))\n\t\t\tbus_space_write_region_2(sc->sc_memt, sc->sc_memh, off,\n\t\t\t    p, n2);\n\t\tif (c & 0x1) {\n\t\t\tc &= ~0x1;\n\t\t\tbus_space_write_1(sc->sc_memt, sc->sc_memh,\n\t\t\t    off + c, *(p + c));\n\t\t}\n\t\tbreak;\n\tcase 1:\n\tcase 3:\n\t\tbus_space_write_region_1(sc->sc_memt, sc->sc_memh, off, p, c);\n\t\tbreak;\n\t}\n#else\n\tbus_space_write_region_1(sc->sc_memt, sc->sc_memh, off, vp, c);\n#endif\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tsc_memh\tsc_mem.memh",
            "#define\tsc_memt\tsc_mem.memt"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_memh\tsc_mem.memh\n#define\tsc_memt\tsc_mem.memt\n\nvoid\nray_write_region(sc, off, vp, c)\n\tstruct ray_softc *sc;\n\tbus_size_t off;\n\tvoid *vp;\n\tsize_t c;\n{\n#ifdef RAY_USE_OPTIMIZED_COPY\n\tsize_t n2, n4, tmp;\n\tu_int8_t *p;\n\n\tp = vp;\n\t/* XXX we may be making poor assumptions here but lets hope */\n\tswitch ((off|(bus_addr_t)p) & 0x03) {\n\tcase 0:\n\t\tif ((n4 = (c >> 2))) {\n\t\t\tbus_space_write_region_4(sc->sc_memt, sc->sc_memh, off,\n\t\t\t    p, n4);\n\t\t\ttmp = c & ~0x3;\n\t\t\tc &= 0x3;\n\t\t\tp += tmp;\n\t\t\toff += tmp;\n\t\t}\n\t\tswitch (c) {\n\t\tcase 3:\n\t\t\tbus_space_write_1(sc->sc_memt,sc->sc_memh, off, *p);\n\t\t\tp++, off++;\n\t\tcase 2:\n\t\t\tbus_space_write_1(sc->sc_memt,sc->sc_memh, off, *p);\n\t\t\tp++, off++;\n\t\tcase 1:\n\t\t\tbus_space_write_1(sc->sc_memt,sc->sc_memh, off, *p);\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tif ((n2 = (c >> 1)))\n\t\t\tbus_space_write_region_2(sc->sc_memt, sc->sc_memh, off,\n\t\t\t    p, n2);\n\t\tif (c & 0x1) {\n\t\t\tc &= ~0x1;\n\t\t\tbus_space_write_1(sc->sc_memt, sc->sc_memh,\n\t\t\t    off + c, *(p + c));\n\t\t}\n\t\tbreak;\n\tcase 1:\n\tcase 3:\n\t\tbus_space_write_region_1(sc->sc_memt, sc->sc_memh, off, p, c);\n\t\tbreak;\n\t}\n#else\n\tbus_space_write_region_1(sc->sc_memt, sc->sc_memh, off, vp, c);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "np.p_ssid",
            "sc->sc_dnwid",
            "sizeof(np.p_ssid)"
          ],
          "line": 2725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&np",
            "0",
            "sizeof(np)"
          ],
          "line": 2723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRAM_WRITE_FIELD_1",
          "args": [
            "sc",
            "ccs",
            "ray_cmd_net",
            "c_upd_param",
            "0"
          ],
          "line": 2720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "sc->sc_cnwid",
            "sc->sc_dnwid",
            "sizeof(sc->sc_cnwid)"
          ],
          "line": 2718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ray_alloc_ccs",
          "args": [
            "sc",
            "&ccs",
            "cmd",
            "SCP_UPD_STARTJOIN"
          ],
          "line": 2714
        },
        "resolved": true,
        "details": {
          "function_name": "ray_alloc_ccs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2184-2221",
          "snippet": "int\nray_alloc_ccs(sc, ccsp, cmd, track)\n\tstruct ray_softc *sc;\n\tbus_size_t *ccsp;\n\tu_int cmd, track;\n{\n\tbus_size_t ccs;\n\tu_int i;\n\n\tRAY_DPRINTF((\"%s: alloc_ccs cmd %d\\n\", sc->sc_xname, cmd));\n\n\t/* for tracked commands, if not ready just set pending */\n\tif (track && !RAY_ECF_READY(sc)) {\n\t\tray_cmd_schedule(sc, track);\n\t\treturn (0);\n\t}\n\n\t/* first scan our inuse array */\n\tfor (i = RAY_CCS_CMD_FIRST; i <= RAY_CCS_CMD_LAST; i++) {\n\t\t/* XXX wonder if we have to probe here to make the card go */\n\t\t(void)SRAM_READ_FIELD_1(sc, RAY_GET_CCS(i), ray_cmd, c_status);\n\t\tif (!sc->sc_ccsinuse[i])\n\t\t\tbreak;\n\t}\n\tif (i > RAY_CCS_CMD_LAST) {\n\t\tif (track)\n\t\t\tray_cmd_schedule(sc, track);\n\t\treturn (0);\n\t}\n\tsc->sc_ccsinuse[i] = 1;\n\tccs = RAY_GET_CCS(i);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_status, RAY_CCS_STATUS_BUSY);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_cmd, cmd);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_link, RAY_CCS_LINK_NULL);\n\n\t*ccsp = ccs;\n\treturn (1);\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tsc_xname\tsc_dev.dv_xname"
          ],
          "globals_used": [
            "int ray_alloc_ccs",
            "void ray_cmd_schedule"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_xname\tsc_dev.dv_xname\n\nint ray_alloc_ccs;\nvoid ray_cmd_schedule;\n\nint\nray_alloc_ccs(sc, ccsp, cmd, track)\n\tstruct ray_softc *sc;\n\tbus_size_t *ccsp;\n\tu_int cmd, track;\n{\n\tbus_size_t ccs;\n\tu_int i;\n\n\tRAY_DPRINTF((\"%s: alloc_ccs cmd %d\\n\", sc->sc_xname, cmd));\n\n\t/* for tracked commands, if not ready just set pending */\n\tif (track && !RAY_ECF_READY(sc)) {\n\t\tray_cmd_schedule(sc, track);\n\t\treturn (0);\n\t}\n\n\t/* first scan our inuse array */\n\tfor (i = RAY_CCS_CMD_FIRST; i <= RAY_CCS_CMD_LAST; i++) {\n\t\t/* XXX wonder if we have to probe here to make the card go */\n\t\t(void)SRAM_READ_FIELD_1(sc, RAY_GET_CCS(i), ray_cmd, c_status);\n\t\tif (!sc->sc_ccsinuse[i])\n\t\t\tbreak;\n\t}\n\tif (i > RAY_CCS_CMD_LAST) {\n\t\tif (track)\n\t\t\tray_cmd_schedule(sc, track);\n\t\treturn (0);\n\t}\n\tsc->sc_ccsinuse[i] = 1;\n\tccs = RAY_GET_CCS(i);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_status, RAY_CCS_STATUS_BUSY);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_cmd, cmd);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_link, RAY_CCS_LINK_NULL);\n\n\t*ccsp = ccs;\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ray_cmd_schedule",
          "args": [
            "sc",
            "SCP_UPD_STARTJOIN"
          ],
          "line": 2705
        },
        "resolved": true,
        "details": {
          "function_name": "ray_cmd_schedule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2248-2265",
          "snippet": "void\nray_cmd_schedule(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tint track;\n\n\tRAY_DPRINTF((\"%s: ray_cmd_schedule 0x%x\\n\", sc->sc_xname, cmdf));\n\n\ttrack = cmdf;\n\tif ((cmdf & SCP_UPD_MASK) == 0)\n\t\tray_set_pending(sc, track);\n\telse if (ray_cmd_is_running(sc, SCP_UPDATESUBCMD)) {\n\t\t/* don't do timeout mechaniscm if subcmd already going */\n\t\tsc->sc_scheduled |= cmdf;\n\t} else\n\t\tray_set_pending(sc, cmdf | SCP_UPDATESUBCMD);\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tSCP_UPD_MASK\t\t0xff00",
            "#define\tSCP_UPDATESUBCMD\t0x0001",
            "#define\tsc_xname\tsc_dev.dv_xname"
          ],
          "globals_used": [
            "void ray_cmd_schedule",
            "int ray_cmd_is_running",
            "void ray_set_pending"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSCP_UPD_MASK\t\t0xff00\n#define\tSCP_UPDATESUBCMD\t0x0001\n#define\tsc_xname\tsc_dev.dv_xname\n\nvoid ray_cmd_schedule;\nint ray_cmd_is_running;\nvoid ray_set_pending;\n\nvoid\nray_cmd_schedule(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tint track;\n\n\tRAY_DPRINTF((\"%s: ray_cmd_schedule 0x%x\\n\", sc->sc_xname, cmdf));\n\n\ttrack = cmdf;\n\tif ((cmdf & SCP_UPD_MASK) == 0)\n\t\tray_set_pending(sc, track);\n\telse if (ray_cmd_is_running(sc, SCP_UPDATESUBCMD)) {\n\t\t/* don't do timeout mechaniscm if subcmd already going */\n\t\tsc->sc_scheduled |= cmdf;\n\t} else\n\t\tray_set_pending(sc, cmdf | SCP_UPDATESUBCMD);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ray_cmd_is_running",
          "args": [
            "sc",
            "SCP_UPDATESUBCMD"
          ],
          "line": 2704
        },
        "resolved": true,
        "details": {
          "function_name": "ray_cmd_is_running",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2326-2334",
          "snippet": "int\nray_cmd_is_running(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_cmd_is_running 0x%x\\n\", sc->sc_xname, cmdf));\n\n\treturn ((sc->sc_running & cmdf) ? 1 : 0);\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tsc_xname\tsc_dev.dv_xname"
          ],
          "globals_used": [
            "int ray_cmd_is_running"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_xname\tsc_dev.dv_xname\n\nint ray_cmd_is_running;\n\nint\nray_cmd_is_running(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_cmd_is_running 0x%x\\n\", sc->sc_xname, cmdf));\n\n\treturn ((sc->sc_running & cmdf) ? 1 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ray_cmd_cancel",
          "args": [
            "sc",
            "SCP_UPD_STARTJOIN"
          ],
          "line": 2699
        },
        "resolved": true,
        "details": {
          "function_name": "ray_cmd_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2283-2299",
          "snippet": "void\nray_cmd_cancel(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_cmd_cancel 0x%x\\n\", sc->sc_xname, cmdf));\n\n\tsc->sc_scheduled &= ~cmdf;\n\tif ((cmdf & SCP_UPD_MASK) && (sc->sc_scheduled & SCP_UPD_MASK) == 0)\n\t\tsc->sc_scheduled &= ~SCP_UPDATESUBCMD;\n\n\t/* if nothing else needed cancel the timer */\n\tif (sc->sc_scheduled == 0 && sc->sc_timoneed) {\n\t\tcallout_stop(&sc->sc_check_scheduled_ch);\n\t\tsc->sc_timoneed = 0;\n\t}\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tSCP_UPD_MASK\t\t0xff00",
            "#define\tSCP_UPDATESUBCMD\t0x0001",
            "#define\tsc_xname\tsc_dev.dv_xname",
            "#define\tcallout_stop\ttimeout_del"
          ],
          "globals_used": [
            "void ray_cmd_cancel"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSCP_UPD_MASK\t\t0xff00\n#define\tSCP_UPDATESUBCMD\t0x0001\n#define\tsc_xname\tsc_dev.dv_xname\n#define\tcallout_stop\ttimeout_del\n\nvoid ray_cmd_cancel;\n\nvoid\nray_cmd_cancel(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_cmd_cancel 0x%x\\n\", sc->sc_xname, cmdf));\n\n\tsc->sc_scheduled &= ~cmdf;\n\tif ((cmdf & SCP_UPD_MASK) && (sc->sc_scheduled & SCP_UPD_MASK) == 0)\n\t\tsc->sc_scheduled &= ~SCP_UPDATESUBCMD;\n\n\t/* if nothing else needed cancel the timer */\n\tif (sc->sc_scheduled == 0 && sc->sc_timoneed) {\n\t\tcallout_stop(&sc->sc_check_scheduled_ch);\n\t\tsc->sc_timoneed = 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSCP_UPD_STARTJOIN\t0x0200\n#define\tSCP_UPDATESUBCMD\t0x0001\n#define\tSC_MODE_ADHOC\t0\t/* ad-hoc mode */\n#define\tsc_if\t\tsc_ec.ac_if\n#define\tsc_if\t\tsc_ec.ec_if\n#define\tRAY_START_TIMEOUT\t(10 * hz)\n\nint ray_alloc_ccs;\nvoid ray_cmd_cancel;\nvoid ray_cmd_schedule;\nint ray_cmd_is_running;\nint ray_issue_cmd;\nvoid ray_start_join_net;\nvoid ray_start_join_timo;\n\nvoid\nray_start_join_net(sc)\n\tstruct ray_softc *sc;\n{\n\tstruct ray_net_params np;\n\tbus_size_t ccs;\n\tint cmd;\n\n\tray_cmd_cancel(sc, SCP_UPD_STARTJOIN);\n\tif ((sc->sc_if.if_flags & IFF_RUNNING) == 0)\n\t\treturn;\n\n\t/* XXX check we may not want to re-issue */\n\tif (ray_cmd_is_running(sc, SCP_UPDATESUBCMD)) {\n\t\tray_cmd_schedule(sc, SCP_UPD_STARTJOIN);\n\t\treturn;\n\t}\n\n\tif (sc->sc_mode == SC_MODE_ADHOC)\n\t\tcmd = RAY_CMD_START_NET;\n\telse\n\t\tcmd = RAY_CMD_JOIN_NET;\n\n\tif (!ray_alloc_ccs(sc, &ccs, cmd, SCP_UPD_STARTJOIN))\n\t\treturn;\n\tsc->sc_startccs = ccs;\n\tsc->sc_startcmd = cmd;\n\tif (!memcmp(sc->sc_cnwid, sc->sc_dnwid, sizeof(sc->sc_cnwid))\n\t    && sc->sc_omode == sc->sc_mode)\n\t\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_net, c_upd_param, 0);\n\telse {\n\t\tsc->sc_havenet = 0;\n\t\tmemset(&np, 0, sizeof(np));\n\t\tnp.p_net_type = sc->sc_mode;\n\t\tmemcpy(np.p_ssid, sc->sc_dnwid, sizeof(np.p_ssid));\n\t\tray_write_region(sc, RAY_HOST_TO_ECF_BASE, &np, sizeof(np));\n\t\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_net, c_upd_param, 1);\n\t}\n\tif (ray_issue_cmd(sc, ccs, SCP_UPD_STARTJOIN))\n\t\tcallout_reset(&sc->sc_start_join_timo_ch, RAY_START_TIMEOUT,\n\t\t    ray_start_join_timo, sc);\n}"
  },
  {
    "function_name": "ray_download_params",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
    "lines": "2500-2686",
    "snippet": "void\nray_download_params(sc)\n\tstruct ray_softc *sc;\n{\n\tstruct ray_startup_params_head *sp;\n\tstruct ray_startup_params_tail_5 *sp5;\n\tstruct ray_startup_params_tail_4 *sp4;\n\tbus_size_t off;\n\n\tRAY_DPRINTF((\"%s: init_startup_params\\n\", sc->sc_xname));\n\n\tray_cmd_cancel(sc, SCP_UPD_STARTUP);\n\n#define\tPUT2(p, v)\t\\\n\tdo { (p)[0] = ((v >> 8) & 0xff); (p)[1] = (v & 0xff); } while(0)\n\n\tsp = &sc->sc_startup;\n\tsp4 = &sc->sc_startup_4;\n\tsp5 = &sc->sc_startup_5;\n\tmemset(sp, 0, sizeof(*sp));\n\tif (sc->sc_version == SC_BUILD_4)\n\t\tmemset(sp4, 0, sizeof(*sp4));\n\telse\n\t\tmemset(sp5, 0, sizeof(*sp5));\n\tmemcpy(sp->sp_ssid, sc->sc_dnwid, sizeof(sp->sp_ssid));\n\tsp->sp_scan_mode = 0x1;\n\tmemcpy(sp->sp_mac_addr, sc->sc_ecf_startup.e_station_addr,\n\t    ETHER_ADDR_LEN);\n\tPUT2(sp->sp_frag_thresh, 0x7fff);\t/* disabled */\n\tif (sc->sc_version == SC_BUILD_4) {\n#if 1\n\t\t/* linux/fbsd */\n\t\tPUT2(sp->sp_dwell_time, 0x200);\n\t\tPUT2(sp->sp_beacon_period, 1);\n#else\n\t\t/* divined */\n\t\tPUT2(sp->sp_dwell_time, 0x400);\n\t\tPUT2(sp->sp_beacon_period, 0);\n#endif\n\t} else {\n\t\tPUT2(sp->sp_dwell_time, 128);\n\t\tPUT2(sp->sp_beacon_period, 256);\n\t}\n\tsp->sp_dtim_interval = 1;\n#if 0\n\t/* these are the documented defaults for build 5/6 */\n\tsp->sp_max_retry = 0x1f;\n\tsp->sp_ack_timo = 0x86;\n\tsp->sp_sifs = 0x1c;\n#elif 1\n\t/* these were scrounged from the linux driver */\n\tsp->sp_max_retry = 0x07;\n\n\tsp->sp_ack_timo = 0xa3;\n\tsp->sp_sifs = 0x1d;\n#else\n\t/* these were divined */\n\tsp->sp_max_retry = 0x03;\n\n\tsp->sp_ack_timo = 0xa3;\n\tsp->sp_sifs = 0x1d;\n#endif\n#if 0\n\t/* these are the documented defaults for build 5/6 */\n\tsp->sp_difs = 0x82;\n\tsp->sp_pifs = 0;\n#else\n\t/* linux/fbsd */\n\tsp->sp_difs = 0x82;\n\n\tif (sc->sc_version == SC_BUILD_4)\n\t\tsp->sp_pifs = 0xce;\n\telse\n\t\tsp->sp_pifs = 0x4e;\n#endif\n\n\tPUT2(sp->sp_rts_thresh, 0x7fff);\t/* disabled */\n\tif (sc->sc_version == SC_BUILD_4) {\n\t\tPUT2(sp->sp_scan_dwell, 0xfb1e);\n\t\tPUT2(sp->sp_scan_max_dwell, 0xc75c);\n\t} else {\n\t\tPUT2(sp->sp_scan_dwell, 0x4e2);\n\t\tPUT2(sp->sp_scan_max_dwell, 0x38a4);\n\t}\n\tsp->sp_assoc_timo = 0x5;\n\tif (sc->sc_version == SC_BUILD_4) {\n#if 1 /* obsd */\n\t\t/* linux/fbsd */\n\t\tsp->sp_adhoc_scan_cycle = 0x4;\n\t\tsp->sp_infra_scan_cycle = 0x2;\n\t\tsp->sp_infra_super_scan_cycle = 0x4;\n#else\n\t\t/* divined */\n\t\tsp->sp_adhoc_scan_cycle = 0x8;\n\t\tsp->sp_infra_scan_cycle = 0x1;\n\t\tsp->sp_infra_super_scan_cycle = 0x18;\n#endif\n\t} else {\n\t\tsp->sp_adhoc_scan_cycle = 0x8;\n\t\tsp->sp_infra_scan_cycle = 0x2;\n\t\tsp->sp_infra_super_scan_cycle = 0x8;\n\t}\n\tsp->sp_promisc = sc->sc_promisc;\n\tPUT2(sp->sp_uniq_word, 0x0cbd);\n\tif (sc->sc_version == SC_BUILD_4) {\n\t/* XXX whats this value anyway.. the std says 50us */\n\t\t/* XXX sp->sp_slot_time = 0x4e; */\n\t\tsp->sp_slot_time = 0x4e;\n#if 1\n\t\t/*linux/fbsd*/\n\t\tsp->sp_roam_low_snr_thresh = 0xff;\n#else\n\t\t/*divined*/\n\t\tsp->sp_roam_low_snr_thresh = 0x30;\n#endif\n\t} else {\n\t\tsp->sp_slot_time = 0x32;\n\t\tsp->sp_roam_low_snr_thresh = 0xff;\t/* disabled */\n\t}\n#if 1\n\tsp->sp_low_snr_count = 0xff;\t\t/* disabled */\n#else\n\t/* divined -- check */\n\tsp->sp_low_snr_count = 0x07;\t\t/* disabled */\n#endif\n#if 0\n\tsp->sp_infra_missed_beacon_count = 0x2;\n#elif 1\n\t/* linux/fbsd */\n\tsp->sp_infra_missed_beacon_count = 0x5;\n#else\n\t/* divined -- check, looks fishy */\n\tsp->sp_infra_missed_beacon_count = 0x7;\n#endif\n\tsp->sp_adhoc_missed_beacon_count = 0xff;\n\tsp->sp_country_code = sc->sc_dcountrycode;\n\tsp->sp_hop_seq = 0x0b;\n\tif (sc->sc_version == SC_BUILD_4) {\n\t\tsp->sp_hop_seq_len = 0x4e;\n\t\tsp4->sp_cw_max = 0x3f;\t/* single byte on build 4 */\n\t\tsp4->sp_cw_min = 0x0f;\t/* single byte on build 4 */\n\t\tsp4->sp_noise_filter_gain = 0x4;\n\t\tsp4->sp_noise_limit_offset = 0x8;\n\t\tsp4->sp_rssi_thresh_offset = 0x28;\n\t\tsp4->sp_busy_thresh_offset = 0x28;\n\t\tsp4->sp_sync_thresh = 0x07;\n\t\tsp4->sp_test_mode = 0x0;\n\t\tsp4->sp_test_min_chan = 0x2;\n\t\tsp4->sp_test_max_chan = 0x2;\n\t} else {\n\t\tsp->sp_hop_seq_len = 0x4f;\n\t\tPUT2(sp5->sp_cw_max, 0x3f);\n\t\tPUT2(sp5->sp_cw_min, 0x0f);\n\t\tsp5->sp_noise_filter_gain = 0x4;\n\t\tsp5->sp_noise_limit_offset = 0x8;\n\t\tsp5->sp_rssi_thresh_offset = 0x28;\n\t\tsp5->sp_busy_thresh_offset = 0x28;\n\t\tsp5->sp_sync_thresh = 0x07;\n\t\tsp5->sp_test_mode = 0x0;\n\t\tsp5->sp_test_min_chan = 0x2;\n\t\tsp5->sp_test_max_chan = 0x2;\n#if 0\n\t\tsp5->sp_allow_probe_resp = 0x1;\n#else\n\t\tsp5->sp_allow_probe_resp = 0x0;\n#endif\n\t\tsp5->sp_privacy_must_start = 0x0;\n\t\tsp5->sp_privacy_can_join = 0x0;\n\t\tsp5->sp_basic_rate_set[0] = 0x2;\n\t\t    /* 2 = 1Mbps, 3 = old 2Mbps 4 = 2Mbps */\n\t}\n\n\t/* we shouldn't be called with some command pending */\n\tif (!RAY_ECF_READY(sc))\n\t\tpanic(\"ray_download_params busy\");\n\n\t/* write the compatible part */\n\toff = RAY_HOST_TO_ECF_BASE;\n\tray_write_region(sc, off, sp, sizeof(sc->sc_startup));\n\toff += sizeof(sc->sc_startup);\n\tif (sc->sc_version == SC_BUILD_4)\n\t\tray_write_region(sc, off, sp4, sizeof(*sp4));\n\telse\n\t\tray_write_region(sc, off, sp5, sizeof(*sp5));\n\tif (!ray_simple_cmd(sc, RAY_CMD_START_PARAMS, SCP_UPD_STARTUP))\n\t\tpanic(\"ray_download_params issue\");\n}",
    "includes": [
      "#include <dev/pcmcia/if_rayreg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_llc.h>",
      "#include <net/if_media.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/timeout.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [
      "#define\tSC_BUILD_4\t0x55",
      "#define\tSCP_UPD_STARTUP\t\t0x0100",
      "#define\tsc_xname\tsc_dev.dv_xname",
      "#define\tsc_version\tsc_ecf_startup.e_fw_build_string",
      "#define\tsc_startup_5\tsc_u.u_params_5",
      "#define\tsc_startup_4\tsc_u.u_params_4"
    ],
    "globals_used": [
      "void ray_cmd_cancel",
      "void ray_download_params",
      "int ray_simple_cmd"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"ray_download_params issue\""
          ],
          "line": 2685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ray_simple_cmd",
          "args": [
            "sc",
            "RAY_CMD_START_PARAMS",
            "SCP_UPD_STARTUP"
          ],
          "line": 2684
        },
        "resolved": true,
        "details": {
          "function_name": "ray_simple_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2396-2405",
          "snippet": "int\nray_simple_cmd(sc, cmd, track)\n\tstruct ray_softc *sc;\n\tu_int cmd, track;\n{\n\tbus_size_t ccs;\n\n\treturn (ray_alloc_ccs(sc, &ccs, cmd, track) &&\n\t    ray_issue_cmd(sc, ccs, track));\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int ray_alloc_ccs",
            "int ray_issue_cmd",
            "int ray_simple_cmd"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\nint ray_alloc_ccs;\nint ray_issue_cmd;\nint ray_simple_cmd;\n\nint\nray_simple_cmd(sc, cmd, track)\n\tstruct ray_softc *sc;\n\tu_int cmd, track;\n{\n\tbus_size_t ccs;\n\n\treturn (ray_alloc_ccs(sc, &ccs, cmd, track) &&\n\t    ray_issue_cmd(sc, ccs, track));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ray_write_region",
          "args": [
            "sc",
            "off",
            "sp5",
            "sizeof(*sp5)"
          ],
          "line": 2683
        },
        "resolved": true,
        "details": {
          "function_name": "ray_write_region",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "3125-3177",
          "snippet": "void\nray_write_region(sc, off, vp, c)\n\tstruct ray_softc *sc;\n\tbus_size_t off;\n\tvoid *vp;\n\tsize_t c;\n{\n#ifdef RAY_USE_OPTIMIZED_COPY\n\tsize_t n2, n4, tmp;\n\tu_int8_t *p;\n\n\tp = vp;\n\t/* XXX we may be making poor assumptions here but lets hope */\n\tswitch ((off|(bus_addr_t)p) & 0x03) {\n\tcase 0:\n\t\tif ((n4 = (c >> 2))) {\n\t\t\tbus_space_write_region_4(sc->sc_memt, sc->sc_memh, off,\n\t\t\t    p, n4);\n\t\t\ttmp = c & ~0x3;\n\t\t\tc &= 0x3;\n\t\t\tp += tmp;\n\t\t\toff += tmp;\n\t\t}\n\t\tswitch (c) {\n\t\tcase 3:\n\t\t\tbus_space_write_1(sc->sc_memt,sc->sc_memh, off, *p);\n\t\t\tp++, off++;\n\t\tcase 2:\n\t\t\tbus_space_write_1(sc->sc_memt,sc->sc_memh, off, *p);\n\t\t\tp++, off++;\n\t\tcase 1:\n\t\t\tbus_space_write_1(sc->sc_memt,sc->sc_memh, off, *p);\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tif ((n2 = (c >> 1)))\n\t\t\tbus_space_write_region_2(sc->sc_memt, sc->sc_memh, off,\n\t\t\t    p, n2);\n\t\tif (c & 0x1) {\n\t\t\tc &= ~0x1;\n\t\t\tbus_space_write_1(sc->sc_memt, sc->sc_memh,\n\t\t\t    off + c, *(p + c));\n\t\t}\n\t\tbreak;\n\tcase 1:\n\tcase 3:\n\t\tbus_space_write_region_1(sc->sc_memt, sc->sc_memh, off, p, c);\n\t\tbreak;\n\t}\n#else\n\tbus_space_write_region_1(sc->sc_memt, sc->sc_memh, off, vp, c);\n#endif\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tsc_memh\tsc_mem.memh",
            "#define\tsc_memt\tsc_mem.memt"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_memh\tsc_mem.memh\n#define\tsc_memt\tsc_mem.memt\n\nvoid\nray_write_region(sc, off, vp, c)\n\tstruct ray_softc *sc;\n\tbus_size_t off;\n\tvoid *vp;\n\tsize_t c;\n{\n#ifdef RAY_USE_OPTIMIZED_COPY\n\tsize_t n2, n4, tmp;\n\tu_int8_t *p;\n\n\tp = vp;\n\t/* XXX we may be making poor assumptions here but lets hope */\n\tswitch ((off|(bus_addr_t)p) & 0x03) {\n\tcase 0:\n\t\tif ((n4 = (c >> 2))) {\n\t\t\tbus_space_write_region_4(sc->sc_memt, sc->sc_memh, off,\n\t\t\t    p, n4);\n\t\t\ttmp = c & ~0x3;\n\t\t\tc &= 0x3;\n\t\t\tp += tmp;\n\t\t\toff += tmp;\n\t\t}\n\t\tswitch (c) {\n\t\tcase 3:\n\t\t\tbus_space_write_1(sc->sc_memt,sc->sc_memh, off, *p);\n\t\t\tp++, off++;\n\t\tcase 2:\n\t\t\tbus_space_write_1(sc->sc_memt,sc->sc_memh, off, *p);\n\t\t\tp++, off++;\n\t\tcase 1:\n\t\t\tbus_space_write_1(sc->sc_memt,sc->sc_memh, off, *p);\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tif ((n2 = (c >> 1)))\n\t\t\tbus_space_write_region_2(sc->sc_memt, sc->sc_memh, off,\n\t\t\t    p, n2);\n\t\tif (c & 0x1) {\n\t\t\tc &= ~0x1;\n\t\t\tbus_space_write_1(sc->sc_memt, sc->sc_memh,\n\t\t\t    off + c, *(p + c));\n\t\t}\n\t\tbreak;\n\tcase 1:\n\tcase 3:\n\t\tbus_space_write_region_1(sc->sc_memt, sc->sc_memh, off, p, c);\n\t\tbreak;\n\t}\n#else\n\tbus_space_write_region_1(sc->sc_memt, sc->sc_memh, off, vp, c);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"ray_download_params busy\""
          ],
          "line": 2674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_ECF_READY",
          "args": [
            "sc"
          ],
          "line": 2673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PUT2",
          "args": [
            "sp5->sp_cw_min",
            "0x0f"
          ],
          "line": 2652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PUT2",
          "args": [
            "sp5->sp_cw_max",
            "0x3f"
          ],
          "line": 2651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PUT2",
          "args": [
            "sp->sp_uniq_word",
            "0x0cbd"
          ],
          "line": 2603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PUT2",
          "args": [
            "sp->sp_scan_max_dwell",
            "0x38a4"
          ],
          "line": 2582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PUT2",
          "args": [
            "sp->sp_scan_dwell",
            "0x4e2"
          ],
          "line": 2581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PUT2",
          "args": [
            "sp->sp_scan_max_dwell",
            "0xc75c"
          ],
          "line": 2579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PUT2",
          "args": [
            "sp->sp_scan_dwell",
            "0xfb1e"
          ],
          "line": 2578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PUT2",
          "args": [
            "sp->sp_rts_thresh",
            "0x7fff"
          ],
          "line": 2576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PUT2",
          "args": [
            "sp->sp_beacon_period",
            "256"
          ],
          "line": 2541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PUT2",
          "args": [
            "sp->sp_dwell_time",
            "128"
          ],
          "line": 2540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PUT2",
          "args": [
            "sp->sp_beacon_period",
            "0"
          ],
          "line": 2537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PUT2",
          "args": [
            "sp->sp_dwell_time",
            "0x400"
          ],
          "line": 2536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PUT2",
          "args": [
            "sp->sp_beacon_period",
            "1"
          ],
          "line": 2533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PUT2",
          "args": [
            "sp->sp_dwell_time",
            "0x200"
          ],
          "line": 2532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PUT2",
          "args": [
            "sp->sp_frag_thresh",
            "0x7fff"
          ],
          "line": 2528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sp->sp_mac_addr",
            "sc->sc_ecf_startup.e_station_addr",
            "ETHER_ADDR_LEN"
          ],
          "line": 2526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sp->sp_ssid",
            "sc->sc_dnwid",
            "sizeof(sp->sp_ssid)"
          ],
          "line": 2524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "sp5",
            "0",
            "sizeof(*sp5)"
          ],
          "line": 2523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "sp4",
            "0",
            "sizeof(*sp4)"
          ],
          "line": 2521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "sp",
            "0",
            "sizeof(*sp)"
          ],
          "line": 2519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ray_cmd_cancel",
          "args": [
            "sc",
            "SCP_UPD_STARTUP"
          ],
          "line": 2511
        },
        "resolved": true,
        "details": {
          "function_name": "ray_cmd_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2283-2299",
          "snippet": "void\nray_cmd_cancel(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_cmd_cancel 0x%x\\n\", sc->sc_xname, cmdf));\n\n\tsc->sc_scheduled &= ~cmdf;\n\tif ((cmdf & SCP_UPD_MASK) && (sc->sc_scheduled & SCP_UPD_MASK) == 0)\n\t\tsc->sc_scheduled &= ~SCP_UPDATESUBCMD;\n\n\t/* if nothing else needed cancel the timer */\n\tif (sc->sc_scheduled == 0 && sc->sc_timoneed) {\n\t\tcallout_stop(&sc->sc_check_scheduled_ch);\n\t\tsc->sc_timoneed = 0;\n\t}\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tSCP_UPD_MASK\t\t0xff00",
            "#define\tSCP_UPDATESUBCMD\t0x0001",
            "#define\tsc_xname\tsc_dev.dv_xname",
            "#define\tcallout_stop\ttimeout_del"
          ],
          "globals_used": [
            "void ray_cmd_cancel"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSCP_UPD_MASK\t\t0xff00\n#define\tSCP_UPDATESUBCMD\t0x0001\n#define\tsc_xname\tsc_dev.dv_xname\n#define\tcallout_stop\ttimeout_del\n\nvoid ray_cmd_cancel;\n\nvoid\nray_cmd_cancel(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_cmd_cancel 0x%x\\n\", sc->sc_xname, cmdf));\n\n\tsc->sc_scheduled &= ~cmdf;\n\tif ((cmdf & SCP_UPD_MASK) && (sc->sc_scheduled & SCP_UPD_MASK) == 0)\n\t\tsc->sc_scheduled &= ~SCP_UPDATESUBCMD;\n\n\t/* if nothing else needed cancel the timer */\n\tif (sc->sc_scheduled == 0 && sc->sc_timoneed) {\n\t\tcallout_stop(&sc->sc_check_scheduled_ch);\n\t\tsc->sc_timoneed = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: init_startup_params\\n\", sc->sc_xname)"
          ],
          "line": 2509
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSC_BUILD_4\t0x55\n#define\tSCP_UPD_STARTUP\t\t0x0100\n#define\tsc_xname\tsc_dev.dv_xname\n#define\tsc_version\tsc_ecf_startup.e_fw_build_string\n#define\tsc_startup_5\tsc_u.u_params_5\n#define\tsc_startup_4\tsc_u.u_params_4\n\nvoid ray_cmd_cancel;\nvoid ray_download_params;\nint ray_simple_cmd;\n\nvoid\nray_download_params(sc)\n\tstruct ray_softc *sc;\n{\n\tstruct ray_startup_params_head *sp;\n\tstruct ray_startup_params_tail_5 *sp5;\n\tstruct ray_startup_params_tail_4 *sp4;\n\tbus_size_t off;\n\n\tRAY_DPRINTF((\"%s: init_startup_params\\n\", sc->sc_xname));\n\n\tray_cmd_cancel(sc, SCP_UPD_STARTUP);\n\n#define\tPUT2(p, v)\t\\\n\tdo { (p)[0] = ((v >> 8) & 0xff); (p)[1] = (v & 0xff); } while(0)\n\n\tsp = &sc->sc_startup;\n\tsp4 = &sc->sc_startup_4;\n\tsp5 = &sc->sc_startup_5;\n\tmemset(sp, 0, sizeof(*sp));\n\tif (sc->sc_version == SC_BUILD_4)\n\t\tmemset(sp4, 0, sizeof(*sp4));\n\telse\n\t\tmemset(sp5, 0, sizeof(*sp5));\n\tmemcpy(sp->sp_ssid, sc->sc_dnwid, sizeof(sp->sp_ssid));\n\tsp->sp_scan_mode = 0x1;\n\tmemcpy(sp->sp_mac_addr, sc->sc_ecf_startup.e_station_addr,\n\t    ETHER_ADDR_LEN);\n\tPUT2(sp->sp_frag_thresh, 0x7fff);\t/* disabled */\n\tif (sc->sc_version == SC_BUILD_4) {\n#if 1\n\t\t/* linux/fbsd */\n\t\tPUT2(sp->sp_dwell_time, 0x200);\n\t\tPUT2(sp->sp_beacon_period, 1);\n#else\n\t\t/* divined */\n\t\tPUT2(sp->sp_dwell_time, 0x400);\n\t\tPUT2(sp->sp_beacon_period, 0);\n#endif\n\t} else {\n\t\tPUT2(sp->sp_dwell_time, 128);\n\t\tPUT2(sp->sp_beacon_period, 256);\n\t}\n\tsp->sp_dtim_interval = 1;\n#if 0\n\t/* these are the documented defaults for build 5/6 */\n\tsp->sp_max_retry = 0x1f;\n\tsp->sp_ack_timo = 0x86;\n\tsp->sp_sifs = 0x1c;\n#elif 1\n\t/* these were scrounged from the linux driver */\n\tsp->sp_max_retry = 0x07;\n\n\tsp->sp_ack_timo = 0xa3;\n\tsp->sp_sifs = 0x1d;\n#else\n\t/* these were divined */\n\tsp->sp_max_retry = 0x03;\n\n\tsp->sp_ack_timo = 0xa3;\n\tsp->sp_sifs = 0x1d;\n#endif\n#if 0\n\t/* these are the documented defaults for build 5/6 */\n\tsp->sp_difs = 0x82;\n\tsp->sp_pifs = 0;\n#else\n\t/* linux/fbsd */\n\tsp->sp_difs = 0x82;\n\n\tif (sc->sc_version == SC_BUILD_4)\n\t\tsp->sp_pifs = 0xce;\n\telse\n\t\tsp->sp_pifs = 0x4e;\n#endif\n\n\tPUT2(sp->sp_rts_thresh, 0x7fff);\t/* disabled */\n\tif (sc->sc_version == SC_BUILD_4) {\n\t\tPUT2(sp->sp_scan_dwell, 0xfb1e);\n\t\tPUT2(sp->sp_scan_max_dwell, 0xc75c);\n\t} else {\n\t\tPUT2(sp->sp_scan_dwell, 0x4e2);\n\t\tPUT2(sp->sp_scan_max_dwell, 0x38a4);\n\t}\n\tsp->sp_assoc_timo = 0x5;\n\tif (sc->sc_version == SC_BUILD_4) {\n#if 1 /* obsd */\n\t\t/* linux/fbsd */\n\t\tsp->sp_adhoc_scan_cycle = 0x4;\n\t\tsp->sp_infra_scan_cycle = 0x2;\n\t\tsp->sp_infra_super_scan_cycle = 0x4;\n#else\n\t\t/* divined */\n\t\tsp->sp_adhoc_scan_cycle = 0x8;\n\t\tsp->sp_infra_scan_cycle = 0x1;\n\t\tsp->sp_infra_super_scan_cycle = 0x18;\n#endif\n\t} else {\n\t\tsp->sp_adhoc_scan_cycle = 0x8;\n\t\tsp->sp_infra_scan_cycle = 0x2;\n\t\tsp->sp_infra_super_scan_cycle = 0x8;\n\t}\n\tsp->sp_promisc = sc->sc_promisc;\n\tPUT2(sp->sp_uniq_word, 0x0cbd);\n\tif (sc->sc_version == SC_BUILD_4) {\n\t/* XXX whats this value anyway.. the std says 50us */\n\t\t/* XXX sp->sp_slot_time = 0x4e; */\n\t\tsp->sp_slot_time = 0x4e;\n#if 1\n\t\t/*linux/fbsd*/\n\t\tsp->sp_roam_low_snr_thresh = 0xff;\n#else\n\t\t/*divined*/\n\t\tsp->sp_roam_low_snr_thresh = 0x30;\n#endif\n\t} else {\n\t\tsp->sp_slot_time = 0x32;\n\t\tsp->sp_roam_low_snr_thresh = 0xff;\t/* disabled */\n\t}\n#if 1\n\tsp->sp_low_snr_count = 0xff;\t\t/* disabled */\n#else\n\t/* divined -- check */\n\tsp->sp_low_snr_count = 0x07;\t\t/* disabled */\n#endif\n#if 0\n\tsp->sp_infra_missed_beacon_count = 0x2;\n#elif 1\n\t/* linux/fbsd */\n\tsp->sp_infra_missed_beacon_count = 0x5;\n#else\n\t/* divined -- check, looks fishy */\n\tsp->sp_infra_missed_beacon_count = 0x7;\n#endif\n\tsp->sp_adhoc_missed_beacon_count = 0xff;\n\tsp->sp_country_code = sc->sc_dcountrycode;\n\tsp->sp_hop_seq = 0x0b;\n\tif (sc->sc_version == SC_BUILD_4) {\n\t\tsp->sp_hop_seq_len = 0x4e;\n\t\tsp4->sp_cw_max = 0x3f;\t/* single byte on build 4 */\n\t\tsp4->sp_cw_min = 0x0f;\t/* single byte on build 4 */\n\t\tsp4->sp_noise_filter_gain = 0x4;\n\t\tsp4->sp_noise_limit_offset = 0x8;\n\t\tsp4->sp_rssi_thresh_offset = 0x28;\n\t\tsp4->sp_busy_thresh_offset = 0x28;\n\t\tsp4->sp_sync_thresh = 0x07;\n\t\tsp4->sp_test_mode = 0x0;\n\t\tsp4->sp_test_min_chan = 0x2;\n\t\tsp4->sp_test_max_chan = 0x2;\n\t} else {\n\t\tsp->sp_hop_seq_len = 0x4f;\n\t\tPUT2(sp5->sp_cw_max, 0x3f);\n\t\tPUT2(sp5->sp_cw_min, 0x0f);\n\t\tsp5->sp_noise_filter_gain = 0x4;\n\t\tsp5->sp_noise_limit_offset = 0x8;\n\t\tsp5->sp_rssi_thresh_offset = 0x28;\n\t\tsp5->sp_busy_thresh_offset = 0x28;\n\t\tsp5->sp_sync_thresh = 0x07;\n\t\tsp5->sp_test_mode = 0x0;\n\t\tsp5->sp_test_min_chan = 0x2;\n\t\tsp5->sp_test_max_chan = 0x2;\n#if 0\n\t\tsp5->sp_allow_probe_resp = 0x1;\n#else\n\t\tsp5->sp_allow_probe_resp = 0x0;\n#endif\n\t\tsp5->sp_privacy_must_start = 0x0;\n\t\tsp5->sp_privacy_can_join = 0x0;\n\t\tsp5->sp_basic_rate_set[0] = 0x2;\n\t\t    /* 2 = 1Mbps, 3 = old 2Mbps 4 = 2Mbps */\n\t}\n\n\t/* we shouldn't be called with some command pending */\n\tif (!RAY_ECF_READY(sc))\n\t\tpanic(\"ray_download_params busy\");\n\n\t/* write the compatible part */\n\toff = RAY_HOST_TO_ECF_BASE;\n\tray_write_region(sc, off, sp, sizeof(sc->sc_startup));\n\toff += sizeof(sc->sc_startup);\n\tif (sc->sc_version == SC_BUILD_4)\n\t\tray_write_region(sc, off, sp4, sizeof(*sp4));\n\telse\n\t\tray_write_region(sc, off, sp5, sizeof(*sp5));\n\tif (!ray_simple_cmd(sc, RAY_CMD_START_PARAMS, SCP_UPD_STARTUP))\n\t\tpanic(\"ray_download_params issue\");\n}"
  },
  {
    "function_name": "ray_start_assoc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
    "lines": "2479-2489",
    "snippet": "void\nray_start_assoc(sc)\n\tstruct ray_softc *sc;\n{\n\tray_cmd_cancel(sc, SCP_STARTASSOC);\n\tif ((sc->sc_if.if_flags & IFF_RUNNING) == 0)\n\t\treturn;\n\telse if (ray_cmd_is_running(sc, SCP_STARTASSOC))\n\t\treturn;\n\t(void)ray_simple_cmd(sc, RAY_CMD_START_ASSOC, SCP_STARTASSOC);\n}",
    "includes": [
      "#include <dev/pcmcia/if_rayreg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_llc.h>",
      "#include <net/if_media.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/timeout.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [
      "#define\tSCP_STARTASSOC\t\t0x0002",
      "#define\tsc_if\t\tsc_ec.ac_if",
      "#define\tsc_if\t\tsc_ec.ec_if"
    ],
    "globals_used": [
      "void ray_cmd_cancel",
      "int ray_cmd_is_running",
      "int ray_simple_cmd",
      "void ray_start_assoc"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ray_simple_cmd",
          "args": [
            "sc",
            "RAY_CMD_START_ASSOC",
            "SCP_STARTASSOC"
          ],
          "line": 2488
        },
        "resolved": true,
        "details": {
          "function_name": "ray_simple_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2396-2405",
          "snippet": "int\nray_simple_cmd(sc, cmd, track)\n\tstruct ray_softc *sc;\n\tu_int cmd, track;\n{\n\tbus_size_t ccs;\n\n\treturn (ray_alloc_ccs(sc, &ccs, cmd, track) &&\n\t    ray_issue_cmd(sc, ccs, track));\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int ray_alloc_ccs",
            "int ray_issue_cmd",
            "int ray_simple_cmd"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\nint ray_alloc_ccs;\nint ray_issue_cmd;\nint ray_simple_cmd;\n\nint\nray_simple_cmd(sc, cmd, track)\n\tstruct ray_softc *sc;\n\tu_int cmd, track;\n{\n\tbus_size_t ccs;\n\n\treturn (ray_alloc_ccs(sc, &ccs, cmd, track) &&\n\t    ray_issue_cmd(sc, ccs, track));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ray_cmd_is_running",
          "args": [
            "sc",
            "SCP_STARTASSOC"
          ],
          "line": 2486
        },
        "resolved": true,
        "details": {
          "function_name": "ray_cmd_is_running",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2326-2334",
          "snippet": "int\nray_cmd_is_running(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_cmd_is_running 0x%x\\n\", sc->sc_xname, cmdf));\n\n\treturn ((sc->sc_running & cmdf) ? 1 : 0);\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tsc_xname\tsc_dev.dv_xname"
          ],
          "globals_used": [
            "int ray_cmd_is_running"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_xname\tsc_dev.dv_xname\n\nint ray_cmd_is_running;\n\nint\nray_cmd_is_running(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_cmd_is_running 0x%x\\n\", sc->sc_xname, cmdf));\n\n\treturn ((sc->sc_running & cmdf) ? 1 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ray_cmd_cancel",
          "args": [
            "sc",
            "SCP_STARTASSOC"
          ],
          "line": 2483
        },
        "resolved": true,
        "details": {
          "function_name": "ray_cmd_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2283-2299",
          "snippet": "void\nray_cmd_cancel(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_cmd_cancel 0x%x\\n\", sc->sc_xname, cmdf));\n\n\tsc->sc_scheduled &= ~cmdf;\n\tif ((cmdf & SCP_UPD_MASK) && (sc->sc_scheduled & SCP_UPD_MASK) == 0)\n\t\tsc->sc_scheduled &= ~SCP_UPDATESUBCMD;\n\n\t/* if nothing else needed cancel the timer */\n\tif (sc->sc_scheduled == 0 && sc->sc_timoneed) {\n\t\tcallout_stop(&sc->sc_check_scheduled_ch);\n\t\tsc->sc_timoneed = 0;\n\t}\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tSCP_UPD_MASK\t\t0xff00",
            "#define\tSCP_UPDATESUBCMD\t0x0001",
            "#define\tsc_xname\tsc_dev.dv_xname",
            "#define\tcallout_stop\ttimeout_del"
          ],
          "globals_used": [
            "void ray_cmd_cancel"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSCP_UPD_MASK\t\t0xff00\n#define\tSCP_UPDATESUBCMD\t0x0001\n#define\tsc_xname\tsc_dev.dv_xname\n#define\tcallout_stop\ttimeout_del\n\nvoid ray_cmd_cancel;\n\nvoid\nray_cmd_cancel(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_cmd_cancel 0x%x\\n\", sc->sc_xname, cmdf));\n\n\tsc->sc_scheduled &= ~cmdf;\n\tif ((cmdf & SCP_UPD_MASK) && (sc->sc_scheduled & SCP_UPD_MASK) == 0)\n\t\tsc->sc_scheduled &= ~SCP_UPDATESUBCMD;\n\n\t/* if nothing else needed cancel the timer */\n\tif (sc->sc_scheduled == 0 && sc->sc_timoneed) {\n\t\tcallout_stop(&sc->sc_check_scheduled_ch);\n\t\tsc->sc_timoneed = 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSCP_STARTASSOC\t\t0x0002\n#define\tsc_if\t\tsc_ec.ac_if\n#define\tsc_if\t\tsc_ec.ec_if\n\nvoid ray_cmd_cancel;\nint ray_cmd_is_running;\nint ray_simple_cmd;\nvoid ray_start_assoc;\n\nvoid\nray_start_assoc(sc)\n\tstruct ray_softc *sc;\n{\n\tray_cmd_cancel(sc, SCP_STARTASSOC);\n\tif ((sc->sc_if.if_flags & IFF_RUNNING) == 0)\n\t\treturn;\n\telse if (ray_cmd_is_running(sc, SCP_STARTASSOC))\n\t\treturn;\n\t(void)ray_simple_cmd(sc, RAY_CMD_START_ASSOC, SCP_STARTASSOC);\n}"
  },
  {
    "function_name": "ray_report_params",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
    "lines": "2449-2474",
    "snippet": "void\nray_report_params(sc)\n\tstruct ray_softc *sc;\n{\n\tbus_size_t ccs;\n\n\tray_cmd_cancel(sc, SCP_REPORTPARAMS);\n\n\tif (!sc->sc_repreq)\n\t\treturn;\n\n\t/* do the issue check before equality check */\n\tif ((sc->sc_if.if_flags & IFF_RUNNING) == 0)\n\t\treturn;\n\telse if (ray_cmd_is_running(sc, SCP_REPORTPARAMS)) {\n\t\tray_cmd_schedule(sc, SCP_REPORTPARAMS);\n\t\treturn;\n\t} else if (!ray_alloc_ccs(sc, &ccs, RAY_CMD_REPORT_PARAMS,\n\t    SCP_REPORTPARAMS))\n\t\treturn;\n\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_report, c_paramid,\n\t    sc->sc_repreq->r_paramid);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_report, c_nparam, 1);\n\t(void)ray_issue_cmd(sc, ccs, SCP_REPORTPARAMS);\n}",
    "includes": [
      "#include <dev/pcmcia/if_rayreg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_llc.h>",
      "#include <net/if_media.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/timeout.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [
      "#define\tSCP_REPORTPARAMS\t0x0004",
      "#define\tsc_if\t\tsc_ec.ac_if",
      "#define\tsc_if\t\tsc_ec.ec_if"
    ],
    "globals_used": [
      "int ray_alloc_ccs",
      "void ray_cmd_cancel",
      "void ray_cmd_schedule",
      "int ray_cmd_is_running",
      "int ray_issue_cmd",
      "void ray_report_params"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ray_issue_cmd",
          "args": [
            "sc",
            "ccs",
            "SCP_REPORTPARAMS"
          ],
          "line": 2473
        },
        "resolved": true,
        "details": {
          "function_name": "ray_issue_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2362-2391",
          "snippet": "int\nray_issue_cmd(sc, ccs, track)\n\tstruct ray_softc *sc;\n\tbus_size_t ccs;\n\tu_int track;\n{\n\tu_int i;\n\n\tRAY_DPRINTF((\"%s: ray_cmd_issue 0x%x\\n\", sc->sc_xname, track));\n\n\t/*\n\t * XXX other drivers did this, but I think\n\t * what we really want to do is just make sure we don't\n\t * get here or that spinning is ok\n\t */\n\ti = 0;\n\twhile (!RAY_ECF_READY(sc))\n\t\tif (++i > 50) {\n\t\t\tray_free_ccs(sc, ccs);\n\t\t\tif (track)\n\t\t\t\tray_cmd_schedule(sc, track);\n\t\t\treturn (0);\n\t\t}\n\n\tSRAM_WRITE_1(sc, RAY_SCB_CCSI, RAY_GET_INDEX(ccs));\n\tRAY_ECF_START_CMD(sc);\n\tray_cmd_ran(sc, track);\n\n\treturn (1);\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tsc_xname\tsc_dev.dv_xname"
          ],
          "globals_used": [
            "void ray_cmd_schedule",
            "void ray_cmd_ran",
            "u_int8_t ray_free_ccs",
            "int ray_issue_cmd"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_xname\tsc_dev.dv_xname\n\nvoid ray_cmd_schedule;\nvoid ray_cmd_ran;\nu_int8_t ray_free_ccs;\nint ray_issue_cmd;\n\nint\nray_issue_cmd(sc, ccs, track)\n\tstruct ray_softc *sc;\n\tbus_size_t ccs;\n\tu_int track;\n{\n\tu_int i;\n\n\tRAY_DPRINTF((\"%s: ray_cmd_issue 0x%x\\n\", sc->sc_xname, track));\n\n\t/*\n\t * XXX other drivers did this, but I think\n\t * what we really want to do is just make sure we don't\n\t * get here or that spinning is ok\n\t */\n\ti = 0;\n\twhile (!RAY_ECF_READY(sc))\n\t\tif (++i > 50) {\n\t\t\tray_free_ccs(sc, ccs);\n\t\t\tif (track)\n\t\t\t\tray_cmd_schedule(sc, track);\n\t\t\treturn (0);\n\t\t}\n\n\tSRAM_WRITE_1(sc, RAY_SCB_CCSI, RAY_GET_INDEX(ccs));\n\tRAY_ECF_START_CMD(sc);\n\tray_cmd_ran(sc, track);\n\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SRAM_WRITE_FIELD_1",
          "args": [
            "sc",
            "ccs",
            "ray_cmd_report",
            "c_nparam",
            "1"
          ],
          "line": 2472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRAM_WRITE_FIELD_1",
          "args": [
            "sc",
            "ccs",
            "ray_cmd_report",
            "c_paramid",
            "sc->sc_repreq->r_paramid"
          ],
          "line": 2470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ray_alloc_ccs",
          "args": [
            "sc",
            "&ccs",
            "RAY_CMD_REPORT_PARAMS",
            "SCP_REPORTPARAMS"
          ],
          "line": 2466
        },
        "resolved": true,
        "details": {
          "function_name": "ray_alloc_ccs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2184-2221",
          "snippet": "int\nray_alloc_ccs(sc, ccsp, cmd, track)\n\tstruct ray_softc *sc;\n\tbus_size_t *ccsp;\n\tu_int cmd, track;\n{\n\tbus_size_t ccs;\n\tu_int i;\n\n\tRAY_DPRINTF((\"%s: alloc_ccs cmd %d\\n\", sc->sc_xname, cmd));\n\n\t/* for tracked commands, if not ready just set pending */\n\tif (track && !RAY_ECF_READY(sc)) {\n\t\tray_cmd_schedule(sc, track);\n\t\treturn (0);\n\t}\n\n\t/* first scan our inuse array */\n\tfor (i = RAY_CCS_CMD_FIRST; i <= RAY_CCS_CMD_LAST; i++) {\n\t\t/* XXX wonder if we have to probe here to make the card go */\n\t\t(void)SRAM_READ_FIELD_1(sc, RAY_GET_CCS(i), ray_cmd, c_status);\n\t\tif (!sc->sc_ccsinuse[i])\n\t\t\tbreak;\n\t}\n\tif (i > RAY_CCS_CMD_LAST) {\n\t\tif (track)\n\t\t\tray_cmd_schedule(sc, track);\n\t\treturn (0);\n\t}\n\tsc->sc_ccsinuse[i] = 1;\n\tccs = RAY_GET_CCS(i);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_status, RAY_CCS_STATUS_BUSY);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_cmd, cmd);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_link, RAY_CCS_LINK_NULL);\n\n\t*ccsp = ccs;\n\treturn (1);\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tsc_xname\tsc_dev.dv_xname"
          ],
          "globals_used": [
            "int ray_alloc_ccs",
            "void ray_cmd_schedule"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_xname\tsc_dev.dv_xname\n\nint ray_alloc_ccs;\nvoid ray_cmd_schedule;\n\nint\nray_alloc_ccs(sc, ccsp, cmd, track)\n\tstruct ray_softc *sc;\n\tbus_size_t *ccsp;\n\tu_int cmd, track;\n{\n\tbus_size_t ccs;\n\tu_int i;\n\n\tRAY_DPRINTF((\"%s: alloc_ccs cmd %d\\n\", sc->sc_xname, cmd));\n\n\t/* for tracked commands, if not ready just set pending */\n\tif (track && !RAY_ECF_READY(sc)) {\n\t\tray_cmd_schedule(sc, track);\n\t\treturn (0);\n\t}\n\n\t/* first scan our inuse array */\n\tfor (i = RAY_CCS_CMD_FIRST; i <= RAY_CCS_CMD_LAST; i++) {\n\t\t/* XXX wonder if we have to probe here to make the card go */\n\t\t(void)SRAM_READ_FIELD_1(sc, RAY_GET_CCS(i), ray_cmd, c_status);\n\t\tif (!sc->sc_ccsinuse[i])\n\t\t\tbreak;\n\t}\n\tif (i > RAY_CCS_CMD_LAST) {\n\t\tif (track)\n\t\t\tray_cmd_schedule(sc, track);\n\t\treturn (0);\n\t}\n\tsc->sc_ccsinuse[i] = 1;\n\tccs = RAY_GET_CCS(i);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_status, RAY_CCS_STATUS_BUSY);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_cmd, cmd);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_link, RAY_CCS_LINK_NULL);\n\n\t*ccsp = ccs;\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ray_cmd_schedule",
          "args": [
            "sc",
            "SCP_REPORTPARAMS"
          ],
          "line": 2464
        },
        "resolved": true,
        "details": {
          "function_name": "ray_cmd_schedule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2248-2265",
          "snippet": "void\nray_cmd_schedule(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tint track;\n\n\tRAY_DPRINTF((\"%s: ray_cmd_schedule 0x%x\\n\", sc->sc_xname, cmdf));\n\n\ttrack = cmdf;\n\tif ((cmdf & SCP_UPD_MASK) == 0)\n\t\tray_set_pending(sc, track);\n\telse if (ray_cmd_is_running(sc, SCP_UPDATESUBCMD)) {\n\t\t/* don't do timeout mechaniscm if subcmd already going */\n\t\tsc->sc_scheduled |= cmdf;\n\t} else\n\t\tray_set_pending(sc, cmdf | SCP_UPDATESUBCMD);\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tSCP_UPD_MASK\t\t0xff00",
            "#define\tSCP_UPDATESUBCMD\t0x0001",
            "#define\tsc_xname\tsc_dev.dv_xname"
          ],
          "globals_used": [
            "void ray_cmd_schedule",
            "int ray_cmd_is_running",
            "void ray_set_pending"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSCP_UPD_MASK\t\t0xff00\n#define\tSCP_UPDATESUBCMD\t0x0001\n#define\tsc_xname\tsc_dev.dv_xname\n\nvoid ray_cmd_schedule;\nint ray_cmd_is_running;\nvoid ray_set_pending;\n\nvoid\nray_cmd_schedule(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tint track;\n\n\tRAY_DPRINTF((\"%s: ray_cmd_schedule 0x%x\\n\", sc->sc_xname, cmdf));\n\n\ttrack = cmdf;\n\tif ((cmdf & SCP_UPD_MASK) == 0)\n\t\tray_set_pending(sc, track);\n\telse if (ray_cmd_is_running(sc, SCP_UPDATESUBCMD)) {\n\t\t/* don't do timeout mechaniscm if subcmd already going */\n\t\tsc->sc_scheduled |= cmdf;\n\t} else\n\t\tray_set_pending(sc, cmdf | SCP_UPDATESUBCMD);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ray_cmd_is_running",
          "args": [
            "sc",
            "SCP_REPORTPARAMS"
          ],
          "line": 2463
        },
        "resolved": true,
        "details": {
          "function_name": "ray_cmd_is_running",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2326-2334",
          "snippet": "int\nray_cmd_is_running(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_cmd_is_running 0x%x\\n\", sc->sc_xname, cmdf));\n\n\treturn ((sc->sc_running & cmdf) ? 1 : 0);\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tsc_xname\tsc_dev.dv_xname"
          ],
          "globals_used": [
            "int ray_cmd_is_running"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_xname\tsc_dev.dv_xname\n\nint ray_cmd_is_running;\n\nint\nray_cmd_is_running(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_cmd_is_running 0x%x\\n\", sc->sc_xname, cmdf));\n\n\treturn ((sc->sc_running & cmdf) ? 1 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ray_cmd_cancel",
          "args": [
            "sc",
            "SCP_REPORTPARAMS"
          ],
          "line": 2455
        },
        "resolved": true,
        "details": {
          "function_name": "ray_cmd_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2283-2299",
          "snippet": "void\nray_cmd_cancel(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_cmd_cancel 0x%x\\n\", sc->sc_xname, cmdf));\n\n\tsc->sc_scheduled &= ~cmdf;\n\tif ((cmdf & SCP_UPD_MASK) && (sc->sc_scheduled & SCP_UPD_MASK) == 0)\n\t\tsc->sc_scheduled &= ~SCP_UPDATESUBCMD;\n\n\t/* if nothing else needed cancel the timer */\n\tif (sc->sc_scheduled == 0 && sc->sc_timoneed) {\n\t\tcallout_stop(&sc->sc_check_scheduled_ch);\n\t\tsc->sc_timoneed = 0;\n\t}\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tSCP_UPD_MASK\t\t0xff00",
            "#define\tSCP_UPDATESUBCMD\t0x0001",
            "#define\tsc_xname\tsc_dev.dv_xname",
            "#define\tcallout_stop\ttimeout_del"
          ],
          "globals_used": [
            "void ray_cmd_cancel"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSCP_UPD_MASK\t\t0xff00\n#define\tSCP_UPDATESUBCMD\t0x0001\n#define\tsc_xname\tsc_dev.dv_xname\n#define\tcallout_stop\ttimeout_del\n\nvoid ray_cmd_cancel;\n\nvoid\nray_cmd_cancel(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_cmd_cancel 0x%x\\n\", sc->sc_xname, cmdf));\n\n\tsc->sc_scheduled &= ~cmdf;\n\tif ((cmdf & SCP_UPD_MASK) && (sc->sc_scheduled & SCP_UPD_MASK) == 0)\n\t\tsc->sc_scheduled &= ~SCP_UPDATESUBCMD;\n\n\t/* if nothing else needed cancel the timer */\n\tif (sc->sc_scheduled == 0 && sc->sc_timoneed) {\n\t\tcallout_stop(&sc->sc_check_scheduled_ch);\n\t\tsc->sc_timoneed = 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSCP_REPORTPARAMS\t0x0004\n#define\tsc_if\t\tsc_ec.ac_if\n#define\tsc_if\t\tsc_ec.ec_if\n\nint ray_alloc_ccs;\nvoid ray_cmd_cancel;\nvoid ray_cmd_schedule;\nint ray_cmd_is_running;\nint ray_issue_cmd;\nvoid ray_report_params;\n\nvoid\nray_report_params(sc)\n\tstruct ray_softc *sc;\n{\n\tbus_size_t ccs;\n\n\tray_cmd_cancel(sc, SCP_REPORTPARAMS);\n\n\tif (!sc->sc_repreq)\n\t\treturn;\n\n\t/* do the issue check before equality check */\n\tif ((sc->sc_if.if_flags & IFF_RUNNING) == 0)\n\t\treturn;\n\telse if (ray_cmd_is_running(sc, SCP_REPORTPARAMS)) {\n\t\tray_cmd_schedule(sc, SCP_REPORTPARAMS);\n\t\treturn;\n\t} else if (!ray_alloc_ccs(sc, &ccs, RAY_CMD_REPORT_PARAMS,\n\t    SCP_REPORTPARAMS))\n\t\treturn;\n\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_report, c_paramid,\n\t    sc->sc_repreq->r_paramid);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_report, c_nparam, 1);\n\t(void)ray_issue_cmd(sc, ccs, SCP_REPORTPARAMS);\n}"
  },
  {
    "function_name": "ray_update_subcmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
    "lines": "2414-2444",
    "snippet": "void\nray_update_subcmd(sc)\n\tstruct ray_softc *sc;\n{\n\tint submask, i;\n\n\tRAY_DPRINTF((\"%s: ray_update_subcmd\\n\", sc->sc_xname));\n\n\tray_cmd_cancel(sc, SCP_UPDATESUBCMD);\n\tif ((sc->sc_if.if_flags & IFF_RUNNING) == 0)\n\t\treturn;\n\tsubmask = SCP_UPD_FIRST;\n\tfor (i = 0; i < ray_nsubcmdtab; submask <<= 1, i++) {\n\t\tif ((sc->sc_scheduled & SCP_UPD_MASK) == 0)\n\t\t\tbreak;\n\t\t/* when done the next command will be scheduled */\n\t\tif (ray_cmd_is_running(sc, SCP_UPDATESUBCMD))\n\t\t\tbreak;\n\t\tif (!RAY_ECF_READY(sc))\n\t\t\tbreak;\n\t\t/*\n\t\t * give priority to LSB -- e.g., if previous loop reschuled\n\t\t * doing this command after calling the function won't catch\n\t\t * if a later command sets an earlier bit\n\t\t */\n\t\tif (sc->sc_scheduled & ((submask - 1) & SCP_UPD_MASK))\n\t\t\tbreak;\n\t\tif (sc->sc_scheduled & submask)\n\t\t\t(*ray_subcmdtab[i])(sc);\n\t}\n}",
    "includes": [
      "#include <dev/pcmcia/if_rayreg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_llc.h>",
      "#include <net/if_media.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/timeout.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [
      "#define\tSCP_UPD_MASK\t\t0xff00",
      "#define\tSCP_UPD_FIRST\t\t0x0100",
      "#define\tSCP_UPDATESUBCMD\t0x0001",
      "#define\tsc_xname\tsc_dev.dv_xname",
      "#define\tsc_if\t\tsc_ec.ac_if",
      "#define\tsc_if\t\tsc_ec.ec_if"
    ],
    "globals_used": [
      "void ray_cmd_cancel",
      "int ray_cmd_is_running",
      "void ray_update_subcmd",
      "static const ray_cmd_func_t ray_subcmdtab[] = {\n\tray_download_params,\t/* SCP_UPD_STARTUP */\n\tray_start_join_net,\t/* SCP_UPD_STARTJOIN */\n\tray_update_promisc,\t/* SCP_UPD_PROMISC */\n\tray_update_mcast,\t/* SCP_UPD_MCAST */\n\tray_update_params\t/* SCP_UPD_UPDATEPARAMS */\n};",
      "static const int ray_nsubcmdtab = sizeof(ray_subcmdtab) / sizeof(*ray_subcmdtab);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc"
          ],
          "line": 2442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_ECF_READY",
          "args": [
            "sc"
          ],
          "line": 2432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ray_cmd_is_running",
          "args": [
            "sc",
            "SCP_UPDATESUBCMD"
          ],
          "line": 2430
        },
        "resolved": true,
        "details": {
          "function_name": "ray_cmd_is_running",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2326-2334",
          "snippet": "int\nray_cmd_is_running(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_cmd_is_running 0x%x\\n\", sc->sc_xname, cmdf));\n\n\treturn ((sc->sc_running & cmdf) ? 1 : 0);\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tsc_xname\tsc_dev.dv_xname"
          ],
          "globals_used": [
            "int ray_cmd_is_running"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_xname\tsc_dev.dv_xname\n\nint ray_cmd_is_running;\n\nint\nray_cmd_is_running(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_cmd_is_running 0x%x\\n\", sc->sc_xname, cmdf));\n\n\treturn ((sc->sc_running & cmdf) ? 1 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ray_cmd_cancel",
          "args": [
            "sc",
            "SCP_UPDATESUBCMD"
          ],
          "line": 2422
        },
        "resolved": true,
        "details": {
          "function_name": "ray_cmd_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2283-2299",
          "snippet": "void\nray_cmd_cancel(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_cmd_cancel 0x%x\\n\", sc->sc_xname, cmdf));\n\n\tsc->sc_scheduled &= ~cmdf;\n\tif ((cmdf & SCP_UPD_MASK) && (sc->sc_scheduled & SCP_UPD_MASK) == 0)\n\t\tsc->sc_scheduled &= ~SCP_UPDATESUBCMD;\n\n\t/* if nothing else needed cancel the timer */\n\tif (sc->sc_scheduled == 0 && sc->sc_timoneed) {\n\t\tcallout_stop(&sc->sc_check_scheduled_ch);\n\t\tsc->sc_timoneed = 0;\n\t}\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tSCP_UPD_MASK\t\t0xff00",
            "#define\tSCP_UPDATESUBCMD\t0x0001",
            "#define\tsc_xname\tsc_dev.dv_xname",
            "#define\tcallout_stop\ttimeout_del"
          ],
          "globals_used": [
            "void ray_cmd_cancel"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSCP_UPD_MASK\t\t0xff00\n#define\tSCP_UPDATESUBCMD\t0x0001\n#define\tsc_xname\tsc_dev.dv_xname\n#define\tcallout_stop\ttimeout_del\n\nvoid ray_cmd_cancel;\n\nvoid\nray_cmd_cancel(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_cmd_cancel 0x%x\\n\", sc->sc_xname, cmdf));\n\n\tsc->sc_scheduled &= ~cmdf;\n\tif ((cmdf & SCP_UPD_MASK) && (sc->sc_scheduled & SCP_UPD_MASK) == 0)\n\t\tsc->sc_scheduled &= ~SCP_UPDATESUBCMD;\n\n\t/* if nothing else needed cancel the timer */\n\tif (sc->sc_scheduled == 0 && sc->sc_timoneed) {\n\t\tcallout_stop(&sc->sc_check_scheduled_ch);\n\t\tsc->sc_timoneed = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: ray_update_subcmd\\n\", sc->sc_xname)"
          ],
          "line": 2420
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSCP_UPD_MASK\t\t0xff00\n#define\tSCP_UPD_FIRST\t\t0x0100\n#define\tSCP_UPDATESUBCMD\t0x0001\n#define\tsc_xname\tsc_dev.dv_xname\n#define\tsc_if\t\tsc_ec.ac_if\n#define\tsc_if\t\tsc_ec.ec_if\n\nvoid ray_cmd_cancel;\nint ray_cmd_is_running;\nvoid ray_update_subcmd;\nstatic const ray_cmd_func_t ray_subcmdtab[] = {\n\tray_download_params,\t/* SCP_UPD_STARTUP */\n\tray_start_join_net,\t/* SCP_UPD_STARTJOIN */\n\tray_update_promisc,\t/* SCP_UPD_PROMISC */\n\tray_update_mcast,\t/* SCP_UPD_MCAST */\n\tray_update_params\t/* SCP_UPD_UPDATEPARAMS */\n};\nstatic const int ray_nsubcmdtab = sizeof(ray_subcmdtab) / sizeof(*ray_subcmdtab);\n\nvoid\nray_update_subcmd(sc)\n\tstruct ray_softc *sc;\n{\n\tint submask, i;\n\n\tRAY_DPRINTF((\"%s: ray_update_subcmd\\n\", sc->sc_xname));\n\n\tray_cmd_cancel(sc, SCP_UPDATESUBCMD);\n\tif ((sc->sc_if.if_flags & IFF_RUNNING) == 0)\n\t\treturn;\n\tsubmask = SCP_UPD_FIRST;\n\tfor (i = 0; i < ray_nsubcmdtab; submask <<= 1, i++) {\n\t\tif ((sc->sc_scheduled & SCP_UPD_MASK) == 0)\n\t\t\tbreak;\n\t\t/* when done the next command will be scheduled */\n\t\tif (ray_cmd_is_running(sc, SCP_UPDATESUBCMD))\n\t\t\tbreak;\n\t\tif (!RAY_ECF_READY(sc))\n\t\t\tbreak;\n\t\t/*\n\t\t * give priority to LSB -- e.g., if previous loop reschuled\n\t\t * doing this command after calling the function won't catch\n\t\t * if a later command sets an earlier bit\n\t\t */\n\t\tif (sc->sc_scheduled & ((submask - 1) & SCP_UPD_MASK))\n\t\t\tbreak;\n\t\tif (sc->sc_scheduled & submask)\n\t\t\t(*ray_subcmdtab[i])(sc);\n\t}\n}"
  },
  {
    "function_name": "ray_simple_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
    "lines": "2396-2405",
    "snippet": "int\nray_simple_cmd(sc, cmd, track)\n\tstruct ray_softc *sc;\n\tu_int cmd, track;\n{\n\tbus_size_t ccs;\n\n\treturn (ray_alloc_ccs(sc, &ccs, cmd, track) &&\n\t    ray_issue_cmd(sc, ccs, track));\n}",
    "includes": [
      "#include <dev/pcmcia/if_rayreg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_llc.h>",
      "#include <net/if_media.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/timeout.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int ray_alloc_ccs",
      "int ray_issue_cmd",
      "int ray_simple_cmd"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ray_issue_cmd",
          "args": [
            "sc",
            "ccs",
            "track"
          ],
          "line": 2404
        },
        "resolved": true,
        "details": {
          "function_name": "ray_issue_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2362-2391",
          "snippet": "int\nray_issue_cmd(sc, ccs, track)\n\tstruct ray_softc *sc;\n\tbus_size_t ccs;\n\tu_int track;\n{\n\tu_int i;\n\n\tRAY_DPRINTF((\"%s: ray_cmd_issue 0x%x\\n\", sc->sc_xname, track));\n\n\t/*\n\t * XXX other drivers did this, but I think\n\t * what we really want to do is just make sure we don't\n\t * get here or that spinning is ok\n\t */\n\ti = 0;\n\twhile (!RAY_ECF_READY(sc))\n\t\tif (++i > 50) {\n\t\t\tray_free_ccs(sc, ccs);\n\t\t\tif (track)\n\t\t\t\tray_cmd_schedule(sc, track);\n\t\t\treturn (0);\n\t\t}\n\n\tSRAM_WRITE_1(sc, RAY_SCB_CCSI, RAY_GET_INDEX(ccs));\n\tRAY_ECF_START_CMD(sc);\n\tray_cmd_ran(sc, track);\n\n\treturn (1);\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tsc_xname\tsc_dev.dv_xname"
          ],
          "globals_used": [
            "void ray_cmd_schedule",
            "void ray_cmd_ran",
            "u_int8_t ray_free_ccs",
            "int ray_issue_cmd"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_xname\tsc_dev.dv_xname\n\nvoid ray_cmd_schedule;\nvoid ray_cmd_ran;\nu_int8_t ray_free_ccs;\nint ray_issue_cmd;\n\nint\nray_issue_cmd(sc, ccs, track)\n\tstruct ray_softc *sc;\n\tbus_size_t ccs;\n\tu_int track;\n{\n\tu_int i;\n\n\tRAY_DPRINTF((\"%s: ray_cmd_issue 0x%x\\n\", sc->sc_xname, track));\n\n\t/*\n\t * XXX other drivers did this, but I think\n\t * what we really want to do is just make sure we don't\n\t * get here or that spinning is ok\n\t */\n\ti = 0;\n\twhile (!RAY_ECF_READY(sc))\n\t\tif (++i > 50) {\n\t\t\tray_free_ccs(sc, ccs);\n\t\t\tif (track)\n\t\t\t\tray_cmd_schedule(sc, track);\n\t\t\treturn (0);\n\t\t}\n\n\tSRAM_WRITE_1(sc, RAY_SCB_CCSI, RAY_GET_INDEX(ccs));\n\tRAY_ECF_START_CMD(sc);\n\tray_cmd_ran(sc, track);\n\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ray_alloc_ccs",
          "args": [
            "sc",
            "&ccs",
            "cmd",
            "track"
          ],
          "line": 2403
        },
        "resolved": true,
        "details": {
          "function_name": "ray_alloc_ccs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2184-2221",
          "snippet": "int\nray_alloc_ccs(sc, ccsp, cmd, track)\n\tstruct ray_softc *sc;\n\tbus_size_t *ccsp;\n\tu_int cmd, track;\n{\n\tbus_size_t ccs;\n\tu_int i;\n\n\tRAY_DPRINTF((\"%s: alloc_ccs cmd %d\\n\", sc->sc_xname, cmd));\n\n\t/* for tracked commands, if not ready just set pending */\n\tif (track && !RAY_ECF_READY(sc)) {\n\t\tray_cmd_schedule(sc, track);\n\t\treturn (0);\n\t}\n\n\t/* first scan our inuse array */\n\tfor (i = RAY_CCS_CMD_FIRST; i <= RAY_CCS_CMD_LAST; i++) {\n\t\t/* XXX wonder if we have to probe here to make the card go */\n\t\t(void)SRAM_READ_FIELD_1(sc, RAY_GET_CCS(i), ray_cmd, c_status);\n\t\tif (!sc->sc_ccsinuse[i])\n\t\t\tbreak;\n\t}\n\tif (i > RAY_CCS_CMD_LAST) {\n\t\tif (track)\n\t\t\tray_cmd_schedule(sc, track);\n\t\treturn (0);\n\t}\n\tsc->sc_ccsinuse[i] = 1;\n\tccs = RAY_GET_CCS(i);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_status, RAY_CCS_STATUS_BUSY);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_cmd, cmd);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_link, RAY_CCS_LINK_NULL);\n\n\t*ccsp = ccs;\n\treturn (1);\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tsc_xname\tsc_dev.dv_xname"
          ],
          "globals_used": [
            "int ray_alloc_ccs",
            "void ray_cmd_schedule"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_xname\tsc_dev.dv_xname\n\nint ray_alloc_ccs;\nvoid ray_cmd_schedule;\n\nint\nray_alloc_ccs(sc, ccsp, cmd, track)\n\tstruct ray_softc *sc;\n\tbus_size_t *ccsp;\n\tu_int cmd, track;\n{\n\tbus_size_t ccs;\n\tu_int i;\n\n\tRAY_DPRINTF((\"%s: alloc_ccs cmd %d\\n\", sc->sc_xname, cmd));\n\n\t/* for tracked commands, if not ready just set pending */\n\tif (track && !RAY_ECF_READY(sc)) {\n\t\tray_cmd_schedule(sc, track);\n\t\treturn (0);\n\t}\n\n\t/* first scan our inuse array */\n\tfor (i = RAY_CCS_CMD_FIRST; i <= RAY_CCS_CMD_LAST; i++) {\n\t\t/* XXX wonder if we have to probe here to make the card go */\n\t\t(void)SRAM_READ_FIELD_1(sc, RAY_GET_CCS(i), ray_cmd, c_status);\n\t\tif (!sc->sc_ccsinuse[i])\n\t\t\tbreak;\n\t}\n\tif (i > RAY_CCS_CMD_LAST) {\n\t\tif (track)\n\t\t\tray_cmd_schedule(sc, track);\n\t\treturn (0);\n\t}\n\tsc->sc_ccsinuse[i] = 1;\n\tccs = RAY_GET_CCS(i);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_status, RAY_CCS_STATUS_BUSY);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_cmd, cmd);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_link, RAY_CCS_LINK_NULL);\n\n\t*ccsp = ccs;\n\treturn (1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\nint ray_alloc_ccs;\nint ray_issue_cmd;\nint ray_simple_cmd;\n\nint\nray_simple_cmd(sc, cmd, track)\n\tstruct ray_softc *sc;\n\tu_int cmd, track;\n{\n\tbus_size_t ccs;\n\n\treturn (ray_alloc_ccs(sc, &ccs, cmd, track) &&\n\t    ray_issue_cmd(sc, ccs, track));\n}"
  },
  {
    "function_name": "ray_issue_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
    "lines": "2362-2391",
    "snippet": "int\nray_issue_cmd(sc, ccs, track)\n\tstruct ray_softc *sc;\n\tbus_size_t ccs;\n\tu_int track;\n{\n\tu_int i;\n\n\tRAY_DPRINTF((\"%s: ray_cmd_issue 0x%x\\n\", sc->sc_xname, track));\n\n\t/*\n\t * XXX other drivers did this, but I think\n\t * what we really want to do is just make sure we don't\n\t * get here or that spinning is ok\n\t */\n\ti = 0;\n\twhile (!RAY_ECF_READY(sc))\n\t\tif (++i > 50) {\n\t\t\tray_free_ccs(sc, ccs);\n\t\t\tif (track)\n\t\t\t\tray_cmd_schedule(sc, track);\n\t\t\treturn (0);\n\t\t}\n\n\tSRAM_WRITE_1(sc, RAY_SCB_CCSI, RAY_GET_INDEX(ccs));\n\tRAY_ECF_START_CMD(sc);\n\tray_cmd_ran(sc, track);\n\n\treturn (1);\n}",
    "includes": [
      "#include <dev/pcmcia/if_rayreg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_llc.h>",
      "#include <net/if_media.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/timeout.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [
      "#define\tsc_xname\tsc_dev.dv_xname"
    ],
    "globals_used": [
      "void ray_cmd_schedule",
      "void ray_cmd_ran",
      "u_int8_t ray_free_ccs",
      "int ray_issue_cmd"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ray_cmd_ran",
          "args": [
            "sc",
            "track"
          ],
          "line": 2388
        },
        "resolved": true,
        "details": {
          "function_name": "ray_cmd_ran",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2304-2321",
          "snippet": "void\nray_cmd_ran(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_cmd_ran 0x%x\\n\", sc->sc_xname, cmdf));\n\n\tif (cmdf & SCP_UPD_MASK)\n\t\tsc->sc_running |= cmdf | SCP_UPDATESUBCMD;\n\telse\n\t\tsc->sc_running |= cmdf;\n\n\tif ((cmdf & SCP_TIMOCHECK_CMD_MASK) && !sc->sc_timocheck) {\n\t\tcallout_reset(&sc->sc_check_ccs_ch, RAY_CHECK_CCS_TIMEOUT,\n\t\t    ray_check_ccs, sc);\n\t\tsc->sc_timocheck = 1;\n\t}\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tSCP_TIMOCHECK_CMD_MASK\t\\\n\t(SCP_UPD_UPDATEPARAMS | SCP_UPD_STARTUP | SCP_UPD_MCAST | \\\n\tSCP_UPD_PROMISC)",
            "#define\tSCP_UPD_MASK\t\t0xff00",
            "#define\tSCP_UPDATESUBCMD\t0x0001",
            "#define\tsc_xname\tsc_dev.dv_xname",
            "#define\tRAY_CHECK_CCS_TIMEOUT\t(hz / 2)"
          ],
          "globals_used": [
            "void ray_check_ccs",
            "void ray_cmd_ran"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSCP_TIMOCHECK_CMD_MASK\t\\\n\t(SCP_UPD_UPDATEPARAMS | SCP_UPD_STARTUP | SCP_UPD_MCAST | \\\n\tSCP_UPD_PROMISC)\n#define\tSCP_UPD_MASK\t\t0xff00\n#define\tSCP_UPDATESUBCMD\t0x0001\n#define\tsc_xname\tsc_dev.dv_xname\n#define\tRAY_CHECK_CCS_TIMEOUT\t(hz / 2)\n\nvoid ray_check_ccs;\nvoid ray_cmd_ran;\n\nvoid\nray_cmd_ran(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_cmd_ran 0x%x\\n\", sc->sc_xname, cmdf));\n\n\tif (cmdf & SCP_UPD_MASK)\n\t\tsc->sc_running |= cmdf | SCP_UPDATESUBCMD;\n\telse\n\t\tsc->sc_running |= cmdf;\n\n\tif ((cmdf & SCP_TIMOCHECK_CMD_MASK) && !sc->sc_timocheck) {\n\t\tcallout_reset(&sc->sc_check_ccs_ch, RAY_CHECK_CCS_TIMEOUT,\n\t\t    ray_check_ccs, sc);\n\t\tsc->sc_timocheck = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RAY_ECF_START_CMD",
          "args": [
            "sc"
          ],
          "line": 2387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRAM_WRITE_1",
          "args": [
            "sc",
            "RAY_SCB_CCSI",
            "RAY_GET_INDEX(ccs)"
          ],
          "line": 2386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_GET_INDEX",
          "args": [
            "ccs"
          ],
          "line": 2386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ray_cmd_schedule",
          "args": [
            "sc",
            "track"
          ],
          "line": 2382
        },
        "resolved": true,
        "details": {
          "function_name": "ray_cmd_schedule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2248-2265",
          "snippet": "void\nray_cmd_schedule(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tint track;\n\n\tRAY_DPRINTF((\"%s: ray_cmd_schedule 0x%x\\n\", sc->sc_xname, cmdf));\n\n\ttrack = cmdf;\n\tif ((cmdf & SCP_UPD_MASK) == 0)\n\t\tray_set_pending(sc, track);\n\telse if (ray_cmd_is_running(sc, SCP_UPDATESUBCMD)) {\n\t\t/* don't do timeout mechaniscm if subcmd already going */\n\t\tsc->sc_scheduled |= cmdf;\n\t} else\n\t\tray_set_pending(sc, cmdf | SCP_UPDATESUBCMD);\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tSCP_UPD_MASK\t\t0xff00",
            "#define\tSCP_UPDATESUBCMD\t0x0001",
            "#define\tsc_xname\tsc_dev.dv_xname"
          ],
          "globals_used": [
            "void ray_cmd_schedule",
            "int ray_cmd_is_running",
            "void ray_set_pending"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSCP_UPD_MASK\t\t0xff00\n#define\tSCP_UPDATESUBCMD\t0x0001\n#define\tsc_xname\tsc_dev.dv_xname\n\nvoid ray_cmd_schedule;\nint ray_cmd_is_running;\nvoid ray_set_pending;\n\nvoid\nray_cmd_schedule(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tint track;\n\n\tRAY_DPRINTF((\"%s: ray_cmd_schedule 0x%x\\n\", sc->sc_xname, cmdf));\n\n\ttrack = cmdf;\n\tif ((cmdf & SCP_UPD_MASK) == 0)\n\t\tray_set_pending(sc, track);\n\telse if (ray_cmd_is_running(sc, SCP_UPDATESUBCMD)) {\n\t\t/* don't do timeout mechaniscm if subcmd already going */\n\t\tsc->sc_scheduled |= cmdf;\n\t} else\n\t\tray_set_pending(sc, cmdf | SCP_UPDATESUBCMD);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ray_free_ccs",
          "args": [
            "sc",
            "ccs"
          ],
          "line": 2380
        },
        "resolved": true,
        "details": {
          "function_name": "ray_free_ccs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2156-2172",
          "snippet": "u_int8_t\nray_free_ccs(sc, ccs)\n\tstruct ray_softc *sc;\n\tbus_size_t ccs;\n{\n\tu_int8_t stat;\n\n\tRAY_DPRINTF((\"%s: free_ccs idx %ld\\n\", sc->sc_xname,\n\t    RAY_GET_INDEX(ccs)));\n\n\tstat = SRAM_READ_FIELD_1(sc, ccs, ray_cmd, c_status);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_status, RAY_CCS_STATUS_FREE);\n\tif (ccs <= RAY_GET_CCS(RAY_CCS_LAST))\n\t\tsc->sc_ccsinuse[RAY_GET_INDEX(ccs)] = 0;\n\n\treturn (stat);\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tsc_xname\tsc_dev.dv_xname"
          ],
          "globals_used": [
            "u_int8_t ray_free_ccs"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_xname\tsc_dev.dv_xname\n\nu_int8_t ray_free_ccs;\n\nu_int8_t\nray_free_ccs(sc, ccs)\n\tstruct ray_softc *sc;\n\tbus_size_t ccs;\n{\n\tu_int8_t stat;\n\n\tRAY_DPRINTF((\"%s: free_ccs idx %ld\\n\", sc->sc_xname,\n\t    RAY_GET_INDEX(ccs)));\n\n\tstat = SRAM_READ_FIELD_1(sc, ccs, ray_cmd, c_status);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_status, RAY_CCS_STATUS_FREE);\n\tif (ccs <= RAY_GET_CCS(RAY_CCS_LAST))\n\t\tsc->sc_ccsinuse[RAY_GET_INDEX(ccs)] = 0;\n\n\treturn (stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RAY_ECF_READY",
          "args": [
            "sc"
          ],
          "line": 2378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: ray_cmd_issue 0x%x\\n\", sc->sc_xname, track)"
          ],
          "line": 2370
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_xname\tsc_dev.dv_xname\n\nvoid ray_cmd_schedule;\nvoid ray_cmd_ran;\nu_int8_t ray_free_ccs;\nint ray_issue_cmd;\n\nint\nray_issue_cmd(sc, ccs, track)\n\tstruct ray_softc *sc;\n\tbus_size_t ccs;\n\tu_int track;\n{\n\tu_int i;\n\n\tRAY_DPRINTF((\"%s: ray_cmd_issue 0x%x\\n\", sc->sc_xname, track));\n\n\t/*\n\t * XXX other drivers did this, but I think\n\t * what we really want to do is just make sure we don't\n\t * get here or that spinning is ok\n\t */\n\ti = 0;\n\twhile (!RAY_ECF_READY(sc))\n\t\tif (++i > 50) {\n\t\t\tray_free_ccs(sc, ccs);\n\t\t\tif (track)\n\t\t\t\tray_cmd_schedule(sc, track);\n\t\t\treturn (0);\n\t\t}\n\n\tSRAM_WRITE_1(sc, RAY_SCB_CCSI, RAY_GET_INDEX(ccs));\n\tRAY_ECF_START_CMD(sc);\n\tray_cmd_ran(sc, track);\n\n\treturn (1);\n}"
  },
  {
    "function_name": "ray_cmd_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
    "lines": "2339-2356",
    "snippet": "void\nray_cmd_done(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_cmd_done 0x%x\\n\", sc->sc_xname, cmdf));\n\n\tsc->sc_running &= ~cmdf;\n\tif (cmdf & SCP_UPD_MASK) {\n\t\tsc->sc_running &= ~SCP_UPDATESUBCMD;\n\t\tif (sc->sc_scheduled & SCP_UPD_MASK)\n\t\t\tray_cmd_schedule(sc, sc->sc_scheduled & SCP_UPD_MASK);\n\t}\n\tif ((sc->sc_running & SCP_TIMOCHECK_CMD_MASK) == 0 && sc->sc_timocheck){\n\t\tcallout_stop(&sc->sc_check_ccs_ch);\n\t\tsc->sc_timocheck = 0;\n\t}\n}",
    "includes": [
      "#include <dev/pcmcia/if_rayreg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_llc.h>",
      "#include <net/if_media.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/timeout.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [
      "#define\tSCP_TIMOCHECK_CMD_MASK\t\\\n\t(SCP_UPD_UPDATEPARAMS | SCP_UPD_STARTUP | SCP_UPD_MCAST | \\\n\tSCP_UPD_PROMISC)",
      "#define\tSCP_UPD_MASK\t\t0xff00",
      "#define\tSCP_UPDATESUBCMD\t0x0001",
      "#define\tsc_xname\tsc_dev.dv_xname",
      "#define\tcallout_stop\ttimeout_del"
    ],
    "globals_used": [
      "void ray_cmd_schedule",
      "void ray_cmd_done"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "callout_stop",
          "args": [
            "&sc->sc_check_ccs_ch"
          ],
          "line": 2353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ray_cmd_schedule",
          "args": [
            "sc",
            "sc->sc_scheduled & SCP_UPD_MASK"
          ],
          "line": 2350
        },
        "resolved": true,
        "details": {
          "function_name": "ray_cmd_schedule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2248-2265",
          "snippet": "void\nray_cmd_schedule(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tint track;\n\n\tRAY_DPRINTF((\"%s: ray_cmd_schedule 0x%x\\n\", sc->sc_xname, cmdf));\n\n\ttrack = cmdf;\n\tif ((cmdf & SCP_UPD_MASK) == 0)\n\t\tray_set_pending(sc, track);\n\telse if (ray_cmd_is_running(sc, SCP_UPDATESUBCMD)) {\n\t\t/* don't do timeout mechaniscm if subcmd already going */\n\t\tsc->sc_scheduled |= cmdf;\n\t} else\n\t\tray_set_pending(sc, cmdf | SCP_UPDATESUBCMD);\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tSCP_UPD_MASK\t\t0xff00",
            "#define\tSCP_UPDATESUBCMD\t0x0001",
            "#define\tsc_xname\tsc_dev.dv_xname"
          ],
          "globals_used": [
            "void ray_cmd_schedule",
            "int ray_cmd_is_running",
            "void ray_set_pending"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSCP_UPD_MASK\t\t0xff00\n#define\tSCP_UPDATESUBCMD\t0x0001\n#define\tsc_xname\tsc_dev.dv_xname\n\nvoid ray_cmd_schedule;\nint ray_cmd_is_running;\nvoid ray_set_pending;\n\nvoid\nray_cmd_schedule(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tint track;\n\n\tRAY_DPRINTF((\"%s: ray_cmd_schedule 0x%x\\n\", sc->sc_xname, cmdf));\n\n\ttrack = cmdf;\n\tif ((cmdf & SCP_UPD_MASK) == 0)\n\t\tray_set_pending(sc, track);\n\telse if (ray_cmd_is_running(sc, SCP_UPDATESUBCMD)) {\n\t\t/* don't do timeout mechaniscm if subcmd already going */\n\t\tsc->sc_scheduled |= cmdf;\n\t} else\n\t\tray_set_pending(sc, cmdf | SCP_UPDATESUBCMD);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: ray_cmd_done 0x%x\\n\", sc->sc_xname, cmdf)"
          ],
          "line": 2344
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSCP_TIMOCHECK_CMD_MASK\t\\\n\t(SCP_UPD_UPDATEPARAMS | SCP_UPD_STARTUP | SCP_UPD_MCAST | \\\n\tSCP_UPD_PROMISC)\n#define\tSCP_UPD_MASK\t\t0xff00\n#define\tSCP_UPDATESUBCMD\t0x0001\n#define\tsc_xname\tsc_dev.dv_xname\n#define\tcallout_stop\ttimeout_del\n\nvoid ray_cmd_schedule;\nvoid ray_cmd_done;\n\nvoid\nray_cmd_done(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_cmd_done 0x%x\\n\", sc->sc_xname, cmdf));\n\n\tsc->sc_running &= ~cmdf;\n\tif (cmdf & SCP_UPD_MASK) {\n\t\tsc->sc_running &= ~SCP_UPDATESUBCMD;\n\t\tif (sc->sc_scheduled & SCP_UPD_MASK)\n\t\t\tray_cmd_schedule(sc, sc->sc_scheduled & SCP_UPD_MASK);\n\t}\n\tif ((sc->sc_running & SCP_TIMOCHECK_CMD_MASK) == 0 && sc->sc_timocheck){\n\t\tcallout_stop(&sc->sc_check_ccs_ch);\n\t\tsc->sc_timocheck = 0;\n\t}\n}"
  },
  {
    "function_name": "ray_cmd_is_running",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
    "lines": "2326-2334",
    "snippet": "int\nray_cmd_is_running(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_cmd_is_running 0x%x\\n\", sc->sc_xname, cmdf));\n\n\treturn ((sc->sc_running & cmdf) ? 1 : 0);\n}",
    "includes": [
      "#include <dev/pcmcia/if_rayreg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_llc.h>",
      "#include <net/if_media.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/timeout.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [
      "#define\tsc_xname\tsc_dev.dv_xname"
    ],
    "globals_used": [
      "int ray_cmd_is_running"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: ray_cmd_is_running 0x%x\\n\", sc->sc_xname, cmdf)"
          ],
          "line": 2331
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_xname\tsc_dev.dv_xname\n\nint ray_cmd_is_running;\n\nint\nray_cmd_is_running(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_cmd_is_running 0x%x\\n\", sc->sc_xname, cmdf));\n\n\treturn ((sc->sc_running & cmdf) ? 1 : 0);\n}"
  },
  {
    "function_name": "ray_cmd_ran",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
    "lines": "2304-2321",
    "snippet": "void\nray_cmd_ran(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_cmd_ran 0x%x\\n\", sc->sc_xname, cmdf));\n\n\tif (cmdf & SCP_UPD_MASK)\n\t\tsc->sc_running |= cmdf | SCP_UPDATESUBCMD;\n\telse\n\t\tsc->sc_running |= cmdf;\n\n\tif ((cmdf & SCP_TIMOCHECK_CMD_MASK) && !sc->sc_timocheck) {\n\t\tcallout_reset(&sc->sc_check_ccs_ch, RAY_CHECK_CCS_TIMEOUT,\n\t\t    ray_check_ccs, sc);\n\t\tsc->sc_timocheck = 1;\n\t}\n}",
    "includes": [
      "#include <dev/pcmcia/if_rayreg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_llc.h>",
      "#include <net/if_media.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/timeout.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [
      "#define\tSCP_TIMOCHECK_CMD_MASK\t\\\n\t(SCP_UPD_UPDATEPARAMS | SCP_UPD_STARTUP | SCP_UPD_MCAST | \\\n\tSCP_UPD_PROMISC)",
      "#define\tSCP_UPD_MASK\t\t0xff00",
      "#define\tSCP_UPDATESUBCMD\t0x0001",
      "#define\tsc_xname\tsc_dev.dv_xname",
      "#define\tRAY_CHECK_CCS_TIMEOUT\t(hz / 2)"
    ],
    "globals_used": [
      "void ray_check_ccs",
      "void ray_cmd_ran"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "callout_reset",
          "args": [
            "&sc->sc_check_ccs_ch",
            "RAY_CHECK_CCS_TIMEOUT",
            "ray_check_ccs",
            "sc"
          ],
          "line": 2317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: ray_cmd_ran 0x%x\\n\", sc->sc_xname, cmdf)"
          ],
          "line": 2309
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSCP_TIMOCHECK_CMD_MASK\t\\\n\t(SCP_UPD_UPDATEPARAMS | SCP_UPD_STARTUP | SCP_UPD_MCAST | \\\n\tSCP_UPD_PROMISC)\n#define\tSCP_UPD_MASK\t\t0xff00\n#define\tSCP_UPDATESUBCMD\t0x0001\n#define\tsc_xname\tsc_dev.dv_xname\n#define\tRAY_CHECK_CCS_TIMEOUT\t(hz / 2)\n\nvoid ray_check_ccs;\nvoid ray_cmd_ran;\n\nvoid\nray_cmd_ran(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_cmd_ran 0x%x\\n\", sc->sc_xname, cmdf));\n\n\tif (cmdf & SCP_UPD_MASK)\n\t\tsc->sc_running |= cmdf | SCP_UPDATESUBCMD;\n\telse\n\t\tsc->sc_running |= cmdf;\n\n\tif ((cmdf & SCP_TIMOCHECK_CMD_MASK) && !sc->sc_timocheck) {\n\t\tcallout_reset(&sc->sc_check_ccs_ch, RAY_CHECK_CCS_TIMEOUT,\n\t\t    ray_check_ccs, sc);\n\t\tsc->sc_timocheck = 1;\n\t}\n}"
  },
  {
    "function_name": "ray_cmd_cancel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
    "lines": "2283-2299",
    "snippet": "void\nray_cmd_cancel(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_cmd_cancel 0x%x\\n\", sc->sc_xname, cmdf));\n\n\tsc->sc_scheduled &= ~cmdf;\n\tif ((cmdf & SCP_UPD_MASK) && (sc->sc_scheduled & SCP_UPD_MASK) == 0)\n\t\tsc->sc_scheduled &= ~SCP_UPDATESUBCMD;\n\n\t/* if nothing else needed cancel the timer */\n\tif (sc->sc_scheduled == 0 && sc->sc_timoneed) {\n\t\tcallout_stop(&sc->sc_check_scheduled_ch);\n\t\tsc->sc_timoneed = 0;\n\t}\n}",
    "includes": [
      "#include <dev/pcmcia/if_rayreg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_llc.h>",
      "#include <net/if_media.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/timeout.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [
      "#define\tSCP_UPD_MASK\t\t0xff00",
      "#define\tSCP_UPDATESUBCMD\t0x0001",
      "#define\tsc_xname\tsc_dev.dv_xname",
      "#define\tcallout_stop\ttimeout_del"
    ],
    "globals_used": [
      "void ray_cmd_cancel"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "callout_stop",
          "args": [
            "&sc->sc_check_scheduled_ch"
          ],
          "line": 2296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: ray_cmd_cancel 0x%x\\n\", sc->sc_xname, cmdf)"
          ],
          "line": 2288
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSCP_UPD_MASK\t\t0xff00\n#define\tSCP_UPDATESUBCMD\t0x0001\n#define\tsc_xname\tsc_dev.dv_xname\n#define\tcallout_stop\ttimeout_del\n\nvoid ray_cmd_cancel;\n\nvoid\nray_cmd_cancel(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_cmd_cancel 0x%x\\n\", sc->sc_xname, cmdf));\n\n\tsc->sc_scheduled &= ~cmdf;\n\tif ((cmdf & SCP_UPD_MASK) && (sc->sc_scheduled & SCP_UPD_MASK) == 0)\n\t\tsc->sc_scheduled &= ~SCP_UPDATESUBCMD;\n\n\t/* if nothing else needed cancel the timer */\n\tif (sc->sc_scheduled == 0 && sc->sc_timoneed) {\n\t\tcallout_stop(&sc->sc_check_scheduled_ch);\n\t\tsc->sc_timoneed = 0;\n\t}\n}"
  },
  {
    "function_name": "ray_cmd_is_scheduled",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
    "lines": "2270-2278",
    "snippet": "int\nray_cmd_is_scheduled(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_cmd_is_scheduled 0x%x\\n\", sc->sc_xname, cmdf));\n\n\treturn ((sc->sc_scheduled & cmdf) ? 1 : 0);\n}",
    "includes": [
      "#include <dev/pcmcia/if_rayreg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_llc.h>",
      "#include <net/if_media.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/timeout.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [
      "#define\tsc_xname\tsc_dev.dv_xname"
    ],
    "globals_used": [
      "int ray_cmd_is_scheduled"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: ray_cmd_is_scheduled 0x%x\\n\", sc->sc_xname, cmdf)"
          ],
          "line": 2275
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_xname\tsc_dev.dv_xname\n\nint ray_cmd_is_scheduled;\n\nint\nray_cmd_is_scheduled(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_cmd_is_scheduled 0x%x\\n\", sc->sc_xname, cmdf));\n\n\treturn ((sc->sc_scheduled & cmdf) ? 1 : 0);\n}"
  },
  {
    "function_name": "ray_cmd_schedule",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
    "lines": "2248-2265",
    "snippet": "void\nray_cmd_schedule(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tint track;\n\n\tRAY_DPRINTF((\"%s: ray_cmd_schedule 0x%x\\n\", sc->sc_xname, cmdf));\n\n\ttrack = cmdf;\n\tif ((cmdf & SCP_UPD_MASK) == 0)\n\t\tray_set_pending(sc, track);\n\telse if (ray_cmd_is_running(sc, SCP_UPDATESUBCMD)) {\n\t\t/* don't do timeout mechaniscm if subcmd already going */\n\t\tsc->sc_scheduled |= cmdf;\n\t} else\n\t\tray_set_pending(sc, cmdf | SCP_UPDATESUBCMD);\n}",
    "includes": [
      "#include <dev/pcmcia/if_rayreg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_llc.h>",
      "#include <net/if_media.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/timeout.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [
      "#define\tSCP_UPD_MASK\t\t0xff00",
      "#define\tSCP_UPDATESUBCMD\t0x0001",
      "#define\tsc_xname\tsc_dev.dv_xname"
    ],
    "globals_used": [
      "void ray_cmd_schedule",
      "int ray_cmd_is_running",
      "void ray_set_pending"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ray_set_pending",
          "args": [
            "sc",
            "cmdf | SCP_UPDATESUBCMD"
          ],
          "line": 2264
        },
        "resolved": true,
        "details": {
          "function_name": "ray_set_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2229-2243",
          "snippet": "void\nray_set_pending(sc, cmdf)\n\tstruct ray_softc *sc;\n\tu_int cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_set_pending 0x%x\\n\", sc->sc_xname, cmdf));\n\n\tsc->sc_scheduled |= cmdf;\n\tif (!sc->sc_timoneed) {\n\t\tRAY_DPRINTF((\"%s: ray_set_pending new timo\\n\", sc->sc_xname));\n\t\tcallout_reset(&sc->sc_check_scheduled_ch,\n\t\t    RAY_CHECK_SCHED_TIMEOUT, ray_check_scheduled, sc);\n\t\tsc->sc_timoneed = 1;\n\t}\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tsc_xname\tsc_dev.dv_xname",
            "#define\tRAY_CHECK_SCHED_TIMEOUT\t(hz)\t/* XXX 5 */"
          ],
          "globals_used": [
            "void ray_check_scheduled",
            "void ray_set_pending"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_xname\tsc_dev.dv_xname\n#define\tRAY_CHECK_SCHED_TIMEOUT\t(hz)\t/* XXX 5 */\n\nvoid ray_check_scheduled;\nvoid ray_set_pending;\n\nvoid\nray_set_pending(sc, cmdf)\n\tstruct ray_softc *sc;\n\tu_int cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_set_pending 0x%x\\n\", sc->sc_xname, cmdf));\n\n\tsc->sc_scheduled |= cmdf;\n\tif (!sc->sc_timoneed) {\n\t\tRAY_DPRINTF((\"%s: ray_set_pending new timo\\n\", sc->sc_xname));\n\t\tcallout_reset(&sc->sc_check_scheduled_ch,\n\t\t    RAY_CHECK_SCHED_TIMEOUT, ray_check_scheduled, sc);\n\t\tsc->sc_timoneed = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ray_cmd_is_running",
          "args": [
            "sc",
            "SCP_UPDATESUBCMD"
          ],
          "line": 2260
        },
        "resolved": true,
        "details": {
          "function_name": "ray_cmd_is_running",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2326-2334",
          "snippet": "int\nray_cmd_is_running(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_cmd_is_running 0x%x\\n\", sc->sc_xname, cmdf));\n\n\treturn ((sc->sc_running & cmdf) ? 1 : 0);\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tsc_xname\tsc_dev.dv_xname"
          ],
          "globals_used": [
            "int ray_cmd_is_running"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_xname\tsc_dev.dv_xname\n\nint ray_cmd_is_running;\n\nint\nray_cmd_is_running(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_cmd_is_running 0x%x\\n\", sc->sc_xname, cmdf));\n\n\treturn ((sc->sc_running & cmdf) ? 1 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: ray_cmd_schedule 0x%x\\n\", sc->sc_xname, cmdf)"
          ],
          "line": 2255
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSCP_UPD_MASK\t\t0xff00\n#define\tSCP_UPDATESUBCMD\t0x0001\n#define\tsc_xname\tsc_dev.dv_xname\n\nvoid ray_cmd_schedule;\nint ray_cmd_is_running;\nvoid ray_set_pending;\n\nvoid\nray_cmd_schedule(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tint track;\n\n\tRAY_DPRINTF((\"%s: ray_cmd_schedule 0x%x\\n\", sc->sc_xname, cmdf));\n\n\ttrack = cmdf;\n\tif ((cmdf & SCP_UPD_MASK) == 0)\n\t\tray_set_pending(sc, track);\n\telse if (ray_cmd_is_running(sc, SCP_UPDATESUBCMD)) {\n\t\t/* don't do timeout mechaniscm if subcmd already going */\n\t\tsc->sc_scheduled |= cmdf;\n\t} else\n\t\tray_set_pending(sc, cmdf | SCP_UPDATESUBCMD);\n}"
  },
  {
    "function_name": "ray_set_pending",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
    "lines": "2229-2243",
    "snippet": "void\nray_set_pending(sc, cmdf)\n\tstruct ray_softc *sc;\n\tu_int cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_set_pending 0x%x\\n\", sc->sc_xname, cmdf));\n\n\tsc->sc_scheduled |= cmdf;\n\tif (!sc->sc_timoneed) {\n\t\tRAY_DPRINTF((\"%s: ray_set_pending new timo\\n\", sc->sc_xname));\n\t\tcallout_reset(&sc->sc_check_scheduled_ch,\n\t\t    RAY_CHECK_SCHED_TIMEOUT, ray_check_scheduled, sc);\n\t\tsc->sc_timoneed = 1;\n\t}\n}",
    "includes": [
      "#include <dev/pcmcia/if_rayreg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_llc.h>",
      "#include <net/if_media.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/timeout.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [
      "#define\tsc_xname\tsc_dev.dv_xname",
      "#define\tRAY_CHECK_SCHED_TIMEOUT\t(hz)\t/* XXX 5 */"
    ],
    "globals_used": [
      "void ray_check_scheduled",
      "void ray_set_pending"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "callout_reset",
          "args": [
            "&sc->sc_check_scheduled_ch",
            "RAY_CHECK_SCHED_TIMEOUT",
            "ray_check_scheduled",
            "sc"
          ],
          "line": 2239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: ray_set_pending new timo\\n\", sc->sc_xname)"
          ],
          "line": 2238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: ray_set_pending 0x%x\\n\", sc->sc_xname, cmdf)"
          ],
          "line": 2234
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_xname\tsc_dev.dv_xname\n#define\tRAY_CHECK_SCHED_TIMEOUT\t(hz)\t/* XXX 5 */\n\nvoid ray_check_scheduled;\nvoid ray_set_pending;\n\nvoid\nray_set_pending(sc, cmdf)\n\tstruct ray_softc *sc;\n\tu_int cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_set_pending 0x%x\\n\", sc->sc_xname, cmdf));\n\n\tsc->sc_scheduled |= cmdf;\n\tif (!sc->sc_timoneed) {\n\t\tRAY_DPRINTF((\"%s: ray_set_pending new timo\\n\", sc->sc_xname));\n\t\tcallout_reset(&sc->sc_check_scheduled_ch,\n\t\t    RAY_CHECK_SCHED_TIMEOUT, ray_check_scheduled, sc);\n\t\tsc->sc_timoneed = 1;\n\t}\n}"
  },
  {
    "function_name": "ray_alloc_ccs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
    "lines": "2184-2221",
    "snippet": "int\nray_alloc_ccs(sc, ccsp, cmd, track)\n\tstruct ray_softc *sc;\n\tbus_size_t *ccsp;\n\tu_int cmd, track;\n{\n\tbus_size_t ccs;\n\tu_int i;\n\n\tRAY_DPRINTF((\"%s: alloc_ccs cmd %d\\n\", sc->sc_xname, cmd));\n\n\t/* for tracked commands, if not ready just set pending */\n\tif (track && !RAY_ECF_READY(sc)) {\n\t\tray_cmd_schedule(sc, track);\n\t\treturn (0);\n\t}\n\n\t/* first scan our inuse array */\n\tfor (i = RAY_CCS_CMD_FIRST; i <= RAY_CCS_CMD_LAST; i++) {\n\t\t/* XXX wonder if we have to probe here to make the card go */\n\t\t(void)SRAM_READ_FIELD_1(sc, RAY_GET_CCS(i), ray_cmd, c_status);\n\t\tif (!sc->sc_ccsinuse[i])\n\t\t\tbreak;\n\t}\n\tif (i > RAY_CCS_CMD_LAST) {\n\t\tif (track)\n\t\t\tray_cmd_schedule(sc, track);\n\t\treturn (0);\n\t}\n\tsc->sc_ccsinuse[i] = 1;\n\tccs = RAY_GET_CCS(i);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_status, RAY_CCS_STATUS_BUSY);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_cmd, cmd);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_link, RAY_CCS_LINK_NULL);\n\n\t*ccsp = ccs;\n\treturn (1);\n}",
    "includes": [
      "#include <dev/pcmcia/if_rayreg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_llc.h>",
      "#include <net/if_media.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/timeout.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [
      "#define\tsc_xname\tsc_dev.dv_xname"
    ],
    "globals_used": [
      "int ray_alloc_ccs",
      "void ray_cmd_schedule"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SRAM_WRITE_FIELD_1",
          "args": [
            "sc",
            "ccs",
            "ray_cmd",
            "c_link",
            "RAY_CCS_LINK_NULL"
          ],
          "line": 2217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRAM_WRITE_FIELD_1",
          "args": [
            "sc",
            "ccs",
            "ray_cmd",
            "c_cmd",
            "cmd"
          ],
          "line": 2216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRAM_WRITE_FIELD_1",
          "args": [
            "sc",
            "ccs",
            "ray_cmd",
            "c_status",
            "RAY_CCS_STATUS_BUSY"
          ],
          "line": 2215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_GET_CCS",
          "args": [
            "i"
          ],
          "line": 2214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ray_cmd_schedule",
          "args": [
            "sc",
            "track"
          ],
          "line": 2210
        },
        "resolved": true,
        "details": {
          "function_name": "ray_cmd_schedule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2248-2265",
          "snippet": "void\nray_cmd_schedule(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tint track;\n\n\tRAY_DPRINTF((\"%s: ray_cmd_schedule 0x%x\\n\", sc->sc_xname, cmdf));\n\n\ttrack = cmdf;\n\tif ((cmdf & SCP_UPD_MASK) == 0)\n\t\tray_set_pending(sc, track);\n\telse if (ray_cmd_is_running(sc, SCP_UPDATESUBCMD)) {\n\t\t/* don't do timeout mechaniscm if subcmd already going */\n\t\tsc->sc_scheduled |= cmdf;\n\t} else\n\t\tray_set_pending(sc, cmdf | SCP_UPDATESUBCMD);\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tSCP_UPD_MASK\t\t0xff00",
            "#define\tSCP_UPDATESUBCMD\t0x0001",
            "#define\tsc_xname\tsc_dev.dv_xname"
          ],
          "globals_used": [
            "void ray_cmd_schedule",
            "int ray_cmd_is_running",
            "void ray_set_pending"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSCP_UPD_MASK\t\t0xff00\n#define\tSCP_UPDATESUBCMD\t0x0001\n#define\tsc_xname\tsc_dev.dv_xname\n\nvoid ray_cmd_schedule;\nint ray_cmd_is_running;\nvoid ray_set_pending;\n\nvoid\nray_cmd_schedule(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tint track;\n\n\tRAY_DPRINTF((\"%s: ray_cmd_schedule 0x%x\\n\", sc->sc_xname, cmdf));\n\n\ttrack = cmdf;\n\tif ((cmdf & SCP_UPD_MASK) == 0)\n\t\tray_set_pending(sc, track);\n\telse if (ray_cmd_is_running(sc, SCP_UPDATESUBCMD)) {\n\t\t/* don't do timeout mechaniscm if subcmd already going */\n\t\tsc->sc_scheduled |= cmdf;\n\t} else\n\t\tray_set_pending(sc, cmdf | SCP_UPDATESUBCMD);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SRAM_READ_FIELD_1",
          "args": [
            "sc",
            "RAY_GET_CCS(i)",
            "ray_cmd",
            "c_status"
          ],
          "line": 2204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_GET_CCS",
          "args": [
            "i"
          ],
          "line": 2204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_ECF_READY",
          "args": [
            "sc"
          ],
          "line": 2196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: alloc_ccs cmd %d\\n\", sc->sc_xname, cmd)"
          ],
          "line": 2193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_xname\tsc_dev.dv_xname\n\nint ray_alloc_ccs;\nvoid ray_cmd_schedule;\n\nint\nray_alloc_ccs(sc, ccsp, cmd, track)\n\tstruct ray_softc *sc;\n\tbus_size_t *ccsp;\n\tu_int cmd, track;\n{\n\tbus_size_t ccs;\n\tu_int i;\n\n\tRAY_DPRINTF((\"%s: alloc_ccs cmd %d\\n\", sc->sc_xname, cmd));\n\n\t/* for tracked commands, if not ready just set pending */\n\tif (track && !RAY_ECF_READY(sc)) {\n\t\tray_cmd_schedule(sc, track);\n\t\treturn (0);\n\t}\n\n\t/* first scan our inuse array */\n\tfor (i = RAY_CCS_CMD_FIRST; i <= RAY_CCS_CMD_LAST; i++) {\n\t\t/* XXX wonder if we have to probe here to make the card go */\n\t\t(void)SRAM_READ_FIELD_1(sc, RAY_GET_CCS(i), ray_cmd, c_status);\n\t\tif (!sc->sc_ccsinuse[i])\n\t\t\tbreak;\n\t}\n\tif (i > RAY_CCS_CMD_LAST) {\n\t\tif (track)\n\t\t\tray_cmd_schedule(sc, track);\n\t\treturn (0);\n\t}\n\tsc->sc_ccsinuse[i] = 1;\n\tccs = RAY_GET_CCS(i);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_status, RAY_CCS_STATUS_BUSY);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_cmd, cmd);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_link, RAY_CCS_LINK_NULL);\n\n\t*ccsp = ccs;\n\treturn (1);\n}"
  },
  {
    "function_name": "ray_free_ccs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
    "lines": "2156-2172",
    "snippet": "u_int8_t\nray_free_ccs(sc, ccs)\n\tstruct ray_softc *sc;\n\tbus_size_t ccs;\n{\n\tu_int8_t stat;\n\n\tRAY_DPRINTF((\"%s: free_ccs idx %ld\\n\", sc->sc_xname,\n\t    RAY_GET_INDEX(ccs)));\n\n\tstat = SRAM_READ_FIELD_1(sc, ccs, ray_cmd, c_status);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_status, RAY_CCS_STATUS_FREE);\n\tif (ccs <= RAY_GET_CCS(RAY_CCS_LAST))\n\t\tsc->sc_ccsinuse[RAY_GET_INDEX(ccs)] = 0;\n\n\treturn (stat);\n}",
    "includes": [
      "#include <dev/pcmcia/if_rayreg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_llc.h>",
      "#include <net/if_media.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/timeout.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [
      "#define\tsc_xname\tsc_dev.dv_xname"
    ],
    "globals_used": [
      "u_int8_t ray_free_ccs"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RAY_GET_INDEX",
          "args": [
            "ccs"
          ],
          "line": 2169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_GET_CCS",
          "args": [
            "RAY_CCS_LAST"
          ],
          "line": 2168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRAM_WRITE_FIELD_1",
          "args": [
            "sc",
            "ccs",
            "ray_cmd",
            "c_status",
            "RAY_CCS_STATUS_FREE"
          ],
          "line": 2167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRAM_READ_FIELD_1",
          "args": [
            "sc",
            "ccs",
            "ray_cmd",
            "c_status"
          ],
          "line": 2166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: free_ccs idx %ld\\n\", sc->sc_xname,\n\t    RAY_GET_INDEX(ccs))"
          ],
          "line": 2163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_GET_INDEX",
          "args": [
            "ccs"
          ],
          "line": 2164
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_xname\tsc_dev.dv_xname\n\nu_int8_t ray_free_ccs;\n\nu_int8_t\nray_free_ccs(sc, ccs)\n\tstruct ray_softc *sc;\n\tbus_size_t ccs;\n{\n\tu_int8_t stat;\n\n\tRAY_DPRINTF((\"%s: free_ccs idx %ld\\n\", sc->sc_xname,\n\t    RAY_GET_INDEX(ccs)));\n\n\tstat = SRAM_READ_FIELD_1(sc, ccs, ray_cmd, c_status);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_status, RAY_CCS_STATUS_FREE);\n\tif (ccs <= RAY_GET_CCS(RAY_CCS_LAST))\n\t\tsc->sc_ccsinuse[RAY_GET_INDEX(ccs)] = 0;\n\n\treturn (stat);\n}"
  },
  {
    "function_name": "ray_free_ccs_chain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
    "lines": "2138-2150",
    "snippet": "void\nray_free_ccs_chain(sc, ni)\n\tstruct ray_softc *sc;\n\tu_int ni;\n{\n\tu_int i;\n\n\twhile ((i = ni) != RAY_CCS_LINK_NULL) {\n\t\tni = SRAM_READ_FIELD_1(sc, RAY_GET_CCS(i), ray_cmd, c_link);\n\t\tSRAM_WRITE_FIELD_1(sc, RAY_GET_CCS(i), ray_cmd, c_status,\n\t\t    RAY_CCS_STATUS_FREE);\n\t}\n}",
    "includes": [
      "#include <dev/pcmcia/if_rayreg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_llc.h>",
      "#include <net/if_media.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/timeout.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void ray_free_ccs_chain"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SRAM_WRITE_FIELD_1",
          "args": [
            "sc",
            "RAY_GET_CCS(i)",
            "ray_cmd",
            "c_status",
            "RAY_CCS_STATUS_FREE"
          ],
          "line": 2147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_GET_CCS",
          "args": [
            "i"
          ],
          "line": 2147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRAM_READ_FIELD_1",
          "args": [
            "sc",
            "RAY_GET_CCS(i)",
            "ray_cmd",
            "c_link"
          ],
          "line": 2146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_GET_CCS",
          "args": [
            "i"
          ],
          "line": 2146
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\nvoid ray_free_ccs_chain;\n\nvoid\nray_free_ccs_chain(sc, ni)\n\tstruct ray_softc *sc;\n\tu_int ni;\n{\n\tu_int i;\n\n\twhile ((i = ni) != RAY_CCS_LINK_NULL) {\n\t\tni = SRAM_READ_FIELD_1(sc, RAY_GET_CCS(i), ray_cmd, c_link);\n\t\tSRAM_WRITE_FIELD_1(sc, RAY_GET_CCS(i), ray_cmd, c_status,\n\t\t    RAY_CCS_STATUS_FREE);\n\t}\n}"
  },
  {
    "function_name": "ray_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
    "lines": "2089-2128",
    "snippet": "int\nray_intr(arg)\n\tvoid *arg;\n{\n\tstruct ray_softc *sc;\n\tray_cmd_func_t rcmd;\n\tu_int i, count;\n\n\tsc = arg;\n\n\tRAY_DPRINTF((\"%s: ray_intr\\n\", sc->sc_xname));\n\n\tif ((++sc->sc_checkcounters % 32) == 0)\n\t\tray_update_error_counters(sc);\n\n\tcount = 0;\n\trcmd = 0;\n\tif (!REG_READ(sc, RAY_HCSIR))\n\t\tcount = 0;\n\telse {\n\t\tcount = 1;\n\t\ti = SRAM_READ_1(sc, RAY_SCB_RCCSI);\n\t\tif (i <= RAY_CCS_LAST)\n\t\t\trcmd = ray_ccs_done(sc, RAY_GET_CCS(i));\n\t\telse if (i <= RAY_RCCS_LAST)\n\t\t\trcmd = ray_rccs_intr(sc, RAY_GET_CCS(i));\n\t\telse\n\t\t\tprintf(\"%s: intr: bad cmd index %d\\n\", sc->sc_xname, i);\n\t}\n\n\tif (rcmd)\n\t\t(*rcmd)(sc);\n\n\tif (count)\n\t\tREG_WRITE(sc, RAY_HCSIR, 0);\n\n\tRAY_DPRINTF((\"%s: interrupt handled %d\\n\", sc->sc_xname, count));\n\n\treturn (count ? 1 : 0);\n}",
    "includes": [
      "#include <dev/pcmcia/if_rayreg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_llc.h>",
      "#include <net/if_media.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/timeout.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [
      "#define\tsc_xname\tsc_dev.dv_xname"
    ],
    "globals_used": [
      "ray_cmd_func_t ray_ccs_done",
      "int ray_intr",
      "ray_cmd_func_t ray_rccs_intr",
      "void ray_update_error_counters"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: interrupt handled %d\\n\", sc->sc_xname, count)"
          ],
          "line": 2125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REG_WRITE",
          "args": [
            "sc",
            "RAY_HCSIR",
            "0"
          ],
          "line": 2123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc"
          ],
          "line": 2120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: intr: bad cmd index %d\\n\"",
            "sc->sc_xname",
            "i"
          ],
          "line": 2116
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ray_rccs_intr",
          "args": [
            "sc",
            "RAY_GET_CCS(i)"
          ],
          "line": 2114
        },
        "resolved": true,
        "details": {
          "function_name": "ray_rccs_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2032-2084",
          "snippet": "ray_cmd_func_t\nray_rccs_intr(sc, ccs)\n\tstruct ray_softc *sc;\n\tbus_size_t ccs;\n{\n\tray_cmd_func_t rcmd;\n\tu_int cmd, stat;\n\n\tcmd = SRAM_READ_FIELD_1(sc, ccs, ray_cmd, c_cmd);\n\tstat = SRAM_READ_FIELD_1(sc, ccs, ray_cmd, c_status);\n\n\tRAY_DPRINTF((\"%s: ray_rccs_intr idx %ld cmd 0x%x stat %d\\n\",\n\t    sc->sc_xname, RAY_GET_INDEX(ccs), cmd, stat));\n\n\trcmd = 0;\n\tswitch (cmd) {\n\t/*\n\t * unsolicted commands\n\t */\n\tcase RAY_ECMD_RX_DONE:\n\t\tray_recv(sc, ccs);\n\t\tgoto done;\n\tcase RAY_ECMD_REJOIN_DONE:\n\t\tif (sc->sc_mode == SC_MODE_ADHOC)\n\t\t\tbreak;\n\t\t/* get the current ssid */\n\t\tSRAM_READ_FIELD_N(sc, ccs, ray_cmd_net, c_bss_id,\n\t\t    sc->sc_bssid, sizeof(sc->sc_bssid));\n\t\trcmd = ray_start_assoc;\n\t\tbreak;\n\tcase RAY_ECMD_ROAM_START:\n\t\t/* no longer have network */\n\t\tsc->sc_havenet = 0;\n\t\tbreak;\n\tcase RAY_ECMD_JAPAN_CALL_SIGNAL:\n\t\tbreak;\n\tdefault:\n\t\tray_update_error_counters(sc);\n\n\t\t/* this is a bogus return from build 4 don't free 0x55 */\n\t\tif (sc->sc_version == SC_BUILD_4 && cmd == 0x55\n\t\t    && RAY_GET_INDEX(ccs) == 0x55) {\n\t\t\tgoto done;\n\t\t}\n\t\tprintf(\"%s: intr: unknown command 0x%x\\n\",\n\t\t    sc->sc_if.if_xname, cmd);\n\t\tbreak;\n\t}\n\t/* free the ccs */\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_status, RAY_CCS_STATUS_FREE);\ndone:\n\treturn (rcmd);\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tSC_BUILD_4\t0x55",
            "#define\tSC_MODE_ADHOC\t0\t/* ad-hoc mode */",
            "#define\tsc_xname\tsc_dev.dv_xname",
            "#define\tsc_if\t\tsc_ec.ac_if",
            "#define\tsc_if\t\tsc_ec.ec_if",
            "#define\tsc_version\tsc_ecf_startup.e_fw_build_string"
          ],
          "globals_used": [
            "ray_cmd_func_t ray_rccs_intr",
            "void ray_recv",
            "void ray_start_assoc",
            "void ray_update_error_counters"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSC_BUILD_4\t0x55\n#define\tSC_MODE_ADHOC\t0\t/* ad-hoc mode */\n#define\tsc_xname\tsc_dev.dv_xname\n#define\tsc_if\t\tsc_ec.ac_if\n#define\tsc_if\t\tsc_ec.ec_if\n#define\tsc_version\tsc_ecf_startup.e_fw_build_string\n\nray_cmd_func_t ray_rccs_intr;\nvoid ray_recv;\nvoid ray_start_assoc;\nvoid ray_update_error_counters;\n\nray_cmd_func_t\nray_rccs_intr(sc, ccs)\n\tstruct ray_softc *sc;\n\tbus_size_t ccs;\n{\n\tray_cmd_func_t rcmd;\n\tu_int cmd, stat;\n\n\tcmd = SRAM_READ_FIELD_1(sc, ccs, ray_cmd, c_cmd);\n\tstat = SRAM_READ_FIELD_1(sc, ccs, ray_cmd, c_status);\n\n\tRAY_DPRINTF((\"%s: ray_rccs_intr idx %ld cmd 0x%x stat %d\\n\",\n\t    sc->sc_xname, RAY_GET_INDEX(ccs), cmd, stat));\n\n\trcmd = 0;\n\tswitch (cmd) {\n\t/*\n\t * unsolicted commands\n\t */\n\tcase RAY_ECMD_RX_DONE:\n\t\tray_recv(sc, ccs);\n\t\tgoto done;\n\tcase RAY_ECMD_REJOIN_DONE:\n\t\tif (sc->sc_mode == SC_MODE_ADHOC)\n\t\t\tbreak;\n\t\t/* get the current ssid */\n\t\tSRAM_READ_FIELD_N(sc, ccs, ray_cmd_net, c_bss_id,\n\t\t    sc->sc_bssid, sizeof(sc->sc_bssid));\n\t\trcmd = ray_start_assoc;\n\t\tbreak;\n\tcase RAY_ECMD_ROAM_START:\n\t\t/* no longer have network */\n\t\tsc->sc_havenet = 0;\n\t\tbreak;\n\tcase RAY_ECMD_JAPAN_CALL_SIGNAL:\n\t\tbreak;\n\tdefault:\n\t\tray_update_error_counters(sc);\n\n\t\t/* this is a bogus return from build 4 don't free 0x55 */\n\t\tif (sc->sc_version == SC_BUILD_4 && cmd == 0x55\n\t\t    && RAY_GET_INDEX(ccs) == 0x55) {\n\t\t\tgoto done;\n\t\t}\n\t\tprintf(\"%s: intr: unknown command 0x%x\\n\",\n\t\t    sc->sc_if.if_xname, cmd);\n\t\tbreak;\n\t}\n\t/* free the ccs */\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_status, RAY_CCS_STATUS_FREE);\ndone:\n\treturn (rcmd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RAY_GET_CCS",
          "args": [
            "i"
          ],
          "line": 2114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ray_ccs_done",
          "args": [
            "sc",
            "RAY_GET_CCS(i)"
          ],
          "line": 2112
        },
        "resolved": true,
        "details": {
          "function_name": "ray_ccs_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "1929-2027",
          "snippet": "ray_cmd_func_t\nray_ccs_done(sc, ccs)\n\tstruct ray_softc *sc;\n\tbus_size_t ccs;\n{\n\tstruct ifnet *ifp;\n\tray_cmd_func_t rcmd;\n\tu_int cmd, stat;\n\n\tifp = &sc->sc_if;\n\tcmd = SRAM_READ_FIELD_1(sc, ccs, ray_cmd, c_cmd);\n\tstat = SRAM_READ_FIELD_1(sc, ccs, ray_cmd, c_status);\n\n\tRAY_DPRINTF((\"%s: ray_ccs_done idx %ld cmd 0x%x stat %d\\n\",\n\t    sc->sc_xname, RAY_GET_INDEX(ccs), cmd, stat));\n\n\trcmd = 0;\n\tswitch (cmd) {\n\t/*\n\t * solicited commands\n\t */\n\tcase RAY_CMD_START_PARAMS:\n\t\t/* start network */\n\t\tray_cmd_done(sc, SCP_UPD_STARTUP);\n\n\t\t/* ok to start queueing packets */\n\t\tsc->sc_if.if_flags &= ~IFF_OACTIVE;\n\n\t\tsc->sc_omode = sc->sc_mode;\n\t\tmemcpy(sc->sc_cnwid, sc->sc_dnwid, sizeof(sc->sc_cnwid));\n\n\t\trcmd = ray_start_join_net;\n\t\tbreak;\n\tcase RAY_CMD_UPDATE_PARAMS:\n\t\trcmd = ray_update_params_done(sc, ccs, stat);\n\t\tbreak;\n\tcase RAY_CMD_REPORT_PARAMS:\n\t\t/* get the reported parameters */\n\t\tray_cmd_done(sc, SCP_REPORTPARAMS);\n\t\tif (!sc->sc_repreq)\n\t\t\tbreak;\n\t\tsc->sc_repreq->r_failcause =\n\t\t    SRAM_READ_FIELD_1(sc, ccs, ray_cmd_report, c_failcause);\n\t\tsc->sc_repreq->r_len =\n\t\t    SRAM_READ_FIELD_1(sc, ccs, ray_cmd_report, c_len);\n\t\tray_read_region(sc, RAY_ECF_TO_HOST_BASE, sc->sc_repreq->r_data,\n\t\t    sc->sc_repreq->r_len);\n\t\tsc->sc_repreq = 0;\n\t\twakeup(ray_report_params);\n\t\tbreak;\n\tcase RAY_CMD_UPDATE_MCAST:\n\t\tray_cmd_done(sc, SCP_UPD_MCAST);\n\t\tif (stat == RAY_CCS_STATUS_FAIL)\n\t\t\trcmd = ray_reset;\n\t\tbreak;\n\tcase RAY_CMD_START_NET:\n\tcase RAY_CMD_JOIN_NET:\n\t\trcmd = ray_start_join_net_done(sc, cmd, ccs, stat);\n\t\tbreak;\n\tcase RAY_CMD_TX_REQ:\n\t\tif (sc->sc_if.if_flags & IFF_OACTIVE) {\n\t\t\tsc->sc_if.if_flags &= ~IFF_OACTIVE;\n\t\t\t/* this may also be a problem */\n\t\t\trcmd = ray_intr_start;\n\t\t}\n\t\t/* free it -- no tracking */\n\t\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_status,\n\t\t    RAY_CCS_STATUS_FREE);\n\t\tgoto done;\n\tcase RAY_CMD_START_ASSOC:\n\t\tray_cmd_done(sc, SCP_STARTASSOC);\n\t\tif (stat == RAY_CCS_STATUS_FAIL)\n\t\t\trcmd = ray_start_join_net;\t/* XXX check */\n\t\telse {\n\t\t\tsc->sc_havenet = 1;\n\t\t\trcmd = ray_intr_start;\n\t\t}\n\t\tbreak;\n\tcase RAY_CMD_UPDATE_APM:\n\tcase RAY_CMD_TEST_MEM:\n\tcase RAY_CMD_SHUTDOWN:\n\tcase RAY_CMD_DUMP_MEM:\n\tcase RAY_CMD_START_TIMER:\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: intr: unknown command 0x%x\\n\",\n\t\t    sc->sc_if.if_xname, cmd);\n\t\tbreak;\n\t}\n\tray_free_ccs(sc, ccs);\ndone:\n\t/*\n\t * see if needed things can be done now that a command\n\t * has completed\n\t */\n\tray_check_scheduled(sc);\n\n\treturn (rcmd);\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tSCP_UPD_MCAST\t\t0x0800",
            "#define\tSCP_UPD_STARTUP\t\t0x0100",
            "#define\tSCP_REPORTPARAMS\t0x0004",
            "#define\tSCP_STARTASSOC\t\t0x0002",
            "#define\tsc_xname\tsc_dev.dv_xname",
            "#define\tsc_if\t\tsc_ec.ac_if",
            "#define\tsc_if\t\tsc_ec.ec_if"
          ],
          "globals_used": [
            "ray_cmd_func_t ray_ccs_done",
            "void ray_check_scheduled",
            "void ray_cmd_done",
            "u_int8_t ray_free_ccs",
            "void ray_intr_start",
            "void ray_report_params",
            "void ray_reset",
            "void ray_start_join_net",
            "ray_cmd_func_t ray_start_join_net_done",
            "ray_cmd_func_t ray_update_params_done"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSCP_UPD_MCAST\t\t0x0800\n#define\tSCP_UPD_STARTUP\t\t0x0100\n#define\tSCP_REPORTPARAMS\t0x0004\n#define\tSCP_STARTASSOC\t\t0x0002\n#define\tsc_xname\tsc_dev.dv_xname\n#define\tsc_if\t\tsc_ec.ac_if\n#define\tsc_if\t\tsc_ec.ec_if\n\nray_cmd_func_t ray_ccs_done;\nvoid ray_check_scheduled;\nvoid ray_cmd_done;\nu_int8_t ray_free_ccs;\nvoid ray_intr_start;\nvoid ray_report_params;\nvoid ray_reset;\nvoid ray_start_join_net;\nray_cmd_func_t ray_start_join_net_done;\nray_cmd_func_t ray_update_params_done;\n\nray_cmd_func_t\nray_ccs_done(sc, ccs)\n\tstruct ray_softc *sc;\n\tbus_size_t ccs;\n{\n\tstruct ifnet *ifp;\n\tray_cmd_func_t rcmd;\n\tu_int cmd, stat;\n\n\tifp = &sc->sc_if;\n\tcmd = SRAM_READ_FIELD_1(sc, ccs, ray_cmd, c_cmd);\n\tstat = SRAM_READ_FIELD_1(sc, ccs, ray_cmd, c_status);\n\n\tRAY_DPRINTF((\"%s: ray_ccs_done idx %ld cmd 0x%x stat %d\\n\",\n\t    sc->sc_xname, RAY_GET_INDEX(ccs), cmd, stat));\n\n\trcmd = 0;\n\tswitch (cmd) {\n\t/*\n\t * solicited commands\n\t */\n\tcase RAY_CMD_START_PARAMS:\n\t\t/* start network */\n\t\tray_cmd_done(sc, SCP_UPD_STARTUP);\n\n\t\t/* ok to start queueing packets */\n\t\tsc->sc_if.if_flags &= ~IFF_OACTIVE;\n\n\t\tsc->sc_omode = sc->sc_mode;\n\t\tmemcpy(sc->sc_cnwid, sc->sc_dnwid, sizeof(sc->sc_cnwid));\n\n\t\trcmd = ray_start_join_net;\n\t\tbreak;\n\tcase RAY_CMD_UPDATE_PARAMS:\n\t\trcmd = ray_update_params_done(sc, ccs, stat);\n\t\tbreak;\n\tcase RAY_CMD_REPORT_PARAMS:\n\t\t/* get the reported parameters */\n\t\tray_cmd_done(sc, SCP_REPORTPARAMS);\n\t\tif (!sc->sc_repreq)\n\t\t\tbreak;\n\t\tsc->sc_repreq->r_failcause =\n\t\t    SRAM_READ_FIELD_1(sc, ccs, ray_cmd_report, c_failcause);\n\t\tsc->sc_repreq->r_len =\n\t\t    SRAM_READ_FIELD_1(sc, ccs, ray_cmd_report, c_len);\n\t\tray_read_region(sc, RAY_ECF_TO_HOST_BASE, sc->sc_repreq->r_data,\n\t\t    sc->sc_repreq->r_len);\n\t\tsc->sc_repreq = 0;\n\t\twakeup(ray_report_params);\n\t\tbreak;\n\tcase RAY_CMD_UPDATE_MCAST:\n\t\tray_cmd_done(sc, SCP_UPD_MCAST);\n\t\tif (stat == RAY_CCS_STATUS_FAIL)\n\t\t\trcmd = ray_reset;\n\t\tbreak;\n\tcase RAY_CMD_START_NET:\n\tcase RAY_CMD_JOIN_NET:\n\t\trcmd = ray_start_join_net_done(sc, cmd, ccs, stat);\n\t\tbreak;\n\tcase RAY_CMD_TX_REQ:\n\t\tif (sc->sc_if.if_flags & IFF_OACTIVE) {\n\t\t\tsc->sc_if.if_flags &= ~IFF_OACTIVE;\n\t\t\t/* this may also be a problem */\n\t\t\trcmd = ray_intr_start;\n\t\t}\n\t\t/* free it -- no tracking */\n\t\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_status,\n\t\t    RAY_CCS_STATUS_FREE);\n\t\tgoto done;\n\tcase RAY_CMD_START_ASSOC:\n\t\tray_cmd_done(sc, SCP_STARTASSOC);\n\t\tif (stat == RAY_CCS_STATUS_FAIL)\n\t\t\trcmd = ray_start_join_net;\t/* XXX check */\n\t\telse {\n\t\t\tsc->sc_havenet = 1;\n\t\t\trcmd = ray_intr_start;\n\t\t}\n\t\tbreak;\n\tcase RAY_CMD_UPDATE_APM:\n\tcase RAY_CMD_TEST_MEM:\n\tcase RAY_CMD_SHUTDOWN:\n\tcase RAY_CMD_DUMP_MEM:\n\tcase RAY_CMD_START_TIMER:\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: intr: unknown command 0x%x\\n\",\n\t\t    sc->sc_if.if_xname, cmd);\n\t\tbreak;\n\t}\n\tray_free_ccs(sc, ccs);\ndone:\n\t/*\n\t * see if needed things can be done now that a command\n\t * has completed\n\t */\n\tray_check_scheduled(sc);\n\n\treturn (rcmd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RAY_GET_CCS",
          "args": [
            "i"
          ],
          "line": 2112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRAM_READ_1",
          "args": [
            "sc",
            "RAY_SCB_RCCSI"
          ],
          "line": 2110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REG_READ",
          "args": [
            "sc",
            "RAY_HCSIR"
          ],
          "line": 2106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ray_update_error_counters",
          "args": [
            "sc"
          ],
          "line": 2102
        },
        "resolved": true,
        "details": {
          "function_name": "ray_update_error_counters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "1900-1924",
          "snippet": "void\nray_update_error_counters(sc)\n\tstruct ray_softc *sc;\n{\n\tbus_size_t csc;\n\n\t/* try and update the error counters */\n\tcsc = RAY_STATUS_BASE;\n\tif (SRAM_READ_FIELD_1(sc, csc, ray_csc, csc_mrxo_own)) {\n\t\tsc->sc_rxoverflow +=\n\t\t    SRAM_READ_FIELD_2(sc, csc, ray_csc, csc_mrx_overflow);\n\t\tSRAM_WRITE_FIELD_1(sc, csc, ray_csc, csc_mrxo_own, 0);\n\t}\n\tif (SRAM_READ_FIELD_1(sc, csc, ray_csc, csc_mrxc_own)) {\n\t\tsc->sc_rxcksum +=\n\t\t    SRAM_READ_FIELD_2(sc, csc, ray_csc, csc_mrx_overflow);\n\t\tSRAM_WRITE_FIELD_1(sc, csc, ray_csc, csc_mrxc_own, 0);\n\t}\n\tif (SRAM_READ_FIELD_1(sc, csc, ray_csc, csc_rxhc_own)) {\n\t\tsc->sc_rxhcksum +=\n\t\t    SRAM_READ_FIELD_2(sc, csc, ray_csc, csc_rx_hcksum);\n\t\tSRAM_WRITE_FIELD_1(sc, csc, ray_csc, csc_rxhc_own, 0);\n\t}\n\tsc->sc_rxnoise = SRAM_READ_FIELD_1(sc, csc, ray_csc, csc_rx_noise);\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ray_update_error_counters"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\nvoid ray_update_error_counters;\n\nvoid\nray_update_error_counters(sc)\n\tstruct ray_softc *sc;\n{\n\tbus_size_t csc;\n\n\t/* try and update the error counters */\n\tcsc = RAY_STATUS_BASE;\n\tif (SRAM_READ_FIELD_1(sc, csc, ray_csc, csc_mrxo_own)) {\n\t\tsc->sc_rxoverflow +=\n\t\t    SRAM_READ_FIELD_2(sc, csc, ray_csc, csc_mrx_overflow);\n\t\tSRAM_WRITE_FIELD_1(sc, csc, ray_csc, csc_mrxo_own, 0);\n\t}\n\tif (SRAM_READ_FIELD_1(sc, csc, ray_csc, csc_mrxc_own)) {\n\t\tsc->sc_rxcksum +=\n\t\t    SRAM_READ_FIELD_2(sc, csc, ray_csc, csc_mrx_overflow);\n\t\tSRAM_WRITE_FIELD_1(sc, csc, ray_csc, csc_mrxc_own, 0);\n\t}\n\tif (SRAM_READ_FIELD_1(sc, csc, ray_csc, csc_rxhc_own)) {\n\t\tsc->sc_rxhcksum +=\n\t\t    SRAM_READ_FIELD_2(sc, csc, ray_csc, csc_rx_hcksum);\n\t\tSRAM_WRITE_FIELD_1(sc, csc, ray_csc, csc_rxhc_own, 0);\n\t}\n\tsc->sc_rxnoise = SRAM_READ_FIELD_1(sc, csc, ray_csc, csc_rx_noise);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: ray_intr\\n\", sc->sc_xname)"
          ],
          "line": 2099
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_xname\tsc_dev.dv_xname\n\nray_cmd_func_t ray_ccs_done;\nint ray_intr;\nray_cmd_func_t ray_rccs_intr;\nvoid ray_update_error_counters;\n\nint\nray_intr(arg)\n\tvoid *arg;\n{\n\tstruct ray_softc *sc;\n\tray_cmd_func_t rcmd;\n\tu_int i, count;\n\n\tsc = arg;\n\n\tRAY_DPRINTF((\"%s: ray_intr\\n\", sc->sc_xname));\n\n\tif ((++sc->sc_checkcounters % 32) == 0)\n\t\tray_update_error_counters(sc);\n\n\tcount = 0;\n\trcmd = 0;\n\tif (!REG_READ(sc, RAY_HCSIR))\n\t\tcount = 0;\n\telse {\n\t\tcount = 1;\n\t\ti = SRAM_READ_1(sc, RAY_SCB_RCCSI);\n\t\tif (i <= RAY_CCS_LAST)\n\t\t\trcmd = ray_ccs_done(sc, RAY_GET_CCS(i));\n\t\telse if (i <= RAY_RCCS_LAST)\n\t\t\trcmd = ray_rccs_intr(sc, RAY_GET_CCS(i));\n\t\telse\n\t\t\tprintf(\"%s: intr: bad cmd index %d\\n\", sc->sc_xname, i);\n\t}\n\n\tif (rcmd)\n\t\t(*rcmd)(sc);\n\n\tif (count)\n\t\tREG_WRITE(sc, RAY_HCSIR, 0);\n\n\tRAY_DPRINTF((\"%s: interrupt handled %d\\n\", sc->sc_xname, count));\n\n\treturn (count ? 1 : 0);\n}"
  },
  {
    "function_name": "ray_rccs_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
    "lines": "2032-2084",
    "snippet": "ray_cmd_func_t\nray_rccs_intr(sc, ccs)\n\tstruct ray_softc *sc;\n\tbus_size_t ccs;\n{\n\tray_cmd_func_t rcmd;\n\tu_int cmd, stat;\n\n\tcmd = SRAM_READ_FIELD_1(sc, ccs, ray_cmd, c_cmd);\n\tstat = SRAM_READ_FIELD_1(sc, ccs, ray_cmd, c_status);\n\n\tRAY_DPRINTF((\"%s: ray_rccs_intr idx %ld cmd 0x%x stat %d\\n\",\n\t    sc->sc_xname, RAY_GET_INDEX(ccs), cmd, stat));\n\n\trcmd = 0;\n\tswitch (cmd) {\n\t/*\n\t * unsolicted commands\n\t */\n\tcase RAY_ECMD_RX_DONE:\n\t\tray_recv(sc, ccs);\n\t\tgoto done;\n\tcase RAY_ECMD_REJOIN_DONE:\n\t\tif (sc->sc_mode == SC_MODE_ADHOC)\n\t\t\tbreak;\n\t\t/* get the current ssid */\n\t\tSRAM_READ_FIELD_N(sc, ccs, ray_cmd_net, c_bss_id,\n\t\t    sc->sc_bssid, sizeof(sc->sc_bssid));\n\t\trcmd = ray_start_assoc;\n\t\tbreak;\n\tcase RAY_ECMD_ROAM_START:\n\t\t/* no longer have network */\n\t\tsc->sc_havenet = 0;\n\t\tbreak;\n\tcase RAY_ECMD_JAPAN_CALL_SIGNAL:\n\t\tbreak;\n\tdefault:\n\t\tray_update_error_counters(sc);\n\n\t\t/* this is a bogus return from build 4 don't free 0x55 */\n\t\tif (sc->sc_version == SC_BUILD_4 && cmd == 0x55\n\t\t    && RAY_GET_INDEX(ccs) == 0x55) {\n\t\t\tgoto done;\n\t\t}\n\t\tprintf(\"%s: intr: unknown command 0x%x\\n\",\n\t\t    sc->sc_if.if_xname, cmd);\n\t\tbreak;\n\t}\n\t/* free the ccs */\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_status, RAY_CCS_STATUS_FREE);\ndone:\n\treturn (rcmd);\n}",
    "includes": [
      "#include <dev/pcmcia/if_rayreg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_llc.h>",
      "#include <net/if_media.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/timeout.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [
      "#define\tSC_BUILD_4\t0x55",
      "#define\tSC_MODE_ADHOC\t0\t/* ad-hoc mode */",
      "#define\tsc_xname\tsc_dev.dv_xname",
      "#define\tsc_if\t\tsc_ec.ac_if",
      "#define\tsc_if\t\tsc_ec.ec_if",
      "#define\tsc_version\tsc_ecf_startup.e_fw_build_string"
    ],
    "globals_used": [
      "ray_cmd_func_t ray_rccs_intr",
      "void ray_recv",
      "void ray_start_assoc",
      "void ray_update_error_counters"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SRAM_WRITE_FIELD_1",
          "args": [
            "sc",
            "ccs",
            "ray_cmd",
            "c_status",
            "RAY_CCS_STATUS_FREE"
          ],
          "line": 2081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: intr: unknown command 0x%x\\n\"",
            "sc->sc_if.if_xname",
            "cmd"
          ],
          "line": 2076
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RAY_GET_INDEX",
          "args": [
            "ccs"
          ],
          "line": 2073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ray_update_error_counters",
          "args": [
            "sc"
          ],
          "line": 2069
        },
        "resolved": true,
        "details": {
          "function_name": "ray_update_error_counters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "1900-1924",
          "snippet": "void\nray_update_error_counters(sc)\n\tstruct ray_softc *sc;\n{\n\tbus_size_t csc;\n\n\t/* try and update the error counters */\n\tcsc = RAY_STATUS_BASE;\n\tif (SRAM_READ_FIELD_1(sc, csc, ray_csc, csc_mrxo_own)) {\n\t\tsc->sc_rxoverflow +=\n\t\t    SRAM_READ_FIELD_2(sc, csc, ray_csc, csc_mrx_overflow);\n\t\tSRAM_WRITE_FIELD_1(sc, csc, ray_csc, csc_mrxo_own, 0);\n\t}\n\tif (SRAM_READ_FIELD_1(sc, csc, ray_csc, csc_mrxc_own)) {\n\t\tsc->sc_rxcksum +=\n\t\t    SRAM_READ_FIELD_2(sc, csc, ray_csc, csc_mrx_overflow);\n\t\tSRAM_WRITE_FIELD_1(sc, csc, ray_csc, csc_mrxc_own, 0);\n\t}\n\tif (SRAM_READ_FIELD_1(sc, csc, ray_csc, csc_rxhc_own)) {\n\t\tsc->sc_rxhcksum +=\n\t\t    SRAM_READ_FIELD_2(sc, csc, ray_csc, csc_rx_hcksum);\n\t\tSRAM_WRITE_FIELD_1(sc, csc, ray_csc, csc_rxhc_own, 0);\n\t}\n\tsc->sc_rxnoise = SRAM_READ_FIELD_1(sc, csc, ray_csc, csc_rx_noise);\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ray_update_error_counters"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\nvoid ray_update_error_counters;\n\nvoid\nray_update_error_counters(sc)\n\tstruct ray_softc *sc;\n{\n\tbus_size_t csc;\n\n\t/* try and update the error counters */\n\tcsc = RAY_STATUS_BASE;\n\tif (SRAM_READ_FIELD_1(sc, csc, ray_csc, csc_mrxo_own)) {\n\t\tsc->sc_rxoverflow +=\n\t\t    SRAM_READ_FIELD_2(sc, csc, ray_csc, csc_mrx_overflow);\n\t\tSRAM_WRITE_FIELD_1(sc, csc, ray_csc, csc_mrxo_own, 0);\n\t}\n\tif (SRAM_READ_FIELD_1(sc, csc, ray_csc, csc_mrxc_own)) {\n\t\tsc->sc_rxcksum +=\n\t\t    SRAM_READ_FIELD_2(sc, csc, ray_csc, csc_mrx_overflow);\n\t\tSRAM_WRITE_FIELD_1(sc, csc, ray_csc, csc_mrxc_own, 0);\n\t}\n\tif (SRAM_READ_FIELD_1(sc, csc, ray_csc, csc_rxhc_own)) {\n\t\tsc->sc_rxhcksum +=\n\t\t    SRAM_READ_FIELD_2(sc, csc, ray_csc, csc_rx_hcksum);\n\t\tSRAM_WRITE_FIELD_1(sc, csc, ray_csc, csc_rxhc_own, 0);\n\t}\n\tsc->sc_rxnoise = SRAM_READ_FIELD_1(sc, csc, ray_csc, csc_rx_noise);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SRAM_READ_FIELD_N",
          "args": [
            "sc",
            "ccs",
            "ray_cmd_net",
            "c_bss_id",
            "sc->sc_bssid",
            "sizeof(sc->sc_bssid)"
          ],
          "line": 2058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ray_recv",
          "args": [
            "sc",
            "ccs"
          ],
          "line": 2052
        },
        "resolved": true,
        "details": {
          "function_name": "ray_recv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "1446-1668",
          "snippet": "void\nray_recv(sc, ccs)\n\tstruct ray_softc *sc;\n\tbus_size_t ccs;\n{\n\tstruct ieee80211_frame *frame;\n\tstruct ether_header *eh;\n\tstruct mbuf *m;\n\tsize_t pktlen, fudge, len, lenread;\n\tbus_size_t bufp, ebufp, tmp;\n\tstruct ifnet *ifp;\n\tu_int8_t *src, *d;\n\tu_int frag, nofrag, ni, i, issnap, first;\n\tu_int8_t fc0;\n#ifdef RAY_DO_SIGLEV\n\tu_int8_t siglev;\n#endif\n\n#ifdef RAY_DEBUG\n\t/* have a look if you want to see how the card rx works :) */\n\tif (ray_debug && ray_debug_dump_desc)\n\t\thexdump((caddr_t)sc->sc_memh + RAY_RCS_BASE, 0x400,\n\t\t    16, 4, 0);\n#endif\n\n\tnofrag = 0;\t/* XXX unused */\n\tm = 0;\n\tifp = &sc->sc_if;\n\n\t/*\n\t * If we're expecting the E2-in-802.11 encapsulation that the\n\t * WebGear Windows driver produces, fudge the packet forward\n\t * in the mbuf by 2 bytes so that the payload after the\n\t * Ethernet header will be aligned.  If we end up getting a\n\t * packet that's not of this type, we'll just drop it anyway.\n\t */\n\tfudge = ifp->if_flags & IFF_LINK0? 2 : 0;\n\n\t/* it looks like at least with build 4 there is no CRC in length */\n\tfirst = RAY_GET_INDEX(ccs);\n\tpktlen = SRAM_READ_FIELD_2(sc, ccs, ray_cmd_rx, c_pktlen);\n#ifdef RAY_DO_SIGLEV\n\tsiglev = SRAM_READ_FIELD_1(sc, ccs, ray_cmd_rx, c_siglev);\n#endif\n\tRAY_DPRINTF((\"%s: recv pktlen %lu nofrag %d\\n\", sc->sc_xname,\n\t    (u_long)pktlen, nofrag));\n\tRAY_DPRINTF_XMIT((\"%s: received packet: len %lu\\n\", sc->sc_xname,\n\t    (u_long)pktlen));\n\tif (pktlen > MCLBYTES\n\t    || pktlen < (sizeof(*frame) + sizeof(struct llc))) {\n\t\tRAY_DPRINTF((\"%s: PKTLEN TOO BIG OR TOO SMALL\\n\",\n\t\t    sc->sc_xname));\n\t\tifp->if_ierrors++;\n\t\tgoto done;\n\t}\n\tMGETHDR(m, M_DONTWAIT, MT_DATA);\n\tif (!m) {\n\t\tRAY_DPRINTF((\"%s: MGETHDR FAILED\\n\", sc->sc_xname));\n\t\tifp->if_ierrors++;\n\t\tgoto done;\n\t}\n\tif ((pktlen + fudge) > MHLEN) {\n\t\t/* XXX should allow chaining? */\n\t\tMCLGET(m, M_DONTWAIT);\n\t\tif ((m->m_flags & M_EXT) == 0) {\n\t\t\tRAY_DPRINTF((\"%s: MCLGET FAILED\\n\", sc->sc_xname));\n\t\t\tifp->if_ierrors++;\n\t\t\tm_freem(m);\n\t\t\tm = 0;\n\t\t\tgoto done;\n\t\t}\n\t}\n\tm->m_pkthdr.rcvif = ifp;\n\tm->m_pkthdr.len = pktlen;\n\tm->m_len = pktlen;\n\tm->m_data += fudge;\n\td = mtod(m, u_int8_t *);\n\n\tRAY_DPRINTF((\"%s: recv ccs index %d\\n\", sc->sc_xname, first));\n\tfrag = 0;\n\tlenread = 0;\n\ti = ni = first;\n\twhile ((i = ni) && i != RAY_CCS_LINK_NULL) {\n\t\tccs = RAY_GET_CCS(i);\n\t\tbufp = SRAM_READ_FIELD_2(sc, ccs, ray_cmd_rx, c_bufp);\n\t\tlen = SRAM_READ_FIELD_2(sc, ccs, ray_cmd_rx, c_len);\n\t\t/* remove the CRC */\n#if 0\n\t\t/* at least with build 4 no crc seems to be here */\n\t\tif (frag++ == 0)\n\t\t\tlen -= 4;\n#endif\n\t\tni = SRAM_READ_FIELD_1(sc, ccs, ray_cmd_rx, c_nextfrag);\n\t\tRAY_DPRINTF((\"%s: recv frag index %d len %lu bufp %p ni %d\\n\",\n\t\t    sc->sc_xname, i, (u_long)len, bufp, ni));\n\t\tif (len + lenread > pktlen) {\n\t\t\tRAY_DPRINTF((\"%s: BAD LEN current %lu pktlen %lu\\n\",\n\t\t\t    sc->sc_xname, (u_long)(len + lenread),\n\t\t\t    (u_long)pktlen));\n\t\t\tifp->if_ierrors++;\n\t\t\tm_freem(m);\n\t\t\tm = 0;\n\t\t\tgoto done;\n\t\t}\n\t\tif (i < RAY_RCCS_FIRST) {\n\t\t\tprintf(\"ray_recv: bad ccs index 0x%x\\n\", i);\n\t\t\tm_freem(m);\n\t\t\tm = 0;\n\t\t\tgoto done;\n\t\t}\n\n\t\tebufp = bufp + len;\n\t\tif (ebufp <= RAY_RX_END)\n\t\t\tray_read_region(sc, bufp, d, len);\n\t\telse {\n\t\t\t/* wrapping */\n\t\t\tray_read_region(sc, bufp, d, (tmp = RAY_RX_END - bufp));\n\t\t\tray_read_region(sc, RAY_RX_BASE, d + tmp, ebufp - RAY_RX_END);\n\t\t}\n\t\td += len;\n\t\tlenread += len;\n\t}\ndone:\n\n\tRAY_DPRINTF((\"%s: recv frag count %d\\n\", sc->sc_xname, frag));\n\n\t/* free the rcss */\n\tni = first;\n\twhile ((i = ni) && (i != RAY_CCS_LINK_NULL)) {\n\t\tccs = RAY_GET_CCS(i);\n\t\tni = SRAM_READ_FIELD_1(sc, ccs, ray_cmd_rx, c_nextfrag);\n\t\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_status,\n\t\t    RAY_CCS_STATUS_FREE);\n\t}\n\n\tif (!m)\n\t\treturn;\n\n\tRAY_DPRINTF((\"%s: recv got packet pktlen %lu actual %lu\\n\",\n\t    sc->sc_xname, (u_long)pktlen, (u_long)lenread));\n#ifdef RAY_DEBUG\n\tif (ray_debug && ray_debug_dump_rx)\n\t\tray_dump_mbuf(sc, m);\n#endif\n\t/* receivce the packet */\n\tframe = mtod(m, struct ieee80211_frame *);\n\tfc0 = frame->i_fc[0]\n\t   & (IEEE80211_FC0_VERSION_MASK|IEEE80211_FC0_TYPE_MASK);\n\tif ((fc0 & IEEE80211_FC0_VERSION_MASK) != IEEE80211_FC0_VERSION_0) {\n\t\tRAY_DPRINTF((\"%s: pkt not version 0 fc 0x%x\\n\",\n\t\t    sc->sc_xname, fc0));\n\t\tm_freem(m);\n\t\treturn;\n\t}\n\tif ((fc0 & IEEE80211_FC0_TYPE_MASK) != IEEE80211_FC0_TYPE_DATA) {\n\t\tRAY_DPRINTF((\"%s: pkt not type data fc0 0x%x\\n\",\n\t\t    sc->sc_xname, fc0));\n\t\tm_freem(m);\n\t\treturn;\n\t}\n\n\tif (!memcmp(frame + 1, llc_snapid, sizeof(llc_snapid)))\n\t\tissnap = 1;\n\telse {\n\t\t/*\n\t\t * if user has link0 flag set we allow the weird\n\t\t * Ethernet2 in 802.11 encapsulation produced by\n\t\t * the windows driver for the WebGear card\n\t\t */\n\t\tRAY_DPRINTF((\"%s: pkt not snap 0\\n\", sc->sc_xname));\n\t\tif ((ifp->if_flags & IFF_LINK0) == 0) {\n\t\t\tm_freem(m);\n\t\t\treturn;\n\t\t}\n\t\tissnap = 0;\n\t}\n\tswitch (frame->i_fc[1] & IEEE80211_FC1_DIR_MASK) {\n\tcase IEEE80211_FC1_DIR_NODS:\n\t\tsrc = frame->i_addr2;\n\t\tbreak;\n\tcase IEEE80211_FC1_DIR_FROMDS:\n\t\tsrc = frame->i_addr3;\n\t\tbreak;\n\tcase IEEE80211_FC1_DIR_TODS:\n\t\tRAY_DPRINTF((\"%s: pkt ap2ap\\n\", sc->sc_xname));\n\t\tm_freem(m);\n\t\treturn;\n\tdefault:\n\t\tRAY_DPRINTF((\"%s: pkt type unknown\\n\", sc->sc_xname));\n\t\tm_freem(m);\n\t\treturn;\n\t}\n\n#ifdef RAY_DO_SIGLEV\n\tray_update_siglev(sc, src, siglev);\n#endif\n\n\t/*\n\t * This is a mess.. we should support other LLC frame types\n\t */\n\tif (issnap) {\n\t\t/* create an ether_header over top of the 802.11+SNAP header */\n\t\teh = (struct ether_header *)((caddr_t)(frame + 1) - 6);\n\t\tmemcpy(eh->ether_shost, src, ETHER_ADDR_LEN);\n\t\tmemcpy(eh->ether_dhost, frame->i_addr1, ETHER_ADDR_LEN);\n\t} else {\n\t\t/* this is the weird e2 in 802.11 encapsulation */\n\t\teh = (struct ether_header *)(frame + 1);\n\t}\n\tm_adj(m, (caddr_t)eh - (caddr_t)frame);\n#if NBPFILTER > 0\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\t/* XXX doesn't appear to be included m->m_flags |= M_HASFCS; */\n\tifp->if_ipackets++;\n#ifdef __NetBSD__\n\t(*ifp->if_input)(ifp, m);\n#elif defined(__OpenBSD__)\n\tm_adj(m, sizeof(struct ether_header));\n\tether_input(ifp, eh, m);\n#endif\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tsc_xname\tsc_dev.dv_xname",
            "#define\tsc_if\t\tsc_ec.ac_if",
            "#define\tsc_if\t\tsc_ec.ec_if",
            "#define\tsc_memh\tsc_mem.memh"
          ],
          "globals_used": [
            "void ray_recv",
            "static const u_int8_t llc_snapid[6] = { LLC_SNAP_LSAP, LLC_SNAP_LSAP, LLC_UI };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_xname\tsc_dev.dv_xname\n#define\tsc_if\t\tsc_ec.ac_if\n#define\tsc_if\t\tsc_ec.ec_if\n#define\tsc_memh\tsc_mem.memh\n\nvoid ray_recv;\nstatic const u_int8_t llc_snapid[6] = { LLC_SNAP_LSAP, LLC_SNAP_LSAP, LLC_UI };\n\nvoid\nray_recv(sc, ccs)\n\tstruct ray_softc *sc;\n\tbus_size_t ccs;\n{\n\tstruct ieee80211_frame *frame;\n\tstruct ether_header *eh;\n\tstruct mbuf *m;\n\tsize_t pktlen, fudge, len, lenread;\n\tbus_size_t bufp, ebufp, tmp;\n\tstruct ifnet *ifp;\n\tu_int8_t *src, *d;\n\tu_int frag, nofrag, ni, i, issnap, first;\n\tu_int8_t fc0;\n#ifdef RAY_DO_SIGLEV\n\tu_int8_t siglev;\n#endif\n\n#ifdef RAY_DEBUG\n\t/* have a look if you want to see how the card rx works :) */\n\tif (ray_debug && ray_debug_dump_desc)\n\t\thexdump((caddr_t)sc->sc_memh + RAY_RCS_BASE, 0x400,\n\t\t    16, 4, 0);\n#endif\n\n\tnofrag = 0;\t/* XXX unused */\n\tm = 0;\n\tifp = &sc->sc_if;\n\n\t/*\n\t * If we're expecting the E2-in-802.11 encapsulation that the\n\t * WebGear Windows driver produces, fudge the packet forward\n\t * in the mbuf by 2 bytes so that the payload after the\n\t * Ethernet header will be aligned.  If we end up getting a\n\t * packet that's not of this type, we'll just drop it anyway.\n\t */\n\tfudge = ifp->if_flags & IFF_LINK0? 2 : 0;\n\n\t/* it looks like at least with build 4 there is no CRC in length */\n\tfirst = RAY_GET_INDEX(ccs);\n\tpktlen = SRAM_READ_FIELD_2(sc, ccs, ray_cmd_rx, c_pktlen);\n#ifdef RAY_DO_SIGLEV\n\tsiglev = SRAM_READ_FIELD_1(sc, ccs, ray_cmd_rx, c_siglev);\n#endif\n\tRAY_DPRINTF((\"%s: recv pktlen %lu nofrag %d\\n\", sc->sc_xname,\n\t    (u_long)pktlen, nofrag));\n\tRAY_DPRINTF_XMIT((\"%s: received packet: len %lu\\n\", sc->sc_xname,\n\t    (u_long)pktlen));\n\tif (pktlen > MCLBYTES\n\t    || pktlen < (sizeof(*frame) + sizeof(struct llc))) {\n\t\tRAY_DPRINTF((\"%s: PKTLEN TOO BIG OR TOO SMALL\\n\",\n\t\t    sc->sc_xname));\n\t\tifp->if_ierrors++;\n\t\tgoto done;\n\t}\n\tMGETHDR(m, M_DONTWAIT, MT_DATA);\n\tif (!m) {\n\t\tRAY_DPRINTF((\"%s: MGETHDR FAILED\\n\", sc->sc_xname));\n\t\tifp->if_ierrors++;\n\t\tgoto done;\n\t}\n\tif ((pktlen + fudge) > MHLEN) {\n\t\t/* XXX should allow chaining? */\n\t\tMCLGET(m, M_DONTWAIT);\n\t\tif ((m->m_flags & M_EXT) == 0) {\n\t\t\tRAY_DPRINTF((\"%s: MCLGET FAILED\\n\", sc->sc_xname));\n\t\t\tifp->if_ierrors++;\n\t\t\tm_freem(m);\n\t\t\tm = 0;\n\t\t\tgoto done;\n\t\t}\n\t}\n\tm->m_pkthdr.rcvif = ifp;\n\tm->m_pkthdr.len = pktlen;\n\tm->m_len = pktlen;\n\tm->m_data += fudge;\n\td = mtod(m, u_int8_t *);\n\n\tRAY_DPRINTF((\"%s: recv ccs index %d\\n\", sc->sc_xname, first));\n\tfrag = 0;\n\tlenread = 0;\n\ti = ni = first;\n\twhile ((i = ni) && i != RAY_CCS_LINK_NULL) {\n\t\tccs = RAY_GET_CCS(i);\n\t\tbufp = SRAM_READ_FIELD_2(sc, ccs, ray_cmd_rx, c_bufp);\n\t\tlen = SRAM_READ_FIELD_2(sc, ccs, ray_cmd_rx, c_len);\n\t\t/* remove the CRC */\n#if 0\n\t\t/* at least with build 4 no crc seems to be here */\n\t\tif (frag++ == 0)\n\t\t\tlen -= 4;\n#endif\n\t\tni = SRAM_READ_FIELD_1(sc, ccs, ray_cmd_rx, c_nextfrag);\n\t\tRAY_DPRINTF((\"%s: recv frag index %d len %lu bufp %p ni %d\\n\",\n\t\t    sc->sc_xname, i, (u_long)len, bufp, ni));\n\t\tif (len + lenread > pktlen) {\n\t\t\tRAY_DPRINTF((\"%s: BAD LEN current %lu pktlen %lu\\n\",\n\t\t\t    sc->sc_xname, (u_long)(len + lenread),\n\t\t\t    (u_long)pktlen));\n\t\t\tifp->if_ierrors++;\n\t\t\tm_freem(m);\n\t\t\tm = 0;\n\t\t\tgoto done;\n\t\t}\n\t\tif (i < RAY_RCCS_FIRST) {\n\t\t\tprintf(\"ray_recv: bad ccs index 0x%x\\n\", i);\n\t\t\tm_freem(m);\n\t\t\tm = 0;\n\t\t\tgoto done;\n\t\t}\n\n\t\tebufp = bufp + len;\n\t\tif (ebufp <= RAY_RX_END)\n\t\t\tray_read_region(sc, bufp, d, len);\n\t\telse {\n\t\t\t/* wrapping */\n\t\t\tray_read_region(sc, bufp, d, (tmp = RAY_RX_END - bufp));\n\t\t\tray_read_region(sc, RAY_RX_BASE, d + tmp, ebufp - RAY_RX_END);\n\t\t}\n\t\td += len;\n\t\tlenread += len;\n\t}\ndone:\n\n\tRAY_DPRINTF((\"%s: recv frag count %d\\n\", sc->sc_xname, frag));\n\n\t/* free the rcss */\n\tni = first;\n\twhile ((i = ni) && (i != RAY_CCS_LINK_NULL)) {\n\t\tccs = RAY_GET_CCS(i);\n\t\tni = SRAM_READ_FIELD_1(sc, ccs, ray_cmd_rx, c_nextfrag);\n\t\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_status,\n\t\t    RAY_CCS_STATUS_FREE);\n\t}\n\n\tif (!m)\n\t\treturn;\n\n\tRAY_DPRINTF((\"%s: recv got packet pktlen %lu actual %lu\\n\",\n\t    sc->sc_xname, (u_long)pktlen, (u_long)lenread));\n#ifdef RAY_DEBUG\n\tif (ray_debug && ray_debug_dump_rx)\n\t\tray_dump_mbuf(sc, m);\n#endif\n\t/* receivce the packet */\n\tframe = mtod(m, struct ieee80211_frame *);\n\tfc0 = frame->i_fc[0]\n\t   & (IEEE80211_FC0_VERSION_MASK|IEEE80211_FC0_TYPE_MASK);\n\tif ((fc0 & IEEE80211_FC0_VERSION_MASK) != IEEE80211_FC0_VERSION_0) {\n\t\tRAY_DPRINTF((\"%s: pkt not version 0 fc 0x%x\\n\",\n\t\t    sc->sc_xname, fc0));\n\t\tm_freem(m);\n\t\treturn;\n\t}\n\tif ((fc0 & IEEE80211_FC0_TYPE_MASK) != IEEE80211_FC0_TYPE_DATA) {\n\t\tRAY_DPRINTF((\"%s: pkt not type data fc0 0x%x\\n\",\n\t\t    sc->sc_xname, fc0));\n\t\tm_freem(m);\n\t\treturn;\n\t}\n\n\tif (!memcmp(frame + 1, llc_snapid, sizeof(llc_snapid)))\n\t\tissnap = 1;\n\telse {\n\t\t/*\n\t\t * if user has link0 flag set we allow the weird\n\t\t * Ethernet2 in 802.11 encapsulation produced by\n\t\t * the windows driver for the WebGear card\n\t\t */\n\t\tRAY_DPRINTF((\"%s: pkt not snap 0\\n\", sc->sc_xname));\n\t\tif ((ifp->if_flags & IFF_LINK0) == 0) {\n\t\t\tm_freem(m);\n\t\t\treturn;\n\t\t}\n\t\tissnap = 0;\n\t}\n\tswitch (frame->i_fc[1] & IEEE80211_FC1_DIR_MASK) {\n\tcase IEEE80211_FC1_DIR_NODS:\n\t\tsrc = frame->i_addr2;\n\t\tbreak;\n\tcase IEEE80211_FC1_DIR_FROMDS:\n\t\tsrc = frame->i_addr3;\n\t\tbreak;\n\tcase IEEE80211_FC1_DIR_TODS:\n\t\tRAY_DPRINTF((\"%s: pkt ap2ap\\n\", sc->sc_xname));\n\t\tm_freem(m);\n\t\treturn;\n\tdefault:\n\t\tRAY_DPRINTF((\"%s: pkt type unknown\\n\", sc->sc_xname));\n\t\tm_freem(m);\n\t\treturn;\n\t}\n\n#ifdef RAY_DO_SIGLEV\n\tray_update_siglev(sc, src, siglev);\n#endif\n\n\t/*\n\t * This is a mess.. we should support other LLC frame types\n\t */\n\tif (issnap) {\n\t\t/* create an ether_header over top of the 802.11+SNAP header */\n\t\teh = (struct ether_header *)((caddr_t)(frame + 1) - 6);\n\t\tmemcpy(eh->ether_shost, src, ETHER_ADDR_LEN);\n\t\tmemcpy(eh->ether_dhost, frame->i_addr1, ETHER_ADDR_LEN);\n\t} else {\n\t\t/* this is the weird e2 in 802.11 encapsulation */\n\t\teh = (struct ether_header *)(frame + 1);\n\t}\n\tm_adj(m, (caddr_t)eh - (caddr_t)frame);\n#if NBPFILTER > 0\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\t/* XXX doesn't appear to be included m->m_flags |= M_HASFCS; */\n\tifp->if_ipackets++;\n#ifdef __NetBSD__\n\t(*ifp->if_input)(ifp, m);\n#elif defined(__OpenBSD__)\n\tm_adj(m, sizeof(struct ether_header));\n\tether_input(ifp, eh, m);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: ray_rccs_intr idx %ld cmd 0x%x stat %d\\n\",\n\t    sc->sc_xname, RAY_GET_INDEX(ccs), cmd, stat)"
          ],
          "line": 2043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_GET_INDEX",
          "args": [
            "ccs"
          ],
          "line": 2044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRAM_READ_FIELD_1",
          "args": [
            "sc",
            "ccs",
            "ray_cmd",
            "c_status"
          ],
          "line": 2041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRAM_READ_FIELD_1",
          "args": [
            "sc",
            "ccs",
            "ray_cmd",
            "c_cmd"
          ],
          "line": 2040
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSC_BUILD_4\t0x55\n#define\tSC_MODE_ADHOC\t0\t/* ad-hoc mode */\n#define\tsc_xname\tsc_dev.dv_xname\n#define\tsc_if\t\tsc_ec.ac_if\n#define\tsc_if\t\tsc_ec.ec_if\n#define\tsc_version\tsc_ecf_startup.e_fw_build_string\n\nray_cmd_func_t ray_rccs_intr;\nvoid ray_recv;\nvoid ray_start_assoc;\nvoid ray_update_error_counters;\n\nray_cmd_func_t\nray_rccs_intr(sc, ccs)\n\tstruct ray_softc *sc;\n\tbus_size_t ccs;\n{\n\tray_cmd_func_t rcmd;\n\tu_int cmd, stat;\n\n\tcmd = SRAM_READ_FIELD_1(sc, ccs, ray_cmd, c_cmd);\n\tstat = SRAM_READ_FIELD_1(sc, ccs, ray_cmd, c_status);\n\n\tRAY_DPRINTF((\"%s: ray_rccs_intr idx %ld cmd 0x%x stat %d\\n\",\n\t    sc->sc_xname, RAY_GET_INDEX(ccs), cmd, stat));\n\n\trcmd = 0;\n\tswitch (cmd) {\n\t/*\n\t * unsolicted commands\n\t */\n\tcase RAY_ECMD_RX_DONE:\n\t\tray_recv(sc, ccs);\n\t\tgoto done;\n\tcase RAY_ECMD_REJOIN_DONE:\n\t\tif (sc->sc_mode == SC_MODE_ADHOC)\n\t\t\tbreak;\n\t\t/* get the current ssid */\n\t\tSRAM_READ_FIELD_N(sc, ccs, ray_cmd_net, c_bss_id,\n\t\t    sc->sc_bssid, sizeof(sc->sc_bssid));\n\t\trcmd = ray_start_assoc;\n\t\tbreak;\n\tcase RAY_ECMD_ROAM_START:\n\t\t/* no longer have network */\n\t\tsc->sc_havenet = 0;\n\t\tbreak;\n\tcase RAY_ECMD_JAPAN_CALL_SIGNAL:\n\t\tbreak;\n\tdefault:\n\t\tray_update_error_counters(sc);\n\n\t\t/* this is a bogus return from build 4 don't free 0x55 */\n\t\tif (sc->sc_version == SC_BUILD_4 && cmd == 0x55\n\t\t    && RAY_GET_INDEX(ccs) == 0x55) {\n\t\t\tgoto done;\n\t\t}\n\t\tprintf(\"%s: intr: unknown command 0x%x\\n\",\n\t\t    sc->sc_if.if_xname, cmd);\n\t\tbreak;\n\t}\n\t/* free the ccs */\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_status, RAY_CCS_STATUS_FREE);\ndone:\n\treturn (rcmd);\n}"
  },
  {
    "function_name": "ray_ccs_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
    "lines": "1929-2027",
    "snippet": "ray_cmd_func_t\nray_ccs_done(sc, ccs)\n\tstruct ray_softc *sc;\n\tbus_size_t ccs;\n{\n\tstruct ifnet *ifp;\n\tray_cmd_func_t rcmd;\n\tu_int cmd, stat;\n\n\tifp = &sc->sc_if;\n\tcmd = SRAM_READ_FIELD_1(sc, ccs, ray_cmd, c_cmd);\n\tstat = SRAM_READ_FIELD_1(sc, ccs, ray_cmd, c_status);\n\n\tRAY_DPRINTF((\"%s: ray_ccs_done idx %ld cmd 0x%x stat %d\\n\",\n\t    sc->sc_xname, RAY_GET_INDEX(ccs), cmd, stat));\n\n\trcmd = 0;\n\tswitch (cmd) {\n\t/*\n\t * solicited commands\n\t */\n\tcase RAY_CMD_START_PARAMS:\n\t\t/* start network */\n\t\tray_cmd_done(sc, SCP_UPD_STARTUP);\n\n\t\t/* ok to start queueing packets */\n\t\tsc->sc_if.if_flags &= ~IFF_OACTIVE;\n\n\t\tsc->sc_omode = sc->sc_mode;\n\t\tmemcpy(sc->sc_cnwid, sc->sc_dnwid, sizeof(sc->sc_cnwid));\n\n\t\trcmd = ray_start_join_net;\n\t\tbreak;\n\tcase RAY_CMD_UPDATE_PARAMS:\n\t\trcmd = ray_update_params_done(sc, ccs, stat);\n\t\tbreak;\n\tcase RAY_CMD_REPORT_PARAMS:\n\t\t/* get the reported parameters */\n\t\tray_cmd_done(sc, SCP_REPORTPARAMS);\n\t\tif (!sc->sc_repreq)\n\t\t\tbreak;\n\t\tsc->sc_repreq->r_failcause =\n\t\t    SRAM_READ_FIELD_1(sc, ccs, ray_cmd_report, c_failcause);\n\t\tsc->sc_repreq->r_len =\n\t\t    SRAM_READ_FIELD_1(sc, ccs, ray_cmd_report, c_len);\n\t\tray_read_region(sc, RAY_ECF_TO_HOST_BASE, sc->sc_repreq->r_data,\n\t\t    sc->sc_repreq->r_len);\n\t\tsc->sc_repreq = 0;\n\t\twakeup(ray_report_params);\n\t\tbreak;\n\tcase RAY_CMD_UPDATE_MCAST:\n\t\tray_cmd_done(sc, SCP_UPD_MCAST);\n\t\tif (stat == RAY_CCS_STATUS_FAIL)\n\t\t\trcmd = ray_reset;\n\t\tbreak;\n\tcase RAY_CMD_START_NET:\n\tcase RAY_CMD_JOIN_NET:\n\t\trcmd = ray_start_join_net_done(sc, cmd, ccs, stat);\n\t\tbreak;\n\tcase RAY_CMD_TX_REQ:\n\t\tif (sc->sc_if.if_flags & IFF_OACTIVE) {\n\t\t\tsc->sc_if.if_flags &= ~IFF_OACTIVE;\n\t\t\t/* this may also be a problem */\n\t\t\trcmd = ray_intr_start;\n\t\t}\n\t\t/* free it -- no tracking */\n\t\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_status,\n\t\t    RAY_CCS_STATUS_FREE);\n\t\tgoto done;\n\tcase RAY_CMD_START_ASSOC:\n\t\tray_cmd_done(sc, SCP_STARTASSOC);\n\t\tif (stat == RAY_CCS_STATUS_FAIL)\n\t\t\trcmd = ray_start_join_net;\t/* XXX check */\n\t\telse {\n\t\t\tsc->sc_havenet = 1;\n\t\t\trcmd = ray_intr_start;\n\t\t}\n\t\tbreak;\n\tcase RAY_CMD_UPDATE_APM:\n\tcase RAY_CMD_TEST_MEM:\n\tcase RAY_CMD_SHUTDOWN:\n\tcase RAY_CMD_DUMP_MEM:\n\tcase RAY_CMD_START_TIMER:\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: intr: unknown command 0x%x\\n\",\n\t\t    sc->sc_if.if_xname, cmd);\n\t\tbreak;\n\t}\n\tray_free_ccs(sc, ccs);\ndone:\n\t/*\n\t * see if needed things can be done now that a command\n\t * has completed\n\t */\n\tray_check_scheduled(sc);\n\n\treturn (rcmd);\n}",
    "includes": [
      "#include <dev/pcmcia/if_rayreg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_llc.h>",
      "#include <net/if_media.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/timeout.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [
      "#define\tSCP_UPD_MCAST\t\t0x0800",
      "#define\tSCP_UPD_STARTUP\t\t0x0100",
      "#define\tSCP_REPORTPARAMS\t0x0004",
      "#define\tSCP_STARTASSOC\t\t0x0002",
      "#define\tsc_xname\tsc_dev.dv_xname",
      "#define\tsc_if\t\tsc_ec.ac_if",
      "#define\tsc_if\t\tsc_ec.ec_if"
    ],
    "globals_used": [
      "ray_cmd_func_t ray_ccs_done",
      "void ray_check_scheduled",
      "void ray_cmd_done",
      "u_int8_t ray_free_ccs",
      "void ray_intr_start",
      "void ray_report_params",
      "void ray_reset",
      "void ray_start_join_net",
      "ray_cmd_func_t ray_start_join_net_done",
      "ray_cmd_func_t ray_update_params_done"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ray_check_scheduled",
          "args": [
            "sc"
          ],
          "line": 2024
        },
        "resolved": true,
        "details": {
          "function_name": "ray_check_scheduled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "1783-1824",
          "snippet": "void\nray_check_scheduled(arg)\n\tvoid *arg;\n{\n\tstruct ray_softc *sc;\n\tint s, i, mask;\n\n\ts = splnet();\n\n\tsc = arg;\n\tRAY_DPRINTF((\n\t    \"%s: ray_check_scheduled enter schd 0x%x running 0x%x ready %d\\n\",\n\t    sc->sc_xname, sc->sc_scheduled, sc->sc_running, RAY_ECF_READY(sc)));\n\n\tif (sc->sc_timoneed) {\n\t\tcallout_stop(&sc->sc_check_scheduled_ch);\n\t\tsc->sc_timoneed = 0;\n\t}\n\n\t/* if update subcmd is running -- clear it in scheduled */\n\tif (sc->sc_running & SCP_UPDATESUBCMD)\n\t\tsc->sc_scheduled &= ~SCP_UPDATESUBCMD;\n\n\tmask = SCP_FIRST;\n\tfor (i = 0; i < ray_ncmdtab; mask <<= 1, i++) {\n\t\tif ((sc->sc_scheduled & ~SCP_UPD_MASK) == 0)\n\t\t\tbreak;\n\t\tif (!RAY_ECF_READY(sc))\n\t\t\tbreak;\n\t\tif (sc->sc_scheduled & mask)\n\t\t\t(*ray_cmdtab[i])(sc);\n\t}\n\n\tRAY_DPRINTF((\n\t    \"%s: ray_check_scheduled exit sched 0x%x running 0x%x ready %d\\n\",\n\t    sc->sc_xname, sc->sc_scheduled, sc->sc_running, RAY_ECF_READY(sc)));\n\n\tif (sc->sc_scheduled & ~SCP_UPD_MASK)\n\t\tray_set_pending(sc, sc->sc_scheduled);\n\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tSCP_UPD_MASK\t\t0xff00",
            "#define\tSCP_UPDATESUBCMD\t0x0001",
            "#define\tSCP_FIRST\t\t0x0001",
            "#define\tsc_xname\tsc_dev.dv_xname",
            "#define\tcallout_stop\ttimeout_del"
          ],
          "globals_used": [
            "void ray_check_scheduled",
            "void ray_set_pending",
            "static const ray_cmd_func_t ray_cmdtab[] = {\n\tray_update_subcmd,\t/* SCP_UPDATESUBCMD */\n\tray_start_assoc,\t/* SCP_STARTASSOC */\n\tray_report_params,\t/* SCP_REPORTPARAMS */\n\tray_intr_start\t\t/* SCP_IFSTART */\n};",
            "static const int ray_ncmdtab = sizeof(ray_cmdtab) / sizeof(*ray_cmdtab);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSCP_UPD_MASK\t\t0xff00\n#define\tSCP_UPDATESUBCMD\t0x0001\n#define\tSCP_FIRST\t\t0x0001\n#define\tsc_xname\tsc_dev.dv_xname\n#define\tcallout_stop\ttimeout_del\n\nvoid ray_check_scheduled;\nvoid ray_set_pending;\nstatic const ray_cmd_func_t ray_cmdtab[] = {\n\tray_update_subcmd,\t/* SCP_UPDATESUBCMD */\n\tray_start_assoc,\t/* SCP_STARTASSOC */\n\tray_report_params,\t/* SCP_REPORTPARAMS */\n\tray_intr_start\t\t/* SCP_IFSTART */\n};\nstatic const int ray_ncmdtab = sizeof(ray_cmdtab) / sizeof(*ray_cmdtab);\n\nvoid\nray_check_scheduled(arg)\n\tvoid *arg;\n{\n\tstruct ray_softc *sc;\n\tint s, i, mask;\n\n\ts = splnet();\n\n\tsc = arg;\n\tRAY_DPRINTF((\n\t    \"%s: ray_check_scheduled enter schd 0x%x running 0x%x ready %d\\n\",\n\t    sc->sc_xname, sc->sc_scheduled, sc->sc_running, RAY_ECF_READY(sc)));\n\n\tif (sc->sc_timoneed) {\n\t\tcallout_stop(&sc->sc_check_scheduled_ch);\n\t\tsc->sc_timoneed = 0;\n\t}\n\n\t/* if update subcmd is running -- clear it in scheduled */\n\tif (sc->sc_running & SCP_UPDATESUBCMD)\n\t\tsc->sc_scheduled &= ~SCP_UPDATESUBCMD;\n\n\tmask = SCP_FIRST;\n\tfor (i = 0; i < ray_ncmdtab; mask <<= 1, i++) {\n\t\tif ((sc->sc_scheduled & ~SCP_UPD_MASK) == 0)\n\t\t\tbreak;\n\t\tif (!RAY_ECF_READY(sc))\n\t\t\tbreak;\n\t\tif (sc->sc_scheduled & mask)\n\t\t\t(*ray_cmdtab[i])(sc);\n\t}\n\n\tRAY_DPRINTF((\n\t    \"%s: ray_check_scheduled exit sched 0x%x running 0x%x ready %d\\n\",\n\t    sc->sc_xname, sc->sc_scheduled, sc->sc_running, RAY_ECF_READY(sc)));\n\n\tif (sc->sc_scheduled & ~SCP_UPD_MASK)\n\t\tray_set_pending(sc, sc->sc_scheduled);\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ray_free_ccs",
          "args": [
            "sc",
            "ccs"
          ],
          "line": 2018
        },
        "resolved": true,
        "details": {
          "function_name": "ray_free_ccs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2156-2172",
          "snippet": "u_int8_t\nray_free_ccs(sc, ccs)\n\tstruct ray_softc *sc;\n\tbus_size_t ccs;\n{\n\tu_int8_t stat;\n\n\tRAY_DPRINTF((\"%s: free_ccs idx %ld\\n\", sc->sc_xname,\n\t    RAY_GET_INDEX(ccs)));\n\n\tstat = SRAM_READ_FIELD_1(sc, ccs, ray_cmd, c_status);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_status, RAY_CCS_STATUS_FREE);\n\tif (ccs <= RAY_GET_CCS(RAY_CCS_LAST))\n\t\tsc->sc_ccsinuse[RAY_GET_INDEX(ccs)] = 0;\n\n\treturn (stat);\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tsc_xname\tsc_dev.dv_xname"
          ],
          "globals_used": [
            "u_int8_t ray_free_ccs"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_xname\tsc_dev.dv_xname\n\nu_int8_t ray_free_ccs;\n\nu_int8_t\nray_free_ccs(sc, ccs)\n\tstruct ray_softc *sc;\n\tbus_size_t ccs;\n{\n\tu_int8_t stat;\n\n\tRAY_DPRINTF((\"%s: free_ccs idx %ld\\n\", sc->sc_xname,\n\t    RAY_GET_INDEX(ccs)));\n\n\tstat = SRAM_READ_FIELD_1(sc, ccs, ray_cmd, c_status);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_status, RAY_CCS_STATUS_FREE);\n\tif (ccs <= RAY_GET_CCS(RAY_CCS_LAST))\n\t\tsc->sc_ccsinuse[RAY_GET_INDEX(ccs)] = 0;\n\n\treturn (stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: intr: unknown command 0x%x\\n\"",
            "sc->sc_if.if_xname",
            "cmd"
          ],
          "line": 2014
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ray_cmd_done",
          "args": [
            "sc",
            "SCP_STARTASSOC"
          ],
          "line": 1999
        },
        "resolved": true,
        "details": {
          "function_name": "ray_cmd_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2339-2356",
          "snippet": "void\nray_cmd_done(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_cmd_done 0x%x\\n\", sc->sc_xname, cmdf));\n\n\tsc->sc_running &= ~cmdf;\n\tif (cmdf & SCP_UPD_MASK) {\n\t\tsc->sc_running &= ~SCP_UPDATESUBCMD;\n\t\tif (sc->sc_scheduled & SCP_UPD_MASK)\n\t\t\tray_cmd_schedule(sc, sc->sc_scheduled & SCP_UPD_MASK);\n\t}\n\tif ((sc->sc_running & SCP_TIMOCHECK_CMD_MASK) == 0 && sc->sc_timocheck){\n\t\tcallout_stop(&sc->sc_check_ccs_ch);\n\t\tsc->sc_timocheck = 0;\n\t}\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tSCP_TIMOCHECK_CMD_MASK\t\\\n\t(SCP_UPD_UPDATEPARAMS | SCP_UPD_STARTUP | SCP_UPD_MCAST | \\\n\tSCP_UPD_PROMISC)",
            "#define\tSCP_UPD_MASK\t\t0xff00",
            "#define\tSCP_UPDATESUBCMD\t0x0001",
            "#define\tsc_xname\tsc_dev.dv_xname",
            "#define\tcallout_stop\ttimeout_del"
          ],
          "globals_used": [
            "void ray_cmd_schedule",
            "void ray_cmd_done"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSCP_TIMOCHECK_CMD_MASK\t\\\n\t(SCP_UPD_UPDATEPARAMS | SCP_UPD_STARTUP | SCP_UPD_MCAST | \\\n\tSCP_UPD_PROMISC)\n#define\tSCP_UPD_MASK\t\t0xff00\n#define\tSCP_UPDATESUBCMD\t0x0001\n#define\tsc_xname\tsc_dev.dv_xname\n#define\tcallout_stop\ttimeout_del\n\nvoid ray_cmd_schedule;\nvoid ray_cmd_done;\n\nvoid\nray_cmd_done(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_cmd_done 0x%x\\n\", sc->sc_xname, cmdf));\n\n\tsc->sc_running &= ~cmdf;\n\tif (cmdf & SCP_UPD_MASK) {\n\t\tsc->sc_running &= ~SCP_UPDATESUBCMD;\n\t\tif (sc->sc_scheduled & SCP_UPD_MASK)\n\t\t\tray_cmd_schedule(sc, sc->sc_scheduled & SCP_UPD_MASK);\n\t}\n\tif ((sc->sc_running & SCP_TIMOCHECK_CMD_MASK) == 0 && sc->sc_timocheck){\n\t\tcallout_stop(&sc->sc_check_ccs_ch);\n\t\tsc->sc_timocheck = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "SRAM_WRITE_FIELD_1",
          "args": [
            "sc",
            "ccs",
            "ray_cmd",
            "c_status",
            "RAY_CCS_STATUS_FREE"
          ],
          "line": 1995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ray_start_join_net_done",
          "args": [
            "sc",
            "cmd",
            "ccs",
            "stat"
          ],
          "line": 1986
        },
        "resolved": true,
        "details": {
          "function_name": "ray_start_join_net_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2754-2840",
          "snippet": "ray_cmd_func_t\nray_start_join_net_done(sc, cmd, ccs, stat)\n\tstruct ray_softc *sc;\n\tu_int cmd;\n\tbus_size_t ccs;\n\tu_int stat;\n{\n\tstruct ray_net_params np;\n\n\tcallout_stop(&sc->sc_start_join_timo_ch);\n\tray_cmd_done(sc, SCP_UPD_STARTJOIN);\n\n\tif (stat == RAY_CCS_STATUS_FAIL) {\n\t\t/* XXX poke ifmedia when it supports this */\n\t\tsc->sc_havenet = 0;\n\t\treturn (ray_start_join_net);\n\t}\n\tif (stat == RAY_CCS_STATUS_BUSY || stat == RAY_CCS_STATUS_FREE) {\n\t\t/* handle the timeout condition */\n\t\tcallout_reset(&sc->sc_start_join_timo_ch, RAY_START_TIMEOUT,\n\t\t    ray_start_join_timo, sc);\n\n\t\t/* be safe -- not a lot occurs with no net though */\n\t\tif (!RAY_ECF_READY(sc))\n\t\t\treturn (0);\n\n\t\t/* see if our nwid is up to date */\n\t\tif (!memcmp(sc->sc_cnwid, sc->sc_dnwid, sizeof(sc->sc_cnwid))\n\t\t    && sc->sc_omode == sc->sc_mode)\n\t\t\tSRAM_WRITE_FIELD_1(sc,ccs, ray_cmd_net, c_upd_param, 0);\n\t\telse {\n\t\t\tmemset(&np, 0, sizeof(np));\n\t\t\tnp.p_net_type = sc->sc_mode;\n\t\t\tmemcpy(np.p_ssid, sc->sc_dnwid, sizeof(np.p_ssid));\n\t\t\tray_write_region(sc, RAY_HOST_TO_ECF_BASE, &np,\n\t\t\t    sizeof(np));\n\t\t\tSRAM_WRITE_FIELD_1(sc,ccs, ray_cmd_net, c_upd_param, 1);\n\t\t}\n\n\t\tif (sc->sc_mode == SC_MODE_ADHOC)\n\t\t\tcmd = RAY_CMD_START_NET;\n\t\telse\n\t\t\tcmd = RAY_CMD_JOIN_NET;\n\t\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_net, c_cmd,\n\t\t    RAY_CCS_STATUS_BUSY);\n\t\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_net, c_status,\n\t\t    RAY_CCS_STATUS_BUSY);\n\n\t\t/* we simply poke the card again issuing the same ccs */\n\t\tSRAM_WRITE_1(sc, RAY_SCB_CCSI, RAY_GET_INDEX(ccs));\n\t\tRAY_ECF_START_CMD(sc);\n\t\tray_cmd_ran(sc, SCP_UPD_STARTJOIN);\n\t\treturn (0);\n\t}\n\t/* get the current ssid */\n\tSRAM_READ_FIELD_N(sc, ccs, ray_cmd_net, c_bss_id, sc->sc_bssid,\n\t    sizeof(sc->sc_bssid));\n\n\tsc->sc_deftxrate = SRAM_READ_FIELD_1(sc, ccs, ray_cmd_net,c_def_txrate);\n\tsc->sc_encrypt = SRAM_READ_FIELD_1(sc, ccs, ray_cmd_net, c_encrypt);\n\n\t/* adjust values for buggy build 4 */\n\tif (sc->sc_deftxrate == 0x55)\n\t\tsc->sc_deftxrate = RAY_PID_BASIC_RATE_1500K;\n\tif (sc->sc_encrypt == 0x55)\n\t\tsc->sc_encrypt = 0;\n\n\tif (SRAM_READ_FIELD_1(sc, ccs, ray_cmd_net, c_upd_param)) {\n\t\tray_read_region(sc, RAY_HOST_TO_ECF_BASE, &np, sizeof(np));\n\t\tmemcpy(sc->sc_cnwid, np.p_ssid, sizeof(sc->sc_cnwid));\n\t\tsc->sc_omode = sc->sc_mode;\n\t\tif (np.p_net_type != sc->sc_mode)\n\t\t\treturn (ray_start_join_net);\n\t}\n\tRAY_DPRINTF((\"%s: net start/join nwid %.32s bssid %s inited %d\\n\",\n\t    sc->sc_xname, sc->sc_cnwid, ether_sprintf(sc->sc_bssid),\n\t\tSRAM_READ_FIELD_1(sc, ccs, ray_cmd_net, c_inited)));\n\n\t/* network is now active */\n\tray_cmd_schedule(sc, SCP_UPD_MCAST|SCP_UPD_PROMISC);\n\tif (cmd == RAY_CMD_JOIN_NET)\n\t\treturn (ray_start_assoc);\n\telse {\n\t\tsc->sc_havenet = 1;\n\t\treturn (ray_intr_start);\n\t}\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tSCP_UPD_MCAST\t\t0x0800",
            "#define\tSCP_UPD_PROMISC\t\t0x0400",
            "#define\tSCP_UPD_STARTJOIN\t0x0200",
            "#define\tSC_MODE_ADHOC\t0\t/* ad-hoc mode */",
            "#define\tsc_xname\tsc_dev.dv_xname",
            "#define\tcallout_stop\ttimeout_del",
            "#define\tRAY_START_TIMEOUT\t(10 * hz)"
          ],
          "globals_used": [
            "void ray_cmd_schedule",
            "void ray_cmd_ran",
            "void ray_cmd_done",
            "void ray_intr_start",
            "void ray_start_assoc",
            "void ray_start_join_net",
            "ray_cmd_func_t ray_start_join_net_done",
            "void ray_start_join_timo"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSCP_UPD_MCAST\t\t0x0800\n#define\tSCP_UPD_PROMISC\t\t0x0400\n#define\tSCP_UPD_STARTJOIN\t0x0200\n#define\tSC_MODE_ADHOC\t0\t/* ad-hoc mode */\n#define\tsc_xname\tsc_dev.dv_xname\n#define\tcallout_stop\ttimeout_del\n#define\tRAY_START_TIMEOUT\t(10 * hz)\n\nvoid ray_cmd_schedule;\nvoid ray_cmd_ran;\nvoid ray_cmd_done;\nvoid ray_intr_start;\nvoid ray_start_assoc;\nvoid ray_start_join_net;\nray_cmd_func_t ray_start_join_net_done;\nvoid ray_start_join_timo;\n\nray_cmd_func_t\nray_start_join_net_done(sc, cmd, ccs, stat)\n\tstruct ray_softc *sc;\n\tu_int cmd;\n\tbus_size_t ccs;\n\tu_int stat;\n{\n\tstruct ray_net_params np;\n\n\tcallout_stop(&sc->sc_start_join_timo_ch);\n\tray_cmd_done(sc, SCP_UPD_STARTJOIN);\n\n\tif (stat == RAY_CCS_STATUS_FAIL) {\n\t\t/* XXX poke ifmedia when it supports this */\n\t\tsc->sc_havenet = 0;\n\t\treturn (ray_start_join_net);\n\t}\n\tif (stat == RAY_CCS_STATUS_BUSY || stat == RAY_CCS_STATUS_FREE) {\n\t\t/* handle the timeout condition */\n\t\tcallout_reset(&sc->sc_start_join_timo_ch, RAY_START_TIMEOUT,\n\t\t    ray_start_join_timo, sc);\n\n\t\t/* be safe -- not a lot occurs with no net though */\n\t\tif (!RAY_ECF_READY(sc))\n\t\t\treturn (0);\n\n\t\t/* see if our nwid is up to date */\n\t\tif (!memcmp(sc->sc_cnwid, sc->sc_dnwid, sizeof(sc->sc_cnwid))\n\t\t    && sc->sc_omode == sc->sc_mode)\n\t\t\tSRAM_WRITE_FIELD_1(sc,ccs, ray_cmd_net, c_upd_param, 0);\n\t\telse {\n\t\t\tmemset(&np, 0, sizeof(np));\n\t\t\tnp.p_net_type = sc->sc_mode;\n\t\t\tmemcpy(np.p_ssid, sc->sc_dnwid, sizeof(np.p_ssid));\n\t\t\tray_write_region(sc, RAY_HOST_TO_ECF_BASE, &np,\n\t\t\t    sizeof(np));\n\t\t\tSRAM_WRITE_FIELD_1(sc,ccs, ray_cmd_net, c_upd_param, 1);\n\t\t}\n\n\t\tif (sc->sc_mode == SC_MODE_ADHOC)\n\t\t\tcmd = RAY_CMD_START_NET;\n\t\telse\n\t\t\tcmd = RAY_CMD_JOIN_NET;\n\t\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_net, c_cmd,\n\t\t    RAY_CCS_STATUS_BUSY);\n\t\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_net, c_status,\n\t\t    RAY_CCS_STATUS_BUSY);\n\n\t\t/* we simply poke the card again issuing the same ccs */\n\t\tSRAM_WRITE_1(sc, RAY_SCB_CCSI, RAY_GET_INDEX(ccs));\n\t\tRAY_ECF_START_CMD(sc);\n\t\tray_cmd_ran(sc, SCP_UPD_STARTJOIN);\n\t\treturn (0);\n\t}\n\t/* get the current ssid */\n\tSRAM_READ_FIELD_N(sc, ccs, ray_cmd_net, c_bss_id, sc->sc_bssid,\n\t    sizeof(sc->sc_bssid));\n\n\tsc->sc_deftxrate = SRAM_READ_FIELD_1(sc, ccs, ray_cmd_net,c_def_txrate);\n\tsc->sc_encrypt = SRAM_READ_FIELD_1(sc, ccs, ray_cmd_net, c_encrypt);\n\n\t/* adjust values for buggy build 4 */\n\tif (sc->sc_deftxrate == 0x55)\n\t\tsc->sc_deftxrate = RAY_PID_BASIC_RATE_1500K;\n\tif (sc->sc_encrypt == 0x55)\n\t\tsc->sc_encrypt = 0;\n\n\tif (SRAM_READ_FIELD_1(sc, ccs, ray_cmd_net, c_upd_param)) {\n\t\tray_read_region(sc, RAY_HOST_TO_ECF_BASE, &np, sizeof(np));\n\t\tmemcpy(sc->sc_cnwid, np.p_ssid, sizeof(sc->sc_cnwid));\n\t\tsc->sc_omode = sc->sc_mode;\n\t\tif (np.p_net_type != sc->sc_mode)\n\t\t\treturn (ray_start_join_net);\n\t}\n\tRAY_DPRINTF((\"%s: net start/join nwid %.32s bssid %s inited %d\\n\",\n\t    sc->sc_xname, sc->sc_cnwid, ether_sprintf(sc->sc_bssid),\n\t\tSRAM_READ_FIELD_1(sc, ccs, ray_cmd_net, c_inited)));\n\n\t/* network is now active */\n\tray_cmd_schedule(sc, SCP_UPD_MCAST|SCP_UPD_PROMISC);\n\tif (cmd == RAY_CMD_JOIN_NET)\n\t\treturn (ray_start_assoc);\n\telse {\n\t\tsc->sc_havenet = 1;\n\t\treturn (ray_intr_start);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "ray_report_params"
          ],
          "line": 1977
        },
        "resolved": true,
        "details": {
          "function_name": "audio_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "765-774",
          "snippet": "static __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nstatic __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ray_read_region",
          "args": [
            "sc",
            "RAY_ECF_TO_HOST_BASE",
            "sc->sc_repreq->r_data",
            "sc->sc_repreq->r_len"
          ],
          "line": 1974
        },
        "resolved": true,
        "details": {
          "function_name": "ray_read_region",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "3063-3116",
          "snippet": "void\nray_read_region(sc, off, vp, c)\n\tstruct ray_softc *sc;\n\tbus_size_t off;\n\tvoid *vp;\n\tsize_t c;\n{\n#ifdef RAY_USE_OPTIMIZED_COPY\n\tu_int n2, n4, tmp;\n\tu_int8_t *p;\n\n\tp = vp;\n\n\t/* XXX we may be making poor assumptions here but lets hope */\n\tswitch ((off|(bus_addr_t)p) & 0x03) {\n\tcase 0:\n\t\tif ((n4 = c / 4)) {\n\t\t\tbus_space_read_region_4(sc->sc_memt, sc->sc_memh, off,\n\t\t\t    p, n4);\n\t\t\ttmp = c & ~0x3;\n\t\t\tc &= 0x3;\n\t\t\tp += tmp;\n\t\t\toff += tmp;\n\t\t}\n\t\tswitch (c) {\n\t\tcase 3:\n\t\t\t*p = bus_space_read_1(sc->sc_memt,sc->sc_memh, off);\n\t\t\tp++, off++;\n\t\tcase 2:\n\t\t\t*p = bus_space_read_1(sc->sc_memt,sc->sc_memh, off);\n\t\t\tp++, off++;\n\t\tcase 1:\n\t\t\t*p = bus_space_read_1(sc->sc_memt,sc->sc_memh, off);\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tif ((n2 = (c >> 1)))\n\t\t\tbus_space_read_region_2(sc->sc_memt, sc->sc_memh, off,\n\t\t\t    p, n2);\n\t\tif (c & 1) {\n\t\t\tc &= ~0x1;\n\t\t\t*(p + c) = bus_space_read_1(sc->sc_memt, sc->sc_memh,\n\t\t\t    off + c);\n\t\t}\n\t\tbreak;\n\tcase 1:\n\tcase 3:\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_memh, off, p, c);\n\t\tbreak;\n\t}\n#else\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_memh, off, vp, c);\n#endif\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tsc_memh\tsc_mem.memh",
            "#define\tsc_memt\tsc_mem.memt"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_memh\tsc_mem.memh\n#define\tsc_memt\tsc_mem.memt\n\nvoid\nray_read_region(sc, off, vp, c)\n\tstruct ray_softc *sc;\n\tbus_size_t off;\n\tvoid *vp;\n\tsize_t c;\n{\n#ifdef RAY_USE_OPTIMIZED_COPY\n\tu_int n2, n4, tmp;\n\tu_int8_t *p;\n\n\tp = vp;\n\n\t/* XXX we may be making poor assumptions here but lets hope */\n\tswitch ((off|(bus_addr_t)p) & 0x03) {\n\tcase 0:\n\t\tif ((n4 = c / 4)) {\n\t\t\tbus_space_read_region_4(sc->sc_memt, sc->sc_memh, off,\n\t\t\t    p, n4);\n\t\t\ttmp = c & ~0x3;\n\t\t\tc &= 0x3;\n\t\t\tp += tmp;\n\t\t\toff += tmp;\n\t\t}\n\t\tswitch (c) {\n\t\tcase 3:\n\t\t\t*p = bus_space_read_1(sc->sc_memt,sc->sc_memh, off);\n\t\t\tp++, off++;\n\t\tcase 2:\n\t\t\t*p = bus_space_read_1(sc->sc_memt,sc->sc_memh, off);\n\t\t\tp++, off++;\n\t\tcase 1:\n\t\t\t*p = bus_space_read_1(sc->sc_memt,sc->sc_memh, off);\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tif ((n2 = (c >> 1)))\n\t\t\tbus_space_read_region_2(sc->sc_memt, sc->sc_memh, off,\n\t\t\t    p, n2);\n\t\tif (c & 1) {\n\t\t\tc &= ~0x1;\n\t\t\t*(p + c) = bus_space_read_1(sc->sc_memt, sc->sc_memh,\n\t\t\t    off + c);\n\t\t}\n\t\tbreak;\n\tcase 1:\n\tcase 3:\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_memh, off, p, c);\n\t\tbreak;\n\t}\n#else\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_memh, off, vp, c);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "SRAM_READ_FIELD_1",
          "args": [
            "sc",
            "ccs",
            "ray_cmd_report",
            "c_len"
          ],
          "line": 1973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRAM_READ_FIELD_1",
          "args": [
            "sc",
            "ccs",
            "ray_cmd_report",
            "c_failcause"
          ],
          "line": 1971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ray_update_params_done",
          "args": [
            "sc",
            "ccs",
            "stat"
          ],
          "line": 1963
        },
        "resolved": true,
        "details": {
          "function_name": "ray_update_params_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "1742-1778",
          "snippet": "ray_cmd_func_t\nray_update_params_done(sc, ccs, stat)\n\tstruct ray_softc *sc;\n\tbus_size_t ccs;\n\tu_int stat;\n{\n\tray_cmd_func_t rcmd;\n\n\trcmd = 0;\n\n\tRAY_DPRINTF((\"%s: ray_update_params_done stat %d\\n\",\n\t   sc->sc_xname, stat));\n\n\t/* this will get more complex as we add commands */\n\tif (stat == RAY_CCS_STATUS_FAIL) {\n\t\tprintf(\"%s: failed to update a promisc\\n\", sc->sc_xname);\n\t\t/* XXX should probably reset */\n\t\t/* rcmd = ray_reset; */\n\t}\n\n\tif (sc->sc_running & SCP_UPD_PROMISC) {\n\t\tray_cmd_done(sc, SCP_UPD_PROMISC);\n\t\tsc->sc_promisc = SRAM_READ_1(sc, RAY_HOST_TO_ECF_BASE);\n\t\tRAY_DPRINTF((\"%s: new promisc value %d\\n\", sc->sc_xname,\n\t\t    sc->sc_promisc));\n\t} else if (sc->sc_updreq) {\n\t\tray_cmd_done(sc, SCP_UPD_UPDATEPARAMS);\n\t\t/* get the update parameter */\n\t\tsc->sc_updreq->r_failcause =\n\t\t    SRAM_READ_FIELD_1(sc, ccs, ray_cmd_update, c_failcause);\n\t\tsc->sc_updreq = 0;\n\t\twakeup(ray_update_params);\n\n\t\trcmd = ray_start_join_net;\n\t}\n\treturn (rcmd);\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tSCP_UPD_UPDATEPARAMS\t0x1000",
            "#define\tSCP_UPD_PROMISC\t\t0x0400",
            "#define\tsc_xname\tsc_dev.dv_xname"
          ],
          "globals_used": [
            "void ray_cmd_done",
            "void ray_reset",
            "void ray_start_join_net",
            "ray_cmd_func_t ray_update_params_done",
            "void ray_update_params"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSCP_UPD_UPDATEPARAMS\t0x1000\n#define\tSCP_UPD_PROMISC\t\t0x0400\n#define\tsc_xname\tsc_dev.dv_xname\n\nvoid ray_cmd_done;\nvoid ray_reset;\nvoid ray_start_join_net;\nray_cmd_func_t ray_update_params_done;\nvoid ray_update_params;\n\nray_cmd_func_t\nray_update_params_done(sc, ccs, stat)\n\tstruct ray_softc *sc;\n\tbus_size_t ccs;\n\tu_int stat;\n{\n\tray_cmd_func_t rcmd;\n\n\trcmd = 0;\n\n\tRAY_DPRINTF((\"%s: ray_update_params_done stat %d\\n\",\n\t   sc->sc_xname, stat));\n\n\t/* this will get more complex as we add commands */\n\tif (stat == RAY_CCS_STATUS_FAIL) {\n\t\tprintf(\"%s: failed to update a promisc\\n\", sc->sc_xname);\n\t\t/* XXX should probably reset */\n\t\t/* rcmd = ray_reset; */\n\t}\n\n\tif (sc->sc_running & SCP_UPD_PROMISC) {\n\t\tray_cmd_done(sc, SCP_UPD_PROMISC);\n\t\tsc->sc_promisc = SRAM_READ_1(sc, RAY_HOST_TO_ECF_BASE);\n\t\tRAY_DPRINTF((\"%s: new promisc value %d\\n\", sc->sc_xname,\n\t\t    sc->sc_promisc));\n\t} else if (sc->sc_updreq) {\n\t\tray_cmd_done(sc, SCP_UPD_UPDATEPARAMS);\n\t\t/* get the update parameter */\n\t\tsc->sc_updreq->r_failcause =\n\t\t    SRAM_READ_FIELD_1(sc, ccs, ray_cmd_update, c_failcause);\n\t\tsc->sc_updreq = 0;\n\t\twakeup(ray_update_params);\n\n\t\trcmd = ray_start_join_net;\n\t}\n\treturn (rcmd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sc->sc_cnwid",
            "sc->sc_dnwid",
            "sizeof(sc->sc_cnwid)"
          ],
          "line": 1958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: ray_ccs_done idx %ld cmd 0x%x stat %d\\n\",\n\t    sc->sc_xname, RAY_GET_INDEX(ccs), cmd, stat)"
          ],
          "line": 1942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_GET_INDEX",
          "args": [
            "ccs"
          ],
          "line": 1943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRAM_READ_FIELD_1",
          "args": [
            "sc",
            "ccs",
            "ray_cmd",
            "c_status"
          ],
          "line": 1940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRAM_READ_FIELD_1",
          "args": [
            "sc",
            "ccs",
            "ray_cmd",
            "c_cmd"
          ],
          "line": 1939
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSCP_UPD_MCAST\t\t0x0800\n#define\tSCP_UPD_STARTUP\t\t0x0100\n#define\tSCP_REPORTPARAMS\t0x0004\n#define\tSCP_STARTASSOC\t\t0x0002\n#define\tsc_xname\tsc_dev.dv_xname\n#define\tsc_if\t\tsc_ec.ac_if\n#define\tsc_if\t\tsc_ec.ec_if\n\nray_cmd_func_t ray_ccs_done;\nvoid ray_check_scheduled;\nvoid ray_cmd_done;\nu_int8_t ray_free_ccs;\nvoid ray_intr_start;\nvoid ray_report_params;\nvoid ray_reset;\nvoid ray_start_join_net;\nray_cmd_func_t ray_start_join_net_done;\nray_cmd_func_t ray_update_params_done;\n\nray_cmd_func_t\nray_ccs_done(sc, ccs)\n\tstruct ray_softc *sc;\n\tbus_size_t ccs;\n{\n\tstruct ifnet *ifp;\n\tray_cmd_func_t rcmd;\n\tu_int cmd, stat;\n\n\tifp = &sc->sc_if;\n\tcmd = SRAM_READ_FIELD_1(sc, ccs, ray_cmd, c_cmd);\n\tstat = SRAM_READ_FIELD_1(sc, ccs, ray_cmd, c_status);\n\n\tRAY_DPRINTF((\"%s: ray_ccs_done idx %ld cmd 0x%x stat %d\\n\",\n\t    sc->sc_xname, RAY_GET_INDEX(ccs), cmd, stat));\n\n\trcmd = 0;\n\tswitch (cmd) {\n\t/*\n\t * solicited commands\n\t */\n\tcase RAY_CMD_START_PARAMS:\n\t\t/* start network */\n\t\tray_cmd_done(sc, SCP_UPD_STARTUP);\n\n\t\t/* ok to start queueing packets */\n\t\tsc->sc_if.if_flags &= ~IFF_OACTIVE;\n\n\t\tsc->sc_omode = sc->sc_mode;\n\t\tmemcpy(sc->sc_cnwid, sc->sc_dnwid, sizeof(sc->sc_cnwid));\n\n\t\trcmd = ray_start_join_net;\n\t\tbreak;\n\tcase RAY_CMD_UPDATE_PARAMS:\n\t\trcmd = ray_update_params_done(sc, ccs, stat);\n\t\tbreak;\n\tcase RAY_CMD_REPORT_PARAMS:\n\t\t/* get the reported parameters */\n\t\tray_cmd_done(sc, SCP_REPORTPARAMS);\n\t\tif (!sc->sc_repreq)\n\t\t\tbreak;\n\t\tsc->sc_repreq->r_failcause =\n\t\t    SRAM_READ_FIELD_1(sc, ccs, ray_cmd_report, c_failcause);\n\t\tsc->sc_repreq->r_len =\n\t\t    SRAM_READ_FIELD_1(sc, ccs, ray_cmd_report, c_len);\n\t\tray_read_region(sc, RAY_ECF_TO_HOST_BASE, sc->sc_repreq->r_data,\n\t\t    sc->sc_repreq->r_len);\n\t\tsc->sc_repreq = 0;\n\t\twakeup(ray_report_params);\n\t\tbreak;\n\tcase RAY_CMD_UPDATE_MCAST:\n\t\tray_cmd_done(sc, SCP_UPD_MCAST);\n\t\tif (stat == RAY_CCS_STATUS_FAIL)\n\t\t\trcmd = ray_reset;\n\t\tbreak;\n\tcase RAY_CMD_START_NET:\n\tcase RAY_CMD_JOIN_NET:\n\t\trcmd = ray_start_join_net_done(sc, cmd, ccs, stat);\n\t\tbreak;\n\tcase RAY_CMD_TX_REQ:\n\t\tif (sc->sc_if.if_flags & IFF_OACTIVE) {\n\t\t\tsc->sc_if.if_flags &= ~IFF_OACTIVE;\n\t\t\t/* this may also be a problem */\n\t\t\trcmd = ray_intr_start;\n\t\t}\n\t\t/* free it -- no tracking */\n\t\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_status,\n\t\t    RAY_CCS_STATUS_FREE);\n\t\tgoto done;\n\tcase RAY_CMD_START_ASSOC:\n\t\tray_cmd_done(sc, SCP_STARTASSOC);\n\t\tif (stat == RAY_CCS_STATUS_FAIL)\n\t\t\trcmd = ray_start_join_net;\t/* XXX check */\n\t\telse {\n\t\t\tsc->sc_havenet = 1;\n\t\t\trcmd = ray_intr_start;\n\t\t}\n\t\tbreak;\n\tcase RAY_CMD_UPDATE_APM:\n\tcase RAY_CMD_TEST_MEM:\n\tcase RAY_CMD_SHUTDOWN:\n\tcase RAY_CMD_DUMP_MEM:\n\tcase RAY_CMD_START_TIMER:\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: intr: unknown command 0x%x\\n\",\n\t\t    sc->sc_if.if_xname, cmd);\n\t\tbreak;\n\t}\n\tray_free_ccs(sc, ccs);\ndone:\n\t/*\n\t * see if needed things can be done now that a command\n\t * has completed\n\t */\n\tray_check_scheduled(sc);\n\n\treturn (rcmd);\n}"
  },
  {
    "function_name": "ray_update_error_counters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
    "lines": "1900-1924",
    "snippet": "void\nray_update_error_counters(sc)\n\tstruct ray_softc *sc;\n{\n\tbus_size_t csc;\n\n\t/* try and update the error counters */\n\tcsc = RAY_STATUS_BASE;\n\tif (SRAM_READ_FIELD_1(sc, csc, ray_csc, csc_mrxo_own)) {\n\t\tsc->sc_rxoverflow +=\n\t\t    SRAM_READ_FIELD_2(sc, csc, ray_csc, csc_mrx_overflow);\n\t\tSRAM_WRITE_FIELD_1(sc, csc, ray_csc, csc_mrxo_own, 0);\n\t}\n\tif (SRAM_READ_FIELD_1(sc, csc, ray_csc, csc_mrxc_own)) {\n\t\tsc->sc_rxcksum +=\n\t\t    SRAM_READ_FIELD_2(sc, csc, ray_csc, csc_mrx_overflow);\n\t\tSRAM_WRITE_FIELD_1(sc, csc, ray_csc, csc_mrxc_own, 0);\n\t}\n\tif (SRAM_READ_FIELD_1(sc, csc, ray_csc, csc_rxhc_own)) {\n\t\tsc->sc_rxhcksum +=\n\t\t    SRAM_READ_FIELD_2(sc, csc, ray_csc, csc_rx_hcksum);\n\t\tSRAM_WRITE_FIELD_1(sc, csc, ray_csc, csc_rxhc_own, 0);\n\t}\n\tsc->sc_rxnoise = SRAM_READ_FIELD_1(sc, csc, ray_csc, csc_rx_noise);\n}",
    "includes": [
      "#include <dev/pcmcia/if_rayreg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_llc.h>",
      "#include <net/if_media.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/timeout.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void ray_update_error_counters"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SRAM_READ_FIELD_1",
          "args": [
            "sc",
            "csc",
            "ray_csc",
            "csc_rx_noise"
          ],
          "line": 1923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRAM_WRITE_FIELD_1",
          "args": [
            "sc",
            "csc",
            "ray_csc",
            "csc_rxhc_own",
            "0"
          ],
          "line": 1921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRAM_READ_FIELD_2",
          "args": [
            "sc",
            "csc",
            "ray_csc",
            "csc_rx_hcksum"
          ],
          "line": 1920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRAM_READ_FIELD_1",
          "args": [
            "sc",
            "csc",
            "ray_csc",
            "csc_rxhc_own"
          ],
          "line": 1918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRAM_WRITE_FIELD_1",
          "args": [
            "sc",
            "csc",
            "ray_csc",
            "csc_mrxc_own",
            "0"
          ],
          "line": 1916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRAM_READ_FIELD_2",
          "args": [
            "sc",
            "csc",
            "ray_csc",
            "csc_mrx_overflow"
          ],
          "line": 1915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRAM_READ_FIELD_1",
          "args": [
            "sc",
            "csc",
            "ray_csc",
            "csc_mrxc_own"
          ],
          "line": 1913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRAM_WRITE_FIELD_1",
          "args": [
            "sc",
            "csc",
            "ray_csc",
            "csc_mrxo_own",
            "0"
          ],
          "line": 1911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRAM_READ_FIELD_2",
          "args": [
            "sc",
            "csc",
            "ray_csc",
            "csc_mrx_overflow"
          ],
          "line": 1910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRAM_READ_FIELD_1",
          "args": [
            "sc",
            "csc",
            "ray_csc",
            "csc_mrxo_own"
          ],
          "line": 1908
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\nvoid ray_update_error_counters;\n\nvoid\nray_update_error_counters(sc)\n\tstruct ray_softc *sc;\n{\n\tbus_size_t csc;\n\n\t/* try and update the error counters */\n\tcsc = RAY_STATUS_BASE;\n\tif (SRAM_READ_FIELD_1(sc, csc, ray_csc, csc_mrxo_own)) {\n\t\tsc->sc_rxoverflow +=\n\t\t    SRAM_READ_FIELD_2(sc, csc, ray_csc, csc_mrx_overflow);\n\t\tSRAM_WRITE_FIELD_1(sc, csc, ray_csc, csc_mrxo_own, 0);\n\t}\n\tif (SRAM_READ_FIELD_1(sc, csc, ray_csc, csc_mrxc_own)) {\n\t\tsc->sc_rxcksum +=\n\t\t    SRAM_READ_FIELD_2(sc, csc, ray_csc, csc_mrx_overflow);\n\t\tSRAM_WRITE_FIELD_1(sc, csc, ray_csc, csc_mrxc_own, 0);\n\t}\n\tif (SRAM_READ_FIELD_1(sc, csc, ray_csc, csc_rxhc_own)) {\n\t\tsc->sc_rxhcksum +=\n\t\t    SRAM_READ_FIELD_2(sc, csc, ray_csc, csc_rx_hcksum);\n\t\tSRAM_WRITE_FIELD_1(sc, csc, ray_csc, csc_rxhc_own, 0);\n\t}\n\tsc->sc_rxnoise = SRAM_READ_FIELD_1(sc, csc, ray_csc, csc_rx_noise);\n}"
  },
  {
    "function_name": "ray_check_ccs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
    "lines": "1833-1890",
    "snippet": "void\nray_check_ccs(arg)\n\tvoid *arg;\n{\n\tray_cmd_func_t fp;\n\tstruct ray_softc *sc;\n\tu_int i, cmd, stat;\n\tbus_size_t ccs;\n\tint s;\n\n\ts = splnet();\n\tsc = arg;\n\n\tRAY_DPRINTF((\"%s: ray_check_ccs\\n\", sc->sc_xname));\n\n\tsc->sc_timocheck = 0;\n\tfor (i = RAY_CCS_CMD_FIRST; i <= RAY_CCS_CMD_LAST; i++) {\n\t\tif (!sc->sc_ccsinuse[i])\n\t\t\tcontinue;\n\t\tccs = RAY_GET_CCS(i);\n\t\tcmd = SRAM_READ_FIELD_1(sc, ccs, ray_cmd, c_cmd);\n\t\tswitch (cmd) {\n\t\tcase RAY_CMD_START_PARAMS:\n\t\tcase RAY_CMD_UPDATE_MCAST:\n\t\tcase RAY_CMD_UPDATE_PARAMS:\n\t\t\tstat = SRAM_READ_FIELD_1(sc, ccs, ray_cmd, c_status);\n\t\t\tRAY_DPRINTF((\"%s: check ccs idx %d ccs 0x%lx \"\n\t\t\t    \"cmd 0x%x stat %d\\n\", sc->sc_xname, i,\n\t\t\t    ccs, cmd, stat));\n\t\t\tgoto breakout;\n\t\t}\n\t}\nbreakout:\n\t/* see if we got one of the commands we are looking for */\n\tif (i > RAY_CCS_CMD_LAST)\n\t\t; /* nothign */\n\telse if (stat == RAY_CCS_STATUS_FREE) {\n\t\tstat = RAY_CCS_STATUS_COMPLETE;\n\t\tif ((fp = ray_ccs_done(sc, ccs)))\n\t\t\t(*fp)(sc);\n\t} else if (stat != RAY_CCS_STATUS_BUSY) {\n\t\tif (sc->sc_ccsinuse[i] == 1) {\n\t\t\t/* give a chance for the interrupt to occur */\n\t\t\tsc->sc_ccsinuse[i] = 2;\n\t\t\tif (!sc->sc_timocheck) {\n\t\t\t\tcallout_reset(&sc->sc_check_ccs_ch, 1,\n\t\t\t\t    ray_check_ccs, sc);\n\t\t\t\tsc->sc_timocheck = 1;\n\t\t\t}\n\t\t} else if ((fp = ray_ccs_done(sc, ccs)))\n\t\t\t(*fp)(sc);\n\t} else {\n\t\tcallout_reset(&sc->sc_check_ccs_ch, RAY_CHECK_CCS_TIMEOUT,\n\t\t    ray_check_ccs, sc);\n\t\tsc->sc_timocheck = 1;\n\t}\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/pcmcia/if_rayreg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_llc.h>",
      "#include <net/if_media.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/timeout.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [
      "#define\tsc_xname\tsc_dev.dv_xname",
      "#define\tRAY_CHECK_CCS_TIMEOUT\t(hz / 2)"
    ],
    "globals_used": [
      "ray_cmd_func_t ray_ccs_done",
      "void ray_check_ccs"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "callout_reset",
          "args": [
            "&sc->sc_check_ccs_ch",
            "RAY_CHECK_CCS_TIMEOUT",
            "ray_check_ccs",
            "sc"
          ],
          "line": 1885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc"
          ],
          "line": 1883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ray_ccs_done",
          "args": [
            "sc",
            "ccs"
          ],
          "line": 1882
        },
        "resolved": true,
        "details": {
          "function_name": "ray_ccs_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "1929-2027",
          "snippet": "ray_cmd_func_t\nray_ccs_done(sc, ccs)\n\tstruct ray_softc *sc;\n\tbus_size_t ccs;\n{\n\tstruct ifnet *ifp;\n\tray_cmd_func_t rcmd;\n\tu_int cmd, stat;\n\n\tifp = &sc->sc_if;\n\tcmd = SRAM_READ_FIELD_1(sc, ccs, ray_cmd, c_cmd);\n\tstat = SRAM_READ_FIELD_1(sc, ccs, ray_cmd, c_status);\n\n\tRAY_DPRINTF((\"%s: ray_ccs_done idx %ld cmd 0x%x stat %d\\n\",\n\t    sc->sc_xname, RAY_GET_INDEX(ccs), cmd, stat));\n\n\trcmd = 0;\n\tswitch (cmd) {\n\t/*\n\t * solicited commands\n\t */\n\tcase RAY_CMD_START_PARAMS:\n\t\t/* start network */\n\t\tray_cmd_done(sc, SCP_UPD_STARTUP);\n\n\t\t/* ok to start queueing packets */\n\t\tsc->sc_if.if_flags &= ~IFF_OACTIVE;\n\n\t\tsc->sc_omode = sc->sc_mode;\n\t\tmemcpy(sc->sc_cnwid, sc->sc_dnwid, sizeof(sc->sc_cnwid));\n\n\t\trcmd = ray_start_join_net;\n\t\tbreak;\n\tcase RAY_CMD_UPDATE_PARAMS:\n\t\trcmd = ray_update_params_done(sc, ccs, stat);\n\t\tbreak;\n\tcase RAY_CMD_REPORT_PARAMS:\n\t\t/* get the reported parameters */\n\t\tray_cmd_done(sc, SCP_REPORTPARAMS);\n\t\tif (!sc->sc_repreq)\n\t\t\tbreak;\n\t\tsc->sc_repreq->r_failcause =\n\t\t    SRAM_READ_FIELD_1(sc, ccs, ray_cmd_report, c_failcause);\n\t\tsc->sc_repreq->r_len =\n\t\t    SRAM_READ_FIELD_1(sc, ccs, ray_cmd_report, c_len);\n\t\tray_read_region(sc, RAY_ECF_TO_HOST_BASE, sc->sc_repreq->r_data,\n\t\t    sc->sc_repreq->r_len);\n\t\tsc->sc_repreq = 0;\n\t\twakeup(ray_report_params);\n\t\tbreak;\n\tcase RAY_CMD_UPDATE_MCAST:\n\t\tray_cmd_done(sc, SCP_UPD_MCAST);\n\t\tif (stat == RAY_CCS_STATUS_FAIL)\n\t\t\trcmd = ray_reset;\n\t\tbreak;\n\tcase RAY_CMD_START_NET:\n\tcase RAY_CMD_JOIN_NET:\n\t\trcmd = ray_start_join_net_done(sc, cmd, ccs, stat);\n\t\tbreak;\n\tcase RAY_CMD_TX_REQ:\n\t\tif (sc->sc_if.if_flags & IFF_OACTIVE) {\n\t\t\tsc->sc_if.if_flags &= ~IFF_OACTIVE;\n\t\t\t/* this may also be a problem */\n\t\t\trcmd = ray_intr_start;\n\t\t}\n\t\t/* free it -- no tracking */\n\t\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_status,\n\t\t    RAY_CCS_STATUS_FREE);\n\t\tgoto done;\n\tcase RAY_CMD_START_ASSOC:\n\t\tray_cmd_done(sc, SCP_STARTASSOC);\n\t\tif (stat == RAY_CCS_STATUS_FAIL)\n\t\t\trcmd = ray_start_join_net;\t/* XXX check */\n\t\telse {\n\t\t\tsc->sc_havenet = 1;\n\t\t\trcmd = ray_intr_start;\n\t\t}\n\t\tbreak;\n\tcase RAY_CMD_UPDATE_APM:\n\tcase RAY_CMD_TEST_MEM:\n\tcase RAY_CMD_SHUTDOWN:\n\tcase RAY_CMD_DUMP_MEM:\n\tcase RAY_CMD_START_TIMER:\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: intr: unknown command 0x%x\\n\",\n\t\t    sc->sc_if.if_xname, cmd);\n\t\tbreak;\n\t}\n\tray_free_ccs(sc, ccs);\ndone:\n\t/*\n\t * see if needed things can be done now that a command\n\t * has completed\n\t */\n\tray_check_scheduled(sc);\n\n\treturn (rcmd);\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tSCP_UPD_MCAST\t\t0x0800",
            "#define\tSCP_UPD_STARTUP\t\t0x0100",
            "#define\tSCP_REPORTPARAMS\t0x0004",
            "#define\tSCP_STARTASSOC\t\t0x0002",
            "#define\tsc_xname\tsc_dev.dv_xname",
            "#define\tsc_if\t\tsc_ec.ac_if",
            "#define\tsc_if\t\tsc_ec.ec_if"
          ],
          "globals_used": [
            "ray_cmd_func_t ray_ccs_done",
            "void ray_check_scheduled",
            "void ray_cmd_done",
            "u_int8_t ray_free_ccs",
            "void ray_intr_start",
            "void ray_report_params",
            "void ray_reset",
            "void ray_start_join_net",
            "ray_cmd_func_t ray_start_join_net_done",
            "ray_cmd_func_t ray_update_params_done"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSCP_UPD_MCAST\t\t0x0800\n#define\tSCP_UPD_STARTUP\t\t0x0100\n#define\tSCP_REPORTPARAMS\t0x0004\n#define\tSCP_STARTASSOC\t\t0x0002\n#define\tsc_xname\tsc_dev.dv_xname\n#define\tsc_if\t\tsc_ec.ac_if\n#define\tsc_if\t\tsc_ec.ec_if\n\nray_cmd_func_t ray_ccs_done;\nvoid ray_check_scheduled;\nvoid ray_cmd_done;\nu_int8_t ray_free_ccs;\nvoid ray_intr_start;\nvoid ray_report_params;\nvoid ray_reset;\nvoid ray_start_join_net;\nray_cmd_func_t ray_start_join_net_done;\nray_cmd_func_t ray_update_params_done;\n\nray_cmd_func_t\nray_ccs_done(sc, ccs)\n\tstruct ray_softc *sc;\n\tbus_size_t ccs;\n{\n\tstruct ifnet *ifp;\n\tray_cmd_func_t rcmd;\n\tu_int cmd, stat;\n\n\tifp = &sc->sc_if;\n\tcmd = SRAM_READ_FIELD_1(sc, ccs, ray_cmd, c_cmd);\n\tstat = SRAM_READ_FIELD_1(sc, ccs, ray_cmd, c_status);\n\n\tRAY_DPRINTF((\"%s: ray_ccs_done idx %ld cmd 0x%x stat %d\\n\",\n\t    sc->sc_xname, RAY_GET_INDEX(ccs), cmd, stat));\n\n\trcmd = 0;\n\tswitch (cmd) {\n\t/*\n\t * solicited commands\n\t */\n\tcase RAY_CMD_START_PARAMS:\n\t\t/* start network */\n\t\tray_cmd_done(sc, SCP_UPD_STARTUP);\n\n\t\t/* ok to start queueing packets */\n\t\tsc->sc_if.if_flags &= ~IFF_OACTIVE;\n\n\t\tsc->sc_omode = sc->sc_mode;\n\t\tmemcpy(sc->sc_cnwid, sc->sc_dnwid, sizeof(sc->sc_cnwid));\n\n\t\trcmd = ray_start_join_net;\n\t\tbreak;\n\tcase RAY_CMD_UPDATE_PARAMS:\n\t\trcmd = ray_update_params_done(sc, ccs, stat);\n\t\tbreak;\n\tcase RAY_CMD_REPORT_PARAMS:\n\t\t/* get the reported parameters */\n\t\tray_cmd_done(sc, SCP_REPORTPARAMS);\n\t\tif (!sc->sc_repreq)\n\t\t\tbreak;\n\t\tsc->sc_repreq->r_failcause =\n\t\t    SRAM_READ_FIELD_1(sc, ccs, ray_cmd_report, c_failcause);\n\t\tsc->sc_repreq->r_len =\n\t\t    SRAM_READ_FIELD_1(sc, ccs, ray_cmd_report, c_len);\n\t\tray_read_region(sc, RAY_ECF_TO_HOST_BASE, sc->sc_repreq->r_data,\n\t\t    sc->sc_repreq->r_len);\n\t\tsc->sc_repreq = 0;\n\t\twakeup(ray_report_params);\n\t\tbreak;\n\tcase RAY_CMD_UPDATE_MCAST:\n\t\tray_cmd_done(sc, SCP_UPD_MCAST);\n\t\tif (stat == RAY_CCS_STATUS_FAIL)\n\t\t\trcmd = ray_reset;\n\t\tbreak;\n\tcase RAY_CMD_START_NET:\n\tcase RAY_CMD_JOIN_NET:\n\t\trcmd = ray_start_join_net_done(sc, cmd, ccs, stat);\n\t\tbreak;\n\tcase RAY_CMD_TX_REQ:\n\t\tif (sc->sc_if.if_flags & IFF_OACTIVE) {\n\t\t\tsc->sc_if.if_flags &= ~IFF_OACTIVE;\n\t\t\t/* this may also be a problem */\n\t\t\trcmd = ray_intr_start;\n\t\t}\n\t\t/* free it -- no tracking */\n\t\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_status,\n\t\t    RAY_CCS_STATUS_FREE);\n\t\tgoto done;\n\tcase RAY_CMD_START_ASSOC:\n\t\tray_cmd_done(sc, SCP_STARTASSOC);\n\t\tif (stat == RAY_CCS_STATUS_FAIL)\n\t\t\trcmd = ray_start_join_net;\t/* XXX check */\n\t\telse {\n\t\t\tsc->sc_havenet = 1;\n\t\t\trcmd = ray_intr_start;\n\t\t}\n\t\tbreak;\n\tcase RAY_CMD_UPDATE_APM:\n\tcase RAY_CMD_TEST_MEM:\n\tcase RAY_CMD_SHUTDOWN:\n\tcase RAY_CMD_DUMP_MEM:\n\tcase RAY_CMD_START_TIMER:\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: intr: unknown command 0x%x\\n\",\n\t\t    sc->sc_if.if_xname, cmd);\n\t\tbreak;\n\t}\n\tray_free_ccs(sc, ccs);\ndone:\n\t/*\n\t * see if needed things can be done now that a command\n\t * has completed\n\t */\n\tray_check_scheduled(sc);\n\n\treturn (rcmd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "callout_reset",
          "args": [
            "&sc->sc_check_ccs_ch",
            "1",
            "ray_check_ccs",
            "sc"
          ],
          "line": 1878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc"
          ],
          "line": 1872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: check ccs idx %d ccs 0x%lx \"\n\t\t\t    \"cmd 0x%x stat %d\\n\", sc->sc_xname, i,\n\t\t\t    ccs, cmd, stat)"
          ],
          "line": 1859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRAM_READ_FIELD_1",
          "args": [
            "sc",
            "ccs",
            "ray_cmd",
            "c_status"
          ],
          "line": 1858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRAM_READ_FIELD_1",
          "args": [
            "sc",
            "ccs",
            "ray_cmd",
            "c_cmd"
          ],
          "line": 1853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_GET_CCS",
          "args": [
            "i"
          ],
          "line": 1852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: ray_check_ccs\\n\", sc->sc_xname)"
          ],
          "line": 1846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splnet",
          "args": [],
          "line": 1843
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_xname\tsc_dev.dv_xname\n#define\tRAY_CHECK_CCS_TIMEOUT\t(hz / 2)\n\nray_cmd_func_t ray_ccs_done;\nvoid ray_check_ccs;\n\nvoid\nray_check_ccs(arg)\n\tvoid *arg;\n{\n\tray_cmd_func_t fp;\n\tstruct ray_softc *sc;\n\tu_int i, cmd, stat;\n\tbus_size_t ccs;\n\tint s;\n\n\ts = splnet();\n\tsc = arg;\n\n\tRAY_DPRINTF((\"%s: ray_check_ccs\\n\", sc->sc_xname));\n\n\tsc->sc_timocheck = 0;\n\tfor (i = RAY_CCS_CMD_FIRST; i <= RAY_CCS_CMD_LAST; i++) {\n\t\tif (!sc->sc_ccsinuse[i])\n\t\t\tcontinue;\n\t\tccs = RAY_GET_CCS(i);\n\t\tcmd = SRAM_READ_FIELD_1(sc, ccs, ray_cmd, c_cmd);\n\t\tswitch (cmd) {\n\t\tcase RAY_CMD_START_PARAMS:\n\t\tcase RAY_CMD_UPDATE_MCAST:\n\t\tcase RAY_CMD_UPDATE_PARAMS:\n\t\t\tstat = SRAM_READ_FIELD_1(sc, ccs, ray_cmd, c_status);\n\t\t\tRAY_DPRINTF((\"%s: check ccs idx %d ccs 0x%lx \"\n\t\t\t    \"cmd 0x%x stat %d\\n\", sc->sc_xname, i,\n\t\t\t    ccs, cmd, stat));\n\t\t\tgoto breakout;\n\t\t}\n\t}\nbreakout:\n\t/* see if we got one of the commands we are looking for */\n\tif (i > RAY_CCS_CMD_LAST)\n\t\t; /* nothign */\n\telse if (stat == RAY_CCS_STATUS_FREE) {\n\t\tstat = RAY_CCS_STATUS_COMPLETE;\n\t\tif ((fp = ray_ccs_done(sc, ccs)))\n\t\t\t(*fp)(sc);\n\t} else if (stat != RAY_CCS_STATUS_BUSY) {\n\t\tif (sc->sc_ccsinuse[i] == 1) {\n\t\t\t/* give a chance for the interrupt to occur */\n\t\t\tsc->sc_ccsinuse[i] = 2;\n\t\t\tif (!sc->sc_timocheck) {\n\t\t\t\tcallout_reset(&sc->sc_check_ccs_ch, 1,\n\t\t\t\t    ray_check_ccs, sc);\n\t\t\t\tsc->sc_timocheck = 1;\n\t\t\t}\n\t\t} else if ((fp = ray_ccs_done(sc, ccs)))\n\t\t\t(*fp)(sc);\n\t} else {\n\t\tcallout_reset(&sc->sc_check_ccs_ch, RAY_CHECK_CCS_TIMEOUT,\n\t\t    ray_check_ccs, sc);\n\t\tsc->sc_timocheck = 1;\n\t}\n\tsplx(s);\n}"
  },
  {
    "function_name": "ray_check_scheduled",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
    "lines": "1783-1824",
    "snippet": "void\nray_check_scheduled(arg)\n\tvoid *arg;\n{\n\tstruct ray_softc *sc;\n\tint s, i, mask;\n\n\ts = splnet();\n\n\tsc = arg;\n\tRAY_DPRINTF((\n\t    \"%s: ray_check_scheduled enter schd 0x%x running 0x%x ready %d\\n\",\n\t    sc->sc_xname, sc->sc_scheduled, sc->sc_running, RAY_ECF_READY(sc)));\n\n\tif (sc->sc_timoneed) {\n\t\tcallout_stop(&sc->sc_check_scheduled_ch);\n\t\tsc->sc_timoneed = 0;\n\t}\n\n\t/* if update subcmd is running -- clear it in scheduled */\n\tif (sc->sc_running & SCP_UPDATESUBCMD)\n\t\tsc->sc_scheduled &= ~SCP_UPDATESUBCMD;\n\n\tmask = SCP_FIRST;\n\tfor (i = 0; i < ray_ncmdtab; mask <<= 1, i++) {\n\t\tif ((sc->sc_scheduled & ~SCP_UPD_MASK) == 0)\n\t\t\tbreak;\n\t\tif (!RAY_ECF_READY(sc))\n\t\t\tbreak;\n\t\tif (sc->sc_scheduled & mask)\n\t\t\t(*ray_cmdtab[i])(sc);\n\t}\n\n\tRAY_DPRINTF((\n\t    \"%s: ray_check_scheduled exit sched 0x%x running 0x%x ready %d\\n\",\n\t    sc->sc_xname, sc->sc_scheduled, sc->sc_running, RAY_ECF_READY(sc)));\n\n\tif (sc->sc_scheduled & ~SCP_UPD_MASK)\n\t\tray_set_pending(sc, sc->sc_scheduled);\n\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/pcmcia/if_rayreg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_llc.h>",
      "#include <net/if_media.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/timeout.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [
      "#define\tSCP_UPD_MASK\t\t0xff00",
      "#define\tSCP_UPDATESUBCMD\t0x0001",
      "#define\tSCP_FIRST\t\t0x0001",
      "#define\tsc_xname\tsc_dev.dv_xname",
      "#define\tcallout_stop\ttimeout_del"
    ],
    "globals_used": [
      "void ray_check_scheduled",
      "void ray_set_pending",
      "static const ray_cmd_func_t ray_cmdtab[] = {\n\tray_update_subcmd,\t/* SCP_UPDATESUBCMD */\n\tray_start_assoc,\t/* SCP_STARTASSOC */\n\tray_report_params,\t/* SCP_REPORTPARAMS */\n\tray_intr_start\t\t/* SCP_IFSTART */\n};",
      "static const int ray_ncmdtab = sizeof(ray_cmdtab) / sizeof(*ray_cmdtab);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ray_set_pending",
          "args": [
            "sc",
            "sc->sc_scheduled"
          ],
          "line": 1821
        },
        "resolved": true,
        "details": {
          "function_name": "ray_set_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2229-2243",
          "snippet": "void\nray_set_pending(sc, cmdf)\n\tstruct ray_softc *sc;\n\tu_int cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_set_pending 0x%x\\n\", sc->sc_xname, cmdf));\n\n\tsc->sc_scheduled |= cmdf;\n\tif (!sc->sc_timoneed) {\n\t\tRAY_DPRINTF((\"%s: ray_set_pending new timo\\n\", sc->sc_xname));\n\t\tcallout_reset(&sc->sc_check_scheduled_ch,\n\t\t    RAY_CHECK_SCHED_TIMEOUT, ray_check_scheduled, sc);\n\t\tsc->sc_timoneed = 1;\n\t}\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tsc_xname\tsc_dev.dv_xname",
            "#define\tRAY_CHECK_SCHED_TIMEOUT\t(hz)\t/* XXX 5 */"
          ],
          "globals_used": [
            "void ray_check_scheduled",
            "void ray_set_pending"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_xname\tsc_dev.dv_xname\n#define\tRAY_CHECK_SCHED_TIMEOUT\t(hz)\t/* XXX 5 */\n\nvoid ray_check_scheduled;\nvoid ray_set_pending;\n\nvoid\nray_set_pending(sc, cmdf)\n\tstruct ray_softc *sc;\n\tu_int cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_set_pending 0x%x\\n\", sc->sc_xname, cmdf));\n\n\tsc->sc_scheduled |= cmdf;\n\tif (!sc->sc_timoneed) {\n\t\tRAY_DPRINTF((\"%s: ray_set_pending new timo\\n\", sc->sc_xname));\n\t\tcallout_reset(&sc->sc_check_scheduled_ch,\n\t\t    RAY_CHECK_SCHED_TIMEOUT, ray_check_scheduled, sc);\n\t\tsc->sc_timoneed = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\n\t    \"%s: ray_check_scheduled exit sched 0x%x running 0x%x ready %d\\n\",\n\t    sc->sc_xname, sc->sc_scheduled, sc->sc_running, RAY_ECF_READY(sc))"
          ],
          "line": 1816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_ECF_READY",
          "args": [
            "sc"
          ],
          "line": 1818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc"
          ],
          "line": 1813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_ECF_READY",
          "args": [
            "sc"
          ],
          "line": 1810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "callout_stop",
          "args": [
            "&sc->sc_check_scheduled_ch"
          ],
          "line": 1798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\n\t    \"%s: ray_check_scheduled enter schd 0x%x running 0x%x ready %d\\n\",\n\t    sc->sc_xname, sc->sc_scheduled, sc->sc_running, RAY_ECF_READY(sc))"
          ],
          "line": 1793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_ECF_READY",
          "args": [
            "sc"
          ],
          "line": 1795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splnet",
          "args": [],
          "line": 1790
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSCP_UPD_MASK\t\t0xff00\n#define\tSCP_UPDATESUBCMD\t0x0001\n#define\tSCP_FIRST\t\t0x0001\n#define\tsc_xname\tsc_dev.dv_xname\n#define\tcallout_stop\ttimeout_del\n\nvoid ray_check_scheduled;\nvoid ray_set_pending;\nstatic const ray_cmd_func_t ray_cmdtab[] = {\n\tray_update_subcmd,\t/* SCP_UPDATESUBCMD */\n\tray_start_assoc,\t/* SCP_STARTASSOC */\n\tray_report_params,\t/* SCP_REPORTPARAMS */\n\tray_intr_start\t\t/* SCP_IFSTART */\n};\nstatic const int ray_ncmdtab = sizeof(ray_cmdtab) / sizeof(*ray_cmdtab);\n\nvoid\nray_check_scheduled(arg)\n\tvoid *arg;\n{\n\tstruct ray_softc *sc;\n\tint s, i, mask;\n\n\ts = splnet();\n\n\tsc = arg;\n\tRAY_DPRINTF((\n\t    \"%s: ray_check_scheduled enter schd 0x%x running 0x%x ready %d\\n\",\n\t    sc->sc_xname, sc->sc_scheduled, sc->sc_running, RAY_ECF_READY(sc)));\n\n\tif (sc->sc_timoneed) {\n\t\tcallout_stop(&sc->sc_check_scheduled_ch);\n\t\tsc->sc_timoneed = 0;\n\t}\n\n\t/* if update subcmd is running -- clear it in scheduled */\n\tif (sc->sc_running & SCP_UPDATESUBCMD)\n\t\tsc->sc_scheduled &= ~SCP_UPDATESUBCMD;\n\n\tmask = SCP_FIRST;\n\tfor (i = 0; i < ray_ncmdtab; mask <<= 1, i++) {\n\t\tif ((sc->sc_scheduled & ~SCP_UPD_MASK) == 0)\n\t\t\tbreak;\n\t\tif (!RAY_ECF_READY(sc))\n\t\t\tbreak;\n\t\tif (sc->sc_scheduled & mask)\n\t\t\t(*ray_cmdtab[i])(sc);\n\t}\n\n\tRAY_DPRINTF((\n\t    \"%s: ray_check_scheduled exit sched 0x%x running 0x%x ready %d\\n\",\n\t    sc->sc_xname, sc->sc_scheduled, sc->sc_running, RAY_ECF_READY(sc)));\n\n\tif (sc->sc_scheduled & ~SCP_UPD_MASK)\n\t\tray_set_pending(sc, sc->sc_scheduled);\n\n\tsplx(s);\n}"
  },
  {
    "function_name": "ray_update_params_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
    "lines": "1742-1778",
    "snippet": "ray_cmd_func_t\nray_update_params_done(sc, ccs, stat)\n\tstruct ray_softc *sc;\n\tbus_size_t ccs;\n\tu_int stat;\n{\n\tray_cmd_func_t rcmd;\n\n\trcmd = 0;\n\n\tRAY_DPRINTF((\"%s: ray_update_params_done stat %d\\n\",\n\t   sc->sc_xname, stat));\n\n\t/* this will get more complex as we add commands */\n\tif (stat == RAY_CCS_STATUS_FAIL) {\n\t\tprintf(\"%s: failed to update a promisc\\n\", sc->sc_xname);\n\t\t/* XXX should probably reset */\n\t\t/* rcmd = ray_reset; */\n\t}\n\n\tif (sc->sc_running & SCP_UPD_PROMISC) {\n\t\tray_cmd_done(sc, SCP_UPD_PROMISC);\n\t\tsc->sc_promisc = SRAM_READ_1(sc, RAY_HOST_TO_ECF_BASE);\n\t\tRAY_DPRINTF((\"%s: new promisc value %d\\n\", sc->sc_xname,\n\t\t    sc->sc_promisc));\n\t} else if (sc->sc_updreq) {\n\t\tray_cmd_done(sc, SCP_UPD_UPDATEPARAMS);\n\t\t/* get the update parameter */\n\t\tsc->sc_updreq->r_failcause =\n\t\t    SRAM_READ_FIELD_1(sc, ccs, ray_cmd_update, c_failcause);\n\t\tsc->sc_updreq = 0;\n\t\twakeup(ray_update_params);\n\n\t\trcmd = ray_start_join_net;\n\t}\n\treturn (rcmd);\n}",
    "includes": [
      "#include <dev/pcmcia/if_rayreg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_llc.h>",
      "#include <net/if_media.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/timeout.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [
      "#define\tSCP_UPD_UPDATEPARAMS\t0x1000",
      "#define\tSCP_UPD_PROMISC\t\t0x0400",
      "#define\tsc_xname\tsc_dev.dv_xname"
    ],
    "globals_used": [
      "void ray_cmd_done",
      "void ray_reset",
      "void ray_start_join_net",
      "ray_cmd_func_t ray_update_params_done",
      "void ray_update_params"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "ray_update_params"
          ],
          "line": 1773
        },
        "resolved": true,
        "details": {
          "function_name": "audio_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "765-774",
          "snippet": "static __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nstatic __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "SRAM_READ_FIELD_1",
          "args": [
            "sc",
            "ccs",
            "ray_cmd_update",
            "c_failcause"
          ],
          "line": 1771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ray_cmd_done",
          "args": [
            "sc",
            "SCP_UPD_UPDATEPARAMS"
          ],
          "line": 1768
        },
        "resolved": true,
        "details": {
          "function_name": "ray_cmd_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2339-2356",
          "snippet": "void\nray_cmd_done(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_cmd_done 0x%x\\n\", sc->sc_xname, cmdf));\n\n\tsc->sc_running &= ~cmdf;\n\tif (cmdf & SCP_UPD_MASK) {\n\t\tsc->sc_running &= ~SCP_UPDATESUBCMD;\n\t\tif (sc->sc_scheduled & SCP_UPD_MASK)\n\t\t\tray_cmd_schedule(sc, sc->sc_scheduled & SCP_UPD_MASK);\n\t}\n\tif ((sc->sc_running & SCP_TIMOCHECK_CMD_MASK) == 0 && sc->sc_timocheck){\n\t\tcallout_stop(&sc->sc_check_ccs_ch);\n\t\tsc->sc_timocheck = 0;\n\t}\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tSCP_TIMOCHECK_CMD_MASK\t\\\n\t(SCP_UPD_UPDATEPARAMS | SCP_UPD_STARTUP | SCP_UPD_MCAST | \\\n\tSCP_UPD_PROMISC)",
            "#define\tSCP_UPD_MASK\t\t0xff00",
            "#define\tSCP_UPDATESUBCMD\t0x0001",
            "#define\tsc_xname\tsc_dev.dv_xname",
            "#define\tcallout_stop\ttimeout_del"
          ],
          "globals_used": [
            "void ray_cmd_schedule",
            "void ray_cmd_done"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSCP_TIMOCHECK_CMD_MASK\t\\\n\t(SCP_UPD_UPDATEPARAMS | SCP_UPD_STARTUP | SCP_UPD_MCAST | \\\n\tSCP_UPD_PROMISC)\n#define\tSCP_UPD_MASK\t\t0xff00\n#define\tSCP_UPDATESUBCMD\t0x0001\n#define\tsc_xname\tsc_dev.dv_xname\n#define\tcallout_stop\ttimeout_del\n\nvoid ray_cmd_schedule;\nvoid ray_cmd_done;\n\nvoid\nray_cmd_done(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_cmd_done 0x%x\\n\", sc->sc_xname, cmdf));\n\n\tsc->sc_running &= ~cmdf;\n\tif (cmdf & SCP_UPD_MASK) {\n\t\tsc->sc_running &= ~SCP_UPDATESUBCMD;\n\t\tif (sc->sc_scheduled & SCP_UPD_MASK)\n\t\t\tray_cmd_schedule(sc, sc->sc_scheduled & SCP_UPD_MASK);\n\t}\n\tif ((sc->sc_running & SCP_TIMOCHECK_CMD_MASK) == 0 && sc->sc_timocheck){\n\t\tcallout_stop(&sc->sc_check_ccs_ch);\n\t\tsc->sc_timocheck = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: new promisc value %d\\n\", sc->sc_xname,\n\t\t    sc->sc_promisc)"
          ],
          "line": 1765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRAM_READ_1",
          "args": [
            "sc",
            "RAY_HOST_TO_ECF_BASE"
          ],
          "line": 1764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: failed to update a promisc\\n\"",
            "sc->sc_xname"
          ],
          "line": 1757
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: ray_update_params_done stat %d\\n\",\n\t   sc->sc_xname, stat)"
          ],
          "line": 1752
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSCP_UPD_UPDATEPARAMS\t0x1000\n#define\tSCP_UPD_PROMISC\t\t0x0400\n#define\tsc_xname\tsc_dev.dv_xname\n\nvoid ray_cmd_done;\nvoid ray_reset;\nvoid ray_start_join_net;\nray_cmd_func_t ray_update_params_done;\nvoid ray_update_params;\n\nray_cmd_func_t\nray_update_params_done(sc, ccs, stat)\n\tstruct ray_softc *sc;\n\tbus_size_t ccs;\n\tu_int stat;\n{\n\tray_cmd_func_t rcmd;\n\n\trcmd = 0;\n\n\tRAY_DPRINTF((\"%s: ray_update_params_done stat %d\\n\",\n\t   sc->sc_xname, stat));\n\n\t/* this will get more complex as we add commands */\n\tif (stat == RAY_CCS_STATUS_FAIL) {\n\t\tprintf(\"%s: failed to update a promisc\\n\", sc->sc_xname);\n\t\t/* XXX should probably reset */\n\t\t/* rcmd = ray_reset; */\n\t}\n\n\tif (sc->sc_running & SCP_UPD_PROMISC) {\n\t\tray_cmd_done(sc, SCP_UPD_PROMISC);\n\t\tsc->sc_promisc = SRAM_READ_1(sc, RAY_HOST_TO_ECF_BASE);\n\t\tRAY_DPRINTF((\"%s: new promisc value %d\\n\", sc->sc_xname,\n\t\t    sc->sc_promisc));\n\t} else if (sc->sc_updreq) {\n\t\tray_cmd_done(sc, SCP_UPD_UPDATEPARAMS);\n\t\t/* get the update parameter */\n\t\tsc->sc_updreq->r_failcause =\n\t\t    SRAM_READ_FIELD_1(sc, ccs, ray_cmd_update, c_failcause);\n\t\tsc->sc_updreq = 0;\n\t\twakeup(ray_update_params);\n\n\t\trcmd = ray_start_join_net;\n\t}\n\treturn (rcmd);\n}"
  },
  {
    "function_name": "ray_fill_in_tx_ccs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
    "lines": "1707-1736",
    "snippet": "bus_size_t\nray_fill_in_tx_ccs(sc, pktlen, i, pi)\n\tstruct ray_softc *sc;\n\tsize_t pktlen;\n\tu_int i, pi;\n{\n\tbus_size_t ccs, bufp;\n\n\t/* pktlen += RAY_TX_PHY_SIZE; */\n\tbufp = RAY_TX_BASE + i * RAY_TX_BUF_SIZE;\n\tbufp += sc->sc_txpad;\n\tccs = RAY_GET_CCS(i);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_tx, c_status, RAY_CCS_STATUS_BUSY);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_tx, c_cmd, RAY_CMD_TX_REQ);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_tx, c_link, RAY_CCS_LINK_NULL);\n\tSRAM_WRITE_FIELD_2(sc, ccs, ray_cmd_tx, c_bufp, bufp);\n\tSRAM_WRITE_FIELD_2(sc, ccs, ray_cmd_tx, c_len, pktlen);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_tx, c_tx_rate, sc->sc_deftxrate);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_tx, c_apm_mode, 0);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_tx, c_antenna, 0);\n\n\t/* link us in */\n\tif (pi != RAY_CCS_LINK_NULL)\n\t\tSRAM_WRITE_FIELD_1(sc, RAY_GET_CCS(pi), ray_cmd_tx, c_link, i);\n\n\tRAY_DPRINTF((\"%s: ray_alloc_tx_ccs bufp 0x%lx idx %d pidx %d \\n\",\n\t    sc->sc_xname, bufp, i, pi));\n\n\treturn (bufp + RAY_TX_PHY_SIZE);\n}",
    "includes": [
      "#include <dev/pcmcia/if_rayreg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_llc.h>",
      "#include <net/if_media.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/timeout.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [
      "#define\tsc_xname\tsc_dev.dv_xname"
    ],
    "globals_used": [
      "bus_size_t ray_fill_in_tx_ccs"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: ray_alloc_tx_ccs bufp 0x%lx idx %d pidx %d \\n\",\n\t    sc->sc_xname, bufp, i, pi)"
          ],
          "line": 1732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRAM_WRITE_FIELD_1",
          "args": [
            "sc",
            "RAY_GET_CCS(pi)",
            "ray_cmd_tx",
            "c_link",
            "i"
          ],
          "line": 1730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_GET_CCS",
          "args": [
            "pi"
          ],
          "line": 1730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRAM_WRITE_FIELD_1",
          "args": [
            "sc",
            "ccs",
            "ray_cmd_tx",
            "c_antenna",
            "0"
          ],
          "line": 1726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRAM_WRITE_FIELD_1",
          "args": [
            "sc",
            "ccs",
            "ray_cmd_tx",
            "c_apm_mode",
            "0"
          ],
          "line": 1725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRAM_WRITE_FIELD_1",
          "args": [
            "sc",
            "ccs",
            "ray_cmd_tx",
            "c_tx_rate",
            "sc->sc_deftxrate"
          ],
          "line": 1724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRAM_WRITE_FIELD_2",
          "args": [
            "sc",
            "ccs",
            "ray_cmd_tx",
            "c_len",
            "pktlen"
          ],
          "line": 1723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRAM_WRITE_FIELD_2",
          "args": [
            "sc",
            "ccs",
            "ray_cmd_tx",
            "c_bufp",
            "bufp"
          ],
          "line": 1722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRAM_WRITE_FIELD_1",
          "args": [
            "sc",
            "ccs",
            "ray_cmd_tx",
            "c_link",
            "RAY_CCS_LINK_NULL"
          ],
          "line": 1721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRAM_WRITE_FIELD_1",
          "args": [
            "sc",
            "ccs",
            "ray_cmd_tx",
            "c_cmd",
            "RAY_CMD_TX_REQ"
          ],
          "line": 1720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRAM_WRITE_FIELD_1",
          "args": [
            "sc",
            "ccs",
            "ray_cmd_tx",
            "c_status",
            "RAY_CCS_STATUS_BUSY"
          ],
          "line": 1719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_GET_CCS",
          "args": [
            "i"
          ],
          "line": 1718
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_xname\tsc_dev.dv_xname\n\nbus_size_t ray_fill_in_tx_ccs;\n\nbus_size_t\nray_fill_in_tx_ccs(sc, pktlen, i, pi)\n\tstruct ray_softc *sc;\n\tsize_t pktlen;\n\tu_int i, pi;\n{\n\tbus_size_t ccs, bufp;\n\n\t/* pktlen += RAY_TX_PHY_SIZE; */\n\tbufp = RAY_TX_BASE + i * RAY_TX_BUF_SIZE;\n\tbufp += sc->sc_txpad;\n\tccs = RAY_GET_CCS(i);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_tx, c_status, RAY_CCS_STATUS_BUSY);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_tx, c_cmd, RAY_CMD_TX_REQ);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_tx, c_link, RAY_CCS_LINK_NULL);\n\tSRAM_WRITE_FIELD_2(sc, ccs, ray_cmd_tx, c_bufp, bufp);\n\tSRAM_WRITE_FIELD_2(sc, ccs, ray_cmd_tx, c_len, pktlen);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_tx, c_tx_rate, sc->sc_deftxrate);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_tx, c_apm_mode, 0);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_tx, c_antenna, 0);\n\n\t/* link us in */\n\tif (pi != RAY_CCS_LINK_NULL)\n\t\tSRAM_WRITE_FIELD_1(sc, RAY_GET_CCS(pi), ray_cmd_tx, c_link, i);\n\n\tRAY_DPRINTF((\"%s: ray_alloc_tx_ccs bufp 0x%lx idx %d pidx %d \\n\",\n\t    sc->sc_xname, bufp, i, pi));\n\n\treturn (bufp + RAY_TX_PHY_SIZE);\n}"
  },
  {
    "function_name": "ray_find_free_tx_ccs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
    "lines": "1679-1701",
    "snippet": "u_int\nray_find_free_tx_ccs(sc, hint)\n\tstruct ray_softc *sc;\n\tu_int hint;\n{\n\tu_int i, stat;\n\n\tfor (i = hint; i <= RAY_CCS_TX_LAST; i++) {\n\t\tstat = SRAM_READ_FIELD_1(sc, RAY_GET_CCS(i), ray_cmd, c_status);\n\t\tif (stat == RAY_CCS_STATUS_FREE)\n\t\t\treturn (i);\n\t}\n\n\tif (hint == RAY_CCS_TX_FIRST)\n\t\treturn (RAY_CCS_LINK_NULL);\n\n\tfor (i = RAY_CCS_TX_FIRST; i < hint; i++) {\n\t\tstat = SRAM_READ_FIELD_1(sc, RAY_GET_CCS(i), ray_cmd, c_status);\n\t\tif (stat == RAY_CCS_STATUS_FREE)\n\t\t\treturn (i);\n\t}\n\treturn (RAY_CCS_LINK_NULL);\n}",
    "includes": [
      "#include <dev/pcmcia/if_rayreg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_llc.h>",
      "#include <net/if_media.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/timeout.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "u_int ray_find_free_tx_ccs"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SRAM_READ_FIELD_1",
          "args": [
            "sc",
            "RAY_GET_CCS(i)",
            "ray_cmd",
            "c_status"
          ],
          "line": 1696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_GET_CCS",
          "args": [
            "i"
          ],
          "line": 1696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRAM_READ_FIELD_1",
          "args": [
            "sc",
            "RAY_GET_CCS(i)",
            "ray_cmd",
            "c_status"
          ],
          "line": 1687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_GET_CCS",
          "args": [
            "i"
          ],
          "line": 1687
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\nu_int ray_find_free_tx_ccs;\n\nu_int\nray_find_free_tx_ccs(sc, hint)\n\tstruct ray_softc *sc;\n\tu_int hint;\n{\n\tu_int i, stat;\n\n\tfor (i = hint; i <= RAY_CCS_TX_LAST; i++) {\n\t\tstat = SRAM_READ_FIELD_1(sc, RAY_GET_CCS(i), ray_cmd, c_status);\n\t\tif (stat == RAY_CCS_STATUS_FREE)\n\t\t\treturn (i);\n\t}\n\n\tif (hint == RAY_CCS_TX_FIRST)\n\t\treturn (RAY_CCS_LINK_NULL);\n\n\tfor (i = RAY_CCS_TX_FIRST; i < hint; i++) {\n\t\tstat = SRAM_READ_FIELD_1(sc, RAY_GET_CCS(i), ray_cmd, c_status);\n\t\tif (stat == RAY_CCS_STATUS_FREE)\n\t\t\treturn (i);\n\t}\n\treturn (RAY_CCS_LINK_NULL);\n}"
  },
  {
    "function_name": "ray_recv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
    "lines": "1446-1668",
    "snippet": "void\nray_recv(sc, ccs)\n\tstruct ray_softc *sc;\n\tbus_size_t ccs;\n{\n\tstruct ieee80211_frame *frame;\n\tstruct ether_header *eh;\n\tstruct mbuf *m;\n\tsize_t pktlen, fudge, len, lenread;\n\tbus_size_t bufp, ebufp, tmp;\n\tstruct ifnet *ifp;\n\tu_int8_t *src, *d;\n\tu_int frag, nofrag, ni, i, issnap, first;\n\tu_int8_t fc0;\n#ifdef RAY_DO_SIGLEV\n\tu_int8_t siglev;\n#endif\n\n#ifdef RAY_DEBUG\n\t/* have a look if you want to see how the card rx works :) */\n\tif (ray_debug && ray_debug_dump_desc)\n\t\thexdump((caddr_t)sc->sc_memh + RAY_RCS_BASE, 0x400,\n\t\t    16, 4, 0);\n#endif\n\n\tnofrag = 0;\t/* XXX unused */\n\tm = 0;\n\tifp = &sc->sc_if;\n\n\t/*\n\t * If we're expecting the E2-in-802.11 encapsulation that the\n\t * WebGear Windows driver produces, fudge the packet forward\n\t * in the mbuf by 2 bytes so that the payload after the\n\t * Ethernet header will be aligned.  If we end up getting a\n\t * packet that's not of this type, we'll just drop it anyway.\n\t */\n\tfudge = ifp->if_flags & IFF_LINK0? 2 : 0;\n\n\t/* it looks like at least with build 4 there is no CRC in length */\n\tfirst = RAY_GET_INDEX(ccs);\n\tpktlen = SRAM_READ_FIELD_2(sc, ccs, ray_cmd_rx, c_pktlen);\n#ifdef RAY_DO_SIGLEV\n\tsiglev = SRAM_READ_FIELD_1(sc, ccs, ray_cmd_rx, c_siglev);\n#endif\n\tRAY_DPRINTF((\"%s: recv pktlen %lu nofrag %d\\n\", sc->sc_xname,\n\t    (u_long)pktlen, nofrag));\n\tRAY_DPRINTF_XMIT((\"%s: received packet: len %lu\\n\", sc->sc_xname,\n\t    (u_long)pktlen));\n\tif (pktlen > MCLBYTES\n\t    || pktlen < (sizeof(*frame) + sizeof(struct llc))) {\n\t\tRAY_DPRINTF((\"%s: PKTLEN TOO BIG OR TOO SMALL\\n\",\n\t\t    sc->sc_xname));\n\t\tifp->if_ierrors++;\n\t\tgoto done;\n\t}\n\tMGETHDR(m, M_DONTWAIT, MT_DATA);\n\tif (!m) {\n\t\tRAY_DPRINTF((\"%s: MGETHDR FAILED\\n\", sc->sc_xname));\n\t\tifp->if_ierrors++;\n\t\tgoto done;\n\t}\n\tif ((pktlen + fudge) > MHLEN) {\n\t\t/* XXX should allow chaining? */\n\t\tMCLGET(m, M_DONTWAIT);\n\t\tif ((m->m_flags & M_EXT) == 0) {\n\t\t\tRAY_DPRINTF((\"%s: MCLGET FAILED\\n\", sc->sc_xname));\n\t\t\tifp->if_ierrors++;\n\t\t\tm_freem(m);\n\t\t\tm = 0;\n\t\t\tgoto done;\n\t\t}\n\t}\n\tm->m_pkthdr.rcvif = ifp;\n\tm->m_pkthdr.len = pktlen;\n\tm->m_len = pktlen;\n\tm->m_data += fudge;\n\td = mtod(m, u_int8_t *);\n\n\tRAY_DPRINTF((\"%s: recv ccs index %d\\n\", sc->sc_xname, first));\n\tfrag = 0;\n\tlenread = 0;\n\ti = ni = first;\n\twhile ((i = ni) && i != RAY_CCS_LINK_NULL) {\n\t\tccs = RAY_GET_CCS(i);\n\t\tbufp = SRAM_READ_FIELD_2(sc, ccs, ray_cmd_rx, c_bufp);\n\t\tlen = SRAM_READ_FIELD_2(sc, ccs, ray_cmd_rx, c_len);\n\t\t/* remove the CRC */\n#if 0\n\t\t/* at least with build 4 no crc seems to be here */\n\t\tif (frag++ == 0)\n\t\t\tlen -= 4;\n#endif\n\t\tni = SRAM_READ_FIELD_1(sc, ccs, ray_cmd_rx, c_nextfrag);\n\t\tRAY_DPRINTF((\"%s: recv frag index %d len %lu bufp %p ni %d\\n\",\n\t\t    sc->sc_xname, i, (u_long)len, bufp, ni));\n\t\tif (len + lenread > pktlen) {\n\t\t\tRAY_DPRINTF((\"%s: BAD LEN current %lu pktlen %lu\\n\",\n\t\t\t    sc->sc_xname, (u_long)(len + lenread),\n\t\t\t    (u_long)pktlen));\n\t\t\tifp->if_ierrors++;\n\t\t\tm_freem(m);\n\t\t\tm = 0;\n\t\t\tgoto done;\n\t\t}\n\t\tif (i < RAY_RCCS_FIRST) {\n\t\t\tprintf(\"ray_recv: bad ccs index 0x%x\\n\", i);\n\t\t\tm_freem(m);\n\t\t\tm = 0;\n\t\t\tgoto done;\n\t\t}\n\n\t\tebufp = bufp + len;\n\t\tif (ebufp <= RAY_RX_END)\n\t\t\tray_read_region(sc, bufp, d, len);\n\t\telse {\n\t\t\t/* wrapping */\n\t\t\tray_read_region(sc, bufp, d, (tmp = RAY_RX_END - bufp));\n\t\t\tray_read_region(sc, RAY_RX_BASE, d + tmp, ebufp - RAY_RX_END);\n\t\t}\n\t\td += len;\n\t\tlenread += len;\n\t}\ndone:\n\n\tRAY_DPRINTF((\"%s: recv frag count %d\\n\", sc->sc_xname, frag));\n\n\t/* free the rcss */\n\tni = first;\n\twhile ((i = ni) && (i != RAY_CCS_LINK_NULL)) {\n\t\tccs = RAY_GET_CCS(i);\n\t\tni = SRAM_READ_FIELD_1(sc, ccs, ray_cmd_rx, c_nextfrag);\n\t\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_status,\n\t\t    RAY_CCS_STATUS_FREE);\n\t}\n\n\tif (!m)\n\t\treturn;\n\n\tRAY_DPRINTF((\"%s: recv got packet pktlen %lu actual %lu\\n\",\n\t    sc->sc_xname, (u_long)pktlen, (u_long)lenread));\n#ifdef RAY_DEBUG\n\tif (ray_debug && ray_debug_dump_rx)\n\t\tray_dump_mbuf(sc, m);\n#endif\n\t/* receivce the packet */\n\tframe = mtod(m, struct ieee80211_frame *);\n\tfc0 = frame->i_fc[0]\n\t   & (IEEE80211_FC0_VERSION_MASK|IEEE80211_FC0_TYPE_MASK);\n\tif ((fc0 & IEEE80211_FC0_VERSION_MASK) != IEEE80211_FC0_VERSION_0) {\n\t\tRAY_DPRINTF((\"%s: pkt not version 0 fc 0x%x\\n\",\n\t\t    sc->sc_xname, fc0));\n\t\tm_freem(m);\n\t\treturn;\n\t}\n\tif ((fc0 & IEEE80211_FC0_TYPE_MASK) != IEEE80211_FC0_TYPE_DATA) {\n\t\tRAY_DPRINTF((\"%s: pkt not type data fc0 0x%x\\n\",\n\t\t    sc->sc_xname, fc0));\n\t\tm_freem(m);\n\t\treturn;\n\t}\n\n\tif (!memcmp(frame + 1, llc_snapid, sizeof(llc_snapid)))\n\t\tissnap = 1;\n\telse {\n\t\t/*\n\t\t * if user has link0 flag set we allow the weird\n\t\t * Ethernet2 in 802.11 encapsulation produced by\n\t\t * the windows driver for the WebGear card\n\t\t */\n\t\tRAY_DPRINTF((\"%s: pkt not snap 0\\n\", sc->sc_xname));\n\t\tif ((ifp->if_flags & IFF_LINK0) == 0) {\n\t\t\tm_freem(m);\n\t\t\treturn;\n\t\t}\n\t\tissnap = 0;\n\t}\n\tswitch (frame->i_fc[1] & IEEE80211_FC1_DIR_MASK) {\n\tcase IEEE80211_FC1_DIR_NODS:\n\t\tsrc = frame->i_addr2;\n\t\tbreak;\n\tcase IEEE80211_FC1_DIR_FROMDS:\n\t\tsrc = frame->i_addr3;\n\t\tbreak;\n\tcase IEEE80211_FC1_DIR_TODS:\n\t\tRAY_DPRINTF((\"%s: pkt ap2ap\\n\", sc->sc_xname));\n\t\tm_freem(m);\n\t\treturn;\n\tdefault:\n\t\tRAY_DPRINTF((\"%s: pkt type unknown\\n\", sc->sc_xname));\n\t\tm_freem(m);\n\t\treturn;\n\t}\n\n#ifdef RAY_DO_SIGLEV\n\tray_update_siglev(sc, src, siglev);\n#endif\n\n\t/*\n\t * This is a mess.. we should support other LLC frame types\n\t */\n\tif (issnap) {\n\t\t/* create an ether_header over top of the 802.11+SNAP header */\n\t\teh = (struct ether_header *)((caddr_t)(frame + 1) - 6);\n\t\tmemcpy(eh->ether_shost, src, ETHER_ADDR_LEN);\n\t\tmemcpy(eh->ether_dhost, frame->i_addr1, ETHER_ADDR_LEN);\n\t} else {\n\t\t/* this is the weird e2 in 802.11 encapsulation */\n\t\teh = (struct ether_header *)(frame + 1);\n\t}\n\tm_adj(m, (caddr_t)eh - (caddr_t)frame);\n#if NBPFILTER > 0\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\t/* XXX doesn't appear to be included m->m_flags |= M_HASFCS; */\n\tifp->if_ipackets++;\n#ifdef __NetBSD__\n\t(*ifp->if_input)(ifp, m);\n#elif defined(__OpenBSD__)\n\tm_adj(m, sizeof(struct ether_header));\n\tether_input(ifp, eh, m);\n#endif\n}",
    "includes": [
      "#include <dev/pcmcia/if_rayreg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_llc.h>",
      "#include <net/if_media.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/timeout.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [
      "#define\tsc_xname\tsc_dev.dv_xname",
      "#define\tsc_if\t\tsc_ec.ac_if",
      "#define\tsc_if\t\tsc_ec.ec_if",
      "#define\tsc_memh\tsc_mem.memh"
    ],
    "globals_used": [
      "void ray_recv",
      "static const u_int8_t llc_snapid[6] = { LLC_SNAP_LSAP, LLC_SNAP_LSAP, LLC_UI };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ether_input",
          "args": [
            "ifp",
            "eh",
            "m"
          ],
          "line": 1666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_adj",
          "args": [
            "m",
            "sizeof(struct ether_header)"
          ],
          "line": 1665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "ifp",
            "m"
          ],
          "line": 1663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_mtap",
          "args": [
            "ifp->if_bpf",
            "m"
          ],
          "line": 1658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_adj",
          "args": [
            "m",
            "(caddr_t)eh - (caddr_t)frame"
          ],
          "line": 1655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "eh->ether_dhost",
            "frame->i_addr1",
            "ETHER_ADDR_LEN"
          ],
          "line": 1650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "eh->ether_shost",
            "src",
            "ETHER_ADDR_LEN"
          ],
          "line": 1649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "frame + 1"
          ],
          "line": 1648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ray_update_siglev",
          "args": [
            "sc",
            "src",
            "siglev"
          ],
          "line": 1640
        },
        "resolved": true,
        "details": {
          "function_name": "ray_update_siglev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "3290-3325",
          "snippet": "static void\nray_update_siglev(sc, src, siglev)\n\tstruct ray_softc *sc;\n\tu_int8_t *src;\n\tu_int8_t siglev;\n{\n\tint i, mini;\n\tstruct timeval mint;\n\tstruct ray_siglev *sl;\n\n\t/* try to find host */\n\tfor (i = 0; i < RAY_NSIGLEVRECS; i++) {\n\t\tsl = &sc->sc_siglevs[i];\n\t\tif (memcmp(sl->rsl_host, src, ETHER_ADDR_LEN) == 0)\n\t\t\tgoto found;\n\t}\n\t/* not found, find oldest slot */\n\tmini = 0;\n\tmint.tv_sec = LONG_MAX;\n\tmint.tv_usec = 0;\n\tfor (i = 0; i < RAY_NSIGLEVRECS; i++) {\n\t\tsl = &sc->sc_siglevs[i];\n\t\tif (timercmp(&sl->rsl_time, &mint, <)) {\n\t\t\tmini = i;\n\t\t\tmint = sl->rsl_time;\n\t\t}\n\t}\n\tsl = &sc->sc_siglevs[mini];\n\tmemset(sl->rsl_siglevs, 0, RAY_NSIGLEV);\n\tmemcpy(sl->rsl_host, src, ETHER_ADDR_LEN);\n\n found:\n\tmicrotime(&sl->rsl_time);\n\tmemmove(&sl->rsl_siglevs[1], sl->rsl_siglevs, RAY_NSIGLEV-1);\n\tsl->rsl_siglevs[0] = siglev;\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tmemmove\t\tmemcpy\t\t/* XXX */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tmemmove\t\tmemcpy\t\t/* XXX */\n\nstatic void\nray_update_siglev(sc, src, siglev)\n\tstruct ray_softc *sc;\n\tu_int8_t *src;\n\tu_int8_t siglev;\n{\n\tint i, mini;\n\tstruct timeval mint;\n\tstruct ray_siglev *sl;\n\n\t/* try to find host */\n\tfor (i = 0; i < RAY_NSIGLEVRECS; i++) {\n\t\tsl = &sc->sc_siglevs[i];\n\t\tif (memcmp(sl->rsl_host, src, ETHER_ADDR_LEN) == 0)\n\t\t\tgoto found;\n\t}\n\t/* not found, find oldest slot */\n\tmini = 0;\n\tmint.tv_sec = LONG_MAX;\n\tmint.tv_usec = 0;\n\tfor (i = 0; i < RAY_NSIGLEVRECS; i++) {\n\t\tsl = &sc->sc_siglevs[i];\n\t\tif (timercmp(&sl->rsl_time, &mint, <)) {\n\t\t\tmini = i;\n\t\t\tmint = sl->rsl_time;\n\t\t}\n\t}\n\tsl = &sc->sc_siglevs[mini];\n\tmemset(sl->rsl_siglevs, 0, RAY_NSIGLEV);\n\tmemcpy(sl->rsl_host, src, ETHER_ADDR_LEN);\n\n found:\n\tmicrotime(&sl->rsl_time);\n\tmemmove(&sl->rsl_siglevs[1], sl->rsl_siglevs, RAY_NSIGLEV-1);\n\tsl->rsl_siglevs[0] = siglev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m"
          ],
          "line": 1635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: pkt type unknown\\n\", sc->sc_xname)"
          ],
          "line": 1634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m"
          ],
          "line": 1631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: pkt ap2ap\\n\", sc->sc_xname)"
          ],
          "line": 1630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m"
          ],
          "line": 1617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: pkt not snap 0\\n\", sc->sc_xname)"
          ],
          "line": 1615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "frame + 1",
            "llc_snapid",
            "sizeof(llc_snapid)"
          ],
          "line": 1607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m"
          ],
          "line": 1603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: pkt not type data fc0 0x%x\\n\",\n\t\t    sc->sc_xname, fc0)"
          ],
          "line": 1601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m"
          ],
          "line": 1597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: pkt not version 0 fc 0x%x\\n\",\n\t\t    sc->sc_xname, fc0)"
          ],
          "line": 1595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "structieee80211_frame*"
          ],
          "line": 1591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ray_dump_mbuf",
          "args": [
            "sc",
            "m"
          ],
          "line": 1588
        },
        "resolved": true,
        "details": {
          "function_name": "ray_dump_mbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "3262-3286",
          "snippet": "void\nray_dump_mbuf(sc, m)\n\tstruct ray_softc *sc;\n\tstruct mbuf *m;\n{\n\tu_int8_t *d, *ed;\n\tu_int i;\n\n\tprintf(\"%s: pkt dump:\", sc->sc_xname);\n\ti = 0;\n\tfor (; m; m = m->m_next) {\n\t\td = mtod(m, u_int8_t *);\n\t\ted = d + m->m_len;\n\n\t\tfor (; d < ed; i++, d++) {\n\t\t\tif ((i % 16) == 0)\n\t\t\t\tprintf(\"\\n\\t\");\n\t\t\telse if ((i % 8) == 0)\n\t\t\t\tprintf(\"  \");\n\t\t\tprintf(\" %02x\", *d);\n\t\t}\n\t}\n\tif ((i - 1) % 16)\n\t\tprintf(\"\\n\");\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tsc_xname\tsc_dev.dv_xname"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_xname\tsc_dev.dv_xname\n\nvoid\nray_dump_mbuf(sc, m)\n\tstruct ray_softc *sc;\n\tstruct mbuf *m;\n{\n\tu_int8_t *d, *ed;\n\tu_int i;\n\n\tprintf(\"%s: pkt dump:\", sc->sc_xname);\n\ti = 0;\n\tfor (; m; m = m->m_next) {\n\t\td = mtod(m, u_int8_t *);\n\t\ted = d + m->m_len;\n\n\t\tfor (; d < ed; i++, d++) {\n\t\t\tif ((i % 16) == 0)\n\t\t\t\tprintf(\"\\n\\t\");\n\t\t\telse if ((i % 8) == 0)\n\t\t\t\tprintf(\"  \");\n\t\t\tprintf(\" %02x\", *d);\n\t\t}\n\t}\n\tif ((i - 1) % 16)\n\t\tprintf(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: recv got packet pktlen %lu actual %lu\\n\",\n\t    sc->sc_xname, (u_long)pktlen, (u_long)lenread)"
          ],
          "line": 1584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRAM_WRITE_FIELD_1",
          "args": [
            "sc",
            "ccs",
            "ray_cmd",
            "c_status",
            "RAY_CCS_STATUS_FREE"
          ],
          "line": 1577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRAM_READ_FIELD_1",
          "args": [
            "sc",
            "ccs",
            "ray_cmd_rx",
            "c_nextfrag"
          ],
          "line": 1576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_GET_CCS",
          "args": [
            "i"
          ],
          "line": 1575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: recv frag count %d\\n\", sc->sc_xname, frag)"
          ],
          "line": 1570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ray_read_region",
          "args": [
            "sc",
            "RAY_RX_BASE",
            "d + tmp",
            "ebufp - RAY_RX_END"
          ],
          "line": 1563
        },
        "resolved": true,
        "details": {
          "function_name": "ray_read_region",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "3063-3116",
          "snippet": "void\nray_read_region(sc, off, vp, c)\n\tstruct ray_softc *sc;\n\tbus_size_t off;\n\tvoid *vp;\n\tsize_t c;\n{\n#ifdef RAY_USE_OPTIMIZED_COPY\n\tu_int n2, n4, tmp;\n\tu_int8_t *p;\n\n\tp = vp;\n\n\t/* XXX we may be making poor assumptions here but lets hope */\n\tswitch ((off|(bus_addr_t)p) & 0x03) {\n\tcase 0:\n\t\tif ((n4 = c / 4)) {\n\t\t\tbus_space_read_region_4(sc->sc_memt, sc->sc_memh, off,\n\t\t\t    p, n4);\n\t\t\ttmp = c & ~0x3;\n\t\t\tc &= 0x3;\n\t\t\tp += tmp;\n\t\t\toff += tmp;\n\t\t}\n\t\tswitch (c) {\n\t\tcase 3:\n\t\t\t*p = bus_space_read_1(sc->sc_memt,sc->sc_memh, off);\n\t\t\tp++, off++;\n\t\tcase 2:\n\t\t\t*p = bus_space_read_1(sc->sc_memt,sc->sc_memh, off);\n\t\t\tp++, off++;\n\t\tcase 1:\n\t\t\t*p = bus_space_read_1(sc->sc_memt,sc->sc_memh, off);\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tif ((n2 = (c >> 1)))\n\t\t\tbus_space_read_region_2(sc->sc_memt, sc->sc_memh, off,\n\t\t\t    p, n2);\n\t\tif (c & 1) {\n\t\t\tc &= ~0x1;\n\t\t\t*(p + c) = bus_space_read_1(sc->sc_memt, sc->sc_memh,\n\t\t\t    off + c);\n\t\t}\n\t\tbreak;\n\tcase 1:\n\tcase 3:\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_memh, off, p, c);\n\t\tbreak;\n\t}\n#else\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_memh, off, vp, c);\n#endif\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tsc_memh\tsc_mem.memh",
            "#define\tsc_memt\tsc_mem.memt"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_memh\tsc_mem.memh\n#define\tsc_memt\tsc_mem.memt\n\nvoid\nray_read_region(sc, off, vp, c)\n\tstruct ray_softc *sc;\n\tbus_size_t off;\n\tvoid *vp;\n\tsize_t c;\n{\n#ifdef RAY_USE_OPTIMIZED_COPY\n\tu_int n2, n4, tmp;\n\tu_int8_t *p;\n\n\tp = vp;\n\n\t/* XXX we may be making poor assumptions here but lets hope */\n\tswitch ((off|(bus_addr_t)p) & 0x03) {\n\tcase 0:\n\t\tif ((n4 = c / 4)) {\n\t\t\tbus_space_read_region_4(sc->sc_memt, sc->sc_memh, off,\n\t\t\t    p, n4);\n\t\t\ttmp = c & ~0x3;\n\t\t\tc &= 0x3;\n\t\t\tp += tmp;\n\t\t\toff += tmp;\n\t\t}\n\t\tswitch (c) {\n\t\tcase 3:\n\t\t\t*p = bus_space_read_1(sc->sc_memt,sc->sc_memh, off);\n\t\t\tp++, off++;\n\t\tcase 2:\n\t\t\t*p = bus_space_read_1(sc->sc_memt,sc->sc_memh, off);\n\t\t\tp++, off++;\n\t\tcase 1:\n\t\t\t*p = bus_space_read_1(sc->sc_memt,sc->sc_memh, off);\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tif ((n2 = (c >> 1)))\n\t\t\tbus_space_read_region_2(sc->sc_memt, sc->sc_memh, off,\n\t\t\t    p, n2);\n\t\tif (c & 1) {\n\t\t\tc &= ~0x1;\n\t\t\t*(p + c) = bus_space_read_1(sc->sc_memt, sc->sc_memh,\n\t\t\t    off + c);\n\t\t}\n\t\tbreak;\n\tcase 1:\n\tcase 3:\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_memh, off, p, c);\n\t\tbreak;\n\t}\n#else\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_memh, off, vp, c);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m"
          ],
          "line": 1552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ray_recv: bad ccs index 0x%x\\n\"",
            "i"
          ],
          "line": 1551
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m"
          ],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: BAD LEN current %lu pktlen %lu\\n\",\n\t\t\t    sc->sc_xname, (u_long)(len + lenread),\n\t\t\t    (u_long)pktlen)"
          ],
          "line": 1542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "len + lenread"
          ],
          "line": 1543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: recv frag index %d len %lu bufp %p ni %d\\n\",\n\t\t    sc->sc_xname, i, (u_long)len, bufp, ni)"
          ],
          "line": 1539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRAM_READ_FIELD_1",
          "args": [
            "sc",
            "ccs",
            "ray_cmd_rx",
            "c_nextfrag"
          ],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRAM_READ_FIELD_2",
          "args": [
            "sc",
            "ccs",
            "ray_cmd_rx",
            "c_len"
          ],
          "line": 1531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRAM_READ_FIELD_2",
          "args": [
            "sc",
            "ccs",
            "ray_cmd_rx",
            "c_bufp"
          ],
          "line": 1530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_GET_CCS",
          "args": [
            "i"
          ],
          "line": 1529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: recv ccs index %d\\n\", sc->sc_xname, first)"
          ],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "u_int8_t*"
          ],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m"
          ],
          "line": 1513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: MCLGET FAILED\\n\", sc->sc_xname)"
          ],
          "line": 1511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MCLGET",
          "args": [
            "m",
            "M_DONTWAIT"
          ],
          "line": 1509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: MGETHDR FAILED\\n\", sc->sc_xname)"
          ],
          "line": 1503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MGETHDR",
          "args": [
            "m",
            "M_DONTWAIT",
            "MT_DATA"
          ],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: PKTLEN TOO BIG OR TOO SMALL\\n\",\n\t\t    sc->sc_xname)"
          ],
          "line": 1496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF_XMIT",
          "args": [
            "(\"%s: received packet: len %lu\\n\", sc->sc_xname,\n\t    (u_long)pktlen)"
          ],
          "line": 1492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: recv pktlen %lu nofrag %d\\n\", sc->sc_xname,\n\t    (u_long)pktlen, nofrag)"
          ],
          "line": 1490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRAM_READ_FIELD_1",
          "args": [
            "sc",
            "ccs",
            "ray_cmd_rx",
            "c_siglev"
          ],
          "line": 1488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRAM_READ_FIELD_2",
          "args": [
            "sc",
            "ccs",
            "ray_cmd_rx",
            "c_pktlen"
          ],
          "line": 1486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_GET_INDEX",
          "args": [
            "ccs"
          ],
          "line": 1485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hexdump",
          "args": [
            "(caddr_t)sc->sc_memh + RAY_RCS_BASE",
            "0x400",
            "16",
            "4",
            "0"
          ],
          "line": 1467
        },
        "resolved": true,
        "details": {
          "function_name": "hexdump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "3184-3258",
          "snippet": "void\nhexdump(const u_int8_t *d, int len, int br, int div, int fl)\n{\n\tint i, j, offw, first, tlen, ni, nj, sp;\n\n\tsp = br / div;\n\toffw = 0;\n\tif (len && (fl & HEXDF_NOOFFSET) == 0) {\n\t\ttlen = len;\n\t\tdo {\n\t\t\toffw++;\n\t\t} while (tlen /= br);\n\t}\n\tif (offw)\n\t\tprintf(\"%0*x: \", offw, 0);\n\tfor (i = 0; i < len; i++, d++) {\n\t\tif (i && (i % br) == 0) {\n\t\t\tif ((fl & HEXDF_NOASCII) == 0) {\n\t\t\t\tprintf(\"   \");\n\t\t\t\td -= br;\n\t\t\t\tfor (j = 0; j < br; d++, j++) {\n\t\t\t\t\tif (j && (j % sp) == 0)\n\t\t\t\t\t\tprintf(\" \");\n\t\t\t\t\tif (PRINTABLE(*d))\n\t\t\t\t\t\tprintf(\"%c\", (int)*d);\n\t\t\t\t\telse\n\t\t\t\t\t\tprintf(\".\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (offw)\n\t\t\t\tprintf(\"\\n%0*x: \", offw, i);\n\t\t\telse\n\t\t\t\tprintf(\"\\n\");\n\t\t\tif ((fl & HEXDF_NOCOMPRESS) == 0) {\n\t\t\t\tfirst = 1;\n\t\t\t\twhile (len - i >= br) {\n\t\t\t\t\tif (memcmp(d, d - br, br))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\td += br;\n\t\t\t\t\ti += br;\n\t\t\t\t\tif (first) {\n\t\t\t\t\t\tprintf(\"*\");\n\t\t\t\t\t\tfirst = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (len == i) {\n\t\t\t\t\tprintf(\"\\n%0*x\", offw, i);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (i && (i % sp) == 0)\n\t\t\tprintf(\" \");\n\t\tprintf(\"%02x \", *d);\n\t}\n\tif (len && (((i - 1) % br) || i == 1)) {\n\t\tif ((fl & HEXDF_NOASCII) == 0) {\n\t\t\ti = i % br ? i % br : br;\n\t\t\tni = (br - i) % br;\n\t\t\tj = (i - 1) / sp;\n\t\t\tnj = (div - j - 1) % div;\n\t\t\tj = 3 * ni + nj + 3;\n\t\t\tprintf(\"%*s\", j, \"\");\n\t\t\td -= i;\n\t\t\tfor (j = 0; j < i; d++, j++) {\n\t\t\t\tif (j && (j % sp) == 0)\n\t\t\t\t\tprintf(\" \");\n\t\t\t\tif (PRINTABLE(*d))\n\t\t\t\t\tprintf(\"%c\", (int)*d);\n\t\t\t\telse\n\t\t\t\t\tprintf(\".\");\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define HEXDF_NOASCII\t\t0x4",
            "#define\tHEXDF_NOOFFSET\t\t0x2",
            "#define\tHEXDF_NOCOMPRESS\t0x1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define HEXDF_NOASCII\t\t0x4\n#define\tHEXDF_NOOFFSET\t\t0x2\n#define\tHEXDF_NOCOMPRESS\t0x1\n\nvoid\nhexdump(const u_int8_t *d, int len, int br, int div, int fl)\n{\n\tint i, j, offw, first, tlen, ni, nj, sp;\n\n\tsp = br / div;\n\toffw = 0;\n\tif (len && (fl & HEXDF_NOOFFSET) == 0) {\n\t\ttlen = len;\n\t\tdo {\n\t\t\toffw++;\n\t\t} while (tlen /= br);\n\t}\n\tif (offw)\n\t\tprintf(\"%0*x: \", offw, 0);\n\tfor (i = 0; i < len; i++, d++) {\n\t\tif (i && (i % br) == 0) {\n\t\t\tif ((fl & HEXDF_NOASCII) == 0) {\n\t\t\t\tprintf(\"   \");\n\t\t\t\td -= br;\n\t\t\t\tfor (j = 0; j < br; d++, j++) {\n\t\t\t\t\tif (j && (j % sp) == 0)\n\t\t\t\t\t\tprintf(\" \");\n\t\t\t\t\tif (PRINTABLE(*d))\n\t\t\t\t\t\tprintf(\"%c\", (int)*d);\n\t\t\t\t\telse\n\t\t\t\t\t\tprintf(\".\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (offw)\n\t\t\t\tprintf(\"\\n%0*x: \", offw, i);\n\t\t\telse\n\t\t\t\tprintf(\"\\n\");\n\t\t\tif ((fl & HEXDF_NOCOMPRESS) == 0) {\n\t\t\t\tfirst = 1;\n\t\t\t\twhile (len - i >= br) {\n\t\t\t\t\tif (memcmp(d, d - br, br))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\td += br;\n\t\t\t\t\ti += br;\n\t\t\t\t\tif (first) {\n\t\t\t\t\t\tprintf(\"*\");\n\t\t\t\t\t\tfirst = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (len == i) {\n\t\t\t\t\tprintf(\"\\n%0*x\", offw, i);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (i && (i % sp) == 0)\n\t\t\tprintf(\" \");\n\t\tprintf(\"%02x \", *d);\n\t}\n\tif (len && (((i - 1) % br) || i == 1)) {\n\t\tif ((fl & HEXDF_NOASCII) == 0) {\n\t\t\ti = i % br ? i % br : br;\n\t\t\tni = (br - i) % br;\n\t\t\tj = (i - 1) / sp;\n\t\t\tnj = (div - j - 1) % div;\n\t\t\tj = 3 * ni + nj + 3;\n\t\t\tprintf(\"%*s\", j, \"\");\n\t\t\td -= i;\n\t\t\tfor (j = 0; j < i; d++, j++) {\n\t\t\t\tif (j && (j % sp) == 0)\n\t\t\t\t\tprintf(\" \");\n\t\t\t\tif (PRINTABLE(*d))\n\t\t\t\t\tprintf(\"%c\", (int)*d);\n\t\t\t\telse\n\t\t\t\t\tprintf(\".\");\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_xname\tsc_dev.dv_xname\n#define\tsc_if\t\tsc_ec.ac_if\n#define\tsc_if\t\tsc_ec.ec_if\n#define\tsc_memh\tsc_mem.memh\n\nvoid ray_recv;\nstatic const u_int8_t llc_snapid[6] = { LLC_SNAP_LSAP, LLC_SNAP_LSAP, LLC_UI };\n\nvoid\nray_recv(sc, ccs)\n\tstruct ray_softc *sc;\n\tbus_size_t ccs;\n{\n\tstruct ieee80211_frame *frame;\n\tstruct ether_header *eh;\n\tstruct mbuf *m;\n\tsize_t pktlen, fudge, len, lenread;\n\tbus_size_t bufp, ebufp, tmp;\n\tstruct ifnet *ifp;\n\tu_int8_t *src, *d;\n\tu_int frag, nofrag, ni, i, issnap, first;\n\tu_int8_t fc0;\n#ifdef RAY_DO_SIGLEV\n\tu_int8_t siglev;\n#endif\n\n#ifdef RAY_DEBUG\n\t/* have a look if you want to see how the card rx works :) */\n\tif (ray_debug && ray_debug_dump_desc)\n\t\thexdump((caddr_t)sc->sc_memh + RAY_RCS_BASE, 0x400,\n\t\t    16, 4, 0);\n#endif\n\n\tnofrag = 0;\t/* XXX unused */\n\tm = 0;\n\tifp = &sc->sc_if;\n\n\t/*\n\t * If we're expecting the E2-in-802.11 encapsulation that the\n\t * WebGear Windows driver produces, fudge the packet forward\n\t * in the mbuf by 2 bytes so that the payload after the\n\t * Ethernet header will be aligned.  If we end up getting a\n\t * packet that's not of this type, we'll just drop it anyway.\n\t */\n\tfudge = ifp->if_flags & IFF_LINK0? 2 : 0;\n\n\t/* it looks like at least with build 4 there is no CRC in length */\n\tfirst = RAY_GET_INDEX(ccs);\n\tpktlen = SRAM_READ_FIELD_2(sc, ccs, ray_cmd_rx, c_pktlen);\n#ifdef RAY_DO_SIGLEV\n\tsiglev = SRAM_READ_FIELD_1(sc, ccs, ray_cmd_rx, c_siglev);\n#endif\n\tRAY_DPRINTF((\"%s: recv pktlen %lu nofrag %d\\n\", sc->sc_xname,\n\t    (u_long)pktlen, nofrag));\n\tRAY_DPRINTF_XMIT((\"%s: received packet: len %lu\\n\", sc->sc_xname,\n\t    (u_long)pktlen));\n\tif (pktlen > MCLBYTES\n\t    || pktlen < (sizeof(*frame) + sizeof(struct llc))) {\n\t\tRAY_DPRINTF((\"%s: PKTLEN TOO BIG OR TOO SMALL\\n\",\n\t\t    sc->sc_xname));\n\t\tifp->if_ierrors++;\n\t\tgoto done;\n\t}\n\tMGETHDR(m, M_DONTWAIT, MT_DATA);\n\tif (!m) {\n\t\tRAY_DPRINTF((\"%s: MGETHDR FAILED\\n\", sc->sc_xname));\n\t\tifp->if_ierrors++;\n\t\tgoto done;\n\t}\n\tif ((pktlen + fudge) > MHLEN) {\n\t\t/* XXX should allow chaining? */\n\t\tMCLGET(m, M_DONTWAIT);\n\t\tif ((m->m_flags & M_EXT) == 0) {\n\t\t\tRAY_DPRINTF((\"%s: MCLGET FAILED\\n\", sc->sc_xname));\n\t\t\tifp->if_ierrors++;\n\t\t\tm_freem(m);\n\t\t\tm = 0;\n\t\t\tgoto done;\n\t\t}\n\t}\n\tm->m_pkthdr.rcvif = ifp;\n\tm->m_pkthdr.len = pktlen;\n\tm->m_len = pktlen;\n\tm->m_data += fudge;\n\td = mtod(m, u_int8_t *);\n\n\tRAY_DPRINTF((\"%s: recv ccs index %d\\n\", sc->sc_xname, first));\n\tfrag = 0;\n\tlenread = 0;\n\ti = ni = first;\n\twhile ((i = ni) && i != RAY_CCS_LINK_NULL) {\n\t\tccs = RAY_GET_CCS(i);\n\t\tbufp = SRAM_READ_FIELD_2(sc, ccs, ray_cmd_rx, c_bufp);\n\t\tlen = SRAM_READ_FIELD_2(sc, ccs, ray_cmd_rx, c_len);\n\t\t/* remove the CRC */\n#if 0\n\t\t/* at least with build 4 no crc seems to be here */\n\t\tif (frag++ == 0)\n\t\t\tlen -= 4;\n#endif\n\t\tni = SRAM_READ_FIELD_1(sc, ccs, ray_cmd_rx, c_nextfrag);\n\t\tRAY_DPRINTF((\"%s: recv frag index %d len %lu bufp %p ni %d\\n\",\n\t\t    sc->sc_xname, i, (u_long)len, bufp, ni));\n\t\tif (len + lenread > pktlen) {\n\t\t\tRAY_DPRINTF((\"%s: BAD LEN current %lu pktlen %lu\\n\",\n\t\t\t    sc->sc_xname, (u_long)(len + lenread),\n\t\t\t    (u_long)pktlen));\n\t\t\tifp->if_ierrors++;\n\t\t\tm_freem(m);\n\t\t\tm = 0;\n\t\t\tgoto done;\n\t\t}\n\t\tif (i < RAY_RCCS_FIRST) {\n\t\t\tprintf(\"ray_recv: bad ccs index 0x%x\\n\", i);\n\t\t\tm_freem(m);\n\t\t\tm = 0;\n\t\t\tgoto done;\n\t\t}\n\n\t\tebufp = bufp + len;\n\t\tif (ebufp <= RAY_RX_END)\n\t\t\tray_read_region(sc, bufp, d, len);\n\t\telse {\n\t\t\t/* wrapping */\n\t\t\tray_read_region(sc, bufp, d, (tmp = RAY_RX_END - bufp));\n\t\t\tray_read_region(sc, RAY_RX_BASE, d + tmp, ebufp - RAY_RX_END);\n\t\t}\n\t\td += len;\n\t\tlenread += len;\n\t}\ndone:\n\n\tRAY_DPRINTF((\"%s: recv frag count %d\\n\", sc->sc_xname, frag));\n\n\t/* free the rcss */\n\tni = first;\n\twhile ((i = ni) && (i != RAY_CCS_LINK_NULL)) {\n\t\tccs = RAY_GET_CCS(i);\n\t\tni = SRAM_READ_FIELD_1(sc, ccs, ray_cmd_rx, c_nextfrag);\n\t\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_status,\n\t\t    RAY_CCS_STATUS_FREE);\n\t}\n\n\tif (!m)\n\t\treturn;\n\n\tRAY_DPRINTF((\"%s: recv got packet pktlen %lu actual %lu\\n\",\n\t    sc->sc_xname, (u_long)pktlen, (u_long)lenread));\n#ifdef RAY_DEBUG\n\tif (ray_debug && ray_debug_dump_rx)\n\t\tray_dump_mbuf(sc, m);\n#endif\n\t/* receivce the packet */\n\tframe = mtod(m, struct ieee80211_frame *);\n\tfc0 = frame->i_fc[0]\n\t   & (IEEE80211_FC0_VERSION_MASK|IEEE80211_FC0_TYPE_MASK);\n\tif ((fc0 & IEEE80211_FC0_VERSION_MASK) != IEEE80211_FC0_VERSION_0) {\n\t\tRAY_DPRINTF((\"%s: pkt not version 0 fc 0x%x\\n\",\n\t\t    sc->sc_xname, fc0));\n\t\tm_freem(m);\n\t\treturn;\n\t}\n\tif ((fc0 & IEEE80211_FC0_TYPE_MASK) != IEEE80211_FC0_TYPE_DATA) {\n\t\tRAY_DPRINTF((\"%s: pkt not type data fc0 0x%x\\n\",\n\t\t    sc->sc_xname, fc0));\n\t\tm_freem(m);\n\t\treturn;\n\t}\n\n\tif (!memcmp(frame + 1, llc_snapid, sizeof(llc_snapid)))\n\t\tissnap = 1;\n\telse {\n\t\t/*\n\t\t * if user has link0 flag set we allow the weird\n\t\t * Ethernet2 in 802.11 encapsulation produced by\n\t\t * the windows driver for the WebGear card\n\t\t */\n\t\tRAY_DPRINTF((\"%s: pkt not snap 0\\n\", sc->sc_xname));\n\t\tif ((ifp->if_flags & IFF_LINK0) == 0) {\n\t\t\tm_freem(m);\n\t\t\treturn;\n\t\t}\n\t\tissnap = 0;\n\t}\n\tswitch (frame->i_fc[1] & IEEE80211_FC1_DIR_MASK) {\n\tcase IEEE80211_FC1_DIR_NODS:\n\t\tsrc = frame->i_addr2;\n\t\tbreak;\n\tcase IEEE80211_FC1_DIR_FROMDS:\n\t\tsrc = frame->i_addr3;\n\t\tbreak;\n\tcase IEEE80211_FC1_DIR_TODS:\n\t\tRAY_DPRINTF((\"%s: pkt ap2ap\\n\", sc->sc_xname));\n\t\tm_freem(m);\n\t\treturn;\n\tdefault:\n\t\tRAY_DPRINTF((\"%s: pkt type unknown\\n\", sc->sc_xname));\n\t\tm_freem(m);\n\t\treturn;\n\t}\n\n#ifdef RAY_DO_SIGLEV\n\tray_update_siglev(sc, src, siglev);\n#endif\n\n\t/*\n\t * This is a mess.. we should support other LLC frame types\n\t */\n\tif (issnap) {\n\t\t/* create an ether_header over top of the 802.11+SNAP header */\n\t\teh = (struct ether_header *)((caddr_t)(frame + 1) - 6);\n\t\tmemcpy(eh->ether_shost, src, ETHER_ADDR_LEN);\n\t\tmemcpy(eh->ether_dhost, frame->i_addr1, ETHER_ADDR_LEN);\n\t} else {\n\t\t/* this is the weird e2 in 802.11 encapsulation */\n\t\teh = (struct ether_header *)(frame + 1);\n\t}\n\tm_adj(m, (caddr_t)eh - (caddr_t)frame);\n#if NBPFILTER > 0\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\t/* XXX doesn't appear to be included m->m_flags |= M_HASFCS; */\n\tifp->if_ipackets++;\n#ifdef __NetBSD__\n\t(*ifp->if_input)(ifp, m);\n#elif defined(__OpenBSD__)\n\tm_adj(m, sizeof(struct ether_header));\n\tether_input(ifp, eh, m);\n#endif\n}"
  },
  {
    "function_name": "ray_intr_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
    "lines": "1234-1441",
    "snippet": "void\nray_intr_start(sc)\n\tstruct ray_softc *sc;\n{\n\tstruct ieee80211_frame *iframe;\n\tstruct ether_header *eh;\n\tsize_t len, pktlen, tmplen;\n\tbus_size_t bufp, ebufp;\n\tstruct mbuf *m0, *m;\n\tstruct ifnet *ifp;\n\tu_int firsti, hinti, previ, i, pcount;\n\tu_int16_t et;\n\tu_int8_t *d;\n\n\tifp = &sc->sc_if;\n\n\tRAY_DPRINTF((\"%s: start free %d qlen %d qmax %d\\n\",\n\t    ifp->if_xname, sc->sc_txfree, ifp->if_snd.ifq_len,\n\t    ifp->if_snd.ifq_maxlen));\n\n\tray_cmd_cancel(sc, SCP_IFSTART);\n\n\tif ((ifp->if_flags & IFF_RUNNING) == 0 || !sc->sc_havenet)\n\t\treturn;\n\n\tif (ifp->if_snd.ifq_len == 0)\n\t\treturn;\n\n\tfirsti = i = previ = RAY_CCS_LINK_NULL;\n\thinti = RAY_CCS_TX_FIRST;\n\n\tif (!RAY_ECF_READY(sc)) {\n\t\tray_cmd_schedule(sc, SCP_IFSTART);\n\t\treturn;\n\t}\n\n\tpcount = 0;\n\tfor (;;) {\n\t\t/* if we have no descriptors be done */\n\t\tif (i == RAY_CCS_LINK_NULL) {\n\t\t\ti = ray_find_free_tx_ccs(sc, hinti);\n\t\t\tif (i == RAY_CCS_LINK_NULL) {\n\t\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tIF_DEQUEUE(&ifp->if_snd, m0);\n\t\tif (!m0)\n\t\t\tbreak;\n\t\tRAY_DPRINTF((\"%s: gotmbuf 0x%lx\\n\", ifp->if_xname, (long)m0));\n\t\tpktlen = m0->m_pkthdr.len;\n\t\tif (pktlen > ETHER_MAX_LEN - ETHER_CRC_LEN) {\n\t\t\tRAY_DPRINTF((\n\t\t\t    \"%s: mbuf too long %lu\\n\", ifp->if_xname,\n\t\t\t    (u_long)pktlen));\n\t\t\tifp->if_oerrors++;\n\t\t\tm_freem(m0);\n\t\t\tcontinue;\n\t\t}\n\t\tRAY_DPRINTF((\"%s: mbuf.m_pkthdr.len %d\\n\", ifp->if_xname,\n\t\t    (int)pktlen));\n\n\t\t/* we need the ether_header now for pktlen adjustments */\n\t\tM_PULLUP(m0, sizeof(struct ether_header));\n\t\tif (!m0) {\n\t\t\tRAY_DPRINTF(( \"%s: couldn\\'t pullup ether header\\n\",\n\t\t\t    ifp->if_xname));\n\t\t\tifp->if_oerrors++;\n\t\t\tcontinue;\n\t\t}\n\t\tRAY_DPRINTF((\"%s: got pulled up mbuf 0x%lx\\n\", ifp->if_xname,\n\t\t    (long)m0));\n\n\t\t/* first peek at the type of packet and figure out what to do */\n\t\teh = mtod(m0, struct ether_header *);\n\t\tet = ntohs(eh->ether_type);\n\t\tif (ifp->if_flags & IFF_LINK0) {\n\t\t\t/* don't support llc for windows compat operation */\n\t\t\tif (et <= ETHERMTU) {\n\t\t\t\tm_freem(m0);\n\t\t\t\tifp->if_oerrors++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttmplen = sizeof(struct ieee80211_frame);\n\t\t} else if (et > ETHERMTU) {\n\t\t\t/* adjust for LLC/SNAP header */\n\t\t\ttmplen= sizeof(struct ieee80211_frame) - ETHER_ADDR_LEN;\n\t\t}\n\t\t/* now get our space for the 802.11 frame */\n\t\tM_PREPEND(m0, tmplen, M_DONTWAIT);\n\t\tif (m0)\n\t\t\tM_PULLUP(m0, sizeof(struct ether_header) + tmplen);\n\t\tif (!m0) {\n\t\t\tRAY_DPRINTF((\"%s: couldn\\'t prepend header\\n\",\n\t\t\t    ifp->if_xname));\n\t\t\tifp->if_oerrors++;\n\t\t\tcontinue;\n\t\t}\n\t\t/* copy the frame into the mbuf for tapping */\n\t\tiframe = mtod(m0, struct ieee80211_frame *);\n\t\teh = (struct ether_header *)((u_int8_t *)iframe + tmplen);\n\t\tiframe->i_fc[0] =\n\t\t    (IEEE80211_FC0_VERSION_0 | IEEE80211_FC0_TYPE_DATA);\n\t\tif (sc->sc_mode == SC_MODE_ADHOC) {\n\t\t\tiframe->i_fc[1] = IEEE80211_FC1_DIR_NODS;\n\t\t\tmemcpy(iframe->i_addr1, eh->ether_dhost,ETHER_ADDR_LEN);\n\t\t\tmemcpy(iframe->i_addr2, eh->ether_shost,ETHER_ADDR_LEN);\n\t\t\tmemcpy(iframe->i_addr3, sc->sc_bssid, ETHER_ADDR_LEN);\n\t\t} else {\n\t\t\tiframe->i_fc[1] = IEEE80211_FC1_DIR_TODS;\n\t\t\tmemcpy(iframe->i_addr1, sc->sc_bssid,ETHER_ADDR_LEN);\n\t\t\tmemcpy(iframe->i_addr2, eh->ether_shost,ETHER_ADDR_LEN);\n\t\t\tmemmove(iframe->i_addr3,eh->ether_dhost,ETHER_ADDR_LEN);\n\t\t}\n\t\tiframe->i_dur[0] = iframe->i_dur[1] = 0;\n\t\tiframe->i_seq[0] = iframe->i_seq[1] = 0;\n\n\t\t/* if not using crummy E2 in 802.11 make it LLC/SNAP */\n\t\tif ((ifp->if_flags & IFF_LINK0) == 0 && et > ETHERMTU)\n\t\t\tmemcpy(iframe + 1, llc_snapid, sizeof(llc_snapid));\n\n\t\tRAY_DPRINTF((\"%s: i %d previ %d\\n\", ifp->if_xname, i, previ));\n\n\t\tif (firsti == RAY_CCS_LINK_NULL)\n\t\t\tfirsti = i;\n\n\t\tpktlen = m0->m_pkthdr.len;\n\t\tbufp = ray_fill_in_tx_ccs(sc, pktlen, i, previ);\n\t\tprevi = hinti = i;\n\t\ti = RAY_CCS_LINK_NULL;\n\n\t\tRAY_DPRINTF((\"%s: bufp 0x%lx new pktlen %d\\n\",\n\t\t    ifp->if_xname, (long)bufp, (int)pktlen));\n\n\t\t/* copy out mbuf */\n\t\tfor (m = m0; m; m = m->m_next) {\n\t\t\tif ((len = m->m_len) == 0)\n\t\t\t\tcontinue;\n\t\t\tRAY_DPRINTF((\n\t\t\t    \"%s: copying mbuf 0x%lx bufp 0x%lx len %d\\n\",\n\t\t\t    ifp->if_xname, (long)m, (long)bufp, (int)len));\n\t\t\td = mtod(m, u_int8_t *);\n\t\t\tebufp = bufp + len;\n\t\t\tif (ebufp <= RAY_TX_END)\n\t\t\t\tray_write_region(sc, bufp, d, len);\n\t\t\telse {\n\t\t\t\tpanic(\"ray_intr_start\");\t/* XXX */\n\t\t\t\t/* wrapping */\n\t\t\t\ttmplen = ebufp - bufp;\n\t\t\t\tlen -= tmplen;\n\t\t\t\tray_write_region(sc, bufp, d, tmplen);\n\t\t\t\td += tmplen;\n\t\t\t\tbufp = RAY_TX_BASE;\n\t\t\t\tray_write_region(sc, bufp, d, len);\n\t\t\t}\n\t\t\tbufp += len;\n\t\t}\n#if NBPFILTER > 0\n\t\tif (ifp->if_bpf) {\n\t\t\tif (ifp->if_flags & IFF_LINK0) {\n\t\t\t\tm0->m_data += sizeof(struct ieee80211_frame);\n\t\t\t\tm0->m_len -=  sizeof(struct ieee80211_frame);\n\t\t\t\tm0->m_pkthdr.len -=  sizeof(struct ieee80211_frame);\n\t\t\t}\n\t\t\tbpf_mtap(ifp->if_bpf, m0);\n\t\t\tif (ifp->if_flags & IFF_LINK0) {\n\t\t\t\tm0->m_data -= sizeof(struct ieee80211_frame);\n\t\t\t\tm0->m_len +=  sizeof(struct ieee80211_frame);\n\t\t\t\tm0->m_pkthdr.len +=  sizeof(struct ieee80211_frame);\n\t\t\t}\n\t\t}\n#endif\n\n#ifdef RAY_DEBUG\n\t\tif (ray_debug && ray_debug_dump_tx)\n\t\t\tray_dump_mbuf(sc, m0);\n#endif\n\t\tpcount++;\n\t\tm_freem(m0);\n\t}\n\n\tif (firsti == RAY_CCS_LINK_NULL)\n\t\treturn;\n\ti = 0;\n\tif (!RAY_ECF_READY(sc)) {\n\t\t/*\n\t\t * if this can really happen perhaps we need to save\n\t\t * the chain and use it later.  I think this might\n\t\t * be a confused state though because we check above\n\t\t * and don't issue any commands between.\n\t\t */\n\t\tprintf(\"%s: dropping tx packets device busy\\n\", sc->sc_xname);\n\t\tray_free_ccs_chain(sc, firsti);\n\t\tifp->if_oerrors += pcount;\n\t\treturn;\n\t}\n\n\t/* send it off */\n\tRAY_DPRINTF((\"%s: ray_start issueing %d \\n\", sc->sc_xname, firsti));\n\tSRAM_WRITE_1(sc, RAY_SCB_CCSI, firsti);\n\tRAY_ECF_START_CMD(sc);\n\n\tRAY_DPRINTF_XMIT((\"%s: sent packet: len %lu\\n\", sc->sc_xname,\n\t    (u_long)pktlen));\n\n\tifp->if_opackets += pcount;\n}",
    "includes": [
      "#include <dev/pcmcia/if_rayreg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_llc.h>",
      "#include <net/if_media.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/timeout.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [
      "#define\tSCP_IFSTART\t\t0x0008",
      "#define\tSC_MODE_ADHOC\t0\t/* ad-hoc mode */",
      "#define\tsc_xname\tsc_dev.dv_xname",
      "#define\tmemmove\t\tmemcpy\t\t/* XXX */",
      "#define\tsc_if\t\tsc_ec.ac_if",
      "#define\tsc_if\t\tsc_ec.ec_if",
      "#define\tETHER_MAX_LEN\t1518",
      "#define\tETHER_CRC_LEN\t4"
    ],
    "globals_used": [
      "bus_size_t ray_fill_in_tx_ccs",
      "void ray_cmd_cancel",
      "void ray_cmd_schedule",
      "u_int ray_find_free_tx_ccs",
      "void ray_free_ccs_chain",
      "void ray_intr_start",
      "static const u_int8_t llc_snapid[6] = { LLC_SNAP_LSAP, LLC_SNAP_LSAP, LLC_UI };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RAY_DPRINTF_XMIT",
          "args": [
            "(\"%s: sent packet: len %lu\\n\", sc->sc_xname,\n\t    (u_long)pktlen)"
          ],
          "line": 1437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_ECF_START_CMD",
          "args": [
            "sc"
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRAM_WRITE_1",
          "args": [
            "sc",
            "RAY_SCB_CCSI",
            "firsti"
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: ray_start issueing %d \\n\", sc->sc_xname, firsti)"
          ],
          "line": 1433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ray_free_ccs_chain",
          "args": [
            "sc",
            "firsti"
          ],
          "line": 1427
        },
        "resolved": true,
        "details": {
          "function_name": "ray_free_ccs_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2138-2150",
          "snippet": "void\nray_free_ccs_chain(sc, ni)\n\tstruct ray_softc *sc;\n\tu_int ni;\n{\n\tu_int i;\n\n\twhile ((i = ni) != RAY_CCS_LINK_NULL) {\n\t\tni = SRAM_READ_FIELD_1(sc, RAY_GET_CCS(i), ray_cmd, c_link);\n\t\tSRAM_WRITE_FIELD_1(sc, RAY_GET_CCS(i), ray_cmd, c_status,\n\t\t    RAY_CCS_STATUS_FREE);\n\t}\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ray_free_ccs_chain"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\nvoid ray_free_ccs_chain;\n\nvoid\nray_free_ccs_chain(sc, ni)\n\tstruct ray_softc *sc;\n\tu_int ni;\n{\n\tu_int i;\n\n\twhile ((i = ni) != RAY_CCS_LINK_NULL) {\n\t\tni = SRAM_READ_FIELD_1(sc, RAY_GET_CCS(i), ray_cmd, c_link);\n\t\tSRAM_WRITE_FIELD_1(sc, RAY_GET_CCS(i), ray_cmd, c_status,\n\t\t    RAY_CCS_STATUS_FREE);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: dropping tx packets device busy\\n\"",
            "sc->sc_xname"
          ],
          "line": 1426
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RAY_ECF_READY",
          "args": [
            "sc"
          ],
          "line": 1419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m0"
          ],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ray_dump_mbuf",
          "args": [
            "sc",
            "m0"
          ],
          "line": 1410
        },
        "resolved": true,
        "details": {
          "function_name": "ray_dump_mbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "3262-3286",
          "snippet": "void\nray_dump_mbuf(sc, m)\n\tstruct ray_softc *sc;\n\tstruct mbuf *m;\n{\n\tu_int8_t *d, *ed;\n\tu_int i;\n\n\tprintf(\"%s: pkt dump:\", sc->sc_xname);\n\ti = 0;\n\tfor (; m; m = m->m_next) {\n\t\td = mtod(m, u_int8_t *);\n\t\ted = d + m->m_len;\n\n\t\tfor (; d < ed; i++, d++) {\n\t\t\tif ((i % 16) == 0)\n\t\t\t\tprintf(\"\\n\\t\");\n\t\t\telse if ((i % 8) == 0)\n\t\t\t\tprintf(\"  \");\n\t\t\tprintf(\" %02x\", *d);\n\t\t}\n\t}\n\tif ((i - 1) % 16)\n\t\tprintf(\"\\n\");\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tsc_xname\tsc_dev.dv_xname"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_xname\tsc_dev.dv_xname\n\nvoid\nray_dump_mbuf(sc, m)\n\tstruct ray_softc *sc;\n\tstruct mbuf *m;\n{\n\tu_int8_t *d, *ed;\n\tu_int i;\n\n\tprintf(\"%s: pkt dump:\", sc->sc_xname);\n\ti = 0;\n\tfor (; m; m = m->m_next) {\n\t\td = mtod(m, u_int8_t *);\n\t\ted = d + m->m_len;\n\n\t\tfor (; d < ed; i++, d++) {\n\t\t\tif ((i % 16) == 0)\n\t\t\t\tprintf(\"\\n\\t\");\n\t\t\telse if ((i % 8) == 0)\n\t\t\t\tprintf(\"  \");\n\t\t\tprintf(\" %02x\", *d);\n\t\t}\n\t}\n\tif ((i - 1) % 16)\n\t\tprintf(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_mtap",
          "args": [
            "ifp->if_bpf",
            "m0"
          ],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ray_write_region",
          "args": [
            "sc",
            "bufp",
            "d",
            "len"
          ],
          "line": 1388
        },
        "resolved": true,
        "details": {
          "function_name": "ray_write_region",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "3125-3177",
          "snippet": "void\nray_write_region(sc, off, vp, c)\n\tstruct ray_softc *sc;\n\tbus_size_t off;\n\tvoid *vp;\n\tsize_t c;\n{\n#ifdef RAY_USE_OPTIMIZED_COPY\n\tsize_t n2, n4, tmp;\n\tu_int8_t *p;\n\n\tp = vp;\n\t/* XXX we may be making poor assumptions here but lets hope */\n\tswitch ((off|(bus_addr_t)p) & 0x03) {\n\tcase 0:\n\t\tif ((n4 = (c >> 2))) {\n\t\t\tbus_space_write_region_4(sc->sc_memt, sc->sc_memh, off,\n\t\t\t    p, n4);\n\t\t\ttmp = c & ~0x3;\n\t\t\tc &= 0x3;\n\t\t\tp += tmp;\n\t\t\toff += tmp;\n\t\t}\n\t\tswitch (c) {\n\t\tcase 3:\n\t\t\tbus_space_write_1(sc->sc_memt,sc->sc_memh, off, *p);\n\t\t\tp++, off++;\n\t\tcase 2:\n\t\t\tbus_space_write_1(sc->sc_memt,sc->sc_memh, off, *p);\n\t\t\tp++, off++;\n\t\tcase 1:\n\t\t\tbus_space_write_1(sc->sc_memt,sc->sc_memh, off, *p);\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tif ((n2 = (c >> 1)))\n\t\t\tbus_space_write_region_2(sc->sc_memt, sc->sc_memh, off,\n\t\t\t    p, n2);\n\t\tif (c & 0x1) {\n\t\t\tc &= ~0x1;\n\t\t\tbus_space_write_1(sc->sc_memt, sc->sc_memh,\n\t\t\t    off + c, *(p + c));\n\t\t}\n\t\tbreak;\n\tcase 1:\n\tcase 3:\n\t\tbus_space_write_region_1(sc->sc_memt, sc->sc_memh, off, p, c);\n\t\tbreak;\n\t}\n#else\n\tbus_space_write_region_1(sc->sc_memt, sc->sc_memh, off, vp, c);\n#endif\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tsc_memh\tsc_mem.memh",
            "#define\tsc_memt\tsc_mem.memt"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_memh\tsc_mem.memh\n#define\tsc_memt\tsc_mem.memt\n\nvoid\nray_write_region(sc, off, vp, c)\n\tstruct ray_softc *sc;\n\tbus_size_t off;\n\tvoid *vp;\n\tsize_t c;\n{\n#ifdef RAY_USE_OPTIMIZED_COPY\n\tsize_t n2, n4, tmp;\n\tu_int8_t *p;\n\n\tp = vp;\n\t/* XXX we may be making poor assumptions here but lets hope */\n\tswitch ((off|(bus_addr_t)p) & 0x03) {\n\tcase 0:\n\t\tif ((n4 = (c >> 2))) {\n\t\t\tbus_space_write_region_4(sc->sc_memt, sc->sc_memh, off,\n\t\t\t    p, n4);\n\t\t\ttmp = c & ~0x3;\n\t\t\tc &= 0x3;\n\t\t\tp += tmp;\n\t\t\toff += tmp;\n\t\t}\n\t\tswitch (c) {\n\t\tcase 3:\n\t\t\tbus_space_write_1(sc->sc_memt,sc->sc_memh, off, *p);\n\t\t\tp++, off++;\n\t\tcase 2:\n\t\t\tbus_space_write_1(sc->sc_memt,sc->sc_memh, off, *p);\n\t\t\tp++, off++;\n\t\tcase 1:\n\t\t\tbus_space_write_1(sc->sc_memt,sc->sc_memh, off, *p);\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tif ((n2 = (c >> 1)))\n\t\t\tbus_space_write_region_2(sc->sc_memt, sc->sc_memh, off,\n\t\t\t    p, n2);\n\t\tif (c & 0x1) {\n\t\t\tc &= ~0x1;\n\t\t\tbus_space_write_1(sc->sc_memt, sc->sc_memh,\n\t\t\t    off + c, *(p + c));\n\t\t}\n\t\tbreak;\n\tcase 1:\n\tcase 3:\n\t\tbus_space_write_region_1(sc->sc_memt, sc->sc_memh, off, p, c);\n\t\tbreak;\n\t}\n#else\n\tbus_space_write_region_1(sc->sc_memt, sc->sc_memh, off, vp, c);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"ray_intr_start\""
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "u_int8_t*"
          ],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\n\t\t\t    \"%s: copying mbuf 0x%lx bufp 0x%lx len %d\\n\",\n\t\t\t    ifp->if_xname, (long)m, (long)bufp, (int)len)"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: bufp 0x%lx new pktlen %d\\n\",\n\t\t    ifp->if_xname, (long)bufp, (int)pktlen)"
          ],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ray_fill_in_tx_ccs",
          "args": [
            "sc",
            "pktlen",
            "i",
            "previ"
          ],
          "line": 1362
        },
        "resolved": true,
        "details": {
          "function_name": "ray_fill_in_tx_ccs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "1707-1736",
          "snippet": "bus_size_t\nray_fill_in_tx_ccs(sc, pktlen, i, pi)\n\tstruct ray_softc *sc;\n\tsize_t pktlen;\n\tu_int i, pi;\n{\n\tbus_size_t ccs, bufp;\n\n\t/* pktlen += RAY_TX_PHY_SIZE; */\n\tbufp = RAY_TX_BASE + i * RAY_TX_BUF_SIZE;\n\tbufp += sc->sc_txpad;\n\tccs = RAY_GET_CCS(i);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_tx, c_status, RAY_CCS_STATUS_BUSY);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_tx, c_cmd, RAY_CMD_TX_REQ);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_tx, c_link, RAY_CCS_LINK_NULL);\n\tSRAM_WRITE_FIELD_2(sc, ccs, ray_cmd_tx, c_bufp, bufp);\n\tSRAM_WRITE_FIELD_2(sc, ccs, ray_cmd_tx, c_len, pktlen);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_tx, c_tx_rate, sc->sc_deftxrate);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_tx, c_apm_mode, 0);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_tx, c_antenna, 0);\n\n\t/* link us in */\n\tif (pi != RAY_CCS_LINK_NULL)\n\t\tSRAM_WRITE_FIELD_1(sc, RAY_GET_CCS(pi), ray_cmd_tx, c_link, i);\n\n\tRAY_DPRINTF((\"%s: ray_alloc_tx_ccs bufp 0x%lx idx %d pidx %d \\n\",\n\t    sc->sc_xname, bufp, i, pi));\n\n\treturn (bufp + RAY_TX_PHY_SIZE);\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tsc_xname\tsc_dev.dv_xname"
          ],
          "globals_used": [
            "bus_size_t ray_fill_in_tx_ccs"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_xname\tsc_dev.dv_xname\n\nbus_size_t ray_fill_in_tx_ccs;\n\nbus_size_t\nray_fill_in_tx_ccs(sc, pktlen, i, pi)\n\tstruct ray_softc *sc;\n\tsize_t pktlen;\n\tu_int i, pi;\n{\n\tbus_size_t ccs, bufp;\n\n\t/* pktlen += RAY_TX_PHY_SIZE; */\n\tbufp = RAY_TX_BASE + i * RAY_TX_BUF_SIZE;\n\tbufp += sc->sc_txpad;\n\tccs = RAY_GET_CCS(i);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_tx, c_status, RAY_CCS_STATUS_BUSY);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_tx, c_cmd, RAY_CMD_TX_REQ);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_tx, c_link, RAY_CCS_LINK_NULL);\n\tSRAM_WRITE_FIELD_2(sc, ccs, ray_cmd_tx, c_bufp, bufp);\n\tSRAM_WRITE_FIELD_2(sc, ccs, ray_cmd_tx, c_len, pktlen);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_tx, c_tx_rate, sc->sc_deftxrate);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_tx, c_apm_mode, 0);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_tx, c_antenna, 0);\n\n\t/* link us in */\n\tif (pi != RAY_CCS_LINK_NULL)\n\t\tSRAM_WRITE_FIELD_1(sc, RAY_GET_CCS(pi), ray_cmd_tx, c_link, i);\n\n\tRAY_DPRINTF((\"%s: ray_alloc_tx_ccs bufp 0x%lx idx %d pidx %d \\n\",\n\t    sc->sc_xname, bufp, i, pi));\n\n\treturn (bufp + RAY_TX_PHY_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: i %d previ %d\\n\", ifp->if_xname, i, previ)"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "iframe + 1",
            "llc_snapid",
            "sizeof(llc_snapid)"
          ],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "iframe->i_addr3",
            "eh->ether_dhost",
            "ETHER_ADDR_LEN"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "iframe->i_addr2",
            "eh->ether_shost",
            "ETHER_ADDR_LEN"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "iframe->i_addr1",
            "sc->sc_bssid",
            "ETHER_ADDR_LEN"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "iframe->i_addr3",
            "sc->sc_bssid",
            "ETHER_ADDR_LEN"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "iframe->i_addr2",
            "eh->ether_shost",
            "ETHER_ADDR_LEN"
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "iframe->i_addr1",
            "eh->ether_dhost",
            "ETHER_ADDR_LEN"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m0",
            "structieee80211_frame*"
          ],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: couldn\\'t prepend header\\n\",\n\t\t\t    ifp->if_xname)"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "M_PULLUP",
          "args": [
            "m0",
            "sizeof(struct ether_header) + tmplen"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "M_PREPEND",
          "args": [
            "m0",
            "tmplen",
            "M_DONTWAIT"
          ],
          "line": 1324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m0"
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "eh->ether_type"
          ],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m0",
            "structether_header*"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: got pulled up mbuf 0x%lx\\n\", ifp->if_xname,\n\t\t    (long)m0)"
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "( \"%s: couldn\\'t pullup ether header\\n\",\n\t\t\t    ifp->if_xname)"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "M_PULLUP",
          "args": [
            "m0",
            "sizeof(struct ether_header)"
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: mbuf.m_pkthdr.len %d\\n\", ifp->if_xname,\n\t\t    (int)pktlen)"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m0"
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\n\t\t\t    \"%s: mbuf too long %lu\\n\", ifp->if_xname,\n\t\t\t    (u_long)pktlen)"
          ],
          "line": 1287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: gotmbuf 0x%lx\\n\", ifp->if_xname, (long)m0)"
          ],
          "line": 1284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_DEQUEUE",
          "args": [
            "&ifp->if_snd",
            "m0"
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ray_find_free_tx_ccs",
          "args": [
            "sc",
            "hinti"
          ],
          "line": 1274
        },
        "resolved": true,
        "details": {
          "function_name": "ray_find_free_tx_ccs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "1679-1701",
          "snippet": "u_int\nray_find_free_tx_ccs(sc, hint)\n\tstruct ray_softc *sc;\n\tu_int hint;\n{\n\tu_int i, stat;\n\n\tfor (i = hint; i <= RAY_CCS_TX_LAST; i++) {\n\t\tstat = SRAM_READ_FIELD_1(sc, RAY_GET_CCS(i), ray_cmd, c_status);\n\t\tif (stat == RAY_CCS_STATUS_FREE)\n\t\t\treturn (i);\n\t}\n\n\tif (hint == RAY_CCS_TX_FIRST)\n\t\treturn (RAY_CCS_LINK_NULL);\n\n\tfor (i = RAY_CCS_TX_FIRST; i < hint; i++) {\n\t\tstat = SRAM_READ_FIELD_1(sc, RAY_GET_CCS(i), ray_cmd, c_status);\n\t\tif (stat == RAY_CCS_STATUS_FREE)\n\t\t\treturn (i);\n\t}\n\treturn (RAY_CCS_LINK_NULL);\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "u_int ray_find_free_tx_ccs"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\nu_int ray_find_free_tx_ccs;\n\nu_int\nray_find_free_tx_ccs(sc, hint)\n\tstruct ray_softc *sc;\n\tu_int hint;\n{\n\tu_int i, stat;\n\n\tfor (i = hint; i <= RAY_CCS_TX_LAST; i++) {\n\t\tstat = SRAM_READ_FIELD_1(sc, RAY_GET_CCS(i), ray_cmd, c_status);\n\t\tif (stat == RAY_CCS_STATUS_FREE)\n\t\t\treturn (i);\n\t}\n\n\tif (hint == RAY_CCS_TX_FIRST)\n\t\treturn (RAY_CCS_LINK_NULL);\n\n\tfor (i = RAY_CCS_TX_FIRST; i < hint; i++) {\n\t\tstat = SRAM_READ_FIELD_1(sc, RAY_GET_CCS(i), ray_cmd, c_status);\n\t\tif (stat == RAY_CCS_STATUS_FREE)\n\t\t\treturn (i);\n\t}\n\treturn (RAY_CCS_LINK_NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ray_cmd_schedule",
          "args": [
            "sc",
            "SCP_IFSTART"
          ],
          "line": 1266
        },
        "resolved": true,
        "details": {
          "function_name": "ray_cmd_schedule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2248-2265",
          "snippet": "void\nray_cmd_schedule(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tint track;\n\n\tRAY_DPRINTF((\"%s: ray_cmd_schedule 0x%x\\n\", sc->sc_xname, cmdf));\n\n\ttrack = cmdf;\n\tif ((cmdf & SCP_UPD_MASK) == 0)\n\t\tray_set_pending(sc, track);\n\telse if (ray_cmd_is_running(sc, SCP_UPDATESUBCMD)) {\n\t\t/* don't do timeout mechaniscm if subcmd already going */\n\t\tsc->sc_scheduled |= cmdf;\n\t} else\n\t\tray_set_pending(sc, cmdf | SCP_UPDATESUBCMD);\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tSCP_UPD_MASK\t\t0xff00",
            "#define\tSCP_UPDATESUBCMD\t0x0001",
            "#define\tsc_xname\tsc_dev.dv_xname"
          ],
          "globals_used": [
            "void ray_cmd_schedule",
            "int ray_cmd_is_running",
            "void ray_set_pending"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSCP_UPD_MASK\t\t0xff00\n#define\tSCP_UPDATESUBCMD\t0x0001\n#define\tsc_xname\tsc_dev.dv_xname\n\nvoid ray_cmd_schedule;\nint ray_cmd_is_running;\nvoid ray_set_pending;\n\nvoid\nray_cmd_schedule(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tint track;\n\n\tRAY_DPRINTF((\"%s: ray_cmd_schedule 0x%x\\n\", sc->sc_xname, cmdf));\n\n\ttrack = cmdf;\n\tif ((cmdf & SCP_UPD_MASK) == 0)\n\t\tray_set_pending(sc, track);\n\telse if (ray_cmd_is_running(sc, SCP_UPDATESUBCMD)) {\n\t\t/* don't do timeout mechaniscm if subcmd already going */\n\t\tsc->sc_scheduled |= cmdf;\n\t} else\n\t\tray_set_pending(sc, cmdf | SCP_UPDATESUBCMD);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RAY_ECF_READY",
          "args": [
            "sc"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ray_cmd_cancel",
          "args": [
            "sc",
            "SCP_IFSTART"
          ],
          "line": 1254
        },
        "resolved": true,
        "details": {
          "function_name": "ray_cmd_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2283-2299",
          "snippet": "void\nray_cmd_cancel(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_cmd_cancel 0x%x\\n\", sc->sc_xname, cmdf));\n\n\tsc->sc_scheduled &= ~cmdf;\n\tif ((cmdf & SCP_UPD_MASK) && (sc->sc_scheduled & SCP_UPD_MASK) == 0)\n\t\tsc->sc_scheduled &= ~SCP_UPDATESUBCMD;\n\n\t/* if nothing else needed cancel the timer */\n\tif (sc->sc_scheduled == 0 && sc->sc_timoneed) {\n\t\tcallout_stop(&sc->sc_check_scheduled_ch);\n\t\tsc->sc_timoneed = 0;\n\t}\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tSCP_UPD_MASK\t\t0xff00",
            "#define\tSCP_UPDATESUBCMD\t0x0001",
            "#define\tsc_xname\tsc_dev.dv_xname",
            "#define\tcallout_stop\ttimeout_del"
          ],
          "globals_used": [
            "void ray_cmd_cancel"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSCP_UPD_MASK\t\t0xff00\n#define\tSCP_UPDATESUBCMD\t0x0001\n#define\tsc_xname\tsc_dev.dv_xname\n#define\tcallout_stop\ttimeout_del\n\nvoid ray_cmd_cancel;\n\nvoid\nray_cmd_cancel(sc, cmdf)\n\tstruct ray_softc *sc;\n\tint cmdf;\n{\n\tRAY_DPRINTF((\"%s: ray_cmd_cancel 0x%x\\n\", sc->sc_xname, cmdf));\n\n\tsc->sc_scheduled &= ~cmdf;\n\tif ((cmdf & SCP_UPD_MASK) && (sc->sc_scheduled & SCP_UPD_MASK) == 0)\n\t\tsc->sc_scheduled &= ~SCP_UPDATESUBCMD;\n\n\t/* if nothing else needed cancel the timer */\n\tif (sc->sc_scheduled == 0 && sc->sc_timoneed) {\n\t\tcallout_stop(&sc->sc_check_scheduled_ch);\n\t\tsc->sc_timoneed = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: start free %d qlen %d qmax %d\\n\",\n\t    ifp->if_xname, sc->sc_txfree, ifp->if_snd.ifq_len,\n\t    ifp->if_snd.ifq_maxlen)"
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSCP_IFSTART\t\t0x0008\n#define\tSC_MODE_ADHOC\t0\t/* ad-hoc mode */\n#define\tsc_xname\tsc_dev.dv_xname\n#define\tmemmove\t\tmemcpy\t\t/* XXX */\n#define\tsc_if\t\tsc_ec.ac_if\n#define\tsc_if\t\tsc_ec.ec_if\n#define\tETHER_MAX_LEN\t1518\n#define\tETHER_CRC_LEN\t4\n\nbus_size_t ray_fill_in_tx_ccs;\nvoid ray_cmd_cancel;\nvoid ray_cmd_schedule;\nu_int ray_find_free_tx_ccs;\nvoid ray_free_ccs_chain;\nvoid ray_intr_start;\nstatic const u_int8_t llc_snapid[6] = { LLC_SNAP_LSAP, LLC_SNAP_LSAP, LLC_UI };\n\nvoid\nray_intr_start(sc)\n\tstruct ray_softc *sc;\n{\n\tstruct ieee80211_frame *iframe;\n\tstruct ether_header *eh;\n\tsize_t len, pktlen, tmplen;\n\tbus_size_t bufp, ebufp;\n\tstruct mbuf *m0, *m;\n\tstruct ifnet *ifp;\n\tu_int firsti, hinti, previ, i, pcount;\n\tu_int16_t et;\n\tu_int8_t *d;\n\n\tifp = &sc->sc_if;\n\n\tRAY_DPRINTF((\"%s: start free %d qlen %d qmax %d\\n\",\n\t    ifp->if_xname, sc->sc_txfree, ifp->if_snd.ifq_len,\n\t    ifp->if_snd.ifq_maxlen));\n\n\tray_cmd_cancel(sc, SCP_IFSTART);\n\n\tif ((ifp->if_flags & IFF_RUNNING) == 0 || !sc->sc_havenet)\n\t\treturn;\n\n\tif (ifp->if_snd.ifq_len == 0)\n\t\treturn;\n\n\tfirsti = i = previ = RAY_CCS_LINK_NULL;\n\thinti = RAY_CCS_TX_FIRST;\n\n\tif (!RAY_ECF_READY(sc)) {\n\t\tray_cmd_schedule(sc, SCP_IFSTART);\n\t\treturn;\n\t}\n\n\tpcount = 0;\n\tfor (;;) {\n\t\t/* if we have no descriptors be done */\n\t\tif (i == RAY_CCS_LINK_NULL) {\n\t\t\ti = ray_find_free_tx_ccs(sc, hinti);\n\t\t\tif (i == RAY_CCS_LINK_NULL) {\n\t\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tIF_DEQUEUE(&ifp->if_snd, m0);\n\t\tif (!m0)\n\t\t\tbreak;\n\t\tRAY_DPRINTF((\"%s: gotmbuf 0x%lx\\n\", ifp->if_xname, (long)m0));\n\t\tpktlen = m0->m_pkthdr.len;\n\t\tif (pktlen > ETHER_MAX_LEN - ETHER_CRC_LEN) {\n\t\t\tRAY_DPRINTF((\n\t\t\t    \"%s: mbuf too long %lu\\n\", ifp->if_xname,\n\t\t\t    (u_long)pktlen));\n\t\t\tifp->if_oerrors++;\n\t\t\tm_freem(m0);\n\t\t\tcontinue;\n\t\t}\n\t\tRAY_DPRINTF((\"%s: mbuf.m_pkthdr.len %d\\n\", ifp->if_xname,\n\t\t    (int)pktlen));\n\n\t\t/* we need the ether_header now for pktlen adjustments */\n\t\tM_PULLUP(m0, sizeof(struct ether_header));\n\t\tif (!m0) {\n\t\t\tRAY_DPRINTF(( \"%s: couldn\\'t pullup ether header\\n\",\n\t\t\t    ifp->if_xname));\n\t\t\tifp->if_oerrors++;\n\t\t\tcontinue;\n\t\t}\n\t\tRAY_DPRINTF((\"%s: got pulled up mbuf 0x%lx\\n\", ifp->if_xname,\n\t\t    (long)m0));\n\n\t\t/* first peek at the type of packet and figure out what to do */\n\t\teh = mtod(m0, struct ether_header *);\n\t\tet = ntohs(eh->ether_type);\n\t\tif (ifp->if_flags & IFF_LINK0) {\n\t\t\t/* don't support llc for windows compat operation */\n\t\t\tif (et <= ETHERMTU) {\n\t\t\t\tm_freem(m0);\n\t\t\t\tifp->if_oerrors++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttmplen = sizeof(struct ieee80211_frame);\n\t\t} else if (et > ETHERMTU) {\n\t\t\t/* adjust for LLC/SNAP header */\n\t\t\ttmplen= sizeof(struct ieee80211_frame) - ETHER_ADDR_LEN;\n\t\t}\n\t\t/* now get our space for the 802.11 frame */\n\t\tM_PREPEND(m0, tmplen, M_DONTWAIT);\n\t\tif (m0)\n\t\t\tM_PULLUP(m0, sizeof(struct ether_header) + tmplen);\n\t\tif (!m0) {\n\t\t\tRAY_DPRINTF((\"%s: couldn\\'t prepend header\\n\",\n\t\t\t    ifp->if_xname));\n\t\t\tifp->if_oerrors++;\n\t\t\tcontinue;\n\t\t}\n\t\t/* copy the frame into the mbuf for tapping */\n\t\tiframe = mtod(m0, struct ieee80211_frame *);\n\t\teh = (struct ether_header *)((u_int8_t *)iframe + tmplen);\n\t\tiframe->i_fc[0] =\n\t\t    (IEEE80211_FC0_VERSION_0 | IEEE80211_FC0_TYPE_DATA);\n\t\tif (sc->sc_mode == SC_MODE_ADHOC) {\n\t\t\tiframe->i_fc[1] = IEEE80211_FC1_DIR_NODS;\n\t\t\tmemcpy(iframe->i_addr1, eh->ether_dhost,ETHER_ADDR_LEN);\n\t\t\tmemcpy(iframe->i_addr2, eh->ether_shost,ETHER_ADDR_LEN);\n\t\t\tmemcpy(iframe->i_addr3, sc->sc_bssid, ETHER_ADDR_LEN);\n\t\t} else {\n\t\t\tiframe->i_fc[1] = IEEE80211_FC1_DIR_TODS;\n\t\t\tmemcpy(iframe->i_addr1, sc->sc_bssid,ETHER_ADDR_LEN);\n\t\t\tmemcpy(iframe->i_addr2, eh->ether_shost,ETHER_ADDR_LEN);\n\t\t\tmemmove(iframe->i_addr3,eh->ether_dhost,ETHER_ADDR_LEN);\n\t\t}\n\t\tiframe->i_dur[0] = iframe->i_dur[1] = 0;\n\t\tiframe->i_seq[0] = iframe->i_seq[1] = 0;\n\n\t\t/* if not using crummy E2 in 802.11 make it LLC/SNAP */\n\t\tif ((ifp->if_flags & IFF_LINK0) == 0 && et > ETHERMTU)\n\t\t\tmemcpy(iframe + 1, llc_snapid, sizeof(llc_snapid));\n\n\t\tRAY_DPRINTF((\"%s: i %d previ %d\\n\", ifp->if_xname, i, previ));\n\n\t\tif (firsti == RAY_CCS_LINK_NULL)\n\t\t\tfirsti = i;\n\n\t\tpktlen = m0->m_pkthdr.len;\n\t\tbufp = ray_fill_in_tx_ccs(sc, pktlen, i, previ);\n\t\tprevi = hinti = i;\n\t\ti = RAY_CCS_LINK_NULL;\n\n\t\tRAY_DPRINTF((\"%s: bufp 0x%lx new pktlen %d\\n\",\n\t\t    ifp->if_xname, (long)bufp, (int)pktlen));\n\n\t\t/* copy out mbuf */\n\t\tfor (m = m0; m; m = m->m_next) {\n\t\t\tif ((len = m->m_len) == 0)\n\t\t\t\tcontinue;\n\t\t\tRAY_DPRINTF((\n\t\t\t    \"%s: copying mbuf 0x%lx bufp 0x%lx len %d\\n\",\n\t\t\t    ifp->if_xname, (long)m, (long)bufp, (int)len));\n\t\t\td = mtod(m, u_int8_t *);\n\t\t\tebufp = bufp + len;\n\t\t\tif (ebufp <= RAY_TX_END)\n\t\t\t\tray_write_region(sc, bufp, d, len);\n\t\t\telse {\n\t\t\t\tpanic(\"ray_intr_start\");\t/* XXX */\n\t\t\t\t/* wrapping */\n\t\t\t\ttmplen = ebufp - bufp;\n\t\t\t\tlen -= tmplen;\n\t\t\t\tray_write_region(sc, bufp, d, tmplen);\n\t\t\t\td += tmplen;\n\t\t\t\tbufp = RAY_TX_BASE;\n\t\t\t\tray_write_region(sc, bufp, d, len);\n\t\t\t}\n\t\t\tbufp += len;\n\t\t}\n#if NBPFILTER > 0\n\t\tif (ifp->if_bpf) {\n\t\t\tif (ifp->if_flags & IFF_LINK0) {\n\t\t\t\tm0->m_data += sizeof(struct ieee80211_frame);\n\t\t\t\tm0->m_len -=  sizeof(struct ieee80211_frame);\n\t\t\t\tm0->m_pkthdr.len -=  sizeof(struct ieee80211_frame);\n\t\t\t}\n\t\t\tbpf_mtap(ifp->if_bpf, m0);\n\t\t\tif (ifp->if_flags & IFF_LINK0) {\n\t\t\t\tm0->m_data -= sizeof(struct ieee80211_frame);\n\t\t\t\tm0->m_len +=  sizeof(struct ieee80211_frame);\n\t\t\t\tm0->m_pkthdr.len +=  sizeof(struct ieee80211_frame);\n\t\t\t}\n\t\t}\n#endif\n\n#ifdef RAY_DEBUG\n\t\tif (ray_debug && ray_debug_dump_tx)\n\t\t\tray_dump_mbuf(sc, m0);\n#endif\n\t\tpcount++;\n\t\tm_freem(m0);\n\t}\n\n\tif (firsti == RAY_CCS_LINK_NULL)\n\t\treturn;\n\ti = 0;\n\tif (!RAY_ECF_READY(sc)) {\n\t\t/*\n\t\t * if this can really happen perhaps we need to save\n\t\t * the chain and use it later.  I think this might\n\t\t * be a confused state though because we check above\n\t\t * and don't issue any commands between.\n\t\t */\n\t\tprintf(\"%s: dropping tx packets device busy\\n\", sc->sc_xname);\n\t\tray_free_ccs_chain(sc, firsti);\n\t\tifp->if_oerrors += pcount;\n\t\treturn;\n\t}\n\n\t/* send it off */\n\tRAY_DPRINTF((\"%s: ray_start issueing %d \\n\", sc->sc_xname, firsti));\n\tSRAM_WRITE_1(sc, RAY_SCB_CCSI, firsti);\n\tRAY_ECF_START_CMD(sc);\n\n\tRAY_DPRINTF_XMIT((\"%s: sent packet: len %lu\\n\", sc->sc_xname,\n\t    (u_long)pktlen));\n\n\tifp->if_opackets += pcount;\n}"
  },
  {
    "function_name": "ray_media_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
    "lines": "1209-1228",
    "snippet": "void\nray_media_status(ifp, imr)\n\tstruct ifnet *ifp;\n\tstruct ifmediareq *imr;\n{\n\tstruct ray_softc *sc;\n\n\tsc = ifp->if_softc;\n\n\tRAY_DPRINTF((\"%s: media status\\n\", ifp->if_xname));\n\n\timr->ifm_status = IFM_AVALID;\n\tif (sc->sc_havenet)\n\t\timr->ifm_status |= IFM_ACTIVE;\n\n\tif (sc->sc_mode == SC_MODE_ADHOC)\n\t\timr->ifm_active = IFM_ADHOC;\n\telse\n\t\timr->ifm_active = IFM_INFRA;\n}",
    "includes": [
      "#include <dev/pcmcia/if_rayreg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_llc.h>",
      "#include <net/if_media.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/timeout.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [
      "#define\tIFM_INFRA\t\\\n\tIFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_FH2, 0, 0)",
      "#define\tIFM_ADHOC\t\\\n\tIFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_FH2, IFM_IEEE80211_ADHOC, 0)",
      "#define\tSC_MODE_ADHOC\t0\t/* ad-hoc mode */"
    ],
    "globals_used": [
      "void ray_media_status"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: media status\\n\", ifp->if_xname)"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tIFM_INFRA\t\\\n\tIFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_FH2, 0, 0)\n#define\tIFM_ADHOC\t\\\n\tIFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_FH2, IFM_IEEE80211_ADHOC, 0)\n#define\tSC_MODE_ADHOC\t0\t/* ad-hoc mode */\n\nvoid ray_media_status;\n\nvoid\nray_media_status(ifp, imr)\n\tstruct ifnet *ifp;\n\tstruct ifmediareq *imr;\n{\n\tstruct ray_softc *sc;\n\n\tsc = ifp->if_softc;\n\n\tRAY_DPRINTF((\"%s: media status\\n\", ifp->if_xname));\n\n\timr->ifm_status = IFM_AVALID;\n\tif (sc->sc_havenet)\n\t\timr->ifm_status |= IFM_ACTIVE;\n\n\tif (sc->sc_mode == SC_MODE_ADHOC)\n\t\timr->ifm_active = IFM_ADHOC;\n\telse\n\t\timr->ifm_active = IFM_INFRA;\n}"
  },
  {
    "function_name": "ray_media_change",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
    "lines": "1191-1207",
    "snippet": "int\nray_media_change(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct ray_softc *sc;\n\n\tsc = ifp->if_softc;\n\tRAY_DPRINTF((\"%s: media change cur %d\\n\", ifp->if_xname,\n\t    sc->sc_media.ifm_cur->ifm_media));\n\tif (sc->sc_media.ifm_cur->ifm_media & IFM_IEEE80211_ADHOC)\n\t\tsc->sc_mode = SC_MODE_ADHOC;\n\telse\n\t\tsc->sc_mode = SC_MODE_INFRA;\n\tif (sc->sc_mode != sc->sc_omode)\n\t\tray_start_join_net(sc);\n\treturn (0);\n}",
    "includes": [
      "#include <dev/pcmcia/if_rayreg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_llc.h>",
      "#include <net/if_media.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/timeout.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [
      "#define\tSC_MODE_INFRA\t1\t/* infrastructure mode */",
      "#define\tSC_MODE_ADHOC\t0\t/* ad-hoc mode */"
    ],
    "globals_used": [
      "int ray_media_change",
      "void ray_start_join_net"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ray_start_join_net",
          "args": [
            "sc"
          ],
          "line": 1205
        },
        "resolved": true,
        "details": {
          "function_name": "ray_start_join_net_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2754-2840",
          "snippet": "ray_cmd_func_t\nray_start_join_net_done(sc, cmd, ccs, stat)\n\tstruct ray_softc *sc;\n\tu_int cmd;\n\tbus_size_t ccs;\n\tu_int stat;\n{\n\tstruct ray_net_params np;\n\n\tcallout_stop(&sc->sc_start_join_timo_ch);\n\tray_cmd_done(sc, SCP_UPD_STARTJOIN);\n\n\tif (stat == RAY_CCS_STATUS_FAIL) {\n\t\t/* XXX poke ifmedia when it supports this */\n\t\tsc->sc_havenet = 0;\n\t\treturn (ray_start_join_net);\n\t}\n\tif (stat == RAY_CCS_STATUS_BUSY || stat == RAY_CCS_STATUS_FREE) {\n\t\t/* handle the timeout condition */\n\t\tcallout_reset(&sc->sc_start_join_timo_ch, RAY_START_TIMEOUT,\n\t\t    ray_start_join_timo, sc);\n\n\t\t/* be safe -- not a lot occurs with no net though */\n\t\tif (!RAY_ECF_READY(sc))\n\t\t\treturn (0);\n\n\t\t/* see if our nwid is up to date */\n\t\tif (!memcmp(sc->sc_cnwid, sc->sc_dnwid, sizeof(sc->sc_cnwid))\n\t\t    && sc->sc_omode == sc->sc_mode)\n\t\t\tSRAM_WRITE_FIELD_1(sc,ccs, ray_cmd_net, c_upd_param, 0);\n\t\telse {\n\t\t\tmemset(&np, 0, sizeof(np));\n\t\t\tnp.p_net_type = sc->sc_mode;\n\t\t\tmemcpy(np.p_ssid, sc->sc_dnwid, sizeof(np.p_ssid));\n\t\t\tray_write_region(sc, RAY_HOST_TO_ECF_BASE, &np,\n\t\t\t    sizeof(np));\n\t\t\tSRAM_WRITE_FIELD_1(sc,ccs, ray_cmd_net, c_upd_param, 1);\n\t\t}\n\n\t\tif (sc->sc_mode == SC_MODE_ADHOC)\n\t\t\tcmd = RAY_CMD_START_NET;\n\t\telse\n\t\t\tcmd = RAY_CMD_JOIN_NET;\n\t\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_net, c_cmd,\n\t\t    RAY_CCS_STATUS_BUSY);\n\t\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_net, c_status,\n\t\t    RAY_CCS_STATUS_BUSY);\n\n\t\t/* we simply poke the card again issuing the same ccs */\n\t\tSRAM_WRITE_1(sc, RAY_SCB_CCSI, RAY_GET_INDEX(ccs));\n\t\tRAY_ECF_START_CMD(sc);\n\t\tray_cmd_ran(sc, SCP_UPD_STARTJOIN);\n\t\treturn (0);\n\t}\n\t/* get the current ssid */\n\tSRAM_READ_FIELD_N(sc, ccs, ray_cmd_net, c_bss_id, sc->sc_bssid,\n\t    sizeof(sc->sc_bssid));\n\n\tsc->sc_deftxrate = SRAM_READ_FIELD_1(sc, ccs, ray_cmd_net,c_def_txrate);\n\tsc->sc_encrypt = SRAM_READ_FIELD_1(sc, ccs, ray_cmd_net, c_encrypt);\n\n\t/* adjust values for buggy build 4 */\n\tif (sc->sc_deftxrate == 0x55)\n\t\tsc->sc_deftxrate = RAY_PID_BASIC_RATE_1500K;\n\tif (sc->sc_encrypt == 0x55)\n\t\tsc->sc_encrypt = 0;\n\n\tif (SRAM_READ_FIELD_1(sc, ccs, ray_cmd_net, c_upd_param)) {\n\t\tray_read_region(sc, RAY_HOST_TO_ECF_BASE, &np, sizeof(np));\n\t\tmemcpy(sc->sc_cnwid, np.p_ssid, sizeof(sc->sc_cnwid));\n\t\tsc->sc_omode = sc->sc_mode;\n\t\tif (np.p_net_type != sc->sc_mode)\n\t\t\treturn (ray_start_join_net);\n\t}\n\tRAY_DPRINTF((\"%s: net start/join nwid %.32s bssid %s inited %d\\n\",\n\t    sc->sc_xname, sc->sc_cnwid, ether_sprintf(sc->sc_bssid),\n\t\tSRAM_READ_FIELD_1(sc, ccs, ray_cmd_net, c_inited)));\n\n\t/* network is now active */\n\tray_cmd_schedule(sc, SCP_UPD_MCAST|SCP_UPD_PROMISC);\n\tif (cmd == RAY_CMD_JOIN_NET)\n\t\treturn (ray_start_assoc);\n\telse {\n\t\tsc->sc_havenet = 1;\n\t\treturn (ray_intr_start);\n\t}\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tSCP_UPD_MCAST\t\t0x0800",
            "#define\tSCP_UPD_PROMISC\t\t0x0400",
            "#define\tSCP_UPD_STARTJOIN\t0x0200",
            "#define\tSC_MODE_ADHOC\t0\t/* ad-hoc mode */",
            "#define\tsc_xname\tsc_dev.dv_xname",
            "#define\tcallout_stop\ttimeout_del",
            "#define\tRAY_START_TIMEOUT\t(10 * hz)"
          ],
          "globals_used": [
            "void ray_cmd_schedule",
            "void ray_cmd_ran",
            "void ray_cmd_done",
            "void ray_intr_start",
            "void ray_start_assoc",
            "void ray_start_join_net",
            "ray_cmd_func_t ray_start_join_net_done",
            "void ray_start_join_timo"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSCP_UPD_MCAST\t\t0x0800\n#define\tSCP_UPD_PROMISC\t\t0x0400\n#define\tSCP_UPD_STARTJOIN\t0x0200\n#define\tSC_MODE_ADHOC\t0\t/* ad-hoc mode */\n#define\tsc_xname\tsc_dev.dv_xname\n#define\tcallout_stop\ttimeout_del\n#define\tRAY_START_TIMEOUT\t(10 * hz)\n\nvoid ray_cmd_schedule;\nvoid ray_cmd_ran;\nvoid ray_cmd_done;\nvoid ray_intr_start;\nvoid ray_start_assoc;\nvoid ray_start_join_net;\nray_cmd_func_t ray_start_join_net_done;\nvoid ray_start_join_timo;\n\nray_cmd_func_t\nray_start_join_net_done(sc, cmd, ccs, stat)\n\tstruct ray_softc *sc;\n\tu_int cmd;\n\tbus_size_t ccs;\n\tu_int stat;\n{\n\tstruct ray_net_params np;\n\n\tcallout_stop(&sc->sc_start_join_timo_ch);\n\tray_cmd_done(sc, SCP_UPD_STARTJOIN);\n\n\tif (stat == RAY_CCS_STATUS_FAIL) {\n\t\t/* XXX poke ifmedia when it supports this */\n\t\tsc->sc_havenet = 0;\n\t\treturn (ray_start_join_net);\n\t}\n\tif (stat == RAY_CCS_STATUS_BUSY || stat == RAY_CCS_STATUS_FREE) {\n\t\t/* handle the timeout condition */\n\t\tcallout_reset(&sc->sc_start_join_timo_ch, RAY_START_TIMEOUT,\n\t\t    ray_start_join_timo, sc);\n\n\t\t/* be safe -- not a lot occurs with no net though */\n\t\tif (!RAY_ECF_READY(sc))\n\t\t\treturn (0);\n\n\t\t/* see if our nwid is up to date */\n\t\tif (!memcmp(sc->sc_cnwid, sc->sc_dnwid, sizeof(sc->sc_cnwid))\n\t\t    && sc->sc_omode == sc->sc_mode)\n\t\t\tSRAM_WRITE_FIELD_1(sc,ccs, ray_cmd_net, c_upd_param, 0);\n\t\telse {\n\t\t\tmemset(&np, 0, sizeof(np));\n\t\t\tnp.p_net_type = sc->sc_mode;\n\t\t\tmemcpy(np.p_ssid, sc->sc_dnwid, sizeof(np.p_ssid));\n\t\t\tray_write_region(sc, RAY_HOST_TO_ECF_BASE, &np,\n\t\t\t    sizeof(np));\n\t\t\tSRAM_WRITE_FIELD_1(sc,ccs, ray_cmd_net, c_upd_param, 1);\n\t\t}\n\n\t\tif (sc->sc_mode == SC_MODE_ADHOC)\n\t\t\tcmd = RAY_CMD_START_NET;\n\t\telse\n\t\t\tcmd = RAY_CMD_JOIN_NET;\n\t\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_net, c_cmd,\n\t\t    RAY_CCS_STATUS_BUSY);\n\t\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_net, c_status,\n\t\t    RAY_CCS_STATUS_BUSY);\n\n\t\t/* we simply poke the card again issuing the same ccs */\n\t\tSRAM_WRITE_1(sc, RAY_SCB_CCSI, RAY_GET_INDEX(ccs));\n\t\tRAY_ECF_START_CMD(sc);\n\t\tray_cmd_ran(sc, SCP_UPD_STARTJOIN);\n\t\treturn (0);\n\t}\n\t/* get the current ssid */\n\tSRAM_READ_FIELD_N(sc, ccs, ray_cmd_net, c_bss_id, sc->sc_bssid,\n\t    sizeof(sc->sc_bssid));\n\n\tsc->sc_deftxrate = SRAM_READ_FIELD_1(sc, ccs, ray_cmd_net,c_def_txrate);\n\tsc->sc_encrypt = SRAM_READ_FIELD_1(sc, ccs, ray_cmd_net, c_encrypt);\n\n\t/* adjust values for buggy build 4 */\n\tif (sc->sc_deftxrate == 0x55)\n\t\tsc->sc_deftxrate = RAY_PID_BASIC_RATE_1500K;\n\tif (sc->sc_encrypt == 0x55)\n\t\tsc->sc_encrypt = 0;\n\n\tif (SRAM_READ_FIELD_1(sc, ccs, ray_cmd_net, c_upd_param)) {\n\t\tray_read_region(sc, RAY_HOST_TO_ECF_BASE, &np, sizeof(np));\n\t\tmemcpy(sc->sc_cnwid, np.p_ssid, sizeof(sc->sc_cnwid));\n\t\tsc->sc_omode = sc->sc_mode;\n\t\tif (np.p_net_type != sc->sc_mode)\n\t\t\treturn (ray_start_join_net);\n\t}\n\tRAY_DPRINTF((\"%s: net start/join nwid %.32s bssid %s inited %d\\n\",\n\t    sc->sc_xname, sc->sc_cnwid, ether_sprintf(sc->sc_bssid),\n\t\tSRAM_READ_FIELD_1(sc, ccs, ray_cmd_net, c_inited)));\n\n\t/* network is now active */\n\tray_cmd_schedule(sc, SCP_UPD_MCAST|SCP_UPD_PROMISC);\n\tif (cmd == RAY_CMD_JOIN_NET)\n\t\treturn (ray_start_assoc);\n\telse {\n\t\tsc->sc_havenet = 1;\n\t\treturn (ray_intr_start);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: media change cur %d\\n\", ifp->if_xname,\n\t    sc->sc_media.ifm_cur->ifm_media)"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSC_MODE_INFRA\t1\t/* infrastructure mode */\n#define\tSC_MODE_ADHOC\t0\t/* ad-hoc mode */\n\nint ray_media_change;\nvoid ray_start_join_net;\n\nint\nray_media_change(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct ray_softc *sc;\n\n\tsc = ifp->if_softc;\n\tRAY_DPRINTF((\"%s: media change cur %d\\n\", ifp->if_xname,\n\t    sc->sc_media.ifm_cur->ifm_media));\n\tif (sc->sc_media.ifm_cur->ifm_media & IFM_IEEE80211_ADHOC)\n\t\tsc->sc_mode = SC_MODE_ADHOC;\n\telse\n\t\tsc->sc_mode = SC_MODE_INFRA;\n\tif (sc->sc_mode != sc->sc_omode)\n\t\tray_start_join_net(sc);\n\treturn (0);\n}"
  },
  {
    "function_name": "ray_if_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
    "lines": "1181-1189",
    "snippet": "void\nray_if_start(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct ray_softc *sc;\n\n\tsc = ifp->if_softc;\n\tray_intr_start(sc);\n}",
    "includes": [
      "#include <dev/pcmcia/if_rayreg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_llc.h>",
      "#include <net/if_media.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/timeout.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void ray_if_start",
      "void ray_intr_start"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ray_intr_start",
          "args": [
            "sc"
          ],
          "line": 1188
        },
        "resolved": true,
        "details": {
          "function_name": "ray_intr_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "1234-1441",
          "snippet": "void\nray_intr_start(sc)\n\tstruct ray_softc *sc;\n{\n\tstruct ieee80211_frame *iframe;\n\tstruct ether_header *eh;\n\tsize_t len, pktlen, tmplen;\n\tbus_size_t bufp, ebufp;\n\tstruct mbuf *m0, *m;\n\tstruct ifnet *ifp;\n\tu_int firsti, hinti, previ, i, pcount;\n\tu_int16_t et;\n\tu_int8_t *d;\n\n\tifp = &sc->sc_if;\n\n\tRAY_DPRINTF((\"%s: start free %d qlen %d qmax %d\\n\",\n\t    ifp->if_xname, sc->sc_txfree, ifp->if_snd.ifq_len,\n\t    ifp->if_snd.ifq_maxlen));\n\n\tray_cmd_cancel(sc, SCP_IFSTART);\n\n\tif ((ifp->if_flags & IFF_RUNNING) == 0 || !sc->sc_havenet)\n\t\treturn;\n\n\tif (ifp->if_snd.ifq_len == 0)\n\t\treturn;\n\n\tfirsti = i = previ = RAY_CCS_LINK_NULL;\n\thinti = RAY_CCS_TX_FIRST;\n\n\tif (!RAY_ECF_READY(sc)) {\n\t\tray_cmd_schedule(sc, SCP_IFSTART);\n\t\treturn;\n\t}\n\n\tpcount = 0;\n\tfor (;;) {\n\t\t/* if we have no descriptors be done */\n\t\tif (i == RAY_CCS_LINK_NULL) {\n\t\t\ti = ray_find_free_tx_ccs(sc, hinti);\n\t\t\tif (i == RAY_CCS_LINK_NULL) {\n\t\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tIF_DEQUEUE(&ifp->if_snd, m0);\n\t\tif (!m0)\n\t\t\tbreak;\n\t\tRAY_DPRINTF((\"%s: gotmbuf 0x%lx\\n\", ifp->if_xname, (long)m0));\n\t\tpktlen = m0->m_pkthdr.len;\n\t\tif (pktlen > ETHER_MAX_LEN - ETHER_CRC_LEN) {\n\t\t\tRAY_DPRINTF((\n\t\t\t    \"%s: mbuf too long %lu\\n\", ifp->if_xname,\n\t\t\t    (u_long)pktlen));\n\t\t\tifp->if_oerrors++;\n\t\t\tm_freem(m0);\n\t\t\tcontinue;\n\t\t}\n\t\tRAY_DPRINTF((\"%s: mbuf.m_pkthdr.len %d\\n\", ifp->if_xname,\n\t\t    (int)pktlen));\n\n\t\t/* we need the ether_header now for pktlen adjustments */\n\t\tM_PULLUP(m0, sizeof(struct ether_header));\n\t\tif (!m0) {\n\t\t\tRAY_DPRINTF(( \"%s: couldn\\'t pullup ether header\\n\",\n\t\t\t    ifp->if_xname));\n\t\t\tifp->if_oerrors++;\n\t\t\tcontinue;\n\t\t}\n\t\tRAY_DPRINTF((\"%s: got pulled up mbuf 0x%lx\\n\", ifp->if_xname,\n\t\t    (long)m0));\n\n\t\t/* first peek at the type of packet and figure out what to do */\n\t\teh = mtod(m0, struct ether_header *);\n\t\tet = ntohs(eh->ether_type);\n\t\tif (ifp->if_flags & IFF_LINK0) {\n\t\t\t/* don't support llc for windows compat operation */\n\t\t\tif (et <= ETHERMTU) {\n\t\t\t\tm_freem(m0);\n\t\t\t\tifp->if_oerrors++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttmplen = sizeof(struct ieee80211_frame);\n\t\t} else if (et > ETHERMTU) {\n\t\t\t/* adjust for LLC/SNAP header */\n\t\t\ttmplen= sizeof(struct ieee80211_frame) - ETHER_ADDR_LEN;\n\t\t}\n\t\t/* now get our space for the 802.11 frame */\n\t\tM_PREPEND(m0, tmplen, M_DONTWAIT);\n\t\tif (m0)\n\t\t\tM_PULLUP(m0, sizeof(struct ether_header) + tmplen);\n\t\tif (!m0) {\n\t\t\tRAY_DPRINTF((\"%s: couldn\\'t prepend header\\n\",\n\t\t\t    ifp->if_xname));\n\t\t\tifp->if_oerrors++;\n\t\t\tcontinue;\n\t\t}\n\t\t/* copy the frame into the mbuf for tapping */\n\t\tiframe = mtod(m0, struct ieee80211_frame *);\n\t\teh = (struct ether_header *)((u_int8_t *)iframe + tmplen);\n\t\tiframe->i_fc[0] =\n\t\t    (IEEE80211_FC0_VERSION_0 | IEEE80211_FC0_TYPE_DATA);\n\t\tif (sc->sc_mode == SC_MODE_ADHOC) {\n\t\t\tiframe->i_fc[1] = IEEE80211_FC1_DIR_NODS;\n\t\t\tmemcpy(iframe->i_addr1, eh->ether_dhost,ETHER_ADDR_LEN);\n\t\t\tmemcpy(iframe->i_addr2, eh->ether_shost,ETHER_ADDR_LEN);\n\t\t\tmemcpy(iframe->i_addr3, sc->sc_bssid, ETHER_ADDR_LEN);\n\t\t} else {\n\t\t\tiframe->i_fc[1] = IEEE80211_FC1_DIR_TODS;\n\t\t\tmemcpy(iframe->i_addr1, sc->sc_bssid,ETHER_ADDR_LEN);\n\t\t\tmemcpy(iframe->i_addr2, eh->ether_shost,ETHER_ADDR_LEN);\n\t\t\tmemmove(iframe->i_addr3,eh->ether_dhost,ETHER_ADDR_LEN);\n\t\t}\n\t\tiframe->i_dur[0] = iframe->i_dur[1] = 0;\n\t\tiframe->i_seq[0] = iframe->i_seq[1] = 0;\n\n\t\t/* if not using crummy E2 in 802.11 make it LLC/SNAP */\n\t\tif ((ifp->if_flags & IFF_LINK0) == 0 && et > ETHERMTU)\n\t\t\tmemcpy(iframe + 1, llc_snapid, sizeof(llc_snapid));\n\n\t\tRAY_DPRINTF((\"%s: i %d previ %d\\n\", ifp->if_xname, i, previ));\n\n\t\tif (firsti == RAY_CCS_LINK_NULL)\n\t\t\tfirsti = i;\n\n\t\tpktlen = m0->m_pkthdr.len;\n\t\tbufp = ray_fill_in_tx_ccs(sc, pktlen, i, previ);\n\t\tprevi = hinti = i;\n\t\ti = RAY_CCS_LINK_NULL;\n\n\t\tRAY_DPRINTF((\"%s: bufp 0x%lx new pktlen %d\\n\",\n\t\t    ifp->if_xname, (long)bufp, (int)pktlen));\n\n\t\t/* copy out mbuf */\n\t\tfor (m = m0; m; m = m->m_next) {\n\t\t\tif ((len = m->m_len) == 0)\n\t\t\t\tcontinue;\n\t\t\tRAY_DPRINTF((\n\t\t\t    \"%s: copying mbuf 0x%lx bufp 0x%lx len %d\\n\",\n\t\t\t    ifp->if_xname, (long)m, (long)bufp, (int)len));\n\t\t\td = mtod(m, u_int8_t *);\n\t\t\tebufp = bufp + len;\n\t\t\tif (ebufp <= RAY_TX_END)\n\t\t\t\tray_write_region(sc, bufp, d, len);\n\t\t\telse {\n\t\t\t\tpanic(\"ray_intr_start\");\t/* XXX */\n\t\t\t\t/* wrapping */\n\t\t\t\ttmplen = ebufp - bufp;\n\t\t\t\tlen -= tmplen;\n\t\t\t\tray_write_region(sc, bufp, d, tmplen);\n\t\t\t\td += tmplen;\n\t\t\t\tbufp = RAY_TX_BASE;\n\t\t\t\tray_write_region(sc, bufp, d, len);\n\t\t\t}\n\t\t\tbufp += len;\n\t\t}\n#if NBPFILTER > 0\n\t\tif (ifp->if_bpf) {\n\t\t\tif (ifp->if_flags & IFF_LINK0) {\n\t\t\t\tm0->m_data += sizeof(struct ieee80211_frame);\n\t\t\t\tm0->m_len -=  sizeof(struct ieee80211_frame);\n\t\t\t\tm0->m_pkthdr.len -=  sizeof(struct ieee80211_frame);\n\t\t\t}\n\t\t\tbpf_mtap(ifp->if_bpf, m0);\n\t\t\tif (ifp->if_flags & IFF_LINK0) {\n\t\t\t\tm0->m_data -= sizeof(struct ieee80211_frame);\n\t\t\t\tm0->m_len +=  sizeof(struct ieee80211_frame);\n\t\t\t\tm0->m_pkthdr.len +=  sizeof(struct ieee80211_frame);\n\t\t\t}\n\t\t}\n#endif\n\n#ifdef RAY_DEBUG\n\t\tif (ray_debug && ray_debug_dump_tx)\n\t\t\tray_dump_mbuf(sc, m0);\n#endif\n\t\tpcount++;\n\t\tm_freem(m0);\n\t}\n\n\tif (firsti == RAY_CCS_LINK_NULL)\n\t\treturn;\n\ti = 0;\n\tif (!RAY_ECF_READY(sc)) {\n\t\t/*\n\t\t * if this can really happen perhaps we need to save\n\t\t * the chain and use it later.  I think this might\n\t\t * be a confused state though because we check above\n\t\t * and don't issue any commands between.\n\t\t */\n\t\tprintf(\"%s: dropping tx packets device busy\\n\", sc->sc_xname);\n\t\tray_free_ccs_chain(sc, firsti);\n\t\tifp->if_oerrors += pcount;\n\t\treturn;\n\t}\n\n\t/* send it off */\n\tRAY_DPRINTF((\"%s: ray_start issueing %d \\n\", sc->sc_xname, firsti));\n\tSRAM_WRITE_1(sc, RAY_SCB_CCSI, firsti);\n\tRAY_ECF_START_CMD(sc);\n\n\tRAY_DPRINTF_XMIT((\"%s: sent packet: len %lu\\n\", sc->sc_xname,\n\t    (u_long)pktlen));\n\n\tifp->if_opackets += pcount;\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tSCP_IFSTART\t\t0x0008",
            "#define\tSC_MODE_ADHOC\t0\t/* ad-hoc mode */",
            "#define\tsc_xname\tsc_dev.dv_xname",
            "#define\tmemmove\t\tmemcpy\t\t/* XXX */",
            "#define\tsc_if\t\tsc_ec.ac_if",
            "#define\tsc_if\t\tsc_ec.ec_if",
            "#define\tETHER_MAX_LEN\t1518",
            "#define\tETHER_CRC_LEN\t4"
          ],
          "globals_used": [
            "bus_size_t ray_fill_in_tx_ccs",
            "void ray_cmd_cancel",
            "void ray_cmd_schedule",
            "u_int ray_find_free_tx_ccs",
            "void ray_free_ccs_chain",
            "void ray_intr_start",
            "static const u_int8_t llc_snapid[6] = { LLC_SNAP_LSAP, LLC_SNAP_LSAP, LLC_UI };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSCP_IFSTART\t\t0x0008\n#define\tSC_MODE_ADHOC\t0\t/* ad-hoc mode */\n#define\tsc_xname\tsc_dev.dv_xname\n#define\tmemmove\t\tmemcpy\t\t/* XXX */\n#define\tsc_if\t\tsc_ec.ac_if\n#define\tsc_if\t\tsc_ec.ec_if\n#define\tETHER_MAX_LEN\t1518\n#define\tETHER_CRC_LEN\t4\n\nbus_size_t ray_fill_in_tx_ccs;\nvoid ray_cmd_cancel;\nvoid ray_cmd_schedule;\nu_int ray_find_free_tx_ccs;\nvoid ray_free_ccs_chain;\nvoid ray_intr_start;\nstatic const u_int8_t llc_snapid[6] = { LLC_SNAP_LSAP, LLC_SNAP_LSAP, LLC_UI };\n\nvoid\nray_intr_start(sc)\n\tstruct ray_softc *sc;\n{\n\tstruct ieee80211_frame *iframe;\n\tstruct ether_header *eh;\n\tsize_t len, pktlen, tmplen;\n\tbus_size_t bufp, ebufp;\n\tstruct mbuf *m0, *m;\n\tstruct ifnet *ifp;\n\tu_int firsti, hinti, previ, i, pcount;\n\tu_int16_t et;\n\tu_int8_t *d;\n\n\tifp = &sc->sc_if;\n\n\tRAY_DPRINTF((\"%s: start free %d qlen %d qmax %d\\n\",\n\t    ifp->if_xname, sc->sc_txfree, ifp->if_snd.ifq_len,\n\t    ifp->if_snd.ifq_maxlen));\n\n\tray_cmd_cancel(sc, SCP_IFSTART);\n\n\tif ((ifp->if_flags & IFF_RUNNING) == 0 || !sc->sc_havenet)\n\t\treturn;\n\n\tif (ifp->if_snd.ifq_len == 0)\n\t\treturn;\n\n\tfirsti = i = previ = RAY_CCS_LINK_NULL;\n\thinti = RAY_CCS_TX_FIRST;\n\n\tif (!RAY_ECF_READY(sc)) {\n\t\tray_cmd_schedule(sc, SCP_IFSTART);\n\t\treturn;\n\t}\n\n\tpcount = 0;\n\tfor (;;) {\n\t\t/* if we have no descriptors be done */\n\t\tif (i == RAY_CCS_LINK_NULL) {\n\t\t\ti = ray_find_free_tx_ccs(sc, hinti);\n\t\t\tif (i == RAY_CCS_LINK_NULL) {\n\t\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tIF_DEQUEUE(&ifp->if_snd, m0);\n\t\tif (!m0)\n\t\t\tbreak;\n\t\tRAY_DPRINTF((\"%s: gotmbuf 0x%lx\\n\", ifp->if_xname, (long)m0));\n\t\tpktlen = m0->m_pkthdr.len;\n\t\tif (pktlen > ETHER_MAX_LEN - ETHER_CRC_LEN) {\n\t\t\tRAY_DPRINTF((\n\t\t\t    \"%s: mbuf too long %lu\\n\", ifp->if_xname,\n\t\t\t    (u_long)pktlen));\n\t\t\tifp->if_oerrors++;\n\t\t\tm_freem(m0);\n\t\t\tcontinue;\n\t\t}\n\t\tRAY_DPRINTF((\"%s: mbuf.m_pkthdr.len %d\\n\", ifp->if_xname,\n\t\t    (int)pktlen));\n\n\t\t/* we need the ether_header now for pktlen adjustments */\n\t\tM_PULLUP(m0, sizeof(struct ether_header));\n\t\tif (!m0) {\n\t\t\tRAY_DPRINTF(( \"%s: couldn\\'t pullup ether header\\n\",\n\t\t\t    ifp->if_xname));\n\t\t\tifp->if_oerrors++;\n\t\t\tcontinue;\n\t\t}\n\t\tRAY_DPRINTF((\"%s: got pulled up mbuf 0x%lx\\n\", ifp->if_xname,\n\t\t    (long)m0));\n\n\t\t/* first peek at the type of packet and figure out what to do */\n\t\teh = mtod(m0, struct ether_header *);\n\t\tet = ntohs(eh->ether_type);\n\t\tif (ifp->if_flags & IFF_LINK0) {\n\t\t\t/* don't support llc for windows compat operation */\n\t\t\tif (et <= ETHERMTU) {\n\t\t\t\tm_freem(m0);\n\t\t\t\tifp->if_oerrors++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttmplen = sizeof(struct ieee80211_frame);\n\t\t} else if (et > ETHERMTU) {\n\t\t\t/* adjust for LLC/SNAP header */\n\t\t\ttmplen= sizeof(struct ieee80211_frame) - ETHER_ADDR_LEN;\n\t\t}\n\t\t/* now get our space for the 802.11 frame */\n\t\tM_PREPEND(m0, tmplen, M_DONTWAIT);\n\t\tif (m0)\n\t\t\tM_PULLUP(m0, sizeof(struct ether_header) + tmplen);\n\t\tif (!m0) {\n\t\t\tRAY_DPRINTF((\"%s: couldn\\'t prepend header\\n\",\n\t\t\t    ifp->if_xname));\n\t\t\tifp->if_oerrors++;\n\t\t\tcontinue;\n\t\t}\n\t\t/* copy the frame into the mbuf for tapping */\n\t\tiframe = mtod(m0, struct ieee80211_frame *);\n\t\teh = (struct ether_header *)((u_int8_t *)iframe + tmplen);\n\t\tiframe->i_fc[0] =\n\t\t    (IEEE80211_FC0_VERSION_0 | IEEE80211_FC0_TYPE_DATA);\n\t\tif (sc->sc_mode == SC_MODE_ADHOC) {\n\t\t\tiframe->i_fc[1] = IEEE80211_FC1_DIR_NODS;\n\t\t\tmemcpy(iframe->i_addr1, eh->ether_dhost,ETHER_ADDR_LEN);\n\t\t\tmemcpy(iframe->i_addr2, eh->ether_shost,ETHER_ADDR_LEN);\n\t\t\tmemcpy(iframe->i_addr3, sc->sc_bssid, ETHER_ADDR_LEN);\n\t\t} else {\n\t\t\tiframe->i_fc[1] = IEEE80211_FC1_DIR_TODS;\n\t\t\tmemcpy(iframe->i_addr1, sc->sc_bssid,ETHER_ADDR_LEN);\n\t\t\tmemcpy(iframe->i_addr2, eh->ether_shost,ETHER_ADDR_LEN);\n\t\t\tmemmove(iframe->i_addr3,eh->ether_dhost,ETHER_ADDR_LEN);\n\t\t}\n\t\tiframe->i_dur[0] = iframe->i_dur[1] = 0;\n\t\tiframe->i_seq[0] = iframe->i_seq[1] = 0;\n\n\t\t/* if not using crummy E2 in 802.11 make it LLC/SNAP */\n\t\tif ((ifp->if_flags & IFF_LINK0) == 0 && et > ETHERMTU)\n\t\t\tmemcpy(iframe + 1, llc_snapid, sizeof(llc_snapid));\n\n\t\tRAY_DPRINTF((\"%s: i %d previ %d\\n\", ifp->if_xname, i, previ));\n\n\t\tif (firsti == RAY_CCS_LINK_NULL)\n\t\t\tfirsti = i;\n\n\t\tpktlen = m0->m_pkthdr.len;\n\t\tbufp = ray_fill_in_tx_ccs(sc, pktlen, i, previ);\n\t\tprevi = hinti = i;\n\t\ti = RAY_CCS_LINK_NULL;\n\n\t\tRAY_DPRINTF((\"%s: bufp 0x%lx new pktlen %d\\n\",\n\t\t    ifp->if_xname, (long)bufp, (int)pktlen));\n\n\t\t/* copy out mbuf */\n\t\tfor (m = m0; m; m = m->m_next) {\n\t\t\tif ((len = m->m_len) == 0)\n\t\t\t\tcontinue;\n\t\t\tRAY_DPRINTF((\n\t\t\t    \"%s: copying mbuf 0x%lx bufp 0x%lx len %d\\n\",\n\t\t\t    ifp->if_xname, (long)m, (long)bufp, (int)len));\n\t\t\td = mtod(m, u_int8_t *);\n\t\t\tebufp = bufp + len;\n\t\t\tif (ebufp <= RAY_TX_END)\n\t\t\t\tray_write_region(sc, bufp, d, len);\n\t\t\telse {\n\t\t\t\tpanic(\"ray_intr_start\");\t/* XXX */\n\t\t\t\t/* wrapping */\n\t\t\t\ttmplen = ebufp - bufp;\n\t\t\t\tlen -= tmplen;\n\t\t\t\tray_write_region(sc, bufp, d, tmplen);\n\t\t\t\td += tmplen;\n\t\t\t\tbufp = RAY_TX_BASE;\n\t\t\t\tray_write_region(sc, bufp, d, len);\n\t\t\t}\n\t\t\tbufp += len;\n\t\t}\n#if NBPFILTER > 0\n\t\tif (ifp->if_bpf) {\n\t\t\tif (ifp->if_flags & IFF_LINK0) {\n\t\t\t\tm0->m_data += sizeof(struct ieee80211_frame);\n\t\t\t\tm0->m_len -=  sizeof(struct ieee80211_frame);\n\t\t\t\tm0->m_pkthdr.len -=  sizeof(struct ieee80211_frame);\n\t\t\t}\n\t\t\tbpf_mtap(ifp->if_bpf, m0);\n\t\t\tif (ifp->if_flags & IFF_LINK0) {\n\t\t\t\tm0->m_data -= sizeof(struct ieee80211_frame);\n\t\t\t\tm0->m_len +=  sizeof(struct ieee80211_frame);\n\t\t\t\tm0->m_pkthdr.len +=  sizeof(struct ieee80211_frame);\n\t\t\t}\n\t\t}\n#endif\n\n#ifdef RAY_DEBUG\n\t\tif (ray_debug && ray_debug_dump_tx)\n\t\t\tray_dump_mbuf(sc, m0);\n#endif\n\t\tpcount++;\n\t\tm_freem(m0);\n\t}\n\n\tif (firsti == RAY_CCS_LINK_NULL)\n\t\treturn;\n\ti = 0;\n\tif (!RAY_ECF_READY(sc)) {\n\t\t/*\n\t\t * if this can really happen perhaps we need to save\n\t\t * the chain and use it later.  I think this might\n\t\t * be a confused state though because we check above\n\t\t * and don't issue any commands between.\n\t\t */\n\t\tprintf(\"%s: dropping tx packets device busy\\n\", sc->sc_xname);\n\t\tray_free_ccs_chain(sc, firsti);\n\t\tifp->if_oerrors += pcount;\n\t\treturn;\n\t}\n\n\t/* send it off */\n\tRAY_DPRINTF((\"%s: ray_start issueing %d \\n\", sc->sc_xname, firsti));\n\tSRAM_WRITE_1(sc, RAY_SCB_CCSI, firsti);\n\tRAY_ECF_START_CMD(sc);\n\n\tRAY_DPRINTF_XMIT((\"%s: sent packet: len %lu\\n\", sc->sc_xname,\n\t    (u_long)pktlen));\n\n\tifp->if_opackets += pcount;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\nvoid ray_if_start;\nvoid ray_intr_start;\n\nvoid\nray_if_start(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct ray_softc *sc;\n\n\tsc = ifp->if_softc;\n\tray_intr_start(sc);\n}"
  },
  {
    "function_name": "ray_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
    "lines": "1028-1176",
    "snippet": "int\nray_ioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tu_long cmd;\n\tcaddr_t data;\n{\n\tu_int8_t nwid[IEEE80211_NWID_LEN];\n\tstruct ray_param_req pr;\n\tstruct ray_softc *sc;\n\tstruct ifreq *ifr;\n\tstruct ifaddr *ifa;\n\tint error, error2, s;\n\n\tsc = ifp->if_softc;\n\terror = 0;\n\n\tifr = (struct ifreq *)data;\n\n\ts = splnet();\n\n\tRAY_DPRINTF((\"%s: ioctl: cmd 0x%lx data 0x%lx\\n\", ifp->if_xname,\n\t    cmd, (long)data));\n\n#ifdef __OpenBSD__\n\tif ((error = ether_ioctl(ifp, &sc->sc_ec, cmd, data)) > 0) {\n\t\tsplx(s);\n\t\treturn error;\n\t}\n#endif\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tRAY_DPRINTF((\"%s: ioctl: cmd SIOCSIFADDR\\n\", ifp->if_xname));\n\t\tif ((ifp->if_flags & IFF_RUNNING) == 0)\n\t\t\tif ((error = ray_enable(sc)))\n\t\t\t\tbreak;\n\t\tifp->if_flags |= IFF_UP;\n\t\tifa = (struct ifaddr *)data;\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n#ifdef __NetBSD__\n\t\t\tarp_ifinit(&sc->sc_if, ifa);\n#elif defined(__OpenBSD__)\n\t\t\tarp_ifinit(&sc->sc_ec, ifa);\n#endif\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase SIOCSIFFLAGS:\n\t\tRAY_DPRINTF((\"%s: ioctl: cmd SIOCSIFFLAGS\\n\", ifp->if_xname));\n\t\tif (ifp->if_flags & IFF_UP) {\n\t\t\tif ((ifp->if_flags & IFF_RUNNING) == 0) {\n\t\t\t\tif ((error = ray_enable(sc)))\n\t\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t\tray_update_promisc(sc);\n\t\t} else if (ifp->if_flags & IFF_RUNNING)\n\t\t\tray_disable(sc);\n\t\tbreak;\n\tcase SIOCADDMULTI:\n\t\tRAY_DPRINTF((\"%s: ioctl: cmd SIOCADDMULTI\\n\", ifp->if_xname));\n\tcase SIOCDELMULTI:\n\t\tif (cmd == SIOCDELMULTI)\n\t\t\tRAY_DPRINTF((\"%s: ioctl: cmd SIOCDELMULTI\\n\",\n\t\t\t    ifp->if_xname));\n\t\tif (cmd == SIOCADDMULTI)\n\t\t\terror = ether_addmulti(ifr, &sc->sc_ec);\n\t\telse\n\t\t\terror = ether_delmulti(ifr, &sc->sc_ec);\n\t\tif (error == ENETRESET) {\n\t\t\terror = 0;\n\t\t\tray_update_mcast(sc);\n\t\t}\n\t\tbreak;\n\tcase SIOCSIFMEDIA:\n\t\tRAY_DPRINTF((\"%s: ioctl: cmd SIOCSIFMEDIA\\n\", ifp->if_xname));\n\tcase SIOCGIFMEDIA:\n\t\tif (cmd == SIOCGIFMEDIA)\n\t\t\tRAY_DPRINTF((\"%s: ioctl: cmd SIOCGIFMEDIA\\n\",\n\t\t\t    ifp->if_xname));\n\t\terror = ifmedia_ioctl(ifp, ifr, &sc->sc_media, cmd);\n\t\tbreak;\n\tcase SIOCSRAYPARAM:\n\t\tRAY_DPRINTF((\"%s: ioctl: cmd SIOCSRAYPARAM\\n\", ifp->if_xname));\n\t\tif ((error = copyin(ifr->ifr_data, &pr, sizeof(pr))))\n\t\t\tbreak;\n\t\t/* disallow certain command that have another interface */\n\t\tswitch (pr.r_paramid) {\n\t\tcase RAY_PID_NET_TYPE:\t/* through media opt */\n\t\tcase RAY_PID_AP_STATUS:\t/* unsupported */\n\t\tcase RAY_PID_SSID:\t/* use SIOC80211[GS]NWID */\n\t\tcase RAY_PID_MAC_ADDR:\t/* XXX need interface? */\n\t\tcase RAY_PID_PROMISC:\t/* bpf */\n\t\t\terror = EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\terror = ray_user_update_params(sc, &pr);\n\t\terror2 = copyout(&pr, ifr->ifr_data, sizeof(pr));\n\t\terror = error2 ? error2 : error;\n\t\tbreak;\n\tcase SIOCGRAYPARAM:\n\t\tRAY_DPRINTF((\"%s: ioctl: cmd SIOCGRAYPARAM\\n\", ifp->if_xname));\n\t\tif ((error = copyin(ifr->ifr_data, &pr, sizeof(pr))))\n\t\t\tbreak;\n\t\terror = ray_user_report_params(sc, &pr);\n\t\terror2 = copyout(&pr, ifr->ifr_data, sizeof(pr));\n\t\terror = error2 ? error2 : error;\n\t\tbreak;\n\tcase SIOCS80211NWID:\n\t\tRAY_DPRINTF((\"%s: ioctl: cmd SIOCSNWID\\n\", ifp->if_xname));\n\t\t/*\n\t\t * if later people overwrite thats ok -- the latest version\n\t\t * will always get start/joined even if it was set by\n\t\t * a previous command\n\t\t */\n\t\tif ((error = copyin(ifr->ifr_data, nwid, sizeof(nwid))))\n\t\t\tbreak;\n\t\tif (!memcmp(sc->sc_dnwid, nwid, sizeof(nwid)))\n\t\t\tbreak;\n\t\tmemcpy(sc->sc_dnwid, nwid, sizeof(nwid));\n\t\tif (ifp->if_flags & IFF_RUNNING)\n\t\t\tray_start_join_net(sc);\n\t\tbreak;\n\tcase SIOCG80211NWID:\n\t\tRAY_DPRINTF((\"%s: ioctl: cmd SIOCHNWID\\n\", ifp->if_xname));\n\t\terror = copyout(sc->sc_cnwid, ifr->ifr_data,\n\t\t    IEEE80211_NWID_LEN);\n\t\tbreak;\n#ifdef RAY_DO_SIGLEV\n\t\terror = copyout(sc->sc_siglevs, ifr->ifr_data,\n\t\t\t    sizeof sc->sc_siglevs);\n\t\tbreak;\n#endif\n\tdefault:\n\t\tRAY_DPRINTF((\"%s: ioctl: unknown\\n\", ifp->if_xname));\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\tRAY_DPRINTF((\"%s: ioctl: returns %d\\n\", ifp->if_xname, error));\n\n\tsplx(s);\n\n\treturn (error);\n}",
    "includes": [
      "#include <dev/pcmcia/if_rayreg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_llc.h>",
      "#include <net/if_media.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/timeout.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [
      "#define\tsc_if\t\tsc_ec.ac_if",
      "#define\tsc_if\t\tsc_ec.ec_if"
    ],
    "globals_used": [
      "void ray_disable",
      "int ray_enable",
      "int ray_ioctl",
      "void ray_start_join_net",
      "void ray_update_mcast",
      "void ray_update_promisc",
      "int ray_user_report_params",
      "int ray_user_update_params"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: ioctl: returns %d\\n\", ifp->if_xname, error)"
          ],
          "line": 1171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: ioctl: unknown\\n\", ifp->if_xname)"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copyout",
          "args": [
            "sc->sc_siglevs",
            "ifr->ifr_data",
            "sizeof sc->sc_siglevs"
          ],
          "line": 1161
        },
        "resolved": true,
        "details": {
          "function_name": "audio_silence_copyout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "1249-1268",
          "snippet": "int\naudio_silence_copyout(sc, n, uio)\n\tstruct audio_softc *sc;\n\tint n;\n\tstruct uio *uio;\n{\n\tint error;\n\tint k;\n\tu_char zerobuf[128];\n\n\taudio_fill_silence(&sc->sc_rparams, zerobuf, sizeof zerobuf);\n\n\terror = 0;\n        while (n > 0 && uio->uio_resid > 0 && !error) {\n\t\tk = min(n, min(uio->uio_resid, sizeof zerobuf));\n\t\terror = uiomove(zerobuf, k, uio);\n\t\tn -= k;\n\t}\n        return (error);\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\naudio_silence_copyout(sc, n, uio)\n\tstruct audio_softc *sc;\n\tint n;\n\tstruct uio *uio;\n{\n\tint error;\n\tint k;\n\tu_char zerobuf[128];\n\n\taudio_fill_silence(&sc->sc_rparams, zerobuf, sizeof zerobuf);\n\n\terror = 0;\n        while (n > 0 && uio->uio_resid > 0 && !error) {\n\t\tk = min(n, min(uio->uio_resid, sizeof zerobuf));\n\t\terror = uiomove(zerobuf, k, uio);\n\t\tn -= k;\n\t}\n        return (error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: ioctl: cmd SIOCHNWID\\n\", ifp->if_xname)"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ray_start_join_net",
          "args": [
            "sc"
          ],
          "line": 1153
        },
        "resolved": true,
        "details": {
          "function_name": "ray_start_join_net_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2754-2840",
          "snippet": "ray_cmd_func_t\nray_start_join_net_done(sc, cmd, ccs, stat)\n\tstruct ray_softc *sc;\n\tu_int cmd;\n\tbus_size_t ccs;\n\tu_int stat;\n{\n\tstruct ray_net_params np;\n\n\tcallout_stop(&sc->sc_start_join_timo_ch);\n\tray_cmd_done(sc, SCP_UPD_STARTJOIN);\n\n\tif (stat == RAY_CCS_STATUS_FAIL) {\n\t\t/* XXX poke ifmedia when it supports this */\n\t\tsc->sc_havenet = 0;\n\t\treturn (ray_start_join_net);\n\t}\n\tif (stat == RAY_CCS_STATUS_BUSY || stat == RAY_CCS_STATUS_FREE) {\n\t\t/* handle the timeout condition */\n\t\tcallout_reset(&sc->sc_start_join_timo_ch, RAY_START_TIMEOUT,\n\t\t    ray_start_join_timo, sc);\n\n\t\t/* be safe -- not a lot occurs with no net though */\n\t\tif (!RAY_ECF_READY(sc))\n\t\t\treturn (0);\n\n\t\t/* see if our nwid is up to date */\n\t\tif (!memcmp(sc->sc_cnwid, sc->sc_dnwid, sizeof(sc->sc_cnwid))\n\t\t    && sc->sc_omode == sc->sc_mode)\n\t\t\tSRAM_WRITE_FIELD_1(sc,ccs, ray_cmd_net, c_upd_param, 0);\n\t\telse {\n\t\t\tmemset(&np, 0, sizeof(np));\n\t\t\tnp.p_net_type = sc->sc_mode;\n\t\t\tmemcpy(np.p_ssid, sc->sc_dnwid, sizeof(np.p_ssid));\n\t\t\tray_write_region(sc, RAY_HOST_TO_ECF_BASE, &np,\n\t\t\t    sizeof(np));\n\t\t\tSRAM_WRITE_FIELD_1(sc,ccs, ray_cmd_net, c_upd_param, 1);\n\t\t}\n\n\t\tif (sc->sc_mode == SC_MODE_ADHOC)\n\t\t\tcmd = RAY_CMD_START_NET;\n\t\telse\n\t\t\tcmd = RAY_CMD_JOIN_NET;\n\t\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_net, c_cmd,\n\t\t    RAY_CCS_STATUS_BUSY);\n\t\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_net, c_status,\n\t\t    RAY_CCS_STATUS_BUSY);\n\n\t\t/* we simply poke the card again issuing the same ccs */\n\t\tSRAM_WRITE_1(sc, RAY_SCB_CCSI, RAY_GET_INDEX(ccs));\n\t\tRAY_ECF_START_CMD(sc);\n\t\tray_cmd_ran(sc, SCP_UPD_STARTJOIN);\n\t\treturn (0);\n\t}\n\t/* get the current ssid */\n\tSRAM_READ_FIELD_N(sc, ccs, ray_cmd_net, c_bss_id, sc->sc_bssid,\n\t    sizeof(sc->sc_bssid));\n\n\tsc->sc_deftxrate = SRAM_READ_FIELD_1(sc, ccs, ray_cmd_net,c_def_txrate);\n\tsc->sc_encrypt = SRAM_READ_FIELD_1(sc, ccs, ray_cmd_net, c_encrypt);\n\n\t/* adjust values for buggy build 4 */\n\tif (sc->sc_deftxrate == 0x55)\n\t\tsc->sc_deftxrate = RAY_PID_BASIC_RATE_1500K;\n\tif (sc->sc_encrypt == 0x55)\n\t\tsc->sc_encrypt = 0;\n\n\tif (SRAM_READ_FIELD_1(sc, ccs, ray_cmd_net, c_upd_param)) {\n\t\tray_read_region(sc, RAY_HOST_TO_ECF_BASE, &np, sizeof(np));\n\t\tmemcpy(sc->sc_cnwid, np.p_ssid, sizeof(sc->sc_cnwid));\n\t\tsc->sc_omode = sc->sc_mode;\n\t\tif (np.p_net_type != sc->sc_mode)\n\t\t\treturn (ray_start_join_net);\n\t}\n\tRAY_DPRINTF((\"%s: net start/join nwid %.32s bssid %s inited %d\\n\",\n\t    sc->sc_xname, sc->sc_cnwid, ether_sprintf(sc->sc_bssid),\n\t\tSRAM_READ_FIELD_1(sc, ccs, ray_cmd_net, c_inited)));\n\n\t/* network is now active */\n\tray_cmd_schedule(sc, SCP_UPD_MCAST|SCP_UPD_PROMISC);\n\tif (cmd == RAY_CMD_JOIN_NET)\n\t\treturn (ray_start_assoc);\n\telse {\n\t\tsc->sc_havenet = 1;\n\t\treturn (ray_intr_start);\n\t}\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tSCP_UPD_MCAST\t\t0x0800",
            "#define\tSCP_UPD_PROMISC\t\t0x0400",
            "#define\tSCP_UPD_STARTJOIN\t0x0200",
            "#define\tSC_MODE_ADHOC\t0\t/* ad-hoc mode */",
            "#define\tsc_xname\tsc_dev.dv_xname",
            "#define\tcallout_stop\ttimeout_del",
            "#define\tRAY_START_TIMEOUT\t(10 * hz)"
          ],
          "globals_used": [
            "void ray_cmd_schedule",
            "void ray_cmd_ran",
            "void ray_cmd_done",
            "void ray_intr_start",
            "void ray_start_assoc",
            "void ray_start_join_net",
            "ray_cmd_func_t ray_start_join_net_done",
            "void ray_start_join_timo"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSCP_UPD_MCAST\t\t0x0800\n#define\tSCP_UPD_PROMISC\t\t0x0400\n#define\tSCP_UPD_STARTJOIN\t0x0200\n#define\tSC_MODE_ADHOC\t0\t/* ad-hoc mode */\n#define\tsc_xname\tsc_dev.dv_xname\n#define\tcallout_stop\ttimeout_del\n#define\tRAY_START_TIMEOUT\t(10 * hz)\n\nvoid ray_cmd_schedule;\nvoid ray_cmd_ran;\nvoid ray_cmd_done;\nvoid ray_intr_start;\nvoid ray_start_assoc;\nvoid ray_start_join_net;\nray_cmd_func_t ray_start_join_net_done;\nvoid ray_start_join_timo;\n\nray_cmd_func_t\nray_start_join_net_done(sc, cmd, ccs, stat)\n\tstruct ray_softc *sc;\n\tu_int cmd;\n\tbus_size_t ccs;\n\tu_int stat;\n{\n\tstruct ray_net_params np;\n\n\tcallout_stop(&sc->sc_start_join_timo_ch);\n\tray_cmd_done(sc, SCP_UPD_STARTJOIN);\n\n\tif (stat == RAY_CCS_STATUS_FAIL) {\n\t\t/* XXX poke ifmedia when it supports this */\n\t\tsc->sc_havenet = 0;\n\t\treturn (ray_start_join_net);\n\t}\n\tif (stat == RAY_CCS_STATUS_BUSY || stat == RAY_CCS_STATUS_FREE) {\n\t\t/* handle the timeout condition */\n\t\tcallout_reset(&sc->sc_start_join_timo_ch, RAY_START_TIMEOUT,\n\t\t    ray_start_join_timo, sc);\n\n\t\t/* be safe -- not a lot occurs with no net though */\n\t\tif (!RAY_ECF_READY(sc))\n\t\t\treturn (0);\n\n\t\t/* see if our nwid is up to date */\n\t\tif (!memcmp(sc->sc_cnwid, sc->sc_dnwid, sizeof(sc->sc_cnwid))\n\t\t    && sc->sc_omode == sc->sc_mode)\n\t\t\tSRAM_WRITE_FIELD_1(sc,ccs, ray_cmd_net, c_upd_param, 0);\n\t\telse {\n\t\t\tmemset(&np, 0, sizeof(np));\n\t\t\tnp.p_net_type = sc->sc_mode;\n\t\t\tmemcpy(np.p_ssid, sc->sc_dnwid, sizeof(np.p_ssid));\n\t\t\tray_write_region(sc, RAY_HOST_TO_ECF_BASE, &np,\n\t\t\t    sizeof(np));\n\t\t\tSRAM_WRITE_FIELD_1(sc,ccs, ray_cmd_net, c_upd_param, 1);\n\t\t}\n\n\t\tif (sc->sc_mode == SC_MODE_ADHOC)\n\t\t\tcmd = RAY_CMD_START_NET;\n\t\telse\n\t\t\tcmd = RAY_CMD_JOIN_NET;\n\t\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_net, c_cmd,\n\t\t    RAY_CCS_STATUS_BUSY);\n\t\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_net, c_status,\n\t\t    RAY_CCS_STATUS_BUSY);\n\n\t\t/* we simply poke the card again issuing the same ccs */\n\t\tSRAM_WRITE_1(sc, RAY_SCB_CCSI, RAY_GET_INDEX(ccs));\n\t\tRAY_ECF_START_CMD(sc);\n\t\tray_cmd_ran(sc, SCP_UPD_STARTJOIN);\n\t\treturn (0);\n\t}\n\t/* get the current ssid */\n\tSRAM_READ_FIELD_N(sc, ccs, ray_cmd_net, c_bss_id, sc->sc_bssid,\n\t    sizeof(sc->sc_bssid));\n\n\tsc->sc_deftxrate = SRAM_READ_FIELD_1(sc, ccs, ray_cmd_net,c_def_txrate);\n\tsc->sc_encrypt = SRAM_READ_FIELD_1(sc, ccs, ray_cmd_net, c_encrypt);\n\n\t/* adjust values for buggy build 4 */\n\tif (sc->sc_deftxrate == 0x55)\n\t\tsc->sc_deftxrate = RAY_PID_BASIC_RATE_1500K;\n\tif (sc->sc_encrypt == 0x55)\n\t\tsc->sc_encrypt = 0;\n\n\tif (SRAM_READ_FIELD_1(sc, ccs, ray_cmd_net, c_upd_param)) {\n\t\tray_read_region(sc, RAY_HOST_TO_ECF_BASE, &np, sizeof(np));\n\t\tmemcpy(sc->sc_cnwid, np.p_ssid, sizeof(sc->sc_cnwid));\n\t\tsc->sc_omode = sc->sc_mode;\n\t\tif (np.p_net_type != sc->sc_mode)\n\t\t\treturn (ray_start_join_net);\n\t}\n\tRAY_DPRINTF((\"%s: net start/join nwid %.32s bssid %s inited %d\\n\",\n\t    sc->sc_xname, sc->sc_cnwid, ether_sprintf(sc->sc_bssid),\n\t\tSRAM_READ_FIELD_1(sc, ccs, ray_cmd_net, c_inited)));\n\n\t/* network is now active */\n\tray_cmd_schedule(sc, SCP_UPD_MCAST|SCP_UPD_PROMISC);\n\tif (cmd == RAY_CMD_JOIN_NET)\n\t\treturn (ray_start_assoc);\n\telse {\n\t\tsc->sc_havenet = 1;\n\t\treturn (ray_intr_start);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sc->sc_dnwid",
            "nwid",
            "sizeof(nwid)"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "sc->sc_dnwid",
            "nwid",
            "sizeof(nwid)"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copyin",
          "args": [
            "ifr->ifr_data",
            "nwid",
            "sizeof(nwid)"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: ioctl: cmd SIOCSNWID\\n\", ifp->if_xname)"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ray_user_report_params",
          "args": [
            "sc",
            "&pr"
          ],
          "line": 1136
        },
        "resolved": true,
        "details": {
          "function_name": "ray_user_report_params",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "3019-3054",
          "snippet": "int\nray_user_report_params(sc, pr)\n\tstruct ray_softc *sc;\n\tstruct ray_param_req *pr;\n{\n\tint rv;\n\n\tif ((sc->sc_if.if_flags & IFF_RUNNING) == 0) {\n\t\tpr->r_failcause = RAY_FAILCAUSE_EDEVSTOP;\n\t\treturn (EIO);\n\t}\n\n\t/* wait to be able to issue the command */\n\trv = 0;\n\twhile (ray_cmd_is_running(sc, SCP_REPORTPARAMS)\n\t    || ray_cmd_is_scheduled(sc, SCP_REPORTPARAMS)) {\n\t\trv = tsleep(ray_report_params, 0|PCATCH, \"cmd in use\", 0);\n\t\tif (rv)\n\t\t\treturn (rv);\n\t\tif ((sc->sc_if.if_flags & IFF_RUNNING) == 0) {\n\t\t\tpr->r_failcause = RAY_FAILCAUSE_EDEVSTOP;\n\t\t\treturn (EIO);\n\t\t}\n\t}\n\n\tpr->r_failcause = RAY_FAILCAUSE_WAITING;\n\tsc->sc_repreq = pr;\n\tray_cmd_schedule(sc, SCP_REPORTPARAMS);\n\tray_check_scheduled(sc);\n\n\twhile (pr->r_failcause == RAY_FAILCAUSE_WAITING)\n\t\t(void)tsleep(ray_report_params, 0, \"waiting cmd\", 0);\n\twakeup(ray_report_params);\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tSCP_REPORTPARAMS\t0x0004",
            "#define\tsc_if\t\tsc_ec.ac_if",
            "#define\tsc_if\t\tsc_ec.ec_if"
          ],
          "globals_used": [
            "void ray_check_scheduled",
            "void ray_cmd_schedule",
            "int ray_cmd_is_running",
            "int ray_cmd_is_scheduled",
            "void ray_report_params",
            "int ray_user_report_params"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSCP_REPORTPARAMS\t0x0004\n#define\tsc_if\t\tsc_ec.ac_if\n#define\tsc_if\t\tsc_ec.ec_if\n\nvoid ray_check_scheduled;\nvoid ray_cmd_schedule;\nint ray_cmd_is_running;\nint ray_cmd_is_scheduled;\nvoid ray_report_params;\nint ray_user_report_params;\n\nint\nray_user_report_params(sc, pr)\n\tstruct ray_softc *sc;\n\tstruct ray_param_req *pr;\n{\n\tint rv;\n\n\tif ((sc->sc_if.if_flags & IFF_RUNNING) == 0) {\n\t\tpr->r_failcause = RAY_FAILCAUSE_EDEVSTOP;\n\t\treturn (EIO);\n\t}\n\n\t/* wait to be able to issue the command */\n\trv = 0;\n\twhile (ray_cmd_is_running(sc, SCP_REPORTPARAMS)\n\t    || ray_cmd_is_scheduled(sc, SCP_REPORTPARAMS)) {\n\t\trv = tsleep(ray_report_params, 0|PCATCH, \"cmd in use\", 0);\n\t\tif (rv)\n\t\t\treturn (rv);\n\t\tif ((sc->sc_if.if_flags & IFF_RUNNING) == 0) {\n\t\t\tpr->r_failcause = RAY_FAILCAUSE_EDEVSTOP;\n\t\t\treturn (EIO);\n\t\t}\n\t}\n\n\tpr->r_failcause = RAY_FAILCAUSE_WAITING;\n\tsc->sc_repreq = pr;\n\tray_cmd_schedule(sc, SCP_REPORTPARAMS);\n\tray_check_scheduled(sc);\n\n\twhile (pr->r_failcause == RAY_FAILCAUSE_WAITING)\n\t\t(void)tsleep(ray_report_params, 0, \"waiting cmd\", 0);\n\twakeup(ray_report_params);\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copyin",
          "args": [
            "ifr->ifr_data",
            "&pr",
            "sizeof(pr)"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: ioctl: cmd SIOCGRAYPARAM\\n\", ifp->if_xname)"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ray_user_update_params",
          "args": [
            "sc",
            "&pr"
          ],
          "line": 1128
        },
        "resolved": true,
        "details": {
          "function_name": "ray_user_update_params",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2977-3012",
          "snippet": "int\nray_user_update_params(sc, pr)\n\tstruct ray_softc *sc;\n\tstruct ray_param_req *pr;\n{\n\tint rv;\n\n\tif ((sc->sc_if.if_flags & IFF_RUNNING) == 0) {\n\t\tpr->r_failcause = RAY_FAILCAUSE_EDEVSTOP;\n\t\treturn (EIO);\n\t}\n\n\t/* wait to be able to issue the command */\n\trv = 0;\n\twhile (ray_cmd_is_running(sc, SCP_UPD_UPDATEPARAMS) ||\n\t    ray_cmd_is_scheduled(sc, SCP_UPD_UPDATEPARAMS)) {\n\t\trv = tsleep(ray_update_params, 0|PCATCH, \"cmd in use\", 0);\n\t\tif (rv)\n\t\t\treturn (rv);\n\t\tif ((sc->sc_if.if_flags & IFF_RUNNING) == 0) {\n\t\t\tpr->r_failcause = RAY_FAILCAUSE_EDEVSTOP;\n\t\t\treturn (EIO);\n\t\t}\n\t}\n\n\tpr->r_failcause = RAY_FAILCAUSE_WAITING;\n\tsc->sc_updreq = pr;\n\tray_cmd_schedule(sc, SCP_UPD_UPDATEPARAMS);\n\tray_check_scheduled(sc);\n\n\twhile (pr->r_failcause == RAY_FAILCAUSE_WAITING)\n\t\t(void)tsleep(ray_update_params, 0, \"waiting cmd\", 0);\n\twakeup(ray_update_params);\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tSCP_UPD_UPDATEPARAMS\t0x1000",
            "#define\tsc_if\t\tsc_ec.ac_if",
            "#define\tsc_if\t\tsc_ec.ec_if"
          ],
          "globals_used": [
            "void ray_check_scheduled",
            "void ray_cmd_schedule",
            "int ray_cmd_is_running",
            "int ray_cmd_is_scheduled",
            "void ray_update_params",
            "int ray_user_update_params"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSCP_UPD_UPDATEPARAMS\t0x1000\n#define\tsc_if\t\tsc_ec.ac_if\n#define\tsc_if\t\tsc_ec.ec_if\n\nvoid ray_check_scheduled;\nvoid ray_cmd_schedule;\nint ray_cmd_is_running;\nint ray_cmd_is_scheduled;\nvoid ray_update_params;\nint ray_user_update_params;\n\nint\nray_user_update_params(sc, pr)\n\tstruct ray_softc *sc;\n\tstruct ray_param_req *pr;\n{\n\tint rv;\n\n\tif ((sc->sc_if.if_flags & IFF_RUNNING) == 0) {\n\t\tpr->r_failcause = RAY_FAILCAUSE_EDEVSTOP;\n\t\treturn (EIO);\n\t}\n\n\t/* wait to be able to issue the command */\n\trv = 0;\n\twhile (ray_cmd_is_running(sc, SCP_UPD_UPDATEPARAMS) ||\n\t    ray_cmd_is_scheduled(sc, SCP_UPD_UPDATEPARAMS)) {\n\t\trv = tsleep(ray_update_params, 0|PCATCH, \"cmd in use\", 0);\n\t\tif (rv)\n\t\t\treturn (rv);\n\t\tif ((sc->sc_if.if_flags & IFF_RUNNING) == 0) {\n\t\t\tpr->r_failcause = RAY_FAILCAUSE_EDEVSTOP;\n\t\t\treturn (EIO);\n\t\t}\n\t}\n\n\tpr->r_failcause = RAY_FAILCAUSE_WAITING;\n\tsc->sc_updreq = pr;\n\tray_cmd_schedule(sc, SCP_UPD_UPDATEPARAMS);\n\tray_check_scheduled(sc);\n\n\twhile (pr->r_failcause == RAY_FAILCAUSE_WAITING)\n\t\t(void)tsleep(ray_update_params, 0, \"waiting cmd\", 0);\n\twakeup(ray_update_params);\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copyin",
          "args": [
            "ifr->ifr_data",
            "&pr",
            "sizeof(pr)"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: ioctl: cmd SIOCSRAYPARAM\\n\", ifp->if_xname)"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_ioctl",
          "args": [
            "ifp",
            "ifr",
            "&sc->sc_media",
            "cmd"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: ioctl: cmd SIOCGIFMEDIA\\n\",\n\t\t\t    ifp->if_xname)"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: ioctl: cmd SIOCSIFMEDIA\\n\", ifp->if_xname)"
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ray_update_mcast",
          "args": [
            "sc"
          ],
          "line": 1103
        },
        "resolved": true,
        "details": {
          "function_name": "ray_update_mcast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2908-2966",
          "snippet": "void\nray_update_mcast(sc)\n\tstruct ray_softc *sc;\n{\n\tbus_size_t ccs;\n\tstruct ether_multistep step;\n\tstruct ether_multi *enm;\n#ifdef __NetBSD__\n\tstruct ethercom *ec;\n#elif defined(__OpenBSD__)\n\tstruct arpcom *ec;\n#endif\n\tbus_size_t bufp;\n\tint count;\n\n\tec = &sc->sc_ec;\n\tray_cmd_cancel(sc, SCP_UPD_MCAST);\n\n\t/* see if we have any ranges */\n\tif ((count = sc->sc_ec.ec_multicnt) < 17) {\n\t\tETHER_FIRST_MULTI(step, ec, enm);\n\t\twhile (enm) {\n\t\t\t/* see if this is a range */\n\t\t\tif (memcmp(enm->enm_addrlo, enm->enm_addrhi,\n\t\t\t\tETHER_ADDR_LEN)) {\n\t\t\t\tcount = 17;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tETHER_NEXT_MULTI(step, enm);\n\t\t}\n\t}\n\n\t/* track this stuff even when not running */\n\tif (count > 16) {\n\t\tsc->sc_if.if_flags |= IFF_ALLMULTI;\n\t\tray_update_promisc(sc);\n\t\treturn;\n\t} else if (sc->sc_if.if_flags & IFF_ALLMULTI) {\n\t\tsc->sc_if.if_flags &= ~IFF_ALLMULTI;\n\t\tray_update_promisc(sc);\n\t}\n\n\tif ((sc->sc_if.if_flags & IFF_RUNNING) == 0)\n\t\treturn;\n\telse if (ray_cmd_is_running(sc, SCP_UPDATESUBCMD)) {\n\t\tray_cmd_schedule(sc, SCP_UPD_MCAST);\n\t\treturn;\n\t} else if (!ray_alloc_ccs(sc,&ccs, RAY_CMD_UPDATE_MCAST, SCP_UPD_MCAST))\n\t\treturn;\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_update_mcast, c_nmcast, count);\n\tbufp = RAY_HOST_TO_ECF_BASE;\n\tETHER_FIRST_MULTI(step, ec, enm);\n\twhile (enm) {\n\t\tray_write_region(sc, bufp, enm->enm_addrlo, ETHER_ADDR_LEN);\n\t\tbufp += ETHER_ADDR_LEN;\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\t(void)ray_issue_cmd(sc, ccs, SCP_UPD_MCAST);\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tSCP_UPD_MCAST\t\t0x0800",
            "#define\tSCP_UPDATESUBCMD\t0x0001",
            "#define\tec_multicnt\tac_multicnt",
            "#define\tsc_if\t\tsc_ec.ac_if",
            "#define\tsc_if\t\tsc_ec.ec_if"
          ],
          "globals_used": [
            "int ray_alloc_ccs",
            "void ray_cmd_cancel",
            "void ray_cmd_schedule",
            "int ray_cmd_is_running",
            "int ray_issue_cmd",
            "void ray_update_mcast",
            "void ray_update_promisc"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSCP_UPD_MCAST\t\t0x0800\n#define\tSCP_UPDATESUBCMD\t0x0001\n#define\tec_multicnt\tac_multicnt\n#define\tsc_if\t\tsc_ec.ac_if\n#define\tsc_if\t\tsc_ec.ec_if\n\nint ray_alloc_ccs;\nvoid ray_cmd_cancel;\nvoid ray_cmd_schedule;\nint ray_cmd_is_running;\nint ray_issue_cmd;\nvoid ray_update_mcast;\nvoid ray_update_promisc;\n\nvoid\nray_update_mcast(sc)\n\tstruct ray_softc *sc;\n{\n\tbus_size_t ccs;\n\tstruct ether_multistep step;\n\tstruct ether_multi *enm;\n#ifdef __NetBSD__\n\tstruct ethercom *ec;\n#elif defined(__OpenBSD__)\n\tstruct arpcom *ec;\n#endif\n\tbus_size_t bufp;\n\tint count;\n\n\tec = &sc->sc_ec;\n\tray_cmd_cancel(sc, SCP_UPD_MCAST);\n\n\t/* see if we have any ranges */\n\tif ((count = sc->sc_ec.ec_multicnt) < 17) {\n\t\tETHER_FIRST_MULTI(step, ec, enm);\n\t\twhile (enm) {\n\t\t\t/* see if this is a range */\n\t\t\tif (memcmp(enm->enm_addrlo, enm->enm_addrhi,\n\t\t\t\tETHER_ADDR_LEN)) {\n\t\t\t\tcount = 17;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tETHER_NEXT_MULTI(step, enm);\n\t\t}\n\t}\n\n\t/* track this stuff even when not running */\n\tif (count > 16) {\n\t\tsc->sc_if.if_flags |= IFF_ALLMULTI;\n\t\tray_update_promisc(sc);\n\t\treturn;\n\t} else if (sc->sc_if.if_flags & IFF_ALLMULTI) {\n\t\tsc->sc_if.if_flags &= ~IFF_ALLMULTI;\n\t\tray_update_promisc(sc);\n\t}\n\n\tif ((sc->sc_if.if_flags & IFF_RUNNING) == 0)\n\t\treturn;\n\telse if (ray_cmd_is_running(sc, SCP_UPDATESUBCMD)) {\n\t\tray_cmd_schedule(sc, SCP_UPD_MCAST);\n\t\treturn;\n\t} else if (!ray_alloc_ccs(sc,&ccs, RAY_CMD_UPDATE_MCAST, SCP_UPD_MCAST))\n\t\treturn;\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_update_mcast, c_nmcast, count);\n\tbufp = RAY_HOST_TO_ECF_BASE;\n\tETHER_FIRST_MULTI(step, ec, enm);\n\twhile (enm) {\n\t\tray_write_region(sc, bufp, enm->enm_addrlo, ETHER_ADDR_LEN);\n\t\tbufp += ETHER_ADDR_LEN;\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\t(void)ray_issue_cmd(sc, ccs, SCP_UPD_MCAST);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ether_delmulti",
          "args": [
            "ifr",
            "&sc->sc_ec"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_addmulti",
          "args": [
            "ifr",
            "&sc->sc_ec"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: ioctl: cmd SIOCDELMULTI\\n\",\n\t\t\t    ifp->if_xname)"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: ioctl: cmd SIOCADDMULTI\\n\", ifp->if_xname)"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ray_disable",
          "args": [
            "sc"
          ],
          "line": 1089
        },
        "resolved": true,
        "details": {
          "function_name": "ray_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "827-845",
          "snippet": "void\nray_disable(sc)\n\tstruct ray_softc *sc;\n{\n\tRAY_DPRINTF((\"%s: disable\\n\", sc->sc_xname));\n\n\tif ((sc->sc_if.if_flags & IFF_RUNNING))\n\t\tray_stop(sc);\n\n\tsc->sc_resetloop = 0;\n\tsc->sc_rxoverflow = 0;\n\tsc->sc_rxcksum = 0;\n\tsc->sc_rxhcksum = 0;\n\tsc->sc_rxnoise = 0;\n\n\tif (sc->sc_ih)\n\t\tpcmcia_intr_disestablish(sc->sc_pf, sc->sc_ih);\n\tsc->sc_ih = 0;\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tsc_xname\tsc_dev.dv_xname",
            "#define\tsc_if\t\tsc_ec.ac_if",
            "#define\tsc_if\t\tsc_ec.ec_if"
          ],
          "globals_used": [
            "void ray_disable",
            "void ray_stop"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_xname\tsc_dev.dv_xname\n#define\tsc_if\t\tsc_ec.ac_if\n#define\tsc_if\t\tsc_ec.ec_if\n\nvoid ray_disable;\nvoid ray_stop;\n\nvoid\nray_disable(sc)\n\tstruct ray_softc *sc;\n{\n\tRAY_DPRINTF((\"%s: disable\\n\", sc->sc_xname));\n\n\tif ((sc->sc_if.if_flags & IFF_RUNNING))\n\t\tray_stop(sc);\n\n\tsc->sc_resetloop = 0;\n\tsc->sc_rxoverflow = 0;\n\tsc->sc_rxcksum = 0;\n\tsc->sc_rxhcksum = 0;\n\tsc->sc_rxnoise = 0;\n\n\tif (sc->sc_ih)\n\t\tpcmcia_intr_disestablish(sc->sc_pf, sc->sc_ih);\n\tsc->sc_ih = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ray_update_promisc",
          "args": [
            "sc"
          ],
          "line": 1087
        },
        "resolved": true,
        "details": {
          "function_name": "ray_update_promisc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2845-2869",
          "snippet": "void\nray_update_promisc(sc)\n\tstruct ray_softc *sc;\n{\n\tbus_size_t ccs;\n\tint promisc;\n\n\tray_cmd_cancel(sc, SCP_UPD_PROMISC);\n\n\t/* do the issue check before equality check */\n\tpromisc = !!(sc->sc_if.if_flags & (IFF_PROMISC | IFF_ALLMULTI));\n\tif ((sc->sc_if.if_flags & IFF_RUNNING) == 0)\n\t\treturn;\n\telse if (ray_cmd_is_running(sc, SCP_UPDATESUBCMD)) {\n\t\tray_cmd_schedule(sc, SCP_UPD_PROMISC);\n\t\treturn;\n\t} else if (promisc == sc->sc_promisc)\n\t\treturn;\n\telse if (!ray_alloc_ccs(sc,&ccs,RAY_CMD_UPDATE_PARAMS, SCP_UPD_PROMISC))\n\t\treturn;\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_update, c_paramid, RAY_PID_PROMISC);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_update, c_nparam, 1);\n\tSRAM_WRITE_1(sc, RAY_HOST_TO_ECF_BASE, promisc);\n\t(void)ray_issue_cmd(sc, ccs, SCP_UPD_PROMISC);\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tSCP_UPD_PROMISC\t\t0x0400",
            "#define\tSCP_UPDATESUBCMD\t0x0001",
            "#define\tsc_if\t\tsc_ec.ac_if",
            "#define\tsc_if\t\tsc_ec.ec_if"
          ],
          "globals_used": [
            "int ray_alloc_ccs",
            "void ray_cmd_cancel",
            "void ray_cmd_schedule",
            "int ray_cmd_is_running",
            "int ray_issue_cmd",
            "void ray_update_promisc"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSCP_UPD_PROMISC\t\t0x0400\n#define\tSCP_UPDATESUBCMD\t0x0001\n#define\tsc_if\t\tsc_ec.ac_if\n#define\tsc_if\t\tsc_ec.ec_if\n\nint ray_alloc_ccs;\nvoid ray_cmd_cancel;\nvoid ray_cmd_schedule;\nint ray_cmd_is_running;\nint ray_issue_cmd;\nvoid ray_update_promisc;\n\nvoid\nray_update_promisc(sc)\n\tstruct ray_softc *sc;\n{\n\tbus_size_t ccs;\n\tint promisc;\n\n\tray_cmd_cancel(sc, SCP_UPD_PROMISC);\n\n\t/* do the issue check before equality check */\n\tpromisc = !!(sc->sc_if.if_flags & (IFF_PROMISC | IFF_ALLMULTI));\n\tif ((sc->sc_if.if_flags & IFF_RUNNING) == 0)\n\t\treturn;\n\telse if (ray_cmd_is_running(sc, SCP_UPDATESUBCMD)) {\n\t\tray_cmd_schedule(sc, SCP_UPD_PROMISC);\n\t\treturn;\n\t} else if (promisc == sc->sc_promisc)\n\t\treturn;\n\telse if (!ray_alloc_ccs(sc,&ccs,RAY_CMD_UPDATE_PARAMS, SCP_UPD_PROMISC))\n\t\treturn;\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_update, c_paramid, RAY_PID_PROMISC);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd_update, c_nparam, 1);\n\tSRAM_WRITE_1(sc, RAY_HOST_TO_ECF_BASE, promisc);\n\t(void)ray_issue_cmd(sc, ccs, SCP_UPD_PROMISC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ray_enable",
          "args": [
            "sc"
          ],
          "line": 1084
        },
        "resolved": true,
        "details": {
          "function_name": "ray_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "805-822",
          "snippet": "int\nray_enable(sc)\n\tstruct ray_softc *sc;\n{\n\tint error;\n\n\tRAY_DPRINTF((\"%s: enable\\n\", sc->sc_xname));\n\n\tif ((error = ray_init(sc)) == 0) {\n\t\tsc->sc_ih = pcmcia_intr_establish(sc->sc_pf, IPL_NET,\n\t\t    ray_intr, sc);\n\t\tif (sc->sc_ih == NULL) {\n\t\t\tray_stop(sc);\n\t\t\treturn (EIO);\n\t\t}\n\t}\n\treturn (error);\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tsc_xname\tsc_dev.dv_xname"
          ],
          "globals_used": [
            "int ray_enable",
            "int ray_init",
            "int ray_intr",
            "void ray_stop"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_xname\tsc_dev.dv_xname\n\nint ray_enable;\nint ray_init;\nint ray_intr;\nvoid ray_stop;\n\nint\nray_enable(sc)\n\tstruct ray_softc *sc;\n{\n\tint error;\n\n\tRAY_DPRINTF((\"%s: enable\\n\", sc->sc_xname));\n\n\tif ((error = ray_init(sc)) == 0) {\n\t\tsc->sc_ih = pcmcia_intr_establish(sc->sc_pf, IPL_NET,\n\t\t    ray_intr, sc);\n\t\tif (sc->sc_ih == NULL) {\n\t\t\tray_stop(sc);\n\t\t\treturn (EIO);\n\t\t}\n\t}\n\treturn (error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: ioctl: cmd SIOCSIFFLAGS\\n\", ifp->if_xname)"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arp_ifinit",
          "args": [
            "&sc->sc_ec",
            "ifa"
          ],
          "line": 1072
        },
        "resolved": true,
        "details": {
          "function_name": "arp_ifinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_devar.h",
          "lines": "929-936",
          "snippet": "static void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}",
          "includes": [
            "#include <sys/devconf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/devconf.h>\n\nstatic void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: ioctl: cmd SIOCSIFADDR\\n\", ifp->if_xname)"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_ioctl",
          "args": [
            "ifp",
            "&sc->sc_ec",
            "cmd",
            "data"
          ],
          "line": 1052
        },
        "resolved": true,
        "details": {
          "function_name": "xe_ether_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_xe.c",
          "lines": "1190-1240",
          "snippet": "int\nxe_ether_ioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tu_long cmd;\n\tcaddr_t data;\n{\n\tstruct ifaddr *ifa = (struct ifaddr *)data;\n\tstruct xe_softc *sc = ifp->if_softc;\n#ifdef NS\n\tstruct ns_addr *ina;\n#endif\t/* NS */\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\txe_init(sc);\n\t\t\tarp_ifinit(&sc->sc_arpcom, ifa);\n\t\t\tbreak;\n#endif\t/* INET */\n\n#ifdef NS\n\t\tcase AF_NS:\n\t\t\tina = &IA_SNS(ifa)->sns_addr;\n\n\t\t\tif (ns_nullhost(*ina))\n\t\t\t\tina->x_host =\n\t\t\t\t    *(union ns_host *)sc->sc_arpcom.ac_enaddr;\n\t\t\telse\n\t\t\t\tbcopy(ina->x_host.c_host,\n\t\t\t\t    sc->sc_arpcom.ac_enaddr, ifp->if_addrlen);\n\t\t\t/* Set new address. */\n\t\t\txe_init(sc);\n\t\t\tbreak;\n#endif\t/* NS */\n\n\t\tdefault:\n\t\t\txe_init(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/pcmcia/if_xereg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\txe_ether_ioctl",
            "void\txe_init",
            "xe_mdi_idle __P((struct xe_softc *));",
            "xe_mdi_pulse __P((struct xe_softc *, int));",
            "xe_mdi_probe __P((struct xe_softc *sc));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_xereg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/mii/miivar.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\txe_ether_ioctl;\nvoid\txe_init;\nxe_mdi_idle __P((struct xe_softc *));\nxe_mdi_pulse __P((struct xe_softc *, int));\nxe_mdi_probe __P((struct xe_softc *sc));\n\nint\nxe_ether_ioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tu_long cmd;\n\tcaddr_t data;\n{\n\tstruct ifaddr *ifa = (struct ifaddr *)data;\n\tstruct xe_softc *sc = ifp->if_softc;\n#ifdef NS\n\tstruct ns_addr *ina;\n#endif\t/* NS */\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\txe_init(sc);\n\t\t\tarp_ifinit(&sc->sc_arpcom, ifa);\n\t\t\tbreak;\n#endif\t/* INET */\n\n#ifdef NS\n\t\tcase AF_NS:\n\t\t\tina = &IA_SNS(ifa)->sns_addr;\n\n\t\t\tif (ns_nullhost(*ina))\n\t\t\t\tina->x_host =\n\t\t\t\t    *(union ns_host *)sc->sc_arpcom.ac_enaddr;\n\t\t\telse\n\t\t\t\tbcopy(ina->x_host.c_host,\n\t\t\t\t    sc->sc_arpcom.ac_enaddr, ifp->if_addrlen);\n\t\t\t/* Set new address. */\n\t\t\txe_init(sc);\n\t\t\tbreak;\n#endif\t/* NS */\n\n\t\tdefault:\n\t\t\txe_init(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: ioctl: cmd 0x%lx data 0x%lx\\n\", ifp->if_xname,\n\t    cmd, (long)data)"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splnet",
          "args": [],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_if\t\tsc_ec.ac_if\n#define\tsc_if\t\tsc_ec.ec_if\n\nvoid ray_disable;\nint ray_enable;\nint ray_ioctl;\nvoid ray_start_join_net;\nvoid ray_update_mcast;\nvoid ray_update_promisc;\nint ray_user_report_params;\nint ray_user_update_params;\n\nint\nray_ioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tu_long cmd;\n\tcaddr_t data;\n{\n\tu_int8_t nwid[IEEE80211_NWID_LEN];\n\tstruct ray_param_req pr;\n\tstruct ray_softc *sc;\n\tstruct ifreq *ifr;\n\tstruct ifaddr *ifa;\n\tint error, error2, s;\n\n\tsc = ifp->if_softc;\n\terror = 0;\n\n\tifr = (struct ifreq *)data;\n\n\ts = splnet();\n\n\tRAY_DPRINTF((\"%s: ioctl: cmd 0x%lx data 0x%lx\\n\", ifp->if_xname,\n\t    cmd, (long)data));\n\n#ifdef __OpenBSD__\n\tif ((error = ether_ioctl(ifp, &sc->sc_ec, cmd, data)) > 0) {\n\t\tsplx(s);\n\t\treturn error;\n\t}\n#endif\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tRAY_DPRINTF((\"%s: ioctl: cmd SIOCSIFADDR\\n\", ifp->if_xname));\n\t\tif ((ifp->if_flags & IFF_RUNNING) == 0)\n\t\t\tif ((error = ray_enable(sc)))\n\t\t\t\tbreak;\n\t\tifp->if_flags |= IFF_UP;\n\t\tifa = (struct ifaddr *)data;\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n#ifdef __NetBSD__\n\t\t\tarp_ifinit(&sc->sc_if, ifa);\n#elif defined(__OpenBSD__)\n\t\t\tarp_ifinit(&sc->sc_ec, ifa);\n#endif\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase SIOCSIFFLAGS:\n\t\tRAY_DPRINTF((\"%s: ioctl: cmd SIOCSIFFLAGS\\n\", ifp->if_xname));\n\t\tif (ifp->if_flags & IFF_UP) {\n\t\t\tif ((ifp->if_flags & IFF_RUNNING) == 0) {\n\t\t\t\tif ((error = ray_enable(sc)))\n\t\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t\tray_update_promisc(sc);\n\t\t} else if (ifp->if_flags & IFF_RUNNING)\n\t\t\tray_disable(sc);\n\t\tbreak;\n\tcase SIOCADDMULTI:\n\t\tRAY_DPRINTF((\"%s: ioctl: cmd SIOCADDMULTI\\n\", ifp->if_xname));\n\tcase SIOCDELMULTI:\n\t\tif (cmd == SIOCDELMULTI)\n\t\t\tRAY_DPRINTF((\"%s: ioctl: cmd SIOCDELMULTI\\n\",\n\t\t\t    ifp->if_xname));\n\t\tif (cmd == SIOCADDMULTI)\n\t\t\terror = ether_addmulti(ifr, &sc->sc_ec);\n\t\telse\n\t\t\terror = ether_delmulti(ifr, &sc->sc_ec);\n\t\tif (error == ENETRESET) {\n\t\t\terror = 0;\n\t\t\tray_update_mcast(sc);\n\t\t}\n\t\tbreak;\n\tcase SIOCSIFMEDIA:\n\t\tRAY_DPRINTF((\"%s: ioctl: cmd SIOCSIFMEDIA\\n\", ifp->if_xname));\n\tcase SIOCGIFMEDIA:\n\t\tif (cmd == SIOCGIFMEDIA)\n\t\t\tRAY_DPRINTF((\"%s: ioctl: cmd SIOCGIFMEDIA\\n\",\n\t\t\t    ifp->if_xname));\n\t\terror = ifmedia_ioctl(ifp, ifr, &sc->sc_media, cmd);\n\t\tbreak;\n\tcase SIOCSRAYPARAM:\n\t\tRAY_DPRINTF((\"%s: ioctl: cmd SIOCSRAYPARAM\\n\", ifp->if_xname));\n\t\tif ((error = copyin(ifr->ifr_data, &pr, sizeof(pr))))\n\t\t\tbreak;\n\t\t/* disallow certain command that have another interface */\n\t\tswitch (pr.r_paramid) {\n\t\tcase RAY_PID_NET_TYPE:\t/* through media opt */\n\t\tcase RAY_PID_AP_STATUS:\t/* unsupported */\n\t\tcase RAY_PID_SSID:\t/* use SIOC80211[GS]NWID */\n\t\tcase RAY_PID_MAC_ADDR:\t/* XXX need interface? */\n\t\tcase RAY_PID_PROMISC:\t/* bpf */\n\t\t\terror = EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\terror = ray_user_update_params(sc, &pr);\n\t\terror2 = copyout(&pr, ifr->ifr_data, sizeof(pr));\n\t\terror = error2 ? error2 : error;\n\t\tbreak;\n\tcase SIOCGRAYPARAM:\n\t\tRAY_DPRINTF((\"%s: ioctl: cmd SIOCGRAYPARAM\\n\", ifp->if_xname));\n\t\tif ((error = copyin(ifr->ifr_data, &pr, sizeof(pr))))\n\t\t\tbreak;\n\t\terror = ray_user_report_params(sc, &pr);\n\t\terror2 = copyout(&pr, ifr->ifr_data, sizeof(pr));\n\t\terror = error2 ? error2 : error;\n\t\tbreak;\n\tcase SIOCS80211NWID:\n\t\tRAY_DPRINTF((\"%s: ioctl: cmd SIOCSNWID\\n\", ifp->if_xname));\n\t\t/*\n\t\t * if later people overwrite thats ok -- the latest version\n\t\t * will always get start/joined even if it was set by\n\t\t * a previous command\n\t\t */\n\t\tif ((error = copyin(ifr->ifr_data, nwid, sizeof(nwid))))\n\t\t\tbreak;\n\t\tif (!memcmp(sc->sc_dnwid, nwid, sizeof(nwid)))\n\t\t\tbreak;\n\t\tmemcpy(sc->sc_dnwid, nwid, sizeof(nwid));\n\t\tif (ifp->if_flags & IFF_RUNNING)\n\t\t\tray_start_join_net(sc);\n\t\tbreak;\n\tcase SIOCG80211NWID:\n\t\tRAY_DPRINTF((\"%s: ioctl: cmd SIOCHNWID\\n\", ifp->if_xname));\n\t\terror = copyout(sc->sc_cnwid, ifr->ifr_data,\n\t\t    IEEE80211_NWID_LEN);\n\t\tbreak;\n#ifdef RAY_DO_SIGLEV\n\t\terror = copyout(sc->sc_siglevs, ifr->ifr_data,\n\t\t\t    sizeof sc->sc_siglevs);\n\t\tbreak;\n#endif\n\tdefault:\n\t\tRAY_DPRINTF((\"%s: ioctl: unknown\\n\", ifp->if_xname));\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\tRAY_DPRINTF((\"%s: ioctl: returns %d\\n\", ifp->if_xname, error));\n\n\tsplx(s);\n\n\treturn (error);\n}"
  },
  {
    "function_name": "ray_shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
    "lines": "1018-1026",
    "snippet": "void\nray_shutdown(arg)\n\tvoid *arg;\n{\n\tstruct ray_softc *sc;\n\n\tsc = arg;\n\tray_disable(sc);\n}",
    "includes": [
      "#include <dev/pcmcia/if_rayreg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_llc.h>",
      "#include <net/if_media.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/timeout.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void ray_disable",
      "void ray_shutdown"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ray_disable",
          "args": [
            "sc"
          ],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "ray_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "827-845",
          "snippet": "void\nray_disable(sc)\n\tstruct ray_softc *sc;\n{\n\tRAY_DPRINTF((\"%s: disable\\n\", sc->sc_xname));\n\n\tif ((sc->sc_if.if_flags & IFF_RUNNING))\n\t\tray_stop(sc);\n\n\tsc->sc_resetloop = 0;\n\tsc->sc_rxoverflow = 0;\n\tsc->sc_rxcksum = 0;\n\tsc->sc_rxhcksum = 0;\n\tsc->sc_rxnoise = 0;\n\n\tif (sc->sc_ih)\n\t\tpcmcia_intr_disestablish(sc->sc_pf, sc->sc_ih);\n\tsc->sc_ih = 0;\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tsc_xname\tsc_dev.dv_xname",
            "#define\tsc_if\t\tsc_ec.ac_if",
            "#define\tsc_if\t\tsc_ec.ec_if"
          ],
          "globals_used": [
            "void ray_disable",
            "void ray_stop"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_xname\tsc_dev.dv_xname\n#define\tsc_if\t\tsc_ec.ac_if\n#define\tsc_if\t\tsc_ec.ec_if\n\nvoid ray_disable;\nvoid ray_stop;\n\nvoid\nray_disable(sc)\n\tstruct ray_softc *sc;\n{\n\tRAY_DPRINTF((\"%s: disable\\n\", sc->sc_xname));\n\n\tif ((sc->sc_if.if_flags & IFF_RUNNING))\n\t\tray_stop(sc);\n\n\tsc->sc_resetloop = 0;\n\tsc->sc_rxoverflow = 0;\n\tsc->sc_rxcksum = 0;\n\tsc->sc_rxhcksum = 0;\n\tsc->sc_rxnoise = 0;\n\n\tif (sc->sc_ih)\n\t\tpcmcia_intr_disestablish(sc->sc_pf, sc->sc_ih);\n\tsc->sc_ih = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\nvoid ray_disable;\nvoid ray_shutdown;\n\nvoid\nray_shutdown(arg)\n\tvoid *arg;\n{\n\tstruct ray_softc *sc;\n\n\tsc = arg;\n\tray_disable(sc);\n}"
  },
  {
    "function_name": "ray_power",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
    "lines": "990-1016",
    "snippet": "void\nray_power(why, arg)\n\tint why;\n\tvoid *arg;\n{\n#if 0\n\tstruct ray_softc *sc;\n\n\t/* can't do this until power hooks are called from thread */\n\tsc = arg;\n\tswitch (why) {\n\tcase PWR_RESUME:\n\t\tif (sc->sc_resumeinit)\n\t\t\tray_init(sc);\n\t\tbreak;\n\tcase PWR_SUSPEND:\n\t\tif ((sc->sc_if.if_flags & IFF_RUNNING)) {\n\t\t\tray_stop(sc);\n\t\t\tsc->sc_resumeinit = 1;\n\t\t}\n\t\tbreak;\n\tcase PWR_STANDBY:\n\tdefault:\n\t\tbreak;\n\t}\n#endif\n}",
    "includes": [
      "#include <dev/pcmcia/if_rayreg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_llc.h>",
      "#include <net/if_media.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/timeout.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [
      "#define\tsc_if\t\tsc_ec.ac_if",
      "#define\tsc_if\t\tsc_ec.ec_if"
    ],
    "globals_used": [
      "int ray_init",
      "void ray_power",
      "void ray_stop"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ray_stop",
          "args": [
            "sc"
          ],
          "line": 1007
        },
        "resolved": true,
        "details": {
          "function_name": "ray_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "924-947",
          "snippet": "void\nray_stop(sc)\n\tstruct ray_softc *sc;\n{\n\tRAY_DPRINTF((\"%s: stop\\n\", sc->sc_xname));\n\n\tcallout_stop(&sc->sc_check_ccs_ch);\n\tsc->sc_timocheck = 0;\n\n\tcallout_stop(&sc->sc_check_scheduled_ch);\n\tsc->sc_timoneed = 0;\n\n\tif (sc->sc_repreq) {\n\t\tsc->sc_repreq->r_failcause = RAY_FAILCAUSE_EDEVSTOP;\n\t\twakeup(ray_report_params);\n\t}\n\tif (sc->sc_updreq) {\n\t\tsc->sc_repreq->r_failcause = RAY_FAILCAUSE_EDEVSTOP;\n\t\twakeup(ray_update_params);\n\t}\n\n\tsc->sc_if.if_flags &= ~IFF_RUNNING;\n\tpcmcia_function_disable(sc->sc_pf);\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tsc_xname\tsc_dev.dv_xname",
            "#define\tsc_if\t\tsc_ec.ac_if",
            "#define\tsc_if\t\tsc_ec.ec_if",
            "#define\tcallout_stop\ttimeout_del"
          ],
          "globals_used": [
            "void ray_report_params",
            "void ray_stop",
            "void ray_update_params"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_xname\tsc_dev.dv_xname\n#define\tsc_if\t\tsc_ec.ac_if\n#define\tsc_if\t\tsc_ec.ec_if\n#define\tcallout_stop\ttimeout_del\n\nvoid ray_report_params;\nvoid ray_stop;\nvoid ray_update_params;\n\nvoid\nray_stop(sc)\n\tstruct ray_softc *sc;\n{\n\tRAY_DPRINTF((\"%s: stop\\n\", sc->sc_xname));\n\n\tcallout_stop(&sc->sc_check_ccs_ch);\n\tsc->sc_timocheck = 0;\n\n\tcallout_stop(&sc->sc_check_scheduled_ch);\n\tsc->sc_timoneed = 0;\n\n\tif (sc->sc_repreq) {\n\t\tsc->sc_repreq->r_failcause = RAY_FAILCAUSE_EDEVSTOP;\n\t\twakeup(ray_report_params);\n\t}\n\tif (sc->sc_updreq) {\n\t\tsc->sc_repreq->r_failcause = RAY_FAILCAUSE_EDEVSTOP;\n\t\twakeup(ray_update_params);\n\t}\n\n\tsc->sc_if.if_flags &= ~IFF_RUNNING;\n\tpcmcia_function_disable(sc->sc_pf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ray_init",
          "args": [
            "sc"
          ],
          "line": 1003
        },
        "resolved": true,
        "details": {
          "function_name": "ray_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "850-919",
          "snippet": "int\nray_init(sc)\n\tstruct ray_softc *sc;\n{\n\tstruct ray_ecf_startup *ep;\n\tbus_size_t ccs;\n\tint i;\n\n\tRAY_DPRINTF((\"%s: init\\n\", sc->sc_xname));\n\n\tif ((sc->sc_if.if_flags & IFF_RUNNING))\n\t\tray_stop(sc);\n\n\tif (pcmcia_function_enable(sc->sc_pf))\n\t\treturn (EIO);\n\n\tRAY_DPRINTF((\"%s: init post-enable\\n\", sc->sc_xname));\n\n\t/* reset some values */\n\tmemset(sc->sc_ccsinuse, 0, sizeof(sc->sc_ccsinuse));\n\tsc->sc_havenet = 0;\n\tmemset(sc->sc_bssid, 0, sizeof(sc->sc_bssid));\n\tsc->sc_deftxrate = 0;\n\tsc->sc_encrypt = 0;\n\tsc->sc_txpad = 0;\n\tsc->sc_promisc = 0;\n\tsc->sc_scheduled = 0;\n\tsc->sc_running = 0;\n\tsc->sc_txfree = RAY_CCS_NTX;\n\tsc->sc_checkcounters = 0;\n\tsc->sc_resumeinit = 0;\n\n\t/* get startup results */\n\tep = &sc->sc_ecf_startup;\n\tray_read_region(sc, RAY_ECF_TO_HOST_BASE, ep,\n\t    sizeof(sc->sc_ecf_startup));\n\n\t/* check to see that card initialized properly */\n\tif (ep->e_status != RAY_ECFS_CARD_OK) {\n\t\tpcmcia_function_disable(sc->sc_pf);\n\t\tprintf(\"%s: card failed self test: status %d\\n\",\n\t\t    sc->sc_xname, sc->sc_ecf_startup.e_status);\n\t\treturn (EIO);\n\t}\n\n\t/* fixup tib size to be correct */\n\tif (sc->sc_version == SC_BUILD_4 && sc->sc_tibsize == 0x55)\n\t\tsc->sc_tibsize = 32;\n\tsc->sc_txpad = sc->sc_tibsize;\n\n\t/* set all ccs to be free */\n\tccs = RAY_GET_CCS(0);\n\tfor (i = 0; i < RAY_CCS_LAST; ccs += RAY_CCS_SIZE, i++)\n\t\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_status,\n\t\t    RAY_CCS_STATUS_FREE);\n\n\t/* clear the interrupt if present */\n\tREG_WRITE(sc, RAY_HCSIR, 0);\n\n\t/* we are now up and running -- and are busy until download is cplt */\n\tsc->sc_if.if_flags |= IFF_RUNNING | IFF_OACTIVE;\n\n\t/* set this now so it gets set in the download */\n\tsc->sc_promisc = !!(sc->sc_if.if_flags & (IFF_PROMISC|IFF_ALLMULTI));\n\n\t/* call after we mark ourselves running */\n\tray_download_params(sc);\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tSC_BUILD_4\t0x55",
            "#define\tsc_xname\tsc_dev.dv_xname",
            "#define\tsc_if\t\tsc_ec.ac_if",
            "#define\tsc_if\t\tsc_ec.ec_if",
            "#define\tsc_tibsize\tsc_ecf_startup.e_tib_size",
            "#define\tsc_version\tsc_ecf_startup.e_fw_build_string"
          ],
          "globals_used": [
            "void ray_download_params",
            "int ray_init",
            "void ray_stop"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSC_BUILD_4\t0x55\n#define\tsc_xname\tsc_dev.dv_xname\n#define\tsc_if\t\tsc_ec.ac_if\n#define\tsc_if\t\tsc_ec.ec_if\n#define\tsc_tibsize\tsc_ecf_startup.e_tib_size\n#define\tsc_version\tsc_ecf_startup.e_fw_build_string\n\nvoid ray_download_params;\nint ray_init;\nvoid ray_stop;\n\nint\nray_init(sc)\n\tstruct ray_softc *sc;\n{\n\tstruct ray_ecf_startup *ep;\n\tbus_size_t ccs;\n\tint i;\n\n\tRAY_DPRINTF((\"%s: init\\n\", sc->sc_xname));\n\n\tif ((sc->sc_if.if_flags & IFF_RUNNING))\n\t\tray_stop(sc);\n\n\tif (pcmcia_function_enable(sc->sc_pf))\n\t\treturn (EIO);\n\n\tRAY_DPRINTF((\"%s: init post-enable\\n\", sc->sc_xname));\n\n\t/* reset some values */\n\tmemset(sc->sc_ccsinuse, 0, sizeof(sc->sc_ccsinuse));\n\tsc->sc_havenet = 0;\n\tmemset(sc->sc_bssid, 0, sizeof(sc->sc_bssid));\n\tsc->sc_deftxrate = 0;\n\tsc->sc_encrypt = 0;\n\tsc->sc_txpad = 0;\n\tsc->sc_promisc = 0;\n\tsc->sc_scheduled = 0;\n\tsc->sc_running = 0;\n\tsc->sc_txfree = RAY_CCS_NTX;\n\tsc->sc_checkcounters = 0;\n\tsc->sc_resumeinit = 0;\n\n\t/* get startup results */\n\tep = &sc->sc_ecf_startup;\n\tray_read_region(sc, RAY_ECF_TO_HOST_BASE, ep,\n\t    sizeof(sc->sc_ecf_startup));\n\n\t/* check to see that card initialized properly */\n\tif (ep->e_status != RAY_ECFS_CARD_OK) {\n\t\tpcmcia_function_disable(sc->sc_pf);\n\t\tprintf(\"%s: card failed self test: status %d\\n\",\n\t\t    sc->sc_xname, sc->sc_ecf_startup.e_status);\n\t\treturn (EIO);\n\t}\n\n\t/* fixup tib size to be correct */\n\tif (sc->sc_version == SC_BUILD_4 && sc->sc_tibsize == 0x55)\n\t\tsc->sc_tibsize = 32;\n\tsc->sc_txpad = sc->sc_tibsize;\n\n\t/* set all ccs to be free */\n\tccs = RAY_GET_CCS(0);\n\tfor (i = 0; i < RAY_CCS_LAST; ccs += RAY_CCS_SIZE, i++)\n\t\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_status,\n\t\t    RAY_CCS_STATUS_FREE);\n\n\t/* clear the interrupt if present */\n\tREG_WRITE(sc, RAY_HCSIR, 0);\n\n\t/* we are now up and running -- and are busy until download is cplt */\n\tsc->sc_if.if_flags |= IFF_RUNNING | IFF_OACTIVE;\n\n\t/* set this now so it gets set in the download */\n\tsc->sc_promisc = !!(sc->sc_if.if_flags & (IFF_PROMISC|IFF_ALLMULTI));\n\n\t/* call after we mark ourselves running */\n\tray_download_params(sc);\n\n\treturn (0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_if\t\tsc_ec.ac_if\n#define\tsc_if\t\tsc_ec.ec_if\n\nint ray_init;\nvoid ray_power;\nvoid ray_stop;\n\nvoid\nray_power(why, arg)\n\tint why;\n\tvoid *arg;\n{\n#if 0\n\tstruct ray_softc *sc;\n\n\t/* can't do this until power hooks are called from thread */\n\tsc = arg;\n\tswitch (why) {\n\tcase PWR_RESUME:\n\t\tif (sc->sc_resumeinit)\n\t\t\tray_init(sc);\n\t\tbreak;\n\tcase PWR_SUSPEND:\n\t\tif ((sc->sc_if.if_flags & IFF_RUNNING)) {\n\t\t\tray_stop(sc);\n\t\t\tsc->sc_resumeinit = 1;\n\t\t}\n\t\tbreak;\n\tcase PWR_STANDBY:\n\tdefault:\n\t\tbreak;\n\t}\n#endif\n}"
  },
  {
    "function_name": "ray_reset_resetloop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
    "lines": "980-988",
    "snippet": "void\nray_reset_resetloop(arg)\n\tvoid *arg;\n{\n\tstruct ray_softc *sc;\n\n\tsc = arg;\n\tsc->sc_resetloop = 0;\n}",
    "includes": [
      "#include <dev/pcmcia/if_rayreg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_llc.h>",
      "#include <net/if_media.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/timeout.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void ray_reset_resetloop"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\nvoid ray_reset_resetloop;\n\nvoid\nray_reset_resetloop(arg)\n\tvoid *arg;\n{\n\tstruct ray_softc *sc;\n\n\tsc = arg;\n\tsc->sc_resetloop = 0;\n}"
  },
  {
    "function_name": "ray_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
    "lines": "952-972",
    "snippet": "void\nray_reset(sc)\n\tstruct ray_softc *sc;\n{\n\tif (++sc->sc_resetloop >= RAY_MAX_RESETS) {\n\t\tif (sc->sc_resetloop == RAY_MAX_RESETS) {\n\t\t\tprintf(\"%s: unable to correct, disabling\\n\",\n\t\t\t    sc->sc_xname);\n\t\t\tcallout_stop(&sc->sc_reset_resetloop_ch);\n\t\t\tcallout_reset(&sc->sc_disable_ch, 1,\n\t\t\t    (void (*)(void *))ray_disable, sc);\n\t\t}\n\t} else {\n\t\tprintf(\"%s: unexpected failure resetting hw [%d more]\\n\",\n\t\t    sc->sc_xname, RAY_MAX_RESETS - sc->sc_resetloop);\n\t\tcallout_stop(&sc->sc_reset_resetloop_ch);\n\t\tray_init(sc);\n\t\tcallout_reset(&sc->sc_reset_resetloop_ch, RAY_RESET_TIMEOUT,\n\t\t    ray_reset_resetloop, sc);\n\t}\n}",
    "includes": [
      "#include <dev/pcmcia/if_rayreg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_llc.h>",
      "#include <net/if_media.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/timeout.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [
      "#define\tsc_xname\tsc_dev.dv_xname",
      "#define\tcallout_stop\ttimeout_del",
      "#define\tRAY_MAX_RESETS\t10",
      "#define\tRAY_RESET_TIMEOUT\t(10 * hz)"
    ],
    "globals_used": [
      "void ray_disable",
      "int ray_init",
      "void ray_reset",
      "void ray_reset_resetloop"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "callout_reset",
          "args": [
            "&sc->sc_reset_resetloop_ch",
            "RAY_RESET_TIMEOUT",
            "ray_reset_resetloop",
            "sc"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ray_init",
          "args": [
            "sc"
          ],
          "line": 968
        },
        "resolved": true,
        "details": {
          "function_name": "ray_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "850-919",
          "snippet": "int\nray_init(sc)\n\tstruct ray_softc *sc;\n{\n\tstruct ray_ecf_startup *ep;\n\tbus_size_t ccs;\n\tint i;\n\n\tRAY_DPRINTF((\"%s: init\\n\", sc->sc_xname));\n\n\tif ((sc->sc_if.if_flags & IFF_RUNNING))\n\t\tray_stop(sc);\n\n\tif (pcmcia_function_enable(sc->sc_pf))\n\t\treturn (EIO);\n\n\tRAY_DPRINTF((\"%s: init post-enable\\n\", sc->sc_xname));\n\n\t/* reset some values */\n\tmemset(sc->sc_ccsinuse, 0, sizeof(sc->sc_ccsinuse));\n\tsc->sc_havenet = 0;\n\tmemset(sc->sc_bssid, 0, sizeof(sc->sc_bssid));\n\tsc->sc_deftxrate = 0;\n\tsc->sc_encrypt = 0;\n\tsc->sc_txpad = 0;\n\tsc->sc_promisc = 0;\n\tsc->sc_scheduled = 0;\n\tsc->sc_running = 0;\n\tsc->sc_txfree = RAY_CCS_NTX;\n\tsc->sc_checkcounters = 0;\n\tsc->sc_resumeinit = 0;\n\n\t/* get startup results */\n\tep = &sc->sc_ecf_startup;\n\tray_read_region(sc, RAY_ECF_TO_HOST_BASE, ep,\n\t    sizeof(sc->sc_ecf_startup));\n\n\t/* check to see that card initialized properly */\n\tif (ep->e_status != RAY_ECFS_CARD_OK) {\n\t\tpcmcia_function_disable(sc->sc_pf);\n\t\tprintf(\"%s: card failed self test: status %d\\n\",\n\t\t    sc->sc_xname, sc->sc_ecf_startup.e_status);\n\t\treturn (EIO);\n\t}\n\n\t/* fixup tib size to be correct */\n\tif (sc->sc_version == SC_BUILD_4 && sc->sc_tibsize == 0x55)\n\t\tsc->sc_tibsize = 32;\n\tsc->sc_txpad = sc->sc_tibsize;\n\n\t/* set all ccs to be free */\n\tccs = RAY_GET_CCS(0);\n\tfor (i = 0; i < RAY_CCS_LAST; ccs += RAY_CCS_SIZE, i++)\n\t\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_status,\n\t\t    RAY_CCS_STATUS_FREE);\n\n\t/* clear the interrupt if present */\n\tREG_WRITE(sc, RAY_HCSIR, 0);\n\n\t/* we are now up and running -- and are busy until download is cplt */\n\tsc->sc_if.if_flags |= IFF_RUNNING | IFF_OACTIVE;\n\n\t/* set this now so it gets set in the download */\n\tsc->sc_promisc = !!(sc->sc_if.if_flags & (IFF_PROMISC|IFF_ALLMULTI));\n\n\t/* call after we mark ourselves running */\n\tray_download_params(sc);\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tSC_BUILD_4\t0x55",
            "#define\tsc_xname\tsc_dev.dv_xname",
            "#define\tsc_if\t\tsc_ec.ac_if",
            "#define\tsc_if\t\tsc_ec.ec_if",
            "#define\tsc_tibsize\tsc_ecf_startup.e_tib_size",
            "#define\tsc_version\tsc_ecf_startup.e_fw_build_string"
          ],
          "globals_used": [
            "void ray_download_params",
            "int ray_init",
            "void ray_stop"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSC_BUILD_4\t0x55\n#define\tsc_xname\tsc_dev.dv_xname\n#define\tsc_if\t\tsc_ec.ac_if\n#define\tsc_if\t\tsc_ec.ec_if\n#define\tsc_tibsize\tsc_ecf_startup.e_tib_size\n#define\tsc_version\tsc_ecf_startup.e_fw_build_string\n\nvoid ray_download_params;\nint ray_init;\nvoid ray_stop;\n\nint\nray_init(sc)\n\tstruct ray_softc *sc;\n{\n\tstruct ray_ecf_startup *ep;\n\tbus_size_t ccs;\n\tint i;\n\n\tRAY_DPRINTF((\"%s: init\\n\", sc->sc_xname));\n\n\tif ((sc->sc_if.if_flags & IFF_RUNNING))\n\t\tray_stop(sc);\n\n\tif (pcmcia_function_enable(sc->sc_pf))\n\t\treturn (EIO);\n\n\tRAY_DPRINTF((\"%s: init post-enable\\n\", sc->sc_xname));\n\n\t/* reset some values */\n\tmemset(sc->sc_ccsinuse, 0, sizeof(sc->sc_ccsinuse));\n\tsc->sc_havenet = 0;\n\tmemset(sc->sc_bssid, 0, sizeof(sc->sc_bssid));\n\tsc->sc_deftxrate = 0;\n\tsc->sc_encrypt = 0;\n\tsc->sc_txpad = 0;\n\tsc->sc_promisc = 0;\n\tsc->sc_scheduled = 0;\n\tsc->sc_running = 0;\n\tsc->sc_txfree = RAY_CCS_NTX;\n\tsc->sc_checkcounters = 0;\n\tsc->sc_resumeinit = 0;\n\n\t/* get startup results */\n\tep = &sc->sc_ecf_startup;\n\tray_read_region(sc, RAY_ECF_TO_HOST_BASE, ep,\n\t    sizeof(sc->sc_ecf_startup));\n\n\t/* check to see that card initialized properly */\n\tif (ep->e_status != RAY_ECFS_CARD_OK) {\n\t\tpcmcia_function_disable(sc->sc_pf);\n\t\tprintf(\"%s: card failed self test: status %d\\n\",\n\t\t    sc->sc_xname, sc->sc_ecf_startup.e_status);\n\t\treturn (EIO);\n\t}\n\n\t/* fixup tib size to be correct */\n\tif (sc->sc_version == SC_BUILD_4 && sc->sc_tibsize == 0x55)\n\t\tsc->sc_tibsize = 32;\n\tsc->sc_txpad = sc->sc_tibsize;\n\n\t/* set all ccs to be free */\n\tccs = RAY_GET_CCS(0);\n\tfor (i = 0; i < RAY_CCS_LAST; ccs += RAY_CCS_SIZE, i++)\n\t\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_status,\n\t\t    RAY_CCS_STATUS_FREE);\n\n\t/* clear the interrupt if present */\n\tREG_WRITE(sc, RAY_HCSIR, 0);\n\n\t/* we are now up and running -- and are busy until download is cplt */\n\tsc->sc_if.if_flags |= IFF_RUNNING | IFF_OACTIVE;\n\n\t/* set this now so it gets set in the download */\n\tsc->sc_promisc = !!(sc->sc_if.if_flags & (IFF_PROMISC|IFF_ALLMULTI));\n\n\t/* call after we mark ourselves running */\n\tray_download_params(sc);\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "callout_stop",
          "args": [
            "&sc->sc_reset_resetloop_ch"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: unexpected failure resetting hw [%d more]\\n\"",
            "sc->sc_xname",
            "RAY_MAX_RESETS - sc->sc_resetloop"
          ],
          "line": 965
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "callout_reset",
          "args": [
            "&sc->sc_disable_ch",
            "1",
            "(void (*)(void *))ray_disable",
            "sc"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "callout_stop",
          "args": [
            "&sc->sc_reset_resetloop_ch"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_xname\tsc_dev.dv_xname\n#define\tcallout_stop\ttimeout_del\n#define\tRAY_MAX_RESETS\t10\n#define\tRAY_RESET_TIMEOUT\t(10 * hz)\n\nvoid ray_disable;\nint ray_init;\nvoid ray_reset;\nvoid ray_reset_resetloop;\n\nvoid\nray_reset(sc)\n\tstruct ray_softc *sc;\n{\n\tif (++sc->sc_resetloop >= RAY_MAX_RESETS) {\n\t\tif (sc->sc_resetloop == RAY_MAX_RESETS) {\n\t\t\tprintf(\"%s: unable to correct, disabling\\n\",\n\t\t\t    sc->sc_xname);\n\t\t\tcallout_stop(&sc->sc_reset_resetloop_ch);\n\t\t\tcallout_reset(&sc->sc_disable_ch, 1,\n\t\t\t    (void (*)(void *))ray_disable, sc);\n\t\t}\n\t} else {\n\t\tprintf(\"%s: unexpected failure resetting hw [%d more]\\n\",\n\t\t    sc->sc_xname, RAY_MAX_RESETS - sc->sc_resetloop);\n\t\tcallout_stop(&sc->sc_reset_resetloop_ch);\n\t\tray_init(sc);\n\t\tcallout_reset(&sc->sc_reset_resetloop_ch, RAY_RESET_TIMEOUT,\n\t\t    ray_reset_resetloop, sc);\n\t}\n}"
  },
  {
    "function_name": "ray_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
    "lines": "924-947",
    "snippet": "void\nray_stop(sc)\n\tstruct ray_softc *sc;\n{\n\tRAY_DPRINTF((\"%s: stop\\n\", sc->sc_xname));\n\n\tcallout_stop(&sc->sc_check_ccs_ch);\n\tsc->sc_timocheck = 0;\n\n\tcallout_stop(&sc->sc_check_scheduled_ch);\n\tsc->sc_timoneed = 0;\n\n\tif (sc->sc_repreq) {\n\t\tsc->sc_repreq->r_failcause = RAY_FAILCAUSE_EDEVSTOP;\n\t\twakeup(ray_report_params);\n\t}\n\tif (sc->sc_updreq) {\n\t\tsc->sc_repreq->r_failcause = RAY_FAILCAUSE_EDEVSTOP;\n\t\twakeup(ray_update_params);\n\t}\n\n\tsc->sc_if.if_flags &= ~IFF_RUNNING;\n\tpcmcia_function_disable(sc->sc_pf);\n}",
    "includes": [
      "#include <dev/pcmcia/if_rayreg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_llc.h>",
      "#include <net/if_media.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/timeout.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [
      "#define\tsc_xname\tsc_dev.dv_xname",
      "#define\tsc_if\t\tsc_ec.ac_if",
      "#define\tsc_if\t\tsc_ec.ec_if",
      "#define\tcallout_stop\ttimeout_del"
    ],
    "globals_used": [
      "void ray_report_params",
      "void ray_stop",
      "void ray_update_params"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcmcia_function_disable",
          "args": [
            "sc->sc_pf"
          ],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_function_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "570-622",
          "snippet": "void\npcmcia_function_disable(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct pcmcia_function *tmp;\n\n\tif (pf->cfe == NULL)\n\t\tpanic(\"pcmcia_function_enable: function not initialized\");\n\n\tif ((pf->pf_flags & PFF_ENABLED) == 0) {\n\t\t/*\n\t\t * Don't do anything if we're already disabled.\n\t\t */\n\t\treturn;\n\t}\n\n\t/* If there was no CIS don't mess with CCR */\n\tif (pf->pf_flags & PFF_FAKE) {\n\t\tpf->pf_flags &= ~PFF_ENABLED;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * it's possible for different functions' CCRs to be in the same\n\t * underlying page.  Check for that.  Note we mark us as disabled\n\t * first to avoid matching ourself.\n\t */\n\tpf->pf_flags &= ~PFF_ENABLED;\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t    tmp = tmp->pf_list.sqe_next) {\n\t\tif ((tmp->pf_flags & PFF_ENABLED) &&\n\t\t    (pf->ccr_base >= (tmp->ccr_base - tmp->pf_ccr_offset)) &&\n\t\t    ((pf->ccr_base + PCMCIA_CCR_SIZE) <=\n\t\t(tmp->ccr_base - tmp->pf_ccr_offset + tmp->pf_ccr_realsize)))\n\t\t\tbreak;\n\t}\n\n\t/* Not used by anyone else; unmap the CCR. */\n\tif (tmp == NULL) {\n\t\tpcmcia_mem_unmap(pf, pf->pf_ccr_window);\n\t\tpcmcia_mem_free(pf, &pf->pf_pcmh);\n\t}\n\n done:\n\t/*\n\t * Decrement the reference count, and power down the socket, if\n\t * necessary.\n\t */\n\tif (--pf->sc->sc_enabled_count == 0)\n\t\tpcmcia_chip_socket_disable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: --enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\n\nvoid\npcmcia_function_disable(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct pcmcia_function *tmp;\n\n\tif (pf->cfe == NULL)\n\t\tpanic(\"pcmcia_function_enable: function not initialized\");\n\n\tif ((pf->pf_flags & PFF_ENABLED) == 0) {\n\t\t/*\n\t\t * Don't do anything if we're already disabled.\n\t\t */\n\t\treturn;\n\t}\n\n\t/* If there was no CIS don't mess with CCR */\n\tif (pf->pf_flags & PFF_FAKE) {\n\t\tpf->pf_flags &= ~PFF_ENABLED;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * it's possible for different functions' CCRs to be in the same\n\t * underlying page.  Check for that.  Note we mark us as disabled\n\t * first to avoid matching ourself.\n\t */\n\tpf->pf_flags &= ~PFF_ENABLED;\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t    tmp = tmp->pf_list.sqe_next) {\n\t\tif ((tmp->pf_flags & PFF_ENABLED) &&\n\t\t    (pf->ccr_base >= (tmp->ccr_base - tmp->pf_ccr_offset)) &&\n\t\t    ((pf->ccr_base + PCMCIA_CCR_SIZE) <=\n\t\t(tmp->ccr_base - tmp->pf_ccr_offset + tmp->pf_ccr_realsize)))\n\t\t\tbreak;\n\t}\n\n\t/* Not used by anyone else; unmap the CCR. */\n\tif (tmp == NULL) {\n\t\tpcmcia_mem_unmap(pf, pf->pf_ccr_window);\n\t\tpcmcia_mem_free(pf, &pf->pf_pcmh);\n\t}\n\n done:\n\t/*\n\t * Decrement the reference count, and power down the socket, if\n\t * necessary.\n\t */\n\tif (--pf->sc->sc_enabled_count == 0)\n\t\tpcmcia_chip_socket_disable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: --enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "ray_update_params"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "audio_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "765-774",
          "snippet": "static __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nstatic __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "callout_stop",
          "args": [
            "&sc->sc_check_scheduled_ch"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "callout_stop",
          "args": [
            "&sc->sc_check_ccs_ch"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: stop\\n\", sc->sc_xname)"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_xname\tsc_dev.dv_xname\n#define\tsc_if\t\tsc_ec.ac_if\n#define\tsc_if\t\tsc_ec.ec_if\n#define\tcallout_stop\ttimeout_del\n\nvoid ray_report_params;\nvoid ray_stop;\nvoid ray_update_params;\n\nvoid\nray_stop(sc)\n\tstruct ray_softc *sc;\n{\n\tRAY_DPRINTF((\"%s: stop\\n\", sc->sc_xname));\n\n\tcallout_stop(&sc->sc_check_ccs_ch);\n\tsc->sc_timocheck = 0;\n\n\tcallout_stop(&sc->sc_check_scheduled_ch);\n\tsc->sc_timoneed = 0;\n\n\tif (sc->sc_repreq) {\n\t\tsc->sc_repreq->r_failcause = RAY_FAILCAUSE_EDEVSTOP;\n\t\twakeup(ray_report_params);\n\t}\n\tif (sc->sc_updreq) {\n\t\tsc->sc_repreq->r_failcause = RAY_FAILCAUSE_EDEVSTOP;\n\t\twakeup(ray_update_params);\n\t}\n\n\tsc->sc_if.if_flags &= ~IFF_RUNNING;\n\tpcmcia_function_disable(sc->sc_pf);\n}"
  },
  {
    "function_name": "ray_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
    "lines": "850-919",
    "snippet": "int\nray_init(sc)\n\tstruct ray_softc *sc;\n{\n\tstruct ray_ecf_startup *ep;\n\tbus_size_t ccs;\n\tint i;\n\n\tRAY_DPRINTF((\"%s: init\\n\", sc->sc_xname));\n\n\tif ((sc->sc_if.if_flags & IFF_RUNNING))\n\t\tray_stop(sc);\n\n\tif (pcmcia_function_enable(sc->sc_pf))\n\t\treturn (EIO);\n\n\tRAY_DPRINTF((\"%s: init post-enable\\n\", sc->sc_xname));\n\n\t/* reset some values */\n\tmemset(sc->sc_ccsinuse, 0, sizeof(sc->sc_ccsinuse));\n\tsc->sc_havenet = 0;\n\tmemset(sc->sc_bssid, 0, sizeof(sc->sc_bssid));\n\tsc->sc_deftxrate = 0;\n\tsc->sc_encrypt = 0;\n\tsc->sc_txpad = 0;\n\tsc->sc_promisc = 0;\n\tsc->sc_scheduled = 0;\n\tsc->sc_running = 0;\n\tsc->sc_txfree = RAY_CCS_NTX;\n\tsc->sc_checkcounters = 0;\n\tsc->sc_resumeinit = 0;\n\n\t/* get startup results */\n\tep = &sc->sc_ecf_startup;\n\tray_read_region(sc, RAY_ECF_TO_HOST_BASE, ep,\n\t    sizeof(sc->sc_ecf_startup));\n\n\t/* check to see that card initialized properly */\n\tif (ep->e_status != RAY_ECFS_CARD_OK) {\n\t\tpcmcia_function_disable(sc->sc_pf);\n\t\tprintf(\"%s: card failed self test: status %d\\n\",\n\t\t    sc->sc_xname, sc->sc_ecf_startup.e_status);\n\t\treturn (EIO);\n\t}\n\n\t/* fixup tib size to be correct */\n\tif (sc->sc_version == SC_BUILD_4 && sc->sc_tibsize == 0x55)\n\t\tsc->sc_tibsize = 32;\n\tsc->sc_txpad = sc->sc_tibsize;\n\n\t/* set all ccs to be free */\n\tccs = RAY_GET_CCS(0);\n\tfor (i = 0; i < RAY_CCS_LAST; ccs += RAY_CCS_SIZE, i++)\n\t\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_status,\n\t\t    RAY_CCS_STATUS_FREE);\n\n\t/* clear the interrupt if present */\n\tREG_WRITE(sc, RAY_HCSIR, 0);\n\n\t/* we are now up and running -- and are busy until download is cplt */\n\tsc->sc_if.if_flags |= IFF_RUNNING | IFF_OACTIVE;\n\n\t/* set this now so it gets set in the download */\n\tsc->sc_promisc = !!(sc->sc_if.if_flags & (IFF_PROMISC|IFF_ALLMULTI));\n\n\t/* call after we mark ourselves running */\n\tray_download_params(sc);\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/pcmcia/if_rayreg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_llc.h>",
      "#include <net/if_media.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/timeout.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [
      "#define\tSC_BUILD_4\t0x55",
      "#define\tsc_xname\tsc_dev.dv_xname",
      "#define\tsc_if\t\tsc_ec.ac_if",
      "#define\tsc_if\t\tsc_ec.ec_if",
      "#define\tsc_tibsize\tsc_ecf_startup.e_tib_size",
      "#define\tsc_version\tsc_ecf_startup.e_fw_build_string"
    ],
    "globals_used": [
      "void ray_download_params",
      "int ray_init",
      "void ray_stop"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ray_download_params",
          "args": [
            "sc"
          ],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "ray_download_params",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2500-2686",
          "snippet": "void\nray_download_params(sc)\n\tstruct ray_softc *sc;\n{\n\tstruct ray_startup_params_head *sp;\n\tstruct ray_startup_params_tail_5 *sp5;\n\tstruct ray_startup_params_tail_4 *sp4;\n\tbus_size_t off;\n\n\tRAY_DPRINTF((\"%s: init_startup_params\\n\", sc->sc_xname));\n\n\tray_cmd_cancel(sc, SCP_UPD_STARTUP);\n\n#define\tPUT2(p, v)\t\\\n\tdo { (p)[0] = ((v >> 8) & 0xff); (p)[1] = (v & 0xff); } while(0)\n\n\tsp = &sc->sc_startup;\n\tsp4 = &sc->sc_startup_4;\n\tsp5 = &sc->sc_startup_5;\n\tmemset(sp, 0, sizeof(*sp));\n\tif (sc->sc_version == SC_BUILD_4)\n\t\tmemset(sp4, 0, sizeof(*sp4));\n\telse\n\t\tmemset(sp5, 0, sizeof(*sp5));\n\tmemcpy(sp->sp_ssid, sc->sc_dnwid, sizeof(sp->sp_ssid));\n\tsp->sp_scan_mode = 0x1;\n\tmemcpy(sp->sp_mac_addr, sc->sc_ecf_startup.e_station_addr,\n\t    ETHER_ADDR_LEN);\n\tPUT2(sp->sp_frag_thresh, 0x7fff);\t/* disabled */\n\tif (sc->sc_version == SC_BUILD_4) {\n#if 1\n\t\t/* linux/fbsd */\n\t\tPUT2(sp->sp_dwell_time, 0x200);\n\t\tPUT2(sp->sp_beacon_period, 1);\n#else\n\t\t/* divined */\n\t\tPUT2(sp->sp_dwell_time, 0x400);\n\t\tPUT2(sp->sp_beacon_period, 0);\n#endif\n\t} else {\n\t\tPUT2(sp->sp_dwell_time, 128);\n\t\tPUT2(sp->sp_beacon_period, 256);\n\t}\n\tsp->sp_dtim_interval = 1;\n#if 0\n\t/* these are the documented defaults for build 5/6 */\n\tsp->sp_max_retry = 0x1f;\n\tsp->sp_ack_timo = 0x86;\n\tsp->sp_sifs = 0x1c;\n#elif 1\n\t/* these were scrounged from the linux driver */\n\tsp->sp_max_retry = 0x07;\n\n\tsp->sp_ack_timo = 0xa3;\n\tsp->sp_sifs = 0x1d;\n#else\n\t/* these were divined */\n\tsp->sp_max_retry = 0x03;\n\n\tsp->sp_ack_timo = 0xa3;\n\tsp->sp_sifs = 0x1d;\n#endif\n#if 0\n\t/* these are the documented defaults for build 5/6 */\n\tsp->sp_difs = 0x82;\n\tsp->sp_pifs = 0;\n#else\n\t/* linux/fbsd */\n\tsp->sp_difs = 0x82;\n\n\tif (sc->sc_version == SC_BUILD_4)\n\t\tsp->sp_pifs = 0xce;\n\telse\n\t\tsp->sp_pifs = 0x4e;\n#endif\n\n\tPUT2(sp->sp_rts_thresh, 0x7fff);\t/* disabled */\n\tif (sc->sc_version == SC_BUILD_4) {\n\t\tPUT2(sp->sp_scan_dwell, 0xfb1e);\n\t\tPUT2(sp->sp_scan_max_dwell, 0xc75c);\n\t} else {\n\t\tPUT2(sp->sp_scan_dwell, 0x4e2);\n\t\tPUT2(sp->sp_scan_max_dwell, 0x38a4);\n\t}\n\tsp->sp_assoc_timo = 0x5;\n\tif (sc->sc_version == SC_BUILD_4) {\n#if 1 /* obsd */\n\t\t/* linux/fbsd */\n\t\tsp->sp_adhoc_scan_cycle = 0x4;\n\t\tsp->sp_infra_scan_cycle = 0x2;\n\t\tsp->sp_infra_super_scan_cycle = 0x4;\n#else\n\t\t/* divined */\n\t\tsp->sp_adhoc_scan_cycle = 0x8;\n\t\tsp->sp_infra_scan_cycle = 0x1;\n\t\tsp->sp_infra_super_scan_cycle = 0x18;\n#endif\n\t} else {\n\t\tsp->sp_adhoc_scan_cycle = 0x8;\n\t\tsp->sp_infra_scan_cycle = 0x2;\n\t\tsp->sp_infra_super_scan_cycle = 0x8;\n\t}\n\tsp->sp_promisc = sc->sc_promisc;\n\tPUT2(sp->sp_uniq_word, 0x0cbd);\n\tif (sc->sc_version == SC_BUILD_4) {\n\t/* XXX whats this value anyway.. the std says 50us */\n\t\t/* XXX sp->sp_slot_time = 0x4e; */\n\t\tsp->sp_slot_time = 0x4e;\n#if 1\n\t\t/*linux/fbsd*/\n\t\tsp->sp_roam_low_snr_thresh = 0xff;\n#else\n\t\t/*divined*/\n\t\tsp->sp_roam_low_snr_thresh = 0x30;\n#endif\n\t} else {\n\t\tsp->sp_slot_time = 0x32;\n\t\tsp->sp_roam_low_snr_thresh = 0xff;\t/* disabled */\n\t}\n#if 1\n\tsp->sp_low_snr_count = 0xff;\t\t/* disabled */\n#else\n\t/* divined -- check */\n\tsp->sp_low_snr_count = 0x07;\t\t/* disabled */\n#endif\n#if 0\n\tsp->sp_infra_missed_beacon_count = 0x2;\n#elif 1\n\t/* linux/fbsd */\n\tsp->sp_infra_missed_beacon_count = 0x5;\n#else\n\t/* divined -- check, looks fishy */\n\tsp->sp_infra_missed_beacon_count = 0x7;\n#endif\n\tsp->sp_adhoc_missed_beacon_count = 0xff;\n\tsp->sp_country_code = sc->sc_dcountrycode;\n\tsp->sp_hop_seq = 0x0b;\n\tif (sc->sc_version == SC_BUILD_4) {\n\t\tsp->sp_hop_seq_len = 0x4e;\n\t\tsp4->sp_cw_max = 0x3f;\t/* single byte on build 4 */\n\t\tsp4->sp_cw_min = 0x0f;\t/* single byte on build 4 */\n\t\tsp4->sp_noise_filter_gain = 0x4;\n\t\tsp4->sp_noise_limit_offset = 0x8;\n\t\tsp4->sp_rssi_thresh_offset = 0x28;\n\t\tsp4->sp_busy_thresh_offset = 0x28;\n\t\tsp4->sp_sync_thresh = 0x07;\n\t\tsp4->sp_test_mode = 0x0;\n\t\tsp4->sp_test_min_chan = 0x2;\n\t\tsp4->sp_test_max_chan = 0x2;\n\t} else {\n\t\tsp->sp_hop_seq_len = 0x4f;\n\t\tPUT2(sp5->sp_cw_max, 0x3f);\n\t\tPUT2(sp5->sp_cw_min, 0x0f);\n\t\tsp5->sp_noise_filter_gain = 0x4;\n\t\tsp5->sp_noise_limit_offset = 0x8;\n\t\tsp5->sp_rssi_thresh_offset = 0x28;\n\t\tsp5->sp_busy_thresh_offset = 0x28;\n\t\tsp5->sp_sync_thresh = 0x07;\n\t\tsp5->sp_test_mode = 0x0;\n\t\tsp5->sp_test_min_chan = 0x2;\n\t\tsp5->sp_test_max_chan = 0x2;\n#if 0\n\t\tsp5->sp_allow_probe_resp = 0x1;\n#else\n\t\tsp5->sp_allow_probe_resp = 0x0;\n#endif\n\t\tsp5->sp_privacy_must_start = 0x0;\n\t\tsp5->sp_privacy_can_join = 0x0;\n\t\tsp5->sp_basic_rate_set[0] = 0x2;\n\t\t    /* 2 = 1Mbps, 3 = old 2Mbps 4 = 2Mbps */\n\t}\n\n\t/* we shouldn't be called with some command pending */\n\tif (!RAY_ECF_READY(sc))\n\t\tpanic(\"ray_download_params busy\");\n\n\t/* write the compatible part */\n\toff = RAY_HOST_TO_ECF_BASE;\n\tray_write_region(sc, off, sp, sizeof(sc->sc_startup));\n\toff += sizeof(sc->sc_startup);\n\tif (sc->sc_version == SC_BUILD_4)\n\t\tray_write_region(sc, off, sp4, sizeof(*sp4));\n\telse\n\t\tray_write_region(sc, off, sp5, sizeof(*sp5));\n\tif (!ray_simple_cmd(sc, RAY_CMD_START_PARAMS, SCP_UPD_STARTUP))\n\t\tpanic(\"ray_download_params issue\");\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tSC_BUILD_4\t0x55",
            "#define\tSCP_UPD_STARTUP\t\t0x0100",
            "#define\tsc_xname\tsc_dev.dv_xname",
            "#define\tsc_version\tsc_ecf_startup.e_fw_build_string",
            "#define\tsc_startup_5\tsc_u.u_params_5",
            "#define\tsc_startup_4\tsc_u.u_params_4"
          ],
          "globals_used": [
            "void ray_cmd_cancel",
            "void ray_download_params",
            "int ray_simple_cmd"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSC_BUILD_4\t0x55\n#define\tSCP_UPD_STARTUP\t\t0x0100\n#define\tsc_xname\tsc_dev.dv_xname\n#define\tsc_version\tsc_ecf_startup.e_fw_build_string\n#define\tsc_startup_5\tsc_u.u_params_5\n#define\tsc_startup_4\tsc_u.u_params_4\n\nvoid ray_cmd_cancel;\nvoid ray_download_params;\nint ray_simple_cmd;\n\nvoid\nray_download_params(sc)\n\tstruct ray_softc *sc;\n{\n\tstruct ray_startup_params_head *sp;\n\tstruct ray_startup_params_tail_5 *sp5;\n\tstruct ray_startup_params_tail_4 *sp4;\n\tbus_size_t off;\n\n\tRAY_DPRINTF((\"%s: init_startup_params\\n\", sc->sc_xname));\n\n\tray_cmd_cancel(sc, SCP_UPD_STARTUP);\n\n#define\tPUT2(p, v)\t\\\n\tdo { (p)[0] = ((v >> 8) & 0xff); (p)[1] = (v & 0xff); } while(0)\n\n\tsp = &sc->sc_startup;\n\tsp4 = &sc->sc_startup_4;\n\tsp5 = &sc->sc_startup_5;\n\tmemset(sp, 0, sizeof(*sp));\n\tif (sc->sc_version == SC_BUILD_4)\n\t\tmemset(sp4, 0, sizeof(*sp4));\n\telse\n\t\tmemset(sp5, 0, sizeof(*sp5));\n\tmemcpy(sp->sp_ssid, sc->sc_dnwid, sizeof(sp->sp_ssid));\n\tsp->sp_scan_mode = 0x1;\n\tmemcpy(sp->sp_mac_addr, sc->sc_ecf_startup.e_station_addr,\n\t    ETHER_ADDR_LEN);\n\tPUT2(sp->sp_frag_thresh, 0x7fff);\t/* disabled */\n\tif (sc->sc_version == SC_BUILD_4) {\n#if 1\n\t\t/* linux/fbsd */\n\t\tPUT2(sp->sp_dwell_time, 0x200);\n\t\tPUT2(sp->sp_beacon_period, 1);\n#else\n\t\t/* divined */\n\t\tPUT2(sp->sp_dwell_time, 0x400);\n\t\tPUT2(sp->sp_beacon_period, 0);\n#endif\n\t} else {\n\t\tPUT2(sp->sp_dwell_time, 128);\n\t\tPUT2(sp->sp_beacon_period, 256);\n\t}\n\tsp->sp_dtim_interval = 1;\n#if 0\n\t/* these are the documented defaults for build 5/6 */\n\tsp->sp_max_retry = 0x1f;\n\tsp->sp_ack_timo = 0x86;\n\tsp->sp_sifs = 0x1c;\n#elif 1\n\t/* these were scrounged from the linux driver */\n\tsp->sp_max_retry = 0x07;\n\n\tsp->sp_ack_timo = 0xa3;\n\tsp->sp_sifs = 0x1d;\n#else\n\t/* these were divined */\n\tsp->sp_max_retry = 0x03;\n\n\tsp->sp_ack_timo = 0xa3;\n\tsp->sp_sifs = 0x1d;\n#endif\n#if 0\n\t/* these are the documented defaults for build 5/6 */\n\tsp->sp_difs = 0x82;\n\tsp->sp_pifs = 0;\n#else\n\t/* linux/fbsd */\n\tsp->sp_difs = 0x82;\n\n\tif (sc->sc_version == SC_BUILD_4)\n\t\tsp->sp_pifs = 0xce;\n\telse\n\t\tsp->sp_pifs = 0x4e;\n#endif\n\n\tPUT2(sp->sp_rts_thresh, 0x7fff);\t/* disabled */\n\tif (sc->sc_version == SC_BUILD_4) {\n\t\tPUT2(sp->sp_scan_dwell, 0xfb1e);\n\t\tPUT2(sp->sp_scan_max_dwell, 0xc75c);\n\t} else {\n\t\tPUT2(sp->sp_scan_dwell, 0x4e2);\n\t\tPUT2(sp->sp_scan_max_dwell, 0x38a4);\n\t}\n\tsp->sp_assoc_timo = 0x5;\n\tif (sc->sc_version == SC_BUILD_4) {\n#if 1 /* obsd */\n\t\t/* linux/fbsd */\n\t\tsp->sp_adhoc_scan_cycle = 0x4;\n\t\tsp->sp_infra_scan_cycle = 0x2;\n\t\tsp->sp_infra_super_scan_cycle = 0x4;\n#else\n\t\t/* divined */\n\t\tsp->sp_adhoc_scan_cycle = 0x8;\n\t\tsp->sp_infra_scan_cycle = 0x1;\n\t\tsp->sp_infra_super_scan_cycle = 0x18;\n#endif\n\t} else {\n\t\tsp->sp_adhoc_scan_cycle = 0x8;\n\t\tsp->sp_infra_scan_cycle = 0x2;\n\t\tsp->sp_infra_super_scan_cycle = 0x8;\n\t}\n\tsp->sp_promisc = sc->sc_promisc;\n\tPUT2(sp->sp_uniq_word, 0x0cbd);\n\tif (sc->sc_version == SC_BUILD_4) {\n\t/* XXX whats this value anyway.. the std says 50us */\n\t\t/* XXX sp->sp_slot_time = 0x4e; */\n\t\tsp->sp_slot_time = 0x4e;\n#if 1\n\t\t/*linux/fbsd*/\n\t\tsp->sp_roam_low_snr_thresh = 0xff;\n#else\n\t\t/*divined*/\n\t\tsp->sp_roam_low_snr_thresh = 0x30;\n#endif\n\t} else {\n\t\tsp->sp_slot_time = 0x32;\n\t\tsp->sp_roam_low_snr_thresh = 0xff;\t/* disabled */\n\t}\n#if 1\n\tsp->sp_low_snr_count = 0xff;\t\t/* disabled */\n#else\n\t/* divined -- check */\n\tsp->sp_low_snr_count = 0x07;\t\t/* disabled */\n#endif\n#if 0\n\tsp->sp_infra_missed_beacon_count = 0x2;\n#elif 1\n\t/* linux/fbsd */\n\tsp->sp_infra_missed_beacon_count = 0x5;\n#else\n\t/* divined -- check, looks fishy */\n\tsp->sp_infra_missed_beacon_count = 0x7;\n#endif\n\tsp->sp_adhoc_missed_beacon_count = 0xff;\n\tsp->sp_country_code = sc->sc_dcountrycode;\n\tsp->sp_hop_seq = 0x0b;\n\tif (sc->sc_version == SC_BUILD_4) {\n\t\tsp->sp_hop_seq_len = 0x4e;\n\t\tsp4->sp_cw_max = 0x3f;\t/* single byte on build 4 */\n\t\tsp4->sp_cw_min = 0x0f;\t/* single byte on build 4 */\n\t\tsp4->sp_noise_filter_gain = 0x4;\n\t\tsp4->sp_noise_limit_offset = 0x8;\n\t\tsp4->sp_rssi_thresh_offset = 0x28;\n\t\tsp4->sp_busy_thresh_offset = 0x28;\n\t\tsp4->sp_sync_thresh = 0x07;\n\t\tsp4->sp_test_mode = 0x0;\n\t\tsp4->sp_test_min_chan = 0x2;\n\t\tsp4->sp_test_max_chan = 0x2;\n\t} else {\n\t\tsp->sp_hop_seq_len = 0x4f;\n\t\tPUT2(sp5->sp_cw_max, 0x3f);\n\t\tPUT2(sp5->sp_cw_min, 0x0f);\n\t\tsp5->sp_noise_filter_gain = 0x4;\n\t\tsp5->sp_noise_limit_offset = 0x8;\n\t\tsp5->sp_rssi_thresh_offset = 0x28;\n\t\tsp5->sp_busy_thresh_offset = 0x28;\n\t\tsp5->sp_sync_thresh = 0x07;\n\t\tsp5->sp_test_mode = 0x0;\n\t\tsp5->sp_test_min_chan = 0x2;\n\t\tsp5->sp_test_max_chan = 0x2;\n#if 0\n\t\tsp5->sp_allow_probe_resp = 0x1;\n#else\n\t\tsp5->sp_allow_probe_resp = 0x0;\n#endif\n\t\tsp5->sp_privacy_must_start = 0x0;\n\t\tsp5->sp_privacy_can_join = 0x0;\n\t\tsp5->sp_basic_rate_set[0] = 0x2;\n\t\t    /* 2 = 1Mbps, 3 = old 2Mbps 4 = 2Mbps */\n\t}\n\n\t/* we shouldn't be called with some command pending */\n\tif (!RAY_ECF_READY(sc))\n\t\tpanic(\"ray_download_params busy\");\n\n\t/* write the compatible part */\n\toff = RAY_HOST_TO_ECF_BASE;\n\tray_write_region(sc, off, sp, sizeof(sc->sc_startup));\n\toff += sizeof(sc->sc_startup);\n\tif (sc->sc_version == SC_BUILD_4)\n\t\tray_write_region(sc, off, sp4, sizeof(*sp4));\n\telse\n\t\tray_write_region(sc, off, sp5, sizeof(*sp5));\n\tif (!ray_simple_cmd(sc, RAY_CMD_START_PARAMS, SCP_UPD_STARTUP))\n\t\tpanic(\"ray_download_params issue\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "REG_WRITE",
          "args": [
            "sc",
            "RAY_HCSIR",
            "0"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRAM_WRITE_FIELD_1",
          "args": [
            "sc",
            "ccs",
            "ray_cmd",
            "c_status",
            "RAY_CCS_STATUS_FREE"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_GET_CCS",
          "args": [
            "0"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: card failed self test: status %d\\n\"",
            "sc->sc_xname",
            "sc->sc_ecf_startup.e_status"
          ],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_function_disable",
          "args": [
            "sc->sc_pf"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_function_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "570-622",
          "snippet": "void\npcmcia_function_disable(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct pcmcia_function *tmp;\n\n\tif (pf->cfe == NULL)\n\t\tpanic(\"pcmcia_function_enable: function not initialized\");\n\n\tif ((pf->pf_flags & PFF_ENABLED) == 0) {\n\t\t/*\n\t\t * Don't do anything if we're already disabled.\n\t\t */\n\t\treturn;\n\t}\n\n\t/* If there was no CIS don't mess with CCR */\n\tif (pf->pf_flags & PFF_FAKE) {\n\t\tpf->pf_flags &= ~PFF_ENABLED;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * it's possible for different functions' CCRs to be in the same\n\t * underlying page.  Check for that.  Note we mark us as disabled\n\t * first to avoid matching ourself.\n\t */\n\tpf->pf_flags &= ~PFF_ENABLED;\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t    tmp = tmp->pf_list.sqe_next) {\n\t\tif ((tmp->pf_flags & PFF_ENABLED) &&\n\t\t    (pf->ccr_base >= (tmp->ccr_base - tmp->pf_ccr_offset)) &&\n\t\t    ((pf->ccr_base + PCMCIA_CCR_SIZE) <=\n\t\t(tmp->ccr_base - tmp->pf_ccr_offset + tmp->pf_ccr_realsize)))\n\t\t\tbreak;\n\t}\n\n\t/* Not used by anyone else; unmap the CCR. */\n\tif (tmp == NULL) {\n\t\tpcmcia_mem_unmap(pf, pf->pf_ccr_window);\n\t\tpcmcia_mem_free(pf, &pf->pf_pcmh);\n\t}\n\n done:\n\t/*\n\t * Decrement the reference count, and power down the socket, if\n\t * necessary.\n\t */\n\tif (--pf->sc->sc_enabled_count == 0)\n\t\tpcmcia_chip_socket_disable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: --enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\n\nvoid\npcmcia_function_disable(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct pcmcia_function *tmp;\n\n\tif (pf->cfe == NULL)\n\t\tpanic(\"pcmcia_function_enable: function not initialized\");\n\n\tif ((pf->pf_flags & PFF_ENABLED) == 0) {\n\t\t/*\n\t\t * Don't do anything if we're already disabled.\n\t\t */\n\t\treturn;\n\t}\n\n\t/* If there was no CIS don't mess with CCR */\n\tif (pf->pf_flags & PFF_FAKE) {\n\t\tpf->pf_flags &= ~PFF_ENABLED;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * it's possible for different functions' CCRs to be in the same\n\t * underlying page.  Check for that.  Note we mark us as disabled\n\t * first to avoid matching ourself.\n\t */\n\tpf->pf_flags &= ~PFF_ENABLED;\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t    tmp = tmp->pf_list.sqe_next) {\n\t\tif ((tmp->pf_flags & PFF_ENABLED) &&\n\t\t    (pf->ccr_base >= (tmp->ccr_base - tmp->pf_ccr_offset)) &&\n\t\t    ((pf->ccr_base + PCMCIA_CCR_SIZE) <=\n\t\t(tmp->ccr_base - tmp->pf_ccr_offset + tmp->pf_ccr_realsize)))\n\t\t\tbreak;\n\t}\n\n\t/* Not used by anyone else; unmap the CCR. */\n\tif (tmp == NULL) {\n\t\tpcmcia_mem_unmap(pf, pf->pf_ccr_window);\n\t\tpcmcia_mem_free(pf, &pf->pf_pcmh);\n\t}\n\n done:\n\t/*\n\t * Decrement the reference count, and power down the socket, if\n\t * necessary.\n\t */\n\tif (--pf->sc->sc_enabled_count == 0)\n\t\tpcmcia_chip_socket_disable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: --enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ray_read_region",
          "args": [
            "sc",
            "RAY_ECF_TO_HOST_BASE",
            "ep",
            "sizeof(sc->sc_ecf_startup)"
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "ray_read_region",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "3063-3116",
          "snippet": "void\nray_read_region(sc, off, vp, c)\n\tstruct ray_softc *sc;\n\tbus_size_t off;\n\tvoid *vp;\n\tsize_t c;\n{\n#ifdef RAY_USE_OPTIMIZED_COPY\n\tu_int n2, n4, tmp;\n\tu_int8_t *p;\n\n\tp = vp;\n\n\t/* XXX we may be making poor assumptions here but lets hope */\n\tswitch ((off|(bus_addr_t)p) & 0x03) {\n\tcase 0:\n\t\tif ((n4 = c / 4)) {\n\t\t\tbus_space_read_region_4(sc->sc_memt, sc->sc_memh, off,\n\t\t\t    p, n4);\n\t\t\ttmp = c & ~0x3;\n\t\t\tc &= 0x3;\n\t\t\tp += tmp;\n\t\t\toff += tmp;\n\t\t}\n\t\tswitch (c) {\n\t\tcase 3:\n\t\t\t*p = bus_space_read_1(sc->sc_memt,sc->sc_memh, off);\n\t\t\tp++, off++;\n\t\tcase 2:\n\t\t\t*p = bus_space_read_1(sc->sc_memt,sc->sc_memh, off);\n\t\t\tp++, off++;\n\t\tcase 1:\n\t\t\t*p = bus_space_read_1(sc->sc_memt,sc->sc_memh, off);\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tif ((n2 = (c >> 1)))\n\t\t\tbus_space_read_region_2(sc->sc_memt, sc->sc_memh, off,\n\t\t\t    p, n2);\n\t\tif (c & 1) {\n\t\t\tc &= ~0x1;\n\t\t\t*(p + c) = bus_space_read_1(sc->sc_memt, sc->sc_memh,\n\t\t\t    off + c);\n\t\t}\n\t\tbreak;\n\tcase 1:\n\tcase 3:\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_memh, off, p, c);\n\t\tbreak;\n\t}\n#else\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_memh, off, vp, c);\n#endif\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tsc_memh\tsc_mem.memh",
            "#define\tsc_memt\tsc_mem.memt"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_memh\tsc_mem.memh\n#define\tsc_memt\tsc_mem.memt\n\nvoid\nray_read_region(sc, off, vp, c)\n\tstruct ray_softc *sc;\n\tbus_size_t off;\n\tvoid *vp;\n\tsize_t c;\n{\n#ifdef RAY_USE_OPTIMIZED_COPY\n\tu_int n2, n4, tmp;\n\tu_int8_t *p;\n\n\tp = vp;\n\n\t/* XXX we may be making poor assumptions here but lets hope */\n\tswitch ((off|(bus_addr_t)p) & 0x03) {\n\tcase 0:\n\t\tif ((n4 = c / 4)) {\n\t\t\tbus_space_read_region_4(sc->sc_memt, sc->sc_memh, off,\n\t\t\t    p, n4);\n\t\t\ttmp = c & ~0x3;\n\t\t\tc &= 0x3;\n\t\t\tp += tmp;\n\t\t\toff += tmp;\n\t\t}\n\t\tswitch (c) {\n\t\tcase 3:\n\t\t\t*p = bus_space_read_1(sc->sc_memt,sc->sc_memh, off);\n\t\t\tp++, off++;\n\t\tcase 2:\n\t\t\t*p = bus_space_read_1(sc->sc_memt,sc->sc_memh, off);\n\t\t\tp++, off++;\n\t\tcase 1:\n\t\t\t*p = bus_space_read_1(sc->sc_memt,sc->sc_memh, off);\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tif ((n2 = (c >> 1)))\n\t\t\tbus_space_read_region_2(sc->sc_memt, sc->sc_memh, off,\n\t\t\t    p, n2);\n\t\tif (c & 1) {\n\t\t\tc &= ~0x1;\n\t\t\t*(p + c) = bus_space_read_1(sc->sc_memt, sc->sc_memh,\n\t\t\t    off + c);\n\t\t}\n\t\tbreak;\n\tcase 1:\n\tcase 3:\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_memh, off, p, c);\n\t\tbreak;\n\t}\n#else\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_memh, off, vp, c);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "sc->sc_bssid",
            "0",
            "sizeof(sc->sc_bssid)"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "sc->sc_ccsinuse",
            "0",
            "sizeof(sc->sc_ccsinuse)"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: init post-enable\\n\", sc->sc_xname)"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_function_enable",
          "args": [
            "sc->sc_pf"
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_function_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "419-567",
          "snippet": "int\npcmcia_function_enable(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct pcmcia_function *tmp;\n\tint reg;\n\n\tif (pf->cfe == NULL)\n\t\tpanic(\"pcmcia_function_enable: function not initialized\");\n\n\t/*\n\t * Increase the reference count on the socket, enabling power, if\n\t * necessary.\n\t */\n\tif (pf->sc->sc_enabled_count++ == 0)\n\t\tpcmcia_chip_socket_enable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: ++enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n\n\tif (pf->pf_flags & PFF_ENABLED) {\n\t\t/*\n\t\t * Don't do anything if we're already enabled.\n\t\t */\n\t\tDPRINTF((\"%s: pcmcia_function_enable on enabled func\\n\"));\n\t\treturn (0);\n\t}\n\n\t/* If there was no CIS don't mess with CCR */\n\tif (pf->pf_flags & PFF_FAKE)\n\t\tgoto done;\n\n\t/*\n\t * It's possible for different functions' CCRs to be in the same\n\t * underlying page.  Check for that.\n\t */\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t    tmp = tmp->pf_list.sqe_next) {\n\t\tif ((tmp->pf_flags & PFF_ENABLED) &&\n\t\t    (pf->ccr_base >= (tmp->ccr_base - tmp->pf_ccr_offset)) &&\n\t\t    ((pf->ccr_base + PCMCIA_CCR_SIZE) <=\n\t\t     (tmp->ccr_base - tmp->pf_ccr_offset +\n\t\t      tmp->pf_ccr_realsize))) {\n\t\t\tpf->pf_ccrt = tmp->pf_ccrt;\n\t\t\tpf->pf_ccrh = tmp->pf_ccrh;\n\t\t\tpf->pf_ccr_realsize = tmp->pf_ccr_realsize;\n\n\t\t\t/*\n\t\t\t * pf->pf_ccr_offset = (tmp->pf_ccr_offset -\n\t\t\t * tmp->ccr_base) + pf->ccr_base;\n\t\t\t */\n\t\t\tpf->pf_ccr_offset =\n\t\t\t    (tmp->pf_ccr_offset + pf->ccr_base) -\n\t\t\t    tmp->ccr_base;\n\t\t\tpf->pf_ccr_window = tmp->pf_ccr_window;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (tmp == NULL) {\n\t\tif (pcmcia_mem_alloc(pf, PCMCIA_CCR_SIZE, &pf->pf_pcmh))\n\t\t\tgoto bad;\n\n\t\tif (pcmcia_mem_map(pf, PCMCIA_MEM_ATTR, pf->ccr_base,\n\t\t    PCMCIA_CCR_SIZE, &pf->pf_pcmh, &pf->pf_ccr_offset,\n\t\t    &pf->pf_ccr_window)) {\n\t\t\tpcmcia_mem_free(pf, &pf->pf_pcmh);\n\t\t\tgoto bad;\n\t\t}\n\t}\n\n\treg = (pf->cfe->number & PCMCIA_CCR_OPTION_CFINDEX);\n\treg |= PCMCIA_CCR_OPTION_LEVIREQ;\n\tif (pcmcia_mfc(pf->sc)) {\n\t\treg |= (PCMCIA_CCR_OPTION_FUNC_ENABLE |\n\t\t\tPCMCIA_CCR_OPTION_ADDR_DECODE);\n\t\tif (pf->ih_fct)\n\t\t\treg |= PCMCIA_CCR_OPTION_IREQ_ENABLE;\n\n\t}\n\t\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\n\treg = 0;\n\n\tif ((pf->cfe->flags & PCMCIA_CFE_IO16) == 0)\n\t\treg |= PCMCIA_CCR_STATUS_IOIS8;\n\tif (pf->cfe->flags & PCMCIA_CFE_AUDIO)\n\t\treg |= PCMCIA_CCR_STATUS_AUDIO;\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_STATUS, reg);\n\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_SOCKETCOPY, 0);\n\t\n\tif (pcmcia_mfc(pf->sc)) {\n\t\tlong tmp, iosize;\n\n\t\ttmp = pf->pf_mfc_iomax - pf->pf_mfc_iobase;\n\t\t/* round up to nearest (2^n)-1 */\n\t\tfor (iosize = 1; iosize < tmp; iosize <<= 1)\n\t\t\t;\n\t\tiosize--;\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE0,\n\t\t\t\t pf->pf_mfc_iobase & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE1,\n\t\t\t\t (pf->pf_mfc_iobase >> 8) & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE2, 0);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE3, 0);\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOSIZE, iosize);\n\t}\n\n#ifdef PCMCIADEBUG\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t     tmp = tmp->pf_list.sqe_next) {\n\t\tprintf(\"%s: function %d CCR at %d offset %lx: \"\n\t\t       \"%x %x %x %x, %x %x %x %x, %x\\n\",\n\t\t       tmp->sc->dev.dv_xname, tmp->number,\n\t\t       tmp->pf_ccr_window, tmp->pf_ccr_offset,\n\t\t       pcmcia_ccr_read(tmp, 0x00),\n\t\t       pcmcia_ccr_read(tmp, 0x02),\n\t\t       pcmcia_ccr_read(tmp, 0x04),\n\t\t       pcmcia_ccr_read(tmp, 0x06),\n\n\t\t       pcmcia_ccr_read(tmp, 0x0A),\n\t\t       pcmcia_ccr_read(tmp, 0x0C), \n\t\t       pcmcia_ccr_read(tmp, 0x0E),\n\t\t       pcmcia_ccr_read(tmp, 0x10),\n\n\t\t       pcmcia_ccr_read(tmp, 0x12));\n\t}\n#endif\n\n done:\n\tpf->pf_flags |= PFF_ENABLED;\n\tdelay(1000);\n\treturn (0);\n\n bad:\n\t/*\n\t * Decrement the reference count, and power down the socket, if\n\t * necessary.\n\t */\n\tif (--pf->sc->sc_enabled_count == 0)\n\t\tpcmcia_chip_socket_disable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: --enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n\n\treturn (1);\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;",
            "int (*ih_fct)"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\nint (*ih_fct);\n\nint\npcmcia_function_enable(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct pcmcia_function *tmp;\n\tint reg;\n\n\tif (pf->cfe == NULL)\n\t\tpanic(\"pcmcia_function_enable: function not initialized\");\n\n\t/*\n\t * Increase the reference count on the socket, enabling power, if\n\t * necessary.\n\t */\n\tif (pf->sc->sc_enabled_count++ == 0)\n\t\tpcmcia_chip_socket_enable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: ++enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n\n\tif (pf->pf_flags & PFF_ENABLED) {\n\t\t/*\n\t\t * Don't do anything if we're already enabled.\n\t\t */\n\t\tDPRINTF((\"%s: pcmcia_function_enable on enabled func\\n\"));\n\t\treturn (0);\n\t}\n\n\t/* If there was no CIS don't mess with CCR */\n\tif (pf->pf_flags & PFF_FAKE)\n\t\tgoto done;\n\n\t/*\n\t * It's possible for different functions' CCRs to be in the same\n\t * underlying page.  Check for that.\n\t */\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t    tmp = tmp->pf_list.sqe_next) {\n\t\tif ((tmp->pf_flags & PFF_ENABLED) &&\n\t\t    (pf->ccr_base >= (tmp->ccr_base - tmp->pf_ccr_offset)) &&\n\t\t    ((pf->ccr_base + PCMCIA_CCR_SIZE) <=\n\t\t     (tmp->ccr_base - tmp->pf_ccr_offset +\n\t\t      tmp->pf_ccr_realsize))) {\n\t\t\tpf->pf_ccrt = tmp->pf_ccrt;\n\t\t\tpf->pf_ccrh = tmp->pf_ccrh;\n\t\t\tpf->pf_ccr_realsize = tmp->pf_ccr_realsize;\n\n\t\t\t/*\n\t\t\t * pf->pf_ccr_offset = (tmp->pf_ccr_offset -\n\t\t\t * tmp->ccr_base) + pf->ccr_base;\n\t\t\t */\n\t\t\tpf->pf_ccr_offset =\n\t\t\t    (tmp->pf_ccr_offset + pf->ccr_base) -\n\t\t\t    tmp->ccr_base;\n\t\t\tpf->pf_ccr_window = tmp->pf_ccr_window;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (tmp == NULL) {\n\t\tif (pcmcia_mem_alloc(pf, PCMCIA_CCR_SIZE, &pf->pf_pcmh))\n\t\t\tgoto bad;\n\n\t\tif (pcmcia_mem_map(pf, PCMCIA_MEM_ATTR, pf->ccr_base,\n\t\t    PCMCIA_CCR_SIZE, &pf->pf_pcmh, &pf->pf_ccr_offset,\n\t\t    &pf->pf_ccr_window)) {\n\t\t\tpcmcia_mem_free(pf, &pf->pf_pcmh);\n\t\t\tgoto bad;\n\t\t}\n\t}\n\n\treg = (pf->cfe->number & PCMCIA_CCR_OPTION_CFINDEX);\n\treg |= PCMCIA_CCR_OPTION_LEVIREQ;\n\tif (pcmcia_mfc(pf->sc)) {\n\t\treg |= (PCMCIA_CCR_OPTION_FUNC_ENABLE |\n\t\t\tPCMCIA_CCR_OPTION_ADDR_DECODE);\n\t\tif (pf->ih_fct)\n\t\t\treg |= PCMCIA_CCR_OPTION_IREQ_ENABLE;\n\n\t}\n\t\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\n\treg = 0;\n\n\tif ((pf->cfe->flags & PCMCIA_CFE_IO16) == 0)\n\t\treg |= PCMCIA_CCR_STATUS_IOIS8;\n\tif (pf->cfe->flags & PCMCIA_CFE_AUDIO)\n\t\treg |= PCMCIA_CCR_STATUS_AUDIO;\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_STATUS, reg);\n\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_SOCKETCOPY, 0);\n\t\n\tif (pcmcia_mfc(pf->sc)) {\n\t\tlong tmp, iosize;\n\n\t\ttmp = pf->pf_mfc_iomax - pf->pf_mfc_iobase;\n\t\t/* round up to nearest (2^n)-1 */\n\t\tfor (iosize = 1; iosize < tmp; iosize <<= 1)\n\t\t\t;\n\t\tiosize--;\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE0,\n\t\t\t\t pf->pf_mfc_iobase & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE1,\n\t\t\t\t (pf->pf_mfc_iobase >> 8) & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE2, 0);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE3, 0);\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOSIZE, iosize);\n\t}\n\n#ifdef PCMCIADEBUG\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t     tmp = tmp->pf_list.sqe_next) {\n\t\tprintf(\"%s: function %d CCR at %d offset %lx: \"\n\t\t       \"%x %x %x %x, %x %x %x %x, %x\\n\",\n\t\t       tmp->sc->dev.dv_xname, tmp->number,\n\t\t       tmp->pf_ccr_window, tmp->pf_ccr_offset,\n\t\t       pcmcia_ccr_read(tmp, 0x00),\n\t\t       pcmcia_ccr_read(tmp, 0x02),\n\t\t       pcmcia_ccr_read(tmp, 0x04),\n\t\t       pcmcia_ccr_read(tmp, 0x06),\n\n\t\t       pcmcia_ccr_read(tmp, 0x0A),\n\t\t       pcmcia_ccr_read(tmp, 0x0C), \n\t\t       pcmcia_ccr_read(tmp, 0x0E),\n\t\t       pcmcia_ccr_read(tmp, 0x10),\n\n\t\t       pcmcia_ccr_read(tmp, 0x12));\n\t}\n#endif\n\n done:\n\tpf->pf_flags |= PFF_ENABLED;\n\tdelay(1000);\n\treturn (0);\n\n bad:\n\t/*\n\t * Decrement the reference count, and power down the socket, if\n\t * necessary.\n\t */\n\tif (--pf->sc->sc_enabled_count == 0)\n\t\tpcmcia_chip_socket_disable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: --enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ray_stop",
          "args": [
            "sc"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "ray_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "924-947",
          "snippet": "void\nray_stop(sc)\n\tstruct ray_softc *sc;\n{\n\tRAY_DPRINTF((\"%s: stop\\n\", sc->sc_xname));\n\n\tcallout_stop(&sc->sc_check_ccs_ch);\n\tsc->sc_timocheck = 0;\n\n\tcallout_stop(&sc->sc_check_scheduled_ch);\n\tsc->sc_timoneed = 0;\n\n\tif (sc->sc_repreq) {\n\t\tsc->sc_repreq->r_failcause = RAY_FAILCAUSE_EDEVSTOP;\n\t\twakeup(ray_report_params);\n\t}\n\tif (sc->sc_updreq) {\n\t\tsc->sc_repreq->r_failcause = RAY_FAILCAUSE_EDEVSTOP;\n\t\twakeup(ray_update_params);\n\t}\n\n\tsc->sc_if.if_flags &= ~IFF_RUNNING;\n\tpcmcia_function_disable(sc->sc_pf);\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tsc_xname\tsc_dev.dv_xname",
            "#define\tsc_if\t\tsc_ec.ac_if",
            "#define\tsc_if\t\tsc_ec.ec_if",
            "#define\tcallout_stop\ttimeout_del"
          ],
          "globals_used": [
            "void ray_report_params",
            "void ray_stop",
            "void ray_update_params"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_xname\tsc_dev.dv_xname\n#define\tsc_if\t\tsc_ec.ac_if\n#define\tsc_if\t\tsc_ec.ec_if\n#define\tcallout_stop\ttimeout_del\n\nvoid ray_report_params;\nvoid ray_stop;\nvoid ray_update_params;\n\nvoid\nray_stop(sc)\n\tstruct ray_softc *sc;\n{\n\tRAY_DPRINTF((\"%s: stop\\n\", sc->sc_xname));\n\n\tcallout_stop(&sc->sc_check_ccs_ch);\n\tsc->sc_timocheck = 0;\n\n\tcallout_stop(&sc->sc_check_scheduled_ch);\n\tsc->sc_timoneed = 0;\n\n\tif (sc->sc_repreq) {\n\t\tsc->sc_repreq->r_failcause = RAY_FAILCAUSE_EDEVSTOP;\n\t\twakeup(ray_report_params);\n\t}\n\tif (sc->sc_updreq) {\n\t\tsc->sc_repreq->r_failcause = RAY_FAILCAUSE_EDEVSTOP;\n\t\twakeup(ray_update_params);\n\t}\n\n\tsc->sc_if.if_flags &= ~IFF_RUNNING;\n\tpcmcia_function_disable(sc->sc_pf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: init\\n\", sc->sc_xname)"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSC_BUILD_4\t0x55\n#define\tsc_xname\tsc_dev.dv_xname\n#define\tsc_if\t\tsc_ec.ac_if\n#define\tsc_if\t\tsc_ec.ec_if\n#define\tsc_tibsize\tsc_ecf_startup.e_tib_size\n#define\tsc_version\tsc_ecf_startup.e_fw_build_string\n\nvoid ray_download_params;\nint ray_init;\nvoid ray_stop;\n\nint\nray_init(sc)\n\tstruct ray_softc *sc;\n{\n\tstruct ray_ecf_startup *ep;\n\tbus_size_t ccs;\n\tint i;\n\n\tRAY_DPRINTF((\"%s: init\\n\", sc->sc_xname));\n\n\tif ((sc->sc_if.if_flags & IFF_RUNNING))\n\t\tray_stop(sc);\n\n\tif (pcmcia_function_enable(sc->sc_pf))\n\t\treturn (EIO);\n\n\tRAY_DPRINTF((\"%s: init post-enable\\n\", sc->sc_xname));\n\n\t/* reset some values */\n\tmemset(sc->sc_ccsinuse, 0, sizeof(sc->sc_ccsinuse));\n\tsc->sc_havenet = 0;\n\tmemset(sc->sc_bssid, 0, sizeof(sc->sc_bssid));\n\tsc->sc_deftxrate = 0;\n\tsc->sc_encrypt = 0;\n\tsc->sc_txpad = 0;\n\tsc->sc_promisc = 0;\n\tsc->sc_scheduled = 0;\n\tsc->sc_running = 0;\n\tsc->sc_txfree = RAY_CCS_NTX;\n\tsc->sc_checkcounters = 0;\n\tsc->sc_resumeinit = 0;\n\n\t/* get startup results */\n\tep = &sc->sc_ecf_startup;\n\tray_read_region(sc, RAY_ECF_TO_HOST_BASE, ep,\n\t    sizeof(sc->sc_ecf_startup));\n\n\t/* check to see that card initialized properly */\n\tif (ep->e_status != RAY_ECFS_CARD_OK) {\n\t\tpcmcia_function_disable(sc->sc_pf);\n\t\tprintf(\"%s: card failed self test: status %d\\n\",\n\t\t    sc->sc_xname, sc->sc_ecf_startup.e_status);\n\t\treturn (EIO);\n\t}\n\n\t/* fixup tib size to be correct */\n\tif (sc->sc_version == SC_BUILD_4 && sc->sc_tibsize == 0x55)\n\t\tsc->sc_tibsize = 32;\n\tsc->sc_txpad = sc->sc_tibsize;\n\n\t/* set all ccs to be free */\n\tccs = RAY_GET_CCS(0);\n\tfor (i = 0; i < RAY_CCS_LAST; ccs += RAY_CCS_SIZE, i++)\n\t\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_status,\n\t\t    RAY_CCS_STATUS_FREE);\n\n\t/* clear the interrupt if present */\n\tREG_WRITE(sc, RAY_HCSIR, 0);\n\n\t/* we are now up and running -- and are busy until download is cplt */\n\tsc->sc_if.if_flags |= IFF_RUNNING | IFF_OACTIVE;\n\n\t/* set this now so it gets set in the download */\n\tsc->sc_promisc = !!(sc->sc_if.if_flags & (IFF_PROMISC|IFF_ALLMULTI));\n\n\t/* call after we mark ourselves running */\n\tray_download_params(sc);\n\n\treturn (0);\n}"
  },
  {
    "function_name": "ray_disable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
    "lines": "827-845",
    "snippet": "void\nray_disable(sc)\n\tstruct ray_softc *sc;\n{\n\tRAY_DPRINTF((\"%s: disable\\n\", sc->sc_xname));\n\n\tif ((sc->sc_if.if_flags & IFF_RUNNING))\n\t\tray_stop(sc);\n\n\tsc->sc_resetloop = 0;\n\tsc->sc_rxoverflow = 0;\n\tsc->sc_rxcksum = 0;\n\tsc->sc_rxhcksum = 0;\n\tsc->sc_rxnoise = 0;\n\n\tif (sc->sc_ih)\n\t\tpcmcia_intr_disestablish(sc->sc_pf, sc->sc_ih);\n\tsc->sc_ih = 0;\n}",
    "includes": [
      "#include <dev/pcmcia/if_rayreg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_llc.h>",
      "#include <net/if_media.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/timeout.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [
      "#define\tsc_xname\tsc_dev.dv_xname",
      "#define\tsc_if\t\tsc_ec.ac_if",
      "#define\tsc_if\t\tsc_ec.ec_if"
    ],
    "globals_used": [
      "void ray_disable",
      "void ray_stop"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcmcia_intr_disestablish",
          "args": [
            "sc->sc_pf",
            "sc->sc_ih"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_intr_disestablish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "784-866",
          "snippet": "void\npcmcia_intr_disestablish(pf, ih)\n\tstruct pcmcia_function *pf;\n\tvoid *ih;\n{\n\tint s, reg, ihcnt, hiipl;\n\tstruct pcmcia_function *pf2;\n\n\t/* Behave differently if this is a multifunction card.  */\n\tif (pcmcia_mfc(pf->sc)) {\n\t\t/*\n\t\t * Mask all the ipl's which are already used by this card,\n\t\t * and find the highest ipl number (lowest priority).  Skip\n\t\t * the current function.\n\t\t */\n\t\tihcnt = 0;\n\t\tfor (pf2 = pf->sc->card.pf_head.sqh_first; pf2 != NULL;\n\t\t    pf2 = pf2->pf_list.sqe_next) {\n\t\t\tif (pf2 == pf)\n\t\t\t\tcontinue;\n\n\t\t\tif (pf2->ih_fct) {\n\t\t\t\tif (ihcnt == 0)\n\t\t\t\t\thiipl = pf2->ih_ipl;\n\t\t\t\telse if (pf2->ih_ipl > hiipl)\n\t\t\t\t\thiipl = pf2->ih_ipl;\n\t\t\t\tihcnt++;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If the ih being removed is lower priority than the lowest\n\t\t * priority remaining interrupt, up the priority.\n\t\t */\n\n\t\t/*\n\t\t * ihcnt is the number of interrupt handlers *not* including\n\t\t * the one about to be removed.\n\t\t */\n\t\tif (ihcnt == 0) {\n#ifdef DIAGNOSTIC\n\t\t\tif (pf->sc->ih == NULL)\n\t\t\t\tpanic(\"disestablishing last function, but card has no ih\");\n#endif\n\t\t\tpcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch,\n\t\t\t    pf->sc->ih);\n\n\t\t\treg = pcmcia_ccr_read(pf, PCMCIA_CCR_OPTION);\n\t\t\treg &= ~PCMCIA_CCR_OPTION_IREQ_ENABLE;\n\t\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\n\t\t\tpf->ih_fct = NULL;\n\t\t\tpf->ih_arg = NULL;\n\n\t\t\tpf->sc->ih = NULL;\n\t\t} else if (pf->ih_ipl > hiipl) {\n#ifdef DIAGNOSTIC\n\t\t\tif (pf->sc->ih == NULL)\n\t\t\t\tpanic(\"changing ih ipl, but card has no ih\");\n#endif\n\t\t\ts = spltty();\n\n\t\t\tpcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch,\n\t\t\t    pf->sc->ih);\n\t\t\tpf->sc->ih = pcmcia_chip_intr_establish(pf->sc->pct,\n\t\t\t    pf->sc->pch, pf, hiipl, pcmcia_card_intr, pf->sc);\n\n\t\t\t/* Null out the handler for this function. */\n\t\t\tpf->ih_fct = NULL;\n\t\t\tpf->ih_arg = NULL;\n\n\t\t\tsplx(s);\n\t\t} else {\n\t\t\ts = spltty();\n\n\t\t\tpf->ih_fct = NULL;\n\t\t\tpf->ih_arg = NULL;\n\n\t\t\tsplx(s);\n\t\t}\n\t} else\n\t\tpcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch, ih);\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int pcmcia_card_intr",
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;",
            "int ipl;",
            "int (*ih_fct)",
            "void *ih_arg;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint pcmcia_card_intr;\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\nint ipl;\nint (*ih_fct);\nvoid *ih_arg;\n\nvoid\npcmcia_intr_disestablish(pf, ih)\n\tstruct pcmcia_function *pf;\n\tvoid *ih;\n{\n\tint s, reg, ihcnt, hiipl;\n\tstruct pcmcia_function *pf2;\n\n\t/* Behave differently if this is a multifunction card.  */\n\tif (pcmcia_mfc(pf->sc)) {\n\t\t/*\n\t\t * Mask all the ipl's which are already used by this card,\n\t\t * and find the highest ipl number (lowest priority).  Skip\n\t\t * the current function.\n\t\t */\n\t\tihcnt = 0;\n\t\tfor (pf2 = pf->sc->card.pf_head.sqh_first; pf2 != NULL;\n\t\t    pf2 = pf2->pf_list.sqe_next) {\n\t\t\tif (pf2 == pf)\n\t\t\t\tcontinue;\n\n\t\t\tif (pf2->ih_fct) {\n\t\t\t\tif (ihcnt == 0)\n\t\t\t\t\thiipl = pf2->ih_ipl;\n\t\t\t\telse if (pf2->ih_ipl > hiipl)\n\t\t\t\t\thiipl = pf2->ih_ipl;\n\t\t\t\tihcnt++;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If the ih being removed is lower priority than the lowest\n\t\t * priority remaining interrupt, up the priority.\n\t\t */\n\n\t\t/*\n\t\t * ihcnt is the number of interrupt handlers *not* including\n\t\t * the one about to be removed.\n\t\t */\n\t\tif (ihcnt == 0) {\n#ifdef DIAGNOSTIC\n\t\t\tif (pf->sc->ih == NULL)\n\t\t\t\tpanic(\"disestablishing last function, but card has no ih\");\n#endif\n\t\t\tpcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch,\n\t\t\t    pf->sc->ih);\n\n\t\t\treg = pcmcia_ccr_read(pf, PCMCIA_CCR_OPTION);\n\t\t\treg &= ~PCMCIA_CCR_OPTION_IREQ_ENABLE;\n\t\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\n\t\t\tpf->ih_fct = NULL;\n\t\t\tpf->ih_arg = NULL;\n\n\t\t\tpf->sc->ih = NULL;\n\t\t} else if (pf->ih_ipl > hiipl) {\n#ifdef DIAGNOSTIC\n\t\t\tif (pf->sc->ih == NULL)\n\t\t\t\tpanic(\"changing ih ipl, but card has no ih\");\n#endif\n\t\t\ts = spltty();\n\n\t\t\tpcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch,\n\t\t\t    pf->sc->ih);\n\t\t\tpf->sc->ih = pcmcia_chip_intr_establish(pf->sc->pct,\n\t\t\t    pf->sc->pch, pf, hiipl, pcmcia_card_intr, pf->sc);\n\n\t\t\t/* Null out the handler for this function. */\n\t\t\tpf->ih_fct = NULL;\n\t\t\tpf->ih_arg = NULL;\n\n\t\t\tsplx(s);\n\t\t} else {\n\t\t\ts = spltty();\n\n\t\t\tpf->ih_fct = NULL;\n\t\t\tpf->ih_arg = NULL;\n\n\t\t\tsplx(s);\n\t\t}\n\t} else\n\t\tpcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch, ih);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ray_stop",
          "args": [
            "sc"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "ray_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "924-947",
          "snippet": "void\nray_stop(sc)\n\tstruct ray_softc *sc;\n{\n\tRAY_DPRINTF((\"%s: stop\\n\", sc->sc_xname));\n\n\tcallout_stop(&sc->sc_check_ccs_ch);\n\tsc->sc_timocheck = 0;\n\n\tcallout_stop(&sc->sc_check_scheduled_ch);\n\tsc->sc_timoneed = 0;\n\n\tif (sc->sc_repreq) {\n\t\tsc->sc_repreq->r_failcause = RAY_FAILCAUSE_EDEVSTOP;\n\t\twakeup(ray_report_params);\n\t}\n\tif (sc->sc_updreq) {\n\t\tsc->sc_repreq->r_failcause = RAY_FAILCAUSE_EDEVSTOP;\n\t\twakeup(ray_update_params);\n\t}\n\n\tsc->sc_if.if_flags &= ~IFF_RUNNING;\n\tpcmcia_function_disable(sc->sc_pf);\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tsc_xname\tsc_dev.dv_xname",
            "#define\tsc_if\t\tsc_ec.ac_if",
            "#define\tsc_if\t\tsc_ec.ec_if",
            "#define\tcallout_stop\ttimeout_del"
          ],
          "globals_used": [
            "void ray_report_params",
            "void ray_stop",
            "void ray_update_params"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_xname\tsc_dev.dv_xname\n#define\tsc_if\t\tsc_ec.ac_if\n#define\tsc_if\t\tsc_ec.ec_if\n#define\tcallout_stop\ttimeout_del\n\nvoid ray_report_params;\nvoid ray_stop;\nvoid ray_update_params;\n\nvoid\nray_stop(sc)\n\tstruct ray_softc *sc;\n{\n\tRAY_DPRINTF((\"%s: stop\\n\", sc->sc_xname));\n\n\tcallout_stop(&sc->sc_check_ccs_ch);\n\tsc->sc_timocheck = 0;\n\n\tcallout_stop(&sc->sc_check_scheduled_ch);\n\tsc->sc_timoneed = 0;\n\n\tif (sc->sc_repreq) {\n\t\tsc->sc_repreq->r_failcause = RAY_FAILCAUSE_EDEVSTOP;\n\t\twakeup(ray_report_params);\n\t}\n\tif (sc->sc_updreq) {\n\t\tsc->sc_repreq->r_failcause = RAY_FAILCAUSE_EDEVSTOP;\n\t\twakeup(ray_update_params);\n\t}\n\n\tsc->sc_if.if_flags &= ~IFF_RUNNING;\n\tpcmcia_function_disable(sc->sc_pf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: disable\\n\", sc->sc_xname)"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_xname\tsc_dev.dv_xname\n#define\tsc_if\t\tsc_ec.ac_if\n#define\tsc_if\t\tsc_ec.ec_if\n\nvoid ray_disable;\nvoid ray_stop;\n\nvoid\nray_disable(sc)\n\tstruct ray_softc *sc;\n{\n\tRAY_DPRINTF((\"%s: disable\\n\", sc->sc_xname));\n\n\tif ((sc->sc_if.if_flags & IFF_RUNNING))\n\t\tray_stop(sc);\n\n\tsc->sc_resetloop = 0;\n\tsc->sc_rxoverflow = 0;\n\tsc->sc_rxcksum = 0;\n\tsc->sc_rxhcksum = 0;\n\tsc->sc_rxnoise = 0;\n\n\tif (sc->sc_ih)\n\t\tpcmcia_intr_disestablish(sc->sc_pf, sc->sc_ih);\n\tsc->sc_ih = 0;\n}"
  },
  {
    "function_name": "ray_enable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
    "lines": "805-822",
    "snippet": "int\nray_enable(sc)\n\tstruct ray_softc *sc;\n{\n\tint error;\n\n\tRAY_DPRINTF((\"%s: enable\\n\", sc->sc_xname));\n\n\tif ((error = ray_init(sc)) == 0) {\n\t\tsc->sc_ih = pcmcia_intr_establish(sc->sc_pf, IPL_NET,\n\t\t    ray_intr, sc);\n\t\tif (sc->sc_ih == NULL) {\n\t\t\tray_stop(sc);\n\t\t\treturn (EIO);\n\t\t}\n\t}\n\treturn (error);\n}",
    "includes": [
      "#include <dev/pcmcia/if_rayreg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_llc.h>",
      "#include <net/if_media.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/timeout.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [
      "#define\tsc_xname\tsc_dev.dv_xname"
    ],
    "globals_used": [
      "int ray_enable",
      "int ray_init",
      "int ray_intr",
      "void ray_stop"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ray_stop",
          "args": [
            "sc"
          ],
          "line": 817
        },
        "resolved": true,
        "details": {
          "function_name": "ray_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "924-947",
          "snippet": "void\nray_stop(sc)\n\tstruct ray_softc *sc;\n{\n\tRAY_DPRINTF((\"%s: stop\\n\", sc->sc_xname));\n\n\tcallout_stop(&sc->sc_check_ccs_ch);\n\tsc->sc_timocheck = 0;\n\n\tcallout_stop(&sc->sc_check_scheduled_ch);\n\tsc->sc_timoneed = 0;\n\n\tif (sc->sc_repreq) {\n\t\tsc->sc_repreq->r_failcause = RAY_FAILCAUSE_EDEVSTOP;\n\t\twakeup(ray_report_params);\n\t}\n\tif (sc->sc_updreq) {\n\t\tsc->sc_repreq->r_failcause = RAY_FAILCAUSE_EDEVSTOP;\n\t\twakeup(ray_update_params);\n\t}\n\n\tsc->sc_if.if_flags &= ~IFF_RUNNING;\n\tpcmcia_function_disable(sc->sc_pf);\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tsc_xname\tsc_dev.dv_xname",
            "#define\tsc_if\t\tsc_ec.ac_if",
            "#define\tsc_if\t\tsc_ec.ec_if",
            "#define\tcallout_stop\ttimeout_del"
          ],
          "globals_used": [
            "void ray_report_params",
            "void ray_stop",
            "void ray_update_params"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_xname\tsc_dev.dv_xname\n#define\tsc_if\t\tsc_ec.ac_if\n#define\tsc_if\t\tsc_ec.ec_if\n#define\tcallout_stop\ttimeout_del\n\nvoid ray_report_params;\nvoid ray_stop;\nvoid ray_update_params;\n\nvoid\nray_stop(sc)\n\tstruct ray_softc *sc;\n{\n\tRAY_DPRINTF((\"%s: stop\\n\", sc->sc_xname));\n\n\tcallout_stop(&sc->sc_check_ccs_ch);\n\tsc->sc_timocheck = 0;\n\n\tcallout_stop(&sc->sc_check_scheduled_ch);\n\tsc->sc_timoneed = 0;\n\n\tif (sc->sc_repreq) {\n\t\tsc->sc_repreq->r_failcause = RAY_FAILCAUSE_EDEVSTOP;\n\t\twakeup(ray_report_params);\n\t}\n\tif (sc->sc_updreq) {\n\t\tsc->sc_repreq->r_failcause = RAY_FAILCAUSE_EDEVSTOP;\n\t\twakeup(ray_update_params);\n\t}\n\n\tsc->sc_if.if_flags &= ~IFF_RUNNING;\n\tpcmcia_function_disable(sc->sc_pf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_intr_establish",
          "args": [
            "sc->sc_pf",
            "IPL_NET",
            "ray_intr",
            "sc"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ray_init",
          "args": [
            "sc"
          ],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "ray_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "850-919",
          "snippet": "int\nray_init(sc)\n\tstruct ray_softc *sc;\n{\n\tstruct ray_ecf_startup *ep;\n\tbus_size_t ccs;\n\tint i;\n\n\tRAY_DPRINTF((\"%s: init\\n\", sc->sc_xname));\n\n\tif ((sc->sc_if.if_flags & IFF_RUNNING))\n\t\tray_stop(sc);\n\n\tif (pcmcia_function_enable(sc->sc_pf))\n\t\treturn (EIO);\n\n\tRAY_DPRINTF((\"%s: init post-enable\\n\", sc->sc_xname));\n\n\t/* reset some values */\n\tmemset(sc->sc_ccsinuse, 0, sizeof(sc->sc_ccsinuse));\n\tsc->sc_havenet = 0;\n\tmemset(sc->sc_bssid, 0, sizeof(sc->sc_bssid));\n\tsc->sc_deftxrate = 0;\n\tsc->sc_encrypt = 0;\n\tsc->sc_txpad = 0;\n\tsc->sc_promisc = 0;\n\tsc->sc_scheduled = 0;\n\tsc->sc_running = 0;\n\tsc->sc_txfree = RAY_CCS_NTX;\n\tsc->sc_checkcounters = 0;\n\tsc->sc_resumeinit = 0;\n\n\t/* get startup results */\n\tep = &sc->sc_ecf_startup;\n\tray_read_region(sc, RAY_ECF_TO_HOST_BASE, ep,\n\t    sizeof(sc->sc_ecf_startup));\n\n\t/* check to see that card initialized properly */\n\tif (ep->e_status != RAY_ECFS_CARD_OK) {\n\t\tpcmcia_function_disable(sc->sc_pf);\n\t\tprintf(\"%s: card failed self test: status %d\\n\",\n\t\t    sc->sc_xname, sc->sc_ecf_startup.e_status);\n\t\treturn (EIO);\n\t}\n\n\t/* fixup tib size to be correct */\n\tif (sc->sc_version == SC_BUILD_4 && sc->sc_tibsize == 0x55)\n\t\tsc->sc_tibsize = 32;\n\tsc->sc_txpad = sc->sc_tibsize;\n\n\t/* set all ccs to be free */\n\tccs = RAY_GET_CCS(0);\n\tfor (i = 0; i < RAY_CCS_LAST; ccs += RAY_CCS_SIZE, i++)\n\t\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_status,\n\t\t    RAY_CCS_STATUS_FREE);\n\n\t/* clear the interrupt if present */\n\tREG_WRITE(sc, RAY_HCSIR, 0);\n\n\t/* we are now up and running -- and are busy until download is cplt */\n\tsc->sc_if.if_flags |= IFF_RUNNING | IFF_OACTIVE;\n\n\t/* set this now so it gets set in the download */\n\tsc->sc_promisc = !!(sc->sc_if.if_flags & (IFF_PROMISC|IFF_ALLMULTI));\n\n\t/* call after we mark ourselves running */\n\tray_download_params(sc);\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tSC_BUILD_4\t0x55",
            "#define\tsc_xname\tsc_dev.dv_xname",
            "#define\tsc_if\t\tsc_ec.ac_if",
            "#define\tsc_if\t\tsc_ec.ec_if",
            "#define\tsc_tibsize\tsc_ecf_startup.e_tib_size",
            "#define\tsc_version\tsc_ecf_startup.e_fw_build_string"
          ],
          "globals_used": [
            "void ray_download_params",
            "int ray_init",
            "void ray_stop"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSC_BUILD_4\t0x55\n#define\tsc_xname\tsc_dev.dv_xname\n#define\tsc_if\t\tsc_ec.ac_if\n#define\tsc_if\t\tsc_ec.ec_if\n#define\tsc_tibsize\tsc_ecf_startup.e_tib_size\n#define\tsc_version\tsc_ecf_startup.e_fw_build_string\n\nvoid ray_download_params;\nint ray_init;\nvoid ray_stop;\n\nint\nray_init(sc)\n\tstruct ray_softc *sc;\n{\n\tstruct ray_ecf_startup *ep;\n\tbus_size_t ccs;\n\tint i;\n\n\tRAY_DPRINTF((\"%s: init\\n\", sc->sc_xname));\n\n\tif ((sc->sc_if.if_flags & IFF_RUNNING))\n\t\tray_stop(sc);\n\n\tif (pcmcia_function_enable(sc->sc_pf))\n\t\treturn (EIO);\n\n\tRAY_DPRINTF((\"%s: init post-enable\\n\", sc->sc_xname));\n\n\t/* reset some values */\n\tmemset(sc->sc_ccsinuse, 0, sizeof(sc->sc_ccsinuse));\n\tsc->sc_havenet = 0;\n\tmemset(sc->sc_bssid, 0, sizeof(sc->sc_bssid));\n\tsc->sc_deftxrate = 0;\n\tsc->sc_encrypt = 0;\n\tsc->sc_txpad = 0;\n\tsc->sc_promisc = 0;\n\tsc->sc_scheduled = 0;\n\tsc->sc_running = 0;\n\tsc->sc_txfree = RAY_CCS_NTX;\n\tsc->sc_checkcounters = 0;\n\tsc->sc_resumeinit = 0;\n\n\t/* get startup results */\n\tep = &sc->sc_ecf_startup;\n\tray_read_region(sc, RAY_ECF_TO_HOST_BASE, ep,\n\t    sizeof(sc->sc_ecf_startup));\n\n\t/* check to see that card initialized properly */\n\tif (ep->e_status != RAY_ECFS_CARD_OK) {\n\t\tpcmcia_function_disable(sc->sc_pf);\n\t\tprintf(\"%s: card failed self test: status %d\\n\",\n\t\t    sc->sc_xname, sc->sc_ecf_startup.e_status);\n\t\treturn (EIO);\n\t}\n\n\t/* fixup tib size to be correct */\n\tif (sc->sc_version == SC_BUILD_4 && sc->sc_tibsize == 0x55)\n\t\tsc->sc_tibsize = 32;\n\tsc->sc_txpad = sc->sc_tibsize;\n\n\t/* set all ccs to be free */\n\tccs = RAY_GET_CCS(0);\n\tfor (i = 0; i < RAY_CCS_LAST; ccs += RAY_CCS_SIZE, i++)\n\t\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_status,\n\t\t    RAY_CCS_STATUS_FREE);\n\n\t/* clear the interrupt if present */\n\tREG_WRITE(sc, RAY_HCSIR, 0);\n\n\t/* we are now up and running -- and are busy until download is cplt */\n\tsc->sc_if.if_flags |= IFF_RUNNING | IFF_OACTIVE;\n\n\t/* set this now so it gets set in the download */\n\tsc->sc_promisc = !!(sc->sc_if.if_flags & (IFF_PROMISC|IFF_ALLMULTI));\n\n\t/* call after we mark ourselves running */\n\tray_download_params(sc);\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: enable\\n\", sc->sc_xname)"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_xname\tsc_dev.dv_xname\n\nint ray_enable;\nint ray_init;\nint ray_intr;\nvoid ray_stop;\n\nint\nray_enable(sc)\n\tstruct ray_softc *sc;\n{\n\tint error;\n\n\tRAY_DPRINTF((\"%s: enable\\n\", sc->sc_xname));\n\n\tif ((error = ray_init(sc)) == 0) {\n\t\tsc->sc_ih = pcmcia_intr_establish(sc->sc_pf, IPL_NET,\n\t\t    ray_intr, sc);\n\t\tif (sc->sc_ih == NULL) {\n\t\t\tray_stop(sc);\n\t\t\treturn (EIO);\n\t\t}\n\t}\n\treturn (error);\n}"
  },
  {
    "function_name": "ray_detach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
    "lines": "762-800",
    "snippet": "int\nray_detach(self, flags)\n\tstruct device *self;\n\tint flags;\n{\n\tstruct ray_softc *sc;\n\tstruct ifnet *ifp;\n\n\tsc = (struct ray_softc *)self;\n\tifp = &sc->sc_if;\n\tRAY_DPRINTF((\"%s: detach\\n\", sc->sc_xname));\n\n\tif (ifp->if_flags & IFF_RUNNING)\n\t\tray_disable(sc);\n\n\t/* give back the memory */\n#if RAY_USE_AMEM\n\tif (sc->sc_awindow != -1) {\n\t\tpcmcia_mem_unmap(sc->sc_pf, sc->sc_awindow);\n\t\tpcmcia_mem_free(sc->sc_pf, &sc->sc_amem);\n\t}\n#endif\n\tif (sc->sc_window != -1) {\n\t\tpcmcia_mem_unmap(sc->sc_pf, sc->sc_window);\n\t\tpcmcia_mem_free(sc->sc_pf, &sc->sc_mem);\n\t}\n\n\tifmedia_delete_instance(&sc->sc_media, IFM_INST_ANY);\n\n#if NBPFILTER > 0\n\tbpfdetach(ifp);\n#endif\n\tether_ifdetach(ifp);\n\tif_detach(ifp);\n\tpowerhook_disestablish(sc->sc_pwrhook);\n\tshutdownhook_disestablish(sc->sc_sdhook);\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/pcmcia/if_rayreg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_llc.h>",
      "#include <net/if_media.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/timeout.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [
      "#define\tsc_xname\tsc_dev.dv_xname",
      "#define\tsc_if\t\tsc_ec.ac_if",
      "#define\tsc_if\t\tsc_ec.ec_if",
      "#define RAY_USE_AMEM 0"
    ],
    "globals_used": [
      "int ray_detach",
      "void ray_disable"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "shutdownhook_disestablish",
          "args": [
            "sc->sc_sdhook"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "powerhook_disestablish",
          "args": [
            "sc->sc_pwrhook"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_detach",
          "args": [
            "ifp"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_ifdetach",
          "args": [
            "ifp"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpfdetach",
          "args": [
            "ifp"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_delete_instance",
          "args": [
            "&sc->sc_media",
            "IFM_INST_ANY"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_mem_free",
          "args": [
            "sc->sc_pf",
            "&sc->sc_mem"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_pcmcia_mem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "2382-2395",
          "snippet": "STATIC void\npccbb_pcmcia_mem_free(pch, pcmhp)\n\tpcmcia_chipset_handle_t pch;\n\tstruct pcmcia_mem_handle *pcmhp;\n{\n#if rbus\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)ph->ph_parent;\n\n\trbus_space_free(sc->sc_rbus_memt, pcmhp->memh, pcmhp->realsize, NULL);\n#else\n\tbus_space_free(pcmhp->memt, pcmhp->memh, pcmhp->realsize);\n#endif\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define STATIC static",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int",
            "cb_reset __P((struct pccbb_softc *));",
            "STATIC int",
            "cb_detect_voltage __P((struct pccbb_softc *));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "pccbb_pcmcia_mem_alloc __P((pcmcia_chipset_handle_t, bus_size_t,\n    struct pcmcia_mem_handle *));",
            "STATIC void",
            "pccbb_pcmcia_mem_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_mem_handle *));",
            "STATIC int",
            "STATIC void",
            "pccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "pccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC void",
            "pccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));",
            "STATIC void",
            "pccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));",
            "STATIC void",
            "pccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));",
            "STATIC int",
            "pccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));",
            "struct pccbb_softc *sc = psc->cpc_parent;",
            "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
            "struct pcic_handle *ph = poll->ph;",
            "struct pccbb_softc *sc = ph->sc;",
            "STATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define STATIC static\n#define STATIC\n\nSTATIC int;\ncb_reset __P((struct pccbb_softc *));\nSTATIC int;\ncb_detect_voltage __P((struct pccbb_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\npccbb_pcmcia_mem_alloc __P((pcmcia_chipset_handle_t, bus_size_t,\n    struct pcmcia_mem_handle *));\nSTATIC void;\npccbb_pcmcia_mem_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_mem_handle *));\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC void;\npccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));\nSTATIC void;\npccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));\nSTATIC void;\npccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));\nSTATIC int;\npccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));\nstruct pccbb_softc *sc = psc->cpc_parent;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pcic_handle *ph = poll->ph;\nstruct pccbb_softc *sc = ph->sc;\nSTATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;\n\nSTATIC void\npccbb_pcmcia_mem_free(pch, pcmhp)\n\tpcmcia_chipset_handle_t pch;\n\tstruct pcmcia_mem_handle *pcmhp;\n{\n#if rbus\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)ph->ph_parent;\n\n\trbus_space_free(sc->sc_rbus_memt, pcmhp->memh, pcmhp->realsize, NULL);\n#else\n\tbus_space_free(pcmhp->memt, pcmhp->memh, pcmhp->realsize);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_mem_unmap",
          "args": [
            "sc->sc_pf",
            "sc->sc_window"
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_pcmcia_mem_unmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "2584-2601",
          "snippet": "STATIC void\npccbb_pcmcia_mem_unmap(pch, window)\n\tpcmcia_chipset_handle_t pch;\n\tint window;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tint reg;\n\n\tif (window >= PCIC_MEM_WINS) {\n\t\tpanic(\"pccbb_pcmcia_mem_unmap: window out of range\");\n\t}\n\n\treg = Pcic_read(ph, PCIC_ADDRWIN_ENABLE);\n\treg &= ~(1 << window);\n\tPcic_write(ph, PCIC_ADDRWIN_ENABLE, reg);\n\n\tph->memalloc &= ~(1 << window);\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define STATIC static",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "pccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "pccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC void",
            "pccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));",
            "STATIC void",
            "pccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));",
            "STATIC void",
            "pccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));",
            "STATIC int",
            "pccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));",
            "struct pcic_handle *ph = poll->ph;",
            "STATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define STATIC static\n#define STATIC\n\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC void;\npccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));\nSTATIC void;\npccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));\nSTATIC void;\npccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));\nSTATIC int;\npccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));\nstruct pcic_handle *ph = poll->ph;\nSTATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;\n\nSTATIC void\npccbb_pcmcia_mem_unmap(pch, window)\n\tpcmcia_chipset_handle_t pch;\n\tint window;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tint reg;\n\n\tif (window >= PCIC_MEM_WINS) {\n\t\tpanic(\"pccbb_pcmcia_mem_unmap: window out of range\");\n\t}\n\n\treg = Pcic_read(ph, PCIC_ADDRWIN_ENABLE);\n\treg &= ~(1 << window);\n\tPcic_write(ph, PCIC_ADDRWIN_ENABLE, reg);\n\n\tph->memalloc &= ~(1 << window);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ray_disable",
          "args": [
            "sc"
          ],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "ray_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "827-845",
          "snippet": "void\nray_disable(sc)\n\tstruct ray_softc *sc;\n{\n\tRAY_DPRINTF((\"%s: disable\\n\", sc->sc_xname));\n\n\tif ((sc->sc_if.if_flags & IFF_RUNNING))\n\t\tray_stop(sc);\n\n\tsc->sc_resetloop = 0;\n\tsc->sc_rxoverflow = 0;\n\tsc->sc_rxcksum = 0;\n\tsc->sc_rxhcksum = 0;\n\tsc->sc_rxnoise = 0;\n\n\tif (sc->sc_ih)\n\t\tpcmcia_intr_disestablish(sc->sc_pf, sc->sc_ih);\n\tsc->sc_ih = 0;\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tsc_xname\tsc_dev.dv_xname",
            "#define\tsc_if\t\tsc_ec.ac_if",
            "#define\tsc_if\t\tsc_ec.ec_if"
          ],
          "globals_used": [
            "void ray_disable",
            "void ray_stop"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_xname\tsc_dev.dv_xname\n#define\tsc_if\t\tsc_ec.ac_if\n#define\tsc_if\t\tsc_ec.ec_if\n\nvoid ray_disable;\nvoid ray_stop;\n\nvoid\nray_disable(sc)\n\tstruct ray_softc *sc;\n{\n\tRAY_DPRINTF((\"%s: disable\\n\", sc->sc_xname));\n\n\tif ((sc->sc_if.if_flags & IFF_RUNNING))\n\t\tray_stop(sc);\n\n\tsc->sc_resetloop = 0;\n\tsc->sc_rxoverflow = 0;\n\tsc->sc_rxcksum = 0;\n\tsc->sc_rxhcksum = 0;\n\tsc->sc_rxnoise = 0;\n\n\tif (sc->sc_ih)\n\t\tpcmcia_intr_disestablish(sc->sc_pf, sc->sc_ih);\n\tsc->sc_ih = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: detach\\n\", sc->sc_xname)"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_xname\tsc_dev.dv_xname\n#define\tsc_if\t\tsc_ec.ac_if\n#define\tsc_if\t\tsc_ec.ec_if\n#define RAY_USE_AMEM 0\n\nint ray_detach;\nvoid ray_disable;\n\nint\nray_detach(self, flags)\n\tstruct device *self;\n\tint flags;\n{\n\tstruct ray_softc *sc;\n\tstruct ifnet *ifp;\n\n\tsc = (struct ray_softc *)self;\n\tifp = &sc->sc_if;\n\tRAY_DPRINTF((\"%s: detach\\n\", sc->sc_xname));\n\n\tif (ifp->if_flags & IFF_RUNNING)\n\t\tray_disable(sc);\n\n\t/* give back the memory */\n#if RAY_USE_AMEM\n\tif (sc->sc_awindow != -1) {\n\t\tpcmcia_mem_unmap(sc->sc_pf, sc->sc_awindow);\n\t\tpcmcia_mem_free(sc->sc_pf, &sc->sc_amem);\n\t}\n#endif\n\tif (sc->sc_window != -1) {\n\t\tpcmcia_mem_unmap(sc->sc_pf, sc->sc_window);\n\t\tpcmcia_mem_free(sc->sc_pf, &sc->sc_mem);\n\t}\n\n\tifmedia_delete_instance(&sc->sc_media, IFM_INST_ANY);\n\n#if NBPFILTER > 0\n\tbpfdetach(ifp);\n#endif\n\tether_ifdetach(ifp);\n\tif_detach(ifp);\n\tpowerhook_disestablish(sc->sc_pwrhook);\n\tshutdownhook_disestablish(sc->sc_sdhook);\n\n\treturn (0);\n}"
  },
  {
    "function_name": "ray_activate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
    "lines": "729-760",
    "snippet": "int\nray_activate(dev, act)\n\tstruct device *dev;\n\tenum devact act;\n{\n\tstruct ray_softc *sc = (struct ray_softc *)dev;\n\tstruct ifnet *ifp = &sc->sc_if;\n\tint s;\n\tint rv = 0;\n\n\tRAY_DPRINTF((\"%s: activate\\n\", sc->sc_xname));\n\n\ts = splnet();\n\tswitch (act) {\n\tcase DVACT_ACTIVATE:\n\t\trv = EOPNOTSUPP;\n\t\tbreak;\n\n\tcase DVACT_DEACTIVATE:\n\t\tif (ifp->if_flags & IFF_RUNNING)\n\t\t\tray_disable(sc);\n#ifdef __NetBSD__\n\t\tif_deactivate(ifp);\n#elif defined(__OpenBSD__)\n\t\tpcmcia_intr_disestablish(sc->sc_pf, sc->sc_ih);\n\t\tpcmcia_function_disable(sc->sc_pf);\n#endif\n\t\tbreak;\n\t}\n\tsplx(s);\n\treturn (rv);\n}",
    "includes": [
      "#include <dev/pcmcia/if_rayreg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_llc.h>",
      "#include <net/if_media.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/timeout.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [
      "#define\tsc_xname\tsc_dev.dv_xname",
      "#define\tsc_if\t\tsc_ec.ac_if",
      "#define\tsc_if\t\tsc_ec.ec_if"
    ],
    "globals_used": [
      "int ray_activate",
      "void ray_disable"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_function_disable",
          "args": [
            "sc->sc_pf"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_function_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "570-622",
          "snippet": "void\npcmcia_function_disable(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct pcmcia_function *tmp;\n\n\tif (pf->cfe == NULL)\n\t\tpanic(\"pcmcia_function_enable: function not initialized\");\n\n\tif ((pf->pf_flags & PFF_ENABLED) == 0) {\n\t\t/*\n\t\t * Don't do anything if we're already disabled.\n\t\t */\n\t\treturn;\n\t}\n\n\t/* If there was no CIS don't mess with CCR */\n\tif (pf->pf_flags & PFF_FAKE) {\n\t\tpf->pf_flags &= ~PFF_ENABLED;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * it's possible for different functions' CCRs to be in the same\n\t * underlying page.  Check for that.  Note we mark us as disabled\n\t * first to avoid matching ourself.\n\t */\n\tpf->pf_flags &= ~PFF_ENABLED;\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t    tmp = tmp->pf_list.sqe_next) {\n\t\tif ((tmp->pf_flags & PFF_ENABLED) &&\n\t\t    (pf->ccr_base >= (tmp->ccr_base - tmp->pf_ccr_offset)) &&\n\t\t    ((pf->ccr_base + PCMCIA_CCR_SIZE) <=\n\t\t(tmp->ccr_base - tmp->pf_ccr_offset + tmp->pf_ccr_realsize)))\n\t\t\tbreak;\n\t}\n\n\t/* Not used by anyone else; unmap the CCR. */\n\tif (tmp == NULL) {\n\t\tpcmcia_mem_unmap(pf, pf->pf_ccr_window);\n\t\tpcmcia_mem_free(pf, &pf->pf_pcmh);\n\t}\n\n done:\n\t/*\n\t * Decrement the reference count, and power down the socket, if\n\t * necessary.\n\t */\n\tif (--pf->sc->sc_enabled_count == 0)\n\t\tpcmcia_chip_socket_disable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: --enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\n\nvoid\npcmcia_function_disable(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct pcmcia_function *tmp;\n\n\tif (pf->cfe == NULL)\n\t\tpanic(\"pcmcia_function_enable: function not initialized\");\n\n\tif ((pf->pf_flags & PFF_ENABLED) == 0) {\n\t\t/*\n\t\t * Don't do anything if we're already disabled.\n\t\t */\n\t\treturn;\n\t}\n\n\t/* If there was no CIS don't mess with CCR */\n\tif (pf->pf_flags & PFF_FAKE) {\n\t\tpf->pf_flags &= ~PFF_ENABLED;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * it's possible for different functions' CCRs to be in the same\n\t * underlying page.  Check for that.  Note we mark us as disabled\n\t * first to avoid matching ourself.\n\t */\n\tpf->pf_flags &= ~PFF_ENABLED;\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t    tmp = tmp->pf_list.sqe_next) {\n\t\tif ((tmp->pf_flags & PFF_ENABLED) &&\n\t\t    (pf->ccr_base >= (tmp->ccr_base - tmp->pf_ccr_offset)) &&\n\t\t    ((pf->ccr_base + PCMCIA_CCR_SIZE) <=\n\t\t(tmp->ccr_base - tmp->pf_ccr_offset + tmp->pf_ccr_realsize)))\n\t\t\tbreak;\n\t}\n\n\t/* Not used by anyone else; unmap the CCR. */\n\tif (tmp == NULL) {\n\t\tpcmcia_mem_unmap(pf, pf->pf_ccr_window);\n\t\tpcmcia_mem_free(pf, &pf->pf_pcmh);\n\t}\n\n done:\n\t/*\n\t * Decrement the reference count, and power down the socket, if\n\t * necessary.\n\t */\n\tif (--pf->sc->sc_enabled_count == 0)\n\t\tpcmcia_chip_socket_disable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: --enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_intr_disestablish",
          "args": [
            "sc->sc_pf",
            "sc->sc_ih"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_intr_disestablish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "784-866",
          "snippet": "void\npcmcia_intr_disestablish(pf, ih)\n\tstruct pcmcia_function *pf;\n\tvoid *ih;\n{\n\tint s, reg, ihcnt, hiipl;\n\tstruct pcmcia_function *pf2;\n\n\t/* Behave differently if this is a multifunction card.  */\n\tif (pcmcia_mfc(pf->sc)) {\n\t\t/*\n\t\t * Mask all the ipl's which are already used by this card,\n\t\t * and find the highest ipl number (lowest priority).  Skip\n\t\t * the current function.\n\t\t */\n\t\tihcnt = 0;\n\t\tfor (pf2 = pf->sc->card.pf_head.sqh_first; pf2 != NULL;\n\t\t    pf2 = pf2->pf_list.sqe_next) {\n\t\t\tif (pf2 == pf)\n\t\t\t\tcontinue;\n\n\t\t\tif (pf2->ih_fct) {\n\t\t\t\tif (ihcnt == 0)\n\t\t\t\t\thiipl = pf2->ih_ipl;\n\t\t\t\telse if (pf2->ih_ipl > hiipl)\n\t\t\t\t\thiipl = pf2->ih_ipl;\n\t\t\t\tihcnt++;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If the ih being removed is lower priority than the lowest\n\t\t * priority remaining interrupt, up the priority.\n\t\t */\n\n\t\t/*\n\t\t * ihcnt is the number of interrupt handlers *not* including\n\t\t * the one about to be removed.\n\t\t */\n\t\tif (ihcnt == 0) {\n#ifdef DIAGNOSTIC\n\t\t\tif (pf->sc->ih == NULL)\n\t\t\t\tpanic(\"disestablishing last function, but card has no ih\");\n#endif\n\t\t\tpcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch,\n\t\t\t    pf->sc->ih);\n\n\t\t\treg = pcmcia_ccr_read(pf, PCMCIA_CCR_OPTION);\n\t\t\treg &= ~PCMCIA_CCR_OPTION_IREQ_ENABLE;\n\t\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\n\t\t\tpf->ih_fct = NULL;\n\t\t\tpf->ih_arg = NULL;\n\n\t\t\tpf->sc->ih = NULL;\n\t\t} else if (pf->ih_ipl > hiipl) {\n#ifdef DIAGNOSTIC\n\t\t\tif (pf->sc->ih == NULL)\n\t\t\t\tpanic(\"changing ih ipl, but card has no ih\");\n#endif\n\t\t\ts = spltty();\n\n\t\t\tpcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch,\n\t\t\t    pf->sc->ih);\n\t\t\tpf->sc->ih = pcmcia_chip_intr_establish(pf->sc->pct,\n\t\t\t    pf->sc->pch, pf, hiipl, pcmcia_card_intr, pf->sc);\n\n\t\t\t/* Null out the handler for this function. */\n\t\t\tpf->ih_fct = NULL;\n\t\t\tpf->ih_arg = NULL;\n\n\t\t\tsplx(s);\n\t\t} else {\n\t\t\ts = spltty();\n\n\t\t\tpf->ih_fct = NULL;\n\t\t\tpf->ih_arg = NULL;\n\n\t\t\tsplx(s);\n\t\t}\n\t} else\n\t\tpcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch, ih);\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int pcmcia_card_intr",
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;",
            "int ipl;",
            "int (*ih_fct)",
            "void *ih_arg;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint pcmcia_card_intr;\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\nint ipl;\nint (*ih_fct);\nvoid *ih_arg;\n\nvoid\npcmcia_intr_disestablish(pf, ih)\n\tstruct pcmcia_function *pf;\n\tvoid *ih;\n{\n\tint s, reg, ihcnt, hiipl;\n\tstruct pcmcia_function *pf2;\n\n\t/* Behave differently if this is a multifunction card.  */\n\tif (pcmcia_mfc(pf->sc)) {\n\t\t/*\n\t\t * Mask all the ipl's which are already used by this card,\n\t\t * and find the highest ipl number (lowest priority).  Skip\n\t\t * the current function.\n\t\t */\n\t\tihcnt = 0;\n\t\tfor (pf2 = pf->sc->card.pf_head.sqh_first; pf2 != NULL;\n\t\t    pf2 = pf2->pf_list.sqe_next) {\n\t\t\tif (pf2 == pf)\n\t\t\t\tcontinue;\n\n\t\t\tif (pf2->ih_fct) {\n\t\t\t\tif (ihcnt == 0)\n\t\t\t\t\thiipl = pf2->ih_ipl;\n\t\t\t\telse if (pf2->ih_ipl > hiipl)\n\t\t\t\t\thiipl = pf2->ih_ipl;\n\t\t\t\tihcnt++;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If the ih being removed is lower priority than the lowest\n\t\t * priority remaining interrupt, up the priority.\n\t\t */\n\n\t\t/*\n\t\t * ihcnt is the number of interrupt handlers *not* including\n\t\t * the one about to be removed.\n\t\t */\n\t\tif (ihcnt == 0) {\n#ifdef DIAGNOSTIC\n\t\t\tif (pf->sc->ih == NULL)\n\t\t\t\tpanic(\"disestablishing last function, but card has no ih\");\n#endif\n\t\t\tpcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch,\n\t\t\t    pf->sc->ih);\n\n\t\t\treg = pcmcia_ccr_read(pf, PCMCIA_CCR_OPTION);\n\t\t\treg &= ~PCMCIA_CCR_OPTION_IREQ_ENABLE;\n\t\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\n\t\t\tpf->ih_fct = NULL;\n\t\t\tpf->ih_arg = NULL;\n\n\t\t\tpf->sc->ih = NULL;\n\t\t} else if (pf->ih_ipl > hiipl) {\n#ifdef DIAGNOSTIC\n\t\t\tif (pf->sc->ih == NULL)\n\t\t\t\tpanic(\"changing ih ipl, but card has no ih\");\n#endif\n\t\t\ts = spltty();\n\n\t\t\tpcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch,\n\t\t\t    pf->sc->ih);\n\t\t\tpf->sc->ih = pcmcia_chip_intr_establish(pf->sc->pct,\n\t\t\t    pf->sc->pch, pf, hiipl, pcmcia_card_intr, pf->sc);\n\n\t\t\t/* Null out the handler for this function. */\n\t\t\tpf->ih_fct = NULL;\n\t\t\tpf->ih_arg = NULL;\n\n\t\t\tsplx(s);\n\t\t} else {\n\t\t\ts = spltty();\n\n\t\t\tpf->ih_fct = NULL;\n\t\t\tpf->ih_arg = NULL;\n\n\t\t\tsplx(s);\n\t\t}\n\t} else\n\t\tpcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch, ih);\n}"
        }
      },
      {
        "call_info": {
          "callee": "if_deactivate",
          "args": [
            "ifp"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ray_disable",
          "args": [
            "sc"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "ray_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "827-845",
          "snippet": "void\nray_disable(sc)\n\tstruct ray_softc *sc;\n{\n\tRAY_DPRINTF((\"%s: disable\\n\", sc->sc_xname));\n\n\tif ((sc->sc_if.if_flags & IFF_RUNNING))\n\t\tray_stop(sc);\n\n\tsc->sc_resetloop = 0;\n\tsc->sc_rxoverflow = 0;\n\tsc->sc_rxcksum = 0;\n\tsc->sc_rxhcksum = 0;\n\tsc->sc_rxnoise = 0;\n\n\tif (sc->sc_ih)\n\t\tpcmcia_intr_disestablish(sc->sc_pf, sc->sc_ih);\n\tsc->sc_ih = 0;\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tsc_xname\tsc_dev.dv_xname",
            "#define\tsc_if\t\tsc_ec.ac_if",
            "#define\tsc_if\t\tsc_ec.ec_if"
          ],
          "globals_used": [
            "void ray_disable",
            "void ray_stop"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_xname\tsc_dev.dv_xname\n#define\tsc_if\t\tsc_ec.ac_if\n#define\tsc_if\t\tsc_ec.ec_if\n\nvoid ray_disable;\nvoid ray_stop;\n\nvoid\nray_disable(sc)\n\tstruct ray_softc *sc;\n{\n\tRAY_DPRINTF((\"%s: disable\\n\", sc->sc_xname));\n\n\tif ((sc->sc_if.if_flags & IFF_RUNNING))\n\t\tray_stop(sc);\n\n\tsc->sc_resetloop = 0;\n\tsc->sc_rxoverflow = 0;\n\tsc->sc_rxcksum = 0;\n\tsc->sc_rxhcksum = 0;\n\tsc->sc_rxnoise = 0;\n\n\tif (sc->sc_ih)\n\t\tpcmcia_intr_disestablish(sc->sc_pf, sc->sc_ih);\n\tsc->sc_ih = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splnet",
          "args": [],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAY_DPRINTF",
          "args": [
            "(\"%s: activate\\n\", sc->sc_xname)"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_xname\tsc_dev.dv_xname\n#define\tsc_if\t\tsc_ec.ac_if\n#define\tsc_if\t\tsc_ec.ec_if\n\nint ray_activate;\nvoid ray_disable;\n\nint\nray_activate(dev, act)\n\tstruct device *dev;\n\tenum devact act;\n{\n\tstruct ray_softc *sc = (struct ray_softc *)dev;\n\tstruct ifnet *ifp = &sc->sc_if;\n\tint s;\n\tint rv = 0;\n\n\tRAY_DPRINTF((\"%s: activate\\n\", sc->sc_xname));\n\n\ts = splnet();\n\tswitch (act) {\n\tcase DVACT_ACTIVATE:\n\t\trv = EOPNOTSUPP;\n\t\tbreak;\n\n\tcase DVACT_DEACTIVATE:\n\t\tif (ifp->if_flags & IFF_RUNNING)\n\t\t\tray_disable(sc);\n#ifdef __NetBSD__\n\t\tif_deactivate(ifp);\n#elif defined(__OpenBSD__)\n\t\tpcmcia_intr_disestablish(sc->sc_pf, sc->sc_ih);\n\t\tpcmcia_function_disable(sc->sc_pf);\n#endif\n\t\tbreak;\n\t}\n\tsplx(s);\n\treturn (rv);\n}"
  },
  {
    "function_name": "ray_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
    "lines": "547-727",
    "snippet": "void\nray_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct ray_ecf_startup *ep;\n\tstruct pcmcia_attach_args *pa;\n\tstruct ray_softc *sc;\n\tstruct ifnet *ifp;\n\tbus_addr_t memoff;\n#ifdef __NetBSD__\n\tchar devinfo[256];\n#endif\n\n\tpa = aux;\n\tsc = (struct ray_softc *)self;\n\tsc->sc_pf = pa->pf;\n\tifp = &sc->sc_if;\n\tsc->sc_window = -1;\n#if RAY_USE_AMEM\n\tsc->sc_awindow = -1;\n#endif\n\n#ifdef __NetBSD__\n\t/* Print out what we are */\n\tpcmcia_devinfo(&pa->pf->sc->card, 0, devinfo, sizeof devinfo);\n\tprintf(\": %s\\n\", devinfo);\n#elif defined(__OpenBSD__)\n\tprintf(\"\\n\");\n#endif\n\n\t/* enable the card */\n\tpcmcia_function_init(sc->sc_pf, sc->sc_pf->cfe_head.sqh_first);\n\tif (pcmcia_function_enable(sc->sc_pf)) {\n\t\tprintf(\": failed to enable the card\");\n\t\treturn;\n\t}\n\n\t/*\n\t * map in the memory\n\t */\n\tif (pcmcia_mem_alloc(sc->sc_pf, RAY_SRAM_MEM_SIZE, &sc->sc_mem)) {\n\t\tprintf(\": can\\'t alloc shared memory\\n\");\n\t\tgoto fail;\n\t}\n\n\tif (pcmcia_mem_map(sc->sc_pf, PCMCIA_WIDTH_MEM8|PCMCIA_MEM_COMMON,\n\t    RAY_SRAM_MEM_BASE, RAY_SRAM_MEM_SIZE, &sc->sc_mem, &memoff,\n\t    &sc->sc_window)) {\n\t\tprintf(\": can\\'t map shared memory\\n\");\n\t\tpcmcia_mem_free(sc->sc_pf, &sc->sc_mem);\n\t\tgoto fail;\n\t}\n\n#if RAY_USE_AMEM\n\t/* use the already mapped ccrt in our pf */\n\t/*\n\t * map in the memory\n\t */\n\tif (pcmcia_mem_alloc(sc->sc_pf, 0x1000, &sc->sc_amem)) {\n\t\tprintf(\": can\\'t alloc attr memory\\n\");\n\t\tgoto fail;\n\t}\n\n\tif (pcmcia_mem_map(sc->sc_pf, PCMCIA_MEM_ATTR, 0,\n\t    0x1000, &sc->sc_amem, &memoff, &sc->sc_awindow)) {\n\t\tprintf(\": can\\'t map attr memory\\n\");\n\t\tpcmcia_mem_free(sc->sc_pf, &sc->sc_amem);\n\t\tgoto fail;\n\t}\n#endif\n\t/* get startup results */\n\tep = &sc->sc_ecf_startup;\n\tray_read_region(sc, RAY_ECF_TO_HOST_BASE, ep,\n\t    sizeof(sc->sc_ecf_startup));\n\n\t/* check to see that card initialized properly */\n\tif (ep->e_status != RAY_ECFS_CARD_OK) {\n\t\tprintf(\": card failed self test: status %d\\n\",\n\t\t    sc->sc_ecf_startup.e_status);\n\t\tgoto fail;\n\t}\n\n\t/* check firmware version */\n\tif (sc->sc_version != SC_BUILD_4 && sc->sc_version != SC_BUILD_5) {\n\t\tprintf(\": unsupported firmware version %d\\n\",\n\t\t    ep->e_fw_build_string);\n\t\tgoto fail;\n\t}\n\n\t/* clear any interrupt if present */\n\tREG_WRITE(sc, RAY_HCSIR, 0);\n\n\t/*\n\t * set the parameters that will survive stop/init\n\t */\n\tmemset(sc->sc_cnwid, 0, sizeof(sc->sc_cnwid));\n\tmemset(sc->sc_dnwid, 0, sizeof(sc->sc_dnwid));\n\tstrncpy(sc->sc_dnwid, RAY_DEF_NWID, sizeof(sc->sc_dnwid));\n\tstrncpy(sc->sc_cnwid, RAY_DEF_NWID, sizeof(sc->sc_dnwid));\n\tsc->sc_omode = sc->sc_mode = RAY_MODE_DEFAULT;\n\tsc->sc_countrycode = sc->sc_dcountrycode = RAY_PID_COUNTRY_CODE_DEFAULT;\n\tsc->sc_resumeinit = 0;\n\n#ifdef __NetBSD__\n\tcallout_init(&sc->sc_check_ccs_ch);\n\tcallout_init(&sc->sc_check_scheduled_ch);\n\tcallout_init(&sc->sc_reset_resetloop_ch);\n\tcallout_init(&sc->sc_disable_ch);\n\tcallout_init(&sc->sc_start_join_timo_ch);\n#elif defined(__OpenBSD__)\n\ttimeout_set(&sc->sc_check_ccs_ch, ray_check_ccs, sc);\n\ttimeout_set(&sc->sc_check_scheduled_ch, ray_check_scheduled, sc);\n\ttimeout_set(&sc->sc_reset_resetloop_ch, ray_reset_resetloop, sc);\n\ttimeout_set(&sc->sc_disable_ch, (void (*)(void *))ray_disable, sc);\n\ttimeout_set(&sc->sc_start_join_timo_ch, ray_start_join_timo, sc);\n#endif\n\t/*\n\t * attach the interface\n\t */\n\t/* The version isn't the most accurate way, but it's easy. */\n\tprintf(\"%s: firmware version %d\\n\", sc->sc_dev.dv_xname,sc->sc_version);\n\tif (sc->sc_version != SC_BUILD_4)\n\t\tprintf(\"%s: supported rates %0x:%0x:%0x:%0x:%0x:%0x:%0x:%0x\\n\",\n\t\t    sc->sc_xname, ep->e_rates[0], ep->e_rates[1],\n\t\t    ep->e_rates[2], ep->e_rates[3], ep->e_rates[4],\n\t\t    ep->e_rates[5], ep->e_rates[6], ep->e_rates[7]);\n\tprintf(\"%s: 802.11 address %s\\n\", sc->sc_xname,\n\t    ether_sprintf(ep->e_station_addr));\n\n\tmemcpy(ifp->if_xname, sc->sc_xname, IFNAMSIZ);\n\tifp->if_softc = sc;\n\tifp->if_start = ray_if_start;\n\tifp->if_ioctl = ray_ioctl;\n\tifp->if_mtu = ETHERMTU;\n\tifp->if_flags = IFF_BROADCAST|IFF_SIMPLEX|IFF_MULTICAST;\n\tif_attach(ifp);\n#ifdef __NetBSD__\n\tether_ifattach(ifp, ep->e_station_addr);\n#elif defined(__OpenBSD__)\n\tmemcpy(&sc->sc_ec.ac_enaddr, ep->e_station_addr, ETHER_ADDR_LEN);\n\tether_ifattach(ifp);\n#endif\n\t/* need enough space for ieee80211_header + (snap or e2) */\n\tifp->if_hdrlen =\n\t    sizeof(struct ieee80211_frame) + sizeof(struct ether_header);\n\n\tifmedia_init(&sc->sc_media, 0, ray_media_change, ray_media_status);\n\tifmedia_add(&sc->sc_media, IFM_ADHOC, 0, 0);\n\tifmedia_add(&sc->sc_media, IFM_INFRA, 0, 0);\n\tif (sc->sc_mode == SC_MODE_ADHOC)\n\t\tifmedia_set(&sc->sc_media, IFM_ADHOC);\n\telse\n\t\tifmedia_set(&sc->sc_media, IFM_INFRA);\n\n#if NBPFILTER > 0\n\tbpfattach(&ifp->if_bpf, ifp, DLT_EN10MB, sizeof(struct ether_header));\n#endif\n\t/* disable the card */\n\tpcmcia_function_disable(sc->sc_pf);\n\n\tsc->sc_sdhook = shutdownhook_establish(ray_shutdown, sc);\n\tsc->sc_pwrhook = powerhook_establish(ray_power, sc);\n\n\treturn;\nfail:\n\t/* disable the card */\n\tpcmcia_function_disable(sc->sc_pf);\n\n\t/* free the alloc/map */\n#if RAY_USE_AMEM\n\tif (sc->sc_awindow != -1) {\n\t\tpcmcia_mem_unmap(sc->sc_pf, sc->sc_awindow);\n\t\tpcmcia_mem_free(sc->sc_pf, &sc->sc_amem);\n\t}\n#endif\n\tif (sc->sc_window != -1) {\n\t\tpcmcia_mem_unmap(sc->sc_pf, sc->sc_window);\n\t\tpcmcia_mem_free(sc->sc_pf, &sc->sc_mem);\n\t}\n}",
    "includes": [
      "#include <dev/pcmcia/if_rayreg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_llc.h>",
      "#include <net/if_media.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/timeout.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [
      "#define\tSC_BUILD_4\t0x55",
      "#define\tSC_BUILD_5\t0x5",
      "#define\tIFM_INFRA\t\\\n\tIFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_FH2, 0, 0)",
      "#define\tIFM_ADHOC\t\\\n\tIFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_FH2, IFM_IEEE80211_ADHOC, 0)",
      "#define\tSC_MODE_ADHOC\t0\t/* ad-hoc mode */",
      "#define\tsc_xname\tsc_dev.dv_xname",
      "#define\tsc_if\t\tsc_ec.ac_if",
      "#define\tsc_if\t\tsc_ec.ec_if",
      "#define\tsc_version\tsc_ecf_startup.e_fw_build_string",
      "#define\tRAY_DEF_NWID\t\"NETWORK_NAME\"",
      "#define\tRAY_MODE_DEFAULT\tSC_MODE_ADHOC",
      "#define\tRAY_PID_COUNTRY_CODE_DEFAULT\tRAY_PID_COUNTRY_CODE_USA",
      "#define RAY_USE_AMEM 0",
      "#define\tPCMCIA_WIDTH_MEM8\t0"
    ],
    "globals_used": [
      "void ray_attach",
      "void ray_check_ccs",
      "void ray_check_scheduled",
      "void ray_disable",
      "void ray_if_start",
      "int ray_ioctl",
      "int ray_media_change",
      "void ray_media_status",
      "void ray_power",
      "void ray_reset_resetloop",
      "void ray_shutdown",
      "void ray_start_join_timo"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcmcia_mem_free",
          "args": [
            "sc->sc_pf",
            "&sc->sc_mem"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_pcmcia_mem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "2382-2395",
          "snippet": "STATIC void\npccbb_pcmcia_mem_free(pch, pcmhp)\n\tpcmcia_chipset_handle_t pch;\n\tstruct pcmcia_mem_handle *pcmhp;\n{\n#if rbus\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)ph->ph_parent;\n\n\trbus_space_free(sc->sc_rbus_memt, pcmhp->memh, pcmhp->realsize, NULL);\n#else\n\tbus_space_free(pcmhp->memt, pcmhp->memh, pcmhp->realsize);\n#endif\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define STATIC static",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int",
            "cb_reset __P((struct pccbb_softc *));",
            "STATIC int",
            "cb_detect_voltage __P((struct pccbb_softc *));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "pccbb_pcmcia_mem_alloc __P((pcmcia_chipset_handle_t, bus_size_t,\n    struct pcmcia_mem_handle *));",
            "STATIC void",
            "pccbb_pcmcia_mem_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_mem_handle *));",
            "STATIC int",
            "STATIC void",
            "pccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "pccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC void",
            "pccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));",
            "STATIC void",
            "pccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));",
            "STATIC void",
            "pccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));",
            "STATIC int",
            "pccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));",
            "struct pccbb_softc *sc = psc->cpc_parent;",
            "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
            "struct pcic_handle *ph = poll->ph;",
            "struct pccbb_softc *sc = ph->sc;",
            "STATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define STATIC static\n#define STATIC\n\nSTATIC int;\ncb_reset __P((struct pccbb_softc *));\nSTATIC int;\ncb_detect_voltage __P((struct pccbb_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\npccbb_pcmcia_mem_alloc __P((pcmcia_chipset_handle_t, bus_size_t,\n    struct pcmcia_mem_handle *));\nSTATIC void;\npccbb_pcmcia_mem_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_mem_handle *));\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC void;\npccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));\nSTATIC void;\npccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));\nSTATIC void;\npccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));\nSTATIC int;\npccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));\nstruct pccbb_softc *sc = psc->cpc_parent;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pcic_handle *ph = poll->ph;\nstruct pccbb_softc *sc = ph->sc;\nSTATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;\n\nSTATIC void\npccbb_pcmcia_mem_free(pch, pcmhp)\n\tpcmcia_chipset_handle_t pch;\n\tstruct pcmcia_mem_handle *pcmhp;\n{\n#if rbus\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)ph->ph_parent;\n\n\trbus_space_free(sc->sc_rbus_memt, pcmhp->memh, pcmhp->realsize, NULL);\n#else\n\tbus_space_free(pcmhp->memt, pcmhp->memh, pcmhp->realsize);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_mem_unmap",
          "args": [
            "sc->sc_pf",
            "sc->sc_window"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_pcmcia_mem_unmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "2584-2601",
          "snippet": "STATIC void\npccbb_pcmcia_mem_unmap(pch, window)\n\tpcmcia_chipset_handle_t pch;\n\tint window;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tint reg;\n\n\tif (window >= PCIC_MEM_WINS) {\n\t\tpanic(\"pccbb_pcmcia_mem_unmap: window out of range\");\n\t}\n\n\treg = Pcic_read(ph, PCIC_ADDRWIN_ENABLE);\n\treg &= ~(1 << window);\n\tPcic_write(ph, PCIC_ADDRWIN_ENABLE, reg);\n\n\tph->memalloc &= ~(1 << window);\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define STATIC static",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "pccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "pccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC void",
            "pccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));",
            "STATIC void",
            "pccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));",
            "STATIC void",
            "pccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));",
            "STATIC int",
            "pccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));",
            "struct pcic_handle *ph = poll->ph;",
            "STATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define STATIC static\n#define STATIC\n\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC void;\npccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));\nSTATIC void;\npccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));\nSTATIC void;\npccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));\nSTATIC int;\npccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));\nstruct pcic_handle *ph = poll->ph;\nSTATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;\n\nSTATIC void\npccbb_pcmcia_mem_unmap(pch, window)\n\tpcmcia_chipset_handle_t pch;\n\tint window;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tint reg;\n\n\tif (window >= PCIC_MEM_WINS) {\n\t\tpanic(\"pccbb_pcmcia_mem_unmap: window out of range\");\n\t}\n\n\treg = Pcic_read(ph, PCIC_ADDRWIN_ENABLE);\n\treg &= ~(1 << window);\n\tPcic_write(ph, PCIC_ADDRWIN_ENABLE, reg);\n\n\tph->memalloc &= ~(1 << window);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_function_disable",
          "args": [
            "sc->sc_pf"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_function_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "570-622",
          "snippet": "void\npcmcia_function_disable(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct pcmcia_function *tmp;\n\n\tif (pf->cfe == NULL)\n\t\tpanic(\"pcmcia_function_enable: function not initialized\");\n\n\tif ((pf->pf_flags & PFF_ENABLED) == 0) {\n\t\t/*\n\t\t * Don't do anything if we're already disabled.\n\t\t */\n\t\treturn;\n\t}\n\n\t/* If there was no CIS don't mess with CCR */\n\tif (pf->pf_flags & PFF_FAKE) {\n\t\tpf->pf_flags &= ~PFF_ENABLED;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * it's possible for different functions' CCRs to be in the same\n\t * underlying page.  Check for that.  Note we mark us as disabled\n\t * first to avoid matching ourself.\n\t */\n\tpf->pf_flags &= ~PFF_ENABLED;\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t    tmp = tmp->pf_list.sqe_next) {\n\t\tif ((tmp->pf_flags & PFF_ENABLED) &&\n\t\t    (pf->ccr_base >= (tmp->ccr_base - tmp->pf_ccr_offset)) &&\n\t\t    ((pf->ccr_base + PCMCIA_CCR_SIZE) <=\n\t\t(tmp->ccr_base - tmp->pf_ccr_offset + tmp->pf_ccr_realsize)))\n\t\t\tbreak;\n\t}\n\n\t/* Not used by anyone else; unmap the CCR. */\n\tif (tmp == NULL) {\n\t\tpcmcia_mem_unmap(pf, pf->pf_ccr_window);\n\t\tpcmcia_mem_free(pf, &pf->pf_pcmh);\n\t}\n\n done:\n\t/*\n\t * Decrement the reference count, and power down the socket, if\n\t * necessary.\n\t */\n\tif (--pf->sc->sc_enabled_count == 0)\n\t\tpcmcia_chip_socket_disable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: --enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\n\nvoid\npcmcia_function_disable(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct pcmcia_function *tmp;\n\n\tif (pf->cfe == NULL)\n\t\tpanic(\"pcmcia_function_enable: function not initialized\");\n\n\tif ((pf->pf_flags & PFF_ENABLED) == 0) {\n\t\t/*\n\t\t * Don't do anything if we're already disabled.\n\t\t */\n\t\treturn;\n\t}\n\n\t/* If there was no CIS don't mess with CCR */\n\tif (pf->pf_flags & PFF_FAKE) {\n\t\tpf->pf_flags &= ~PFF_ENABLED;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * it's possible for different functions' CCRs to be in the same\n\t * underlying page.  Check for that.  Note we mark us as disabled\n\t * first to avoid matching ourself.\n\t */\n\tpf->pf_flags &= ~PFF_ENABLED;\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t    tmp = tmp->pf_list.sqe_next) {\n\t\tif ((tmp->pf_flags & PFF_ENABLED) &&\n\t\t    (pf->ccr_base >= (tmp->ccr_base - tmp->pf_ccr_offset)) &&\n\t\t    ((pf->ccr_base + PCMCIA_CCR_SIZE) <=\n\t\t(tmp->ccr_base - tmp->pf_ccr_offset + tmp->pf_ccr_realsize)))\n\t\t\tbreak;\n\t}\n\n\t/* Not used by anyone else; unmap the CCR. */\n\tif (tmp == NULL) {\n\t\tpcmcia_mem_unmap(pf, pf->pf_ccr_window);\n\t\tpcmcia_mem_free(pf, &pf->pf_pcmh);\n\t}\n\n done:\n\t/*\n\t * Decrement the reference count, and power down the socket, if\n\t * necessary.\n\t */\n\tif (--pf->sc->sc_enabled_count == 0)\n\t\tpcmcia_chip_socket_disable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: --enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n}"
        }
      },
      {
        "call_info": {
          "callee": "powerhook_establish",
          "args": [
            "ray_power",
            "sc"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shutdownhook_establish",
          "args": [
            "ray_shutdown",
            "sc"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpfattach",
          "args": [
            "&ifp->if_bpf",
            "ifp",
            "DLT_EN10MB",
            "sizeof(struct ether_header)"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_set",
          "args": [
            "&sc->sc_media",
            "IFM_INFRA"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_set",
          "args": [
            "&sc->sc_media",
            "IFM_ADHOC"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "&sc->sc_media",
            "IFM_INFRA",
            "0",
            "0"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "&sc->sc_media",
            "IFM_ADHOC",
            "0",
            "0"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_init",
          "args": [
            "&sc->sc_media",
            "0",
            "ray_media_change",
            "ray_media_status"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_ifattach",
          "args": [
            "ifp"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&sc->sc_ec.ac_enaddr",
            "ep->e_station_addr",
            "ETHER_ADDR_LEN"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_ifattach",
          "args": [
            "ifp",
            "ep->e_station_addr"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_attach",
          "args": [
            "ifp"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ifp->if_xname",
            "sc->sc_xname",
            "IFNAMSIZ"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: 802.11 address %s\\n\"",
            "sc->sc_xname",
            "ether_sprintf(ep->e_station_addr)"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ether_sprintf",
          "args": [
            "ep->e_station_addr"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timeout_set",
          "args": [
            "&sc->sc_start_join_timo_ch",
            "ray_start_join_timo",
            "sc"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timeout_set",
          "args": [
            "&sc->sc_disable_ch",
            "(void (*)(void *))ray_disable",
            "sc"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timeout_set",
          "args": [
            "&sc->sc_reset_resetloop_ch",
            "ray_reset_resetloop",
            "sc"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timeout_set",
          "args": [
            "&sc->sc_check_scheduled_ch",
            "ray_check_scheduled",
            "sc"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timeout_set",
          "args": [
            "&sc->sc_check_ccs_ch",
            "ray_check_ccs",
            "sc"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "callout_init",
          "args": [
            "&sc->sc_start_join_timo_ch"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "callout_init",
          "args": [
            "&sc->sc_disable_ch"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "callout_init",
          "args": [
            "&sc->sc_reset_resetloop_ch"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "callout_init",
          "args": [
            "&sc->sc_check_scheduled_ch"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "callout_init",
          "args": [
            "&sc->sc_check_ccs_ch"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "sc->sc_cnwid",
            "RAY_DEF_NWID",
            "sizeof(sc->sc_dnwid)"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "sc->sc_dnwid",
            "RAY_DEF_NWID",
            "sizeof(sc->sc_dnwid)"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "sc->sc_dnwid",
            "0",
            "sizeof(sc->sc_dnwid)"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "sc->sc_cnwid",
            "0",
            "sizeof(sc->sc_cnwid)"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REG_WRITE",
          "args": [
            "sc",
            "RAY_HCSIR",
            "0"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ray_read_region",
          "args": [
            "sc",
            "RAY_ECF_TO_HOST_BASE",
            "ep",
            "sizeof(sc->sc_ecf_startup)"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "ray_read_region",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "3063-3116",
          "snippet": "void\nray_read_region(sc, off, vp, c)\n\tstruct ray_softc *sc;\n\tbus_size_t off;\n\tvoid *vp;\n\tsize_t c;\n{\n#ifdef RAY_USE_OPTIMIZED_COPY\n\tu_int n2, n4, tmp;\n\tu_int8_t *p;\n\n\tp = vp;\n\n\t/* XXX we may be making poor assumptions here but lets hope */\n\tswitch ((off|(bus_addr_t)p) & 0x03) {\n\tcase 0:\n\t\tif ((n4 = c / 4)) {\n\t\t\tbus_space_read_region_4(sc->sc_memt, sc->sc_memh, off,\n\t\t\t    p, n4);\n\t\t\ttmp = c & ~0x3;\n\t\t\tc &= 0x3;\n\t\t\tp += tmp;\n\t\t\toff += tmp;\n\t\t}\n\t\tswitch (c) {\n\t\tcase 3:\n\t\t\t*p = bus_space_read_1(sc->sc_memt,sc->sc_memh, off);\n\t\t\tp++, off++;\n\t\tcase 2:\n\t\t\t*p = bus_space_read_1(sc->sc_memt,sc->sc_memh, off);\n\t\t\tp++, off++;\n\t\tcase 1:\n\t\t\t*p = bus_space_read_1(sc->sc_memt,sc->sc_memh, off);\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tif ((n2 = (c >> 1)))\n\t\t\tbus_space_read_region_2(sc->sc_memt, sc->sc_memh, off,\n\t\t\t    p, n2);\n\t\tif (c & 1) {\n\t\t\tc &= ~0x1;\n\t\t\t*(p + c) = bus_space_read_1(sc->sc_memt, sc->sc_memh,\n\t\t\t    off + c);\n\t\t}\n\t\tbreak;\n\tcase 1:\n\tcase 3:\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_memh, off, p, c);\n\t\tbreak;\n\t}\n#else\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_memh, off, vp, c);\n#endif\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tsc_memh\tsc_mem.memh",
            "#define\tsc_memt\tsc_mem.memt"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_memh\tsc_mem.memh\n#define\tsc_memt\tsc_mem.memt\n\nvoid\nray_read_region(sc, off, vp, c)\n\tstruct ray_softc *sc;\n\tbus_size_t off;\n\tvoid *vp;\n\tsize_t c;\n{\n#ifdef RAY_USE_OPTIMIZED_COPY\n\tu_int n2, n4, tmp;\n\tu_int8_t *p;\n\n\tp = vp;\n\n\t/* XXX we may be making poor assumptions here but lets hope */\n\tswitch ((off|(bus_addr_t)p) & 0x03) {\n\tcase 0:\n\t\tif ((n4 = c / 4)) {\n\t\t\tbus_space_read_region_4(sc->sc_memt, sc->sc_memh, off,\n\t\t\t    p, n4);\n\t\t\ttmp = c & ~0x3;\n\t\t\tc &= 0x3;\n\t\t\tp += tmp;\n\t\t\toff += tmp;\n\t\t}\n\t\tswitch (c) {\n\t\tcase 3:\n\t\t\t*p = bus_space_read_1(sc->sc_memt,sc->sc_memh, off);\n\t\t\tp++, off++;\n\t\tcase 2:\n\t\t\t*p = bus_space_read_1(sc->sc_memt,sc->sc_memh, off);\n\t\t\tp++, off++;\n\t\tcase 1:\n\t\t\t*p = bus_space_read_1(sc->sc_memt,sc->sc_memh, off);\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tif ((n2 = (c >> 1)))\n\t\t\tbus_space_read_region_2(sc->sc_memt, sc->sc_memh, off,\n\t\t\t    p, n2);\n\t\tif (c & 1) {\n\t\t\tc &= ~0x1;\n\t\t\t*(p + c) = bus_space_read_1(sc->sc_memt, sc->sc_memh,\n\t\t\t    off + c);\n\t\t}\n\t\tbreak;\n\tcase 1:\n\tcase 3:\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_memh, off, p, c);\n\t\tbreak;\n\t}\n#else\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_memh, off, vp, c);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_mem_map",
          "args": [
            "sc->sc_pf",
            "PCMCIA_MEM_ATTR",
            "0",
            "0x1000",
            "&sc->sc_amem",
            "&memoff",
            "&sc->sc_awindow"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_pcmcia_mem_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "2509-2575",
          "snippet": "STATIC int\npccbb_pcmcia_mem_map(pch, kind, card_addr, size, pcmhp, offsetp, windowp)\n\tpcmcia_chipset_handle_t pch;\n\tint kind;\n\tbus_addr_t card_addr;\n\tbus_size_t size;\n\tstruct pcmcia_mem_handle *pcmhp;\n\tbus_addr_t *offsetp;\n\tint *windowp;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tbus_addr_t busaddr;\n\tlong card_offset;\n\tint win;\n\n\tfor (win = 0; win < PCIC_MEM_WINS; ++win) {\n\t\tif ((ph->memalloc & (1 << win)) == 0) {\n\t\t\tph->memalloc |= (1 << win);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (win == PCIC_MEM_WINS) {\n\t\treturn 1;\n\t}\n\n\t*windowp = win;\n\n\t/* XXX this is pretty gross */\n\n\tif (((struct pccbb_softc *)ph->ph_parent)->sc_memt != pcmhp->memt) {\n\t\tpanic(\"pccbb_pcmcia_mem_map memt is bogus\");\n\t}\n\n\tbusaddr = pcmhp->addr;\n\n\t/* \n\t * compute the address offset to the pcmcia address space for the\n\t * pcic.  this is intentionally signed.  The masks and shifts below\n\t * will cause TRT to happen in the pcic registers.  Deal with making\n\t * sure the address is aligned, and return the alignment offset.\n\t */\n\n\t*offsetp = card_addr % PCIC_MEM_PAGESIZE;\n\tcard_addr -= *offsetp;\n\n\tDPRINTF((\"pccbb_pcmcia_mem_map window %d bus %lx+%lx+%lx at card addr \"\n\t    \"%lx\\n\", win, (u_long) busaddr, (u_long) * offsetp, (u_long) size,\n\t    (u_long) card_addr));\n\n\t/* \n\t * include the offset in the size, and decrement size by one, since\n\t * the hw wants start/stop\n\t */\n\tsize += *offsetp - 1;\n\n\tcard_offset = (((long)card_addr) - ((long)busaddr));\n\n\tph->mem[win].addr = busaddr;\n\tph->mem[win].size = size;\n\tph->mem[win].offset = card_offset;\n\tph->mem[win].kind = kind;\n\n\tpccbb_pcmcia_do_mem_map(ph, win);\n\n\treturn 0;\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define STATIC static",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int",
            "cb_reset __P((struct pccbb_softc *));",
            "STATIC int",
            "cb_detect_voltage __P((struct pccbb_softc *));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "pccbb_pcmcia_mem_alloc __P((pcmcia_chipset_handle_t, bus_size_t,\n    struct pcmcia_mem_handle *));",
            "STATIC void",
            "pccbb_pcmcia_mem_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_mem_handle *));",
            "STATIC int",
            "pccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));",
            "STATIC void",
            "pccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "pccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC void",
            "pccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));",
            "STATIC void",
            "pccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));",
            "STATIC void",
            "pccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));",
            "STATIC int",
            "pccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));",
            "static void pccbb_pcmcia_do_mem_map",
            "struct pcic_handle *ph = poll->ph;",
            "STATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define STATIC static\n#define STATIC\n\nSTATIC int;\ncb_reset __P((struct pccbb_softc *));\nSTATIC int;\ncb_detect_voltage __P((struct pccbb_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\npccbb_pcmcia_mem_alloc __P((pcmcia_chipset_handle_t, bus_size_t,\n    struct pcmcia_mem_handle *));\nSTATIC void;\npccbb_pcmcia_mem_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_mem_handle *));\nSTATIC int;\npccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));\nSTATIC void;\npccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC void;\npccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));\nSTATIC void;\npccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));\nSTATIC void;\npccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));\nSTATIC int;\npccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));\nstatic void pccbb_pcmcia_do_mem_map;\nstruct pcic_handle *ph = poll->ph;\nSTATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;\n\nSTATIC int\npccbb_pcmcia_mem_map(pch, kind, card_addr, size, pcmhp, offsetp, windowp)\n\tpcmcia_chipset_handle_t pch;\n\tint kind;\n\tbus_addr_t card_addr;\n\tbus_size_t size;\n\tstruct pcmcia_mem_handle *pcmhp;\n\tbus_addr_t *offsetp;\n\tint *windowp;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tbus_addr_t busaddr;\n\tlong card_offset;\n\tint win;\n\n\tfor (win = 0; win < PCIC_MEM_WINS; ++win) {\n\t\tif ((ph->memalloc & (1 << win)) == 0) {\n\t\t\tph->memalloc |= (1 << win);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (win == PCIC_MEM_WINS) {\n\t\treturn 1;\n\t}\n\n\t*windowp = win;\n\n\t/* XXX this is pretty gross */\n\n\tif (((struct pccbb_softc *)ph->ph_parent)->sc_memt != pcmhp->memt) {\n\t\tpanic(\"pccbb_pcmcia_mem_map memt is bogus\");\n\t}\n\n\tbusaddr = pcmhp->addr;\n\n\t/* \n\t * compute the address offset to the pcmcia address space for the\n\t * pcic.  this is intentionally signed.  The masks and shifts below\n\t * will cause TRT to happen in the pcic registers.  Deal with making\n\t * sure the address is aligned, and return the alignment offset.\n\t */\n\n\t*offsetp = card_addr % PCIC_MEM_PAGESIZE;\n\tcard_addr -= *offsetp;\n\n\tDPRINTF((\"pccbb_pcmcia_mem_map window %d bus %lx+%lx+%lx at card addr \"\n\t    \"%lx\\n\", win, (u_long) busaddr, (u_long) * offsetp, (u_long) size,\n\t    (u_long) card_addr));\n\n\t/* \n\t * include the offset in the size, and decrement size by one, since\n\t * the hw wants start/stop\n\t */\n\tsize += *offsetp - 1;\n\n\tcard_offset = (((long)card_addr) - ((long)busaddr));\n\n\tph->mem[win].addr = busaddr;\n\tph->mem[win].size = size;\n\tph->mem[win].offset = card_offset;\n\tph->mem[win].kind = kind;\n\n\tpccbb_pcmcia_do_mem_map(ph, win);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_mem_alloc",
          "args": [
            "sc->sc_pf",
            "0x1000",
            "&sc->sc_amem"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_pcmcia_mem_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "2307-2373",
          "snippet": "STATIC int\npccbb_pcmcia_mem_alloc(pch, size, pcmhp)\n\tpcmcia_chipset_handle_t pch;\n\tbus_size_t size;\n\tstruct pcmcia_mem_handle *pcmhp;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tbus_space_handle_t memh;\n\tbus_addr_t addr;\n\tbus_size_t sizepg;\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)ph->ph_parent;\n#if rbus\n\trbus_tag_t rb;\n#endif\n\n\t/* out of sc->memh, allocate as many pages as necessary */\n\n\t/* convert size to PCIC pages */\n\t/* \n\t * This is not enough; when the requested region is on the page\n\t * boundaries, this may calculate wrong result.\n\t */\n\tsizepg = (size + (PCIC_MEM_PAGESIZE - 1)) / PCIC_MEM_PAGESIZE;\n#if 0\n\tif (sizepg > PCIC_MAX_MEM_PAGES) {\n\t\treturn 1;\n\t}\n#endif\n\n\tif (!(sc->sc_pcmcia_flags & PCCBB_PCMCIA_MEM_32)) {\n\t\treturn 1;\n\t}\n\n\taddr = 0;\t\t       /* XXX gcc -Wuninitialized */\n\n#if rbus\n\trb = sc->sc_rbus_memt;\n\tif (rbus_space_alloc(rb, 0, sizepg * PCIC_MEM_PAGESIZE,\n\t    sizepg * PCIC_MEM_PAGESIZE - 1, PCIC_MEM_PAGESIZE, 0,\n\t    &addr, &memh)) {\n\t\treturn 1;\n\t}\n#else\n\tif (bus_space_alloc(sc->sc_memt, sc->sc_mem_start, sc->sc_mem_end,\n\t    sizepg * PCIC_MEM_PAGESIZE, PCIC_MEM_PAGESIZE,\n\t    0, /* boundary */\n\t    0,\t/* flags */\n\t    &addr, &memh)) {\n\t\treturn 1;\n\t}\n#endif\n\n\tDPRINTF(\n\t    (\"pccbb_pcmcia_alloc_mem: addr 0x%lx size 0x%lx, realsize 0x%lx\\n\",\n\t    addr, size, sizepg * PCIC_MEM_PAGESIZE));\n\n\tpcmhp->memt = sc->sc_memt;\n\tpcmhp->memh = memh;\n\tpcmhp->addr = addr;\n\tpcmhp->size = size;\n\tpcmhp->realsize = sizepg * PCIC_MEM_PAGESIZE;\n\t/* What is mhandle?  I feel it is very dirty and it must go trush. */\n\tpcmhp->mhandle = 0;\n\t/* No offset???  Funny. */\n\n\treturn 0;\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define STATIC static",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int",
            "cb_reset __P((struct pccbb_softc *));",
            "STATIC int",
            "cb_detect_voltage __P((struct pccbb_softc *));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "pccbb_pcmcia_mem_alloc __P((pcmcia_chipset_handle_t, bus_size_t,\n    struct pcmcia_mem_handle *));",
            "STATIC void",
            "pccbb_pcmcia_mem_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_mem_handle *));",
            "STATIC int",
            "pccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));",
            "STATIC void",
            "pccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "pccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC void",
            "pccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));",
            "STATIC void",
            "pccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));",
            "STATIC void",
            "pccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));",
            "STATIC int",
            "pccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));",
            "struct pccbb_softc *sc = psc->cpc_parent;",
            "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
            "struct pcic_handle *ph = poll->ph;",
            "struct pccbb_softc *sc = ph->sc;",
            "STATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define STATIC static\n#define STATIC\n\nSTATIC int;\ncb_reset __P((struct pccbb_softc *));\nSTATIC int;\ncb_detect_voltage __P((struct pccbb_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\npccbb_pcmcia_mem_alloc __P((pcmcia_chipset_handle_t, bus_size_t,\n    struct pcmcia_mem_handle *));\nSTATIC void;\npccbb_pcmcia_mem_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_mem_handle *));\nSTATIC int;\npccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));\nSTATIC void;\npccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC void;\npccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));\nSTATIC void;\npccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));\nSTATIC void;\npccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));\nSTATIC int;\npccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));\nstruct pccbb_softc *sc = psc->cpc_parent;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pcic_handle *ph = poll->ph;\nstruct pccbb_softc *sc = ph->sc;\nSTATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;\n\nSTATIC int\npccbb_pcmcia_mem_alloc(pch, size, pcmhp)\n\tpcmcia_chipset_handle_t pch;\n\tbus_size_t size;\n\tstruct pcmcia_mem_handle *pcmhp;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tbus_space_handle_t memh;\n\tbus_addr_t addr;\n\tbus_size_t sizepg;\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)ph->ph_parent;\n#if rbus\n\trbus_tag_t rb;\n#endif\n\n\t/* out of sc->memh, allocate as many pages as necessary */\n\n\t/* convert size to PCIC pages */\n\t/* \n\t * This is not enough; when the requested region is on the page\n\t * boundaries, this may calculate wrong result.\n\t */\n\tsizepg = (size + (PCIC_MEM_PAGESIZE - 1)) / PCIC_MEM_PAGESIZE;\n#if 0\n\tif (sizepg > PCIC_MAX_MEM_PAGES) {\n\t\treturn 1;\n\t}\n#endif\n\n\tif (!(sc->sc_pcmcia_flags & PCCBB_PCMCIA_MEM_32)) {\n\t\treturn 1;\n\t}\n\n\taddr = 0;\t\t       /* XXX gcc -Wuninitialized */\n\n#if rbus\n\trb = sc->sc_rbus_memt;\n\tif (rbus_space_alloc(rb, 0, sizepg * PCIC_MEM_PAGESIZE,\n\t    sizepg * PCIC_MEM_PAGESIZE - 1, PCIC_MEM_PAGESIZE, 0,\n\t    &addr, &memh)) {\n\t\treturn 1;\n\t}\n#else\n\tif (bus_space_alloc(sc->sc_memt, sc->sc_mem_start, sc->sc_mem_end,\n\t    sizepg * PCIC_MEM_PAGESIZE, PCIC_MEM_PAGESIZE,\n\t    0, /* boundary */\n\t    0,\t/* flags */\n\t    &addr, &memh)) {\n\t\treturn 1;\n\t}\n#endif\n\n\tDPRINTF(\n\t    (\"pccbb_pcmcia_alloc_mem: addr 0x%lx size 0x%lx, realsize 0x%lx\\n\",\n\t    addr, size, sizepg * PCIC_MEM_PAGESIZE));\n\n\tpcmhp->memt = sc->sc_memt;\n\tpcmhp->memh = memh;\n\tpcmhp->addr = addr;\n\tpcmhp->size = size;\n\tpcmhp->realsize = sizepg * PCIC_MEM_PAGESIZE;\n\t/* What is mhandle?  I feel it is very dirty and it must go trush. */\n\tpcmhp->mhandle = 0;\n\t/* No offset???  Funny. */\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_function_enable",
          "args": [
            "sc->sc_pf"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_function_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "419-567",
          "snippet": "int\npcmcia_function_enable(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct pcmcia_function *tmp;\n\tint reg;\n\n\tif (pf->cfe == NULL)\n\t\tpanic(\"pcmcia_function_enable: function not initialized\");\n\n\t/*\n\t * Increase the reference count on the socket, enabling power, if\n\t * necessary.\n\t */\n\tif (pf->sc->sc_enabled_count++ == 0)\n\t\tpcmcia_chip_socket_enable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: ++enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n\n\tif (pf->pf_flags & PFF_ENABLED) {\n\t\t/*\n\t\t * Don't do anything if we're already enabled.\n\t\t */\n\t\tDPRINTF((\"%s: pcmcia_function_enable on enabled func\\n\"));\n\t\treturn (0);\n\t}\n\n\t/* If there was no CIS don't mess with CCR */\n\tif (pf->pf_flags & PFF_FAKE)\n\t\tgoto done;\n\n\t/*\n\t * It's possible for different functions' CCRs to be in the same\n\t * underlying page.  Check for that.\n\t */\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t    tmp = tmp->pf_list.sqe_next) {\n\t\tif ((tmp->pf_flags & PFF_ENABLED) &&\n\t\t    (pf->ccr_base >= (tmp->ccr_base - tmp->pf_ccr_offset)) &&\n\t\t    ((pf->ccr_base + PCMCIA_CCR_SIZE) <=\n\t\t     (tmp->ccr_base - tmp->pf_ccr_offset +\n\t\t      tmp->pf_ccr_realsize))) {\n\t\t\tpf->pf_ccrt = tmp->pf_ccrt;\n\t\t\tpf->pf_ccrh = tmp->pf_ccrh;\n\t\t\tpf->pf_ccr_realsize = tmp->pf_ccr_realsize;\n\n\t\t\t/*\n\t\t\t * pf->pf_ccr_offset = (tmp->pf_ccr_offset -\n\t\t\t * tmp->ccr_base) + pf->ccr_base;\n\t\t\t */\n\t\t\tpf->pf_ccr_offset =\n\t\t\t    (tmp->pf_ccr_offset + pf->ccr_base) -\n\t\t\t    tmp->ccr_base;\n\t\t\tpf->pf_ccr_window = tmp->pf_ccr_window;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (tmp == NULL) {\n\t\tif (pcmcia_mem_alloc(pf, PCMCIA_CCR_SIZE, &pf->pf_pcmh))\n\t\t\tgoto bad;\n\n\t\tif (pcmcia_mem_map(pf, PCMCIA_MEM_ATTR, pf->ccr_base,\n\t\t    PCMCIA_CCR_SIZE, &pf->pf_pcmh, &pf->pf_ccr_offset,\n\t\t    &pf->pf_ccr_window)) {\n\t\t\tpcmcia_mem_free(pf, &pf->pf_pcmh);\n\t\t\tgoto bad;\n\t\t}\n\t}\n\n\treg = (pf->cfe->number & PCMCIA_CCR_OPTION_CFINDEX);\n\treg |= PCMCIA_CCR_OPTION_LEVIREQ;\n\tif (pcmcia_mfc(pf->sc)) {\n\t\treg |= (PCMCIA_CCR_OPTION_FUNC_ENABLE |\n\t\t\tPCMCIA_CCR_OPTION_ADDR_DECODE);\n\t\tif (pf->ih_fct)\n\t\t\treg |= PCMCIA_CCR_OPTION_IREQ_ENABLE;\n\n\t}\n\t\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\n\treg = 0;\n\n\tif ((pf->cfe->flags & PCMCIA_CFE_IO16) == 0)\n\t\treg |= PCMCIA_CCR_STATUS_IOIS8;\n\tif (pf->cfe->flags & PCMCIA_CFE_AUDIO)\n\t\treg |= PCMCIA_CCR_STATUS_AUDIO;\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_STATUS, reg);\n\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_SOCKETCOPY, 0);\n\t\n\tif (pcmcia_mfc(pf->sc)) {\n\t\tlong tmp, iosize;\n\n\t\ttmp = pf->pf_mfc_iomax - pf->pf_mfc_iobase;\n\t\t/* round up to nearest (2^n)-1 */\n\t\tfor (iosize = 1; iosize < tmp; iosize <<= 1)\n\t\t\t;\n\t\tiosize--;\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE0,\n\t\t\t\t pf->pf_mfc_iobase & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE1,\n\t\t\t\t (pf->pf_mfc_iobase >> 8) & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE2, 0);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE3, 0);\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOSIZE, iosize);\n\t}\n\n#ifdef PCMCIADEBUG\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t     tmp = tmp->pf_list.sqe_next) {\n\t\tprintf(\"%s: function %d CCR at %d offset %lx: \"\n\t\t       \"%x %x %x %x, %x %x %x %x, %x\\n\",\n\t\t       tmp->sc->dev.dv_xname, tmp->number,\n\t\t       tmp->pf_ccr_window, tmp->pf_ccr_offset,\n\t\t       pcmcia_ccr_read(tmp, 0x00),\n\t\t       pcmcia_ccr_read(tmp, 0x02),\n\t\t       pcmcia_ccr_read(tmp, 0x04),\n\t\t       pcmcia_ccr_read(tmp, 0x06),\n\n\t\t       pcmcia_ccr_read(tmp, 0x0A),\n\t\t       pcmcia_ccr_read(tmp, 0x0C), \n\t\t       pcmcia_ccr_read(tmp, 0x0E),\n\t\t       pcmcia_ccr_read(tmp, 0x10),\n\n\t\t       pcmcia_ccr_read(tmp, 0x12));\n\t}\n#endif\n\n done:\n\tpf->pf_flags |= PFF_ENABLED;\n\tdelay(1000);\n\treturn (0);\n\n bad:\n\t/*\n\t * Decrement the reference count, and power down the socket, if\n\t * necessary.\n\t */\n\tif (--pf->sc->sc_enabled_count == 0)\n\t\tpcmcia_chip_socket_disable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: --enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n\n\treturn (1);\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;",
            "int (*ih_fct)"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\nint (*ih_fct);\n\nint\npcmcia_function_enable(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct pcmcia_function *tmp;\n\tint reg;\n\n\tif (pf->cfe == NULL)\n\t\tpanic(\"pcmcia_function_enable: function not initialized\");\n\n\t/*\n\t * Increase the reference count on the socket, enabling power, if\n\t * necessary.\n\t */\n\tif (pf->sc->sc_enabled_count++ == 0)\n\t\tpcmcia_chip_socket_enable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: ++enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n\n\tif (pf->pf_flags & PFF_ENABLED) {\n\t\t/*\n\t\t * Don't do anything if we're already enabled.\n\t\t */\n\t\tDPRINTF((\"%s: pcmcia_function_enable on enabled func\\n\"));\n\t\treturn (0);\n\t}\n\n\t/* If there was no CIS don't mess with CCR */\n\tif (pf->pf_flags & PFF_FAKE)\n\t\tgoto done;\n\n\t/*\n\t * It's possible for different functions' CCRs to be in the same\n\t * underlying page.  Check for that.\n\t */\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t    tmp = tmp->pf_list.sqe_next) {\n\t\tif ((tmp->pf_flags & PFF_ENABLED) &&\n\t\t    (pf->ccr_base >= (tmp->ccr_base - tmp->pf_ccr_offset)) &&\n\t\t    ((pf->ccr_base + PCMCIA_CCR_SIZE) <=\n\t\t     (tmp->ccr_base - tmp->pf_ccr_offset +\n\t\t      tmp->pf_ccr_realsize))) {\n\t\t\tpf->pf_ccrt = tmp->pf_ccrt;\n\t\t\tpf->pf_ccrh = tmp->pf_ccrh;\n\t\t\tpf->pf_ccr_realsize = tmp->pf_ccr_realsize;\n\n\t\t\t/*\n\t\t\t * pf->pf_ccr_offset = (tmp->pf_ccr_offset -\n\t\t\t * tmp->ccr_base) + pf->ccr_base;\n\t\t\t */\n\t\t\tpf->pf_ccr_offset =\n\t\t\t    (tmp->pf_ccr_offset + pf->ccr_base) -\n\t\t\t    tmp->ccr_base;\n\t\t\tpf->pf_ccr_window = tmp->pf_ccr_window;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (tmp == NULL) {\n\t\tif (pcmcia_mem_alloc(pf, PCMCIA_CCR_SIZE, &pf->pf_pcmh))\n\t\t\tgoto bad;\n\n\t\tif (pcmcia_mem_map(pf, PCMCIA_MEM_ATTR, pf->ccr_base,\n\t\t    PCMCIA_CCR_SIZE, &pf->pf_pcmh, &pf->pf_ccr_offset,\n\t\t    &pf->pf_ccr_window)) {\n\t\t\tpcmcia_mem_free(pf, &pf->pf_pcmh);\n\t\t\tgoto bad;\n\t\t}\n\t}\n\n\treg = (pf->cfe->number & PCMCIA_CCR_OPTION_CFINDEX);\n\treg |= PCMCIA_CCR_OPTION_LEVIREQ;\n\tif (pcmcia_mfc(pf->sc)) {\n\t\treg |= (PCMCIA_CCR_OPTION_FUNC_ENABLE |\n\t\t\tPCMCIA_CCR_OPTION_ADDR_DECODE);\n\t\tif (pf->ih_fct)\n\t\t\treg |= PCMCIA_CCR_OPTION_IREQ_ENABLE;\n\n\t}\n\t\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\n\treg = 0;\n\n\tif ((pf->cfe->flags & PCMCIA_CFE_IO16) == 0)\n\t\treg |= PCMCIA_CCR_STATUS_IOIS8;\n\tif (pf->cfe->flags & PCMCIA_CFE_AUDIO)\n\t\treg |= PCMCIA_CCR_STATUS_AUDIO;\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_STATUS, reg);\n\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_SOCKETCOPY, 0);\n\t\n\tif (pcmcia_mfc(pf->sc)) {\n\t\tlong tmp, iosize;\n\n\t\ttmp = pf->pf_mfc_iomax - pf->pf_mfc_iobase;\n\t\t/* round up to nearest (2^n)-1 */\n\t\tfor (iosize = 1; iosize < tmp; iosize <<= 1)\n\t\t\t;\n\t\tiosize--;\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE0,\n\t\t\t\t pf->pf_mfc_iobase & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE1,\n\t\t\t\t (pf->pf_mfc_iobase >> 8) & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE2, 0);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE3, 0);\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOSIZE, iosize);\n\t}\n\n#ifdef PCMCIADEBUG\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t     tmp = tmp->pf_list.sqe_next) {\n\t\tprintf(\"%s: function %d CCR at %d offset %lx: \"\n\t\t       \"%x %x %x %x, %x %x %x %x, %x\\n\",\n\t\t       tmp->sc->dev.dv_xname, tmp->number,\n\t\t       tmp->pf_ccr_window, tmp->pf_ccr_offset,\n\t\t       pcmcia_ccr_read(tmp, 0x00),\n\t\t       pcmcia_ccr_read(tmp, 0x02),\n\t\t       pcmcia_ccr_read(tmp, 0x04),\n\t\t       pcmcia_ccr_read(tmp, 0x06),\n\n\t\t       pcmcia_ccr_read(tmp, 0x0A),\n\t\t       pcmcia_ccr_read(tmp, 0x0C), \n\t\t       pcmcia_ccr_read(tmp, 0x0E),\n\t\t       pcmcia_ccr_read(tmp, 0x10),\n\n\t\t       pcmcia_ccr_read(tmp, 0x12));\n\t}\n#endif\n\n done:\n\tpf->pf_flags |= PFF_ENABLED;\n\tdelay(1000);\n\treturn (0);\n\n bad:\n\t/*\n\t * Decrement the reference count, and power down the socket, if\n\t * necessary.\n\t */\n\tif (--pf->sc->sc_enabled_count == 0)\n\t\tpcmcia_chip_socket_disable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: --enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_function_init",
          "args": [
            "sc->sc_pf",
            "sc->sc_pf->cfe_head.sqh_first"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_function_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "392-402",
          "snippet": "void\npcmcia_function_init(pf, cfe)\n\tstruct pcmcia_function *pf;\n\tstruct pcmcia_config_entry *cfe;\n{\n\tif (pf->pf_flags & PFF_ENABLED)\n\t\tpanic(\"pcmcia_function_init: function is enabled\");\n\n\t/* Remember which configuration entry we are using. */\n\tpf->cfe = cfe;\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\n\nvoid\npcmcia_function_init(pf, cfe)\n\tstruct pcmcia_function *pf;\n\tstruct pcmcia_config_entry *cfe;\n{\n\tif (pf->pf_flags & PFF_ENABLED)\n\t\tpanic(\"pcmcia_function_init: function is enabled\");\n\n\t/* Remember which configuration entry we are using. */\n\tpf->cfe = cfe;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_devinfo",
          "args": [
            "&pa->pf->sc->card",
            "0",
            "devinfo",
            "sizeof devinfo"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tSC_BUILD_4\t0x55\n#define\tSC_BUILD_5\t0x5\n#define\tIFM_INFRA\t\\\n\tIFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_FH2, 0, 0)\n#define\tIFM_ADHOC\t\\\n\tIFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_FH2, IFM_IEEE80211_ADHOC, 0)\n#define\tSC_MODE_ADHOC\t0\t/* ad-hoc mode */\n#define\tsc_xname\tsc_dev.dv_xname\n#define\tsc_if\t\tsc_ec.ac_if\n#define\tsc_if\t\tsc_ec.ec_if\n#define\tsc_version\tsc_ecf_startup.e_fw_build_string\n#define\tRAY_DEF_NWID\t\"NETWORK_NAME\"\n#define\tRAY_MODE_DEFAULT\tSC_MODE_ADHOC\n#define\tRAY_PID_COUNTRY_CODE_DEFAULT\tRAY_PID_COUNTRY_CODE_USA\n#define RAY_USE_AMEM 0\n#define\tPCMCIA_WIDTH_MEM8\t0\n\nvoid ray_attach;\nvoid ray_check_ccs;\nvoid ray_check_scheduled;\nvoid ray_disable;\nvoid ray_if_start;\nint ray_ioctl;\nint ray_media_change;\nvoid ray_media_status;\nvoid ray_power;\nvoid ray_reset_resetloop;\nvoid ray_shutdown;\nvoid ray_start_join_timo;\n\nvoid\nray_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct ray_ecf_startup *ep;\n\tstruct pcmcia_attach_args *pa;\n\tstruct ray_softc *sc;\n\tstruct ifnet *ifp;\n\tbus_addr_t memoff;\n#ifdef __NetBSD__\n\tchar devinfo[256];\n#endif\n\n\tpa = aux;\n\tsc = (struct ray_softc *)self;\n\tsc->sc_pf = pa->pf;\n\tifp = &sc->sc_if;\n\tsc->sc_window = -1;\n#if RAY_USE_AMEM\n\tsc->sc_awindow = -1;\n#endif\n\n#ifdef __NetBSD__\n\t/* Print out what we are */\n\tpcmcia_devinfo(&pa->pf->sc->card, 0, devinfo, sizeof devinfo);\n\tprintf(\": %s\\n\", devinfo);\n#elif defined(__OpenBSD__)\n\tprintf(\"\\n\");\n#endif\n\n\t/* enable the card */\n\tpcmcia_function_init(sc->sc_pf, sc->sc_pf->cfe_head.sqh_first);\n\tif (pcmcia_function_enable(sc->sc_pf)) {\n\t\tprintf(\": failed to enable the card\");\n\t\treturn;\n\t}\n\n\t/*\n\t * map in the memory\n\t */\n\tif (pcmcia_mem_alloc(sc->sc_pf, RAY_SRAM_MEM_SIZE, &sc->sc_mem)) {\n\t\tprintf(\": can\\'t alloc shared memory\\n\");\n\t\tgoto fail;\n\t}\n\n\tif (pcmcia_mem_map(sc->sc_pf, PCMCIA_WIDTH_MEM8|PCMCIA_MEM_COMMON,\n\t    RAY_SRAM_MEM_BASE, RAY_SRAM_MEM_SIZE, &sc->sc_mem, &memoff,\n\t    &sc->sc_window)) {\n\t\tprintf(\": can\\'t map shared memory\\n\");\n\t\tpcmcia_mem_free(sc->sc_pf, &sc->sc_mem);\n\t\tgoto fail;\n\t}\n\n#if RAY_USE_AMEM\n\t/* use the already mapped ccrt in our pf */\n\t/*\n\t * map in the memory\n\t */\n\tif (pcmcia_mem_alloc(sc->sc_pf, 0x1000, &sc->sc_amem)) {\n\t\tprintf(\": can\\'t alloc attr memory\\n\");\n\t\tgoto fail;\n\t}\n\n\tif (pcmcia_mem_map(sc->sc_pf, PCMCIA_MEM_ATTR, 0,\n\t    0x1000, &sc->sc_amem, &memoff, &sc->sc_awindow)) {\n\t\tprintf(\": can\\'t map attr memory\\n\");\n\t\tpcmcia_mem_free(sc->sc_pf, &sc->sc_amem);\n\t\tgoto fail;\n\t}\n#endif\n\t/* get startup results */\n\tep = &sc->sc_ecf_startup;\n\tray_read_region(sc, RAY_ECF_TO_HOST_BASE, ep,\n\t    sizeof(sc->sc_ecf_startup));\n\n\t/* check to see that card initialized properly */\n\tif (ep->e_status != RAY_ECFS_CARD_OK) {\n\t\tprintf(\": card failed self test: status %d\\n\",\n\t\t    sc->sc_ecf_startup.e_status);\n\t\tgoto fail;\n\t}\n\n\t/* check firmware version */\n\tif (sc->sc_version != SC_BUILD_4 && sc->sc_version != SC_BUILD_5) {\n\t\tprintf(\": unsupported firmware version %d\\n\",\n\t\t    ep->e_fw_build_string);\n\t\tgoto fail;\n\t}\n\n\t/* clear any interrupt if present */\n\tREG_WRITE(sc, RAY_HCSIR, 0);\n\n\t/*\n\t * set the parameters that will survive stop/init\n\t */\n\tmemset(sc->sc_cnwid, 0, sizeof(sc->sc_cnwid));\n\tmemset(sc->sc_dnwid, 0, sizeof(sc->sc_dnwid));\n\tstrncpy(sc->sc_dnwid, RAY_DEF_NWID, sizeof(sc->sc_dnwid));\n\tstrncpy(sc->sc_cnwid, RAY_DEF_NWID, sizeof(sc->sc_dnwid));\n\tsc->sc_omode = sc->sc_mode = RAY_MODE_DEFAULT;\n\tsc->sc_countrycode = sc->sc_dcountrycode = RAY_PID_COUNTRY_CODE_DEFAULT;\n\tsc->sc_resumeinit = 0;\n\n#ifdef __NetBSD__\n\tcallout_init(&sc->sc_check_ccs_ch);\n\tcallout_init(&sc->sc_check_scheduled_ch);\n\tcallout_init(&sc->sc_reset_resetloop_ch);\n\tcallout_init(&sc->sc_disable_ch);\n\tcallout_init(&sc->sc_start_join_timo_ch);\n#elif defined(__OpenBSD__)\n\ttimeout_set(&sc->sc_check_ccs_ch, ray_check_ccs, sc);\n\ttimeout_set(&sc->sc_check_scheduled_ch, ray_check_scheduled, sc);\n\ttimeout_set(&sc->sc_reset_resetloop_ch, ray_reset_resetloop, sc);\n\ttimeout_set(&sc->sc_disable_ch, (void (*)(void *))ray_disable, sc);\n\ttimeout_set(&sc->sc_start_join_timo_ch, ray_start_join_timo, sc);\n#endif\n\t/*\n\t * attach the interface\n\t */\n\t/* The version isn't the most accurate way, but it's easy. */\n\tprintf(\"%s: firmware version %d\\n\", sc->sc_dev.dv_xname,sc->sc_version);\n\tif (sc->sc_version != SC_BUILD_4)\n\t\tprintf(\"%s: supported rates %0x:%0x:%0x:%0x:%0x:%0x:%0x:%0x\\n\",\n\t\t    sc->sc_xname, ep->e_rates[0], ep->e_rates[1],\n\t\t    ep->e_rates[2], ep->e_rates[3], ep->e_rates[4],\n\t\t    ep->e_rates[5], ep->e_rates[6], ep->e_rates[7]);\n\tprintf(\"%s: 802.11 address %s\\n\", sc->sc_xname,\n\t    ether_sprintf(ep->e_station_addr));\n\n\tmemcpy(ifp->if_xname, sc->sc_xname, IFNAMSIZ);\n\tifp->if_softc = sc;\n\tifp->if_start = ray_if_start;\n\tifp->if_ioctl = ray_ioctl;\n\tifp->if_mtu = ETHERMTU;\n\tifp->if_flags = IFF_BROADCAST|IFF_SIMPLEX|IFF_MULTICAST;\n\tif_attach(ifp);\n#ifdef __NetBSD__\n\tether_ifattach(ifp, ep->e_station_addr);\n#elif defined(__OpenBSD__)\n\tmemcpy(&sc->sc_ec.ac_enaddr, ep->e_station_addr, ETHER_ADDR_LEN);\n\tether_ifattach(ifp);\n#endif\n\t/* need enough space for ieee80211_header + (snap or e2) */\n\tifp->if_hdrlen =\n\t    sizeof(struct ieee80211_frame) + sizeof(struct ether_header);\n\n\tifmedia_init(&sc->sc_media, 0, ray_media_change, ray_media_status);\n\tifmedia_add(&sc->sc_media, IFM_ADHOC, 0, 0);\n\tifmedia_add(&sc->sc_media, IFM_INFRA, 0, 0);\n\tif (sc->sc_mode == SC_MODE_ADHOC)\n\t\tifmedia_set(&sc->sc_media, IFM_ADHOC);\n\telse\n\t\tifmedia_set(&sc->sc_media, IFM_INFRA);\n\n#if NBPFILTER > 0\n\tbpfattach(&ifp->if_bpf, ifp, DLT_EN10MB, sizeof(struct ether_header));\n#endif\n\t/* disable the card */\n\tpcmcia_function_disable(sc->sc_pf);\n\n\tsc->sc_sdhook = shutdownhook_establish(ray_shutdown, sc);\n\tsc->sc_pwrhook = powerhook_establish(ray_power, sc);\n\n\treturn;\nfail:\n\t/* disable the card */\n\tpcmcia_function_disable(sc->sc_pf);\n\n\t/* free the alloc/map */\n#if RAY_USE_AMEM\n\tif (sc->sc_awindow != -1) {\n\t\tpcmcia_mem_unmap(sc->sc_pf, sc->sc_awindow);\n\t\tpcmcia_mem_free(sc->sc_pf, &sc->sc_amem);\n\t}\n#endif\n\tif (sc->sc_window != -1) {\n\t\tpcmcia_mem_unmap(sc->sc_pf, sc->sc_window);\n\t\tpcmcia_mem_free(sc->sc_pf, &sc->sc_mem);\n\t}\n}"
  },
  {
    "function_name": "ray_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
    "lines": "526-544",
    "snippet": "int\nray_match(parent, match, aux)\n\tstruct device *parent;\n\tstruct cfdata *match;\n\tvoid *aux;\n{\n\tstruct pcmcia_attach_args *pa = aux;\n\n#ifdef RAY_DEBUG\n\tif (!ltp) {\n\t\t/* initialize timestamp XXX */\n\t\tttp = &tv1;\n\t\tltp = &tv2;\n\t\tmicrotime(ltp);\n\t}\n#endif\n\treturn (pa->manufacturer == PCMCIA_VENDOR_RAYTHEON\n\t    && pa->product == PCMCIA_PRODUCT_RAYTHEON_WLAN);\n}",
    "includes": [
      "#include <dev/pcmcia/if_rayreg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_llc.h>",
      "#include <net/if_media.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/timeout.h>",
      "#include <sys/callout.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int ray_match"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "microtime",
          "args": [
            "ltp"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\nint ray_match;\n\nint\nray_match(parent, match, aux)\n\tstruct device *parent;\n\tstruct cfdata *match;\n\tvoid *aux;\n{\n\tstruct pcmcia_attach_args *pa = aux;\n\n#ifdef RAY_DEBUG\n\tif (!ltp) {\n\t\t/* initialize timestamp XXX */\n\t\tttp = &tv1;\n\t\tltp = &tv2;\n\t\tmicrotime(ltp);\n\t}\n#endif\n\treturn (pa->manufacturer == PCMCIA_VENDOR_RAYTHEON\n\t    && pa->product == PCMCIA_PRODUCT_RAYTHEON_WLAN);\n}"
  }
]