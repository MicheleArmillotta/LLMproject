[
  {
    "function_name": "le_ioasic_zerobuf_gap16",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/tc/if_le_ioasic.c",
    "lines": "245-264",
    "snippet": "void\nle_ioasic_zerobuf_gap16(sc, boff, len)\n\tstruct am7990_softc *sc;\n\tint boff, len;\n{\n\tvolatile caddr_t buf = sc->sc_mem;\n\tregister caddr_t bptr;\n\tregister int xfer;\n\n\tbptr = buf + ((boff << 1) & ~0x1f);\n\tboff &= 0xf;\n\txfer = min(len, 16 - boff);\n\twhile (len > 0) {\n\t\tbzero(bptr + boff, xfer);\n\t\tbptr += 32;\n\t\tboff = 0;\n\t\tlen -= xfer;\n\t\txfer = min(len, 16);\n\t}\n}",
    "includes": [
      "#include <dev/tc/ioasicvar.h>",
      "#include <dev/tc/tcvar.h>",
      "#include <dev/tc/if_levar.h>",
      "#include <dev/ic/am7990var.h>",
      "#include <dev/ic/am7990reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "le_ioasic_copytobuf_gap2 __P((struct am7990_softc *, void *,\n\t    int, int));",
      "le_ioasic_copyfrombuf_gap2 __P((struct am7990_softc *, void *,\n\t    int, int));",
      "le_ioasic_copytobuf_gap16 __P((struct am7990_softc *, void *,\n\t    int, int));",
      "le_ioasic_copyfrombuf_gap16 __P((struct am7990_softc *, void *,\n\t    int, int));",
      "le_ioasic_zerobuf_gap16 __P((struct am7990_softc *, int, int));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "min",
          "args": [
            "len",
            "16"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "asc_minphys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/tc/asc.c",
          "lines": "551-556",
          "snippet": "void\nasc_minphys(bp)\n\tstruct buf *bp;\n{\n\t/*XXX*/\n}",
          "includes": [
            "#include <dev/tc/ascvar.h>",
            "#include <pmax/pmax/kmin.h>",
            "#include <pmax/pmax/asic.h>",
            "#include <pmax/dev/ascreg.h>",
            "#include <pmax/dev/scsi.h>",
            "#include <pmax/dev/device.h>",
            "#include <machine/bus.h>",
            "#include <machine/autoconf.h>",
            "#include <machine/cpu.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/tc/ioasicvar.h>",
            "#include <dev/tc/tcvar.h>",
            "#include <sys/reboot.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/errno.h>",
            "#include <sys/conf.h>",
            "#include <sys/buf.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <asc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/tc/ascvar.h>\n#include <pmax/pmax/kmin.h>\n#include <pmax/pmax/asic.h>\n#include <pmax/dev/ascreg.h>\n#include <pmax/dev/scsi.h>\n#include <pmax/dev/device.h>\n#include <machine/bus.h>\n#include <machine/autoconf.h>\n#include <machine/cpu.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/tc/ioasicvar.h>\n#include <dev/tc/tcvar.h>\n#include <sys/reboot.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/errno.h>\n#include <sys/conf.h>\n#include <sys/buf.h>\n#include <sys/dkstat.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <asc.h>\n\nvoid\nasc_minphys(bp)\n\tstruct buf *bp;\n{\n\t/*XXX*/\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "bptr + boff",
            "xfer"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/tc/ioasicvar.h>\n#include <dev/tc/tcvar.h>\n#include <dev/tc/if_levar.h>\n#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nle_ioasic_copytobuf_gap2 __P((struct am7990_softc *, void *,\n\t    int, int));\nle_ioasic_copyfrombuf_gap2 __P((struct am7990_softc *, void *,\n\t    int, int));\nle_ioasic_copytobuf_gap16 __P((struct am7990_softc *, void *,\n\t    int, int));\nle_ioasic_copyfrombuf_gap16 __P((struct am7990_softc *, void *,\n\t    int, int));\nle_ioasic_zerobuf_gap16 __P((struct am7990_softc *, int, int));\n\nvoid\nle_ioasic_zerobuf_gap16(sc, boff, len)\n\tstruct am7990_softc *sc;\n\tint boff, len;\n{\n\tvolatile caddr_t buf = sc->sc_mem;\n\tregister caddr_t bptr;\n\tregister int xfer;\n\n\tbptr = buf + ((boff << 1) & ~0x1f);\n\tboff &= 0xf;\n\txfer = min(len, 16 - boff);\n\twhile (len > 0) {\n\t\tbzero(bptr + boff, xfer);\n\t\tbptr += 32;\n\t\tboff = 0;\n\t\tlen -= xfer;\n\t\txfer = min(len, 16);\n\t}\n}"
  },
  {
    "function_name": "le_ioasic_copyfrombuf_gap16",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/tc/if_le_ioasic.c",
    "lines": "221-243",
    "snippet": "void\nle_ioasic_copyfrombuf_gap16(sc, tov, boff, len)\n\tstruct am7990_softc *sc;\n\tvoid *tov;\n\tint boff, len;\n{\n\tvolatile caddr_t buf = sc->sc_mem;\n\tregister caddr_t to = tov;\n\tregister caddr_t bptr;\n\tregister int xfer;\n\n\tbptr = buf + ((boff << 1) & ~0x1f);\n\tboff &= 0xf;\n\txfer = min(len, 16 - boff);\n\twhile (len > 0) {\n\t\tbcopy(bptr + boff, to, xfer);\n\t\tto += xfer;\n\t\tbptr += 32;\n\t\tboff = 0;\n\t\tlen -= xfer;\n\t\txfer = min(len, 16);\n\t}\n}",
    "includes": [
      "#include <dev/tc/ioasicvar.h>",
      "#include <dev/tc/tcvar.h>",
      "#include <dev/tc/if_levar.h>",
      "#include <dev/ic/am7990var.h>",
      "#include <dev/ic/am7990reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "le_ioasic_copytobuf_gap2 __P((struct am7990_softc *, void *,\n\t    int, int));",
      "le_ioasic_copyfrombuf_gap2 __P((struct am7990_softc *, void *,\n\t    int, int));",
      "le_ioasic_copytobuf_gap16 __P((struct am7990_softc *, void *,\n\t    int, int));",
      "le_ioasic_copyfrombuf_gap16 __P((struct am7990_softc *, void *,\n\t    int, int));",
      "le_ioasic_zerobuf_gap16 __P((struct am7990_softc *, int, int));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "min",
          "args": [
            "len",
            "16"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "asc_minphys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/tc/asc.c",
          "lines": "551-556",
          "snippet": "void\nasc_minphys(bp)\n\tstruct buf *bp;\n{\n\t/*XXX*/\n}",
          "includes": [
            "#include <dev/tc/ascvar.h>",
            "#include <pmax/pmax/kmin.h>",
            "#include <pmax/pmax/asic.h>",
            "#include <pmax/dev/ascreg.h>",
            "#include <pmax/dev/scsi.h>",
            "#include <pmax/dev/device.h>",
            "#include <machine/bus.h>",
            "#include <machine/autoconf.h>",
            "#include <machine/cpu.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/tc/ioasicvar.h>",
            "#include <dev/tc/tcvar.h>",
            "#include <sys/reboot.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/errno.h>",
            "#include <sys/conf.h>",
            "#include <sys/buf.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <asc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/tc/ascvar.h>\n#include <pmax/pmax/kmin.h>\n#include <pmax/pmax/asic.h>\n#include <pmax/dev/ascreg.h>\n#include <pmax/dev/scsi.h>\n#include <pmax/dev/device.h>\n#include <machine/bus.h>\n#include <machine/autoconf.h>\n#include <machine/cpu.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/tc/ioasicvar.h>\n#include <dev/tc/tcvar.h>\n#include <sys/reboot.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/errno.h>\n#include <sys/conf.h>\n#include <sys/buf.h>\n#include <sys/dkstat.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <asc.h>\n\nvoid\nasc_minphys(bp)\n\tstruct buf *bp;\n{\n\t/*XXX*/\n}"
        }
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "bptr + boff",
            "to",
            "xfer"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/tc/ioasicvar.h>\n#include <dev/tc/tcvar.h>\n#include <dev/tc/if_levar.h>\n#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nle_ioasic_copytobuf_gap2 __P((struct am7990_softc *, void *,\n\t    int, int));\nle_ioasic_copyfrombuf_gap2 __P((struct am7990_softc *, void *,\n\t    int, int));\nle_ioasic_copytobuf_gap16 __P((struct am7990_softc *, void *,\n\t    int, int));\nle_ioasic_copyfrombuf_gap16 __P((struct am7990_softc *, void *,\n\t    int, int));\nle_ioasic_zerobuf_gap16 __P((struct am7990_softc *, int, int));\n\nvoid\nle_ioasic_copyfrombuf_gap16(sc, tov, boff, len)\n\tstruct am7990_softc *sc;\n\tvoid *tov;\n\tint boff, len;\n{\n\tvolatile caddr_t buf = sc->sc_mem;\n\tregister caddr_t to = tov;\n\tregister caddr_t bptr;\n\tregister int xfer;\n\n\tbptr = buf + ((boff << 1) & ~0x1f);\n\tboff &= 0xf;\n\txfer = min(len, 16 - boff);\n\twhile (len > 0) {\n\t\tbcopy(bptr + boff, to, xfer);\n\t\tto += xfer;\n\t\tbptr += 32;\n\t\tboff = 0;\n\t\tlen -= xfer;\n\t\txfer = min(len, 16);\n\t}\n}"
  },
  {
    "function_name": "le_ioasic_copytobuf_gap16",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/tc/if_le_ioasic.c",
    "lines": "196-219",
    "snippet": "void\nle_ioasic_copytobuf_gap16(sc, fromv, boff, len)\n\tstruct am7990_softc *sc;\n\tvoid *fromv;\n\tint boff;\n\tregister int len;\n{\n\tvolatile caddr_t buf = sc->sc_mem;\n\tregister caddr_t from = fromv;\n\tregister caddr_t bptr;\n\tregister int xfer;\n\n\tbptr = buf + ((boff << 1) & ~0x1f);\n\tboff &= 0xf;\n\txfer = min(len, 16 - boff);\n\twhile (len > 0) {\n\t\tbcopy(from, bptr + boff, xfer);\n\t\tfrom += xfer;\n\t\tbptr += 32;\n\t\tboff = 0;\n\t\tlen -= xfer;\n\t\txfer = min(len, 16);\n\t}\n}",
    "includes": [
      "#include <dev/tc/ioasicvar.h>",
      "#include <dev/tc/tcvar.h>",
      "#include <dev/tc/if_levar.h>",
      "#include <dev/ic/am7990var.h>",
      "#include <dev/ic/am7990reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "le_ioasic_copytobuf_gap2 __P((struct am7990_softc *, void *,\n\t    int, int));",
      "le_ioasic_copyfrombuf_gap2 __P((struct am7990_softc *, void *,\n\t    int, int));",
      "le_ioasic_copytobuf_gap16 __P((struct am7990_softc *, void *,\n\t    int, int));",
      "le_ioasic_copyfrombuf_gap16 __P((struct am7990_softc *, void *,\n\t    int, int));",
      "le_ioasic_zerobuf_gap16 __P((struct am7990_softc *, int, int));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "min",
          "args": [
            "len",
            "16"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "asc_minphys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/tc/asc.c",
          "lines": "551-556",
          "snippet": "void\nasc_minphys(bp)\n\tstruct buf *bp;\n{\n\t/*XXX*/\n}",
          "includes": [
            "#include <dev/tc/ascvar.h>",
            "#include <pmax/pmax/kmin.h>",
            "#include <pmax/pmax/asic.h>",
            "#include <pmax/dev/ascreg.h>",
            "#include <pmax/dev/scsi.h>",
            "#include <pmax/dev/device.h>",
            "#include <machine/bus.h>",
            "#include <machine/autoconf.h>",
            "#include <machine/cpu.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/tc/ioasicvar.h>",
            "#include <dev/tc/tcvar.h>",
            "#include <sys/reboot.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/errno.h>",
            "#include <sys/conf.h>",
            "#include <sys/buf.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <asc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/tc/ascvar.h>\n#include <pmax/pmax/kmin.h>\n#include <pmax/pmax/asic.h>\n#include <pmax/dev/ascreg.h>\n#include <pmax/dev/scsi.h>\n#include <pmax/dev/device.h>\n#include <machine/bus.h>\n#include <machine/autoconf.h>\n#include <machine/cpu.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/tc/ioasicvar.h>\n#include <dev/tc/tcvar.h>\n#include <sys/reboot.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/errno.h>\n#include <sys/conf.h>\n#include <sys/buf.h>\n#include <sys/dkstat.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <asc.h>\n\nvoid\nasc_minphys(bp)\n\tstruct buf *bp;\n{\n\t/*XXX*/\n}"
        }
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "from",
            "bptr + boff",
            "xfer"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/tc/ioasicvar.h>\n#include <dev/tc/tcvar.h>\n#include <dev/tc/if_levar.h>\n#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nle_ioasic_copytobuf_gap2 __P((struct am7990_softc *, void *,\n\t    int, int));\nle_ioasic_copyfrombuf_gap2 __P((struct am7990_softc *, void *,\n\t    int, int));\nle_ioasic_copytobuf_gap16 __P((struct am7990_softc *, void *,\n\t    int, int));\nle_ioasic_copyfrombuf_gap16 __P((struct am7990_softc *, void *,\n\t    int, int));\nle_ioasic_zerobuf_gap16 __P((struct am7990_softc *, int, int));\n\nvoid\nle_ioasic_copytobuf_gap16(sc, fromv, boff, len)\n\tstruct am7990_softc *sc;\n\tvoid *fromv;\n\tint boff;\n\tregister int len;\n{\n\tvolatile caddr_t buf = sc->sc_mem;\n\tregister caddr_t from = fromv;\n\tregister caddr_t bptr;\n\tregister int xfer;\n\n\tbptr = buf + ((boff << 1) & ~0x1f);\n\tboff &= 0xf;\n\txfer = min(len, 16 - boff);\n\twhile (len > 0) {\n\t\tbcopy(from, bptr + boff, xfer);\n\t\tfrom += xfer;\n\t\tbptr += 32;\n\t\tboff = 0;\n\t\tlen -= xfer;\n\t\txfer = min(len, 16);\n\t}\n}"
  },
  {
    "function_name": "le_ioasic_copyfrombuf_gap2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/tc/if_le_ioasic.c",
    "lines": "160-188",
    "snippet": "void\nle_ioasic_copyfrombuf_gap2(sc, tov, boff, len)\n\tstruct am7990_softc *sc;\n\tvoid *tov;\n\tint boff, len;\n{\n\tvolatile caddr_t buf = sc->sc_mem;\n\tregister caddr_t to = tov;\n\tregister volatile u_int16_t *bptr;\n\tregister u_int16_t tmp;\n\n\tif (boff & 0x1) {\n\t\t/* handle unaligned first byte */\n\t\tbptr = ((volatile u_int16_t *)buf) + (boff - 1);\n\t\t*to++ = (*bptr >> 8) & 0xff;\n\t\tbptr += 2;\n\t\tlen--;\n\t} else\n\t\tbptr = ((volatile u_int16_t *)buf) + boff;\n\twhile (len > 1) {\n\t\ttmp = *bptr;\n\t\t*to++ = tmp & 0xff;\n\t\t*to++ = (tmp >> 8) & 0xff;\n\t\tbptr += 2;\n\t\tlen -= 2;\n\t}\n\tif (len == 1)\n\t\t*to = *bptr & 0xff;\n}",
    "includes": [
      "#include <dev/tc/ioasicvar.h>",
      "#include <dev/tc/tcvar.h>",
      "#include <dev/tc/if_levar.h>",
      "#include <dev/ic/am7990var.h>",
      "#include <dev/ic/am7990reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "le_ioasic_copytobuf_gap2 __P((struct am7990_softc *, void *,\n\t    int, int));",
      "le_ioasic_copyfrombuf_gap2 __P((struct am7990_softc *, void *,\n\t    int, int));",
      "le_ioasic_copytobuf_gap16 __P((struct am7990_softc *, void *,\n\t    int, int));",
      "le_ioasic_copyfrombuf_gap16 __P((struct am7990_softc *, void *,\n\t    int, int));",
      "le_ioasic_zerobuf_gap16 __P((struct am7990_softc *, int, int));"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/tc/ioasicvar.h>\n#include <dev/tc/tcvar.h>\n#include <dev/tc/if_levar.h>\n#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nle_ioasic_copytobuf_gap2 __P((struct am7990_softc *, void *,\n\t    int, int));\nle_ioasic_copyfrombuf_gap2 __P((struct am7990_softc *, void *,\n\t    int, int));\nle_ioasic_copytobuf_gap16 __P((struct am7990_softc *, void *,\n\t    int, int));\nle_ioasic_copyfrombuf_gap16 __P((struct am7990_softc *, void *,\n\t    int, int));\nle_ioasic_zerobuf_gap16 __P((struct am7990_softc *, int, int));\n\nvoid\nle_ioasic_copyfrombuf_gap2(sc, tov, boff, len)\n\tstruct am7990_softc *sc;\n\tvoid *tov;\n\tint boff, len;\n{\n\tvolatile caddr_t buf = sc->sc_mem;\n\tregister caddr_t to = tov;\n\tregister volatile u_int16_t *bptr;\n\tregister u_int16_t tmp;\n\n\tif (boff & 0x1) {\n\t\t/* handle unaligned first byte */\n\t\tbptr = ((volatile u_int16_t *)buf) + (boff - 1);\n\t\t*to++ = (*bptr >> 8) & 0xff;\n\t\tbptr += 2;\n\t\tlen--;\n\t} else\n\t\tbptr = ((volatile u_int16_t *)buf) + boff;\n\twhile (len > 1) {\n\t\ttmp = *bptr;\n\t\t*to++ = tmp & 0xff;\n\t\t*to++ = (tmp >> 8) & 0xff;\n\t\tbptr += 2;\n\t\tlen -= 2;\n\t}\n\tif (len == 1)\n\t\t*to = *bptr & 0xff;\n}"
  },
  {
    "function_name": "le_ioasic_copytobuf_gap2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/tc/if_le_ioasic.c",
    "lines": "131-158",
    "snippet": "void\nle_ioasic_copytobuf_gap2(sc, fromv, boff, len)\n\tstruct am7990_softc *sc;  \n\tvoid *fromv;\n\tint boff;\n\tregister int len;\n{\n\tvolatile caddr_t buf = sc->sc_mem;\n\tregister caddr_t from = fromv;\n\tregister volatile u_int16_t *bptr;  \n\n\tif (boff & 0x1) {\n\t\t/* handle unaligned first byte */\n\t\tbptr = ((volatile u_int16_t *)buf) + (boff - 1);\n\t\t*bptr = (*from++ << 8) | (*bptr & 0xff);\n\t\tbptr += 2;  \n\t\tlen--;\n\t} else\n\t\tbptr = ((volatile u_int16_t *)buf) + boff;\n\twhile (len > 1) {\n\t\t*bptr = (from[1] << 8) | (from[0] & 0xff);\n\t\tbptr += 2;\n\t\tfrom += 2;\n\t\tlen -= 2;\n\t}\n\tif (len == 1)\n\t\t*bptr = (u_int16_t)*from;\n}",
    "includes": [
      "#include <dev/tc/ioasicvar.h>",
      "#include <dev/tc/tcvar.h>",
      "#include <dev/tc/if_levar.h>",
      "#include <dev/ic/am7990var.h>",
      "#include <dev/ic/am7990reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "le_ioasic_copytobuf_gap2 __P((struct am7990_softc *, void *,\n\t    int, int));",
      "le_ioasic_copyfrombuf_gap2 __P((struct am7990_softc *, void *,\n\t    int, int));",
      "le_ioasic_copytobuf_gap16 __P((struct am7990_softc *, void *,\n\t    int, int));",
      "le_ioasic_copyfrombuf_gap16 __P((struct am7990_softc *, void *,\n\t    int, int));",
      "le_ioasic_zerobuf_gap16 __P((struct am7990_softc *, int, int));"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/tc/ioasicvar.h>\n#include <dev/tc/tcvar.h>\n#include <dev/tc/if_levar.h>\n#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nle_ioasic_copytobuf_gap2 __P((struct am7990_softc *, void *,\n\t    int, int));\nle_ioasic_copyfrombuf_gap2 __P((struct am7990_softc *, void *,\n\t    int, int));\nle_ioasic_copytobuf_gap16 __P((struct am7990_softc *, void *,\n\t    int, int));\nle_ioasic_copyfrombuf_gap16 __P((struct am7990_softc *, void *,\n\t    int, int));\nle_ioasic_zerobuf_gap16 __P((struct am7990_softc *, int, int));\n\nvoid\nle_ioasic_copytobuf_gap2(sc, fromv, boff, len)\n\tstruct am7990_softc *sc;  \n\tvoid *fromv;\n\tint boff;\n\tregister int len;\n{\n\tvolatile caddr_t buf = sc->sc_mem;\n\tregister caddr_t from = fromv;\n\tregister volatile u_int16_t *bptr;  \n\n\tif (boff & 0x1) {\n\t\t/* handle unaligned first byte */\n\t\tbptr = ((volatile u_int16_t *)buf) + (boff - 1);\n\t\t*bptr = (*from++ << 8) | (*bptr & 0xff);\n\t\tbptr += 2;  \n\t\tlen--;\n\t} else\n\t\tbptr = ((volatile u_int16_t *)buf) + boff;\n\twhile (len > 1) {\n\t\t*bptr = (from[1] << 8) | (from[0] & 0xff);\n\t\tbptr += 2;\n\t\tfrom += 2;\n\t\tlen -= 2;\n\t}\n\tif (len == 1)\n\t\t*bptr = (u_int16_t)*from;\n}"
  },
  {
    "function_name": "le_ioasic_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/tc/if_le_ioasic.c",
    "lines": "92-117",
    "snippet": "void\nle_ioasic_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct ioasicdev_attach_args *d = aux;\n\tregister struct le_softc *lesc = (void *)self;\n\tregister struct am7990_softc *sc = &lesc->sc_am7990;\n\n\tlesc->sc_r1 = (struct lereg1 *)\n\t\tTC_DENSE_TO_SPARSE(TC_PHYS_TO_UNCACHED(d->iada_addr));\n\tsc->sc_mem = (void *)TC_PHYS_TO_UNCACHED(le_iomem);\n\n\tsc->sc_copytodesc = le_ioasic_copytobuf_gap2;\n\tsc->sc_copyfromdesc = le_ioasic_copyfrombuf_gap2;\n\tsc->sc_copytobuf = le_ioasic_copytobuf_gap16;\n\tsc->sc_copyfrombuf = le_ioasic_copyfrombuf_gap16;\n\tsc->sc_zerobuf = le_ioasic_zerobuf_gap16;\n\n\tioasic_lance_dma_setup(le_iomem);\t/* XXX more thought */\n\n\tdec_le_common_attach(sc, ioasic_lance_ether_address());\n\n\tioasic_intr_establish(parent, d->iada_cookie, TC_IPL_NET,\n\t    am7990_intr, sc);\n}",
    "includes": [
      "#include <dev/tc/ioasicvar.h>",
      "#include <dev/tc/tcvar.h>",
      "#include <dev/tc/if_levar.h>",
      "#include <dev/ic/am7990var.h>",
      "#include <dev/ic/am7990reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern caddr_t le_iomem;",
      "void\tle_ioasic_attach",
      "le_ioasic_copytobuf_gap2 __P((struct am7990_softc *, void *,\n\t    int, int));",
      "le_ioasic_copyfrombuf_gap2 __P((struct am7990_softc *, void *,\n\t    int, int));",
      "le_ioasic_copytobuf_gap16 __P((struct am7990_softc *, void *,\n\t    int, int));",
      "le_ioasic_copyfrombuf_gap16 __P((struct am7990_softc *, void *,\n\t    int, int));",
      "le_ioasic_zerobuf_gap16 __P((struct am7990_softc *, int, int));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ioasic_intr_establish",
          "args": [
            "parent",
            "d->iada_cookie",
            "TC_IPL_NET",
            "am7990_intr",
            "sc"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dec_le_common_attach",
          "args": [
            "sc",
            "ioasic_lance_ether_address()"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "dec_le_common_attach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/tc/if_le_dec.c",
          "lines": "74-98",
          "snippet": "void\ndec_le_common_attach(sc, eap)\n\tstruct am7990_softc *sc;\n\tu_char *eap;\n{\n\tint i;\n\n\tsc->sc_rdcsr = le_dec_rdcsr;\n\tsc->sc_wrcsr = le_dec_wrcsr;\n\tsc->sc_hwinit = NULL;\n\n\tsc->sc_conf3 = 0;\n\tsc->sc_addr = 0;\n\tsc->sc_memsize = 65536;\n\n\t/*\n\t * Get the ethernet address out of rom\n\t */\n\tfor (i = 0; i < sizeof(sc->sc_arpcom.ac_enaddr); i++) {\n\t\tsc->sc_arpcom.ac_enaddr[i] = *eap;\n\t\teap += 4;\n\t}\n\n\tam7990_config(sc);\n}",
          "includes": [
            "#include <dev/tc/tcvar.h>",
            "#include <dev/tc/if_levar.h>",
            "#include <dev/ic/am7990var.h>",
            "#include <dev/ic/am7990reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/tc/tcvar.h>\n#include <dev/tc/if_levar.h>\n#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ndec_le_common_attach(sc, eap)\n\tstruct am7990_softc *sc;\n\tu_char *eap;\n{\n\tint i;\n\n\tsc->sc_rdcsr = le_dec_rdcsr;\n\tsc->sc_wrcsr = le_dec_wrcsr;\n\tsc->sc_hwinit = NULL;\n\n\tsc->sc_conf3 = 0;\n\tsc->sc_addr = 0;\n\tsc->sc_memsize = 65536;\n\n\t/*\n\t * Get the ethernet address out of rom\n\t */\n\tfor (i = 0; i < sizeof(sc->sc_arpcom.ac_enaddr); i++) {\n\t\tsc->sc_arpcom.ac_enaddr[i] = *eap;\n\t\teap += 4;\n\t}\n\n\tam7990_config(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ioasic_lance_ether_address",
          "args": [],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioasic_lance_dma_setup",
          "args": [
            "le_iomem"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TC_PHYS_TO_UNCACHED",
          "args": [
            "le_iomem"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TC_DENSE_TO_SPARSE",
          "args": [
            "TC_PHYS_TO_UNCACHED(d->iada_addr)"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TC_PHYS_TO_UNCACHED",
          "args": [
            "d->iada_addr"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/tc/ioasicvar.h>\n#include <dev/tc/tcvar.h>\n#include <dev/tc/if_levar.h>\n#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nextern caddr_t le_iomem;\nvoid\tle_ioasic_attach;\nle_ioasic_copytobuf_gap2 __P((struct am7990_softc *, void *,\n\t    int, int));\nle_ioasic_copyfrombuf_gap2 __P((struct am7990_softc *, void *,\n\t    int, int));\nle_ioasic_copytobuf_gap16 __P((struct am7990_softc *, void *,\n\t    int, int));\nle_ioasic_copyfrombuf_gap16 __P((struct am7990_softc *, void *,\n\t    int, int));\nle_ioasic_zerobuf_gap16 __P((struct am7990_softc *, int, int));\n\nvoid\nle_ioasic_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct ioasicdev_attach_args *d = aux;\n\tregister struct le_softc *lesc = (void *)self;\n\tregister struct am7990_softc *sc = &lesc->sc_am7990;\n\n\tlesc->sc_r1 = (struct lereg1 *)\n\t\tTC_DENSE_TO_SPARSE(TC_PHYS_TO_UNCACHED(d->iada_addr));\n\tsc->sc_mem = (void *)TC_PHYS_TO_UNCACHED(le_iomem);\n\n\tsc->sc_copytodesc = le_ioasic_copytobuf_gap2;\n\tsc->sc_copyfromdesc = le_ioasic_copyfrombuf_gap2;\n\tsc->sc_copytobuf = le_ioasic_copytobuf_gap16;\n\tsc->sc_copyfrombuf = le_ioasic_copyfrombuf_gap16;\n\tsc->sc_zerobuf = le_ioasic_zerobuf_gap16;\n\n\tioasic_lance_dma_setup(le_iomem);\t/* XXX more thought */\n\n\tdec_le_common_attach(sc, ioasic_lance_ether_address());\n\n\tioasic_intr_establish(parent, d->iada_cookie, TC_IPL_NET,\n\t    am7990_intr, sc);\n}"
  },
  {
    "function_name": "le_ioasic_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/tc/if_le_ioasic.c",
    "lines": "77-90",
    "snippet": "int\nle_ioasic_match(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct ioasicdev_attach_args *d = aux;\n\n\tif (!ioasic_submatch(match, aux))\n\t\treturn (0);\n\tif (strncmp(\"lance\", d->iada_modname, TC_ROM_LLEN))\n\t\treturn (0);\n\n\treturn (1);\n}",
    "includes": [
      "#include <dev/tc/ioasicvar.h>",
      "#include <dev/tc/tcvar.h>",
      "#include <dev/tc/if_levar.h>",
      "#include <dev/ic/am7990var.h>",
      "#include <dev/ic/am7990reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tle_ioasic_match"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "\"lance\"",
            "d->iada_modname",
            "TC_ROM_LLEN"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioasic_submatch",
          "args": [
            "match",
            "aux"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/tc/ioasicvar.h>\n#include <dev/tc/tcvar.h>\n#include <dev/tc/if_levar.h>\n#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tle_ioasic_match;\n\nint\nle_ioasic_match(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct ioasicdev_attach_args *d = aux;\n\n\tif (!ioasic_submatch(match, aux))\n\t\treturn (0);\n\tif (strncmp(\"lance\", d->iada_modname, TC_ROM_LLEN))\n\t\treturn (0);\n\n\treturn (1);\n}"
  }
]