[
  {
    "function_name": "rf_remove_hot_spare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_disks.c",
    "lines": "865-894",
    "snippet": "int\nrf_remove_hot_spare(raidPtr,sparePtr)\n\tRF_Raid_t *raidPtr;\n\tRF_SingleComponent_t *sparePtr;\n{\n\tint spare_number;\n\n\n\tif (raidPtr->numSpare==0) {\n\t\tprintf(\"No spares to remove!\\n\");\n\t\treturn(EINVAL);\n\t}\n\n\tspare_number = sparePtr->column;\n\n\treturn(EINVAL); /* XXX not implemented yet */\n#if 0\n\tif (spare_number < 0 || spare_number > raidPtr->numSpare) {\n\t\treturn(EINVAL);\n\t}\n\n\t/* verify that this spare isn't in use... */\n\n\t/* it's gone.. */\n\n\traidPtr->numSpare--;\n\n\treturn (0);\n#endif\n}",
    "includes": [
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"rf_kintf.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void rf_UnconfigureVnodes( RF_Raid_t * );",
      "int rf_add_hot_spare(RF_Raid_t *, RF_SingleComponent_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"No spares to remove!\\n\""
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"rf_kintf.h\"\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_utils.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid rf_UnconfigureVnodes( RF_Raid_t * );\nint rf_add_hot_spare(RF_Raid_t *, RF_SingleComponent_t *);\n\nint\nrf_remove_hot_spare(raidPtr,sparePtr)\n\tRF_Raid_t *raidPtr;\n\tRF_SingleComponent_t *sparePtr;\n{\n\tint spare_number;\n\n\n\tif (raidPtr->numSpare==0) {\n\t\tprintf(\"No spares to remove!\\n\");\n\t\treturn(EINVAL);\n\t}\n\n\tspare_number = sparePtr->column;\n\n\treturn(EINVAL); /* XXX not implemented yet */\n#if 0\n\tif (spare_number < 0 || spare_number > raidPtr->numSpare) {\n\t\treturn(EINVAL);\n\t}\n\n\t/* verify that this spare isn't in use... */\n\n\t/* it's gone.. */\n\n\traidPtr->numSpare--;\n\n\treturn (0);\n#endif\n}"
  },
  {
    "function_name": "rf_add_hot_spare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_disks.c",
    "lines": "774-863",
    "snippet": "int\nrf_add_hot_spare(raidPtr, sparePtr)\n\tRF_Raid_t *raidPtr;\n\tRF_SingleComponent_t *sparePtr;\n{\n\tRF_RaidDisk_t *disks;\n\tRF_DiskQueue_t *spareQueues;\n\tint ret;\n\tunsigned int bs;\n\tint spare_number;\n\n\tprintf(\"Just in rf_add_hot_spare: %d\\n\",raidPtr->numSpare);\n\tprintf(\"Num col: %d\\n\",raidPtr->numCol);\n\tif (raidPtr->numSpare >= RF_MAXSPARE) {\n\t\tRF_ERRORMSG1(\"Too many spares: %d\\n\", raidPtr->numSpare);\n\t\treturn(EINVAL);\n \t}\n\n\tRF_LOCK_MUTEX(raidPtr->mutex);\n\n\t/* the beginning of the spares... */\n\tdisks = &raidPtr->Disks[0][raidPtr->numCol];\n\n\tspare_number = raidPtr->numSpare;\n\n\tret = rf_ConfigureDisk(raidPtr, sparePtr->component_name,\n\t\t\t       &disks[spare_number], 0,\n\t\t\t       raidPtr->numCol + spare_number);\n\n\tif (ret)\n\t\tgoto fail;\n\tif (disks[spare_number].status != rf_ds_optimal) {\n\t\tRF_ERRORMSG1(\"Warning: spare disk %s failed TUR\\n\", \n\t\t\t     sparePtr->component_name);\n\t\tret=EINVAL;\n\t\tgoto fail;\n\t} else {\n\t\tdisks[spare_number].status = rf_ds_spare;\n\t\tDPRINTF6(\"Spare Disk %d: dev %s numBlocks %ld blockSize %d (%ld MB)\\n\", spare_number,\n\t\t\t disks[spare_number].devname,\n\t\t\t (long int) disks[spare_number].numBlocks, \n\t\t\t disks[spare_number].blockSize,\n\t\t\t (long int) disks[spare_number].numBlocks * \n\t\t\t disks[spare_number].blockSize / 1024 / 1024);\n\t}\n\t\n\n\t/* check sizes and block sizes on the spare disk */\n\tbs = 1 << raidPtr->logBytesPerSector;\n\tif (disks[spare_number].blockSize != bs) {\n\t\tRF_ERRORMSG3(\"Block size of %d on spare disk %s is not the same as on other disks (%d)\\n\", disks[spare_number].blockSize, disks[spare_number].devname, bs);\n\t\tret = EINVAL;\n\t\tgoto fail;\n\t}\n\tif (disks[spare_number].numBlocks < raidPtr->sectorsPerDisk) {\n\t\tRF_ERRORMSG3(\"Spare disk %s (%d blocks) is too small to serve as a spare (need %ld blocks)\\n\",\n\t\t\t     disks[spare_number].devname, \n\t\t\t     disks[spare_number].blockSize, \n\t\t\t     (long int) raidPtr->sectorsPerDisk);\n\t\tret = EINVAL;\n\t\tgoto fail;\n\t} else {\n\t\tif (disks[spare_number].numBlocks > \n\t\t    raidPtr->sectorsPerDisk) {\n\t\t\tRF_ERRORMSG2(\"Warning: truncating spare disk %s to %ld blocks\\n\", disks[spare_number].devname, \n\t\t\t\t     (long int) raidPtr->sectorsPerDisk);\n\t\t\t\n\t\t\tdisks[spare_number].numBlocks = raidPtr->sectorsPerDisk;\n\t\t}\n\t}\n\n\tspareQueues = &raidPtr->Queues[0][raidPtr->numCol];\n\tret = config_disk_queue( raidPtr, &spareQueues[spare_number],\n\t\t\t\t 0, raidPtr->numCol + spare_number, \n\t\t\t\t raidPtr->Queues[0][0].qPtr, /* XXX */\n\t\t\t\t raidPtr->sectorsPerDisk,\n\t\t\t\t raidPtr->Disks[0][raidPtr->numCol + spare_number].dev,\n\t\t\t\t raidPtr->Queues[0][0].maxOutstanding, /* XXX */\n\t\t\t\t &raidPtr->shutdownList,\n\t\t\t\t raidPtr->cleanupList);\n\t\t\t\t \n\n\traidPtr->numSpare++;\n\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\treturn (0);\n\nfail:\n\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\treturn(ret);\n}",
    "includes": [
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"rf_kintf.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void rf_UnconfigureVnodes( RF_Raid_t * );",
      "int rf_add_hot_spare(RF_Raid_t *, RF_SingleComponent_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_UNLOCK_MUTEX",
          "args": [
            "raidPtr->mutex"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_UNLOCK_MUTEX",
          "args": [
            "raidPtr->mutex"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "config_disk_queue",
          "args": [
            "raidPtr",
            "&spareQueues[spare_number]",
            "0",
            "raidPtr->numCol + spare_number",
            "raidPtr->Queues[0][0].qPtr",
            "/* XXX */raidPtr->sectorsPerDisk",
            "raidPtr->Disks[0][raidPtr->numCol + spare_number].dev",
            "raidPtr->Queues[0][0].maxOutstanding",
            "/* XXX */&raidPtr->shutdownList",
            "raidPtr->cleanupList"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "config_disk_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_diskqueue.c",
          "lines": "189-233",
          "snippet": "int \nconfig_disk_queue(\n    RF_Raid_t * raidPtr,\n    RF_DiskQueue_t * diskqueue,\n    RF_RowCol_t r,\t\t/* row & col -- debug only.  BZZT not any\n\t\t\t\t * more... */\n    RF_RowCol_t c,\n    RF_DiskQueueSW_t * p,\n    RF_SectorCount_t sectPerDisk,\n    dev_t dev,\n    int maxOutstanding,\n    RF_ShutdownList_t ** listp,\n    RF_AllocListElem_t * clList)\n{\n\tint     rc;\n\n\tdiskqueue->row = r;\n\tdiskqueue->col = c;\n\tdiskqueue->qPtr = p;\n\tdiskqueue->qHdr = (p->Create) (sectPerDisk, clList, listp);\n\tdiskqueue->dev = dev;\n\tdiskqueue->numOutstanding = 0;\n\tdiskqueue->queueLength = 0;\n\tdiskqueue->maxOutstanding = maxOutstanding;\n\tdiskqueue->curPriority = RF_IO_NORMAL_PRIORITY;\n\tdiskqueue->nextLockingOp = NULL;\n\tdiskqueue->unlockingOp = NULL;\n\tdiskqueue->numWaiting = 0;\n\tdiskqueue->flags = 0;\n\tdiskqueue->raidPtr = raidPtr;\n\tdiskqueue->rf_cinfo = &raidPtr->raid_cinfo[r][c];\n\trc = rf_create_managed_mutex(listp, &diskqueue->mutex);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to init mutex file %s line %d rc=%d\\n\", __FILE__,\n\t\t    __LINE__, rc);\n\t\treturn (rc);\n\t}\n\trc = rf_create_managed_cond(listp, &diskqueue->cond);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to init cond file %s line %d rc=%d\\n\", __FILE__,\n\t\t    __LINE__, rc);\n\t\treturn (rc);\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include <sys/buf.h>",
            "#include \"rf_fifo.h\"",
            "#include \"rf_sstf.h\"",
            "#include \"rf_cvscan.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int config_disk_queue(RF_Raid_t *, RF_DiskQueue_t *, RF_RowCol_t, \n\t\t      RF_RowCol_t, RF_DiskQueueSW_t *,\n\t\t      RF_SectorCount_t, dev_t, int, \n\t\t      RF_ShutdownList_t **,\n\t\t      RF_AllocListElem_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_fifo.h\"\n#include \"rf_sstf.h\"\n#include \"rf_cvscan.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nint config_disk_queue(RF_Raid_t *, RF_DiskQueue_t *, RF_RowCol_t, \n\t\t      RF_RowCol_t, RF_DiskQueueSW_t *,\n\t\t      RF_SectorCount_t, dev_t, int, \n\t\t      RF_ShutdownList_t **,\n\t\t      RF_AllocListElem_t *);\n\nint \nconfig_disk_queue(\n    RF_Raid_t * raidPtr,\n    RF_DiskQueue_t * diskqueue,\n    RF_RowCol_t r,\t\t/* row & col -- debug only.  BZZT not any\n\t\t\t\t * more... */\n    RF_RowCol_t c,\n    RF_DiskQueueSW_t * p,\n    RF_SectorCount_t sectPerDisk,\n    dev_t dev,\n    int maxOutstanding,\n    RF_ShutdownList_t ** listp,\n    RF_AllocListElem_t * clList)\n{\n\tint     rc;\n\n\tdiskqueue->row = r;\n\tdiskqueue->col = c;\n\tdiskqueue->qPtr = p;\n\tdiskqueue->qHdr = (p->Create) (sectPerDisk, clList, listp);\n\tdiskqueue->dev = dev;\n\tdiskqueue->numOutstanding = 0;\n\tdiskqueue->queueLength = 0;\n\tdiskqueue->maxOutstanding = maxOutstanding;\n\tdiskqueue->curPriority = RF_IO_NORMAL_PRIORITY;\n\tdiskqueue->nextLockingOp = NULL;\n\tdiskqueue->unlockingOp = NULL;\n\tdiskqueue->numWaiting = 0;\n\tdiskqueue->flags = 0;\n\tdiskqueue->raidPtr = raidPtr;\n\tdiskqueue->rf_cinfo = &raidPtr->raid_cinfo[r][c];\n\trc = rf_create_managed_mutex(listp, &diskqueue->mutex);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to init mutex file %s line %d rc=%d\\n\", __FILE__,\n\t\t    __LINE__, rc);\n\t\treturn (rc);\n\t}\n\trc = rf_create_managed_cond(listp, &diskqueue->cond);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to init cond file %s line %d rc=%d\\n\", __FILE__,\n\t\t    __LINE__, rc);\n\t\treturn (rc);\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG2",
          "args": [
            "\"Warning: truncating spare disk %s to %ld blocks\\n\"",
            "disks[spare_number].devname",
            "(long int) raidPtr->sectorsPerDisk"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG3",
          "args": [
            "\"Spare disk %s (%d blocks) is too small to serve as a spare (need %ld blocks)\\n\"",
            "disks[spare_number].devname",
            "disks[spare_number].blockSize",
            "(long int) raidPtr->sectorsPerDisk"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG3",
          "args": [
            "\"Block size of %d on spare disk %s is not the same as on other disks (%d)\\n\"",
            "disks[spare_number].blockSize",
            "disks[spare_number].devname",
            "bs"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF6",
          "args": [
            "\"Spare Disk %d: dev %s numBlocks %ld blockSize %d (%ld MB)\\n\"",
            "spare_number",
            "disks[spare_number].devname",
            "(long int) disks[spare_number].numBlocks",
            "disks[spare_number].blockSize",
            "(long int) disks[spare_number].numBlocks * \n\t\t\t disks[spare_number].blockSize / 1024 / 1024"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG1",
          "args": [
            "\"Warning: spare disk %s failed TUR\\n\"",
            "sparePtr->component_name"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_ConfigureDisk",
          "args": [
            "raidPtr",
            "sparePtr->component_name",
            "&disks[spare_number]",
            "0",
            "raidPtr->numCol + spare_number"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "rf_ConfigureDisk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_disks.c",
          "lines": "350-423",
          "snippet": "int \nrf_ConfigureDisk(raidPtr, buf, diskPtr, row, col)\n\tRF_Raid_t *raidPtr;\n\tchar   *buf;\n\tRF_RaidDisk_t *diskPtr;\n\tRF_RowCol_t row;\n\tRF_RowCol_t col;\n{\n\tchar   *p;\n\tint     retcode;\n\n\tstruct partinfo dpart;\n\tstruct vnode *vp;\n\tstruct vattr va;\n\tstruct proc *proc;\n\tint     error;\n\n\tretcode = 0;\n\tp = rf_find_non_white(buf);\n\tif (p[strlen(p) - 1] == '\\n') {\n\t\t/* strip off the newline */\n\t\tp[strlen(p) - 1] = '\\0';\n\t}\n\t(void) strcpy(diskPtr->devname, p);\n\n#if 0\n\tproc = raidPtr->engine_thread;\n#else\n\tproc = curproc;\n#endif\n\n\t/* Let's start by claiming the component is fine and well... */\n\tdiskPtr->status = rf_ds_optimal;\n\n\traidPtr->raid_cinfo[row][col].ci_vp = NULL;\n\traidPtr->raid_cinfo[row][col].ci_dev = NULL;\n\n\terror = raidlookup(diskPtr->devname, proc, &vp);\n\tif (error) {\n\t\tprintf(\"raidlookup on device: %s failed!\\n\", diskPtr->devname);\n\t\tif (error == ENXIO) {\n\t\t\t/* the component isn't there... must be dead :-( */\n\t\t\tdiskPtr->status = rf_ds_failed;\n\t\t} else {\n\t\t\treturn (error);\n\t\t}\n\t}\n\tif (diskPtr->status == rf_ds_optimal) {\n\n\t\tif ((error = VOP_GETATTR(vp, &va, proc->p_ucred, proc)) != 0) {\n\t\t\treturn (error);\n\t\t}\n\t\terror = VOP_IOCTL(vp, DIOCGPART, (caddr_t) & dpart,\n\t\t    FREAD, proc->p_ucred, proc);\n\t\tif (error) {\n\t\t\treturn (error);\n\t\t}\n\t\tdiskPtr->blockSize = dpart.disklab->d_secsize;\n\n\t\tdiskPtr->numBlocks = dpart.part->p_size - rf_protectedSectors;\n\n\t\traidPtr->raid_cinfo[row][col].ci_vp = vp;\n\t\traidPtr->raid_cinfo[row][col].ci_dev = va.va_rdev;\n\n\t\tdiskPtr->dev = va.va_rdev;\n\n\t\t/* we allow the user to specify that only a fraction of the\n\t\t * disks should be used this is just for debug:  it speeds up\n\t\t * the parity scan */\n\t\tdiskPtr->numBlocks = diskPtr->numBlocks * \n\t\t\trf_sizePercentage / 100;\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"rf_kintf.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void rf_UnconfigureVnodes( RF_Raid_t * );"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"rf_kintf.h\"\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_utils.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid rf_UnconfigureVnodes( RF_Raid_t * );\n\nint \nrf_ConfigureDisk(raidPtr, buf, diskPtr, row, col)\n\tRF_Raid_t *raidPtr;\n\tchar   *buf;\n\tRF_RaidDisk_t *diskPtr;\n\tRF_RowCol_t row;\n\tRF_RowCol_t col;\n{\n\tchar   *p;\n\tint     retcode;\n\n\tstruct partinfo dpart;\n\tstruct vnode *vp;\n\tstruct vattr va;\n\tstruct proc *proc;\n\tint     error;\n\n\tretcode = 0;\n\tp = rf_find_non_white(buf);\n\tif (p[strlen(p) - 1] == '\\n') {\n\t\t/* strip off the newline */\n\t\tp[strlen(p) - 1] = '\\0';\n\t}\n\t(void) strcpy(diskPtr->devname, p);\n\n#if 0\n\tproc = raidPtr->engine_thread;\n#else\n\tproc = curproc;\n#endif\n\n\t/* Let's start by claiming the component is fine and well... */\n\tdiskPtr->status = rf_ds_optimal;\n\n\traidPtr->raid_cinfo[row][col].ci_vp = NULL;\n\traidPtr->raid_cinfo[row][col].ci_dev = NULL;\n\n\terror = raidlookup(diskPtr->devname, proc, &vp);\n\tif (error) {\n\t\tprintf(\"raidlookup on device: %s failed!\\n\", diskPtr->devname);\n\t\tif (error == ENXIO) {\n\t\t\t/* the component isn't there... must be dead :-( */\n\t\t\tdiskPtr->status = rf_ds_failed;\n\t\t} else {\n\t\t\treturn (error);\n\t\t}\n\t}\n\tif (diskPtr->status == rf_ds_optimal) {\n\n\t\tif ((error = VOP_GETATTR(vp, &va, proc->p_ucred, proc)) != 0) {\n\t\t\treturn (error);\n\t\t}\n\t\terror = VOP_IOCTL(vp, DIOCGPART, (caddr_t) & dpart,\n\t\t    FREAD, proc->p_ucred, proc);\n\t\tif (error) {\n\t\t\treturn (error);\n\t\t}\n\t\tdiskPtr->blockSize = dpart.disklab->d_secsize;\n\n\t\tdiskPtr->numBlocks = dpart.part->p_size - rf_protectedSectors;\n\n\t\traidPtr->raid_cinfo[row][col].ci_vp = vp;\n\t\traidPtr->raid_cinfo[row][col].ci_dev = va.va_rdev;\n\n\t\tdiskPtr->dev = va.va_rdev;\n\n\t\t/* we allow the user to specify that only a fraction of the\n\t\t * disks should be used this is just for debug:  it speeds up\n\t\t * the parity scan */\n\t\tdiskPtr->numBlocks = diskPtr->numBlocks * \n\t\t\trf_sizePercentage / 100;\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_LOCK_MUTEX",
          "args": [
            "raidPtr->mutex"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG1",
          "args": [
            "\"Too many spares: %d\\n\"",
            "raidPtr->numSpare"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Num col: %d\\n\"",
            "raidPtr->numCol"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"rf_kintf.h\"\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_utils.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid rf_UnconfigureVnodes( RF_Raid_t * );\nint rf_add_hot_spare(RF_Raid_t *, RF_SingleComponent_t *);\n\nint\nrf_add_hot_spare(raidPtr, sparePtr)\n\tRF_Raid_t *raidPtr;\n\tRF_SingleComponent_t *sparePtr;\n{\n\tRF_RaidDisk_t *disks;\n\tRF_DiskQueue_t *spareQueues;\n\tint ret;\n\tunsigned int bs;\n\tint spare_number;\n\n\tprintf(\"Just in rf_add_hot_spare: %d\\n\",raidPtr->numSpare);\n\tprintf(\"Num col: %d\\n\",raidPtr->numCol);\n\tif (raidPtr->numSpare >= RF_MAXSPARE) {\n\t\tRF_ERRORMSG1(\"Too many spares: %d\\n\", raidPtr->numSpare);\n\t\treturn(EINVAL);\n \t}\n\n\tRF_LOCK_MUTEX(raidPtr->mutex);\n\n\t/* the beginning of the spares... */\n\tdisks = &raidPtr->Disks[0][raidPtr->numCol];\n\n\tspare_number = raidPtr->numSpare;\n\n\tret = rf_ConfigureDisk(raidPtr, sparePtr->component_name,\n\t\t\t       &disks[spare_number], 0,\n\t\t\t       raidPtr->numCol + spare_number);\n\n\tif (ret)\n\t\tgoto fail;\n\tif (disks[spare_number].status != rf_ds_optimal) {\n\t\tRF_ERRORMSG1(\"Warning: spare disk %s failed TUR\\n\", \n\t\t\t     sparePtr->component_name);\n\t\tret=EINVAL;\n\t\tgoto fail;\n\t} else {\n\t\tdisks[spare_number].status = rf_ds_spare;\n\t\tDPRINTF6(\"Spare Disk %d: dev %s numBlocks %ld blockSize %d (%ld MB)\\n\", spare_number,\n\t\t\t disks[spare_number].devname,\n\t\t\t (long int) disks[spare_number].numBlocks, \n\t\t\t disks[spare_number].blockSize,\n\t\t\t (long int) disks[spare_number].numBlocks * \n\t\t\t disks[spare_number].blockSize / 1024 / 1024);\n\t}\n\t\n\n\t/* check sizes and block sizes on the spare disk */\n\tbs = 1 << raidPtr->logBytesPerSector;\n\tif (disks[spare_number].blockSize != bs) {\n\t\tRF_ERRORMSG3(\"Block size of %d on spare disk %s is not the same as on other disks (%d)\\n\", disks[spare_number].blockSize, disks[spare_number].devname, bs);\n\t\tret = EINVAL;\n\t\tgoto fail;\n\t}\n\tif (disks[spare_number].numBlocks < raidPtr->sectorsPerDisk) {\n\t\tRF_ERRORMSG3(\"Spare disk %s (%d blocks) is too small to serve as a spare (need %ld blocks)\\n\",\n\t\t\t     disks[spare_number].devname, \n\t\t\t     disks[spare_number].blockSize, \n\t\t\t     (long int) raidPtr->sectorsPerDisk);\n\t\tret = EINVAL;\n\t\tgoto fail;\n\t} else {\n\t\tif (disks[spare_number].numBlocks > \n\t\t    raidPtr->sectorsPerDisk) {\n\t\t\tRF_ERRORMSG2(\"Warning: truncating spare disk %s to %ld blocks\\n\", disks[spare_number].devname, \n\t\t\t\t     (long int) raidPtr->sectorsPerDisk);\n\t\t\t\n\t\t\tdisks[spare_number].numBlocks = raidPtr->sectorsPerDisk;\n\t\t}\n\t}\n\n\tspareQueues = &raidPtr->Queues[0][raidPtr->numCol];\n\tret = config_disk_queue( raidPtr, &spareQueues[spare_number],\n\t\t\t\t 0, raidPtr->numCol + spare_number, \n\t\t\t\t raidPtr->Queues[0][0].qPtr, /* XXX */\n\t\t\t\t raidPtr->sectorsPerDisk,\n\t\t\t\t raidPtr->Disks[0][raidPtr->numCol + spare_number].dev,\n\t\t\t\t raidPtr->Queues[0][0].maxOutstanding, /* XXX */\n\t\t\t\t &raidPtr->shutdownList,\n\t\t\t\t raidPtr->cleanupList);\n\t\t\t\t \n\n\traidPtr->numSpare++;\n\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\treturn (0);\n\nfail:\n\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\treturn(ret);\n}"
  },
  {
    "function_name": "rf_CheckLabels",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_disks.c",
    "lines": "504-765",
    "snippet": "int \nrf_CheckLabels( raidPtr, cfgPtr )\n\tRF_Raid_t *raidPtr;\n\tRF_Config_t *cfgPtr;\n{\n\tint r,c;\n\tchar *dev_name;\n\tRF_ComponentLabel_t *ci_label;\n\tint serial_number = 0;\n\tint mod_number = 0;\n\tint fatal_error = 0;\n\tint mod_values[4];\n\tint mod_count[4];\n\tint ser_values[4];\n\tint ser_count[4];\n\tint num_ser;\n\tint num_mod;\n\tint i;\n\tint found;\n\tint hosed_row;\n\tint hosed_column;\n\tint too_fatal;\n\tint parity_good;\n\tint force;\n\n\thosed_row = -1;\n\thosed_column = -1;\n\ttoo_fatal = 0;\n\tforce = cfgPtr->force;\n\n\t/* \n\t   We're going to try to be a little intelligent here.  If one \n\t   component's label is bogus, and we can identify that it's the\n\t   *only* one that's gone, we'll mark it as \"failed\" and allow\n\t   the configuration to proceed.  This will be the *only* case\n\t   that we'll proceed if there would be (otherwise) fatal errors.\n\t   \n\t   Basically we simply keep a count of how many components had\n\t   what serial number.  If all but one agree, we simply mark\n\t   the disagreeing component as being failed, and allow \n\t   things to come up \"normally\".\n\t   \n\t   We do this first for serial numbers, and then for \"mod_counter\".\n\n\t */\n\n\tnum_ser = 0;\n\tnum_mod = 0;\n\tfor (r = 0; r < raidPtr->numRow && !fatal_error ; r++) {\n\t\tfor (c = 0; c < raidPtr->numCol; c++) {\n\t\t\tci_label = &raidPtr->raid_cinfo[r][c].ci_label;\n\t\t\tfound=0;\n\t\t\tfor(i=0;i<num_ser;i++) {\n\t\t\t\tif (ser_values[i] == ci_label->serial_number) {\n\t\t\t\t\tser_count[i]++;\n\t\t\t\t\tfound=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t\tser_values[num_ser] = ci_label->serial_number;\n\t\t\t\tser_count[num_ser] = 1;\n\t\t\t\tnum_ser++;\n\t\t\t\tif (num_ser>2) {\n\t\t\t\t\tfatal_error = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfound=0;\n\t\t\tfor(i=0;i<num_mod;i++) {\n\t\t\t\tif (mod_values[i] == ci_label->mod_counter) {\n\t\t\t\t\tmod_count[i]++;\n\t\t\t\t\tfound=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t        mod_values[num_mod] = ci_label->mod_counter;\n\t\t\t\tmod_count[num_mod] = 1;\n\t\t\t\tnum_mod++;\n\t\t\t\tif (num_mod>2) {\n\t\t\t\t\tfatal_error = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n#if DEBUG\n\tprintf(\"raid%d: Summary of serial numbers:\\n\", raidPtr->raidid);\n\tfor(i=0;i<num_ser;i++) {\n\t\tprintf(\"%d %d\\n\", ser_values[i], ser_count[i]);\n\t}\n\tprintf(\"raid%d: Summary of mod counters:\\n\", raidPtr->raidid);\n\tfor(i=0;i<num_mod;i++) {\n\t\tprintf(\"%d %d\\n\", mod_values[i], mod_count[i]);\n\t}\n#endif\n\tserial_number = ser_values[0];\n\tif (num_ser == 2) {\n\t\tif ((ser_count[0] == 1) || (ser_count[1] == 1)) {\n\t\t\t/* Locate the maverick component */\n\t\t\tif (ser_count[1] > ser_count[0]) {\n\t\t\t\tserial_number = ser_values[1];\n\t\t\t} \n\t\t\tfor (r = 0; r < raidPtr->numRow; r++) {\n\t\t\t\tfor (c = 0; c < raidPtr->numCol; c++) {\n\t\t\t\tci_label = &raidPtr->raid_cinfo[r][c].ci_label;\n\t\t\t\t\tif (serial_number != \n\t\t\t\t\t    ci_label->serial_number) {\n\t\t\t\t\t\thosed_row = r;\n\t\t\t\t\t\thosed_column = c;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"Hosed component: %s\\n\",\n\t\t\t       &cfgPtr->devnames[hosed_row][hosed_column][0]);\n\t\t\tif (!force) {\n\t\t\t\t/* we'll fail this component, as if there are\n\t\t\t\t   other major errors, we arn't forcing things\n\t\t\t\t   and we'll abort the config anyways */\n\t\t\t\traidPtr->Disks[hosed_row][hosed_column].status\n\t\t\t\t\t= rf_ds_failed;\n\t\t\t\traidPtr->numFailures++;\n\t\t\t\traidPtr->status[hosed_row] = rf_rs_degraded;\n\t\t\t}\n\t\t} else {\n\t\t\ttoo_fatal = 1;\n\t\t}\n\t\tif (cfgPtr->parityConfig == '0') {\n\t\t\t/* We've identified two different serial numbers. \n\t\t\t   RAID 0 can't cope with that, so we'll punt */\n\t\t\ttoo_fatal = 1;\n\t\t}\n\n\t} \n\n\t/* record the serial number for later.  If we bail later, setting\n\t   this doesn't matter, otherwise we've got the best guess at the \n\t   correct serial number */\n\traidPtr->serial_number = serial_number;\n\n\tmod_number = mod_values[0];\n\tif (num_mod == 2) {\n\t\tif ((mod_count[0] == 1) || (mod_count[1] == 1)) {\n\t\t\t/* Locate the maverick component */\n\t\t\tif (mod_count[1] > mod_count[0]) {\n\t\t\t\tmod_number = mod_values[1];\n\t\t\t} else if (mod_count[1] < mod_count[0]) {\n\t\t\t\tmod_number = mod_values[0];\n\t\t\t} else {\n\t\t\t\t/* counts of different modification values\n\t\t\t\t   are the same.   Assume greater value is \n\t\t\t\t   the correct one, all other things \n\t\t\t\t   considered */\n\t\t\t\tif (mod_values[0] > mod_values[1]) {\n\t\t\t\t\tmod_number = mod_values[0];\n\t\t\t\t} else {\n\t\t\t\t\tmod_number = mod_values[1];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tfor (r = 0; r < raidPtr->numRow && !too_fatal ; r++) {\n\t\t\t\tfor (c = 0; c < raidPtr->numCol; c++) {\n\t\t\t\t\tci_label = &raidPtr->raid_cinfo[r][c].ci_label;\n\t\t\t\t\tif (mod_number != \n\t\t\t\t\t    ci_label->mod_counter) {\n\t\t\t\t\t\tif ( ( hosed_row == r ) &&\n\t\t\t\t\t\t     ( hosed_column == c )) {\n\t\t\t\t\t\t\t/* same one.  Can\n\t\t\t\t\t\t\t   deal with it.  */\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\thosed_row = r;\n\t\t\t\t\t\t\thosed_column = c;\n\t\t\t\t\t\t\tif (num_ser != 1) {\n\t\t\t\t\t\t\t\ttoo_fatal = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"Hosed component: %s\\n\",\n\t\t\t       &cfgPtr->devnames[hosed_row][hosed_column][0]);\n\t\t\tif (!force) {\n\t\t\t\t/* we'll fail this component, as if there are\n\t\t\t\t   other major errors, we arn't forcing things\n\t\t\t\t   and we'll abort the config anyways */\n\t\t\t\tif (raidPtr->Disks[hosed_row][hosed_column].status != rf_ds_failed) {\n\t\t\t\t\traidPtr->Disks[hosed_row][hosed_column].status\n\t\t\t\t\t\t= rf_ds_failed;\n\t\t\t\t\traidPtr->numFailures++;\n\t\t\t\t\traidPtr->status[hosed_row] = rf_rs_degraded;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\ttoo_fatal = 1;\n\t\t}\n\t\tif (cfgPtr->parityConfig == '0') {\n\t\t\t/* We've identified two different mod counters.\n\t\t\t   RAID 0 can't cope with that, so we'll punt */\n\t\t\ttoo_fatal = 1;\n\t\t}\n\t} \n\n\traidPtr->mod_counter = mod_number;\n\n\tif (too_fatal) {\n\t\t/* we've had both a serial number mismatch, and a mod_counter\n\t\t   mismatch -- and they involved two different components!!\n\t\t   Bail -- make things fail so that the user must force\n\t\t   the issue... */\n\t\thosed_row = -1;\n\t\thosed_column = -1;\n\t}\n\n\tif (num_ser > 2) {\n\t\tprintf(\"raid%d: Too many different serial numbers!\\n\", \n\t\t       raidPtr->raidid);\n\t}\n\n\tif (num_mod > 2) {\n\t\tprintf(\"raid%d: Too many different mod counters!\\n\", \n\t\t       raidPtr->raidid);\n\t}\n\n\t/* we start by assuming the parity will be good, and flee from\n\t   that notion at the slightest sign of trouble */\n\n\tparity_good = RF_RAID_CLEAN;\n\tfor (r = 0; r < raidPtr->numRow; r++) {\n\t\tfor (c = 0; c < raidPtr->numCol; c++) {\n\t\t\tdev_name = &cfgPtr->devnames[r][c][0];\n\t\t\tci_label = &raidPtr->raid_cinfo[r][c].ci_label;\n\n\t\t\tif ((r == hosed_row) && (c == hosed_column)) {\n\t\t\t\tprintf(\"raid%d: Ignoring %s\\n\",\n\t\t\t\t       raidPtr->raidid, dev_name);\n\t\t\t} else {\t\t\t\n\t\t\t\trf_print_label_status( raidPtr, r, c, \n\t\t\t\t\t\t       dev_name, ci_label );\n\t\t\t\tif (rf_check_label_vitals( raidPtr, r, c, \n\t\t\t\t\t\t\t   dev_name, ci_label,\n\t\t\t\t\t\t\t   serial_number, \n\t\t\t\t\t\t\t   mod_number )) {\n\t\t\t\t\tfatal_error = 1;\n\t\t\t\t}\n\t\t\t\tif (ci_label->clean != RF_RAID_CLEAN) {\n\t\t\t\t\tparity_good = RF_RAID_DIRTY;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (fatal_error) {\n\t\tparity_good = RF_RAID_DIRTY;\n\t}\n\n\t/* we note the state of the parity */\n\traidPtr->parity_good = parity_good;\n\n\treturn(fatal_error);\t\n}",
    "includes": [
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"rf_kintf.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void rf_UnconfigureVnodes( RF_Raid_t * );",
      "int rf_CheckLabels( RF_Raid_t *, RF_Config_t *);",
      "static void rf_print_label_status( RF_Raid_t *, int, int, char *, \n\t\t\t\t  RF_ComponentLabel_t *);",
      "static int rf_check_label_vitals( RF_Raid_t *, int, int, char *, \n\t\t\t\t  RF_ComponentLabel_t *, int, int );"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_check_label_vitals",
          "args": [
            "raidPtr",
            "r",
            "c",
            "dev_name",
            "ci_label",
            "serial_number",
            "mod_number"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "rf_check_label_vitals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_disks.c",
          "lines": "451-494",
          "snippet": "static int rf_check_label_vitals( raidPtr, row, column, dev_name, ci_label,\n\t\t\t\t  serial_number, mod_counter )\n\tRF_Raid_t *raidPtr;\n\tint row;\n\tint column;\n\tchar *dev_name;\n\tRF_ComponentLabel_t *ci_label;\n\tint serial_number;\n\tint mod_counter;\n{\n\tint fatal_error = 0;\n\n\tif (serial_number != ci_label->serial_number) {\n\t\tprintf(\"%s has a different serial number: %d %d\\n\", \n\t\t       dev_name, serial_number, ci_label->serial_number);\n\t\tfatal_error = 1;\n\t}\n\tif (mod_counter != ci_label->mod_counter) {\n\t\tprintf(\"%s has a different modfication count: %d %d\\n\",\n\t\t       dev_name, mod_counter, ci_label->mod_counter);\n\t}\n\t\n\tif (row != ci_label->row) {\n\t\tprintf(\"Row out of alignment for: %s\\n\", dev_name); \n\t\tfatal_error = 1;\n\t}\n\tif (column != ci_label->column) {\n\t\tprintf(\"Column out of alignment for: %s\\n\", dev_name);\n\t\tfatal_error = 1;\n\t}\n\tif (raidPtr->numRow != ci_label->num_rows) {\n\t\tprintf(\"Number of rows do not match for: %s\\n\", dev_name);\n\t\tfatal_error = 1;\n\t}\n\tif (raidPtr->numCol != ci_label->num_columns) {\n\t\tprintf(\"Number of columns do not match for: %s\\n\", dev_name);\n\t\tfatal_error = 1;\n\t}\n\tif (ci_label->clean == 0) {\n\t\t/* it's not clean, but that's not fatal */\n\t\tprintf(\"%s is not clean!\\n\", dev_name);\n\t}\n\treturn(fatal_error);\n}",
          "includes": [
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"rf_kintf.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void rf_UnconfigureVnodes( RF_Raid_t * );",
            "static void rf_print_label_status( RF_Raid_t *, int, int, char *, \n\t\t\t\t  RF_ComponentLabel_t *);",
            "static int rf_check_label_vitals( RF_Raid_t *, int, int, char *, \n\t\t\t\t  RF_ComponentLabel_t *, int, int );"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"rf_kintf.h\"\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_utils.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid rf_UnconfigureVnodes( RF_Raid_t * );\nstatic void rf_print_label_status( RF_Raid_t *, int, int, char *, \n\t\t\t\t  RF_ComponentLabel_t *);\nstatic int rf_check_label_vitals( RF_Raid_t *, int, int, char *, \n\t\t\t\t  RF_ComponentLabel_t *, int, int );\n\nstatic int rf_check_label_vitals( raidPtr, row, column, dev_name, ci_label,\n\t\t\t\t  serial_number, mod_counter )\n\tRF_Raid_t *raidPtr;\n\tint row;\n\tint column;\n\tchar *dev_name;\n\tRF_ComponentLabel_t *ci_label;\n\tint serial_number;\n\tint mod_counter;\n{\n\tint fatal_error = 0;\n\n\tif (serial_number != ci_label->serial_number) {\n\t\tprintf(\"%s has a different serial number: %d %d\\n\", \n\t\t       dev_name, serial_number, ci_label->serial_number);\n\t\tfatal_error = 1;\n\t}\n\tif (mod_counter != ci_label->mod_counter) {\n\t\tprintf(\"%s has a different modfication count: %d %d\\n\",\n\t\t       dev_name, mod_counter, ci_label->mod_counter);\n\t}\n\t\n\tif (row != ci_label->row) {\n\t\tprintf(\"Row out of alignment for: %s\\n\", dev_name); \n\t\tfatal_error = 1;\n\t}\n\tif (column != ci_label->column) {\n\t\tprintf(\"Column out of alignment for: %s\\n\", dev_name);\n\t\tfatal_error = 1;\n\t}\n\tif (raidPtr->numRow != ci_label->num_rows) {\n\t\tprintf(\"Number of rows do not match for: %s\\n\", dev_name);\n\t\tfatal_error = 1;\n\t}\n\tif (raidPtr->numCol != ci_label->num_columns) {\n\t\tprintf(\"Number of columns do not match for: %s\\n\", dev_name);\n\t\tfatal_error = 1;\n\t}\n\tif (ci_label->clean == 0) {\n\t\t/* it's not clean, but that's not fatal */\n\t\tprintf(\"%s is not clean!\\n\", dev_name);\n\t}\n\treturn(fatal_error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_print_label_status",
          "args": [
            "raidPtr",
            "r",
            "c",
            "dev_name",
            "ci_label"
          ],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "rf_print_label_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_disks.c",
          "lines": "428-447",
          "snippet": "static void\nrf_print_label_status( raidPtr, row, column, dev_name, ci_label )\n\tRF_Raid_t *raidPtr;\n\tint row;\n\tint column;\n\tchar *dev_name;\n\tRF_ComponentLabel_t *ci_label;\n{\n\n\tprintf(\"raid%d: Component %s being configured at row: %d col: %d\\n\", \n\t       raidPtr->raidid, dev_name, row, column );\n\tprintf(\"         Row: %d Column: %d Num Rows: %d Num Columns: %d\\n\",\n\t       ci_label->row, ci_label->column, \n\t       ci_label->num_rows, ci_label->num_columns);\n\tprintf(\"         Version: %d Serial Number: %d Mod Counter: %d\\n\",\n\t       ci_label->version, ci_label->serial_number,\n\t       ci_label->mod_counter);\n\tprintf(\"         Clean: %s Status: %d\\n\",\n\t       ci_label->clean ? \"Yes\" : \"No\", ci_label->status );\n}",
          "includes": [
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"rf_kintf.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void rf_UnconfigureVnodes( RF_Raid_t * );",
            "static void rf_print_label_status( RF_Raid_t *, int, int, char *, \n\t\t\t\t  RF_ComponentLabel_t *);",
            "static int rf_check_label_vitals( RF_Raid_t *, int, int, char *, \n\t\t\t\t  RF_ComponentLabel_t *, int, int );"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"rf_kintf.h\"\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_utils.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid rf_UnconfigureVnodes( RF_Raid_t * );\nstatic void rf_print_label_status( RF_Raid_t *, int, int, char *, \n\t\t\t\t  RF_ComponentLabel_t *);\nstatic int rf_check_label_vitals( RF_Raid_t *, int, int, char *, \n\t\t\t\t  RF_ComponentLabel_t *, int, int );\n\nstatic void\nrf_print_label_status( raidPtr, row, column, dev_name, ci_label )\n\tRF_Raid_t *raidPtr;\n\tint row;\n\tint column;\n\tchar *dev_name;\n\tRF_ComponentLabel_t *ci_label;\n{\n\n\tprintf(\"raid%d: Component %s being configured at row: %d col: %d\\n\", \n\t       raidPtr->raidid, dev_name, row, column );\n\tprintf(\"         Row: %d Column: %d Num Rows: %d Num Columns: %d\\n\",\n\t       ci_label->row, ci_label->column, \n\t       ci_label->num_rows, ci_label->num_columns);\n\tprintf(\"         Version: %d Serial Number: %d Mod Counter: %d\\n\",\n\t       ci_label->version, ci_label->serial_number,\n\t       ci_label->mod_counter);\n\tprintf(\"         Clean: %s Status: %d\\n\",\n\t       ci_label->clean ? \"Yes\" : \"No\", ci_label->status );\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"raid%d: Ignoring %s\\n\"",
            "raidPtr->raidid",
            "dev_name"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"rf_kintf.h\"\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_utils.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid rf_UnconfigureVnodes( RF_Raid_t * );\nint rf_CheckLabels( RF_Raid_t *, RF_Config_t *);\nstatic void rf_print_label_status( RF_Raid_t *, int, int, char *, \n\t\t\t\t  RF_ComponentLabel_t *);\nstatic int rf_check_label_vitals( RF_Raid_t *, int, int, char *, \n\t\t\t\t  RF_ComponentLabel_t *, int, int );\n\nint \nrf_CheckLabels( raidPtr, cfgPtr )\n\tRF_Raid_t *raidPtr;\n\tRF_Config_t *cfgPtr;\n{\n\tint r,c;\n\tchar *dev_name;\n\tRF_ComponentLabel_t *ci_label;\n\tint serial_number = 0;\n\tint mod_number = 0;\n\tint fatal_error = 0;\n\tint mod_values[4];\n\tint mod_count[4];\n\tint ser_values[4];\n\tint ser_count[4];\n\tint num_ser;\n\tint num_mod;\n\tint i;\n\tint found;\n\tint hosed_row;\n\tint hosed_column;\n\tint too_fatal;\n\tint parity_good;\n\tint force;\n\n\thosed_row = -1;\n\thosed_column = -1;\n\ttoo_fatal = 0;\n\tforce = cfgPtr->force;\n\n\t/* \n\t   We're going to try to be a little intelligent here.  If one \n\t   component's label is bogus, and we can identify that it's the\n\t   *only* one that's gone, we'll mark it as \"failed\" and allow\n\t   the configuration to proceed.  This will be the *only* case\n\t   that we'll proceed if there would be (otherwise) fatal errors.\n\t   \n\t   Basically we simply keep a count of how many components had\n\t   what serial number.  If all but one agree, we simply mark\n\t   the disagreeing component as being failed, and allow \n\t   things to come up \"normally\".\n\t   \n\t   We do this first for serial numbers, and then for \"mod_counter\".\n\n\t */\n\n\tnum_ser = 0;\n\tnum_mod = 0;\n\tfor (r = 0; r < raidPtr->numRow && !fatal_error ; r++) {\n\t\tfor (c = 0; c < raidPtr->numCol; c++) {\n\t\t\tci_label = &raidPtr->raid_cinfo[r][c].ci_label;\n\t\t\tfound=0;\n\t\t\tfor(i=0;i<num_ser;i++) {\n\t\t\t\tif (ser_values[i] == ci_label->serial_number) {\n\t\t\t\t\tser_count[i]++;\n\t\t\t\t\tfound=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t\tser_values[num_ser] = ci_label->serial_number;\n\t\t\t\tser_count[num_ser] = 1;\n\t\t\t\tnum_ser++;\n\t\t\t\tif (num_ser>2) {\n\t\t\t\t\tfatal_error = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfound=0;\n\t\t\tfor(i=0;i<num_mod;i++) {\n\t\t\t\tif (mod_values[i] == ci_label->mod_counter) {\n\t\t\t\t\tmod_count[i]++;\n\t\t\t\t\tfound=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t        mod_values[num_mod] = ci_label->mod_counter;\n\t\t\t\tmod_count[num_mod] = 1;\n\t\t\t\tnum_mod++;\n\t\t\t\tif (num_mod>2) {\n\t\t\t\t\tfatal_error = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n#if DEBUG\n\tprintf(\"raid%d: Summary of serial numbers:\\n\", raidPtr->raidid);\n\tfor(i=0;i<num_ser;i++) {\n\t\tprintf(\"%d %d\\n\", ser_values[i], ser_count[i]);\n\t}\n\tprintf(\"raid%d: Summary of mod counters:\\n\", raidPtr->raidid);\n\tfor(i=0;i<num_mod;i++) {\n\t\tprintf(\"%d %d\\n\", mod_values[i], mod_count[i]);\n\t}\n#endif\n\tserial_number = ser_values[0];\n\tif (num_ser == 2) {\n\t\tif ((ser_count[0] == 1) || (ser_count[1] == 1)) {\n\t\t\t/* Locate the maverick component */\n\t\t\tif (ser_count[1] > ser_count[0]) {\n\t\t\t\tserial_number = ser_values[1];\n\t\t\t} \n\t\t\tfor (r = 0; r < raidPtr->numRow; r++) {\n\t\t\t\tfor (c = 0; c < raidPtr->numCol; c++) {\n\t\t\t\tci_label = &raidPtr->raid_cinfo[r][c].ci_label;\n\t\t\t\t\tif (serial_number != \n\t\t\t\t\t    ci_label->serial_number) {\n\t\t\t\t\t\thosed_row = r;\n\t\t\t\t\t\thosed_column = c;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"Hosed component: %s\\n\",\n\t\t\t       &cfgPtr->devnames[hosed_row][hosed_column][0]);\n\t\t\tif (!force) {\n\t\t\t\t/* we'll fail this component, as if there are\n\t\t\t\t   other major errors, we arn't forcing things\n\t\t\t\t   and we'll abort the config anyways */\n\t\t\t\traidPtr->Disks[hosed_row][hosed_column].status\n\t\t\t\t\t= rf_ds_failed;\n\t\t\t\traidPtr->numFailures++;\n\t\t\t\traidPtr->status[hosed_row] = rf_rs_degraded;\n\t\t\t}\n\t\t} else {\n\t\t\ttoo_fatal = 1;\n\t\t}\n\t\tif (cfgPtr->parityConfig == '0') {\n\t\t\t/* We've identified two different serial numbers. \n\t\t\t   RAID 0 can't cope with that, so we'll punt */\n\t\t\ttoo_fatal = 1;\n\t\t}\n\n\t} \n\n\t/* record the serial number for later.  If we bail later, setting\n\t   this doesn't matter, otherwise we've got the best guess at the \n\t   correct serial number */\n\traidPtr->serial_number = serial_number;\n\n\tmod_number = mod_values[0];\n\tif (num_mod == 2) {\n\t\tif ((mod_count[0] == 1) || (mod_count[1] == 1)) {\n\t\t\t/* Locate the maverick component */\n\t\t\tif (mod_count[1] > mod_count[0]) {\n\t\t\t\tmod_number = mod_values[1];\n\t\t\t} else if (mod_count[1] < mod_count[0]) {\n\t\t\t\tmod_number = mod_values[0];\n\t\t\t} else {\n\t\t\t\t/* counts of different modification values\n\t\t\t\t   are the same.   Assume greater value is \n\t\t\t\t   the correct one, all other things \n\t\t\t\t   considered */\n\t\t\t\tif (mod_values[0] > mod_values[1]) {\n\t\t\t\t\tmod_number = mod_values[0];\n\t\t\t\t} else {\n\t\t\t\t\tmod_number = mod_values[1];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tfor (r = 0; r < raidPtr->numRow && !too_fatal ; r++) {\n\t\t\t\tfor (c = 0; c < raidPtr->numCol; c++) {\n\t\t\t\t\tci_label = &raidPtr->raid_cinfo[r][c].ci_label;\n\t\t\t\t\tif (mod_number != \n\t\t\t\t\t    ci_label->mod_counter) {\n\t\t\t\t\t\tif ( ( hosed_row == r ) &&\n\t\t\t\t\t\t     ( hosed_column == c )) {\n\t\t\t\t\t\t\t/* same one.  Can\n\t\t\t\t\t\t\t   deal with it.  */\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\thosed_row = r;\n\t\t\t\t\t\t\thosed_column = c;\n\t\t\t\t\t\t\tif (num_ser != 1) {\n\t\t\t\t\t\t\t\ttoo_fatal = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"Hosed component: %s\\n\",\n\t\t\t       &cfgPtr->devnames[hosed_row][hosed_column][0]);\n\t\t\tif (!force) {\n\t\t\t\t/* we'll fail this component, as if there are\n\t\t\t\t   other major errors, we arn't forcing things\n\t\t\t\t   and we'll abort the config anyways */\n\t\t\t\tif (raidPtr->Disks[hosed_row][hosed_column].status != rf_ds_failed) {\n\t\t\t\t\traidPtr->Disks[hosed_row][hosed_column].status\n\t\t\t\t\t\t= rf_ds_failed;\n\t\t\t\t\traidPtr->numFailures++;\n\t\t\t\t\traidPtr->status[hosed_row] = rf_rs_degraded;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\ttoo_fatal = 1;\n\t\t}\n\t\tif (cfgPtr->parityConfig == '0') {\n\t\t\t/* We've identified two different mod counters.\n\t\t\t   RAID 0 can't cope with that, so we'll punt */\n\t\t\ttoo_fatal = 1;\n\t\t}\n\t} \n\n\traidPtr->mod_counter = mod_number;\n\n\tif (too_fatal) {\n\t\t/* we've had both a serial number mismatch, and a mod_counter\n\t\t   mismatch -- and they involved two different components!!\n\t\t   Bail -- make things fail so that the user must force\n\t\t   the issue... */\n\t\thosed_row = -1;\n\t\thosed_column = -1;\n\t}\n\n\tif (num_ser > 2) {\n\t\tprintf(\"raid%d: Too many different serial numbers!\\n\", \n\t\t       raidPtr->raidid);\n\t}\n\n\tif (num_mod > 2) {\n\t\tprintf(\"raid%d: Too many different mod counters!\\n\", \n\t\t       raidPtr->raidid);\n\t}\n\n\t/* we start by assuming the parity will be good, and flee from\n\t   that notion at the slightest sign of trouble */\n\n\tparity_good = RF_RAID_CLEAN;\n\tfor (r = 0; r < raidPtr->numRow; r++) {\n\t\tfor (c = 0; c < raidPtr->numCol; c++) {\n\t\t\tdev_name = &cfgPtr->devnames[r][c][0];\n\t\t\tci_label = &raidPtr->raid_cinfo[r][c].ci_label;\n\n\t\t\tif ((r == hosed_row) && (c == hosed_column)) {\n\t\t\t\tprintf(\"raid%d: Ignoring %s\\n\",\n\t\t\t\t       raidPtr->raidid, dev_name);\n\t\t\t} else {\t\t\t\n\t\t\t\trf_print_label_status( raidPtr, r, c, \n\t\t\t\t\t\t       dev_name, ci_label );\n\t\t\t\tif (rf_check_label_vitals( raidPtr, r, c, \n\t\t\t\t\t\t\t   dev_name, ci_label,\n\t\t\t\t\t\t\t   serial_number, \n\t\t\t\t\t\t\t   mod_number )) {\n\t\t\t\t\tfatal_error = 1;\n\t\t\t\t}\n\t\t\t\tif (ci_label->clean != RF_RAID_CLEAN) {\n\t\t\t\t\tparity_good = RF_RAID_DIRTY;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (fatal_error) {\n\t\tparity_good = RF_RAID_DIRTY;\n\t}\n\n\t/* we note the state of the parity */\n\traidPtr->parity_good = parity_good;\n\n\treturn(fatal_error);\t\n}"
  },
  {
    "function_name": "rf_check_label_vitals",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_disks.c",
    "lines": "451-494",
    "snippet": "static int rf_check_label_vitals( raidPtr, row, column, dev_name, ci_label,\n\t\t\t\t  serial_number, mod_counter )\n\tRF_Raid_t *raidPtr;\n\tint row;\n\tint column;\n\tchar *dev_name;\n\tRF_ComponentLabel_t *ci_label;\n\tint serial_number;\n\tint mod_counter;\n{\n\tint fatal_error = 0;\n\n\tif (serial_number != ci_label->serial_number) {\n\t\tprintf(\"%s has a different serial number: %d %d\\n\", \n\t\t       dev_name, serial_number, ci_label->serial_number);\n\t\tfatal_error = 1;\n\t}\n\tif (mod_counter != ci_label->mod_counter) {\n\t\tprintf(\"%s has a different modfication count: %d %d\\n\",\n\t\t       dev_name, mod_counter, ci_label->mod_counter);\n\t}\n\t\n\tif (row != ci_label->row) {\n\t\tprintf(\"Row out of alignment for: %s\\n\", dev_name); \n\t\tfatal_error = 1;\n\t}\n\tif (column != ci_label->column) {\n\t\tprintf(\"Column out of alignment for: %s\\n\", dev_name);\n\t\tfatal_error = 1;\n\t}\n\tif (raidPtr->numRow != ci_label->num_rows) {\n\t\tprintf(\"Number of rows do not match for: %s\\n\", dev_name);\n\t\tfatal_error = 1;\n\t}\n\tif (raidPtr->numCol != ci_label->num_columns) {\n\t\tprintf(\"Number of columns do not match for: %s\\n\", dev_name);\n\t\tfatal_error = 1;\n\t}\n\tif (ci_label->clean == 0) {\n\t\t/* it's not clean, but that's not fatal */\n\t\tprintf(\"%s is not clean!\\n\", dev_name);\n\t}\n\treturn(fatal_error);\n}",
    "includes": [
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"rf_kintf.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void rf_UnconfigureVnodes( RF_Raid_t * );",
      "static void rf_print_label_status( RF_Raid_t *, int, int, char *, \n\t\t\t\t  RF_ComponentLabel_t *);",
      "static int rf_check_label_vitals( RF_Raid_t *, int, int, char *, \n\t\t\t\t  RF_ComponentLabel_t *, int, int );"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s is not clean!\\n\"",
            "dev_name"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"rf_kintf.h\"\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_utils.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid rf_UnconfigureVnodes( RF_Raid_t * );\nstatic void rf_print_label_status( RF_Raid_t *, int, int, char *, \n\t\t\t\t  RF_ComponentLabel_t *);\nstatic int rf_check_label_vitals( RF_Raid_t *, int, int, char *, \n\t\t\t\t  RF_ComponentLabel_t *, int, int );\n\nstatic int rf_check_label_vitals( raidPtr, row, column, dev_name, ci_label,\n\t\t\t\t  serial_number, mod_counter )\n\tRF_Raid_t *raidPtr;\n\tint row;\n\tint column;\n\tchar *dev_name;\n\tRF_ComponentLabel_t *ci_label;\n\tint serial_number;\n\tint mod_counter;\n{\n\tint fatal_error = 0;\n\n\tif (serial_number != ci_label->serial_number) {\n\t\tprintf(\"%s has a different serial number: %d %d\\n\", \n\t\t       dev_name, serial_number, ci_label->serial_number);\n\t\tfatal_error = 1;\n\t}\n\tif (mod_counter != ci_label->mod_counter) {\n\t\tprintf(\"%s has a different modfication count: %d %d\\n\",\n\t\t       dev_name, mod_counter, ci_label->mod_counter);\n\t}\n\t\n\tif (row != ci_label->row) {\n\t\tprintf(\"Row out of alignment for: %s\\n\", dev_name); \n\t\tfatal_error = 1;\n\t}\n\tif (column != ci_label->column) {\n\t\tprintf(\"Column out of alignment for: %s\\n\", dev_name);\n\t\tfatal_error = 1;\n\t}\n\tif (raidPtr->numRow != ci_label->num_rows) {\n\t\tprintf(\"Number of rows do not match for: %s\\n\", dev_name);\n\t\tfatal_error = 1;\n\t}\n\tif (raidPtr->numCol != ci_label->num_columns) {\n\t\tprintf(\"Number of columns do not match for: %s\\n\", dev_name);\n\t\tfatal_error = 1;\n\t}\n\tif (ci_label->clean == 0) {\n\t\t/* it's not clean, but that's not fatal */\n\t\tprintf(\"%s is not clean!\\n\", dev_name);\n\t}\n\treturn(fatal_error);\n}"
  },
  {
    "function_name": "rf_print_label_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_disks.c",
    "lines": "428-447",
    "snippet": "static void\nrf_print_label_status( raidPtr, row, column, dev_name, ci_label )\n\tRF_Raid_t *raidPtr;\n\tint row;\n\tint column;\n\tchar *dev_name;\n\tRF_ComponentLabel_t *ci_label;\n{\n\n\tprintf(\"raid%d: Component %s being configured at row: %d col: %d\\n\", \n\t       raidPtr->raidid, dev_name, row, column );\n\tprintf(\"         Row: %d Column: %d Num Rows: %d Num Columns: %d\\n\",\n\t       ci_label->row, ci_label->column, \n\t       ci_label->num_rows, ci_label->num_columns);\n\tprintf(\"         Version: %d Serial Number: %d Mod Counter: %d\\n\",\n\t       ci_label->version, ci_label->serial_number,\n\t       ci_label->mod_counter);\n\tprintf(\"         Clean: %s Status: %d\\n\",\n\t       ci_label->clean ? \"Yes\" : \"No\", ci_label->status );\n}",
    "includes": [
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"rf_kintf.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void rf_UnconfigureVnodes( RF_Raid_t * );",
      "static void rf_print_label_status( RF_Raid_t *, int, int, char *, \n\t\t\t\t  RF_ComponentLabel_t *);",
      "static int rf_check_label_vitals( RF_Raid_t *, int, int, char *, \n\t\t\t\t  RF_ComponentLabel_t *, int, int );"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"         Clean: %s Status: %d\\n\"",
            "ci_label->clean ? \"Yes\" : \"No\"",
            "ci_label->status"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"rf_kintf.h\"\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_utils.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid rf_UnconfigureVnodes( RF_Raid_t * );\nstatic void rf_print_label_status( RF_Raid_t *, int, int, char *, \n\t\t\t\t  RF_ComponentLabel_t *);\nstatic int rf_check_label_vitals( RF_Raid_t *, int, int, char *, \n\t\t\t\t  RF_ComponentLabel_t *, int, int );\n\nstatic void\nrf_print_label_status( raidPtr, row, column, dev_name, ci_label )\n\tRF_Raid_t *raidPtr;\n\tint row;\n\tint column;\n\tchar *dev_name;\n\tRF_ComponentLabel_t *ci_label;\n{\n\n\tprintf(\"raid%d: Component %s being configured at row: %d col: %d\\n\", \n\t       raidPtr->raidid, dev_name, row, column );\n\tprintf(\"         Row: %d Column: %d Num Rows: %d Num Columns: %d\\n\",\n\t       ci_label->row, ci_label->column, \n\t       ci_label->num_rows, ci_label->num_columns);\n\tprintf(\"         Version: %d Serial Number: %d Mod Counter: %d\\n\",\n\t       ci_label->version, ci_label->serial_number,\n\t       ci_label->mod_counter);\n\tprintf(\"         Clean: %s Status: %d\\n\",\n\t       ci_label->clean ? \"Yes\" : \"No\", ci_label->status );\n}"
  },
  {
    "function_name": "rf_ConfigureDisk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_disks.c",
    "lines": "350-423",
    "snippet": "int \nrf_ConfigureDisk(raidPtr, buf, diskPtr, row, col)\n\tRF_Raid_t *raidPtr;\n\tchar   *buf;\n\tRF_RaidDisk_t *diskPtr;\n\tRF_RowCol_t row;\n\tRF_RowCol_t col;\n{\n\tchar   *p;\n\tint     retcode;\n\n\tstruct partinfo dpart;\n\tstruct vnode *vp;\n\tstruct vattr va;\n\tstruct proc *proc;\n\tint     error;\n\n\tretcode = 0;\n\tp = rf_find_non_white(buf);\n\tif (p[strlen(p) - 1] == '\\n') {\n\t\t/* strip off the newline */\n\t\tp[strlen(p) - 1] = '\\0';\n\t}\n\t(void) strcpy(diskPtr->devname, p);\n\n#if 0\n\tproc = raidPtr->engine_thread;\n#else\n\tproc = curproc;\n#endif\n\n\t/* Let's start by claiming the component is fine and well... */\n\tdiskPtr->status = rf_ds_optimal;\n\n\traidPtr->raid_cinfo[row][col].ci_vp = NULL;\n\traidPtr->raid_cinfo[row][col].ci_dev = NULL;\n\n\terror = raidlookup(diskPtr->devname, proc, &vp);\n\tif (error) {\n\t\tprintf(\"raidlookup on device: %s failed!\\n\", diskPtr->devname);\n\t\tif (error == ENXIO) {\n\t\t\t/* the component isn't there... must be dead :-( */\n\t\t\tdiskPtr->status = rf_ds_failed;\n\t\t} else {\n\t\t\treturn (error);\n\t\t}\n\t}\n\tif (diskPtr->status == rf_ds_optimal) {\n\n\t\tif ((error = VOP_GETATTR(vp, &va, proc->p_ucred, proc)) != 0) {\n\t\t\treturn (error);\n\t\t}\n\t\terror = VOP_IOCTL(vp, DIOCGPART, (caddr_t) & dpart,\n\t\t    FREAD, proc->p_ucred, proc);\n\t\tif (error) {\n\t\t\treturn (error);\n\t\t}\n\t\tdiskPtr->blockSize = dpart.disklab->d_secsize;\n\n\t\tdiskPtr->numBlocks = dpart.part->p_size - rf_protectedSectors;\n\n\t\traidPtr->raid_cinfo[row][col].ci_vp = vp;\n\t\traidPtr->raid_cinfo[row][col].ci_dev = va.va_rdev;\n\n\t\tdiskPtr->dev = va.va_rdev;\n\n\t\t/* we allow the user to specify that only a fraction of the\n\t\t * disks should be used this is just for debug:  it speeds up\n\t\t * the parity scan */\n\t\tdiskPtr->numBlocks = diskPtr->numBlocks * \n\t\t\trf_sizePercentage / 100;\n\t}\n\treturn (0);\n}",
    "includes": [
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"rf_kintf.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void rf_UnconfigureVnodes( RF_Raid_t * );"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VOP_IOCTL",
          "args": [
            "vp",
            "DIOCGPART",
            "(caddr_t) & dpart",
            "FREAD",
            "proc->p_ucred",
            "proc"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VOP_GETATTR",
          "args": [
            "vp",
            "&va",
            "proc->p_ucred",
            "proc"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"raidlookup on device: %s failed!\\n\"",
            "diskPtr->devname"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "raidlookup",
          "args": [
            "diskPtr->devname",
            "proc",
            "&vp"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "raidlookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_netbsdkintf.c",
          "lines": "1831-1869",
          "snippet": "int\nraidlookup(path, p, vpp)\n\tchar   *path;\n\tstruct proc *p;\n\tstruct vnode **vpp;\t/* result */\n{\n\tstruct nameidata nd;\n\tstruct vnode *vp;\n\tstruct vattr va;\n\tint     error;\n\n\tNDINIT(&nd, LOOKUP, FOLLOW, UIO_SYSSPACE, path, p);\n\tif ((error = vn_open(&nd, FREAD | FWRITE, 0)) != 0) {\n#ifdef DEBUG\n\t\tprintf(\"RAIDframe: vn_open returned %d\\n\", error);\n#endif\n\t\treturn (error);\n\t}\n\tvp = nd.ni_vp;\n\tif (vp->v_usecount > 1) {\n\t\tVOP_UNLOCK(vp, 0);\n\t\t(void) vn_close(vp, FREAD | FWRITE, p->p_ucred, p);\n\t\treturn (EBUSY);\n\t}\n\tif ((error = VOP_GETATTR(vp, &va, p->p_ucred, p)) != 0) {\n\t\tVOP_UNLOCK(vp, 0);\n\t\t(void) vn_close(vp, FREAD | FWRITE, p->p_ucred, p);\n\t\treturn (error);\n\t}\n\t/* XXX: eventually we should handle VREG, too. */\n\tif (va.va_type != VBLK) {\n\t\tVOP_UNLOCK(vp, 0);\n\t\t(void) vn_close(vp, FREAD | FWRITE, p->p_ucred, p);\n\t\treturn (ENOTBLK);\n\t}\n\tVOP_UNLOCK(vp, 0);\n\t*vpp = vp;\n\treturn (0);\n}",
          "includes": [
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_dagflags.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_raidframe.h\"",
            "#include \"rf_raid.h\"",
            "#include \"raid.h\"",
            "#include <sys/user.h>",
            "#include <sys/buf.h>",
            "#include <sys/lock.h>",
            "#include <sys/conf.h>",
            "#include <sys/disklabel.h>",
            "#include <machine/types.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/vnode.h>",
            "#include <sys/namei.h>",
            "#include <sys/systm.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/device.h>",
            "#include <sys/disk.h>",
            "#include <sys/queue.h>",
            "#include <sys/pool.h>",
            "#include <sys/param.h>",
            "#include <sys/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/disklabel.h>\n#include <machine/types.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/vnode.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/pool.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\nint\nraidlookup(path, p, vpp)\n\tchar   *path;\n\tstruct proc *p;\n\tstruct vnode **vpp;\t/* result */\n{\n\tstruct nameidata nd;\n\tstruct vnode *vp;\n\tstruct vattr va;\n\tint     error;\n\n\tNDINIT(&nd, LOOKUP, FOLLOW, UIO_SYSSPACE, path, p);\n\tif ((error = vn_open(&nd, FREAD | FWRITE, 0)) != 0) {\n#ifdef DEBUG\n\t\tprintf(\"RAIDframe: vn_open returned %d\\n\", error);\n#endif\n\t\treturn (error);\n\t}\n\tvp = nd.ni_vp;\n\tif (vp->v_usecount > 1) {\n\t\tVOP_UNLOCK(vp, 0);\n\t\t(void) vn_close(vp, FREAD | FWRITE, p->p_ucred, p);\n\t\treturn (EBUSY);\n\t}\n\tif ((error = VOP_GETATTR(vp, &va, p->p_ucred, p)) != 0) {\n\t\tVOP_UNLOCK(vp, 0);\n\t\t(void) vn_close(vp, FREAD | FWRITE, p->p_ucred, p);\n\t\treturn (error);\n\t}\n\t/* XXX: eventually we should handle VREG, too. */\n\tif (va.va_type != VBLK) {\n\t\tVOP_UNLOCK(vp, 0);\n\t\t(void) vn_close(vp, FREAD | FWRITE, p->p_ucred, p);\n\t\treturn (ENOTBLK);\n\t}\n\tVOP_UNLOCK(vp, 0);\n\t*vpp = vp;\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "diskPtr->devname",
            "p"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "p"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "p"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_find_non_white",
          "args": [
            "buf"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "rf_find_non_white",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_strutils.c",
          "lines": "44-49",
          "snippet": "char   *\nrf_find_non_white(char *p)\n{\n\tfor (; *p != '\\0' && (*p == ' ' || *p == '\\t'); p++);\n\treturn (p);\n}",
          "includes": [
            "#include \"rf_utils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_utils.h\"\n\nchar   *\nrf_find_non_white(char *p)\n{\n\tfor (; *p != '\\0' && (*p == ' ' || *p == '\\t'); p++);\n\treturn (p);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"rf_kintf.h\"\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_utils.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid rf_UnconfigureVnodes( RF_Raid_t * );\n\nint \nrf_ConfigureDisk(raidPtr, buf, diskPtr, row, col)\n\tRF_Raid_t *raidPtr;\n\tchar   *buf;\n\tRF_RaidDisk_t *diskPtr;\n\tRF_RowCol_t row;\n\tRF_RowCol_t col;\n{\n\tchar   *p;\n\tint     retcode;\n\n\tstruct partinfo dpart;\n\tstruct vnode *vp;\n\tstruct vattr va;\n\tstruct proc *proc;\n\tint     error;\n\n\tretcode = 0;\n\tp = rf_find_non_white(buf);\n\tif (p[strlen(p) - 1] == '\\n') {\n\t\t/* strip off the newline */\n\t\tp[strlen(p) - 1] = '\\0';\n\t}\n\t(void) strcpy(diskPtr->devname, p);\n\n#if 0\n\tproc = raidPtr->engine_thread;\n#else\n\tproc = curproc;\n#endif\n\n\t/* Let's start by claiming the component is fine and well... */\n\tdiskPtr->status = rf_ds_optimal;\n\n\traidPtr->raid_cinfo[row][col].ci_vp = NULL;\n\traidPtr->raid_cinfo[row][col].ci_dev = NULL;\n\n\terror = raidlookup(diskPtr->devname, proc, &vp);\n\tif (error) {\n\t\tprintf(\"raidlookup on device: %s failed!\\n\", diskPtr->devname);\n\t\tif (error == ENXIO) {\n\t\t\t/* the component isn't there... must be dead :-( */\n\t\t\tdiskPtr->status = rf_ds_failed;\n\t\t} else {\n\t\t\treturn (error);\n\t\t}\n\t}\n\tif (diskPtr->status == rf_ds_optimal) {\n\n\t\tif ((error = VOP_GETATTR(vp, &va, proc->p_ucred, proc)) != 0) {\n\t\t\treturn (error);\n\t\t}\n\t\terror = VOP_IOCTL(vp, DIOCGPART, (caddr_t) & dpart,\n\t\t    FREAD, proc->p_ucred, proc);\n\t\tif (error) {\n\t\t\treturn (error);\n\t\t}\n\t\tdiskPtr->blockSize = dpart.disklab->d_secsize;\n\n\t\tdiskPtr->numBlocks = dpart.part->p_size - rf_protectedSectors;\n\n\t\traidPtr->raid_cinfo[row][col].ci_vp = vp;\n\t\traidPtr->raid_cinfo[row][col].ci_dev = va.va_rdev;\n\n\t\tdiskPtr->dev = va.va_rdev;\n\n\t\t/* we allow the user to specify that only a fraction of the\n\t\t * disks should be used this is just for debug:  it speeds up\n\t\t * the parity scan */\n\t\tdiskPtr->numBlocks = diskPtr->numBlocks * \n\t\t\trf_sizePercentage / 100;\n\t}\n\treturn (0);\n}"
  },
  {
    "function_name": "rf_ConfigureSpareDisks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_disks.c",
    "lines": "269-345",
    "snippet": "int \nrf_ConfigureSpareDisks( listp, raidPtr, cfgPtr )\n\tRF_ShutdownList_t ** listp;\n\tRF_Raid_t * raidPtr;\n\tRF_Config_t * cfgPtr;\n{\n\tint     i, ret;\n\tunsigned int bs;\n\tRF_RaidDisk_t *disks;\n\tint     num_spares_done;\n\n\tnum_spares_done = 0;\n\n\t/* The space for the spares should have already been allocated by\n\t * ConfigureDisks() */\n\n\tdisks = &raidPtr->Disks[0][raidPtr->numCol];\n\tfor (i = 0; i < raidPtr->numSpare; i++) {\n\t\tret = rf_ConfigureDisk(raidPtr, &cfgPtr->spare_names[i][0],\n\t\t\t\t       &disks[i], 0, raidPtr->numCol + i);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t\tif (disks[i].status != rf_ds_optimal) {\n\t\t\tRF_ERRORMSG1(\"Warning: spare disk %s failed TUR\\n\", \n\t\t\t\t     &cfgPtr->spare_names[i][0]);\n\t\t} else {\n\t\t\tdisks[i].status = rf_ds_spare;\t/* change status to\n\t\t\t\t\t\t\t * spare */\n\t\t\tDPRINTF6(\"Spare Disk %d: dev %s numBlocks %ld blockSize %d (%ld MB)\\n\", i,\n\t\t\t    disks[i].devname,\n\t\t\t    (long int) disks[i].numBlocks, disks[i].blockSize,\n\t\t\t    (long int) disks[i].numBlocks * \n\t\t\t\t disks[i].blockSize / 1024 / 1024);\n\t\t}\n\t\tnum_spares_done++;\n\t}\n\n\t/* check sizes and block sizes on spare disks */\n\tbs = 1 << raidPtr->logBytesPerSector;\n\tfor (i = 0; i < raidPtr->numSpare; i++) {\n\t\tif (disks[i].blockSize != bs) {\n\t\t\tRF_ERRORMSG3(\"Block size of %d on spare disk %s is not the same as on other disks (%d)\\n\", disks[i].blockSize, disks[i].devname, bs);\n\t\t\tret = EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\t\tif (disks[i].numBlocks < raidPtr->sectorsPerDisk) {\n\t\t\tRF_ERRORMSG3(\"Spare disk %s (%d blocks) is too small to serve as a spare (need %ld blocks)\\n\",\n\t\t\t\t     disks[i].devname, disks[i].blockSize, \n\t\t\t\t     (long int) raidPtr->sectorsPerDisk);\n\t\t\tret = EINVAL;\n\t\t\tgoto fail;\n\t\t} else\n\t\t\tif (disks[i].numBlocks > raidPtr->sectorsPerDisk) {\n\t\t\t\tRF_ERRORMSG2(\"Warning: truncating spare disk %s to %ld blocks\\n\", disks[i].devname, (long int) raidPtr->sectorsPerDisk);\n\n\t\t\t\tdisks[i].numBlocks = raidPtr->sectorsPerDisk;\n\t\t\t}\n\t}\n\n\treturn (0);\n\nfail:\n\n\t/* Release the hold on the main components.  We've failed to allocate\n\t * a spare, and since we're failing, we need to free things.. \n\n\t XXX failing to allocate a spare is *not* that big of a deal... \n\t We *can* survive without it, if need be, esp. if we get hot\n\t adding working.  \n\t If we don't fail out here, then we need a way to remove this spare... \n\t that should be easier to do here than if we are \"live\"... \n\t */\n\n\trf_UnconfigureVnodes( raidPtr );\n\n\treturn (ret);\n}",
    "includes": [
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"rf_kintf.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void rf_UnconfigureVnodes( RF_Raid_t * );",
      "int rf_CheckLabels( RF_Raid_t *, RF_Config_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_UnconfigureVnodes",
          "args": [
            "raidPtr"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "rf_UnconfigureVnodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_driver.c",
          "lines": "284-320",
          "snippet": "void\nrf_UnconfigureVnodes( raidPtr )\n\tRF_Raid_t *raidPtr;\n{\n\tint r,c; \n\tstruct proc *p;\n\n\t/* We take this opportunity to close the vnodes like we should.. */\n\n\tp = raidPtr->engine_thread;\n\n\tfor (r = 0; r < raidPtr->numRow; r++) {\n\t\tfor (c = 0; c < raidPtr->numCol; c++) {\n\t\t\tprintf(\"Closing vnode for row: %d col: %d\\n\", r, c);\n\t\t\tif (raidPtr->raid_cinfo[r][c].ci_vp) {\n\t\t\t\tVOP_UNLOCK(raidPtr->raid_cinfo[r][c].ci_vp, 0, p);\n \t\t\t\t(void) vn_close(raidPtr->raid_cinfo[r][c].ci_vp,\n \t\t\t\t    FREAD | FWRITE, p->p_ucred, p);\n\t\t\t\traidPtr->raid_cinfo[r][c].ci_vp = NULL;\n\t\t\t} else {\n\t\t\t\tprintf(\"vnode was NULL\\n\");\n\t\t\t}\n\n\t\t}\n\t}\n\tfor (r = 0; r < raidPtr->numSpare; r++) {\n\t\tprintf(\"Closing vnode for spare: %d\\n\", r);\n\t\tif (raidPtr->raid_cinfo[0][raidPtr->numCol + r].ci_vp) {\n\t\t\tVOP_UNLOCK(raidPtr->raid_cinfo[0][raidPtr->numCol + r].ci_vp, 0, p);\n\t\t\t(void) vn_close(raidPtr->raid_cinfo[0][raidPtr->numCol + r].ci_vp,\n\t\t\t    FREAD | FWRITE, p->p_ucred, p);\n\t\t\traidPtr->raid_cinfo[0][raidPtr->numCol + r].ci_vp = NULL;\n\t\t} else {\n\t\t\tprintf(\"vnode was NULL\\n\");\n\t\t}\n\t}\n}",
          "includes": [
            "#include <sys/buf.h>",
            "#include \"rf_kintf.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_nwayxor.h\"",
            "#include \"rf_mcpair.h\"",
            "#include \"rf_memchunk.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_callback.h\"",
            "#include \"rf_revent.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_decluster.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_states.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_aselect.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include <sys/errno.h>",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_archs.h\"",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rf_UnconfigureVnodes( RF_Raid_t * );"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_options.h\"\n#include \"rf_driver.h\"\n#include \"rf_copyback.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_nwayxor.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_memchunk.h\"\n#include \"rf_engine.h\"\n#include \"rf_callback.h\"\n#include \"rf_revent.h\"\n#include \"rf_map.h\"\n#include \"rf_decluster.h\"\n#include \"rf_freelist.h\"\n#include \"rf_states.h\"\n#include \"rf_desc.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_utils.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_aselect.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n#include \"rf_archs.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid rf_UnconfigureVnodes( RF_Raid_t * );\n\nvoid\nrf_UnconfigureVnodes( raidPtr )\n\tRF_Raid_t *raidPtr;\n{\n\tint r,c; \n\tstruct proc *p;\n\n\t/* We take this opportunity to close the vnodes like we should.. */\n\n\tp = raidPtr->engine_thread;\n\n\tfor (r = 0; r < raidPtr->numRow; r++) {\n\t\tfor (c = 0; c < raidPtr->numCol; c++) {\n\t\t\tprintf(\"Closing vnode for row: %d col: %d\\n\", r, c);\n\t\t\tif (raidPtr->raid_cinfo[r][c].ci_vp) {\n\t\t\t\tVOP_UNLOCK(raidPtr->raid_cinfo[r][c].ci_vp, 0, p);\n \t\t\t\t(void) vn_close(raidPtr->raid_cinfo[r][c].ci_vp,\n \t\t\t\t    FREAD | FWRITE, p->p_ucred, p);\n\t\t\t\traidPtr->raid_cinfo[r][c].ci_vp = NULL;\n\t\t\t} else {\n\t\t\t\tprintf(\"vnode was NULL\\n\");\n\t\t\t}\n\n\t\t}\n\t}\n\tfor (r = 0; r < raidPtr->numSpare; r++) {\n\t\tprintf(\"Closing vnode for spare: %d\\n\", r);\n\t\tif (raidPtr->raid_cinfo[0][raidPtr->numCol + r].ci_vp) {\n\t\t\tVOP_UNLOCK(raidPtr->raid_cinfo[0][raidPtr->numCol + r].ci_vp, 0, p);\n\t\t\t(void) vn_close(raidPtr->raid_cinfo[0][raidPtr->numCol + r].ci_vp,\n\t\t\t    FREAD | FWRITE, p->p_ucred, p);\n\t\t\traidPtr->raid_cinfo[0][raidPtr->numCol + r].ci_vp = NULL;\n\t\t} else {\n\t\t\tprintf(\"vnode was NULL\\n\");\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG2",
          "args": [
            "\"Warning: truncating spare disk %s to %ld blocks\\n\"",
            "disks[i].devname",
            "(long int) raidPtr->sectorsPerDisk"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG3",
          "args": [
            "\"Spare disk %s (%d blocks) is too small to serve as a spare (need %ld blocks)\\n\"",
            "disks[i].devname",
            "disks[i].blockSize",
            "(long int) raidPtr->sectorsPerDisk"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG3",
          "args": [
            "\"Block size of %d on spare disk %s is not the same as on other disks (%d)\\n\"",
            "disks[i].blockSize",
            "disks[i].devname",
            "bs"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF6",
          "args": [
            "\"Spare Disk %d: dev %s numBlocks %ld blockSize %d (%ld MB)\\n\"",
            "i",
            "disks[i].devname",
            "(long int) disks[i].numBlocks",
            "disks[i].blockSize",
            "(long int) disks[i].numBlocks * \n\t\t\t\t disks[i].blockSize / 1024 / 1024"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG1",
          "args": [
            "\"Warning: spare disk %s failed TUR\\n\"",
            "&cfgPtr->spare_names[i][0]"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_ConfigureDisk",
          "args": [
            "raidPtr",
            "&cfgPtr->spare_names[i][0]",
            "&disks[i]",
            "0",
            "raidPtr->numCol + i"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "rf_ConfigureDisk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_disks.c",
          "lines": "350-423",
          "snippet": "int \nrf_ConfigureDisk(raidPtr, buf, diskPtr, row, col)\n\tRF_Raid_t *raidPtr;\n\tchar   *buf;\n\tRF_RaidDisk_t *diskPtr;\n\tRF_RowCol_t row;\n\tRF_RowCol_t col;\n{\n\tchar   *p;\n\tint     retcode;\n\n\tstruct partinfo dpart;\n\tstruct vnode *vp;\n\tstruct vattr va;\n\tstruct proc *proc;\n\tint     error;\n\n\tretcode = 0;\n\tp = rf_find_non_white(buf);\n\tif (p[strlen(p) - 1] == '\\n') {\n\t\t/* strip off the newline */\n\t\tp[strlen(p) - 1] = '\\0';\n\t}\n\t(void) strcpy(diskPtr->devname, p);\n\n#if 0\n\tproc = raidPtr->engine_thread;\n#else\n\tproc = curproc;\n#endif\n\n\t/* Let's start by claiming the component is fine and well... */\n\tdiskPtr->status = rf_ds_optimal;\n\n\traidPtr->raid_cinfo[row][col].ci_vp = NULL;\n\traidPtr->raid_cinfo[row][col].ci_dev = NULL;\n\n\terror = raidlookup(diskPtr->devname, proc, &vp);\n\tif (error) {\n\t\tprintf(\"raidlookup on device: %s failed!\\n\", diskPtr->devname);\n\t\tif (error == ENXIO) {\n\t\t\t/* the component isn't there... must be dead :-( */\n\t\t\tdiskPtr->status = rf_ds_failed;\n\t\t} else {\n\t\t\treturn (error);\n\t\t}\n\t}\n\tif (diskPtr->status == rf_ds_optimal) {\n\n\t\tif ((error = VOP_GETATTR(vp, &va, proc->p_ucred, proc)) != 0) {\n\t\t\treturn (error);\n\t\t}\n\t\terror = VOP_IOCTL(vp, DIOCGPART, (caddr_t) & dpart,\n\t\t    FREAD, proc->p_ucred, proc);\n\t\tif (error) {\n\t\t\treturn (error);\n\t\t}\n\t\tdiskPtr->blockSize = dpart.disklab->d_secsize;\n\n\t\tdiskPtr->numBlocks = dpart.part->p_size - rf_protectedSectors;\n\n\t\traidPtr->raid_cinfo[row][col].ci_vp = vp;\n\t\traidPtr->raid_cinfo[row][col].ci_dev = va.va_rdev;\n\n\t\tdiskPtr->dev = va.va_rdev;\n\n\t\t/* we allow the user to specify that only a fraction of the\n\t\t * disks should be used this is just for debug:  it speeds up\n\t\t * the parity scan */\n\t\tdiskPtr->numBlocks = diskPtr->numBlocks * \n\t\t\trf_sizePercentage / 100;\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"rf_kintf.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void rf_UnconfigureVnodes( RF_Raid_t * );"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"rf_kintf.h\"\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_utils.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid rf_UnconfigureVnodes( RF_Raid_t * );\n\nint \nrf_ConfigureDisk(raidPtr, buf, diskPtr, row, col)\n\tRF_Raid_t *raidPtr;\n\tchar   *buf;\n\tRF_RaidDisk_t *diskPtr;\n\tRF_RowCol_t row;\n\tRF_RowCol_t col;\n{\n\tchar   *p;\n\tint     retcode;\n\n\tstruct partinfo dpart;\n\tstruct vnode *vp;\n\tstruct vattr va;\n\tstruct proc *proc;\n\tint     error;\n\n\tretcode = 0;\n\tp = rf_find_non_white(buf);\n\tif (p[strlen(p) - 1] == '\\n') {\n\t\t/* strip off the newline */\n\t\tp[strlen(p) - 1] = '\\0';\n\t}\n\t(void) strcpy(diskPtr->devname, p);\n\n#if 0\n\tproc = raidPtr->engine_thread;\n#else\n\tproc = curproc;\n#endif\n\n\t/* Let's start by claiming the component is fine and well... */\n\tdiskPtr->status = rf_ds_optimal;\n\n\traidPtr->raid_cinfo[row][col].ci_vp = NULL;\n\traidPtr->raid_cinfo[row][col].ci_dev = NULL;\n\n\terror = raidlookup(diskPtr->devname, proc, &vp);\n\tif (error) {\n\t\tprintf(\"raidlookup on device: %s failed!\\n\", diskPtr->devname);\n\t\tif (error == ENXIO) {\n\t\t\t/* the component isn't there... must be dead :-( */\n\t\t\tdiskPtr->status = rf_ds_failed;\n\t\t} else {\n\t\t\treturn (error);\n\t\t}\n\t}\n\tif (diskPtr->status == rf_ds_optimal) {\n\n\t\tif ((error = VOP_GETATTR(vp, &va, proc->p_ucred, proc)) != 0) {\n\t\t\treturn (error);\n\t\t}\n\t\terror = VOP_IOCTL(vp, DIOCGPART, (caddr_t) & dpart,\n\t\t    FREAD, proc->p_ucred, proc);\n\t\tif (error) {\n\t\t\treturn (error);\n\t\t}\n\t\tdiskPtr->blockSize = dpart.disklab->d_secsize;\n\n\t\tdiskPtr->numBlocks = dpart.part->p_size - rf_protectedSectors;\n\n\t\traidPtr->raid_cinfo[row][col].ci_vp = vp;\n\t\traidPtr->raid_cinfo[row][col].ci_dev = va.va_rdev;\n\n\t\tdiskPtr->dev = va.va_rdev;\n\n\t\t/* we allow the user to specify that only a fraction of the\n\t\t * disks should be used this is just for debug:  it speeds up\n\t\t * the parity scan */\n\t\tdiskPtr->numBlocks = diskPtr->numBlocks * \n\t\t\trf_sizePercentage / 100;\n\t}\n\treturn (0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"rf_kintf.h\"\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_utils.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid rf_UnconfigureVnodes( RF_Raid_t * );\nint rf_CheckLabels( RF_Raid_t *, RF_Config_t *);\n\nint \nrf_ConfigureSpareDisks( listp, raidPtr, cfgPtr )\n\tRF_ShutdownList_t ** listp;\n\tRF_Raid_t * raidPtr;\n\tRF_Config_t * cfgPtr;\n{\n\tint     i, ret;\n\tunsigned int bs;\n\tRF_RaidDisk_t *disks;\n\tint     num_spares_done;\n\n\tnum_spares_done = 0;\n\n\t/* The space for the spares should have already been allocated by\n\t * ConfigureDisks() */\n\n\tdisks = &raidPtr->Disks[0][raidPtr->numCol];\n\tfor (i = 0; i < raidPtr->numSpare; i++) {\n\t\tret = rf_ConfigureDisk(raidPtr, &cfgPtr->spare_names[i][0],\n\t\t\t\t       &disks[i], 0, raidPtr->numCol + i);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t\tif (disks[i].status != rf_ds_optimal) {\n\t\t\tRF_ERRORMSG1(\"Warning: spare disk %s failed TUR\\n\", \n\t\t\t\t     &cfgPtr->spare_names[i][0]);\n\t\t} else {\n\t\t\tdisks[i].status = rf_ds_spare;\t/* change status to\n\t\t\t\t\t\t\t * spare */\n\t\t\tDPRINTF6(\"Spare Disk %d: dev %s numBlocks %ld blockSize %d (%ld MB)\\n\", i,\n\t\t\t    disks[i].devname,\n\t\t\t    (long int) disks[i].numBlocks, disks[i].blockSize,\n\t\t\t    (long int) disks[i].numBlocks * \n\t\t\t\t disks[i].blockSize / 1024 / 1024);\n\t\t}\n\t\tnum_spares_done++;\n\t}\n\n\t/* check sizes and block sizes on spare disks */\n\tbs = 1 << raidPtr->logBytesPerSector;\n\tfor (i = 0; i < raidPtr->numSpare; i++) {\n\t\tif (disks[i].blockSize != bs) {\n\t\t\tRF_ERRORMSG3(\"Block size of %d on spare disk %s is not the same as on other disks (%d)\\n\", disks[i].blockSize, disks[i].devname, bs);\n\t\t\tret = EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\t\tif (disks[i].numBlocks < raidPtr->sectorsPerDisk) {\n\t\t\tRF_ERRORMSG3(\"Spare disk %s (%d blocks) is too small to serve as a spare (need %ld blocks)\\n\",\n\t\t\t\t     disks[i].devname, disks[i].blockSize, \n\t\t\t\t     (long int) raidPtr->sectorsPerDisk);\n\t\t\tret = EINVAL;\n\t\t\tgoto fail;\n\t\t} else\n\t\t\tif (disks[i].numBlocks > raidPtr->sectorsPerDisk) {\n\t\t\t\tRF_ERRORMSG2(\"Warning: truncating spare disk %s to %ld blocks\\n\", disks[i].devname, (long int) raidPtr->sectorsPerDisk);\n\n\t\t\t\tdisks[i].numBlocks = raidPtr->sectorsPerDisk;\n\t\t\t}\n\t}\n\n\treturn (0);\n\nfail:\n\n\t/* Release the hold on the main components.  We've failed to allocate\n\t * a spare, and since we're failing, we need to free things.. \n\n\t XXX failing to allocate a spare is *not* that big of a deal... \n\t We *can* survive without it, if need be, esp. if we get hot\n\t adding working.  \n\t If we don't fail out here, then we need a way to remove this spare... \n\t that should be easier to do here than if we are \"live\"... \n\t */\n\n\trf_UnconfigureVnodes( raidPtr );\n\n\treturn (ret);\n}"
  },
  {
    "function_name": "rf_ConfigureDisks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_disks.c",
    "lines": "108-261",
    "snippet": "int \nrf_ConfigureDisks( listp, raidPtr, cfgPtr )\n\tRF_ShutdownList_t **listp;\n\tRF_Raid_t *raidPtr;\n\tRF_Config_t *cfgPtr;\n{\n\tRF_RaidDisk_t **disks;\n\tRF_SectorCount_t min_numblks = (RF_SectorCount_t) 0x7FFFFFFFFFFFLL;\n\tRF_RowCol_t r, c;\n\tint     bs, ret;\n\tunsigned i, count, foundone = 0, numFailuresThisRow;\n\tint     num_rows_done, num_cols_done;\n\tint\tforce;\n\n\tnum_rows_done = 0;\n\tnum_cols_done = 0;\n\tforce = cfgPtr->force;\n \n\tRF_CallocAndAdd(disks, raidPtr->numRow, sizeof(RF_RaidDisk_t *), \n\t\t\t(RF_RaidDisk_t **), raidPtr->cleanupList);\n\tif (disks == NULL) {\n\t\tret = ENOMEM;\n\t\tgoto fail;\n\t}\n\traidPtr->Disks = disks;\n\n\t/* get space for the device-specific stuff... */\n\tRF_CallocAndAdd(raidPtr->raid_cinfo, raidPtr->numRow,\n\t    sizeof(struct raidcinfo *), (struct raidcinfo **),\n\t    raidPtr->cleanupList);\n\tif (raidPtr->raid_cinfo == NULL) {\n\t\tret = ENOMEM;\n\t\tgoto fail;\n\t}\n\tfor (r = 0; r < raidPtr->numRow; r++) {\n\t\tnumFailuresThisRow = 0;\n\t\t/* We allocate RF_MAXSPARE on the first row so that we\n\t\t   have room to do hot-swapping of spares */\n\t\tRF_CallocAndAdd(disks[r], raidPtr->numCol \n\t\t\t\t+ ((r == 0) ? RF_MAXSPARE : 0), \n\t\t\t\tsizeof(RF_RaidDisk_t), (RF_RaidDisk_t *), \n\t\t\t\traidPtr->cleanupList);\n\t\tif (disks[r] == NULL) {\n\t\t\tret = ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\t\t/* get more space for device specific stuff.. */\n\t\tRF_CallocAndAdd(raidPtr->raid_cinfo[r],\n\t\t    raidPtr->numCol + ((r == 0) ? raidPtr->numSpare : 0),\n\t\t    sizeof(struct raidcinfo), (struct raidcinfo *),\n\t\t    raidPtr->cleanupList);\n\t\tif (raidPtr->raid_cinfo[r] == NULL) {\n\t\t\tret = ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\t\tfor (c = 0; c < raidPtr->numCol; c++) {\n\t\t\tret = rf_ConfigureDisk(raidPtr, \n\t\t\t\t\t       &cfgPtr->devnames[r][c][0],\n\t\t\t\t\t       &disks[r][c], r, c);\n\t\t\tif (ret)\n\t\t\t\tgoto fail;\n\n\t\t\tif (disks[r][c].status == rf_ds_optimal) {\n\t\t\t\traidread_component_label(\n\t\t\t\t\t raidPtr->raid_cinfo[r][c].ci_dev,\n\t\t\t\t\t raidPtr->raid_cinfo[r][c].ci_vp,\n\t\t\t\t\t &raidPtr->raid_cinfo[r][c].ci_label);\n\t\t\t}\n\n\t\t\tif (disks[r][c].status != rf_ds_optimal) {\n\t\t\t\tnumFailuresThisRow++;\n\t\t\t} else {\n\t\t\t\tif (disks[r][c].numBlocks < min_numblks)\n\t\t\t\t\tmin_numblks = disks[r][c].numBlocks;\n\t\t\t\tDPRINTF7(\"Disk at row %d col %d: dev %s numBlocks %ld blockSize %d (%ld MB)\\n\",\n\t\t\t\t    r, c, disks[r][c].devname,\n\t\t\t\t    (long int) disks[r][c].numBlocks,\n\t\t\t\t    disks[r][c].blockSize,\n\t\t\t\t    (long int) disks[r][c].numBlocks *\n\t\t\t\t\t disks[r][c].blockSize / 1024 / 1024);\n\t\t\t}\n\t\t\tnum_cols_done++;\n\t\t}\n\t\t/* XXX fix for n-fault tolerant */\n\t\t/* XXX this should probably check to see how many failures\n\t\t   we can handle for this configuration! */\n\t\tif (numFailuresThisRow > 0)\n\t\t\traidPtr->status[r] = rf_rs_degraded;\n\t\tnum_rows_done++;\n\t}\n\t/* all disks must be the same size & have the same block size, bs must\n\t * be a power of 2 */\n\tbs = 0;\n\tfor (foundone = r = 0; !foundone && r < raidPtr->numRow; r++) {\n\t\tfor (c = 0; !foundone && c < raidPtr->numCol; c++) {\n\t\t\tif (disks[r][c].status == rf_ds_optimal) {\n\t\t\t\tbs = disks[r][c].blockSize;\n\t\t\t\tfoundone = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (!foundone) {\n\t\tRF_ERRORMSG(\"RAIDFRAME: Did not find any live disks in the array.\\n\");\n\t\tret = EINVAL;\n\t\tgoto fail;\n\t}\n\tfor (count = 0, i = 1; i; i <<= 1)\n\t\tif (bs & i)\n\t\t\tcount++;\n\tif (count != 1) {\n\t\tRF_ERRORMSG1(\"Error: block size on disks (%d) must be a power of 2\\n\", bs);\n\t\tret = EINVAL;\n\t\tgoto fail;\n\t}\n\n\tif (rf_CheckLabels( raidPtr, cfgPtr )) {\n\t\tprintf(\"raid%d: There were fatal errors\\n\", raidPtr->raidid);\n\t\tif (force != 0) {\n\t\t\tprintf(\"raid%d: Fatal errors being ignored.\\n\",\n\t\t\t       raidPtr->raidid);\n\t\t} else {\n\t\t\tret = EINVAL;\n\t\t\tgoto fail;\n\t\t} \n\t}\n\n\tfor (r = 0; r < raidPtr->numRow; r++) {\n\t\tfor (c = 0; c < raidPtr->numCol; c++) {\n\t\t\tif (disks[r][c].status == rf_ds_optimal) {\n\t\t\t\tif (disks[r][c].blockSize != bs) {\n\t\t\t\t\tRF_ERRORMSG2(\"Error: block size of disk at r %d c %d different from disk at r 0 c 0\\n\", r, c);\n\t\t\t\t\tret = EINVAL;\n\t\t\t\t\tgoto fail;\n\t\t\t\t}\n\t\t\t\tif (disks[r][c].numBlocks != min_numblks) {\n\t\t\t\t\tRF_ERRORMSG3(\"WARNING: truncating disk at r %d c %d to %d blocks\\n\",\n\t\t\t\t\t    r, c, (int) min_numblks);\n\t\t\t\t\tdisks[r][c].numBlocks = min_numblks;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\traidPtr->sectorsPerDisk = min_numblks;\n\traidPtr->logBytesPerSector = ffs(bs) - 1;\n\traidPtr->bytesPerSector = bs;\n\traidPtr->sectorMask = bs - 1;\n\treturn (0);\n\nfail:\n\trf_UnconfigureVnodes( raidPtr );\n\n\treturn (ret);\n}",
    "includes": [
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"rf_kintf.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void rf_UnconfigureVnodes( RF_Raid_t * );",
      "int rf_CheckLabels( RF_Raid_t *, RF_Config_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_UnconfigureVnodes",
          "args": [
            "raidPtr"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "rf_UnconfigureVnodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_driver.c",
          "lines": "284-320",
          "snippet": "void\nrf_UnconfigureVnodes( raidPtr )\n\tRF_Raid_t *raidPtr;\n{\n\tint r,c; \n\tstruct proc *p;\n\n\t/* We take this opportunity to close the vnodes like we should.. */\n\n\tp = raidPtr->engine_thread;\n\n\tfor (r = 0; r < raidPtr->numRow; r++) {\n\t\tfor (c = 0; c < raidPtr->numCol; c++) {\n\t\t\tprintf(\"Closing vnode for row: %d col: %d\\n\", r, c);\n\t\t\tif (raidPtr->raid_cinfo[r][c].ci_vp) {\n\t\t\t\tVOP_UNLOCK(raidPtr->raid_cinfo[r][c].ci_vp, 0, p);\n \t\t\t\t(void) vn_close(raidPtr->raid_cinfo[r][c].ci_vp,\n \t\t\t\t    FREAD | FWRITE, p->p_ucred, p);\n\t\t\t\traidPtr->raid_cinfo[r][c].ci_vp = NULL;\n\t\t\t} else {\n\t\t\t\tprintf(\"vnode was NULL\\n\");\n\t\t\t}\n\n\t\t}\n\t}\n\tfor (r = 0; r < raidPtr->numSpare; r++) {\n\t\tprintf(\"Closing vnode for spare: %d\\n\", r);\n\t\tif (raidPtr->raid_cinfo[0][raidPtr->numCol + r].ci_vp) {\n\t\t\tVOP_UNLOCK(raidPtr->raid_cinfo[0][raidPtr->numCol + r].ci_vp, 0, p);\n\t\t\t(void) vn_close(raidPtr->raid_cinfo[0][raidPtr->numCol + r].ci_vp,\n\t\t\t    FREAD | FWRITE, p->p_ucred, p);\n\t\t\traidPtr->raid_cinfo[0][raidPtr->numCol + r].ci_vp = NULL;\n\t\t} else {\n\t\t\tprintf(\"vnode was NULL\\n\");\n\t\t}\n\t}\n}",
          "includes": [
            "#include <sys/buf.h>",
            "#include \"rf_kintf.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_nwayxor.h\"",
            "#include \"rf_mcpair.h\"",
            "#include \"rf_memchunk.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_callback.h\"",
            "#include \"rf_revent.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_decluster.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_states.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_aselect.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include <sys/errno.h>",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_archs.h\"",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rf_UnconfigureVnodes( RF_Raid_t * );"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_options.h\"\n#include \"rf_driver.h\"\n#include \"rf_copyback.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_nwayxor.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_memchunk.h\"\n#include \"rf_engine.h\"\n#include \"rf_callback.h\"\n#include \"rf_revent.h\"\n#include \"rf_map.h\"\n#include \"rf_decluster.h\"\n#include \"rf_freelist.h\"\n#include \"rf_states.h\"\n#include \"rf_desc.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_utils.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_aselect.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n#include \"rf_archs.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid rf_UnconfigureVnodes( RF_Raid_t * );\n\nvoid\nrf_UnconfigureVnodes( raidPtr )\n\tRF_Raid_t *raidPtr;\n{\n\tint r,c; \n\tstruct proc *p;\n\n\t/* We take this opportunity to close the vnodes like we should.. */\n\n\tp = raidPtr->engine_thread;\n\n\tfor (r = 0; r < raidPtr->numRow; r++) {\n\t\tfor (c = 0; c < raidPtr->numCol; c++) {\n\t\t\tprintf(\"Closing vnode for row: %d col: %d\\n\", r, c);\n\t\t\tif (raidPtr->raid_cinfo[r][c].ci_vp) {\n\t\t\t\tVOP_UNLOCK(raidPtr->raid_cinfo[r][c].ci_vp, 0, p);\n \t\t\t\t(void) vn_close(raidPtr->raid_cinfo[r][c].ci_vp,\n \t\t\t\t    FREAD | FWRITE, p->p_ucred, p);\n\t\t\t\traidPtr->raid_cinfo[r][c].ci_vp = NULL;\n\t\t\t} else {\n\t\t\t\tprintf(\"vnode was NULL\\n\");\n\t\t\t}\n\n\t\t}\n\t}\n\tfor (r = 0; r < raidPtr->numSpare; r++) {\n\t\tprintf(\"Closing vnode for spare: %d\\n\", r);\n\t\tif (raidPtr->raid_cinfo[0][raidPtr->numCol + r].ci_vp) {\n\t\t\tVOP_UNLOCK(raidPtr->raid_cinfo[0][raidPtr->numCol + r].ci_vp, 0, p);\n\t\t\t(void) vn_close(raidPtr->raid_cinfo[0][raidPtr->numCol + r].ci_vp,\n\t\t\t    FREAD | FWRITE, p->p_ucred, p);\n\t\t\traidPtr->raid_cinfo[0][raidPtr->numCol + r].ci_vp = NULL;\n\t\t} else {\n\t\t\tprintf(\"vnode was NULL\\n\");\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ffs",
          "args": [
            "bs"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_validate_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "1227-1248",
          "snippet": "STATIC void\nahc_validate_offset(ahc, syncrate, offset, wide)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_syncrate *syncrate;\n\tu_int *offset;\n\tint wide;\n{\n\tu_int maxoffset;\n\n\t/* Limit offset to what we can do */\n\tif (syncrate == NULL) {\n\t\tmaxoffset = 0;\n\t} else if ((ahc->features & AHC_ULTRA2) != 0) {\n\t\tmaxoffset = MAX_OFFSET_ULTRA2;\n\t} else {\n\t\tif (wide)\n\t\t\tmaxoffset = MAX_OFFSET_16BIT;\n\t\telse\n\t\t\tmaxoffset = MAX_OFFSET_8BIT;\n\t}\n\t*offset = MIN(*offset, maxoffset);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "ahc_validate_offset __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct ahc_syncrate *syncrate,\n\t\t\t\t\t u_int *offset, int wide));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nahc_validate_offset __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct ahc_syncrate *syncrate,\n\t\t\t\t\t u_int *offset, int wide));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_validate_offset(ahc, syncrate, offset, wide)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_syncrate *syncrate;\n\tu_int *offset;\n\tint wide;\n{\n\tu_int maxoffset;\n\n\t/* Limit offset to what we can do */\n\tif (syncrate == NULL) {\n\t\tmaxoffset = 0;\n\t} else if ((ahc->features & AHC_ULTRA2) != 0) {\n\t\tmaxoffset = MAX_OFFSET_ULTRA2;\n\t} else {\n\t\tif (wide)\n\t\t\tmaxoffset = MAX_OFFSET_16BIT;\n\t\telse\n\t\t\tmaxoffset = MAX_OFFSET_8BIT;\n\t}\n\t*offset = MIN(*offset, maxoffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG3",
          "args": [
            "\"WARNING: truncating disk at r %d c %d to %d blocks\\n\"",
            "r",
            "c",
            "(int) min_numblks"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG2",
          "args": [
            "\"Error: block size of disk at r %d c %d different from disk at r 0 c 0\\n\"",
            "r",
            "c"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"raid%d: Fatal errors being ignored.\\n\"",
            "raidPtr->raidid"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_CheckLabels",
          "args": [
            "raidPtr",
            "cfgPtr"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "rf_CheckLabels",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_disks.c",
          "lines": "504-765",
          "snippet": "int \nrf_CheckLabels( raidPtr, cfgPtr )\n\tRF_Raid_t *raidPtr;\n\tRF_Config_t *cfgPtr;\n{\n\tint r,c;\n\tchar *dev_name;\n\tRF_ComponentLabel_t *ci_label;\n\tint serial_number = 0;\n\tint mod_number = 0;\n\tint fatal_error = 0;\n\tint mod_values[4];\n\tint mod_count[4];\n\tint ser_values[4];\n\tint ser_count[4];\n\tint num_ser;\n\tint num_mod;\n\tint i;\n\tint found;\n\tint hosed_row;\n\tint hosed_column;\n\tint too_fatal;\n\tint parity_good;\n\tint force;\n\n\thosed_row = -1;\n\thosed_column = -1;\n\ttoo_fatal = 0;\n\tforce = cfgPtr->force;\n\n\t/* \n\t   We're going to try to be a little intelligent here.  If one \n\t   component's label is bogus, and we can identify that it's the\n\t   *only* one that's gone, we'll mark it as \"failed\" and allow\n\t   the configuration to proceed.  This will be the *only* case\n\t   that we'll proceed if there would be (otherwise) fatal errors.\n\t   \n\t   Basically we simply keep a count of how many components had\n\t   what serial number.  If all but one agree, we simply mark\n\t   the disagreeing component as being failed, and allow \n\t   things to come up \"normally\".\n\t   \n\t   We do this first for serial numbers, and then for \"mod_counter\".\n\n\t */\n\n\tnum_ser = 0;\n\tnum_mod = 0;\n\tfor (r = 0; r < raidPtr->numRow && !fatal_error ; r++) {\n\t\tfor (c = 0; c < raidPtr->numCol; c++) {\n\t\t\tci_label = &raidPtr->raid_cinfo[r][c].ci_label;\n\t\t\tfound=0;\n\t\t\tfor(i=0;i<num_ser;i++) {\n\t\t\t\tif (ser_values[i] == ci_label->serial_number) {\n\t\t\t\t\tser_count[i]++;\n\t\t\t\t\tfound=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t\tser_values[num_ser] = ci_label->serial_number;\n\t\t\t\tser_count[num_ser] = 1;\n\t\t\t\tnum_ser++;\n\t\t\t\tif (num_ser>2) {\n\t\t\t\t\tfatal_error = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfound=0;\n\t\t\tfor(i=0;i<num_mod;i++) {\n\t\t\t\tif (mod_values[i] == ci_label->mod_counter) {\n\t\t\t\t\tmod_count[i]++;\n\t\t\t\t\tfound=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t        mod_values[num_mod] = ci_label->mod_counter;\n\t\t\t\tmod_count[num_mod] = 1;\n\t\t\t\tnum_mod++;\n\t\t\t\tif (num_mod>2) {\n\t\t\t\t\tfatal_error = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n#if DEBUG\n\tprintf(\"raid%d: Summary of serial numbers:\\n\", raidPtr->raidid);\n\tfor(i=0;i<num_ser;i++) {\n\t\tprintf(\"%d %d\\n\", ser_values[i], ser_count[i]);\n\t}\n\tprintf(\"raid%d: Summary of mod counters:\\n\", raidPtr->raidid);\n\tfor(i=0;i<num_mod;i++) {\n\t\tprintf(\"%d %d\\n\", mod_values[i], mod_count[i]);\n\t}\n#endif\n\tserial_number = ser_values[0];\n\tif (num_ser == 2) {\n\t\tif ((ser_count[0] == 1) || (ser_count[1] == 1)) {\n\t\t\t/* Locate the maverick component */\n\t\t\tif (ser_count[1] > ser_count[0]) {\n\t\t\t\tserial_number = ser_values[1];\n\t\t\t} \n\t\t\tfor (r = 0; r < raidPtr->numRow; r++) {\n\t\t\t\tfor (c = 0; c < raidPtr->numCol; c++) {\n\t\t\t\tci_label = &raidPtr->raid_cinfo[r][c].ci_label;\n\t\t\t\t\tif (serial_number != \n\t\t\t\t\t    ci_label->serial_number) {\n\t\t\t\t\t\thosed_row = r;\n\t\t\t\t\t\thosed_column = c;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"Hosed component: %s\\n\",\n\t\t\t       &cfgPtr->devnames[hosed_row][hosed_column][0]);\n\t\t\tif (!force) {\n\t\t\t\t/* we'll fail this component, as if there are\n\t\t\t\t   other major errors, we arn't forcing things\n\t\t\t\t   and we'll abort the config anyways */\n\t\t\t\traidPtr->Disks[hosed_row][hosed_column].status\n\t\t\t\t\t= rf_ds_failed;\n\t\t\t\traidPtr->numFailures++;\n\t\t\t\traidPtr->status[hosed_row] = rf_rs_degraded;\n\t\t\t}\n\t\t} else {\n\t\t\ttoo_fatal = 1;\n\t\t}\n\t\tif (cfgPtr->parityConfig == '0') {\n\t\t\t/* We've identified two different serial numbers. \n\t\t\t   RAID 0 can't cope with that, so we'll punt */\n\t\t\ttoo_fatal = 1;\n\t\t}\n\n\t} \n\n\t/* record the serial number for later.  If we bail later, setting\n\t   this doesn't matter, otherwise we've got the best guess at the \n\t   correct serial number */\n\traidPtr->serial_number = serial_number;\n\n\tmod_number = mod_values[0];\n\tif (num_mod == 2) {\n\t\tif ((mod_count[0] == 1) || (mod_count[1] == 1)) {\n\t\t\t/* Locate the maverick component */\n\t\t\tif (mod_count[1] > mod_count[0]) {\n\t\t\t\tmod_number = mod_values[1];\n\t\t\t} else if (mod_count[1] < mod_count[0]) {\n\t\t\t\tmod_number = mod_values[0];\n\t\t\t} else {\n\t\t\t\t/* counts of different modification values\n\t\t\t\t   are the same.   Assume greater value is \n\t\t\t\t   the correct one, all other things \n\t\t\t\t   considered */\n\t\t\t\tif (mod_values[0] > mod_values[1]) {\n\t\t\t\t\tmod_number = mod_values[0];\n\t\t\t\t} else {\n\t\t\t\t\tmod_number = mod_values[1];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tfor (r = 0; r < raidPtr->numRow && !too_fatal ; r++) {\n\t\t\t\tfor (c = 0; c < raidPtr->numCol; c++) {\n\t\t\t\t\tci_label = &raidPtr->raid_cinfo[r][c].ci_label;\n\t\t\t\t\tif (mod_number != \n\t\t\t\t\t    ci_label->mod_counter) {\n\t\t\t\t\t\tif ( ( hosed_row == r ) &&\n\t\t\t\t\t\t     ( hosed_column == c )) {\n\t\t\t\t\t\t\t/* same one.  Can\n\t\t\t\t\t\t\t   deal with it.  */\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\thosed_row = r;\n\t\t\t\t\t\t\thosed_column = c;\n\t\t\t\t\t\t\tif (num_ser != 1) {\n\t\t\t\t\t\t\t\ttoo_fatal = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"Hosed component: %s\\n\",\n\t\t\t       &cfgPtr->devnames[hosed_row][hosed_column][0]);\n\t\t\tif (!force) {\n\t\t\t\t/* we'll fail this component, as if there are\n\t\t\t\t   other major errors, we arn't forcing things\n\t\t\t\t   and we'll abort the config anyways */\n\t\t\t\tif (raidPtr->Disks[hosed_row][hosed_column].status != rf_ds_failed) {\n\t\t\t\t\traidPtr->Disks[hosed_row][hosed_column].status\n\t\t\t\t\t\t= rf_ds_failed;\n\t\t\t\t\traidPtr->numFailures++;\n\t\t\t\t\traidPtr->status[hosed_row] = rf_rs_degraded;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\ttoo_fatal = 1;\n\t\t}\n\t\tif (cfgPtr->parityConfig == '0') {\n\t\t\t/* We've identified two different mod counters.\n\t\t\t   RAID 0 can't cope with that, so we'll punt */\n\t\t\ttoo_fatal = 1;\n\t\t}\n\t} \n\n\traidPtr->mod_counter = mod_number;\n\n\tif (too_fatal) {\n\t\t/* we've had both a serial number mismatch, and a mod_counter\n\t\t   mismatch -- and they involved two different components!!\n\t\t   Bail -- make things fail so that the user must force\n\t\t   the issue... */\n\t\thosed_row = -1;\n\t\thosed_column = -1;\n\t}\n\n\tif (num_ser > 2) {\n\t\tprintf(\"raid%d: Too many different serial numbers!\\n\", \n\t\t       raidPtr->raidid);\n\t}\n\n\tif (num_mod > 2) {\n\t\tprintf(\"raid%d: Too many different mod counters!\\n\", \n\t\t       raidPtr->raidid);\n\t}\n\n\t/* we start by assuming the parity will be good, and flee from\n\t   that notion at the slightest sign of trouble */\n\n\tparity_good = RF_RAID_CLEAN;\n\tfor (r = 0; r < raidPtr->numRow; r++) {\n\t\tfor (c = 0; c < raidPtr->numCol; c++) {\n\t\t\tdev_name = &cfgPtr->devnames[r][c][0];\n\t\t\tci_label = &raidPtr->raid_cinfo[r][c].ci_label;\n\n\t\t\tif ((r == hosed_row) && (c == hosed_column)) {\n\t\t\t\tprintf(\"raid%d: Ignoring %s\\n\",\n\t\t\t\t       raidPtr->raidid, dev_name);\n\t\t\t} else {\t\t\t\n\t\t\t\trf_print_label_status( raidPtr, r, c, \n\t\t\t\t\t\t       dev_name, ci_label );\n\t\t\t\tif (rf_check_label_vitals( raidPtr, r, c, \n\t\t\t\t\t\t\t   dev_name, ci_label,\n\t\t\t\t\t\t\t   serial_number, \n\t\t\t\t\t\t\t   mod_number )) {\n\t\t\t\t\tfatal_error = 1;\n\t\t\t\t}\n\t\t\t\tif (ci_label->clean != RF_RAID_CLEAN) {\n\t\t\t\t\tparity_good = RF_RAID_DIRTY;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (fatal_error) {\n\t\tparity_good = RF_RAID_DIRTY;\n\t}\n\n\t/* we note the state of the parity */\n\traidPtr->parity_good = parity_good;\n\n\treturn(fatal_error);\t\n}",
          "includes": [
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"rf_kintf.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void rf_UnconfigureVnodes( RF_Raid_t * );",
            "int rf_CheckLabels( RF_Raid_t *, RF_Config_t *);",
            "static void rf_print_label_status( RF_Raid_t *, int, int, char *, \n\t\t\t\t  RF_ComponentLabel_t *);",
            "static int rf_check_label_vitals( RF_Raid_t *, int, int, char *, \n\t\t\t\t  RF_ComponentLabel_t *, int, int );"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"rf_kintf.h\"\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_utils.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid rf_UnconfigureVnodes( RF_Raid_t * );\nint rf_CheckLabels( RF_Raid_t *, RF_Config_t *);\nstatic void rf_print_label_status( RF_Raid_t *, int, int, char *, \n\t\t\t\t  RF_ComponentLabel_t *);\nstatic int rf_check_label_vitals( RF_Raid_t *, int, int, char *, \n\t\t\t\t  RF_ComponentLabel_t *, int, int );\n\nint \nrf_CheckLabels( raidPtr, cfgPtr )\n\tRF_Raid_t *raidPtr;\n\tRF_Config_t *cfgPtr;\n{\n\tint r,c;\n\tchar *dev_name;\n\tRF_ComponentLabel_t *ci_label;\n\tint serial_number = 0;\n\tint mod_number = 0;\n\tint fatal_error = 0;\n\tint mod_values[4];\n\tint mod_count[4];\n\tint ser_values[4];\n\tint ser_count[4];\n\tint num_ser;\n\tint num_mod;\n\tint i;\n\tint found;\n\tint hosed_row;\n\tint hosed_column;\n\tint too_fatal;\n\tint parity_good;\n\tint force;\n\n\thosed_row = -1;\n\thosed_column = -1;\n\ttoo_fatal = 0;\n\tforce = cfgPtr->force;\n\n\t/* \n\t   We're going to try to be a little intelligent here.  If one \n\t   component's label is bogus, and we can identify that it's the\n\t   *only* one that's gone, we'll mark it as \"failed\" and allow\n\t   the configuration to proceed.  This will be the *only* case\n\t   that we'll proceed if there would be (otherwise) fatal errors.\n\t   \n\t   Basically we simply keep a count of how many components had\n\t   what serial number.  If all but one agree, we simply mark\n\t   the disagreeing component as being failed, and allow \n\t   things to come up \"normally\".\n\t   \n\t   We do this first for serial numbers, and then for \"mod_counter\".\n\n\t */\n\n\tnum_ser = 0;\n\tnum_mod = 0;\n\tfor (r = 0; r < raidPtr->numRow && !fatal_error ; r++) {\n\t\tfor (c = 0; c < raidPtr->numCol; c++) {\n\t\t\tci_label = &raidPtr->raid_cinfo[r][c].ci_label;\n\t\t\tfound=0;\n\t\t\tfor(i=0;i<num_ser;i++) {\n\t\t\t\tif (ser_values[i] == ci_label->serial_number) {\n\t\t\t\t\tser_count[i]++;\n\t\t\t\t\tfound=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t\tser_values[num_ser] = ci_label->serial_number;\n\t\t\t\tser_count[num_ser] = 1;\n\t\t\t\tnum_ser++;\n\t\t\t\tif (num_ser>2) {\n\t\t\t\t\tfatal_error = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfound=0;\n\t\t\tfor(i=0;i<num_mod;i++) {\n\t\t\t\tif (mod_values[i] == ci_label->mod_counter) {\n\t\t\t\t\tmod_count[i]++;\n\t\t\t\t\tfound=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t        mod_values[num_mod] = ci_label->mod_counter;\n\t\t\t\tmod_count[num_mod] = 1;\n\t\t\t\tnum_mod++;\n\t\t\t\tif (num_mod>2) {\n\t\t\t\t\tfatal_error = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n#if DEBUG\n\tprintf(\"raid%d: Summary of serial numbers:\\n\", raidPtr->raidid);\n\tfor(i=0;i<num_ser;i++) {\n\t\tprintf(\"%d %d\\n\", ser_values[i], ser_count[i]);\n\t}\n\tprintf(\"raid%d: Summary of mod counters:\\n\", raidPtr->raidid);\n\tfor(i=0;i<num_mod;i++) {\n\t\tprintf(\"%d %d\\n\", mod_values[i], mod_count[i]);\n\t}\n#endif\n\tserial_number = ser_values[0];\n\tif (num_ser == 2) {\n\t\tif ((ser_count[0] == 1) || (ser_count[1] == 1)) {\n\t\t\t/* Locate the maverick component */\n\t\t\tif (ser_count[1] > ser_count[0]) {\n\t\t\t\tserial_number = ser_values[1];\n\t\t\t} \n\t\t\tfor (r = 0; r < raidPtr->numRow; r++) {\n\t\t\t\tfor (c = 0; c < raidPtr->numCol; c++) {\n\t\t\t\tci_label = &raidPtr->raid_cinfo[r][c].ci_label;\n\t\t\t\t\tif (serial_number != \n\t\t\t\t\t    ci_label->serial_number) {\n\t\t\t\t\t\thosed_row = r;\n\t\t\t\t\t\thosed_column = c;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"Hosed component: %s\\n\",\n\t\t\t       &cfgPtr->devnames[hosed_row][hosed_column][0]);\n\t\t\tif (!force) {\n\t\t\t\t/* we'll fail this component, as if there are\n\t\t\t\t   other major errors, we arn't forcing things\n\t\t\t\t   and we'll abort the config anyways */\n\t\t\t\traidPtr->Disks[hosed_row][hosed_column].status\n\t\t\t\t\t= rf_ds_failed;\n\t\t\t\traidPtr->numFailures++;\n\t\t\t\traidPtr->status[hosed_row] = rf_rs_degraded;\n\t\t\t}\n\t\t} else {\n\t\t\ttoo_fatal = 1;\n\t\t}\n\t\tif (cfgPtr->parityConfig == '0') {\n\t\t\t/* We've identified two different serial numbers. \n\t\t\t   RAID 0 can't cope with that, so we'll punt */\n\t\t\ttoo_fatal = 1;\n\t\t}\n\n\t} \n\n\t/* record the serial number for later.  If we bail later, setting\n\t   this doesn't matter, otherwise we've got the best guess at the \n\t   correct serial number */\n\traidPtr->serial_number = serial_number;\n\n\tmod_number = mod_values[0];\n\tif (num_mod == 2) {\n\t\tif ((mod_count[0] == 1) || (mod_count[1] == 1)) {\n\t\t\t/* Locate the maverick component */\n\t\t\tif (mod_count[1] > mod_count[0]) {\n\t\t\t\tmod_number = mod_values[1];\n\t\t\t} else if (mod_count[1] < mod_count[0]) {\n\t\t\t\tmod_number = mod_values[0];\n\t\t\t} else {\n\t\t\t\t/* counts of different modification values\n\t\t\t\t   are the same.   Assume greater value is \n\t\t\t\t   the correct one, all other things \n\t\t\t\t   considered */\n\t\t\t\tif (mod_values[0] > mod_values[1]) {\n\t\t\t\t\tmod_number = mod_values[0];\n\t\t\t\t} else {\n\t\t\t\t\tmod_number = mod_values[1];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tfor (r = 0; r < raidPtr->numRow && !too_fatal ; r++) {\n\t\t\t\tfor (c = 0; c < raidPtr->numCol; c++) {\n\t\t\t\t\tci_label = &raidPtr->raid_cinfo[r][c].ci_label;\n\t\t\t\t\tif (mod_number != \n\t\t\t\t\t    ci_label->mod_counter) {\n\t\t\t\t\t\tif ( ( hosed_row == r ) &&\n\t\t\t\t\t\t     ( hosed_column == c )) {\n\t\t\t\t\t\t\t/* same one.  Can\n\t\t\t\t\t\t\t   deal with it.  */\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\thosed_row = r;\n\t\t\t\t\t\t\thosed_column = c;\n\t\t\t\t\t\t\tif (num_ser != 1) {\n\t\t\t\t\t\t\t\ttoo_fatal = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"Hosed component: %s\\n\",\n\t\t\t       &cfgPtr->devnames[hosed_row][hosed_column][0]);\n\t\t\tif (!force) {\n\t\t\t\t/* we'll fail this component, as if there are\n\t\t\t\t   other major errors, we arn't forcing things\n\t\t\t\t   and we'll abort the config anyways */\n\t\t\t\tif (raidPtr->Disks[hosed_row][hosed_column].status != rf_ds_failed) {\n\t\t\t\t\traidPtr->Disks[hosed_row][hosed_column].status\n\t\t\t\t\t\t= rf_ds_failed;\n\t\t\t\t\traidPtr->numFailures++;\n\t\t\t\t\traidPtr->status[hosed_row] = rf_rs_degraded;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\ttoo_fatal = 1;\n\t\t}\n\t\tif (cfgPtr->parityConfig == '0') {\n\t\t\t/* We've identified two different mod counters.\n\t\t\t   RAID 0 can't cope with that, so we'll punt */\n\t\t\ttoo_fatal = 1;\n\t\t}\n\t} \n\n\traidPtr->mod_counter = mod_number;\n\n\tif (too_fatal) {\n\t\t/* we've had both a serial number mismatch, and a mod_counter\n\t\t   mismatch -- and they involved two different components!!\n\t\t   Bail -- make things fail so that the user must force\n\t\t   the issue... */\n\t\thosed_row = -1;\n\t\thosed_column = -1;\n\t}\n\n\tif (num_ser > 2) {\n\t\tprintf(\"raid%d: Too many different serial numbers!\\n\", \n\t\t       raidPtr->raidid);\n\t}\n\n\tif (num_mod > 2) {\n\t\tprintf(\"raid%d: Too many different mod counters!\\n\", \n\t\t       raidPtr->raidid);\n\t}\n\n\t/* we start by assuming the parity will be good, and flee from\n\t   that notion at the slightest sign of trouble */\n\n\tparity_good = RF_RAID_CLEAN;\n\tfor (r = 0; r < raidPtr->numRow; r++) {\n\t\tfor (c = 0; c < raidPtr->numCol; c++) {\n\t\t\tdev_name = &cfgPtr->devnames[r][c][0];\n\t\t\tci_label = &raidPtr->raid_cinfo[r][c].ci_label;\n\n\t\t\tif ((r == hosed_row) && (c == hosed_column)) {\n\t\t\t\tprintf(\"raid%d: Ignoring %s\\n\",\n\t\t\t\t       raidPtr->raidid, dev_name);\n\t\t\t} else {\t\t\t\n\t\t\t\trf_print_label_status( raidPtr, r, c, \n\t\t\t\t\t\t       dev_name, ci_label );\n\t\t\t\tif (rf_check_label_vitals( raidPtr, r, c, \n\t\t\t\t\t\t\t   dev_name, ci_label,\n\t\t\t\t\t\t\t   serial_number, \n\t\t\t\t\t\t\t   mod_number )) {\n\t\t\t\t\tfatal_error = 1;\n\t\t\t\t}\n\t\t\t\tif (ci_label->clean != RF_RAID_CLEAN) {\n\t\t\t\t\tparity_good = RF_RAID_DIRTY;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (fatal_error) {\n\t\tparity_good = RF_RAID_DIRTY;\n\t}\n\n\t/* we note the state of the parity */\n\traidPtr->parity_good = parity_good;\n\n\treturn(fatal_error);\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG1",
          "args": [
            "\"Error: block size on disks (%d) must be a power of 2\\n\"",
            "bs"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG",
          "args": [
            "\"RAIDFRAME: Did not find any live disks in the array.\\n\""
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF7",
          "args": [
            "\"Disk at row %d col %d: dev %s numBlocks %ld blockSize %d (%ld MB)\\n\"",
            "r",
            "c",
            "disks[r][c].devname",
            "(long int) disks[r][c].numBlocks",
            "disks[r][c].blockSize",
            "(long int) disks[r][c].numBlocks *\n\t\t\t\t\t disks[r][c].blockSize / 1024 / 1024"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raidread_component_label",
          "args": [
            "raidPtr->raid_cinfo[r][c].ci_dev",
            "raidPtr->raid_cinfo[r][c].ci_vp",
            "&raidPtr->raid_cinfo[r][c].ci_label"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "raidread_component_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_netbsdkintf.c",
          "lines": "1935-1983",
          "snippet": "int\nraidread_component_label(dev, b_vp, component_label)\n\tdev_t dev;\n\tstruct vnode *b_vp;\n\tRF_ComponentLabel_t *component_label;\n{\n\tstruct buf *bp;\n\tint error;\n\t\n\t/* XXX should probably ensure that we don't try to do this if\n\t   someone has changed rf_protected_sectors. */ \n\n\t/* get a block of the appropriate size... */\n\tbp = geteblk((int)RF_COMPONENT_INFO_SIZE);\n\tbp->b_dev = dev;\n\n\t/* get our ducks in a row for the read */\n\tbp->b_blkno = RF_COMPONENT_INFO_OFFSET / DEV_BSIZE;\n\tbp->b_bcount = RF_COMPONENT_INFO_SIZE;\n\tbp->b_flags = B_BUSY | B_READ;\n \tbp->b_resid = RF_COMPONENT_INFO_SIZE / DEV_BSIZE;\n\n\t(*bdevsw[major(bp->b_dev)].d_strategy)(bp);\n\n\terror = biowait(bp); \n\n\tif (!error) {\n\t\tmemcpy(component_label, bp->b_un.b_addr,\n\t\t       sizeof(RF_ComponentLabel_t));\n#if 0\n\t\tprintf(\"raidread_component_label: got component label:\\n\");\n\t\tprintf(\"Version: %d\\n\",component_label->version);\n\t\tprintf(\"Serial Number: %d\\n\",component_label->serial_number);\n\t\tprintf(\"Mod counter: %d\\n\",component_label->mod_counter);\n\t\tprintf(\"Row: %d\\n\", component_label->row);\n\t\tprintf(\"Column: %d\\n\", component_label->column);\n\t\tprintf(\"Num Rows: %d\\n\", component_label->num_rows);\n\t\tprintf(\"Num Columns: %d\\n\", component_label->num_columns);\n\t\tprintf(\"Clean: %d\\n\", component_label->clean);\n\t\tprintf(\"Status: %d\\n\", component_label->status);\n#endif\n        } else {\n\t\tprintf(\"Failed to read RAID component label!\\n\");\n\t}\n\n        bp->b_flags = B_INVAL | B_AGE;\n\tbrelse(bp); \n\treturn(error);\n}",
          "includes": [
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_dagflags.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_raidframe.h\"",
            "#include \"rf_raid.h\"",
            "#include \"raid.h\"",
            "#include <sys/user.h>",
            "#include <sys/buf.h>",
            "#include <sys/lock.h>",
            "#include <sys/conf.h>",
            "#include <sys/disklabel.h>",
            "#include <machine/types.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/vnode.h>",
            "#include <sys/namei.h>",
            "#include <sys/systm.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/device.h>",
            "#include <sys/disk.h>",
            "#include <sys/queue.h>",
            "#include <sys/pool.h>",
            "#include <sys/param.h>",
            "#include <sys/errno.h>"
          ],
          "macros_used": [
            "#define RF_COMPONENT_INFO_SIZE     1024 /* bytes */",
            "#define RF_COMPONENT_INFO_OFFSET  16384 /* bytes */"
          ],
          "globals_used": [
            "static void KernelWakeupFunc(struct buf * bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/disklabel.h>\n#include <machine/types.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/vnode.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/pool.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\n#define RF_COMPONENT_INFO_SIZE     1024 /* bytes */\n#define RF_COMPONENT_INFO_OFFSET  16384 /* bytes */\n\nstatic void KernelWakeupFunc(struct buf * bp);\n\nint\nraidread_component_label(dev, b_vp, component_label)\n\tdev_t dev;\n\tstruct vnode *b_vp;\n\tRF_ComponentLabel_t *component_label;\n{\n\tstruct buf *bp;\n\tint error;\n\t\n\t/* XXX should probably ensure that we don't try to do this if\n\t   someone has changed rf_protected_sectors. */ \n\n\t/* get a block of the appropriate size... */\n\tbp = geteblk((int)RF_COMPONENT_INFO_SIZE);\n\tbp->b_dev = dev;\n\n\t/* get our ducks in a row for the read */\n\tbp->b_blkno = RF_COMPONENT_INFO_OFFSET / DEV_BSIZE;\n\tbp->b_bcount = RF_COMPONENT_INFO_SIZE;\n\tbp->b_flags = B_BUSY | B_READ;\n \tbp->b_resid = RF_COMPONENT_INFO_SIZE / DEV_BSIZE;\n\n\t(*bdevsw[major(bp->b_dev)].d_strategy)(bp);\n\n\terror = biowait(bp); \n\n\tif (!error) {\n\t\tmemcpy(component_label, bp->b_un.b_addr,\n\t\t       sizeof(RF_ComponentLabel_t));\n#if 0\n\t\tprintf(\"raidread_component_label: got component label:\\n\");\n\t\tprintf(\"Version: %d\\n\",component_label->version);\n\t\tprintf(\"Serial Number: %d\\n\",component_label->serial_number);\n\t\tprintf(\"Mod counter: %d\\n\",component_label->mod_counter);\n\t\tprintf(\"Row: %d\\n\", component_label->row);\n\t\tprintf(\"Column: %d\\n\", component_label->column);\n\t\tprintf(\"Num Rows: %d\\n\", component_label->num_rows);\n\t\tprintf(\"Num Columns: %d\\n\", component_label->num_columns);\n\t\tprintf(\"Clean: %d\\n\", component_label->clean);\n\t\tprintf(\"Status: %d\\n\", component_label->status);\n#endif\n        } else {\n\t\tprintf(\"Failed to read RAID component label!\\n\");\n\t}\n\n        bp->b_flags = B_INVAL | B_AGE;\n\tbrelse(bp); \n\treturn(error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_ConfigureDisk",
          "args": [
            "raidPtr",
            "&cfgPtr->devnames[r][c][0]",
            "&disks[r][c]",
            "r",
            "c"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "rf_ConfigureDisk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_disks.c",
          "lines": "350-423",
          "snippet": "int \nrf_ConfigureDisk(raidPtr, buf, diskPtr, row, col)\n\tRF_Raid_t *raidPtr;\n\tchar   *buf;\n\tRF_RaidDisk_t *diskPtr;\n\tRF_RowCol_t row;\n\tRF_RowCol_t col;\n{\n\tchar   *p;\n\tint     retcode;\n\n\tstruct partinfo dpart;\n\tstruct vnode *vp;\n\tstruct vattr va;\n\tstruct proc *proc;\n\tint     error;\n\n\tretcode = 0;\n\tp = rf_find_non_white(buf);\n\tif (p[strlen(p) - 1] == '\\n') {\n\t\t/* strip off the newline */\n\t\tp[strlen(p) - 1] = '\\0';\n\t}\n\t(void) strcpy(diskPtr->devname, p);\n\n#if 0\n\tproc = raidPtr->engine_thread;\n#else\n\tproc = curproc;\n#endif\n\n\t/* Let's start by claiming the component is fine and well... */\n\tdiskPtr->status = rf_ds_optimal;\n\n\traidPtr->raid_cinfo[row][col].ci_vp = NULL;\n\traidPtr->raid_cinfo[row][col].ci_dev = NULL;\n\n\terror = raidlookup(diskPtr->devname, proc, &vp);\n\tif (error) {\n\t\tprintf(\"raidlookup on device: %s failed!\\n\", diskPtr->devname);\n\t\tif (error == ENXIO) {\n\t\t\t/* the component isn't there... must be dead :-( */\n\t\t\tdiskPtr->status = rf_ds_failed;\n\t\t} else {\n\t\t\treturn (error);\n\t\t}\n\t}\n\tif (diskPtr->status == rf_ds_optimal) {\n\n\t\tif ((error = VOP_GETATTR(vp, &va, proc->p_ucred, proc)) != 0) {\n\t\t\treturn (error);\n\t\t}\n\t\terror = VOP_IOCTL(vp, DIOCGPART, (caddr_t) & dpart,\n\t\t    FREAD, proc->p_ucred, proc);\n\t\tif (error) {\n\t\t\treturn (error);\n\t\t}\n\t\tdiskPtr->blockSize = dpart.disklab->d_secsize;\n\n\t\tdiskPtr->numBlocks = dpart.part->p_size - rf_protectedSectors;\n\n\t\traidPtr->raid_cinfo[row][col].ci_vp = vp;\n\t\traidPtr->raid_cinfo[row][col].ci_dev = va.va_rdev;\n\n\t\tdiskPtr->dev = va.va_rdev;\n\n\t\t/* we allow the user to specify that only a fraction of the\n\t\t * disks should be used this is just for debug:  it speeds up\n\t\t * the parity scan */\n\t\tdiskPtr->numBlocks = diskPtr->numBlocks * \n\t\t\trf_sizePercentage / 100;\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"rf_kintf.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void rf_UnconfigureVnodes( RF_Raid_t * );"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"rf_kintf.h\"\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_utils.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid rf_UnconfigureVnodes( RF_Raid_t * );\n\nint \nrf_ConfigureDisk(raidPtr, buf, diskPtr, row, col)\n\tRF_Raid_t *raidPtr;\n\tchar   *buf;\n\tRF_RaidDisk_t *diskPtr;\n\tRF_RowCol_t row;\n\tRF_RowCol_t col;\n{\n\tchar   *p;\n\tint     retcode;\n\n\tstruct partinfo dpart;\n\tstruct vnode *vp;\n\tstruct vattr va;\n\tstruct proc *proc;\n\tint     error;\n\n\tretcode = 0;\n\tp = rf_find_non_white(buf);\n\tif (p[strlen(p) - 1] == '\\n') {\n\t\t/* strip off the newline */\n\t\tp[strlen(p) - 1] = '\\0';\n\t}\n\t(void) strcpy(diskPtr->devname, p);\n\n#if 0\n\tproc = raidPtr->engine_thread;\n#else\n\tproc = curproc;\n#endif\n\n\t/* Let's start by claiming the component is fine and well... */\n\tdiskPtr->status = rf_ds_optimal;\n\n\traidPtr->raid_cinfo[row][col].ci_vp = NULL;\n\traidPtr->raid_cinfo[row][col].ci_dev = NULL;\n\n\terror = raidlookup(diskPtr->devname, proc, &vp);\n\tif (error) {\n\t\tprintf(\"raidlookup on device: %s failed!\\n\", diskPtr->devname);\n\t\tif (error == ENXIO) {\n\t\t\t/* the component isn't there... must be dead :-( */\n\t\t\tdiskPtr->status = rf_ds_failed;\n\t\t} else {\n\t\t\treturn (error);\n\t\t}\n\t}\n\tif (diskPtr->status == rf_ds_optimal) {\n\n\t\tif ((error = VOP_GETATTR(vp, &va, proc->p_ucred, proc)) != 0) {\n\t\t\treturn (error);\n\t\t}\n\t\terror = VOP_IOCTL(vp, DIOCGPART, (caddr_t) & dpart,\n\t\t    FREAD, proc->p_ucred, proc);\n\t\tif (error) {\n\t\t\treturn (error);\n\t\t}\n\t\tdiskPtr->blockSize = dpart.disklab->d_secsize;\n\n\t\tdiskPtr->numBlocks = dpart.part->p_size - rf_protectedSectors;\n\n\t\traidPtr->raid_cinfo[row][col].ci_vp = vp;\n\t\traidPtr->raid_cinfo[row][col].ci_dev = va.va_rdev;\n\n\t\tdiskPtr->dev = va.va_rdev;\n\n\t\t/* we allow the user to specify that only a fraction of the\n\t\t * disks should be used this is just for debug:  it speeds up\n\t\t * the parity scan */\n\t\tdiskPtr->numBlocks = diskPtr->numBlocks * \n\t\t\trf_sizePercentage / 100;\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_CallocAndAdd",
          "args": [
            "raidPtr->raid_cinfo[r]",
            "raidPtr->numCol + ((r == 0) ? raidPtr->numSpare : 0)",
            "sizeof(struct raidcinfo)",
            "(struct raidcinfo *),\n\t\t    raidPtr->cleanupList"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_CallocAndAdd",
          "args": [
            "disks[r]",
            "raidPtr->numCol \n\t\t\t\t+ ((r == 0) ? RF_MAXSPARE : 0)",
            "sizeof(RF_RaidDisk_t)",
            "(RF_RaidDisk_t *), \n\t\t\t\traidPtr->cleanupList"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_CallocAndAdd",
          "args": [
            "raidPtr->raid_cinfo",
            "raidPtr->numRow",
            "sizeof(struct raidcinfo *)",
            "(struct raidcinfo **),\n\t    raidPtr->cleanupList"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_CallocAndAdd",
          "args": [
            "disks",
            "raidPtr->numRow",
            "sizeof(RF_RaidDisk_t *)",
            "(RF_RaidDisk_t **), raidPtr->cleanupList"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"rf_kintf.h\"\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_utils.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid rf_UnconfigureVnodes( RF_Raid_t * );\nint rf_CheckLabels( RF_Raid_t *, RF_Config_t *);\n\nint \nrf_ConfigureDisks( listp, raidPtr, cfgPtr )\n\tRF_ShutdownList_t **listp;\n\tRF_Raid_t *raidPtr;\n\tRF_Config_t *cfgPtr;\n{\n\tRF_RaidDisk_t **disks;\n\tRF_SectorCount_t min_numblks = (RF_SectorCount_t) 0x7FFFFFFFFFFFLL;\n\tRF_RowCol_t r, c;\n\tint     bs, ret;\n\tunsigned i, count, foundone = 0, numFailuresThisRow;\n\tint     num_rows_done, num_cols_done;\n\tint\tforce;\n\n\tnum_rows_done = 0;\n\tnum_cols_done = 0;\n\tforce = cfgPtr->force;\n \n\tRF_CallocAndAdd(disks, raidPtr->numRow, sizeof(RF_RaidDisk_t *), \n\t\t\t(RF_RaidDisk_t **), raidPtr->cleanupList);\n\tif (disks == NULL) {\n\t\tret = ENOMEM;\n\t\tgoto fail;\n\t}\n\traidPtr->Disks = disks;\n\n\t/* get space for the device-specific stuff... */\n\tRF_CallocAndAdd(raidPtr->raid_cinfo, raidPtr->numRow,\n\t    sizeof(struct raidcinfo *), (struct raidcinfo **),\n\t    raidPtr->cleanupList);\n\tif (raidPtr->raid_cinfo == NULL) {\n\t\tret = ENOMEM;\n\t\tgoto fail;\n\t}\n\tfor (r = 0; r < raidPtr->numRow; r++) {\n\t\tnumFailuresThisRow = 0;\n\t\t/* We allocate RF_MAXSPARE on the first row so that we\n\t\t   have room to do hot-swapping of spares */\n\t\tRF_CallocAndAdd(disks[r], raidPtr->numCol \n\t\t\t\t+ ((r == 0) ? RF_MAXSPARE : 0), \n\t\t\t\tsizeof(RF_RaidDisk_t), (RF_RaidDisk_t *), \n\t\t\t\traidPtr->cleanupList);\n\t\tif (disks[r] == NULL) {\n\t\t\tret = ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\t\t/* get more space for device specific stuff.. */\n\t\tRF_CallocAndAdd(raidPtr->raid_cinfo[r],\n\t\t    raidPtr->numCol + ((r == 0) ? raidPtr->numSpare : 0),\n\t\t    sizeof(struct raidcinfo), (struct raidcinfo *),\n\t\t    raidPtr->cleanupList);\n\t\tif (raidPtr->raid_cinfo[r] == NULL) {\n\t\t\tret = ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\t\tfor (c = 0; c < raidPtr->numCol; c++) {\n\t\t\tret = rf_ConfigureDisk(raidPtr, \n\t\t\t\t\t       &cfgPtr->devnames[r][c][0],\n\t\t\t\t\t       &disks[r][c], r, c);\n\t\t\tif (ret)\n\t\t\t\tgoto fail;\n\n\t\t\tif (disks[r][c].status == rf_ds_optimal) {\n\t\t\t\traidread_component_label(\n\t\t\t\t\t raidPtr->raid_cinfo[r][c].ci_dev,\n\t\t\t\t\t raidPtr->raid_cinfo[r][c].ci_vp,\n\t\t\t\t\t &raidPtr->raid_cinfo[r][c].ci_label);\n\t\t\t}\n\n\t\t\tif (disks[r][c].status != rf_ds_optimal) {\n\t\t\t\tnumFailuresThisRow++;\n\t\t\t} else {\n\t\t\t\tif (disks[r][c].numBlocks < min_numblks)\n\t\t\t\t\tmin_numblks = disks[r][c].numBlocks;\n\t\t\t\tDPRINTF7(\"Disk at row %d col %d: dev %s numBlocks %ld blockSize %d (%ld MB)\\n\",\n\t\t\t\t    r, c, disks[r][c].devname,\n\t\t\t\t    (long int) disks[r][c].numBlocks,\n\t\t\t\t    disks[r][c].blockSize,\n\t\t\t\t    (long int) disks[r][c].numBlocks *\n\t\t\t\t\t disks[r][c].blockSize / 1024 / 1024);\n\t\t\t}\n\t\t\tnum_cols_done++;\n\t\t}\n\t\t/* XXX fix for n-fault tolerant */\n\t\t/* XXX this should probably check to see how many failures\n\t\t   we can handle for this configuration! */\n\t\tif (numFailuresThisRow > 0)\n\t\t\traidPtr->status[r] = rf_rs_degraded;\n\t\tnum_rows_done++;\n\t}\n\t/* all disks must be the same size & have the same block size, bs must\n\t * be a power of 2 */\n\tbs = 0;\n\tfor (foundone = r = 0; !foundone && r < raidPtr->numRow; r++) {\n\t\tfor (c = 0; !foundone && c < raidPtr->numCol; c++) {\n\t\t\tif (disks[r][c].status == rf_ds_optimal) {\n\t\t\t\tbs = disks[r][c].blockSize;\n\t\t\t\tfoundone = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (!foundone) {\n\t\tRF_ERRORMSG(\"RAIDFRAME: Did not find any live disks in the array.\\n\");\n\t\tret = EINVAL;\n\t\tgoto fail;\n\t}\n\tfor (count = 0, i = 1; i; i <<= 1)\n\t\tif (bs & i)\n\t\t\tcount++;\n\tif (count != 1) {\n\t\tRF_ERRORMSG1(\"Error: block size on disks (%d) must be a power of 2\\n\", bs);\n\t\tret = EINVAL;\n\t\tgoto fail;\n\t}\n\n\tif (rf_CheckLabels( raidPtr, cfgPtr )) {\n\t\tprintf(\"raid%d: There were fatal errors\\n\", raidPtr->raidid);\n\t\tif (force != 0) {\n\t\t\tprintf(\"raid%d: Fatal errors being ignored.\\n\",\n\t\t\t       raidPtr->raidid);\n\t\t} else {\n\t\t\tret = EINVAL;\n\t\t\tgoto fail;\n\t\t} \n\t}\n\n\tfor (r = 0; r < raidPtr->numRow; r++) {\n\t\tfor (c = 0; c < raidPtr->numCol; c++) {\n\t\t\tif (disks[r][c].status == rf_ds_optimal) {\n\t\t\t\tif (disks[r][c].blockSize != bs) {\n\t\t\t\t\tRF_ERRORMSG2(\"Error: block size of disk at r %d c %d different from disk at r 0 c 0\\n\", r, c);\n\t\t\t\t\tret = EINVAL;\n\t\t\t\t\tgoto fail;\n\t\t\t\t}\n\t\t\t\tif (disks[r][c].numBlocks != min_numblks) {\n\t\t\t\t\tRF_ERRORMSG3(\"WARNING: truncating disk at r %d c %d to %d blocks\\n\",\n\t\t\t\t\t    r, c, (int) min_numblks);\n\t\t\t\t\tdisks[r][c].numBlocks = min_numblks;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\traidPtr->sectorsPerDisk = min_numblks;\n\traidPtr->logBytesPerSector = ffs(bs) - 1;\n\traidPtr->bytesPerSector = bs;\n\traidPtr->sectorMask = bs - 1;\n\treturn (0);\n\nfail:\n\trf_UnconfigureVnodes( raidPtr );\n\n\treturn (ret);\n}"
  }
]