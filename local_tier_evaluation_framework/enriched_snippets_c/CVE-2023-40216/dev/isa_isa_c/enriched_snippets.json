[
  {
    "function_name": "isascan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/isa.c",
    "lines": "185-286",
    "snippet": "void\nisascan(parent, match)\n\tstruct device *parent;\n\tvoid *match;\n{\n\tstruct isa_softc *sc = (struct isa_softc *)parent;\n\tstruct device *dev = match;\n\tstruct cfdata *cf = dev->dv_cfdata;\n\tstruct isa_attach_args ia;\n\n\tia.ia_iot = sc->sc_iot;\n\tia.ia_memt = sc->sc_memt;\n#if NISADMA > 0\n\tia.ia_dmat = sc->sc_dmat;\n#endif /* NISADMA > 0 */\n\tia.ia_ic = sc->sc_ic;\n\tia.ia_iobase = cf->cf_iobase;\n\tia.ia_iosize = 0x666;\n\tia.ia_maddr = cf->cf_maddr;\n\tia.ia_msize = cf->cf_msize;\n\tia.ia_irq = cf->cf_irq == 2 ? 9 : cf->cf_irq;\n\tia.ia_drq = cf->cf_drq;\n\tia.ia_drq2 = cf->cf_drq2;\n\tia.ia_delaybah = sc->sc_delaybah;\n\n\tif (cf->cf_fstate == FSTATE_STAR) {\n\t\tstruct isa_attach_args ia2 = ia;\n\n\t\tif (autoconf_verbose)\n\t\t\tprintf(\">>> probing for %s*\\n\",\n\t\t\t    cf->cf_driver->cd_name);\n\t\twhile ((*cf->cf_attach->ca_match)(parent, dev, &ia2) > 0) {\n#if !defined(__NO_ISA_INTR_CHECK)\n\t\t\tif ((ia2.ia_irq != IRQUNK) &&\n\t\t\t    !isa_intr_check(sc->sc_ic, ia2.ia_irq, IST_EDGE)) {\n\t\t\t\tprintf(\"%s%d: irq %d already in use\\n\",\n\t\t\t\t    cf->cf_driver->cd_name, cf->cf_unit,\n\t\t\t\t    ia2.ia_irq);\n\t\t\t\tia2 = ia;\n\t\t\t\tbreak;\n\t\t\t}\n#endif\n\n\t\t\tif (autoconf_verbose)\n\t\t\t\tprintf(\">>> probe for %s* clone into %s%d\\n\",\n\t\t\t\t    cf->cf_driver->cd_name,\n\t\t\t\t    cf->cf_driver->cd_name, cf->cf_unit);\n\t\t\tif (ia2.ia_iosize == 0x666) {\n\t\t\t\tprintf(\"%s: iosize not repaired by driver\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\tia2.ia_iosize = 0;\n\t\t\t}\n\t\t\tconfig_attach(parent, dev, &ia2, isaprint);\n\t\t\tdev = config_make_softc(parent, cf);\n#if NISADMA > 0\n\t\t\tif (ia2.ia_drq != DRQUNK)\n\t\t\t\tISA_DRQ_ALLOC((struct device *)sc, ia2.ia_drq);\n\t\t\tif (ia2.ia_drq2 != DRQUNK)\n\t\t\t\tISA_DRQ_ALLOC((struct device *)sc, ia2.ia_drq2);\n#endif /* NISAMDA > 0 */\n\t\t\tia2 = ia;\n\t\t}\n\t\tif (autoconf_verbose)\n\t\t\tprintf(\">>> probing for %s* finished\\n\",\n\t\t\t    cf->cf_driver->cd_name);\n\t\tfree(dev, M_DEVBUF);\n\t\treturn;\n\t}\n\n\tif (autoconf_verbose)\n\t\tprintf(\">>> probing for %s%d\\n\", cf->cf_driver->cd_name,\n\t\t    cf->cf_unit);\n\tif ((*cf->cf_attach->ca_match)(parent, dev, &ia) > 0) {\n#if !defined(__NO_ISA_INTR_CHECK)\n\t\tif ((ia.ia_irq != IRQUNK) &&\n\t\t    !isa_intr_check(sc->sc_ic, ia.ia_irq, IST_EDGE)) {\n\t\t\tprintf(\"%s%d: irq %d already in use\\n\",\n\t\t\t    cf->cf_driver->cd_name, cf->cf_unit, ia.ia_irq);\n\t\t\tfree(dev, M_DEVBUF);\n\t\t} else {\n#endif\n\t\t\tif (autoconf_verbose)\n\t\t\t\tprintf(\">>> probing for %s%d succeeded\\n\",\n\t\t\t\t    cf->cf_driver->cd_name, cf->cf_unit);\n\t\t\tconfig_attach(parent, dev, &ia, isaprint);\n\n#if NISADMA > 0\n\t\t\tif (ia.ia_drq != DRQUNK)\n\t\t\t\tISA_DRQ_ALLOC((struct device *)sc, ia.ia_drq);\n\t\t\tif (ia.ia_drq2 != DRQUNK)\n\t\t\t\tISA_DRQ_ALLOC((struct device *)sc, ia.ia_drq2);\n#endif /* NISAMDA > 0 */\n#if !defined(__NO_ISA_INTR_CHECK)\n\t\t}\n#endif\n\t} else {\n\t\tif (autoconf_verbose)\n\t\t\tprintf(\">>> probing for %s%d failed\\n\",\n\t\t\t    cf->cf_driver->cd_name, cf->cf_unit);\n\t\tfree(dev, M_DEVBUF);\n\t}\n}",
    "includes": [
      "#include <dev/isa/isadmareg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern int autoconf_verbose;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "dev",
            "M_DEVBUF"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "sb_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/sbdsp.c",
          "lines": "2202-2209",
          "snippet": "void\nsb_free(addr, ptr, pool)\n\tvoid *addr;\n\tvoid *ptr;\n\tint pool;\n{\n\tisa_free(ptr, pool);\n}",
          "includes": [
            "#include <dev/isa/sbdspvar.h>",
            "#include <dev/isa/sbreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/midi_if.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"midi.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void *\nsb_malloc(addr, size, pool, flags)\n\tvoid *addr;",
            "int pool;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/sbdspvar.h>\n#include <dev/isa/sbreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"midi.h\"\n\nvoid *\nsb_malloc(addr, size, pool, flags)\n\tvoid *addr;\nint pool;\n\nvoid\nsb_free(addr, ptr, pool)\n\tvoid *addr;\n\tvoid *ptr;\n\tint pool;\n{\n\tisa_free(ptr, pool);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\">>> probing for %s%d failed\\n\"",
            "cf->cf_driver->cd_name",
            "cf->cf_unit"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ISA_DRQ_ALLOC",
          "args": [
            "(struct device *)sc",
            "ia.ia_drq2"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_DRQ_ALLOC",
          "args": [
            "(struct device *)sc",
            "ia.ia_drq"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "config_attach",
          "args": [
            "parent",
            "dev",
            "&ia",
            "isaprint"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isa_intr_check",
          "args": [
            "sc->sc_ic",
            "ia.ia_irq",
            "IST_EDGE"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "parent",
            "dev",
            "&ia"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_DRQ_ALLOC",
          "args": [
            "(struct device *)sc",
            "ia2.ia_drq2"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_DRQ_ALLOC",
          "args": [
            "(struct device *)sc",
            "ia2.ia_drq"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "config_make_softc",
          "args": [
            "parent",
            "cf"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "config_attach",
          "args": [
            "parent",
            "dev",
            "&ia2",
            "isaprint"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isa_intr_check",
          "args": [
            "sc->sc_ic",
            "ia2.ia_irq",
            "IST_EDGE"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "parent",
            "dev",
            "&ia2"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/isadmareg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nextern int autoconf_verbose;\n\nvoid\nisascan(parent, match)\n\tstruct device *parent;\n\tvoid *match;\n{\n\tstruct isa_softc *sc = (struct isa_softc *)parent;\n\tstruct device *dev = match;\n\tstruct cfdata *cf = dev->dv_cfdata;\n\tstruct isa_attach_args ia;\n\n\tia.ia_iot = sc->sc_iot;\n\tia.ia_memt = sc->sc_memt;\n#if NISADMA > 0\n\tia.ia_dmat = sc->sc_dmat;\n#endif /* NISADMA > 0 */\n\tia.ia_ic = sc->sc_ic;\n\tia.ia_iobase = cf->cf_iobase;\n\tia.ia_iosize = 0x666;\n\tia.ia_maddr = cf->cf_maddr;\n\tia.ia_msize = cf->cf_msize;\n\tia.ia_irq = cf->cf_irq == 2 ? 9 : cf->cf_irq;\n\tia.ia_drq = cf->cf_drq;\n\tia.ia_drq2 = cf->cf_drq2;\n\tia.ia_delaybah = sc->sc_delaybah;\n\n\tif (cf->cf_fstate == FSTATE_STAR) {\n\t\tstruct isa_attach_args ia2 = ia;\n\n\t\tif (autoconf_verbose)\n\t\t\tprintf(\">>> probing for %s*\\n\",\n\t\t\t    cf->cf_driver->cd_name);\n\t\twhile ((*cf->cf_attach->ca_match)(parent, dev, &ia2) > 0) {\n#if !defined(__NO_ISA_INTR_CHECK)\n\t\t\tif ((ia2.ia_irq != IRQUNK) &&\n\t\t\t    !isa_intr_check(sc->sc_ic, ia2.ia_irq, IST_EDGE)) {\n\t\t\t\tprintf(\"%s%d: irq %d already in use\\n\",\n\t\t\t\t    cf->cf_driver->cd_name, cf->cf_unit,\n\t\t\t\t    ia2.ia_irq);\n\t\t\t\tia2 = ia;\n\t\t\t\tbreak;\n\t\t\t}\n#endif\n\n\t\t\tif (autoconf_verbose)\n\t\t\t\tprintf(\">>> probe for %s* clone into %s%d\\n\",\n\t\t\t\t    cf->cf_driver->cd_name,\n\t\t\t\t    cf->cf_driver->cd_name, cf->cf_unit);\n\t\t\tif (ia2.ia_iosize == 0x666) {\n\t\t\t\tprintf(\"%s: iosize not repaired by driver\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\tia2.ia_iosize = 0;\n\t\t\t}\n\t\t\tconfig_attach(parent, dev, &ia2, isaprint);\n\t\t\tdev = config_make_softc(parent, cf);\n#if NISADMA > 0\n\t\t\tif (ia2.ia_drq != DRQUNK)\n\t\t\t\tISA_DRQ_ALLOC((struct device *)sc, ia2.ia_drq);\n\t\t\tif (ia2.ia_drq2 != DRQUNK)\n\t\t\t\tISA_DRQ_ALLOC((struct device *)sc, ia2.ia_drq2);\n#endif /* NISAMDA > 0 */\n\t\t\tia2 = ia;\n\t\t}\n\t\tif (autoconf_verbose)\n\t\t\tprintf(\">>> probing for %s* finished\\n\",\n\t\t\t    cf->cf_driver->cd_name);\n\t\tfree(dev, M_DEVBUF);\n\t\treturn;\n\t}\n\n\tif (autoconf_verbose)\n\t\tprintf(\">>> probing for %s%d\\n\", cf->cf_driver->cd_name,\n\t\t    cf->cf_unit);\n\tif ((*cf->cf_attach->ca_match)(parent, dev, &ia) > 0) {\n#if !defined(__NO_ISA_INTR_CHECK)\n\t\tif ((ia.ia_irq != IRQUNK) &&\n\t\t    !isa_intr_check(sc->sc_ic, ia.ia_irq, IST_EDGE)) {\n\t\t\tprintf(\"%s%d: irq %d already in use\\n\",\n\t\t\t    cf->cf_driver->cd_name, cf->cf_unit, ia.ia_irq);\n\t\t\tfree(dev, M_DEVBUF);\n\t\t} else {\n#endif\n\t\t\tif (autoconf_verbose)\n\t\t\t\tprintf(\">>> probing for %s%d succeeded\\n\",\n\t\t\t\t    cf->cf_driver->cd_name, cf->cf_unit);\n\t\t\tconfig_attach(parent, dev, &ia, isaprint);\n\n#if NISADMA > 0\n\t\t\tif (ia.ia_drq != DRQUNK)\n\t\t\t\tISA_DRQ_ALLOC((struct device *)sc, ia.ia_drq);\n\t\t\tif (ia.ia_drq2 != DRQUNK)\n\t\t\t\tISA_DRQ_ALLOC((struct device *)sc, ia.ia_drq2);\n#endif /* NISAMDA > 0 */\n#if !defined(__NO_ISA_INTR_CHECK)\n\t\t}\n#endif\n\t} else {\n\t\tif (autoconf_verbose)\n\t\t\tprintf(\">>> probing for %s%d failed\\n\",\n\t\t\t    cf->cf_driver->cd_name, cf->cf_unit);\n\t\tfree(dev, M_DEVBUF);\n\t}\n}"
  },
  {
    "function_name": "isaprint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/isa.c",
    "lines": "161-183",
    "snippet": "int\nisaprint(aux, isa)\n\tvoid *aux;\n\tconst char *isa;\n{\n\tstruct isa_attach_args *ia = aux;\n\n\tif (ia->ia_iosize)\n\t\tprintf(\" port 0x%x\", ia->ia_iobase);\n\tif (ia->ia_iosize > 1)\n\t\tprintf(\"/%d\", ia->ia_iosize);\n\tif (ia->ia_msize)\n\t\tprintf(\" iomem 0x%x\", ia->ia_maddr);\n\tif (ia->ia_msize > 1)\n\t\tprintf(\"/%d\", ia->ia_msize);\n\tif (ia->ia_irq != IRQUNK)\n\t\tprintf(\" irq %d\", ia->ia_irq);\n\tif (ia->ia_drq != DRQUNK)\n\t\tprintf(\" drq %d\", ia->ia_drq);\n\tif (ia->ia_drq2 != DRQUNK)\n\t\tprintf(\" drq2 %d\", ia->ia_drq2);\n\treturn (UNCONF);\n}",
    "includes": [
      "#include <dev/isa/isadmareg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" drq2 %d\"",
            "ia->ia_drq2"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/isadmareg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nisaprint(aux, isa)\n\tvoid *aux;\n\tconst char *isa;\n{\n\tstruct isa_attach_args *ia = aux;\n\n\tif (ia->ia_iosize)\n\t\tprintf(\" port 0x%x\", ia->ia_iobase);\n\tif (ia->ia_iosize > 1)\n\t\tprintf(\"/%d\", ia->ia_iosize);\n\tif (ia->ia_msize)\n\t\tprintf(\" iomem 0x%x\", ia->ia_maddr);\n\tif (ia->ia_msize > 1)\n\t\tprintf(\"/%d\", ia->ia_msize);\n\tif (ia->ia_irq != IRQUNK)\n\t\tprintf(\" irq %d\", ia->ia_irq);\n\tif (ia->ia_drq != DRQUNK)\n\t\tprintf(\" drq %d\", ia->ia_drq);\n\tif (ia->ia_drq2 != DRQUNK)\n\t\tprintf(\" drq2 %d\", ia->ia_drq2);\n\treturn (UNCONF);\n}"
  },
  {
    "function_name": "isaattach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/isa.c",
    "lines": "108-159",
    "snippet": "void\nisaattach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct isa_softc *sc = (struct isa_softc *)self;\n\tstruct isabus_attach_args *iba = aux;\n\n\tisa_attach_hook(parent, self, iba);\n\tprintf(\"\\n\");\n\n\tsc->sc_iot = iba->iba_iot;\n\tsc->sc_memt = iba->iba_memt;\n#if NISADMA > 0\n\tsc->sc_dmat = iba->iba_dmat;\n#endif /* NISADMA > 0 */\n\tsc->sc_ic = iba->iba_ic;\n\n#if NISAPNP > 0\n\tisapnp_isa_attach_hook(sc);\n#endif\n\n#if NISADMA > 0\n\t/*\n\t * Map the registers used by the ISA DMA controller.\n\t * XXX Should be done in the isadmaattach routine.. but the delay\n\t * XXX port makes it troublesome.  Note that these aren't really\n\t * XXX valid on ISA busses without DMA.\n\t */\n\tif (bus_space_map(sc->sc_iot, IO_DMA1, DMA1_IOSIZE, 0, &sc->sc_dma1h))\n\t\tpanic(\"isaattach: can't map DMA controller #1\");\n\tif (bus_space_map(sc->sc_iot, IO_DMA2, DMA2_IOSIZE, 0, &sc->sc_dma2h))\n\t\tpanic(\"isaattach: can't map DMA controller #2\");\n\tif (bus_space_map(sc->sc_iot, IO_DMAPG, 0xf, 0, &sc->sc_dmapgh))\n\t\tpanic(\"isaattach: can't map DMA page registers\");\n\n\t/*\n  \t * Map port 0x84, which causes a 1.25us delay when read.\n  \t * We do this now, since several drivers need it.\n\t * XXX this port doesn't exist on all ISA busses...\n\t */\n\tif (bus_space_subregion(sc->sc_iot, sc->sc_dmapgh, 0x04, 1,\n\t    &sc->sc_delaybah))\n#else /* NISADMA > 0 */\n\tif (bus_space_map(sc->sc_iot, IO_DMAPG + 0x4, 0x1, 0,\n\t    &sc->sc_delaybah))\n#endif /* NISADMA > 0 */\n\t\tpanic(\"isaattach: can't map `delay port'\");\t/* XXX */\n\n\tTAILQ_INIT(&sc->sc_subdevs);\n\tconfig_scan(isascan, self);\n}",
    "includes": [
      "#include <dev/isa/isadmareg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void isaattach"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "config_scan",
          "args": [
            "isascan",
            "self"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_INIT",
          "args": [
            "&sc->sc_subdevs"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"isaattach: can't map `delay port'\""
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "sc->sc_iot",
            "IO_DMAPG + 0x4",
            "0x1",
            "0",
            "&sc->sc_delaybah"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_subregion",
          "args": [
            "sc->sc_iot",
            "sc->sc_dmapgh",
            "0x04",
            "1",
            "&sc->sc_delaybah"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"isaattach: can't map DMA page registers\""
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "sc->sc_iot",
            "IO_DMAPG",
            "0xf",
            "0",
            "&sc->sc_dmapgh"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"isaattach: can't map DMA controller #2\""
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "sc->sc_iot",
            "IO_DMA2",
            "DMA2_IOSIZE",
            "0",
            "&sc->sc_dma2h"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"isaattach: can't map DMA controller #1\""
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "sc->sc_iot",
            "IO_DMA1",
            "DMA1_IOSIZE",
            "0",
            "&sc->sc_dma1h"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isapnp_isa_attach_hook",
          "args": [
            "sc"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "isapnp_isa_attach_hook",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/isapnp.c",
          "lines": "824-844",
          "snippet": "void\nisapnp_isa_attach_hook(isa_sc)\n\tstruct isa_softc *isa_sc;\n\n{\n\tstruct isapnp_softc sc;\n\t\n\tbzero(&sc, sizeof sc);\n\tsc.sc_iot = isa_sc->sc_iot;\n\tsc.sc_ncards = 0;\n\n\tif (isapnp_map(&sc))\n\t\treturn;\n\n\tisapnp_init(&sc);\n\n\tisapnp_write_reg(&sc, ISAPNP_CONFIG_CONTROL, ISAPNP_CC_RESET_DRV);\n\tDELAY(2000);\n\n\tisapnp_unmap(&sc);\n}",
          "includes": [
            "#include <dev/isa/pnpdevs.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isapnpreg.h>",
            "#include <machine/bus.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void isapnp_init",
            "struct isapnp_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/pnpdevs.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isapnpreg.h>\n#include <machine/bus.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid isapnp_init;\nstruct isapnp_softc *sc;\n\nvoid\nisapnp_isa_attach_hook(isa_sc)\n\tstruct isa_softc *isa_sc;\n\n{\n\tstruct isapnp_softc sc;\n\t\n\tbzero(&sc, sizeof sc);\n\tsc.sc_iot = isa_sc->sc_iot;\n\tsc.sc_ncards = 0;\n\n\tif (isapnp_map(&sc))\n\t\treturn;\n\n\tisapnp_init(&sc);\n\n\tisapnp_write_reg(&sc, ISAPNP_CONFIG_CONTROL, ISAPNP_CC_RESET_DRV);\n\tDELAY(2000);\n\n\tisapnp_unmap(&sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/isadmareg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid isaattach;\n\nvoid\nisaattach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct isa_softc *sc = (struct isa_softc *)self;\n\tstruct isabus_attach_args *iba = aux;\n\n\tisa_attach_hook(parent, self, iba);\n\tprintf(\"\\n\");\n\n\tsc->sc_iot = iba->iba_iot;\n\tsc->sc_memt = iba->iba_memt;\n#if NISADMA > 0\n\tsc->sc_dmat = iba->iba_dmat;\n#endif /* NISADMA > 0 */\n\tsc->sc_ic = iba->iba_ic;\n\n#if NISAPNP > 0\n\tisapnp_isa_attach_hook(sc);\n#endif\n\n#if NISADMA > 0\n\t/*\n\t * Map the registers used by the ISA DMA controller.\n\t * XXX Should be done in the isadmaattach routine.. but the delay\n\t * XXX port makes it troublesome.  Note that these aren't really\n\t * XXX valid on ISA busses without DMA.\n\t */\n\tif (bus_space_map(sc->sc_iot, IO_DMA1, DMA1_IOSIZE, 0, &sc->sc_dma1h))\n\t\tpanic(\"isaattach: can't map DMA controller #1\");\n\tif (bus_space_map(sc->sc_iot, IO_DMA2, DMA2_IOSIZE, 0, &sc->sc_dma2h))\n\t\tpanic(\"isaattach: can't map DMA controller #2\");\n\tif (bus_space_map(sc->sc_iot, IO_DMAPG, 0xf, 0, &sc->sc_dmapgh))\n\t\tpanic(\"isaattach: can't map DMA page registers\");\n\n\t/*\n  \t * Map port 0x84, which causes a 1.25us delay when read.\n  \t * We do this now, since several drivers need it.\n\t * XXX this port doesn't exist on all ISA busses...\n\t */\n\tif (bus_space_subregion(sc->sc_iot, sc->sc_dmapgh, 0x04, 1,\n\t    &sc->sc_delaybah))\n#else /* NISADMA > 0 */\n\tif (bus_space_map(sc->sc_iot, IO_DMAPG + 0x4, 0x1, 0,\n\t    &sc->sc_delaybah))\n#endif /* NISADMA > 0 */\n\t\tpanic(\"isaattach: can't map `delay port'\");\t/* XXX */\n\n\tTAILQ_INIT(&sc->sc_subdevs);\n\tconfig_scan(isascan, self);\n}"
  },
  {
    "function_name": "isamatch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/isa.c",
    "lines": "92-106",
    "snippet": "int\nisamatch(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct cfdata *cf = match;\n\tstruct isabus_attach_args *iba = aux;\n\n\tif (strcmp(iba->iba_busname, cf->cf_driver->cd_name))\n\t\treturn (0);\n\n\t/* XXX check other indicators */\n\n        return (1);\n}",
    "includes": [
      "#include <dev/isa/isadmareg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int isamatch"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "iba->iba_busname",
            "cf->cf_driver->cd_name"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/isadmareg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint isamatch;\n\nint\nisamatch(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct cfdata *cf = match;\n\tstruct isabus_attach_args *iba = aux;\n\n\tif (strcmp(iba->iba_busname, cf->cf_driver->cd_name))\n\t\treturn (0);\n\n\t/* XXX check other indicators */\n\n        return (1);\n}"
  }
]