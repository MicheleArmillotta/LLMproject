[
  {
    "function_name": "ohci_device_isoc_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "3272-3290",
    "snippet": "void\nohci_device_isoc_close(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tstruct ohci_pipe *opipe = (struct ohci_pipe *)pipe;\n\tohci_softc_t *sc = (ohci_softc_t *)pipe->device->bus;\n\tint s;\n\n\tDPRINTF((\"ohci_device_isoc_close: pipe=%p\\n\", pipe));\n\n\ts = splusb();\n\tohci_rem_ed(opipe->sed, sc->sc_isoc_head);\n\tsplx(s);\n\tohci_close_pipe(pipe, sc->sc_isoc_head);\n#ifdef DIAGNOSTIC\n\topipe->tail.itd->isdone = 1;\n#endif\n\tohci_free_sitd(sc, opipe->tail.itd);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "ohci_open __P((usbd_pipe_handle));",
      "ohci_setup_isoc __P((usbd_pipe_handle pipe));",
      "ohci_root_ctrl_close __P((usbd_pipe_handle));",
      "ohci_root_intr_close __P((usbd_pipe_handle));",
      "ohci_device_ctrl_close __P((usbd_pipe_handle));",
      "ohci_device_bulk_close __P((usbd_pipe_handle));",
      "ohci_device_intr_close __P((usbd_pipe_handle));",
      "ohci_device_isoc_close __P((usbd_pipe_handle));",
      "ohci_rhsc_able __P((ohci_softc_t *, int));",
      "ohci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "ohci_noop __P((usbd_pipe_handle pipe));",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
      "ohci_intr1 __P((ohci_softc_t *));",
      "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ohci_free_sitd",
          "args": [
            "sc",
            "opipe->tail.itd"
          ],
          "line": 3289
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_free_sitd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "632-653",
          "snippet": "void\nohci_free_sitd(sc, sitd)\n\tohci_softc_t *sc;\n\tohci_soft_itd_t *sitd;\n{\n\tint s;\n\n\tDPRINTFN(10,(\"ohci_free_sitd: sitd=%p\\n\", sitd));\n\n#ifdef DIAGNOSTIC\n\tif (!sitd->isdone) {\n\t\tpanic(\"ohci_free_sitd: sitd=%p not done\\n\", sitd);\n\t\treturn;\n\t}\n#endif\n\n\ts = splusb();\n\tohci_hash_rem_itd(sc, sitd);\n\tsitd->nextitd = sc->sc_freeitds;\n\tsc->sc_freeitds = sitd;\n\tsplx(s);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static ohci_soft_itd_t",
            "ohci_free_sitd __P((ohci_softc_t *,ohci_soft_itd_t *));",
            "ohci_hash_add_itd __P((ohci_softc_t *, \n\t\t\t    ohci_soft_itd_t *));",
            "ohci_hash_rem_itd __P((ohci_softc_t *,\n\t\t\t    ohci_soft_itd_t *));",
            "Static ohci_soft_itd_t",
            "ohci_rhsc_able __P((ohci_softc_t *, int));",
            "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
            "ohci_intr1 __P((ohci_softc_t *));",
            "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_itd_t;\nohci_free_sitd __P((ohci_softc_t *,ohci_soft_itd_t *));\nohci_hash_add_itd __P((ohci_softc_t *, \n\t\t\t    ohci_soft_itd_t *));\nohci_hash_rem_itd __P((ohci_softc_t *,\n\t\t\t    ohci_soft_itd_t *));\nStatic ohci_soft_itd_t;\nohci_rhsc_able __P((ohci_softc_t *, int));\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nvoid\nohci_free_sitd(sc, sitd)\n\tohci_softc_t *sc;\n\tohci_soft_itd_t *sitd;\n{\n\tint s;\n\n\tDPRINTFN(10,(\"ohci_free_sitd: sitd=%p\\n\", sitd));\n\n#ifdef DIAGNOSTIC\n\tif (!sitd->isdone) {\n\t\tpanic(\"ohci_free_sitd: sitd=%p not done\\n\", sitd);\n\t\treturn;\n\t}\n#endif\n\n\ts = splusb();\n\tohci_hash_rem_itd(sc, sitd);\n\tsitd->nextitd = sc->sc_freeitds;\n\tsc->sc_freeitds = sitd;\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ohci_close_pipe",
          "args": [
            "pipe",
            "sc->sc_isoc_head"
          ],
          "line": 3285
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_close_pipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "1974-2010",
          "snippet": "void\nohci_close_pipe(pipe, head)\n\tusbd_pipe_handle pipe;\n\tohci_soft_ed_t *head;\n{\n\tstruct ohci_pipe *opipe = (struct ohci_pipe *)pipe;\n\tohci_softc_t *sc = (ohci_softc_t *)pipe->device->bus;\n\tohci_soft_ed_t *sed = opipe->sed;\n\tint s;\n\n\ts = splusb();\n#ifdef DIAGNOSTIC\n\tsed->ed.ed_flags |= htole32(OHCI_ED_SKIP);\n\tif ((le32toh(sed->ed.ed_tailp) & OHCI_HEADMASK) != \n\t    (le32toh(sed->ed.ed_headp) & OHCI_HEADMASK)) {\n\t\tohci_physaddr_t td = le32toh(sed->ed.ed_headp);\n\t\tohci_soft_td_t *std;\n\t\tfor (std = LIST_FIRST(&sc->sc_hash_tds[HASH(td)]); \n\t\t     std != NULL;\n\t\t     std = LIST_NEXT(std, hnext))\n\t\t    if (std->physaddr == td)\n\t\t\tbreak;\n\t\tprintf(\"ohci_close_pipe: pipe not empty sed=%p hd=0x%x \"\n\t\t       \"tl=0x%x pipe=%p, std=%p\\n\", sed,\n\t\t       (int)le32toh(sed->ed.ed_headp),\n\t\t       (int)le32toh(sed->ed.ed_tailp),\n\t\t       pipe, std);\n\t\tusb_delay_ms(&sc->sc_bus, 2);\n\t\tif ((le32toh(sed->ed.ed_tailp) & OHCI_HEADMASK) != \n\t\t    (le32toh(sed->ed.ed_headp) & OHCI_HEADMASK))\n\t\t\tprintf(\"ohci_close_pipe: pipe still not empty\\n\");\n\t}\n#endif\n\tohci_rem_ed(sed, head);\n\tsplx(s);\n\tohci_free_sed(sc, opipe->sed);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static ohci_soft_ed_t",
            "ohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));",
            "Static ohci_soft_td_t",
            "ohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));",
            "ohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));",
            "ohci_open __P((usbd_pipe_handle));",
            "ohci_add_done __P((ohci_softc_t *, ohci_physaddr_t));",
            "ohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
            "ohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
            "ohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));",
            "ohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));",
            "Static ohci_soft_td_t",
            "ohci_setup_isoc __P((usbd_pipe_handle pipe));",
            "ohci_root_ctrl_close __P((usbd_pipe_handle));",
            "ohci_root_intr_close __P((usbd_pipe_handle));",
            "ohci_device_ctrl_close __P((usbd_pipe_handle));",
            "ohci_device_bulk_close __P((usbd_pipe_handle));",
            "ohci_device_intr_close __P((usbd_pipe_handle));",
            "ohci_device_isoc_close __P((usbd_pipe_handle));",
            "ohci_rhsc_able __P((ohci_softc_t *, int));",
            "ohci_close_pipe __P((usbd_pipe_handle pipe, \n\t\t\t    ohci_soft_ed_t *head));",
            "ohci_device_clear_toggle __P((usbd_pipe_handle pipe));",
            "ohci_noop __P((usbd_pipe_handle pipe));",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
            "ohci_intr1 __P((ohci_softc_t *));",
            "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_ed_t;\nohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));\nStatic ohci_soft_td_t;\nohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));\nohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));\nohci_open __P((usbd_pipe_handle));\nohci_add_done __P((ohci_softc_t *, ohci_physaddr_t));\nohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));\nohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));\nStatic ohci_soft_td_t;\nohci_setup_isoc __P((usbd_pipe_handle pipe));\nohci_root_ctrl_close __P((usbd_pipe_handle));\nohci_root_intr_close __P((usbd_pipe_handle));\nohci_device_ctrl_close __P((usbd_pipe_handle));\nohci_device_bulk_close __P((usbd_pipe_handle));\nohci_device_intr_close __P((usbd_pipe_handle));\nohci_device_isoc_close __P((usbd_pipe_handle));\nohci_rhsc_able __P((ohci_softc_t *, int));\nohci_close_pipe __P((usbd_pipe_handle pipe, \n\t\t\t    ohci_soft_ed_t *head));\nohci_device_clear_toggle __P((usbd_pipe_handle pipe));\nohci_noop __P((usbd_pipe_handle pipe));\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nvoid\nohci_close_pipe(pipe, head)\n\tusbd_pipe_handle pipe;\n\tohci_soft_ed_t *head;\n{\n\tstruct ohci_pipe *opipe = (struct ohci_pipe *)pipe;\n\tohci_softc_t *sc = (ohci_softc_t *)pipe->device->bus;\n\tohci_soft_ed_t *sed = opipe->sed;\n\tint s;\n\n\ts = splusb();\n#ifdef DIAGNOSTIC\n\tsed->ed.ed_flags |= htole32(OHCI_ED_SKIP);\n\tif ((le32toh(sed->ed.ed_tailp) & OHCI_HEADMASK) != \n\t    (le32toh(sed->ed.ed_headp) & OHCI_HEADMASK)) {\n\t\tohci_physaddr_t td = le32toh(sed->ed.ed_headp);\n\t\tohci_soft_td_t *std;\n\t\tfor (std = LIST_FIRST(&sc->sc_hash_tds[HASH(td)]); \n\t\t     std != NULL;\n\t\t     std = LIST_NEXT(std, hnext))\n\t\t    if (std->physaddr == td)\n\t\t\tbreak;\n\t\tprintf(\"ohci_close_pipe: pipe not empty sed=%p hd=0x%x \"\n\t\t       \"tl=0x%x pipe=%p, std=%p\\n\", sed,\n\t\t       (int)le32toh(sed->ed.ed_headp),\n\t\t       (int)le32toh(sed->ed.ed_tailp),\n\t\t       pipe, std);\n\t\tusb_delay_ms(&sc->sc_bus, 2);\n\t\tif ((le32toh(sed->ed.ed_tailp) & OHCI_HEADMASK) != \n\t\t    (le32toh(sed->ed.ed_headp) & OHCI_HEADMASK))\n\t\t\tprintf(\"ohci_close_pipe: pipe still not empty\\n\");\n\t}\n#endif\n\tohci_rem_ed(sed, head);\n\tsplx(s);\n\tohci_free_sed(sc, opipe->sed);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 3284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ohci_rem_ed",
          "args": [
            "opipe->sed",
            "sc->sc_isoc_head"
          ],
          "line": 3283
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_rem_ed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "1655-1671",
          "snippet": "void\nohci_rem_ed(sed, head)\n\tohci_soft_ed_t *sed; \n\tohci_soft_ed_t *head; \n{\n\tohci_soft_ed_t *p; \n\n\tSPLUSBCHECK;\n\n\t/* XXX */\n\tfor (p = head; p == NULL && p->next != sed; p = p->next)\n\t\t;\n\tif (p == NULL)\n\t\tpanic(\"ohci_rem_ed: ED not found\\n\");\n\tp->next = sed->next;\n\tp->ed.ed_nexted = sed->ed.ed_nexted;\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static ohci_soft_ed_t",
            "ohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));",
            "ohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
            "ohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
            "ohci_close_pipe __P((usbd_pipe_handle pipe, \n\t\t\t    ohci_soft_ed_t *head));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_ed_t;\nohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));\nohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nohci_close_pipe __P((usbd_pipe_handle pipe, \n\t\t\t    ohci_soft_ed_t *head));\n\nvoid\nohci_rem_ed(sed, head)\n\tohci_soft_ed_t *sed; \n\tohci_soft_ed_t *head; \n{\n\tohci_soft_ed_t *p; \n\n\tSPLUSBCHECK;\n\n\t/* XXX */\n\tfor (p = head; p == NULL && p->next != sed; p = p->next)\n\t\t;\n\tif (p == NULL)\n\t\tpanic(\"ohci_rem_ed: ED not found\\n\");\n\tp->next = sed->next;\n\tp->ed.ed_nexted = sed->ed.ed_nexted;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 3282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ohci_device_isoc_close: pipe=%p\\n\", pipe)"
          ],
          "line": 3280
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nohci_open __P((usbd_pipe_handle));\nohci_setup_isoc __P((usbd_pipe_handle pipe));\nohci_root_ctrl_close __P((usbd_pipe_handle));\nohci_root_intr_close __P((usbd_pipe_handle));\nohci_device_ctrl_close __P((usbd_pipe_handle));\nohci_device_bulk_close __P((usbd_pipe_handle));\nohci_device_intr_close __P((usbd_pipe_handle));\nohci_device_isoc_close __P((usbd_pipe_handle));\nohci_rhsc_able __P((ohci_softc_t *, int));\nohci_device_clear_toggle __P((usbd_pipe_handle pipe));\nohci_noop __P((usbd_pipe_handle pipe));\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nvoid\nohci_device_isoc_close(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tstruct ohci_pipe *opipe = (struct ohci_pipe *)pipe;\n\tohci_softc_t *sc = (ohci_softc_t *)pipe->device->bus;\n\tint s;\n\n\tDPRINTF((\"ohci_device_isoc_close: pipe=%p\\n\", pipe));\n\n\ts = splusb();\n\tohci_rem_ed(opipe->sed, sc->sc_isoc_head);\n\tsplx(s);\n\tohci_close_pipe(pipe, sc->sc_isoc_head);\n#ifdef DIAGNOSTIC\n\topipe->tail.itd->isdone = 1;\n#endif\n\tohci_free_sitd(sc, opipe->tail.itd);\n}"
  },
  {
    "function_name": "ohci_setup_isoc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "3253-3270",
    "snippet": "usbd_status\nohci_setup_isoc(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tstruct ohci_pipe *opipe = (struct ohci_pipe *)pipe;\n\tohci_softc_t *sc = (ohci_softc_t *)pipe->device->bus;\n\tstruct iso *iso = &opipe->u.iso;\n\tint s;\n\n\tiso->next = -1;\n\tiso->inuse = 0;\n\n\ts = splusb();\n\tohci_add_ed(opipe->sed, sc->sc_isoc_head);\n\tsplx(s);\n\n\treturn (USBD_NORMAL_COMPLETION);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static usbd_status",
      "Static usbd_status",
      "ohci_open __P((usbd_pipe_handle));",
      "Static usbd_status",
      "Static usbd_status",
      "ohci_setup_isoc __P((usbd_pipe_handle pipe));",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "ohci_root_ctrl_close __P((usbd_pipe_handle));",
      "Static usbd_status",
      "Static usbd_status",
      "ohci_root_intr_close __P((usbd_pipe_handle));",
      "Static usbd_status",
      "Static usbd_status",
      "ohci_device_ctrl_close __P((usbd_pipe_handle));",
      "Static usbd_status",
      "Static usbd_status",
      "ohci_device_bulk_close __P((usbd_pipe_handle));",
      "Static usbd_status",
      "Static usbd_status",
      "ohci_device_intr_close __P((usbd_pipe_handle));",
      "Static usbd_status",
      "Static usbd_status",
      "ohci_device_isoc_close __P((usbd_pipe_handle));",
      "Static usbd_status",
      "ohci_rhsc_able __P((ohci_softc_t *, int));",
      "ohci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "ohci_noop __P((usbd_pipe_handle pipe));",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
      "ohci_intr1 __P((ohci_softc_t *));",
      "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 3267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ohci_add_ed",
          "args": [
            "opipe->sed",
            "sc->sc_isoc_head"
          ],
          "line": 3266
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_add_ed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "1640-1650",
          "snippet": "void\nohci_add_ed(sed, head)\n\tohci_soft_ed_t *sed; \n\tohci_soft_ed_t *head; \n{\n\tSPLUSBCHECK;\n\tsed->next = head->next;\n\tsed->ed.ed_nexted = head->ed.ed_nexted;\n\thead->next = sed;\n\thead->ed.ed_nexted = htole32(sed->physaddr);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static ohci_soft_ed_t",
            "ohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));",
            "ohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
            "ohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
            "ohci_close_pipe __P((usbd_pipe_handle pipe, \n\t\t\t    ohci_soft_ed_t *head));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_ed_t;\nohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));\nohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nohci_close_pipe __P((usbd_pipe_handle pipe, \n\t\t\t    ohci_soft_ed_t *head));\n\nvoid\nohci_add_ed(sed, head)\n\tohci_soft_ed_t *sed; \n\tohci_soft_ed_t *head; \n{\n\tSPLUSBCHECK;\n\tsed->next = head->next;\n\tsed->ed.ed_nexted = head->ed.ed_nexted;\n\thead->next = sed;\n\thead->ed.ed_nexted = htole32(sed->physaddr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 3265
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nStatic usbd_status;\nohci_open __P((usbd_pipe_handle));\nStatic usbd_status;\nStatic usbd_status;\nohci_setup_isoc __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nohci_root_ctrl_close __P((usbd_pipe_handle));\nStatic usbd_status;\nStatic usbd_status;\nohci_root_intr_close __P((usbd_pipe_handle));\nStatic usbd_status;\nStatic usbd_status;\nohci_device_ctrl_close __P((usbd_pipe_handle));\nStatic usbd_status;\nStatic usbd_status;\nohci_device_bulk_close __P((usbd_pipe_handle));\nStatic usbd_status;\nStatic usbd_status;\nohci_device_intr_close __P((usbd_pipe_handle));\nStatic usbd_status;\nStatic usbd_status;\nohci_device_isoc_close __P((usbd_pipe_handle));\nStatic usbd_status;\nohci_rhsc_able __P((ohci_softc_t *, int));\nohci_device_clear_toggle __P((usbd_pipe_handle pipe));\nohci_noop __P((usbd_pipe_handle pipe));\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nusbd_status\nohci_setup_isoc(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tstruct ohci_pipe *opipe = (struct ohci_pipe *)pipe;\n\tohci_softc_t *sc = (ohci_softc_t *)pipe->device->bus;\n\tstruct iso *iso = &opipe->u.iso;\n\tint s;\n\n\tiso->next = -1;\n\tiso->inuse = 0;\n\n\ts = splusb();\n\tohci_add_ed(opipe->sed, sc->sc_isoc_head);\n\tsplx(s);\n\n\treturn (USBD_NORMAL_COMPLETION);\n}"
  },
  {
    "function_name": "ohci_device_isoc_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "3232-3251",
    "snippet": "void\nohci_device_isoc_done(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tstruct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;\n\tohci_softc_t *sc = (ohci_softc_t *)opipe->pipe.device->bus;\n\tohci_soft_itd_t *sitd, *nsitd;\t\n\n\tDPRINTFN(1,(\"ohci_device_isoc_done: xfer=%p\\n\", xfer));\n\n\tfor (sitd = xfer->hcpriv;\n\t     !(sitd->flags & OHCI_CALL_DONE);\n\t     sitd = nsitd) {\n\t\tnsitd = sitd->nextitd;\n\t\tDPRINTFN(1,(\"ohci_device_isoc_done: free sitd=%p\\n\", sitd));\n\t\tohci_free_sitd(sc, sitd);\n\t}\n\tohci_free_sitd(sc, sitd);\n\txfer->hcpriv = NULL;\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static ohci_soft_itd_t",
      "ohci_free_sitd __P((ohci_softc_t *,ohci_soft_itd_t *));",
      "ohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));",
      "ohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));",
      "ohci_device_request __P((usbd_xfer_handle xfer));",
      "ohci_hash_add_itd __P((ohci_softc_t *, \n\t\t\t    ohci_soft_itd_t *));",
      "ohci_hash_rem_itd __P((ohci_softc_t *,\n\t\t\t    ohci_soft_itd_t *));",
      "Static ohci_soft_itd_t",
      "ohci_setup_isoc __P((usbd_pipe_handle pipe));",
      "ohci_device_isoc_enter __P((usbd_xfer_handle));",
      "Static usbd_xfer_handle",
      "ohci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "ohci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "ohci_root_ctrl_start __P((usbd_xfer_handle));",
      "ohci_root_ctrl_abort __P((usbd_xfer_handle));",
      "ohci_root_ctrl_done  __P((usbd_xfer_handle));",
      "ohci_root_intr_transfer __P((usbd_xfer_handle));",
      "ohci_root_intr_start __P((usbd_xfer_handle));",
      "ohci_root_intr_abort __P((usbd_xfer_handle));",
      "ohci_root_intr_done  __P((usbd_xfer_handle));",
      "ohci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "ohci_device_ctrl_start __P((usbd_xfer_handle));",
      "ohci_device_ctrl_abort __P((usbd_xfer_handle));",
      "ohci_device_ctrl_done  __P((usbd_xfer_handle));",
      "ohci_device_bulk_transfer __P((usbd_xfer_handle));",
      "ohci_device_bulk_start __P((usbd_xfer_handle));",
      "ohci_device_bulk_abort __P((usbd_xfer_handle));",
      "ohci_device_bulk_done  __P((usbd_xfer_handle));",
      "ohci_device_intr_transfer __P((usbd_xfer_handle));",
      "ohci_device_intr_start __P((usbd_xfer_handle));",
      "ohci_device_intr_abort __P((usbd_xfer_handle));",
      "ohci_device_intr_done  __P((usbd_xfer_handle));",
      "ohci_device_isoc_transfer __P((usbd_xfer_handle));",
      "ohci_device_isoc_start __P((usbd_xfer_handle));",
      "ohci_device_isoc_abort __P((usbd_xfer_handle));",
      "ohci_device_isoc_done  __P((usbd_xfer_handle));",
      "ohci_rhsc_able __P((ohci_softc_t *, int));",
      "ohci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "ohci_noop __P((usbd_pipe_handle pipe));",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
      "ohci_intr1 __P((ohci_softc_t *));",
      "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ohci_free_sitd",
          "args": [
            "sc",
            "sitd"
          ],
          "line": 3249
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_free_sitd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "632-653",
          "snippet": "void\nohci_free_sitd(sc, sitd)\n\tohci_softc_t *sc;\n\tohci_soft_itd_t *sitd;\n{\n\tint s;\n\n\tDPRINTFN(10,(\"ohci_free_sitd: sitd=%p\\n\", sitd));\n\n#ifdef DIAGNOSTIC\n\tif (!sitd->isdone) {\n\t\tpanic(\"ohci_free_sitd: sitd=%p not done\\n\", sitd);\n\t\treturn;\n\t}\n#endif\n\n\ts = splusb();\n\tohci_hash_rem_itd(sc, sitd);\n\tsitd->nextitd = sc->sc_freeitds;\n\tsc->sc_freeitds = sitd;\n\tsplx(s);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static ohci_soft_itd_t",
            "ohci_free_sitd __P((ohci_softc_t *,ohci_soft_itd_t *));",
            "ohci_hash_add_itd __P((ohci_softc_t *, \n\t\t\t    ohci_soft_itd_t *));",
            "ohci_hash_rem_itd __P((ohci_softc_t *,\n\t\t\t    ohci_soft_itd_t *));",
            "Static ohci_soft_itd_t",
            "ohci_rhsc_able __P((ohci_softc_t *, int));",
            "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
            "ohci_intr1 __P((ohci_softc_t *));",
            "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_itd_t;\nohci_free_sitd __P((ohci_softc_t *,ohci_soft_itd_t *));\nohci_hash_add_itd __P((ohci_softc_t *, \n\t\t\t    ohci_soft_itd_t *));\nohci_hash_rem_itd __P((ohci_softc_t *,\n\t\t\t    ohci_soft_itd_t *));\nStatic ohci_soft_itd_t;\nohci_rhsc_able __P((ohci_softc_t *, int));\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nvoid\nohci_free_sitd(sc, sitd)\n\tohci_softc_t *sc;\n\tohci_soft_itd_t *sitd;\n{\n\tint s;\n\n\tDPRINTFN(10,(\"ohci_free_sitd: sitd=%p\\n\", sitd));\n\n#ifdef DIAGNOSTIC\n\tif (!sitd->isdone) {\n\t\tpanic(\"ohci_free_sitd: sitd=%p not done\\n\", sitd);\n\t\treturn;\n\t}\n#endif\n\n\ts = splusb();\n\tohci_hash_rem_itd(sc, sitd);\n\tsitd->nextitd = sc->sc_freeitds;\n\tsc->sc_freeitds = sitd;\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"ohci_device_isoc_done: free sitd=%p\\n\", sitd)"
          ],
          "line": 3246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"ohci_device_isoc_done: xfer=%p\\n\", xfer)"
          ],
          "line": 3240
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_itd_t;\nohci_free_sitd __P((ohci_softc_t *,ohci_soft_itd_t *));\nohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));\nohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));\nohci_device_request __P((usbd_xfer_handle xfer));\nohci_hash_add_itd __P((ohci_softc_t *, \n\t\t\t    ohci_soft_itd_t *));\nohci_hash_rem_itd __P((ohci_softc_t *,\n\t\t\t    ohci_soft_itd_t *));\nStatic ohci_soft_itd_t;\nohci_setup_isoc __P((usbd_pipe_handle pipe));\nohci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_xfer_handle;\nohci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nohci_root_ctrl_transfer __P((usbd_xfer_handle));\nohci_root_ctrl_start __P((usbd_xfer_handle));\nohci_root_ctrl_abort __P((usbd_xfer_handle));\nohci_root_ctrl_done  __P((usbd_xfer_handle));\nohci_root_intr_transfer __P((usbd_xfer_handle));\nohci_root_intr_start __P((usbd_xfer_handle));\nohci_root_intr_abort __P((usbd_xfer_handle));\nohci_root_intr_done  __P((usbd_xfer_handle));\nohci_device_ctrl_transfer __P((usbd_xfer_handle));\nohci_device_ctrl_start __P((usbd_xfer_handle));\nohci_device_ctrl_abort __P((usbd_xfer_handle));\nohci_device_ctrl_done  __P((usbd_xfer_handle));\nohci_device_bulk_transfer __P((usbd_xfer_handle));\nohci_device_bulk_start __P((usbd_xfer_handle));\nohci_device_bulk_abort __P((usbd_xfer_handle));\nohci_device_bulk_done  __P((usbd_xfer_handle));\nohci_device_intr_transfer __P((usbd_xfer_handle));\nohci_device_intr_start __P((usbd_xfer_handle));\nohci_device_intr_abort __P((usbd_xfer_handle));\nohci_device_intr_done  __P((usbd_xfer_handle));\nohci_device_isoc_transfer __P((usbd_xfer_handle));\nohci_device_isoc_start __P((usbd_xfer_handle));\nohci_device_isoc_abort __P((usbd_xfer_handle));\nohci_device_isoc_done  __P((usbd_xfer_handle));\nohci_rhsc_able __P((ohci_softc_t *, int));\nohci_device_clear_toggle __P((usbd_pipe_handle pipe));\nohci_noop __P((usbd_pipe_handle pipe));\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nvoid\nohci_device_isoc_done(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tstruct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;\n\tohci_softc_t *sc = (ohci_softc_t *)opipe->pipe.device->bus;\n\tohci_soft_itd_t *sitd, *nsitd;\t\n\n\tDPRINTFN(1,(\"ohci_device_isoc_done: xfer=%p\\n\", xfer));\n\n\tfor (sitd = xfer->hcpriv;\n\t     !(sitd->flags & OHCI_CALL_DONE);\n\t     sitd = nsitd) {\n\t\tnsitd = sitd->nextitd;\n\t\tDPRINTFN(1,(\"ohci_device_isoc_done: free sitd=%p\\n\", sitd));\n\t\tohci_free_sitd(sc, sitd);\n\t}\n\tohci_free_sitd(sc, sitd);\n\txfer->hcpriv = NULL;\n}"
  },
  {
    "function_name": "ohci_device_isoc_abort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "3175-3230",
    "snippet": "void\nohci_device_isoc_abort(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tstruct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;\n\tohci_softc_t *sc = (ohci_softc_t *)opipe->pipe.device->bus;\n\tohci_soft_ed_t *sed;\n\tohci_soft_itd_t *sitd;\n\tint s;\n\n\ts = splusb();\n\n\tDPRINTFN(1,(\"ohci_device_isoc_abort: xfer=%p\\n\", xfer));\n\n\t/* Transfer is already done. */\n\tif (xfer->status != USBD_NOT_STARTED && \n\t    xfer->status != USBD_IN_PROGRESS) {\n\t\tsplx(s);\n\t\tprintf(\"ohci_device_isoc_abort: early return\\n\");\n\t\treturn;\n\t}\n\n\t/* Give xfer the requested abort code. */\n\txfer->status = USBD_CANCELLED;\n\n\tsed = opipe->sed;\n\tsed->ed.ed_flags |= htole32(OHCI_ED_SKIP); /* force hardware skip */\n\n\tsitd = xfer->hcpriv;\n#ifdef DIAGNOSTIC\n\tif (sitd == NULL) {\n\t\tprintf(\"ohci_device_isoc_abort: hcpriv==0\\n\");\n\t\treturn;\n\t}\n#endif\n\tfor (; sitd->xfer == xfer; sitd = sitd->nextitd) {\n#ifdef DIAGNOSTIC\n\t\tDPRINTFN(1,(\"abort sets done sitd=%p\\n\", sitd));\n\t\tsitd->isdone = 1;\n#endif\n\t}\n\n\tsplx(s);\n\n\tusb_delay_ms(&sc->sc_bus, OHCI_ITD_NOFFSET);\n\n\ts = splusb();\n\n\t/* Run callback. */\n\tusb_transfer_complete(xfer);\n\n\tsed->ed.ed_headp = htole32(sitd->physaddr); /* unlink TDs */\n\tsed->ed.ed_flags &= htole32(~OHCI_ED_SKIP); /* remove hardware skip */\n\n\tsplx(s);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static ohci_soft_ed_t",
      "ohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));",
      "Static ohci_soft_itd_t",
      "ohci_free_sitd __P((ohci_softc_t *,ohci_soft_itd_t *));",
      "ohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));",
      "ohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));",
      "ohci_device_request __P((usbd_xfer_handle xfer));",
      "ohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
      "ohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
      "ohci_hash_add_itd __P((ohci_softc_t *, \n\t\t\t    ohci_soft_itd_t *));",
      "ohci_hash_rem_itd __P((ohci_softc_t *,\n\t\t\t    ohci_soft_itd_t *));",
      "Static ohci_soft_itd_t",
      "ohci_setup_isoc __P((usbd_pipe_handle pipe));",
      "ohci_device_isoc_enter __P((usbd_xfer_handle));",
      "Static usbd_xfer_handle",
      "ohci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "ohci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "ohci_root_ctrl_start __P((usbd_xfer_handle));",
      "ohci_root_ctrl_abort __P((usbd_xfer_handle));",
      "ohci_root_ctrl_done  __P((usbd_xfer_handle));",
      "ohci_root_intr_transfer __P((usbd_xfer_handle));",
      "ohci_root_intr_start __P((usbd_xfer_handle));",
      "ohci_root_intr_abort __P((usbd_xfer_handle));",
      "ohci_root_intr_done  __P((usbd_xfer_handle));",
      "ohci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "ohci_device_ctrl_start __P((usbd_xfer_handle));",
      "ohci_device_ctrl_abort __P((usbd_xfer_handle));",
      "ohci_device_ctrl_done  __P((usbd_xfer_handle));",
      "ohci_device_bulk_transfer __P((usbd_xfer_handle));",
      "ohci_device_bulk_start __P((usbd_xfer_handle));",
      "ohci_device_bulk_abort __P((usbd_xfer_handle));",
      "ohci_device_bulk_done  __P((usbd_xfer_handle));",
      "ohci_device_intr_transfer __P((usbd_xfer_handle));",
      "ohci_device_intr_start __P((usbd_xfer_handle));",
      "ohci_device_intr_abort __P((usbd_xfer_handle));",
      "ohci_device_intr_done  __P((usbd_xfer_handle));",
      "ohci_device_isoc_transfer __P((usbd_xfer_handle));",
      "ohci_device_isoc_start __P((usbd_xfer_handle));",
      "ohci_device_isoc_abort __P((usbd_xfer_handle));",
      "ohci_device_isoc_done  __P((usbd_xfer_handle));",
      "ohci_rhsc_able __P((ohci_softc_t *, int));",
      "ohci_abort_xfer __P((usbd_xfer_handle xfer,\n\t\t\t    usbd_status status));",
      "ohci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "ohci_noop __P((usbd_pipe_handle pipe));",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
      "ohci_intr1 __P((ohci_softc_t *));",
      "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 3229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "~OHCI_ED_SKIP"
          ],
          "line": 3227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "sitd->physaddr"
          ],
          "line": 3226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_transfer_complete",
          "args": [
            "xfer"
          ],
          "line": 3224
        },
        "resolved": true,
        "details": {
          "function_name": "usb_transfer_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "789-883",
          "snippet": "void\nusb_transfer_complete(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tint repeat = pipe->repeat;\n\tint polling;\n\n\tSPLUSBCHECK;\n\n\tDPRINTFN(5, (\"usb_transfer_complete: pipe=%p xfer=%p status=%d \"\n\t\t     \"actlen=%d\\n\", pipe, xfer, xfer->status, xfer->actlen));\n\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_transfer_cb: pipe==0, xfer=%p\\n\", xfer);\n\t\treturn;\n\t}\n#endif\n\tpolling = pipe->device->bus->use_polling;\n\t/* XXXX */\n\tif (polling)\n\t\tpipe->running = 0;\n\n\tif (!(xfer->flags & USBD_NO_COPY) && xfer->actlen != 0 &&\n\t    usbd_xfer_isread(xfer)) {\n#ifdef DIAGNOSTIC\n\t\tif (xfer->actlen > xfer->length) {\n\t\t\tprintf(\"usb_transfer_complete: actlen > len %d > %d\\n\",\n\t\t\t       xfer->actlen, xfer->length);\n\t\t\txfer->actlen = xfer->length;\n\t\t}\n#endif\n\t\tmemcpy(xfer->buffer, KERNADDR(dmap), xfer->actlen);\n\t}\n\n\t/* if we allocated the buffer in usbd_transfer() we free it here. */\n\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\tif (!repeat) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\t\t\tbus->methods->freem(bus, dmap);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!repeat) {\n\t\t/* Remove request from queue. */\n#ifdef DIAGNOSTIC\n\t\tif (xfer != SIMPLEQ_FIRST(&pipe->queue))\n\t\t\tprintf(\"usb_transfer_complete: bad dequeue %p != %p\\n\",\n\t\t\t       xfer, SIMPLEQ_FIRST(&pipe->queue));\n#endif\n\t\tSIMPLEQ_REMOVE_HEAD(&pipe->queue, xfer, next);\n\t}\n\tDPRINTFN(5,(\"usb_transfer_complete: repeat=%d new head=%p\\n\", \n\t\t    repeat, SIMPLEQ_FIRST(&pipe->queue)));\n\n\t/* Count completed transfers. */\n\t++pipe->device->bus->stats.requests\n\t\t[pipe->endpoint->edesc->bmAttributes & UE_XFERTYPE];\n\n\txfer->done = 1;\n\tif (!xfer->status && xfer->actlen < xfer->length &&\n\t    !(xfer->flags & USBD_SHORT_XFER_OK)) {\n\t\tDPRINTFN(-1,(\"usbd_transfer_cb: short transfer %d<%d\\n\",\n\t\t\t     xfer->actlen, xfer->length));\n\t\txfer->status = USBD_SHORT_XFER;\n\t}\n\n\tif (xfer->callback)\n\t\txfer->callback(xfer, xfer->priv, xfer->status);\n\n#ifdef DIAGNOSTIC\n\tif (pipe->methods->done != NULL)\n\t\tpipe->methods->done(xfer);\n\telse\n\t\tprintf(\"usb_transfer_complete: pipe->methods->done == NULL\\n\");\n#else\n\tpipe->methods->done(xfer);\n#endif\n\n\tif ((xfer->flags & USBD_SYNCHRONOUS) && !polling)\n\t\twakeup(xfer);\n\n\tif (!repeat) {\n\t\t/* XXX should we stop the queue on all errors? */\n\t\tif ((xfer->status == USBD_CANCELLED ||\n\t\t     xfer->status == USBD_TIMEOUT) &&\n\t\t    pipe->iface != NULL)\t\t/* not control pipe */\n\t\t\tpipe->running = 0;\n\t\telse\n\t\t\tusbd_start_next(pipe);\n\t}\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "usb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;",
            "usb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);",
            "usb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_start_next __P((usbd_pipe_handle pipe));\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nusb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;\nusb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\nusb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;\n\nvoid\nusb_transfer_complete(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tint repeat = pipe->repeat;\n\tint polling;\n\n\tSPLUSBCHECK;\n\n\tDPRINTFN(5, (\"usb_transfer_complete: pipe=%p xfer=%p status=%d \"\n\t\t     \"actlen=%d\\n\", pipe, xfer, xfer->status, xfer->actlen));\n\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_transfer_cb: pipe==0, xfer=%p\\n\", xfer);\n\t\treturn;\n\t}\n#endif\n\tpolling = pipe->device->bus->use_polling;\n\t/* XXXX */\n\tif (polling)\n\t\tpipe->running = 0;\n\n\tif (!(xfer->flags & USBD_NO_COPY) && xfer->actlen != 0 &&\n\t    usbd_xfer_isread(xfer)) {\n#ifdef DIAGNOSTIC\n\t\tif (xfer->actlen > xfer->length) {\n\t\t\tprintf(\"usb_transfer_complete: actlen > len %d > %d\\n\",\n\t\t\t       xfer->actlen, xfer->length);\n\t\t\txfer->actlen = xfer->length;\n\t\t}\n#endif\n\t\tmemcpy(xfer->buffer, KERNADDR(dmap), xfer->actlen);\n\t}\n\n\t/* if we allocated the buffer in usbd_transfer() we free it here. */\n\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\tif (!repeat) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\t\t\tbus->methods->freem(bus, dmap);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!repeat) {\n\t\t/* Remove request from queue. */\n#ifdef DIAGNOSTIC\n\t\tif (xfer != SIMPLEQ_FIRST(&pipe->queue))\n\t\t\tprintf(\"usb_transfer_complete: bad dequeue %p != %p\\n\",\n\t\t\t       xfer, SIMPLEQ_FIRST(&pipe->queue));\n#endif\n\t\tSIMPLEQ_REMOVE_HEAD(&pipe->queue, xfer, next);\n\t}\n\tDPRINTFN(5,(\"usb_transfer_complete: repeat=%d new head=%p\\n\", \n\t\t    repeat, SIMPLEQ_FIRST(&pipe->queue)));\n\n\t/* Count completed transfers. */\n\t++pipe->device->bus->stats.requests\n\t\t[pipe->endpoint->edesc->bmAttributes & UE_XFERTYPE];\n\n\txfer->done = 1;\n\tif (!xfer->status && xfer->actlen < xfer->length &&\n\t    !(xfer->flags & USBD_SHORT_XFER_OK)) {\n\t\tDPRINTFN(-1,(\"usbd_transfer_cb: short transfer %d<%d\\n\",\n\t\t\t     xfer->actlen, xfer->length));\n\t\txfer->status = USBD_SHORT_XFER;\n\t}\n\n\tif (xfer->callback)\n\t\txfer->callback(xfer, xfer->priv, xfer->status);\n\n#ifdef DIAGNOSTIC\n\tif (pipe->methods->done != NULL)\n\t\tpipe->methods->done(xfer);\n\telse\n\t\tprintf(\"usb_transfer_complete: pipe->methods->done == NULL\\n\");\n#else\n\tpipe->methods->done(xfer);\n#endif\n\n\tif ((xfer->flags & USBD_SYNCHRONOUS) && !polling)\n\t\twakeup(xfer);\n\n\tif (!repeat) {\n\t\t/* XXX should we stop the queue on all errors? */\n\t\tif ((xfer->status == USBD_CANCELLED ||\n\t\t     xfer->status == USBD_TIMEOUT) &&\n\t\t    pipe->iface != NULL)\t\t/* not control pipe */\n\t\t\tpipe->running = 0;\n\t\telse\n\t\t\tusbd_start_next(pipe);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 3221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_delay_ms",
          "args": [
            "&sc->sc_bus",
            "OHCI_ITD_NOFFSET"
          ],
          "line": 3219
        },
        "resolved": true,
        "details": {
          "function_name": "usb_delay_ms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "301-313",
          "snippet": "void\nusb_delay_ms(bus, ms)\n\tusbd_bus_handle bus;\n\tu_int ms;\n{\n\textern int cold;\n\n\t/* Wait at least two clock ticks so we know the time has passed. */\n\tif (bus->use_polling || cold)\n\t\tdelay((ms+1) * 1000);\n\telse\n\t\ttsleep(&ms, PRIBIO, \"usbdly\", (ms*hz+999)/1000 + 1);\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_getnewaddr __P((usbd_bus_handle bus));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_getnewaddr __P((usbd_bus_handle bus));\n\nvoid\nusb_delay_ms(bus, ms)\n\tusbd_bus_handle bus;\n\tu_int ms;\n{\n\textern int cold;\n\n\t/* Wait at least two clock ticks so we know the time has passed. */\n\tif (bus->use_polling || cold)\n\t\tdelay((ms+1) * 1000);\n\telse\n\t\ttsleep(&ms, PRIBIO, \"usbdly\", (ms*hz+999)/1000 + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 3217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"abort sets done sitd=%p\\n\", sitd)"
          ],
          "line": 3212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ohci_device_isoc_abort: hcpriv==0\\n\""
          ],
          "line": 3206
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "OHCI_ED_SKIP"
          ],
          "line": 3201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 3192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"ohci_device_isoc_abort: xfer=%p\\n\", xfer)"
          ],
          "line": 3187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 3185
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_ed_t;\nohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));\nStatic ohci_soft_itd_t;\nohci_free_sitd __P((ohci_softc_t *,ohci_soft_itd_t *));\nohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));\nohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));\nohci_device_request __P((usbd_xfer_handle xfer));\nohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nohci_hash_add_itd __P((ohci_softc_t *, \n\t\t\t    ohci_soft_itd_t *));\nohci_hash_rem_itd __P((ohci_softc_t *,\n\t\t\t    ohci_soft_itd_t *));\nStatic ohci_soft_itd_t;\nohci_setup_isoc __P((usbd_pipe_handle pipe));\nohci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_xfer_handle;\nohci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nohci_root_ctrl_transfer __P((usbd_xfer_handle));\nohci_root_ctrl_start __P((usbd_xfer_handle));\nohci_root_ctrl_abort __P((usbd_xfer_handle));\nohci_root_ctrl_done  __P((usbd_xfer_handle));\nohci_root_intr_transfer __P((usbd_xfer_handle));\nohci_root_intr_start __P((usbd_xfer_handle));\nohci_root_intr_abort __P((usbd_xfer_handle));\nohci_root_intr_done  __P((usbd_xfer_handle));\nohci_device_ctrl_transfer __P((usbd_xfer_handle));\nohci_device_ctrl_start __P((usbd_xfer_handle));\nohci_device_ctrl_abort __P((usbd_xfer_handle));\nohci_device_ctrl_done  __P((usbd_xfer_handle));\nohci_device_bulk_transfer __P((usbd_xfer_handle));\nohci_device_bulk_start __P((usbd_xfer_handle));\nohci_device_bulk_abort __P((usbd_xfer_handle));\nohci_device_bulk_done  __P((usbd_xfer_handle));\nohci_device_intr_transfer __P((usbd_xfer_handle));\nohci_device_intr_start __P((usbd_xfer_handle));\nohci_device_intr_abort __P((usbd_xfer_handle));\nohci_device_intr_done  __P((usbd_xfer_handle));\nohci_device_isoc_transfer __P((usbd_xfer_handle));\nohci_device_isoc_start __P((usbd_xfer_handle));\nohci_device_isoc_abort __P((usbd_xfer_handle));\nohci_device_isoc_done  __P((usbd_xfer_handle));\nohci_rhsc_able __P((ohci_softc_t *, int));\nohci_abort_xfer __P((usbd_xfer_handle xfer,\n\t\t\t    usbd_status status));\nohci_device_clear_toggle __P((usbd_pipe_handle pipe));\nohci_noop __P((usbd_pipe_handle pipe));\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nvoid\nohci_device_isoc_abort(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tstruct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;\n\tohci_softc_t *sc = (ohci_softc_t *)opipe->pipe.device->bus;\n\tohci_soft_ed_t *sed;\n\tohci_soft_itd_t *sitd;\n\tint s;\n\n\ts = splusb();\n\n\tDPRINTFN(1,(\"ohci_device_isoc_abort: xfer=%p\\n\", xfer));\n\n\t/* Transfer is already done. */\n\tif (xfer->status != USBD_NOT_STARTED && \n\t    xfer->status != USBD_IN_PROGRESS) {\n\t\tsplx(s);\n\t\tprintf(\"ohci_device_isoc_abort: early return\\n\");\n\t\treturn;\n\t}\n\n\t/* Give xfer the requested abort code. */\n\txfer->status = USBD_CANCELLED;\n\n\tsed = opipe->sed;\n\tsed->ed.ed_flags |= htole32(OHCI_ED_SKIP); /* force hardware skip */\n\n\tsitd = xfer->hcpriv;\n#ifdef DIAGNOSTIC\n\tif (sitd == NULL) {\n\t\tprintf(\"ohci_device_isoc_abort: hcpriv==0\\n\");\n\t\treturn;\n\t}\n#endif\n\tfor (; sitd->xfer == xfer; sitd = sitd->nextitd) {\n#ifdef DIAGNOSTIC\n\t\tDPRINTFN(1,(\"abort sets done sitd=%p\\n\", sitd));\n\t\tsitd->isdone = 1;\n#endif\n\t}\n\n\tsplx(s);\n\n\tusb_delay_ms(&sc->sc_bus, OHCI_ITD_NOFFSET);\n\n\ts = splusb();\n\n\t/* Run callback. */\n\tusb_transfer_complete(xfer);\n\n\tsed->ed.ed_headp = htole32(sitd->physaddr); /* unlink TDs */\n\tsed->ed.ed_flags &= htole32(~OHCI_ED_SKIP); /* remove hardware skip */\n\n\tsplx(s);\n}"
  },
  {
    "function_name": "ohci_device_isoc_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "3153-3173",
    "snippet": "usbd_status\nohci_device_isoc_start(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tstruct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;\n\tohci_softc_t *sc = (ohci_softc_t *)opipe->pipe.device->bus;\n\n\tDPRINTFN(5,(\"ohci_device_isoc_start: xfer=%p\\n\", xfer));\n\n\tif (sc->sc_dying)\n\t\treturn (USBD_IOERROR);\n\n#ifdef DIAGNOSTIC\n\tif (xfer->status != USBD_IN_PROGRESS)\n\t\tprintf(\"uhci_device_isoc_start: not in progress %p\\n\", xfer);\n#endif\n\n\t/* XXX anything to do? */\n\n\treturn (USBD_IN_PROGRESS);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static usbd_status",
      "Static usbd_status",
      "ohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));",
      "ohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_request __P((usbd_xfer_handle xfer));",
      "Static usbd_status",
      "ohci_setup_isoc __P((usbd_pipe_handle pipe));",
      "ohci_device_isoc_enter __P((usbd_xfer_handle));",
      "Static usbd_status",
      "Static usbd_xfer_handle",
      "ohci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_root_ctrl_start __P((usbd_xfer_handle));",
      "ohci_root_ctrl_abort __P((usbd_xfer_handle));",
      "ohci_root_ctrl_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_root_intr_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_root_intr_start __P((usbd_xfer_handle));",
      "ohci_root_intr_abort __P((usbd_xfer_handle));",
      "ohci_root_intr_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_ctrl_start __P((usbd_xfer_handle));",
      "ohci_device_ctrl_abort __P((usbd_xfer_handle));",
      "ohci_device_ctrl_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_bulk_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_bulk_start __P((usbd_xfer_handle));",
      "ohci_device_bulk_abort __P((usbd_xfer_handle));",
      "ohci_device_bulk_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_intr_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_intr_start __P((usbd_xfer_handle));",
      "ohci_device_intr_abort __P((usbd_xfer_handle));",
      "ohci_device_intr_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_isoc_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_isoc_start __P((usbd_xfer_handle));",
      "ohci_device_isoc_abort __P((usbd_xfer_handle));",
      "ohci_device_isoc_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_rhsc_able __P((ohci_softc_t *, int));",
      "ohci_abort_xfer __P((usbd_xfer_handle xfer,\n\t\t\t    usbd_status status));",
      "ohci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "ohci_noop __P((usbd_pipe_handle pipe));",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
      "ohci_intr1 __P((ohci_softc_t *));",
      "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"uhci_device_isoc_start: not in progress %p\\n\"",
            "xfer"
          ],
          "line": 3167
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"ohci_device_isoc_start: xfer=%p\\n\", xfer)"
          ],
          "line": 3160
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nStatic usbd_status;\nohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));\nohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));\nStatic usbd_status;\nohci_device_request __P((usbd_xfer_handle xfer));\nStatic usbd_status;\nohci_setup_isoc __P((usbd_pipe_handle pipe));\nohci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic usbd_xfer_handle;\nohci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nStatic usbd_status;\nohci_root_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_ctrl_start __P((usbd_xfer_handle));\nohci_root_ctrl_abort __P((usbd_xfer_handle));\nohci_root_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_intr_start __P((usbd_xfer_handle));\nohci_root_intr_abort __P((usbd_xfer_handle));\nohci_root_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_ctrl_start __P((usbd_xfer_handle));\nohci_device_ctrl_abort __P((usbd_xfer_handle));\nohci_device_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_bulk_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_bulk_start __P((usbd_xfer_handle));\nohci_device_bulk_abort __P((usbd_xfer_handle));\nohci_device_bulk_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_intr_start __P((usbd_xfer_handle));\nohci_device_intr_abort __P((usbd_xfer_handle));\nohci_device_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_isoc_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_isoc_start __P((usbd_xfer_handle));\nohci_device_isoc_abort __P((usbd_xfer_handle));\nohci_device_isoc_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_rhsc_able __P((ohci_softc_t *, int));\nohci_abort_xfer __P((usbd_xfer_handle xfer,\n\t\t\t    usbd_status status));\nohci_device_clear_toggle __P((usbd_pipe_handle pipe));\nohci_noop __P((usbd_pipe_handle pipe));\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nusbd_status\nohci_device_isoc_start(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tstruct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;\n\tohci_softc_t *sc = (ohci_softc_t *)opipe->pipe.device->bus;\n\n\tDPRINTFN(5,(\"ohci_device_isoc_start: xfer=%p\\n\", xfer));\n\n\tif (sc->sc_dying)\n\t\treturn (USBD_IOERROR);\n\n#ifdef DIAGNOSTIC\n\tif (xfer->status != USBD_IN_PROGRESS)\n\t\tprintf(\"uhci_device_isoc_start: not in progress %p\\n\", xfer);\n#endif\n\n\t/* XXX anything to do? */\n\n\treturn (USBD_IN_PROGRESS);\n}"
  },
  {
    "function_name": "ohci_device_isoc_enter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "3032-3151",
    "snippet": "void\nohci_device_isoc_enter(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tstruct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;\n\tusbd_device_handle dev = opipe->pipe.device;\n\tohci_softc_t *sc = (ohci_softc_t *)dev->bus;\n\tohci_soft_ed_t *sed = opipe->sed;\n\tstruct iso *iso = &opipe->u.iso;\n\tohci_soft_itd_t *sitd, *nsitd;\t\n\tohci_physaddr_t buf, offs, noffs, bp0;\n\tint i, ncur, nframes;\n\tint s;\n\n\tDPRINTFN(1,(\"ohci_device_isoc_enter: used=%d next=%d xfer=%p \"\n\t\t    \"nframes=%d\\n\",\n\t\t    iso->inuse, iso->next, xfer, xfer->nframes));\n\n\tif (sc->sc_dying)\n\t\treturn;\n\n\tif (iso->next == -1) {\n\t\t/* Not in use yet, schedule it a few frames ahead. */\n\t\tiso->next = le32toh(sc->sc_hcca->hcca_frame_number) + 5;\n\t\tDPRINTFN(2,(\"ohci_device_isoc_enter: start next=%d\\n\", \n\t\t\t    iso->next));\n\t}\n\n\tsitd = opipe->tail.itd;\n\tbuf = DMAADDR(&xfer->dmabuf);\n\tbp0 = OHCI_PAGE(buf);\n\toffs = OHCI_PAGE_OFFSET(buf);\n\tnframes = xfer->nframes;\n\txfer->hcpriv = sitd;\n\tfor (i = ncur = 0; i < nframes; i++, ncur++) {\n\t\tnoffs = offs + xfer->frlengths[i];\n\t\tif (ncur == OHCI_ITD_NOFFSET ||\t/* all offsets used */\n\t\t    OHCI_PAGE(buf + noffs) > bp0 + OHCI_PAGE_SIZE) { /* too many page crossings */\n\t\t\t\n\t\t\t/* Allocate next ITD */\n\t\t\tnsitd = ohci_alloc_sitd(sc);\n\t\t\tif (nsitd == NULL) {\n\t\t\t\t/* XXX what now? */\n\t\t\t\tprintf(\"%s: isoc TD alloc failed\\n\",\n\t\t\t\t       USBDEVNAME(sc->sc_bus.bdev));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/* Fill current ITD */\n\t\t\tsitd->itd.itd_flags = htole32(\n\t\t\t\tOHCI_ITD_NOCC | \n\t\t\t\tOHCI_ITD_SET_SF(iso->next) |\n\t\t\t\tOHCI_ITD_SET_DI(6) | /* delay intr a little */\n\t\t\t\tOHCI_ITD_SET_FC(ncur));\n\t\t\tsitd->itd.itd_bp0 = htole32(bp0);\n\t\t\tsitd->nextitd = nsitd;\n\t\t\tsitd->itd.itd_nextitd = htole32(nsitd->physaddr);\n\t\t\tsitd->itd.itd_be = htole32(bp0 + offs - 1);\n\t\t\tsitd->xfer = xfer;\n\t\t\tsitd->flags = 0;\n\n\t\t\tsitd = nsitd;\n\t\t\tiso->next = iso->next + ncur; \n\t\t\tbp0 = OHCI_PAGE(buf + offs);\n\t\t\tncur = 0;\n\t\t}\n\t\tsitd->itd.itd_offset[ncur] = htole16(OHCI_ITD_MK_OFFS(offs));\n\t\toffs = noffs;\n\t}\n\tnsitd = ohci_alloc_sitd(sc);\n\tif (nsitd == NULL) {\n\t\t/* XXX what now? */\n\t\tprintf(\"%s: isoc TD alloc failed\\n\", \n\t\t       USBDEVNAME(sc->sc_bus.bdev));\n\t\treturn;\n\t}\n\t/* Fixup last used ITD */\n\tsitd->itd.itd_flags = htole32(\n\t\tOHCI_ITD_NOCC | \n\t\tOHCI_ITD_SET_SF(iso->next) |\n\t\tOHCI_ITD_SET_DI(0) |\n\t\tOHCI_ITD_SET_FC(ncur));\n\tsitd->itd.itd_bp0 = htole32(bp0);\n\tsitd->nextitd = nsitd;\n\tsitd->itd.itd_nextitd = htole32(nsitd->physaddr);\n\tsitd->itd.itd_be = htole32(bp0 + offs - 1);\n\tsitd->xfer = xfer;\n\tsitd->flags = OHCI_CALL_DONE;\n\n\tiso->next = iso->next + ncur;\n\tiso->inuse += nframes;\n\n\txfer->actlen = offs;\t/* XXX pretend we did it all */\n\n\txfer->status = USBD_IN_PROGRESS;\n\n#ifdef OHCI_DEBUG\n\tif (ohcidebug > 5) {\n\t\tDPRINTF((\"ohci_device_isoc_enter: frame=%d\\n\",\n\t\t\t le32toh(sc->sc_hcca->hcca_frame_number)));\n\t\tohci_dump_itds(xfer->hcpriv);\n\t\tohci_dump_ed(sed);\n\t}\n#endif\n\n\ts = splusb();\n\topipe->tail.itd = nsitd;\n\tsed->ed.ed_tailp = htole32(nsitd->physaddr);\n\tsplx(s);\n\n#ifdef OHCI_DEBUG\n\tif (ohcidebug > 5) {\n\t\tdelay(150000);\n\t\tDPRINTF((\"ohci_device_isoc_enter: after frame=%d\\n\",\n\t\t\t le32toh(sc->sc_hcca->hcca_frame_number)));\n\t\tohci_dump_itds(xfer->hcpriv);\n\t\tohci_dump_ed(sed);\n\t}\n#endif\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static ohci_soft_ed_t",
      "ohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));",
      "Static ohci_soft_itd_t",
      "ohci_free_sitd __P((ohci_softc_t *,ohci_soft_itd_t *));",
      "ohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));",
      "ohci_add_done __P((ohci_softc_t *, ohci_physaddr_t));",
      "ohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));",
      "ohci_device_request __P((usbd_xfer_handle xfer));",
      "ohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
      "ohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
      "ohci_hash_add_itd __P((ohci_softc_t *, \n\t\t\t    ohci_soft_itd_t *));",
      "ohci_hash_rem_itd __P((ohci_softc_t *,\n\t\t\t    ohci_soft_itd_t *));",
      "Static ohci_soft_itd_t",
      "ohci_setup_isoc __P((usbd_pipe_handle pipe));",
      "ohci_device_isoc_enter __P((usbd_xfer_handle));",
      "Static usbd_xfer_handle",
      "ohci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "ohci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "ohci_root_ctrl_start __P((usbd_xfer_handle));",
      "ohci_root_ctrl_abort __P((usbd_xfer_handle));",
      "ohci_root_ctrl_done  __P((usbd_xfer_handle));",
      "ohci_root_intr_transfer __P((usbd_xfer_handle));",
      "ohci_root_intr_start __P((usbd_xfer_handle));",
      "ohci_root_intr_abort __P((usbd_xfer_handle));",
      "ohci_root_intr_done  __P((usbd_xfer_handle));",
      "ohci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "ohci_device_ctrl_start __P((usbd_xfer_handle));",
      "ohci_device_ctrl_abort __P((usbd_xfer_handle));",
      "ohci_device_ctrl_done  __P((usbd_xfer_handle));",
      "ohci_device_bulk_transfer __P((usbd_xfer_handle));",
      "ohci_device_bulk_start __P((usbd_xfer_handle));",
      "ohci_device_bulk_abort __P((usbd_xfer_handle));",
      "ohci_device_bulk_done  __P((usbd_xfer_handle));",
      "ohci_device_intr_transfer __P((usbd_xfer_handle));",
      "ohci_device_intr_start __P((usbd_xfer_handle));",
      "ohci_device_intr_abort __P((usbd_xfer_handle));",
      "ohci_device_intr_done  __P((usbd_xfer_handle));",
      "ohci_device_isoc_transfer __P((usbd_xfer_handle));",
      "ohci_device_isoc_start __P((usbd_xfer_handle));",
      "ohci_device_isoc_abort __P((usbd_xfer_handle));",
      "ohci_device_isoc_done  __P((usbd_xfer_handle));",
      "ohci_rhsc_able __P((ohci_softc_t *, int));",
      "ohci_abort_xfer __P((usbd_xfer_handle xfer,\n\t\t\t    usbd_status status));",
      "ohci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "ohci_noop __P((usbd_pipe_handle pipe));",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
      "ohci_intr1 __P((ohci_softc_t *));",
      "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
      "ohci_physaddr_t a;",
      "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;",
      "ohci_physaddr_t a;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ohci_dump_ed",
          "args": [
            "sed"
          ],
          "line": 3148
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_dump_ed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "1842-1859",
          "snippet": "void\nohci_dump_ed(sed)\n\tohci_soft_ed_t *sed;\n{\n\tDPRINTF((\"ED(%p) at 0x%08lx: addr=%d endpt=%d maxp=%d %b\\ntailp=0x%08lx \"\n\t\t \"headflags=%b headp=0x%08lx nexted=0x%08lx\\n\",\n\t\t sed, (u_long)sed->physaddr, \n\t\t OHCI_ED_GET_FA(le32toh(sed->ed.ed_flags)),\n\t\t OHCI_ED_GET_EN(le32toh(sed->ed.ed_flags)),\n\t\t OHCI_ED_GET_MAXP(le32toh(sed->ed.ed_flags)),\n\t\t (int)le32toh(sed->ed.ed_flags),\n\t\t \"\\20\\14OUT\\15IN\\16LOWSPEED\\17SKIP\\20ISO\",\n\t\t (u_long)le32toh(sed->ed.ed_tailp),\n\t\t (u_long)le32toh(sed->ed.ed_headp),\n\t\t \"\\20\\1HALT\\2CARRY\",\n\t\t (u_long)le32toh(sed->ed.ed_headp),\n\t\t (u_long)le32toh(sed->ed.ed_nexted)));\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static ohci_soft_ed_t",
            "ohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));",
            "ohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
            "ohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_ed_t;\nohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));\nohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\n\nvoid\nohci_dump_ed(sed)\n\tohci_soft_ed_t *sed;\n{\n\tDPRINTF((\"ED(%p) at 0x%08lx: addr=%d endpt=%d maxp=%d %b\\ntailp=0x%08lx \"\n\t\t \"headflags=%b headp=0x%08lx nexted=0x%08lx\\n\",\n\t\t sed, (u_long)sed->physaddr, \n\t\t OHCI_ED_GET_FA(le32toh(sed->ed.ed_flags)),\n\t\t OHCI_ED_GET_EN(le32toh(sed->ed.ed_flags)),\n\t\t OHCI_ED_GET_MAXP(le32toh(sed->ed.ed_flags)),\n\t\t (int)le32toh(sed->ed.ed_flags),\n\t\t \"\\20\\14OUT\\15IN\\16LOWSPEED\\17SKIP\\20ISO\",\n\t\t (u_long)le32toh(sed->ed.ed_tailp),\n\t\t (u_long)le32toh(sed->ed.ed_headp),\n\t\t \"\\20\\1HALT\\2CARRY\",\n\t\t (u_long)le32toh(sed->ed.ed_headp),\n\t\t (u_long)le32toh(sed->ed.ed_nexted)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ohci_dump_itds",
          "args": [
            "xfer->hcpriv"
          ],
          "line": 3147
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_dump_itds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "1834-1840",
          "snippet": "void\nohci_dump_itds(sitd)\n\tohci_soft_itd_t *sitd;\n{\n\tfor (; sitd; sitd = sitd->nextitd)\n\t\tohci_dump_itd(sitd);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static ohci_soft_itd_t",
            "ohci_free_sitd __P((ohci_softc_t *,ohci_soft_itd_t *));",
            "ohci_hash_add_itd __P((ohci_softc_t *, \n\t\t\t    ohci_soft_itd_t *));",
            "ohci_hash_rem_itd __P((ohci_softc_t *,\n\t\t\t    ohci_soft_itd_t *));",
            "Static ohci_soft_itd_t"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_itd_t;\nohci_free_sitd __P((ohci_softc_t *,ohci_soft_itd_t *));\nohci_hash_add_itd __P((ohci_softc_t *, \n\t\t\t    ohci_soft_itd_t *));\nohci_hash_rem_itd __P((ohci_softc_t *,\n\t\t\t    ohci_soft_itd_t *));\nStatic ohci_soft_itd_t;\n\nvoid\nohci_dump_itds(sitd)\n\tohci_soft_itd_t *sitd;\n{\n\tfor (; sitd; sitd = sitd->nextitd)\n\t\tohci_dump_itd(sitd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ohci_device_isoc_enter: after frame=%d\\n\",\n\t\t\t le32toh(sc->sc_hcca->hcca_frame_number))"
          ],
          "line": 3145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "sc->sc_hcca->hcca_frame_number"
          ],
          "line": 3146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "150000"
          ],
          "line": 3144
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_delay_ms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "316-322",
          "snippet": "void\nusbd_delay_ms(dev, ms)\n\tusbd_device_handle dev;\n\tu_int ms;\n{\n\tusb_delay_ms(dev->bus, ms);\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_set_config __P((usbd_device_handle, int));",
            "usbd_getnewaddr __P((usbd_bus_handle bus));",
            "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_set_config __P((usbd_device_handle, int));\nusbd_getnewaddr __P((usbd_bus_handle bus));\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\n\nvoid\nusbd_delay_ms(dev, ms)\n\tusbd_device_handle dev;\n\tu_int ms;\n{\n\tusb_delay_ms(dev->bus, ms);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 3140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "nsitd->physaddr"
          ],
          "line": 3139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 3137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ohci_device_isoc_enter: frame=%d\\n\",\n\t\t\t le32toh(sc->sc_hcca->hcca_frame_number))"
          ],
          "line": 3130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "sc->sc_hcca->hcca_frame_number"
          ],
          "line": 3131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "bp0 + offs - 1"
          ],
          "line": 3117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "nsitd->physaddr"
          ],
          "line": 3116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "bp0"
          ],
          "line": 3114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "OHCI_ITD_NOCC | \n\t\tOHCI_ITD_SET_SF(iso->next) |\n\t\tOHCI_ITD_SET_DI(0) |\n\t\tOHCI_ITD_SET_FC(ncur)"
          ],
          "line": 3109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OHCI_ITD_SET_FC",
          "args": [
            "ncur"
          ],
          "line": 3113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OHCI_ITD_SET_DI",
          "args": [
            "0"
          ],
          "line": 3112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OHCI_ITD_SET_SF",
          "args": [
            "iso->next"
          ],
          "line": 3111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: isoc TD alloc failed\\n\"",
            "USBDEVNAME(sc->sc_bus.bdev)"
          ],
          "line": 3104
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_bus.bdev"
          ],
          "line": 3105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ohci_alloc_sitd",
          "args": [
            "sc"
          ],
          "line": 3101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole16",
          "args": [
            "OHCI_ITD_MK_OFFS(offs)"
          ],
          "line": 3098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OHCI_ITD_MK_OFFS",
          "args": [
            "offs"
          ],
          "line": 3098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OHCI_PAGE",
          "args": [
            "buf + offs"
          ],
          "line": 3095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "bp0 + offs - 1"
          ],
          "line": 3089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "nsitd->physaddr"
          ],
          "line": 3088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "bp0"
          ],
          "line": 3086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "OHCI_ITD_NOCC | \n\t\t\t\tOHCI_ITD_SET_SF(iso->next) |\n\t\t\t\tOHCI_ITD_SET_DI(6) | /* delay intr a little */\n\t\t\t\tOHCI_ITD_SET_FC(ncur)"
          ],
          "line": 3081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OHCI_ITD_SET_FC",
          "args": [
            "ncur"
          ],
          "line": 3085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OHCI_ITD_SET_DI",
          "args": [
            "6"
          ],
          "line": 3084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OHCI_ITD_SET_SF",
          "args": [
            "iso->next"
          ],
          "line": 3083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_bus.bdev"
          ],
          "line": 3076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ohci_alloc_sitd",
          "args": [
            "sc"
          ],
          "line": 3072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OHCI_PAGE",
          "args": [
            "buf + noffs"
          ],
          "line": 3069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OHCI_PAGE_OFFSET",
          "args": [
            "buf"
          ],
          "line": 3063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OHCI_PAGE",
          "args": [
            "buf"
          ],
          "line": 3062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DMAADDR",
          "args": [
            "&xfer->dmabuf"
          ],
          "line": 3061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "2",
            "(\"ohci_device_isoc_enter: start next=%d\\n\", \n\t\t\t    iso->next)"
          ],
          "line": 3056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "sc->sc_hcca->hcca_frame_number"
          ],
          "line": 3055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"ohci_device_isoc_enter: used=%d next=%d xfer=%p \"\n\t\t    \"nframes=%d\\n\",\n\t\t    iso->inuse, iso->next, xfer, xfer->nframes)"
          ],
          "line": 3046
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_ed_t;\nohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));\nStatic ohci_soft_itd_t;\nohci_free_sitd __P((ohci_softc_t *,ohci_soft_itd_t *));\nohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));\nohci_add_done __P((ohci_softc_t *, ohci_physaddr_t));\nohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));\nohci_device_request __P((usbd_xfer_handle xfer));\nohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nohci_hash_add_itd __P((ohci_softc_t *, \n\t\t\t    ohci_soft_itd_t *));\nohci_hash_rem_itd __P((ohci_softc_t *,\n\t\t\t    ohci_soft_itd_t *));\nStatic ohci_soft_itd_t;\nohci_setup_isoc __P((usbd_pipe_handle pipe));\nohci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_xfer_handle;\nohci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nohci_root_ctrl_transfer __P((usbd_xfer_handle));\nohci_root_ctrl_start __P((usbd_xfer_handle));\nohci_root_ctrl_abort __P((usbd_xfer_handle));\nohci_root_ctrl_done  __P((usbd_xfer_handle));\nohci_root_intr_transfer __P((usbd_xfer_handle));\nohci_root_intr_start __P((usbd_xfer_handle));\nohci_root_intr_abort __P((usbd_xfer_handle));\nohci_root_intr_done  __P((usbd_xfer_handle));\nohci_device_ctrl_transfer __P((usbd_xfer_handle));\nohci_device_ctrl_start __P((usbd_xfer_handle));\nohci_device_ctrl_abort __P((usbd_xfer_handle));\nohci_device_ctrl_done  __P((usbd_xfer_handle));\nohci_device_bulk_transfer __P((usbd_xfer_handle));\nohci_device_bulk_start __P((usbd_xfer_handle));\nohci_device_bulk_abort __P((usbd_xfer_handle));\nohci_device_bulk_done  __P((usbd_xfer_handle));\nohci_device_intr_transfer __P((usbd_xfer_handle));\nohci_device_intr_start __P((usbd_xfer_handle));\nohci_device_intr_abort __P((usbd_xfer_handle));\nohci_device_intr_done  __P((usbd_xfer_handle));\nohci_device_isoc_transfer __P((usbd_xfer_handle));\nohci_device_isoc_start __P((usbd_xfer_handle));\nohci_device_isoc_abort __P((usbd_xfer_handle));\nohci_device_isoc_done  __P((usbd_xfer_handle));\nohci_rhsc_able __P((ohci_softc_t *, int));\nohci_abort_xfer __P((usbd_xfer_handle xfer,\n\t\t\t    usbd_status status));\nohci_device_clear_toggle __P((usbd_pipe_handle pipe));\nohci_noop __P((usbd_pipe_handle pipe));\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_physaddr_t a;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\nohci_physaddr_t a;\n\nvoid\nohci_device_isoc_enter(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tstruct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;\n\tusbd_device_handle dev = opipe->pipe.device;\n\tohci_softc_t *sc = (ohci_softc_t *)dev->bus;\n\tohci_soft_ed_t *sed = opipe->sed;\n\tstruct iso *iso = &opipe->u.iso;\n\tohci_soft_itd_t *sitd, *nsitd;\t\n\tohci_physaddr_t buf, offs, noffs, bp0;\n\tint i, ncur, nframes;\n\tint s;\n\n\tDPRINTFN(1,(\"ohci_device_isoc_enter: used=%d next=%d xfer=%p \"\n\t\t    \"nframes=%d\\n\",\n\t\t    iso->inuse, iso->next, xfer, xfer->nframes));\n\n\tif (sc->sc_dying)\n\t\treturn;\n\n\tif (iso->next == -1) {\n\t\t/* Not in use yet, schedule it a few frames ahead. */\n\t\tiso->next = le32toh(sc->sc_hcca->hcca_frame_number) + 5;\n\t\tDPRINTFN(2,(\"ohci_device_isoc_enter: start next=%d\\n\", \n\t\t\t    iso->next));\n\t}\n\n\tsitd = opipe->tail.itd;\n\tbuf = DMAADDR(&xfer->dmabuf);\n\tbp0 = OHCI_PAGE(buf);\n\toffs = OHCI_PAGE_OFFSET(buf);\n\tnframes = xfer->nframes;\n\txfer->hcpriv = sitd;\n\tfor (i = ncur = 0; i < nframes; i++, ncur++) {\n\t\tnoffs = offs + xfer->frlengths[i];\n\t\tif (ncur == OHCI_ITD_NOFFSET ||\t/* all offsets used */\n\t\t    OHCI_PAGE(buf + noffs) > bp0 + OHCI_PAGE_SIZE) { /* too many page crossings */\n\t\t\t\n\t\t\t/* Allocate next ITD */\n\t\t\tnsitd = ohci_alloc_sitd(sc);\n\t\t\tif (nsitd == NULL) {\n\t\t\t\t/* XXX what now? */\n\t\t\t\tprintf(\"%s: isoc TD alloc failed\\n\",\n\t\t\t\t       USBDEVNAME(sc->sc_bus.bdev));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/* Fill current ITD */\n\t\t\tsitd->itd.itd_flags = htole32(\n\t\t\t\tOHCI_ITD_NOCC | \n\t\t\t\tOHCI_ITD_SET_SF(iso->next) |\n\t\t\t\tOHCI_ITD_SET_DI(6) | /* delay intr a little */\n\t\t\t\tOHCI_ITD_SET_FC(ncur));\n\t\t\tsitd->itd.itd_bp0 = htole32(bp0);\n\t\t\tsitd->nextitd = nsitd;\n\t\t\tsitd->itd.itd_nextitd = htole32(nsitd->physaddr);\n\t\t\tsitd->itd.itd_be = htole32(bp0 + offs - 1);\n\t\t\tsitd->xfer = xfer;\n\t\t\tsitd->flags = 0;\n\n\t\t\tsitd = nsitd;\n\t\t\tiso->next = iso->next + ncur; \n\t\t\tbp0 = OHCI_PAGE(buf + offs);\n\t\t\tncur = 0;\n\t\t}\n\t\tsitd->itd.itd_offset[ncur] = htole16(OHCI_ITD_MK_OFFS(offs));\n\t\toffs = noffs;\n\t}\n\tnsitd = ohci_alloc_sitd(sc);\n\tif (nsitd == NULL) {\n\t\t/* XXX what now? */\n\t\tprintf(\"%s: isoc TD alloc failed\\n\", \n\t\t       USBDEVNAME(sc->sc_bus.bdev));\n\t\treturn;\n\t}\n\t/* Fixup last used ITD */\n\tsitd->itd.itd_flags = htole32(\n\t\tOHCI_ITD_NOCC | \n\t\tOHCI_ITD_SET_SF(iso->next) |\n\t\tOHCI_ITD_SET_DI(0) |\n\t\tOHCI_ITD_SET_FC(ncur));\n\tsitd->itd.itd_bp0 = htole32(bp0);\n\tsitd->nextitd = nsitd;\n\tsitd->itd.itd_nextitd = htole32(nsitd->physaddr);\n\tsitd->itd.itd_be = htole32(bp0 + offs - 1);\n\tsitd->xfer = xfer;\n\tsitd->flags = OHCI_CALL_DONE;\n\n\tiso->next = iso->next + ncur;\n\tiso->inuse += nframes;\n\n\txfer->actlen = offs;\t/* XXX pretend we did it all */\n\n\txfer->status = USBD_IN_PROGRESS;\n\n#ifdef OHCI_DEBUG\n\tif (ohcidebug > 5) {\n\t\tDPRINTF((\"ohci_device_isoc_enter: frame=%d\\n\",\n\t\t\t le32toh(sc->sc_hcca->hcca_frame_number)));\n\t\tohci_dump_itds(xfer->hcpriv);\n\t\tohci_dump_ed(sed);\n\t}\n#endif\n\n\ts = splusb();\n\topipe->tail.itd = nsitd;\n\tsed->ed.ed_tailp = htole32(nsitd->physaddr);\n\tsplx(s);\n\n#ifdef OHCI_DEBUG\n\tif (ohcidebug > 5) {\n\t\tdelay(150000);\n\t\tDPRINTF((\"ohci_device_isoc_enter: after frame=%d\\n\",\n\t\t\t le32toh(sc->sc_hcca->hcca_frame_number)));\n\t\tohci_dump_itds(xfer->hcpriv);\n\t\tohci_dump_ed(sed);\n\t}\n#endif\n}"
  },
  {
    "function_name": "ohci_device_isoc_transfer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "3005-3030",
    "snippet": "usbd_status\nohci_device_isoc_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_status err;\n\n\tDPRINTFN(5,(\"ohci_device_isoc_transfer: xfer=%p\\n\", xfer));\n\n\t/* Put it on our queue, */\n\terr = usb_insert_transfer(xfer);\n\n\t/* bail out on error, */\n\tif (err && err != USBD_IN_PROGRESS)\n\t\treturn (err);\n\n\t/* XXX should check inuse here */\n\n\t/* insert into schedule, */\n\tohci_device_isoc_enter(xfer);\n\n\t/* and start if the pipe wasn't running */\n\tif (!err)\n\t\tohci_device_isoc_start(SIMPLEQ_FIRST(&xfer->pipe->queue));\n\n\treturn (err);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static usbd_status",
      "Static usbd_status",
      "ohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));",
      "ohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_request __P((usbd_xfer_handle xfer));",
      "Static usbd_status",
      "ohci_setup_isoc __P((usbd_pipe_handle pipe));",
      "ohci_device_isoc_enter __P((usbd_xfer_handle));",
      "Static usbd_status",
      "Static usbd_xfer_handle",
      "ohci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_root_ctrl_start __P((usbd_xfer_handle));",
      "ohci_root_ctrl_abort __P((usbd_xfer_handle));",
      "ohci_root_ctrl_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_root_intr_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_root_intr_start __P((usbd_xfer_handle));",
      "ohci_root_intr_abort __P((usbd_xfer_handle));",
      "ohci_root_intr_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_ctrl_start __P((usbd_xfer_handle));",
      "ohci_device_ctrl_abort __P((usbd_xfer_handle));",
      "ohci_device_ctrl_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_bulk_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_bulk_start __P((usbd_xfer_handle));",
      "ohci_device_bulk_abort __P((usbd_xfer_handle));",
      "ohci_device_bulk_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_intr_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_intr_start __P((usbd_xfer_handle));",
      "ohci_device_intr_abort __P((usbd_xfer_handle));",
      "ohci_device_intr_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_isoc_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_isoc_start __P((usbd_xfer_handle));",
      "ohci_device_isoc_abort __P((usbd_xfer_handle));",
      "ohci_device_isoc_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "ohci_noop __P((usbd_pipe_handle pipe));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ohci_device_isoc_start",
          "args": [
            "SIMPLEQ_FIRST(&xfer->pipe->queue)"
          ],
          "line": 3027
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_device_isoc_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "3153-3173",
          "snippet": "usbd_status\nohci_device_isoc_start(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tstruct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;\n\tohci_softc_t *sc = (ohci_softc_t *)opipe->pipe.device->bus;\n\n\tDPRINTFN(5,(\"ohci_device_isoc_start: xfer=%p\\n\", xfer));\n\n\tif (sc->sc_dying)\n\t\treturn (USBD_IOERROR);\n\n#ifdef DIAGNOSTIC\n\tif (xfer->status != USBD_IN_PROGRESS)\n\t\tprintf(\"uhci_device_isoc_start: not in progress %p\\n\", xfer);\n#endif\n\n\t/* XXX anything to do? */\n\n\treturn (USBD_IN_PROGRESS);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "Static usbd_status",
            "ohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));",
            "ohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_request __P((usbd_xfer_handle xfer));",
            "Static usbd_status",
            "ohci_setup_isoc __P((usbd_pipe_handle pipe));",
            "ohci_device_isoc_enter __P((usbd_xfer_handle));",
            "Static usbd_status",
            "Static usbd_xfer_handle",
            "ohci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_root_ctrl_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_root_ctrl_start __P((usbd_xfer_handle));",
            "ohci_root_ctrl_abort __P((usbd_xfer_handle));",
            "ohci_root_ctrl_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_root_intr_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_root_intr_start __P((usbd_xfer_handle));",
            "ohci_root_intr_abort __P((usbd_xfer_handle));",
            "ohci_root_intr_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_ctrl_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_ctrl_start __P((usbd_xfer_handle));",
            "ohci_device_ctrl_abort __P((usbd_xfer_handle));",
            "ohci_device_ctrl_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_bulk_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_bulk_start __P((usbd_xfer_handle));",
            "ohci_device_bulk_abort __P((usbd_xfer_handle));",
            "ohci_device_bulk_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_intr_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_intr_start __P((usbd_xfer_handle));",
            "ohci_device_intr_abort __P((usbd_xfer_handle));",
            "ohci_device_intr_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_isoc_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_isoc_start __P((usbd_xfer_handle));",
            "ohci_device_isoc_abort __P((usbd_xfer_handle));",
            "ohci_device_isoc_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_rhsc_able __P((ohci_softc_t *, int));",
            "ohci_abort_xfer __P((usbd_xfer_handle xfer,\n\t\t\t    usbd_status status));",
            "ohci_device_clear_toggle __P((usbd_pipe_handle pipe));",
            "ohci_noop __P((usbd_pipe_handle pipe));",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
            "ohci_intr1 __P((ohci_softc_t *));",
            "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nStatic usbd_status;\nohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));\nohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));\nStatic usbd_status;\nohci_device_request __P((usbd_xfer_handle xfer));\nStatic usbd_status;\nohci_setup_isoc __P((usbd_pipe_handle pipe));\nohci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic usbd_xfer_handle;\nohci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nStatic usbd_status;\nohci_root_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_ctrl_start __P((usbd_xfer_handle));\nohci_root_ctrl_abort __P((usbd_xfer_handle));\nohci_root_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_intr_start __P((usbd_xfer_handle));\nohci_root_intr_abort __P((usbd_xfer_handle));\nohci_root_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_ctrl_start __P((usbd_xfer_handle));\nohci_device_ctrl_abort __P((usbd_xfer_handle));\nohci_device_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_bulk_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_bulk_start __P((usbd_xfer_handle));\nohci_device_bulk_abort __P((usbd_xfer_handle));\nohci_device_bulk_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_intr_start __P((usbd_xfer_handle));\nohci_device_intr_abort __P((usbd_xfer_handle));\nohci_device_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_isoc_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_isoc_start __P((usbd_xfer_handle));\nohci_device_isoc_abort __P((usbd_xfer_handle));\nohci_device_isoc_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_rhsc_able __P((ohci_softc_t *, int));\nohci_abort_xfer __P((usbd_xfer_handle xfer,\n\t\t\t    usbd_status status));\nohci_device_clear_toggle __P((usbd_pipe_handle pipe));\nohci_noop __P((usbd_pipe_handle pipe));\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nusbd_status\nohci_device_isoc_start(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tstruct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;\n\tohci_softc_t *sc = (ohci_softc_t *)opipe->pipe.device->bus;\n\n\tDPRINTFN(5,(\"ohci_device_isoc_start: xfer=%p\\n\", xfer));\n\n\tif (sc->sc_dying)\n\t\treturn (USBD_IOERROR);\n\n#ifdef DIAGNOSTIC\n\tif (xfer->status != USBD_IN_PROGRESS)\n\t\tprintf(\"uhci_device_isoc_start: not in progress %p\\n\", xfer);\n#endif\n\n\t/* XXX anything to do? */\n\n\treturn (USBD_IN_PROGRESS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_FIRST",
          "args": [
            "&xfer->pipe->queue"
          ],
          "line": 3027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ohci_device_isoc_enter",
          "args": [
            "xfer"
          ],
          "line": 3023
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_device_isoc_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "3032-3151",
          "snippet": "void\nohci_device_isoc_enter(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tstruct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;\n\tusbd_device_handle dev = opipe->pipe.device;\n\tohci_softc_t *sc = (ohci_softc_t *)dev->bus;\n\tohci_soft_ed_t *sed = opipe->sed;\n\tstruct iso *iso = &opipe->u.iso;\n\tohci_soft_itd_t *sitd, *nsitd;\t\n\tohci_physaddr_t buf, offs, noffs, bp0;\n\tint i, ncur, nframes;\n\tint s;\n\n\tDPRINTFN(1,(\"ohci_device_isoc_enter: used=%d next=%d xfer=%p \"\n\t\t    \"nframes=%d\\n\",\n\t\t    iso->inuse, iso->next, xfer, xfer->nframes));\n\n\tif (sc->sc_dying)\n\t\treturn;\n\n\tif (iso->next == -1) {\n\t\t/* Not in use yet, schedule it a few frames ahead. */\n\t\tiso->next = le32toh(sc->sc_hcca->hcca_frame_number) + 5;\n\t\tDPRINTFN(2,(\"ohci_device_isoc_enter: start next=%d\\n\", \n\t\t\t    iso->next));\n\t}\n\n\tsitd = opipe->tail.itd;\n\tbuf = DMAADDR(&xfer->dmabuf);\n\tbp0 = OHCI_PAGE(buf);\n\toffs = OHCI_PAGE_OFFSET(buf);\n\tnframes = xfer->nframes;\n\txfer->hcpriv = sitd;\n\tfor (i = ncur = 0; i < nframes; i++, ncur++) {\n\t\tnoffs = offs + xfer->frlengths[i];\n\t\tif (ncur == OHCI_ITD_NOFFSET ||\t/* all offsets used */\n\t\t    OHCI_PAGE(buf + noffs) > bp0 + OHCI_PAGE_SIZE) { /* too many page crossings */\n\t\t\t\n\t\t\t/* Allocate next ITD */\n\t\t\tnsitd = ohci_alloc_sitd(sc);\n\t\t\tif (nsitd == NULL) {\n\t\t\t\t/* XXX what now? */\n\t\t\t\tprintf(\"%s: isoc TD alloc failed\\n\",\n\t\t\t\t       USBDEVNAME(sc->sc_bus.bdev));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/* Fill current ITD */\n\t\t\tsitd->itd.itd_flags = htole32(\n\t\t\t\tOHCI_ITD_NOCC | \n\t\t\t\tOHCI_ITD_SET_SF(iso->next) |\n\t\t\t\tOHCI_ITD_SET_DI(6) | /* delay intr a little */\n\t\t\t\tOHCI_ITD_SET_FC(ncur));\n\t\t\tsitd->itd.itd_bp0 = htole32(bp0);\n\t\t\tsitd->nextitd = nsitd;\n\t\t\tsitd->itd.itd_nextitd = htole32(nsitd->physaddr);\n\t\t\tsitd->itd.itd_be = htole32(bp0 + offs - 1);\n\t\t\tsitd->xfer = xfer;\n\t\t\tsitd->flags = 0;\n\n\t\t\tsitd = nsitd;\n\t\t\tiso->next = iso->next + ncur; \n\t\t\tbp0 = OHCI_PAGE(buf + offs);\n\t\t\tncur = 0;\n\t\t}\n\t\tsitd->itd.itd_offset[ncur] = htole16(OHCI_ITD_MK_OFFS(offs));\n\t\toffs = noffs;\n\t}\n\tnsitd = ohci_alloc_sitd(sc);\n\tif (nsitd == NULL) {\n\t\t/* XXX what now? */\n\t\tprintf(\"%s: isoc TD alloc failed\\n\", \n\t\t       USBDEVNAME(sc->sc_bus.bdev));\n\t\treturn;\n\t}\n\t/* Fixup last used ITD */\n\tsitd->itd.itd_flags = htole32(\n\t\tOHCI_ITD_NOCC | \n\t\tOHCI_ITD_SET_SF(iso->next) |\n\t\tOHCI_ITD_SET_DI(0) |\n\t\tOHCI_ITD_SET_FC(ncur));\n\tsitd->itd.itd_bp0 = htole32(bp0);\n\tsitd->nextitd = nsitd;\n\tsitd->itd.itd_nextitd = htole32(nsitd->physaddr);\n\tsitd->itd.itd_be = htole32(bp0 + offs - 1);\n\tsitd->xfer = xfer;\n\tsitd->flags = OHCI_CALL_DONE;\n\n\tiso->next = iso->next + ncur;\n\tiso->inuse += nframes;\n\n\txfer->actlen = offs;\t/* XXX pretend we did it all */\n\n\txfer->status = USBD_IN_PROGRESS;\n\n#ifdef OHCI_DEBUG\n\tif (ohcidebug > 5) {\n\t\tDPRINTF((\"ohci_device_isoc_enter: frame=%d\\n\",\n\t\t\t le32toh(sc->sc_hcca->hcca_frame_number)));\n\t\tohci_dump_itds(xfer->hcpriv);\n\t\tohci_dump_ed(sed);\n\t}\n#endif\n\n\ts = splusb();\n\topipe->tail.itd = nsitd;\n\tsed->ed.ed_tailp = htole32(nsitd->physaddr);\n\tsplx(s);\n\n#ifdef OHCI_DEBUG\n\tif (ohcidebug > 5) {\n\t\tdelay(150000);\n\t\tDPRINTF((\"ohci_device_isoc_enter: after frame=%d\\n\",\n\t\t\t le32toh(sc->sc_hcca->hcca_frame_number)));\n\t\tohci_dump_itds(xfer->hcpriv);\n\t\tohci_dump_ed(sed);\n\t}\n#endif\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static ohci_soft_ed_t",
            "ohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));",
            "Static ohci_soft_itd_t",
            "ohci_free_sitd __P((ohci_softc_t *,ohci_soft_itd_t *));",
            "ohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));",
            "ohci_add_done __P((ohci_softc_t *, ohci_physaddr_t));",
            "ohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));",
            "ohci_device_request __P((usbd_xfer_handle xfer));",
            "ohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
            "ohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
            "ohci_hash_add_itd __P((ohci_softc_t *, \n\t\t\t    ohci_soft_itd_t *));",
            "ohci_hash_rem_itd __P((ohci_softc_t *,\n\t\t\t    ohci_soft_itd_t *));",
            "Static ohci_soft_itd_t",
            "ohci_setup_isoc __P((usbd_pipe_handle pipe));",
            "ohci_device_isoc_enter __P((usbd_xfer_handle));",
            "Static usbd_xfer_handle",
            "ohci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
            "ohci_root_ctrl_transfer __P((usbd_xfer_handle));",
            "ohci_root_ctrl_start __P((usbd_xfer_handle));",
            "ohci_root_ctrl_abort __P((usbd_xfer_handle));",
            "ohci_root_ctrl_done  __P((usbd_xfer_handle));",
            "ohci_root_intr_transfer __P((usbd_xfer_handle));",
            "ohci_root_intr_start __P((usbd_xfer_handle));",
            "ohci_root_intr_abort __P((usbd_xfer_handle));",
            "ohci_root_intr_done  __P((usbd_xfer_handle));",
            "ohci_device_ctrl_transfer __P((usbd_xfer_handle));",
            "ohci_device_ctrl_start __P((usbd_xfer_handle));",
            "ohci_device_ctrl_abort __P((usbd_xfer_handle));",
            "ohci_device_ctrl_done  __P((usbd_xfer_handle));",
            "ohci_device_bulk_transfer __P((usbd_xfer_handle));",
            "ohci_device_bulk_start __P((usbd_xfer_handle));",
            "ohci_device_bulk_abort __P((usbd_xfer_handle));",
            "ohci_device_bulk_done  __P((usbd_xfer_handle));",
            "ohci_device_intr_transfer __P((usbd_xfer_handle));",
            "ohci_device_intr_start __P((usbd_xfer_handle));",
            "ohci_device_intr_abort __P((usbd_xfer_handle));",
            "ohci_device_intr_done  __P((usbd_xfer_handle));",
            "ohci_device_isoc_transfer __P((usbd_xfer_handle));",
            "ohci_device_isoc_start __P((usbd_xfer_handle));",
            "ohci_device_isoc_abort __P((usbd_xfer_handle));",
            "ohci_device_isoc_done  __P((usbd_xfer_handle));",
            "ohci_rhsc_able __P((ohci_softc_t *, int));",
            "ohci_abort_xfer __P((usbd_xfer_handle xfer,\n\t\t\t    usbd_status status));",
            "ohci_device_clear_toggle __P((usbd_pipe_handle pipe));",
            "ohci_noop __P((usbd_pipe_handle pipe));",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
            "ohci_intr1 __P((ohci_softc_t *));",
            "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
            "ohci_physaddr_t a;",
            "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;",
            "ohci_physaddr_t a;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_ed_t;\nohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));\nStatic ohci_soft_itd_t;\nohci_free_sitd __P((ohci_softc_t *,ohci_soft_itd_t *));\nohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));\nohci_add_done __P((ohci_softc_t *, ohci_physaddr_t));\nohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));\nohci_device_request __P((usbd_xfer_handle xfer));\nohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nohci_hash_add_itd __P((ohci_softc_t *, \n\t\t\t    ohci_soft_itd_t *));\nohci_hash_rem_itd __P((ohci_softc_t *,\n\t\t\t    ohci_soft_itd_t *));\nStatic ohci_soft_itd_t;\nohci_setup_isoc __P((usbd_pipe_handle pipe));\nohci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_xfer_handle;\nohci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nohci_root_ctrl_transfer __P((usbd_xfer_handle));\nohci_root_ctrl_start __P((usbd_xfer_handle));\nohci_root_ctrl_abort __P((usbd_xfer_handle));\nohci_root_ctrl_done  __P((usbd_xfer_handle));\nohci_root_intr_transfer __P((usbd_xfer_handle));\nohci_root_intr_start __P((usbd_xfer_handle));\nohci_root_intr_abort __P((usbd_xfer_handle));\nohci_root_intr_done  __P((usbd_xfer_handle));\nohci_device_ctrl_transfer __P((usbd_xfer_handle));\nohci_device_ctrl_start __P((usbd_xfer_handle));\nohci_device_ctrl_abort __P((usbd_xfer_handle));\nohci_device_ctrl_done  __P((usbd_xfer_handle));\nohci_device_bulk_transfer __P((usbd_xfer_handle));\nohci_device_bulk_start __P((usbd_xfer_handle));\nohci_device_bulk_abort __P((usbd_xfer_handle));\nohci_device_bulk_done  __P((usbd_xfer_handle));\nohci_device_intr_transfer __P((usbd_xfer_handle));\nohci_device_intr_start __P((usbd_xfer_handle));\nohci_device_intr_abort __P((usbd_xfer_handle));\nohci_device_intr_done  __P((usbd_xfer_handle));\nohci_device_isoc_transfer __P((usbd_xfer_handle));\nohci_device_isoc_start __P((usbd_xfer_handle));\nohci_device_isoc_abort __P((usbd_xfer_handle));\nohci_device_isoc_done  __P((usbd_xfer_handle));\nohci_rhsc_able __P((ohci_softc_t *, int));\nohci_abort_xfer __P((usbd_xfer_handle xfer,\n\t\t\t    usbd_status status));\nohci_device_clear_toggle __P((usbd_pipe_handle pipe));\nohci_noop __P((usbd_pipe_handle pipe));\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_physaddr_t a;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\nohci_physaddr_t a;\n\nvoid\nohci_device_isoc_enter(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tstruct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;\n\tusbd_device_handle dev = opipe->pipe.device;\n\tohci_softc_t *sc = (ohci_softc_t *)dev->bus;\n\tohci_soft_ed_t *sed = opipe->sed;\n\tstruct iso *iso = &opipe->u.iso;\n\tohci_soft_itd_t *sitd, *nsitd;\t\n\tohci_physaddr_t buf, offs, noffs, bp0;\n\tint i, ncur, nframes;\n\tint s;\n\n\tDPRINTFN(1,(\"ohci_device_isoc_enter: used=%d next=%d xfer=%p \"\n\t\t    \"nframes=%d\\n\",\n\t\t    iso->inuse, iso->next, xfer, xfer->nframes));\n\n\tif (sc->sc_dying)\n\t\treturn;\n\n\tif (iso->next == -1) {\n\t\t/* Not in use yet, schedule it a few frames ahead. */\n\t\tiso->next = le32toh(sc->sc_hcca->hcca_frame_number) + 5;\n\t\tDPRINTFN(2,(\"ohci_device_isoc_enter: start next=%d\\n\", \n\t\t\t    iso->next));\n\t}\n\n\tsitd = opipe->tail.itd;\n\tbuf = DMAADDR(&xfer->dmabuf);\n\tbp0 = OHCI_PAGE(buf);\n\toffs = OHCI_PAGE_OFFSET(buf);\n\tnframes = xfer->nframes;\n\txfer->hcpriv = sitd;\n\tfor (i = ncur = 0; i < nframes; i++, ncur++) {\n\t\tnoffs = offs + xfer->frlengths[i];\n\t\tif (ncur == OHCI_ITD_NOFFSET ||\t/* all offsets used */\n\t\t    OHCI_PAGE(buf + noffs) > bp0 + OHCI_PAGE_SIZE) { /* too many page crossings */\n\t\t\t\n\t\t\t/* Allocate next ITD */\n\t\t\tnsitd = ohci_alloc_sitd(sc);\n\t\t\tif (nsitd == NULL) {\n\t\t\t\t/* XXX what now? */\n\t\t\t\tprintf(\"%s: isoc TD alloc failed\\n\",\n\t\t\t\t       USBDEVNAME(sc->sc_bus.bdev));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/* Fill current ITD */\n\t\t\tsitd->itd.itd_flags = htole32(\n\t\t\t\tOHCI_ITD_NOCC | \n\t\t\t\tOHCI_ITD_SET_SF(iso->next) |\n\t\t\t\tOHCI_ITD_SET_DI(6) | /* delay intr a little */\n\t\t\t\tOHCI_ITD_SET_FC(ncur));\n\t\t\tsitd->itd.itd_bp0 = htole32(bp0);\n\t\t\tsitd->nextitd = nsitd;\n\t\t\tsitd->itd.itd_nextitd = htole32(nsitd->physaddr);\n\t\t\tsitd->itd.itd_be = htole32(bp0 + offs - 1);\n\t\t\tsitd->xfer = xfer;\n\t\t\tsitd->flags = 0;\n\n\t\t\tsitd = nsitd;\n\t\t\tiso->next = iso->next + ncur; \n\t\t\tbp0 = OHCI_PAGE(buf + offs);\n\t\t\tncur = 0;\n\t\t}\n\t\tsitd->itd.itd_offset[ncur] = htole16(OHCI_ITD_MK_OFFS(offs));\n\t\toffs = noffs;\n\t}\n\tnsitd = ohci_alloc_sitd(sc);\n\tif (nsitd == NULL) {\n\t\t/* XXX what now? */\n\t\tprintf(\"%s: isoc TD alloc failed\\n\", \n\t\t       USBDEVNAME(sc->sc_bus.bdev));\n\t\treturn;\n\t}\n\t/* Fixup last used ITD */\n\tsitd->itd.itd_flags = htole32(\n\t\tOHCI_ITD_NOCC | \n\t\tOHCI_ITD_SET_SF(iso->next) |\n\t\tOHCI_ITD_SET_DI(0) |\n\t\tOHCI_ITD_SET_FC(ncur));\n\tsitd->itd.itd_bp0 = htole32(bp0);\n\tsitd->nextitd = nsitd;\n\tsitd->itd.itd_nextitd = htole32(nsitd->physaddr);\n\tsitd->itd.itd_be = htole32(bp0 + offs - 1);\n\tsitd->xfer = xfer;\n\tsitd->flags = OHCI_CALL_DONE;\n\n\tiso->next = iso->next + ncur;\n\tiso->inuse += nframes;\n\n\txfer->actlen = offs;\t/* XXX pretend we did it all */\n\n\txfer->status = USBD_IN_PROGRESS;\n\n#ifdef OHCI_DEBUG\n\tif (ohcidebug > 5) {\n\t\tDPRINTF((\"ohci_device_isoc_enter: frame=%d\\n\",\n\t\t\t le32toh(sc->sc_hcca->hcca_frame_number)));\n\t\tohci_dump_itds(xfer->hcpriv);\n\t\tohci_dump_ed(sed);\n\t}\n#endif\n\n\ts = splusb();\n\topipe->tail.itd = nsitd;\n\tsed->ed.ed_tailp = htole32(nsitd->physaddr);\n\tsplx(s);\n\n#ifdef OHCI_DEBUG\n\tif (ohcidebug > 5) {\n\t\tdelay(150000);\n\t\tDPRINTF((\"ohci_device_isoc_enter: after frame=%d\\n\",\n\t\t\t le32toh(sc->sc_hcca->hcca_frame_number)));\n\t\tohci_dump_itds(xfer->hcpriv);\n\t\tohci_dump_ed(sed);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "usb_insert_transfer",
          "args": [
            "xfer"
          ],
          "line": 3014
        },
        "resolved": true,
        "details": {
          "function_name": "usb_insert_transfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "885-905",
          "snippet": "usbd_status\nusb_insert_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusbd_status err;\n\tint s;\n\n\tDPRINTFN(5,(\"usb_insert_transfer: pipe=%p running=%d timeout=%d\\n\", \n\t\t    pipe, pipe->running, xfer->timeout));\n\ts = splusb();\n\tSIMPLEQ_INSERT_TAIL(&pipe->queue, xfer, next);\n\tif (pipe->running)\n\t\terr = USBD_IN_PROGRESS;\n\telse {\n\t\tpipe->running = 1;\n\t\terr = USBD_NORMAL_COMPLETION;\n\t}\n\tsplx(s);\n\treturn (err);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nusbd_status\nusb_insert_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusbd_status err;\n\tint s;\n\n\tDPRINTFN(5,(\"usb_insert_transfer: pipe=%p running=%d timeout=%d\\n\", \n\t\t    pipe, pipe->running, xfer->timeout));\n\ts = splusb();\n\tSIMPLEQ_INSERT_TAIL(&pipe->queue, xfer, next);\n\tif (pipe->running)\n\t\terr = USBD_IN_PROGRESS;\n\telse {\n\t\tpipe->running = 1;\n\t\terr = USBD_NORMAL_COMPLETION;\n\t}\n\tsplx(s);\n\treturn (err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"ohci_device_isoc_transfer: xfer=%p\\n\", xfer)"
          ],
          "line": 3011
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nStatic usbd_status;\nohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));\nohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));\nStatic usbd_status;\nohci_device_request __P((usbd_xfer_handle xfer));\nStatic usbd_status;\nohci_setup_isoc __P((usbd_pipe_handle pipe));\nohci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic usbd_xfer_handle;\nohci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nStatic usbd_status;\nohci_root_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_ctrl_start __P((usbd_xfer_handle));\nohci_root_ctrl_abort __P((usbd_xfer_handle));\nohci_root_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_intr_start __P((usbd_xfer_handle));\nohci_root_intr_abort __P((usbd_xfer_handle));\nohci_root_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_ctrl_start __P((usbd_xfer_handle));\nohci_device_ctrl_abort __P((usbd_xfer_handle));\nohci_device_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_bulk_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_bulk_start __P((usbd_xfer_handle));\nohci_device_bulk_abort __P((usbd_xfer_handle));\nohci_device_bulk_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_intr_start __P((usbd_xfer_handle));\nohci_device_intr_abort __P((usbd_xfer_handle));\nohci_device_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_isoc_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_isoc_start __P((usbd_xfer_handle));\nohci_device_isoc_abort __P((usbd_xfer_handle));\nohci_device_isoc_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_clear_toggle __P((usbd_pipe_handle pipe));\nohci_noop __P((usbd_pipe_handle pipe));\n\nusbd_status\nohci_device_isoc_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_status err;\n\n\tDPRINTFN(5,(\"ohci_device_isoc_transfer: xfer=%p\\n\", xfer));\n\n\t/* Put it on our queue, */\n\terr = usb_insert_transfer(xfer);\n\n\t/* bail out on error, */\n\tif (err && err != USBD_IN_PROGRESS)\n\t\treturn (err);\n\n\t/* XXX should check inuse here */\n\n\t/* insert into schedule, */\n\tohci_device_isoc_enter(xfer);\n\n\t/* and start if the pipe wasn't running */\n\tif (!err)\n\t\tohci_device_isoc_start(SIMPLEQ_FIRST(&xfer->pipe->queue));\n\n\treturn (err);\n}"
  },
  {
    "function_name": "ohci_device_setintr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "2938-3001",
    "snippet": "Static usbd_status\nohci_device_setintr(sc, opipe, ival)\n\tohci_softc_t *sc;\n\tstruct ohci_pipe *opipe;\n\tint ival;\n{\n\tint i, j, s, best;\n\tu_int npoll, slow, shigh, nslots;\n\tu_int bestbw, bw;\n\tohci_soft_ed_t *hsed, *sed = opipe->sed;\n\n\tDPRINTFN(2, (\"ohci_setintr: pipe=%p\\n\", opipe));\n\tif (ival == 0) {\n\t\tprintf(\"ohci_setintr: 0 interval\\n\");\n\t\treturn (USBD_INVAL);\n\t}\n\n\tnpoll = OHCI_NO_INTRS;\n\twhile (npoll > ival)\n\t\tnpoll /= 2;\n\tDPRINTFN(2, (\"ohci_setintr: ival=%d npoll=%d\\n\", ival, npoll));\n\n\t/*\n\t * We now know which level in the tree the ED must go into.\n\t * Figure out which slot has most bandwidth left over.\n\t * Slots to examine:\n\t * npoll\n\t * 1\t0\n\t * 2\t1 2\n\t * 4\t3 4 5 6\n\t * 8\t7 8 9 10 11 12 13 14\n\t * N    (N-1) .. (N-1+N-1)\n\t */\n\tslow = npoll-1;\n\tshigh = slow + npoll;\n\tnslots = OHCI_NO_INTRS / npoll;\n\tfor (best = i = slow, bestbw = ~0; i < shigh; i++) {\n\t\tbw = 0;\n\t\tfor (j = 0; j < nslots; j++)\n\t\t\tbw += sc->sc_bws[(i * nslots + j) % OHCI_NO_INTRS];\n\t\tif (bw < bestbw) {\n\t\t\tbest = i;\n\t\t\tbestbw = bw;\n\t\t}\n\t}\n\tDPRINTFN(2, (\"ohci_setintr: best=%d(%d..%d) bestbw=%d\\n\", \n\t\t     best, slow, shigh, bestbw));\n\n\ts = splusb();\n\thsed = sc->sc_eds[best];\n\tsed->next = hsed->next;\n\tsed->ed.ed_nexted = hsed->ed.ed_nexted;\n\thsed->next = sed;\n\thsed->ed.ed_nexted = htole32(sed->physaddr);\n\tsplx(s);\n\n\tfor (j = 0; j < nslots; j++)\n\t\t++sc->sc_bws[(best * nslots + j) % OHCI_NO_INTRS];\n\topipe->u.intr.nslots = nslots;\n\topipe->u.intr.pos = best;\n\n\tDPRINTFN(5, (\"ohci_setintr: returns %p\\n\", opipe));\n\treturn (USBD_NORMAL_COMPLETION);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static ohci_soft_ed_t",
      "Static void",
      "ohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));",
      "Static void",
      "Static void",
      "Static usbd_status",
      "Static void",
      "Static void",
      "Static usbd_status",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static usbd_status",
      "Static void",
      "ohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
      "Static void",
      "ohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static usbd_status",
      "ohci_setup_isoc __P((usbd_pipe_handle pipe));",
      "Static void",
      "Static usbd_status",
      "Static void",
      "Static void",
      "Static usbd_status",
      "Static usbd_status",
      "Static void",
      "Static void",
      "Static void",
      "Static usbd_status",
      "Static usbd_status",
      "Static void",
      "Static void",
      "Static void",
      "Static usbd_status",
      "Static usbd_status",
      "Static void",
      "Static void",
      "Static void",
      "Static usbd_status",
      "Static usbd_status",
      "Static void",
      "Static void",
      "Static void",
      "Static usbd_status",
      "Static usbd_status",
      "Static void",
      "Static void",
      "Static void",
      "Static usbd_status",
      "Static usbd_status",
      "Static void",
      "Static void",
      "Static void",
      "Static usbd_status",
      "ohci_device_setintr __P((ohci_softc_t *sc, \n\t\t\t    struct ohci_pipe *pipe, int ival));",
      "Static int",
      "Static void",
      "Static void",
      "ohci_rhsc_able __P((ohci_softc_t *, int));",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "ohci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "Static void",
      "ohci_noop __P((usbd_pipe_handle pipe));",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
      "Static int",
      "ohci_intr1 __P((ohci_softc_t *));",
      "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"ohci_setintr: returns %p\\n\", opipe)"
          ],
          "line": 2999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 2992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "sed->physaddr"
          ],
          "line": 2991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 2986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "2",
            "(\"ohci_setintr: best=%d(%d..%d) bestbw=%d\\n\", \n\t\t     best, slow, shigh, bestbw)"
          ],
          "line": 2983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "2",
            "(\"ohci_setintr: ival=%d npoll=%d\\n\", ival, npoll)"
          ],
          "line": 2958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ohci_setintr: 0 interval\\n\""
          ],
          "line": 2951
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "2",
            "(\"ohci_setintr: pipe=%p\\n\", opipe)"
          ],
          "line": 2949
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_ed_t;\nStatic void;\nohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));\nStatic void;\nStatic void;\nStatic usbd_status;\nStatic void;\nStatic void;\nStatic usbd_status;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic usbd_status;\nStatic void;\nohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nStatic void;\nohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic usbd_status;\nohci_setup_isoc __P((usbd_pipe_handle pipe));\nStatic void;\nStatic usbd_status;\nStatic void;\nStatic void;\nStatic usbd_status;\nStatic usbd_status;\nStatic void;\nStatic void;\nStatic void;\nStatic usbd_status;\nStatic usbd_status;\nStatic void;\nStatic void;\nStatic void;\nStatic usbd_status;\nStatic usbd_status;\nStatic void;\nStatic void;\nStatic void;\nStatic usbd_status;\nStatic usbd_status;\nStatic void;\nStatic void;\nStatic void;\nStatic usbd_status;\nStatic usbd_status;\nStatic void;\nStatic void;\nStatic void;\nStatic usbd_status;\nStatic usbd_status;\nStatic void;\nStatic void;\nStatic void;\nStatic usbd_status;\nohci_device_setintr __P((ohci_softc_t *sc, \n\t\t\t    struct ohci_pipe *pipe, int ival));\nStatic int;\nStatic void;\nStatic void;\nohci_rhsc_able __P((ohci_softc_t *, int));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_device_clear_toggle __P((usbd_pipe_handle pipe));\nStatic void;\nohci_noop __P((usbd_pipe_handle pipe));\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nStatic int;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nStatic usbd_status\nohci_device_setintr(sc, opipe, ival)\n\tohci_softc_t *sc;\n\tstruct ohci_pipe *opipe;\n\tint ival;\n{\n\tint i, j, s, best;\n\tu_int npoll, slow, shigh, nslots;\n\tu_int bestbw, bw;\n\tohci_soft_ed_t *hsed, *sed = opipe->sed;\n\n\tDPRINTFN(2, (\"ohci_setintr: pipe=%p\\n\", opipe));\n\tif (ival == 0) {\n\t\tprintf(\"ohci_setintr: 0 interval\\n\");\n\t\treturn (USBD_INVAL);\n\t}\n\n\tnpoll = OHCI_NO_INTRS;\n\twhile (npoll > ival)\n\t\tnpoll /= 2;\n\tDPRINTFN(2, (\"ohci_setintr: ival=%d npoll=%d\\n\", ival, npoll));\n\n\t/*\n\t * We now know which level in the tree the ED must go into.\n\t * Figure out which slot has most bandwidth left over.\n\t * Slots to examine:\n\t * npoll\n\t * 1\t0\n\t * 2\t1 2\n\t * 4\t3 4 5 6\n\t * 8\t7 8 9 10 11 12 13 14\n\t * N    (N-1) .. (N-1+N-1)\n\t */\n\tslow = npoll-1;\n\tshigh = slow + npoll;\n\tnslots = OHCI_NO_INTRS / npoll;\n\tfor (best = i = slow, bestbw = ~0; i < shigh; i++) {\n\t\tbw = 0;\n\t\tfor (j = 0; j < nslots; j++)\n\t\t\tbw += sc->sc_bws[(i * nslots + j) % OHCI_NO_INTRS];\n\t\tif (bw < bestbw) {\n\t\t\tbest = i;\n\t\t\tbestbw = bw;\n\t\t}\n\t}\n\tDPRINTFN(2, (\"ohci_setintr: best=%d(%d..%d) bestbw=%d\\n\", \n\t\t     best, slow, shigh, bestbw));\n\n\ts = splusb();\n\thsed = sc->sc_eds[best];\n\tsed->next = hsed->next;\n\tsed->ed.ed_nexted = hsed->ed.ed_nexted;\n\thsed->next = sed;\n\thsed->ed.ed_nexted = htole32(sed->physaddr);\n\tsplx(s);\n\n\tfor (j = 0; j < nslots; j++)\n\t\t++sc->sc_bws[(best * nslots + j) % OHCI_NO_INTRS];\n\topipe->u.intr.nslots = nslots;\n\topipe->u.intr.pos = best;\n\n\tDPRINTFN(5, (\"ohci_setintr: returns %p\\n\", opipe));\n\treturn (USBD_NORMAL_COMPLETION);\n}"
  },
  {
    "function_name": "ohci_device_intr_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "2901-2936",
    "snippet": "Static void\nohci_device_intr_close(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tstruct ohci_pipe *opipe = (struct ohci_pipe *)pipe;\n\tohci_softc_t *sc = (ohci_softc_t *)pipe->device->bus;\n\tint nslots = opipe->u.intr.nslots;\n\tint pos = opipe->u.intr.pos;\n\tint j;\n\tohci_soft_ed_t *p, *sed = opipe->sed;\n\tint s;\n\n\tDPRINTFN(1,(\"ohci_device_intr_close: pipe=%p nslots=%d pos=%d\\n\",\n\t\t    pipe, nslots, pos));\n\ts = splusb();\n\tsed->ed.ed_flags |= htole32(OHCI_ED_SKIP);\n\tif ((le32toh(sed->ed.ed_tailp) & OHCI_HEADMASK) != \n\t    (le32toh(sed->ed.ed_headp) & OHCI_HEADMASK))\n\t\tusb_delay_ms(&sc->sc_bus, 2);\n\n\tfor (p = sc->sc_eds[pos]; p && p->next != sed; p = p->next)\n\t\t;\n#ifdef DIAGNOSTIC\n\tif (p == NULL)\n\t\tpanic(\"ohci_device_intr_close: ED not found\\n\");\n#endif\n\tp->next = sed->next;\n\tp->ed.ed_nexted = sed->ed.ed_nexted;\n\tsplx(s);\n\n\tfor (j = 0; j < nslots; j++)\n\t\t--sc->sc_bws[(pos * nslots + j) % OHCI_NO_INTRS];\n\n\tohci_free_std(sc, opipe->tail.td);\n\tohci_free_sed(sc, opipe->sed);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static ohci_soft_ed_t",
      "Static void",
      "ohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "ohci_open __P((usbd_pipe_handle));",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "ohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
      "Static void",
      "ohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "ohci_setup_isoc __P((usbd_pipe_handle pipe));",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "ohci_root_ctrl_close __P((usbd_pipe_handle));",
      "Static void",
      "Static void",
      "Static void",
      "ohci_root_intr_close __P((usbd_pipe_handle));",
      "Static void",
      "Static void",
      "Static void",
      "ohci_device_ctrl_close __P((usbd_pipe_handle));",
      "Static void",
      "Static void",
      "Static void",
      "ohci_device_bulk_close __P((usbd_pipe_handle));",
      "Static void",
      "Static void",
      "Static void",
      "ohci_device_intr_close __P((usbd_pipe_handle));",
      "Static void",
      "Static void",
      "Static void",
      "ohci_device_isoc_close __P((usbd_pipe_handle));",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "ohci_rhsc_able __P((ohci_softc_t *, int));",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "ohci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "Static void",
      "ohci_noop __P((usbd_pipe_handle pipe));",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
      "Static int",
      "ohci_intr1 __P((ohci_softc_t *));",
      "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ohci_free_sed",
          "args": [
            "sc",
            "opipe->sed"
          ],
          "line": 2935
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_free_sed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "417-424",
          "snippet": "void\nohci_free_sed(sc, sed)\n\tohci_softc_t *sc;\n\tohci_soft_ed_t *sed;\n{\n\tsed->next = sc->sc_freeeds;\n\tsc->sc_freeeds = sed;\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static ohci_soft_ed_t",
            "ohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));",
            "ohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
            "ohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
            "ohci_rhsc_able __P((ohci_softc_t *, int));",
            "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
            "ohci_intr1 __P((ohci_softc_t *));",
            "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_ed_t;\nohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));\nohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nohci_rhsc_able __P((ohci_softc_t *, int));\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nvoid\nohci_free_sed(sc, sed)\n\tohci_softc_t *sc;\n\tohci_soft_ed_t *sed;\n{\n\tsed->next = sc->sc_freeeds;\n\tsc->sc_freeeds = sed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ohci_free_std",
          "args": [
            "sc",
            "opipe->tail.td"
          ],
          "line": 2934
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_free_std_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "577-589",
          "snippet": "Static void\nohci_free_std_chain(sc, std, stdend)\n\tohci_softc_t *sc;\n\tohci_soft_td_t *std;\n\tohci_soft_td_t *stdend;\n{\n\tohci_soft_td_t *p;\n\n\tfor (; std != stdend; std = p) {\n\t\tp = std->nexttd;\n\t\tohci_free_std(sc, std);\n\t}\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static void",
            "Static ohci_soft_td_t",
            "Static void",
            "ohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));",
            "Static void",
            "ohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "ohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));",
            "Static void",
            "ohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));",
            "Static ohci_soft_td_t",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "ohci_rhsc_able __P((ohci_softc_t *, int));",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
            "Static int",
            "ohci_intr1 __P((ohci_softc_t *));",
            "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nStatic ohci_soft_td_t;\nStatic void;\nohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));\nStatic void;\nohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));\nStatic void;\nohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));\nStatic ohci_soft_td_t;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nohci_rhsc_able __P((ohci_softc_t *, int));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nStatic int;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nStatic void\nohci_free_std_chain(sc, std, stdend)\n\tohci_softc_t *sc;\n\tohci_soft_td_t *std;\n\tohci_soft_td_t *stdend;\n{\n\tohci_soft_td_t *p;\n\n\tfor (; std != stdend; std = p) {\n\t\tp = std->nexttd;\n\t\tohci_free_std(sc, std);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 2929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"ohci_device_intr_close: ED not found\\n\""
          ],
          "line": 2925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_delay_ms",
          "args": [
            "&sc->sc_bus",
            "2"
          ],
          "line": 2919
        },
        "resolved": true,
        "details": {
          "function_name": "usb_delay_ms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "301-313",
          "snippet": "void\nusb_delay_ms(bus, ms)\n\tusbd_bus_handle bus;\n\tu_int ms;\n{\n\textern int cold;\n\n\t/* Wait at least two clock ticks so we know the time has passed. */\n\tif (bus->use_polling || cold)\n\t\tdelay((ms+1) * 1000);\n\telse\n\t\ttsleep(&ms, PRIBIO, \"usbdly\", (ms*hz+999)/1000 + 1);\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_getnewaddr __P((usbd_bus_handle bus));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_getnewaddr __P((usbd_bus_handle bus));\n\nvoid\nusb_delay_ms(bus, ms)\n\tusbd_bus_handle bus;\n\tu_int ms;\n{\n\textern int cold;\n\n\t/* Wait at least two clock ticks so we know the time has passed. */\n\tif (bus->use_polling || cold)\n\t\tdelay((ms+1) * 1000);\n\telse\n\t\ttsleep(&ms, PRIBIO, \"usbdly\", (ms*hz+999)/1000 + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "sed->ed.ed_headp"
          ],
          "line": 2918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "sed->ed.ed_tailp"
          ],
          "line": 2917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "OHCI_ED_SKIP"
          ],
          "line": 2916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 2915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"ohci_device_intr_close: pipe=%p nslots=%d pos=%d\\n\",\n\t\t    pipe, nslots, pos)"
          ],
          "line": 2913
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_ed_t;\nStatic void;\nohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_open __P((usbd_pipe_handle));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nStatic void;\nohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_setup_isoc __P((usbd_pipe_handle pipe));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_root_ctrl_close __P((usbd_pipe_handle));\nStatic void;\nStatic void;\nStatic void;\nohci_root_intr_close __P((usbd_pipe_handle));\nStatic void;\nStatic void;\nStatic void;\nohci_device_ctrl_close __P((usbd_pipe_handle));\nStatic void;\nStatic void;\nStatic void;\nohci_device_bulk_close __P((usbd_pipe_handle));\nStatic void;\nStatic void;\nStatic void;\nohci_device_intr_close __P((usbd_pipe_handle));\nStatic void;\nStatic void;\nStatic void;\nohci_device_isoc_close __P((usbd_pipe_handle));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nohci_rhsc_able __P((ohci_softc_t *, int));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_device_clear_toggle __P((usbd_pipe_handle pipe));\nStatic void;\nohci_noop __P((usbd_pipe_handle pipe));\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nStatic int;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nStatic void\nohci_device_intr_close(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tstruct ohci_pipe *opipe = (struct ohci_pipe *)pipe;\n\tohci_softc_t *sc = (ohci_softc_t *)pipe->device->bus;\n\tint nslots = opipe->u.intr.nslots;\n\tint pos = opipe->u.intr.pos;\n\tint j;\n\tohci_soft_ed_t *p, *sed = opipe->sed;\n\tint s;\n\n\tDPRINTFN(1,(\"ohci_device_intr_close: pipe=%p nslots=%d pos=%d\\n\",\n\t\t    pipe, nslots, pos));\n\ts = splusb();\n\tsed->ed.ed_flags |= htole32(OHCI_ED_SKIP);\n\tif ((le32toh(sed->ed.ed_tailp) & OHCI_HEADMASK) != \n\t    (le32toh(sed->ed.ed_headp) & OHCI_HEADMASK))\n\t\tusb_delay_ms(&sc->sc_bus, 2);\n\n\tfor (p = sc->sc_eds[pos]; p && p->next != sed; p = p->next)\n\t\t;\n#ifdef DIAGNOSTIC\n\tif (p == NULL)\n\t\tpanic(\"ohci_device_intr_close: ED not found\\n\");\n#endif\n\tp->next = sed->next;\n\tp->ed.ed_nexted = sed->ed.ed_nexted;\n\tsplx(s);\n\n\tfor (j = 0; j < nslots; j++)\n\t\t--sc->sc_bws[(pos * nslots + j) % OHCI_NO_INTRS];\n\n\tohci_free_std(sc, opipe->tail.td);\n\tohci_free_sed(sc, opipe->sed);\n}"
  },
  {
    "function_name": "ohci_device_intr_abort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "2889-2898",
    "snippet": "Static void\nohci_device_intr_abort(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tif (xfer->pipe->intrxfer == xfer) {\n\t\tDPRINTF((\"ohci_device_intr_abort: remove\\n\"));\n\t\txfer->pipe->intrxfer = NULL;\n\t}\n\tohci_abort_xfer(xfer, USBD_CANCELLED);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "ohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));",
      "ohci_device_request __P((usbd_xfer_handle xfer));",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "ohci_setup_isoc __P((usbd_pipe_handle pipe));",
      "Static void",
      "ohci_device_isoc_enter __P((usbd_xfer_handle));",
      "Static void",
      "Static usbd_xfer_handle",
      "Static void",
      "ohci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "ohci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "ohci_root_ctrl_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_root_ctrl_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_root_ctrl_done  __P((usbd_xfer_handle));",
      "ohci_root_intr_transfer __P((usbd_xfer_handle));",
      "ohci_root_intr_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_root_intr_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_root_intr_done  __P((usbd_xfer_handle));",
      "ohci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "ohci_device_ctrl_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_device_ctrl_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_device_ctrl_done  __P((usbd_xfer_handle));",
      "ohci_device_bulk_transfer __P((usbd_xfer_handle));",
      "ohci_device_bulk_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_device_bulk_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_device_bulk_done  __P((usbd_xfer_handle));",
      "ohci_device_intr_transfer __P((usbd_xfer_handle));",
      "ohci_device_intr_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_device_intr_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_device_intr_done  __P((usbd_xfer_handle));",
      "ohci_device_isoc_transfer __P((usbd_xfer_handle));",
      "ohci_device_isoc_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_device_isoc_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_device_isoc_done  __P((usbd_xfer_handle));",
      "Static int",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "ohci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "Static void",
      "ohci_noop __P((usbd_pipe_handle pipe));",
      "Static int"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ohci_abort_xfer",
          "args": [
            "xfer",
            "USBD_CANCELLED"
          ],
          "line": 2897
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_abort_xfer_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "2059-2093",
          "snippet": "void\nohci_abort_xfer_end(v)\n\tvoid *v;\n{\n\tusbd_xfer_handle xfer = v;\n\tstruct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;\n\tohci_softc_t *sc = (ohci_softc_t *)opipe->pipe.device->bus;\n\tohci_soft_ed_t *sed;\n\tohci_soft_td_t *p, *n;\n\tint s;\n\n\ts = splusb();\n\n\tp = xfer->hcpriv;\n#ifdef DIAGNOSTIC\n\tif (p == NULL) {\n\t\tprintf(\"ohci_abort_xfer: hcpriv==0\\n\");\n\t\treturn;\n\t}\n#endif\n\tfor (; p->xfer == xfer; p = n) {\n\t\tn = p->nexttd;\n\t\tohci_free_std(sc, p);\n\t}\n\n\tsed = opipe->sed;\n\tDPRINTFN(2,(\"ohci_abort_xfer: set hd=%x, tl=%x\\n\",\n\t\t    (int)p->physaddr, (int)le32toh(sed->ed.ed_tailp)));\n\tsed->ed.ed_headp = htole32(p->physaddr); /* unlink TDs */\n\tsed->ed.ed_flags &= htole32(~OHCI_ED_SKIP); /* remove hardware skip */\n\n\tusb_transfer_complete(xfer);\n\n\tsplx(s);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static ohci_soft_ed_t",
            "ohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));",
            "Static ohci_soft_td_t",
            "ohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));",
            "ohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));",
            "ohci_shutdown __P((void *v));",
            "ohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));",
            "ohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));",
            "ohci_device_request __P((usbd_xfer_handle xfer));",
            "ohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
            "ohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
            "ohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));",
            "ohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));",
            "Static ohci_soft_td_t",
            "ohci_setup_isoc __P((usbd_pipe_handle pipe));",
            "ohci_device_isoc_enter __P((usbd_xfer_handle));",
            "Static usbd_xfer_handle",
            "ohci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
            "ohci_root_ctrl_transfer __P((usbd_xfer_handle));",
            "ohci_root_ctrl_start __P((usbd_xfer_handle));",
            "ohci_root_ctrl_abort __P((usbd_xfer_handle));",
            "ohci_root_ctrl_done  __P((usbd_xfer_handle));",
            "ohci_root_intr_transfer __P((usbd_xfer_handle));",
            "ohci_root_intr_start __P((usbd_xfer_handle));",
            "ohci_root_intr_abort __P((usbd_xfer_handle));",
            "ohci_root_intr_done  __P((usbd_xfer_handle));",
            "ohci_device_ctrl_transfer __P((usbd_xfer_handle));",
            "ohci_device_ctrl_start __P((usbd_xfer_handle));",
            "ohci_device_ctrl_abort __P((usbd_xfer_handle));",
            "ohci_device_ctrl_done  __P((usbd_xfer_handle));",
            "ohci_device_bulk_transfer __P((usbd_xfer_handle));",
            "ohci_device_bulk_start __P((usbd_xfer_handle));",
            "ohci_device_bulk_abort __P((usbd_xfer_handle));",
            "ohci_device_bulk_done  __P((usbd_xfer_handle));",
            "ohci_device_intr_transfer __P((usbd_xfer_handle));",
            "ohci_device_intr_start __P((usbd_xfer_handle));",
            "ohci_device_intr_abort __P((usbd_xfer_handle));",
            "ohci_device_intr_done  __P((usbd_xfer_handle));",
            "ohci_device_isoc_transfer __P((usbd_xfer_handle));",
            "ohci_device_isoc_start __P((usbd_xfer_handle));",
            "ohci_device_isoc_abort __P((usbd_xfer_handle));",
            "ohci_device_isoc_done  __P((usbd_xfer_handle));",
            "ohci_rhsc_able __P((ohci_softc_t *, int));",
            "ohci_device_clear_toggle __P((usbd_pipe_handle pipe));",
            "ohci_noop __P((usbd_pipe_handle pipe));",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
            "ohci_intr1 __P((ohci_softc_t *));",
            "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_ed_t;\nohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));\nStatic ohci_soft_td_t;\nohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));\nohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));\nohci_shutdown __P((void *v));\nohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));\nohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));\nohci_device_request __P((usbd_xfer_handle xfer));\nohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));\nohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));\nStatic ohci_soft_td_t;\nohci_setup_isoc __P((usbd_pipe_handle pipe));\nohci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_xfer_handle;\nohci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nohci_root_ctrl_transfer __P((usbd_xfer_handle));\nohci_root_ctrl_start __P((usbd_xfer_handle));\nohci_root_ctrl_abort __P((usbd_xfer_handle));\nohci_root_ctrl_done  __P((usbd_xfer_handle));\nohci_root_intr_transfer __P((usbd_xfer_handle));\nohci_root_intr_start __P((usbd_xfer_handle));\nohci_root_intr_abort __P((usbd_xfer_handle));\nohci_root_intr_done  __P((usbd_xfer_handle));\nohci_device_ctrl_transfer __P((usbd_xfer_handle));\nohci_device_ctrl_start __P((usbd_xfer_handle));\nohci_device_ctrl_abort __P((usbd_xfer_handle));\nohci_device_ctrl_done  __P((usbd_xfer_handle));\nohci_device_bulk_transfer __P((usbd_xfer_handle));\nohci_device_bulk_start __P((usbd_xfer_handle));\nohci_device_bulk_abort __P((usbd_xfer_handle));\nohci_device_bulk_done  __P((usbd_xfer_handle));\nohci_device_intr_transfer __P((usbd_xfer_handle));\nohci_device_intr_start __P((usbd_xfer_handle));\nohci_device_intr_abort __P((usbd_xfer_handle));\nohci_device_intr_done  __P((usbd_xfer_handle));\nohci_device_isoc_transfer __P((usbd_xfer_handle));\nohci_device_isoc_start __P((usbd_xfer_handle));\nohci_device_isoc_abort __P((usbd_xfer_handle));\nohci_device_isoc_done  __P((usbd_xfer_handle));\nohci_rhsc_able __P((ohci_softc_t *, int));\nohci_device_clear_toggle __P((usbd_pipe_handle pipe));\nohci_noop __P((usbd_pipe_handle pipe));\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nvoid\nohci_abort_xfer_end(v)\n\tvoid *v;\n{\n\tusbd_xfer_handle xfer = v;\n\tstruct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;\n\tohci_softc_t *sc = (ohci_softc_t *)opipe->pipe.device->bus;\n\tohci_soft_ed_t *sed;\n\tohci_soft_td_t *p, *n;\n\tint s;\n\n\ts = splusb();\n\n\tp = xfer->hcpriv;\n#ifdef DIAGNOSTIC\n\tif (p == NULL) {\n\t\tprintf(\"ohci_abort_xfer: hcpriv==0\\n\");\n\t\treturn;\n\t}\n#endif\n\tfor (; p->xfer == xfer; p = n) {\n\t\tn = p->nexttd;\n\t\tohci_free_std(sc, p);\n\t}\n\n\tsed = opipe->sed;\n\tDPRINTFN(2,(\"ohci_abort_xfer: set hd=%x, tl=%x\\n\",\n\t\t    (int)p->physaddr, (int)le32toh(sed->ed.ed_tailp)));\n\tsed->ed.ed_headp = htole32(p->physaddr); /* unlink TDs */\n\tsed->ed.ed_flags &= htole32(~OHCI_ED_SKIP); /* remove hardware skip */\n\n\tusb_transfer_complete(xfer);\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ohci_device_intr_abort: remove\\n\")"
          ],
          "line": 2894
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));\nohci_device_request __P((usbd_xfer_handle xfer));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_setup_isoc __P((usbd_pipe_handle pipe));\nStatic void;\nohci_device_isoc_enter __P((usbd_xfer_handle));\nStatic void;\nStatic usbd_xfer_handle;\nStatic void;\nohci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nohci_root_ctrl_transfer __P((usbd_xfer_handle));\nohci_root_ctrl_start __P((usbd_xfer_handle));\nStatic void;\nohci_root_ctrl_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_root_ctrl_done  __P((usbd_xfer_handle));\nohci_root_intr_transfer __P((usbd_xfer_handle));\nohci_root_intr_start __P((usbd_xfer_handle));\nStatic void;\nohci_root_intr_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_root_intr_done  __P((usbd_xfer_handle));\nohci_device_ctrl_transfer __P((usbd_xfer_handle));\nohci_device_ctrl_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_ctrl_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_ctrl_done  __P((usbd_xfer_handle));\nohci_device_bulk_transfer __P((usbd_xfer_handle));\nohci_device_bulk_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_bulk_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_bulk_done  __P((usbd_xfer_handle));\nohci_device_intr_transfer __P((usbd_xfer_handle));\nohci_device_intr_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_intr_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_intr_done  __P((usbd_xfer_handle));\nohci_device_isoc_transfer __P((usbd_xfer_handle));\nohci_device_isoc_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_isoc_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_isoc_done  __P((usbd_xfer_handle));\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_device_clear_toggle __P((usbd_pipe_handle pipe));\nStatic void;\nohci_noop __P((usbd_pipe_handle pipe));\nStatic int;\n\nStatic void\nohci_device_intr_abort(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tif (xfer->pipe->intrxfer == xfer) {\n\t\tDPRINTF((\"ohci_device_intr_abort: remove\\n\"));\n\t\txfer->pipe->intrxfer = NULL;\n\t}\n\tohci_abort_xfer(xfer, USBD_CANCELLED);\n}"
  },
  {
    "function_name": "ohci_device_intr_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "2809-2886",
    "snippet": "Static usbd_status\nohci_device_intr_start(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tstruct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;\n\tusbd_device_handle dev = opipe->pipe.device;\n\tohci_softc_t *sc = (ohci_softc_t *)dev->bus;\n\tohci_soft_ed_t *sed = opipe->sed;\n\tohci_soft_td_t *data, *tail;\n\tint len;\n\tint s;\n\n\tif (sc->sc_dying)\n\t\treturn (USBD_IOERROR);\n\n\tDPRINTFN(3, (\"ohci_device_intr_transfer: xfer=%p len=%d \"\n\t\t     \"flags=%d priv=%p\\n\",\n\t\t     xfer, xfer->length, xfer->flags, xfer->priv));\n\n#ifdef DIAGNOSTIC\n\tif (xfer->rqflags & URQ_REQUEST)\n\t\tpanic(\"ohci_device_intr_transfer: a request\\n\");\n#endif\n\n\tlen = xfer->length;\n\n\tdata = opipe->tail.td;\n\ttail = ohci_alloc_std(sc);\n\tif (tail == NULL)\n\t\treturn (USBD_NOMEM);\n\ttail->xfer = NULL;\n\n\tdata->td.td_flags = htole32(\n\t\tOHCI_TD_IN | OHCI_TD_NOCC | \n\t\tOHCI_TD_SET_DI(1) | OHCI_TD_TOGGLE_CARRY);\n\tif (xfer->flags & USBD_SHORT_XFER_OK)\n\t\tdata->td.td_flags |= htole32(OHCI_TD_R);\n\tdata->td.td_cbp = htole32(DMAADDR(&xfer->dmabuf));\n\tdata->nexttd = tail;\n\tdata->td.td_nexttd = htole32(tail->physaddr);\n\tdata->td.td_be = htole32(le32toh(data->td.td_cbp) + len - 1);\n\tdata->len = len;\n\tdata->xfer = xfer;\n\tdata->flags = OHCI_CALL_DONE | OHCI_ADD_LEN;\n\txfer->hcpriv = data;\n\n#ifdef OHCI_DEBUG\n\tif (ohcidebug > 5) {\n\t\tDPRINTF((\"ohci_device_intr_transfer:\\n\"));\n\t\tohci_dump_ed(sed);\n\t\tohci_dump_tds(data);\n\t}\n#endif\n\n\t/* Insert ED in schedule */\n\ts = splusb();\n\tsed->ed.ed_tailp = htole32(tail->physaddr);\n\topipe->tail.td = tail;\n\tsed->ed.ed_flags &= htole32(~OHCI_ED_SKIP);\n\n#if 0\n/*\n * This goes horribly wrong, printing thousands of descriptors,\n * because false references are followed due to the fact that the\n * TD is gone.\n */\n\tif (ohcidebug > 5) {\n\t\tusb_delay_ms(&sc->sc_bus, 5);\n\t\tDPRINTF((\"ohci_device_intr_transfer: status=%x\\n\",\n\t\t\t OREAD4(sc, OHCI_COMMAND_STATUS)));\n\t\tohci_dump_ed(sed);\n\t\tohci_dump_tds(data);\n\t}\n#endif\n\tsplx(s);\n\n\treturn (USBD_IN_PROGRESS);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static ohci_soft_ed_t",
      "Static void",
      "ohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));",
      "Static ohci_soft_td_t",
      "Static void",
      "ohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));",
      "Static void",
      "Static usbd_status",
      "ohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));",
      "Static void",
      "Static void",
      "Static usbd_status",
      "Static void",
      "Static void",
      "Static void",
      "ohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_request __P((usbd_xfer_handle xfer));",
      "Static void",
      "ohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
      "Static void",
      "ohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
      "Static void",
      "ohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));",
      "Static void",
      "ohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));",
      "Static ohci_soft_td_t",
      "Static void",
      "Static void",
      "Static usbd_status",
      "ohci_setup_isoc __P((usbd_pipe_handle pipe));",
      "Static void",
      "ohci_device_isoc_enter __P((usbd_xfer_handle));",
      "Static usbd_status",
      "Static void",
      "Static usbd_xfer_handle",
      "Static void",
      "ohci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_root_ctrl_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_root_ctrl_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_root_ctrl_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_root_intr_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_root_intr_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_root_intr_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_root_intr_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_ctrl_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_device_ctrl_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_device_ctrl_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_bulk_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_bulk_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_device_bulk_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_device_bulk_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_intr_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_intr_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_device_intr_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_device_intr_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_isoc_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_isoc_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_device_isoc_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_device_isoc_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "Static int",
      "Static void",
      "Static void",
      "ohci_rhsc_able __P((ohci_softc_t *, int));",
      "Static void",
      "Static void",
      "ohci_abort_xfer __P((usbd_xfer_handle xfer,\n\t\t\t    usbd_status status));",
      "Static void",
      "Static void",
      "ohci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "Static void",
      "ohci_noop __P((usbd_pipe_handle pipe));",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
      "Static int",
      "ohci_intr1 __P((ohci_softc_t *));",
      "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
      "ohci_physaddr_t a;",
      "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;",
      "ohci_physaddr_t a;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 2883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ohci_dump_tds",
          "args": [
            "data"
          ],
          "line": 2880
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_dump_tds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "1787-1793",
          "snippet": "void\nohci_dump_tds(std)\n\tohci_soft_td_t *std;\n{\n\tfor (; std; std = std->nexttd)\n\t\tohci_dump_td(std);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static ohci_soft_td_t",
            "ohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));",
            "ohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));",
            "ohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));",
            "ohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));",
            "Static ohci_soft_td_t"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_td_t;\nohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));\nohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));\nohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));\nohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));\nStatic ohci_soft_td_t;\n\nvoid\nohci_dump_tds(std)\n\tohci_soft_td_t *std;\n{\n\tfor (; std; std = std->nexttd)\n\t\tohci_dump_td(std);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ohci_dump_ed",
          "args": [
            "sed"
          ],
          "line": 2879
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_dump_ed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "1842-1859",
          "snippet": "void\nohci_dump_ed(sed)\n\tohci_soft_ed_t *sed;\n{\n\tDPRINTF((\"ED(%p) at 0x%08lx: addr=%d endpt=%d maxp=%d %b\\ntailp=0x%08lx \"\n\t\t \"headflags=%b headp=0x%08lx nexted=0x%08lx\\n\",\n\t\t sed, (u_long)sed->physaddr, \n\t\t OHCI_ED_GET_FA(le32toh(sed->ed.ed_flags)),\n\t\t OHCI_ED_GET_EN(le32toh(sed->ed.ed_flags)),\n\t\t OHCI_ED_GET_MAXP(le32toh(sed->ed.ed_flags)),\n\t\t (int)le32toh(sed->ed.ed_flags),\n\t\t \"\\20\\14OUT\\15IN\\16LOWSPEED\\17SKIP\\20ISO\",\n\t\t (u_long)le32toh(sed->ed.ed_tailp),\n\t\t (u_long)le32toh(sed->ed.ed_headp),\n\t\t \"\\20\\1HALT\\2CARRY\",\n\t\t (u_long)le32toh(sed->ed.ed_headp),\n\t\t (u_long)le32toh(sed->ed.ed_nexted)));\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static ohci_soft_ed_t",
            "ohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));",
            "ohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
            "ohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_ed_t;\nohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));\nohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\n\nvoid\nohci_dump_ed(sed)\n\tohci_soft_ed_t *sed;\n{\n\tDPRINTF((\"ED(%p) at 0x%08lx: addr=%d endpt=%d maxp=%d %b\\ntailp=0x%08lx \"\n\t\t \"headflags=%b headp=0x%08lx nexted=0x%08lx\\n\",\n\t\t sed, (u_long)sed->physaddr, \n\t\t OHCI_ED_GET_FA(le32toh(sed->ed.ed_flags)),\n\t\t OHCI_ED_GET_EN(le32toh(sed->ed.ed_flags)),\n\t\t OHCI_ED_GET_MAXP(le32toh(sed->ed.ed_flags)),\n\t\t (int)le32toh(sed->ed.ed_flags),\n\t\t \"\\20\\14OUT\\15IN\\16LOWSPEED\\17SKIP\\20ISO\",\n\t\t (u_long)le32toh(sed->ed.ed_tailp),\n\t\t (u_long)le32toh(sed->ed.ed_headp),\n\t\t \"\\20\\1HALT\\2CARRY\",\n\t\t (u_long)le32toh(sed->ed.ed_headp),\n\t\t (u_long)le32toh(sed->ed.ed_nexted)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ohci_device_intr_transfer: status=%x\\n\",\n\t\t\t OREAD4(sc, OHCI_COMMAND_STATUS))"
          ],
          "line": 2877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OREAD4",
          "args": [
            "sc",
            "OHCI_COMMAND_STATUS"
          ],
          "line": 2878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_delay_ms",
          "args": [
            "&sc->sc_bus",
            "5"
          ],
          "line": 2876
        },
        "resolved": true,
        "details": {
          "function_name": "usb_delay_ms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "301-313",
          "snippet": "void\nusb_delay_ms(bus, ms)\n\tusbd_bus_handle bus;\n\tu_int ms;\n{\n\textern int cold;\n\n\t/* Wait at least two clock ticks so we know the time has passed. */\n\tif (bus->use_polling || cold)\n\t\tdelay((ms+1) * 1000);\n\telse\n\t\ttsleep(&ms, PRIBIO, \"usbdly\", (ms*hz+999)/1000 + 1);\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_getnewaddr __P((usbd_bus_handle bus));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_getnewaddr __P((usbd_bus_handle bus));\n\nvoid\nusb_delay_ms(bus, ms)\n\tusbd_bus_handle bus;\n\tu_int ms;\n{\n\textern int cold;\n\n\t/* Wait at least two clock ticks so we know the time has passed. */\n\tif (bus->use_polling || cold)\n\t\tdelay((ms+1) * 1000);\n\telse\n\t\ttsleep(&ms, PRIBIO, \"usbdly\", (ms*hz+999)/1000 + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "~OHCI_ED_SKIP"
          ],
          "line": 2867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "tail->physaddr"
          ],
          "line": 2865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 2864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ohci_device_intr_transfer:\\n\")"
          ],
          "line": 2857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "le32toh(data->td.td_cbp) + len - 1"
          ],
          "line": 2849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "data->td.td_cbp"
          ],
          "line": 2849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "tail->physaddr"
          ],
          "line": 2848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "DMAADDR(&xfer->dmabuf)"
          ],
          "line": 2846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DMAADDR",
          "args": [
            "&xfer->dmabuf"
          ],
          "line": 2846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "OHCI_TD_R"
          ],
          "line": 2845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "OHCI_TD_IN | OHCI_TD_NOCC | \n\t\tOHCI_TD_SET_DI(1) | OHCI_TD_TOGGLE_CARRY"
          ],
          "line": 2841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OHCI_TD_SET_DI",
          "args": [
            "1"
          ],
          "line": 2843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ohci_alloc_std",
          "args": [
            "sc"
          ],
          "line": 2836
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_alloc_std_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "479-574",
          "snippet": "usbd_status\nohci_alloc_std_chain(opipe, sc, alen, rd, xfer, sp, ep)\n\tstruct ohci_pipe *opipe;\n\tohci_softc_t *sc;\n\tint alen, rd;\n\tusbd_xfer_handle xfer;\n\tohci_soft_td_t *sp, **ep;\n{\n\tohci_soft_td_t *next, *cur;\n\tohci_physaddr_t dataphys, dataphysend;\n\tu_int32_t tdflags;\n\tint len, curlen;\n\tusb_dma_t *dma = &xfer->dmabuf;\n\tu_int16_t flags = xfer->flags;\n\n\tDPRINTFN(alen < 4096,(\"ohci_alloc_std_chain: start len=%d\\n\", alen));\n\n\tlen = alen;\n\tcur = sp;\n\tdataphys = DMAADDR(dma);\n\tdataphysend = OHCI_PAGE(dataphys + len - 1);\n\ttdflags = htole32(\n\t    (rd ? OHCI_TD_IN : OHCI_TD_OUT) | \n\t    (flags & USBD_SHORT_XFER_OK ? OHCI_TD_R : 0) |\n\t    OHCI_TD_NOCC | OHCI_TD_TOGGLE_CARRY | OHCI_TD_NOINTR);\n\n\tfor (;;) {\n\t\tnext = ohci_alloc_std(sc);\n\t\tif (next == NULL)\n\t\t\tgoto nomem;\n\n\t\t/* The OHCI hardware can handle at most one page crossing. */\n\t\tif (OHCI_PAGE(dataphys) == dataphysend ||\n\t\t    OHCI_PAGE(dataphys) + OHCI_PAGE_SIZE == dataphysend) {\n\t\t\t/* we can handle it in this TD */\n\t\t\tcurlen = len;\n\t\t} else {\n\t\t\t/* must use multiple TDs, fill as much as possible. */\n\t\t\tcurlen = 2 * OHCI_PAGE_SIZE - \n\t\t\t\t (dataphys & (OHCI_PAGE_SIZE-1));\n\t\t\t/* the length must be a multiple of the max size */\n\t\t\tcurlen -= curlen % UGETW(opipe->pipe.endpoint->edesc->wMaxPacketSize);\n#ifdef DIAGNOSTIC\n\t\t\tif (curlen == 0)\n\t\t\t\tpanic(\"ohci_alloc_std: curlen == 0\\n\");\n#endif\n\t\t}\n\t\tDPRINTFN(4,(\"ohci_alloc_std_chain: dataphys=0x%08x \"\n\t\t\t    \"dataphysend=0x%08x len=%d curlen=%d\\n\",\n\t\t\t    dataphys, dataphysend,\n\t\t\t    len, curlen));\n\t\tlen -= curlen;\n\n\t\tcur->td.td_flags = tdflags;\n\t\tcur->td.td_cbp = htole32(dataphys);\n\t\tcur->nexttd = next;\n\t\tcur->td.td_nexttd = htole32(next->physaddr);\n\t\tcur->td.td_be = htole32(dataphys + curlen - 1);\n\t\tcur->len = curlen;\n\t\tcur->flags = OHCI_ADD_LEN;\n\t\tcur->xfer = xfer;\n\t\tDPRINTFN(10,(\"ohci_alloc_std_chain: cbp=0x%08x be=0x%08x\\n\",\n\t\t\t    dataphys, dataphys + curlen - 1));\n\t\tif (len == 0)\n\t\t\tbreak;\n\t\tDPRINTFN(10,(\"ohci_alloc_std_chain: extend chain\\n\"));\n\t\tdataphys += curlen;\n\t\tcur = next;\n\t}\n\tif ((flags & USBD_FORCE_SHORT_XFER) &&\n\t    alen % UGETW(opipe->pipe.endpoint->edesc->wMaxPacketSize) == 0) {\n\t\t/* Force a 0 length transfer at the end. */\n\n\t\tcur = next;\n\t\tnext = ohci_alloc_std(sc);\n\t\tif (next == NULL)\n\t\t\tgoto nomem;\n\n\t\tcur->td.td_flags = tdflags;\n\t\tcur->td.td_cbp = 0; /* indicate 0 length packet */\n\t\tcur->nexttd = next;\n\t\tcur->td.td_nexttd = htole32(next->physaddr);\n\t\tcur->td.td_be = ~0;\n\t\tcur->len = 0;\n\t\tcur->flags = 0;\n\t\tcur->xfer = xfer;\n\t\tDPRINTFN(2,(\"ohci_alloc_std_chain: add 0 xfer\\n\"));\n\t}\n\t*ep = cur;\n\n\treturn (USBD_NORMAL_COMPLETION);\n\n nomem:\n\t/* XXX free chain */\n\treturn (USBD_NOMEM);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static ohci_soft_td_t",
            "ohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));",
            "Static usbd_status",
            "ohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));",
            "Static usbd_status",
            "ohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));",
            "ohci_add_done __P((ohci_softc_t *, ohci_physaddr_t));",
            "ohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_request __P((usbd_xfer_handle xfer));",
            "ohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));",
            "ohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));",
            "Static ohci_soft_td_t",
            "Static usbd_status",
            "ohci_setup_isoc __P((usbd_pipe_handle pipe));",
            "ohci_device_isoc_enter __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));",
            "ohci_freem __P((struct usbd_bus *, usb_dma_t *));",
            "Static usbd_xfer_handle",
            "ohci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_root_ctrl_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_root_ctrl_start __P((usbd_xfer_handle));",
            "ohci_root_ctrl_abort __P((usbd_xfer_handle));",
            "ohci_root_ctrl_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_root_intr_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_root_intr_start __P((usbd_xfer_handle));",
            "ohci_root_intr_abort __P((usbd_xfer_handle));",
            "ohci_root_intr_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_ctrl_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_ctrl_start __P((usbd_xfer_handle));",
            "ohci_device_ctrl_abort __P((usbd_xfer_handle));",
            "ohci_device_ctrl_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_bulk_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_bulk_start __P((usbd_xfer_handle));",
            "ohci_device_bulk_abort __P((usbd_xfer_handle));",
            "ohci_device_bulk_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_intr_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_intr_start __P((usbd_xfer_handle));",
            "ohci_device_intr_abort __P((usbd_xfer_handle));",
            "ohci_device_intr_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_isoc_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_isoc_start __P((usbd_xfer_handle));",
            "ohci_device_isoc_abort __P((usbd_xfer_handle));",
            "ohci_device_isoc_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_rhsc_able __P((ohci_softc_t *, int));",
            "ohci_device_clear_toggle __P((usbd_pipe_handle pipe));",
            "ohci_noop __P((usbd_pipe_handle pipe));",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
            "ohci_intr1 __P((ohci_softc_t *));",
            "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
            "ohci_physaddr_t a;",
            "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;",
            "ohci_physaddr_t a;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_td_t;\nohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));\nStatic usbd_status;\nohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));\nStatic usbd_status;\nohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));\nohci_add_done __P((ohci_softc_t *, ohci_physaddr_t));\nohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));\nStatic usbd_status;\nohci_device_request __P((usbd_xfer_handle xfer));\nohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));\nohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));\nStatic ohci_soft_td_t;\nStatic usbd_status;\nohci_setup_isoc __P((usbd_pipe_handle pipe));\nohci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));\nohci_freem __P((struct usbd_bus *, usb_dma_t *));\nStatic usbd_xfer_handle;\nohci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nStatic usbd_status;\nohci_root_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_ctrl_start __P((usbd_xfer_handle));\nohci_root_ctrl_abort __P((usbd_xfer_handle));\nohci_root_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_intr_start __P((usbd_xfer_handle));\nohci_root_intr_abort __P((usbd_xfer_handle));\nohci_root_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_ctrl_start __P((usbd_xfer_handle));\nohci_device_ctrl_abort __P((usbd_xfer_handle));\nohci_device_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_bulk_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_bulk_start __P((usbd_xfer_handle));\nohci_device_bulk_abort __P((usbd_xfer_handle));\nohci_device_bulk_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_intr_start __P((usbd_xfer_handle));\nohci_device_intr_abort __P((usbd_xfer_handle));\nohci_device_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_isoc_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_isoc_start __P((usbd_xfer_handle));\nohci_device_isoc_abort __P((usbd_xfer_handle));\nohci_device_isoc_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_rhsc_able __P((ohci_softc_t *, int));\nohci_device_clear_toggle __P((usbd_pipe_handle pipe));\nohci_noop __P((usbd_pipe_handle pipe));\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_physaddr_t a;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\nohci_physaddr_t a;\n\nusbd_status\nohci_alloc_std_chain(opipe, sc, alen, rd, xfer, sp, ep)\n\tstruct ohci_pipe *opipe;\n\tohci_softc_t *sc;\n\tint alen, rd;\n\tusbd_xfer_handle xfer;\n\tohci_soft_td_t *sp, **ep;\n{\n\tohci_soft_td_t *next, *cur;\n\tohci_physaddr_t dataphys, dataphysend;\n\tu_int32_t tdflags;\n\tint len, curlen;\n\tusb_dma_t *dma = &xfer->dmabuf;\n\tu_int16_t flags = xfer->flags;\n\n\tDPRINTFN(alen < 4096,(\"ohci_alloc_std_chain: start len=%d\\n\", alen));\n\n\tlen = alen;\n\tcur = sp;\n\tdataphys = DMAADDR(dma);\n\tdataphysend = OHCI_PAGE(dataphys + len - 1);\n\ttdflags = htole32(\n\t    (rd ? OHCI_TD_IN : OHCI_TD_OUT) | \n\t    (flags & USBD_SHORT_XFER_OK ? OHCI_TD_R : 0) |\n\t    OHCI_TD_NOCC | OHCI_TD_TOGGLE_CARRY | OHCI_TD_NOINTR);\n\n\tfor (;;) {\n\t\tnext = ohci_alloc_std(sc);\n\t\tif (next == NULL)\n\t\t\tgoto nomem;\n\n\t\t/* The OHCI hardware can handle at most one page crossing. */\n\t\tif (OHCI_PAGE(dataphys) == dataphysend ||\n\t\t    OHCI_PAGE(dataphys) + OHCI_PAGE_SIZE == dataphysend) {\n\t\t\t/* we can handle it in this TD */\n\t\t\tcurlen = len;\n\t\t} else {\n\t\t\t/* must use multiple TDs, fill as much as possible. */\n\t\t\tcurlen = 2 * OHCI_PAGE_SIZE - \n\t\t\t\t (dataphys & (OHCI_PAGE_SIZE-1));\n\t\t\t/* the length must be a multiple of the max size */\n\t\t\tcurlen -= curlen % UGETW(opipe->pipe.endpoint->edesc->wMaxPacketSize);\n#ifdef DIAGNOSTIC\n\t\t\tif (curlen == 0)\n\t\t\t\tpanic(\"ohci_alloc_std: curlen == 0\\n\");\n#endif\n\t\t}\n\t\tDPRINTFN(4,(\"ohci_alloc_std_chain: dataphys=0x%08x \"\n\t\t\t    \"dataphysend=0x%08x len=%d curlen=%d\\n\",\n\t\t\t    dataphys, dataphysend,\n\t\t\t    len, curlen));\n\t\tlen -= curlen;\n\n\t\tcur->td.td_flags = tdflags;\n\t\tcur->td.td_cbp = htole32(dataphys);\n\t\tcur->nexttd = next;\n\t\tcur->td.td_nexttd = htole32(next->physaddr);\n\t\tcur->td.td_be = htole32(dataphys + curlen - 1);\n\t\tcur->len = curlen;\n\t\tcur->flags = OHCI_ADD_LEN;\n\t\tcur->xfer = xfer;\n\t\tDPRINTFN(10,(\"ohci_alloc_std_chain: cbp=0x%08x be=0x%08x\\n\",\n\t\t\t    dataphys, dataphys + curlen - 1));\n\t\tif (len == 0)\n\t\t\tbreak;\n\t\tDPRINTFN(10,(\"ohci_alloc_std_chain: extend chain\\n\"));\n\t\tdataphys += curlen;\n\t\tcur = next;\n\t}\n\tif ((flags & USBD_FORCE_SHORT_XFER) &&\n\t    alen % UGETW(opipe->pipe.endpoint->edesc->wMaxPacketSize) == 0) {\n\t\t/* Force a 0 length transfer at the end. */\n\n\t\tcur = next;\n\t\tnext = ohci_alloc_std(sc);\n\t\tif (next == NULL)\n\t\t\tgoto nomem;\n\n\t\tcur->td.td_flags = tdflags;\n\t\tcur->td.td_cbp = 0; /* indicate 0 length packet */\n\t\tcur->nexttd = next;\n\t\tcur->td.td_nexttd = htole32(next->physaddr);\n\t\tcur->td.td_be = ~0;\n\t\tcur->len = 0;\n\t\tcur->flags = 0;\n\t\tcur->xfer = xfer;\n\t\tDPRINTFN(2,(\"ohci_alloc_std_chain: add 0 xfer\\n\"));\n\t}\n\t*ep = cur;\n\n\treturn (USBD_NORMAL_COMPLETION);\n\n nomem:\n\t/* XXX free chain */\n\treturn (USBD_NOMEM);\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"ohci_device_intr_transfer: a request\\n\""
          ],
          "line": 2830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "3",
            "(\"ohci_device_intr_transfer: xfer=%p len=%d \"\n\t\t     \"flags=%d priv=%p\\n\",\n\t\t     xfer, xfer->length, xfer->flags, xfer->priv)"
          ],
          "line": 2824
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_ed_t;\nStatic void;\nohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));\nStatic ohci_soft_td_t;\nStatic void;\nohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));\nStatic void;\nStatic usbd_status;\nohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));\nStatic void;\nStatic void;\nStatic usbd_status;\nStatic void;\nStatic void;\nStatic void;\nohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));\nStatic usbd_status;\nohci_device_request __P((usbd_xfer_handle xfer));\nStatic void;\nohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nStatic void;\nohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nStatic void;\nohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));\nStatic void;\nohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));\nStatic ohci_soft_td_t;\nStatic void;\nStatic void;\nStatic usbd_status;\nohci_setup_isoc __P((usbd_pipe_handle pipe));\nStatic void;\nohci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic void;\nStatic usbd_xfer_handle;\nStatic void;\nohci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nStatic usbd_status;\nohci_root_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_ctrl_start __P((usbd_xfer_handle));\nStatic void;\nohci_root_ctrl_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_root_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_intr_start __P((usbd_xfer_handle));\nStatic void;\nohci_root_intr_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_root_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_ctrl_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_ctrl_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_bulk_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_bulk_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_bulk_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_bulk_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_intr_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_intr_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_isoc_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_isoc_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_isoc_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_isoc_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic int;\nStatic void;\nStatic void;\nohci_rhsc_able __P((ohci_softc_t *, int));\nStatic void;\nStatic void;\nohci_abort_xfer __P((usbd_xfer_handle xfer,\n\t\t\t    usbd_status status));\nStatic void;\nStatic void;\nohci_device_clear_toggle __P((usbd_pipe_handle pipe));\nStatic void;\nohci_noop __P((usbd_pipe_handle pipe));\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nStatic int;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_physaddr_t a;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\nohci_physaddr_t a;\n\nStatic usbd_status\nohci_device_intr_start(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tstruct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;\n\tusbd_device_handle dev = opipe->pipe.device;\n\tohci_softc_t *sc = (ohci_softc_t *)dev->bus;\n\tohci_soft_ed_t *sed = opipe->sed;\n\tohci_soft_td_t *data, *tail;\n\tint len;\n\tint s;\n\n\tif (sc->sc_dying)\n\t\treturn (USBD_IOERROR);\n\n\tDPRINTFN(3, (\"ohci_device_intr_transfer: xfer=%p len=%d \"\n\t\t     \"flags=%d priv=%p\\n\",\n\t\t     xfer, xfer->length, xfer->flags, xfer->priv));\n\n#ifdef DIAGNOSTIC\n\tif (xfer->rqflags & URQ_REQUEST)\n\t\tpanic(\"ohci_device_intr_transfer: a request\\n\");\n#endif\n\n\tlen = xfer->length;\n\n\tdata = opipe->tail.td;\n\ttail = ohci_alloc_std(sc);\n\tif (tail == NULL)\n\t\treturn (USBD_NOMEM);\n\ttail->xfer = NULL;\n\n\tdata->td.td_flags = htole32(\n\t\tOHCI_TD_IN | OHCI_TD_NOCC | \n\t\tOHCI_TD_SET_DI(1) | OHCI_TD_TOGGLE_CARRY);\n\tif (xfer->flags & USBD_SHORT_XFER_OK)\n\t\tdata->td.td_flags |= htole32(OHCI_TD_R);\n\tdata->td.td_cbp = htole32(DMAADDR(&xfer->dmabuf));\n\tdata->nexttd = tail;\n\tdata->td.td_nexttd = htole32(tail->physaddr);\n\tdata->td.td_be = htole32(le32toh(data->td.td_cbp) + len - 1);\n\tdata->len = len;\n\tdata->xfer = xfer;\n\tdata->flags = OHCI_CALL_DONE | OHCI_ADD_LEN;\n\txfer->hcpriv = data;\n\n#ifdef OHCI_DEBUG\n\tif (ohcidebug > 5) {\n\t\tDPRINTF((\"ohci_device_intr_transfer:\\n\"));\n\t\tohci_dump_ed(sed);\n\t\tohci_dump_tds(data);\n\t}\n#endif\n\n\t/* Insert ED in schedule */\n\ts = splusb();\n\tsed->ed.ed_tailp = htole32(tail->physaddr);\n\topipe->tail.td = tail;\n\tsed->ed.ed_flags &= htole32(~OHCI_ED_SKIP);\n\n#if 0\n/*\n * This goes horribly wrong, printing thousands of descriptors,\n * because false references are followed due to the fact that the\n * TD is gone.\n */\n\tif (ohcidebug > 5) {\n\t\tusb_delay_ms(&sc->sc_bus, 5);\n\t\tDPRINTF((\"ohci_device_intr_transfer: status=%x\\n\",\n\t\t\t OREAD4(sc, OHCI_COMMAND_STATUS)));\n\t\tohci_dump_ed(sed);\n\t\tohci_dump_tds(data);\n\t}\n#endif\n\tsplx(s);\n\n\treturn (USBD_IN_PROGRESS);\n}"
  },
  {
    "function_name": "ohci_device_intr_transfer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "2794-2807",
    "snippet": "Static usbd_status\nohci_device_intr_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_status err;\n\n\t/* Insert last in queue. */\n\terr = usb_insert_transfer(xfer);\n\tif (err)\n\t\treturn (err);\n\n\t/* Pipe isn't running, start first */\n\treturn (ohci_device_intr_start(SIMPLEQ_FIRST(&xfer->pipe->queue)));\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static void",
      "Static void",
      "Static void",
      "Static usbd_status",
      "Static void",
      "Static void",
      "Static usbd_status",
      "Static void",
      "Static void",
      "Static void",
      "ohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_request __P((usbd_xfer_handle xfer));",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static usbd_status",
      "ohci_setup_isoc __P((usbd_pipe_handle pipe));",
      "Static void",
      "ohci_device_isoc_enter __P((usbd_xfer_handle));",
      "Static usbd_status",
      "Static void",
      "Static usbd_xfer_handle",
      "Static void",
      "ohci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_root_ctrl_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_root_ctrl_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_root_ctrl_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_root_intr_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_root_intr_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_root_intr_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_root_intr_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_ctrl_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_device_ctrl_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_device_ctrl_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_bulk_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_bulk_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_device_bulk_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_device_bulk_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_intr_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_intr_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_device_intr_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_device_intr_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_isoc_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_isoc_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_device_isoc_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_device_isoc_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "Static int",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "ohci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "Static void",
      "ohci_noop __P((usbd_pipe_handle pipe));",
      "Static int"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ohci_device_intr_start",
          "args": [
            "SIMPLEQ_FIRST(&xfer->pipe->queue)"
          ],
          "line": 2806
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_device_intr_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "2809-2886",
          "snippet": "Static usbd_status\nohci_device_intr_start(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tstruct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;\n\tusbd_device_handle dev = opipe->pipe.device;\n\tohci_softc_t *sc = (ohci_softc_t *)dev->bus;\n\tohci_soft_ed_t *sed = opipe->sed;\n\tohci_soft_td_t *data, *tail;\n\tint len;\n\tint s;\n\n\tif (sc->sc_dying)\n\t\treturn (USBD_IOERROR);\n\n\tDPRINTFN(3, (\"ohci_device_intr_transfer: xfer=%p len=%d \"\n\t\t     \"flags=%d priv=%p\\n\",\n\t\t     xfer, xfer->length, xfer->flags, xfer->priv));\n\n#ifdef DIAGNOSTIC\n\tif (xfer->rqflags & URQ_REQUEST)\n\t\tpanic(\"ohci_device_intr_transfer: a request\\n\");\n#endif\n\n\tlen = xfer->length;\n\n\tdata = opipe->tail.td;\n\ttail = ohci_alloc_std(sc);\n\tif (tail == NULL)\n\t\treturn (USBD_NOMEM);\n\ttail->xfer = NULL;\n\n\tdata->td.td_flags = htole32(\n\t\tOHCI_TD_IN | OHCI_TD_NOCC | \n\t\tOHCI_TD_SET_DI(1) | OHCI_TD_TOGGLE_CARRY);\n\tif (xfer->flags & USBD_SHORT_XFER_OK)\n\t\tdata->td.td_flags |= htole32(OHCI_TD_R);\n\tdata->td.td_cbp = htole32(DMAADDR(&xfer->dmabuf));\n\tdata->nexttd = tail;\n\tdata->td.td_nexttd = htole32(tail->physaddr);\n\tdata->td.td_be = htole32(le32toh(data->td.td_cbp) + len - 1);\n\tdata->len = len;\n\tdata->xfer = xfer;\n\tdata->flags = OHCI_CALL_DONE | OHCI_ADD_LEN;\n\txfer->hcpriv = data;\n\n#ifdef OHCI_DEBUG\n\tif (ohcidebug > 5) {\n\t\tDPRINTF((\"ohci_device_intr_transfer:\\n\"));\n\t\tohci_dump_ed(sed);\n\t\tohci_dump_tds(data);\n\t}\n#endif\n\n\t/* Insert ED in schedule */\n\ts = splusb();\n\tsed->ed.ed_tailp = htole32(tail->physaddr);\n\topipe->tail.td = tail;\n\tsed->ed.ed_flags &= htole32(~OHCI_ED_SKIP);\n\n#if 0\n/*\n * This goes horribly wrong, printing thousands of descriptors,\n * because false references are followed due to the fact that the\n * TD is gone.\n */\n\tif (ohcidebug > 5) {\n\t\tusb_delay_ms(&sc->sc_bus, 5);\n\t\tDPRINTF((\"ohci_device_intr_transfer: status=%x\\n\",\n\t\t\t OREAD4(sc, OHCI_COMMAND_STATUS)));\n\t\tohci_dump_ed(sed);\n\t\tohci_dump_tds(data);\n\t}\n#endif\n\tsplx(s);\n\n\treturn (USBD_IN_PROGRESS);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static ohci_soft_ed_t",
            "Static void",
            "ohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));",
            "Static ohci_soft_td_t",
            "Static void",
            "ohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));",
            "Static void",
            "Static usbd_status",
            "ohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));",
            "Static void",
            "Static void",
            "Static usbd_status",
            "Static void",
            "Static void",
            "Static void",
            "ohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));",
            "Static void",
            "Static void",
            "ohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_request __P((usbd_xfer_handle xfer));",
            "Static void",
            "ohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
            "Static void",
            "ohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
            "Static void",
            "ohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));",
            "Static void",
            "ohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));",
            "Static ohci_soft_td_t",
            "Static void",
            "Static void",
            "Static usbd_status",
            "ohci_setup_isoc __P((usbd_pipe_handle pipe));",
            "Static void",
            "ohci_device_isoc_enter __P((usbd_xfer_handle));",
            "Static usbd_status",
            "Static void",
            "Static usbd_xfer_handle",
            "Static void",
            "ohci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_root_ctrl_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_root_ctrl_start __P((usbd_xfer_handle));",
            "Static void",
            "ohci_root_ctrl_abort __P((usbd_xfer_handle));",
            "Static void",
            "Static void",
            "ohci_root_ctrl_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_root_intr_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_root_intr_start __P((usbd_xfer_handle));",
            "Static void",
            "ohci_root_intr_abort __P((usbd_xfer_handle));",
            "Static void",
            "Static void",
            "ohci_root_intr_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_ctrl_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_ctrl_start __P((usbd_xfer_handle));",
            "Static void",
            "ohci_device_ctrl_abort __P((usbd_xfer_handle));",
            "Static void",
            "Static void",
            "ohci_device_ctrl_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_bulk_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_bulk_start __P((usbd_xfer_handle));",
            "Static void",
            "ohci_device_bulk_abort __P((usbd_xfer_handle));",
            "Static void",
            "Static void",
            "ohci_device_bulk_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_intr_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_intr_start __P((usbd_xfer_handle));",
            "Static void",
            "ohci_device_intr_abort __P((usbd_xfer_handle));",
            "Static void",
            "Static void",
            "ohci_device_intr_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_isoc_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_isoc_start __P((usbd_xfer_handle));",
            "Static void",
            "ohci_device_isoc_abort __P((usbd_xfer_handle));",
            "Static void",
            "Static void",
            "ohci_device_isoc_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "Static int",
            "Static void",
            "Static void",
            "ohci_rhsc_able __P((ohci_softc_t *, int));",
            "Static void",
            "Static void",
            "ohci_abort_xfer __P((usbd_xfer_handle xfer,\n\t\t\t    usbd_status status));",
            "Static void",
            "Static void",
            "ohci_device_clear_toggle __P((usbd_pipe_handle pipe));",
            "Static void",
            "ohci_noop __P((usbd_pipe_handle pipe));",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
            "Static int",
            "ohci_intr1 __P((ohci_softc_t *));",
            "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
            "ohci_physaddr_t a;",
            "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;",
            "ohci_physaddr_t a;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_ed_t;\nStatic void;\nohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));\nStatic ohci_soft_td_t;\nStatic void;\nohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));\nStatic void;\nStatic usbd_status;\nohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));\nStatic void;\nStatic void;\nStatic usbd_status;\nStatic void;\nStatic void;\nStatic void;\nohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));\nStatic usbd_status;\nohci_device_request __P((usbd_xfer_handle xfer));\nStatic void;\nohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nStatic void;\nohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nStatic void;\nohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));\nStatic void;\nohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));\nStatic ohci_soft_td_t;\nStatic void;\nStatic void;\nStatic usbd_status;\nohci_setup_isoc __P((usbd_pipe_handle pipe));\nStatic void;\nohci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic void;\nStatic usbd_xfer_handle;\nStatic void;\nohci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nStatic usbd_status;\nohci_root_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_ctrl_start __P((usbd_xfer_handle));\nStatic void;\nohci_root_ctrl_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_root_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_intr_start __P((usbd_xfer_handle));\nStatic void;\nohci_root_intr_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_root_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_ctrl_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_ctrl_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_bulk_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_bulk_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_bulk_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_bulk_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_intr_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_intr_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_isoc_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_isoc_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_isoc_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_isoc_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic int;\nStatic void;\nStatic void;\nohci_rhsc_able __P((ohci_softc_t *, int));\nStatic void;\nStatic void;\nohci_abort_xfer __P((usbd_xfer_handle xfer,\n\t\t\t    usbd_status status));\nStatic void;\nStatic void;\nohci_device_clear_toggle __P((usbd_pipe_handle pipe));\nStatic void;\nohci_noop __P((usbd_pipe_handle pipe));\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nStatic int;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_physaddr_t a;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\nohci_physaddr_t a;\n\nStatic usbd_status\nohci_device_intr_start(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tstruct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;\n\tusbd_device_handle dev = opipe->pipe.device;\n\tohci_softc_t *sc = (ohci_softc_t *)dev->bus;\n\tohci_soft_ed_t *sed = opipe->sed;\n\tohci_soft_td_t *data, *tail;\n\tint len;\n\tint s;\n\n\tif (sc->sc_dying)\n\t\treturn (USBD_IOERROR);\n\n\tDPRINTFN(3, (\"ohci_device_intr_transfer: xfer=%p len=%d \"\n\t\t     \"flags=%d priv=%p\\n\",\n\t\t     xfer, xfer->length, xfer->flags, xfer->priv));\n\n#ifdef DIAGNOSTIC\n\tif (xfer->rqflags & URQ_REQUEST)\n\t\tpanic(\"ohci_device_intr_transfer: a request\\n\");\n#endif\n\n\tlen = xfer->length;\n\n\tdata = opipe->tail.td;\n\ttail = ohci_alloc_std(sc);\n\tif (tail == NULL)\n\t\treturn (USBD_NOMEM);\n\ttail->xfer = NULL;\n\n\tdata->td.td_flags = htole32(\n\t\tOHCI_TD_IN | OHCI_TD_NOCC | \n\t\tOHCI_TD_SET_DI(1) | OHCI_TD_TOGGLE_CARRY);\n\tif (xfer->flags & USBD_SHORT_XFER_OK)\n\t\tdata->td.td_flags |= htole32(OHCI_TD_R);\n\tdata->td.td_cbp = htole32(DMAADDR(&xfer->dmabuf));\n\tdata->nexttd = tail;\n\tdata->td.td_nexttd = htole32(tail->physaddr);\n\tdata->td.td_be = htole32(le32toh(data->td.td_cbp) + len - 1);\n\tdata->len = len;\n\tdata->xfer = xfer;\n\tdata->flags = OHCI_CALL_DONE | OHCI_ADD_LEN;\n\txfer->hcpriv = data;\n\n#ifdef OHCI_DEBUG\n\tif (ohcidebug > 5) {\n\t\tDPRINTF((\"ohci_device_intr_transfer:\\n\"));\n\t\tohci_dump_ed(sed);\n\t\tohci_dump_tds(data);\n\t}\n#endif\n\n\t/* Insert ED in schedule */\n\ts = splusb();\n\tsed->ed.ed_tailp = htole32(tail->physaddr);\n\topipe->tail.td = tail;\n\tsed->ed.ed_flags &= htole32(~OHCI_ED_SKIP);\n\n#if 0\n/*\n * This goes horribly wrong, printing thousands of descriptors,\n * because false references are followed due to the fact that the\n * TD is gone.\n */\n\tif (ohcidebug > 5) {\n\t\tusb_delay_ms(&sc->sc_bus, 5);\n\t\tDPRINTF((\"ohci_device_intr_transfer: status=%x\\n\",\n\t\t\t OREAD4(sc, OHCI_COMMAND_STATUS)));\n\t\tohci_dump_ed(sed);\n\t\tohci_dump_tds(data);\n\t}\n#endif\n\tsplx(s);\n\n\treturn (USBD_IN_PROGRESS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_FIRST",
          "args": [
            "&xfer->pipe->queue"
          ],
          "line": 2806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_insert_transfer",
          "args": [
            "xfer"
          ],
          "line": 2801
        },
        "resolved": true,
        "details": {
          "function_name": "usb_insert_transfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "885-905",
          "snippet": "usbd_status\nusb_insert_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusbd_status err;\n\tint s;\n\n\tDPRINTFN(5,(\"usb_insert_transfer: pipe=%p running=%d timeout=%d\\n\", \n\t\t    pipe, pipe->running, xfer->timeout));\n\ts = splusb();\n\tSIMPLEQ_INSERT_TAIL(&pipe->queue, xfer, next);\n\tif (pipe->running)\n\t\terr = USBD_IN_PROGRESS;\n\telse {\n\t\tpipe->running = 1;\n\t\terr = USBD_NORMAL_COMPLETION;\n\t}\n\tsplx(s);\n\treturn (err);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nusbd_status\nusb_insert_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusbd_status err;\n\tint s;\n\n\tDPRINTFN(5,(\"usb_insert_transfer: pipe=%p running=%d timeout=%d\\n\", \n\t\t    pipe, pipe->running, xfer->timeout));\n\ts = splusb();\n\tSIMPLEQ_INSERT_TAIL(&pipe->queue, xfer, next);\n\tif (pipe->running)\n\t\terr = USBD_IN_PROGRESS;\n\telse {\n\t\tpipe->running = 1;\n\t\terr = USBD_NORMAL_COMPLETION;\n\t}\n\tsplx(s);\n\treturn (err);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nStatic void;\nStatic void;\nStatic usbd_status;\nStatic void;\nStatic void;\nStatic usbd_status;\nStatic void;\nStatic void;\nStatic void;\nohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));\nStatic usbd_status;\nohci_device_request __P((usbd_xfer_handle xfer));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic usbd_status;\nohci_setup_isoc __P((usbd_pipe_handle pipe));\nStatic void;\nohci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic void;\nStatic usbd_xfer_handle;\nStatic void;\nohci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nStatic usbd_status;\nohci_root_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_ctrl_start __P((usbd_xfer_handle));\nStatic void;\nohci_root_ctrl_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_root_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_intr_start __P((usbd_xfer_handle));\nStatic void;\nohci_root_intr_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_root_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_ctrl_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_ctrl_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_bulk_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_bulk_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_bulk_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_bulk_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_intr_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_intr_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_isoc_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_isoc_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_isoc_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_isoc_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_device_clear_toggle __P((usbd_pipe_handle pipe));\nStatic void;\nohci_noop __P((usbd_pipe_handle pipe));\nStatic int;\n\nStatic usbd_status\nohci_device_intr_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_status err;\n\n\t/* Insert last in queue. */\n\terr = usb_insert_transfer(xfer);\n\tif (err)\n\t\treturn (err);\n\n\t/* Pipe isn't running, start first */\n\treturn (ohci_device_intr_start(SIMPLEQ_FIRST(&xfer->pipe->queue)));\n}"
  },
  {
    "function_name": "ohci_device_bulk_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "2780-2790",
    "snippet": "Static void\nohci_device_bulk_close(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tstruct ohci_pipe *opipe = (struct ohci_pipe *)pipe;\n\tohci_softc_t *sc = (ohci_softc_t *)pipe->device->bus;\n\n\tDPRINTF((\"ohci_device_bulk_close: pipe=%p\\n\", pipe));\n\tohci_close_pipe(pipe, sc->sc_bulk_head);\n\tohci_free_std(sc, opipe->tail.td);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "ohci_open __P((usbd_pipe_handle));",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "ohci_setup_isoc __P((usbd_pipe_handle pipe));",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "ohci_root_ctrl_close __P((usbd_pipe_handle));",
      "Static void",
      "Static void",
      "Static void",
      "ohci_root_intr_close __P((usbd_pipe_handle));",
      "Static void",
      "Static void",
      "Static void",
      "ohci_device_ctrl_close __P((usbd_pipe_handle));",
      "Static void",
      "Static void",
      "Static void",
      "ohci_device_bulk_close __P((usbd_pipe_handle));",
      "Static void",
      "Static void",
      "Static void",
      "ohci_device_intr_close __P((usbd_pipe_handle));",
      "Static void",
      "Static void",
      "Static void",
      "ohci_device_isoc_close __P((usbd_pipe_handle));",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "ohci_rhsc_able __P((ohci_softc_t *, int));",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "ohci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "Static void",
      "ohci_noop __P((usbd_pipe_handle pipe));",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
      "Static int",
      "ohci_intr1 __P((ohci_softc_t *));",
      "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ohci_free_std",
          "args": [
            "sc",
            "opipe->tail.td"
          ],
          "line": 2789
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_free_std_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "577-589",
          "snippet": "Static void\nohci_free_std_chain(sc, std, stdend)\n\tohci_softc_t *sc;\n\tohci_soft_td_t *std;\n\tohci_soft_td_t *stdend;\n{\n\tohci_soft_td_t *p;\n\n\tfor (; std != stdend; std = p) {\n\t\tp = std->nexttd;\n\t\tohci_free_std(sc, std);\n\t}\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static void",
            "Static ohci_soft_td_t",
            "Static void",
            "ohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));",
            "Static void",
            "ohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "ohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));",
            "Static void",
            "ohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));",
            "Static ohci_soft_td_t",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "ohci_rhsc_able __P((ohci_softc_t *, int));",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
            "Static int",
            "ohci_intr1 __P((ohci_softc_t *));",
            "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nStatic ohci_soft_td_t;\nStatic void;\nohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));\nStatic void;\nohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));\nStatic void;\nohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));\nStatic ohci_soft_td_t;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nohci_rhsc_able __P((ohci_softc_t *, int));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nStatic int;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nStatic void\nohci_free_std_chain(sc, std, stdend)\n\tohci_softc_t *sc;\n\tohci_soft_td_t *std;\n\tohci_soft_td_t *stdend;\n{\n\tohci_soft_td_t *p;\n\n\tfor (; std != stdend; std = p) {\n\t\tp = std->nexttd;\n\t\tohci_free_std(sc, std);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ohci_close_pipe",
          "args": [
            "pipe",
            "sc->sc_bulk_head"
          ],
          "line": 2788
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_close_pipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "1974-2010",
          "snippet": "void\nohci_close_pipe(pipe, head)\n\tusbd_pipe_handle pipe;\n\tohci_soft_ed_t *head;\n{\n\tstruct ohci_pipe *opipe = (struct ohci_pipe *)pipe;\n\tohci_softc_t *sc = (ohci_softc_t *)pipe->device->bus;\n\tohci_soft_ed_t *sed = opipe->sed;\n\tint s;\n\n\ts = splusb();\n#ifdef DIAGNOSTIC\n\tsed->ed.ed_flags |= htole32(OHCI_ED_SKIP);\n\tif ((le32toh(sed->ed.ed_tailp) & OHCI_HEADMASK) != \n\t    (le32toh(sed->ed.ed_headp) & OHCI_HEADMASK)) {\n\t\tohci_physaddr_t td = le32toh(sed->ed.ed_headp);\n\t\tohci_soft_td_t *std;\n\t\tfor (std = LIST_FIRST(&sc->sc_hash_tds[HASH(td)]); \n\t\t     std != NULL;\n\t\t     std = LIST_NEXT(std, hnext))\n\t\t    if (std->physaddr == td)\n\t\t\tbreak;\n\t\tprintf(\"ohci_close_pipe: pipe not empty sed=%p hd=0x%x \"\n\t\t       \"tl=0x%x pipe=%p, std=%p\\n\", sed,\n\t\t       (int)le32toh(sed->ed.ed_headp),\n\t\t       (int)le32toh(sed->ed.ed_tailp),\n\t\t       pipe, std);\n\t\tusb_delay_ms(&sc->sc_bus, 2);\n\t\tif ((le32toh(sed->ed.ed_tailp) & OHCI_HEADMASK) != \n\t\t    (le32toh(sed->ed.ed_headp) & OHCI_HEADMASK))\n\t\t\tprintf(\"ohci_close_pipe: pipe still not empty\\n\");\n\t}\n#endif\n\tohci_rem_ed(sed, head);\n\tsplx(s);\n\tohci_free_sed(sc, opipe->sed);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static ohci_soft_ed_t",
            "ohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));",
            "Static ohci_soft_td_t",
            "ohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));",
            "ohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));",
            "ohci_open __P((usbd_pipe_handle));",
            "ohci_add_done __P((ohci_softc_t *, ohci_physaddr_t));",
            "ohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
            "ohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
            "ohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));",
            "ohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));",
            "Static ohci_soft_td_t",
            "ohci_setup_isoc __P((usbd_pipe_handle pipe));",
            "ohci_root_ctrl_close __P((usbd_pipe_handle));",
            "ohci_root_intr_close __P((usbd_pipe_handle));",
            "ohci_device_ctrl_close __P((usbd_pipe_handle));",
            "ohci_device_bulk_close __P((usbd_pipe_handle));",
            "ohci_device_intr_close __P((usbd_pipe_handle));",
            "ohci_device_isoc_close __P((usbd_pipe_handle));",
            "ohci_rhsc_able __P((ohci_softc_t *, int));",
            "ohci_close_pipe __P((usbd_pipe_handle pipe, \n\t\t\t    ohci_soft_ed_t *head));",
            "ohci_device_clear_toggle __P((usbd_pipe_handle pipe));",
            "ohci_noop __P((usbd_pipe_handle pipe));",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
            "ohci_intr1 __P((ohci_softc_t *));",
            "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_ed_t;\nohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));\nStatic ohci_soft_td_t;\nohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));\nohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));\nohci_open __P((usbd_pipe_handle));\nohci_add_done __P((ohci_softc_t *, ohci_physaddr_t));\nohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));\nohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));\nStatic ohci_soft_td_t;\nohci_setup_isoc __P((usbd_pipe_handle pipe));\nohci_root_ctrl_close __P((usbd_pipe_handle));\nohci_root_intr_close __P((usbd_pipe_handle));\nohci_device_ctrl_close __P((usbd_pipe_handle));\nohci_device_bulk_close __P((usbd_pipe_handle));\nohci_device_intr_close __P((usbd_pipe_handle));\nohci_device_isoc_close __P((usbd_pipe_handle));\nohci_rhsc_able __P((ohci_softc_t *, int));\nohci_close_pipe __P((usbd_pipe_handle pipe, \n\t\t\t    ohci_soft_ed_t *head));\nohci_device_clear_toggle __P((usbd_pipe_handle pipe));\nohci_noop __P((usbd_pipe_handle pipe));\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nvoid\nohci_close_pipe(pipe, head)\n\tusbd_pipe_handle pipe;\n\tohci_soft_ed_t *head;\n{\n\tstruct ohci_pipe *opipe = (struct ohci_pipe *)pipe;\n\tohci_softc_t *sc = (ohci_softc_t *)pipe->device->bus;\n\tohci_soft_ed_t *sed = opipe->sed;\n\tint s;\n\n\ts = splusb();\n#ifdef DIAGNOSTIC\n\tsed->ed.ed_flags |= htole32(OHCI_ED_SKIP);\n\tif ((le32toh(sed->ed.ed_tailp) & OHCI_HEADMASK) != \n\t    (le32toh(sed->ed.ed_headp) & OHCI_HEADMASK)) {\n\t\tohci_physaddr_t td = le32toh(sed->ed.ed_headp);\n\t\tohci_soft_td_t *std;\n\t\tfor (std = LIST_FIRST(&sc->sc_hash_tds[HASH(td)]); \n\t\t     std != NULL;\n\t\t     std = LIST_NEXT(std, hnext))\n\t\t    if (std->physaddr == td)\n\t\t\tbreak;\n\t\tprintf(\"ohci_close_pipe: pipe not empty sed=%p hd=0x%x \"\n\t\t       \"tl=0x%x pipe=%p, std=%p\\n\", sed,\n\t\t       (int)le32toh(sed->ed.ed_headp),\n\t\t       (int)le32toh(sed->ed.ed_tailp),\n\t\t       pipe, std);\n\t\tusb_delay_ms(&sc->sc_bus, 2);\n\t\tif ((le32toh(sed->ed.ed_tailp) & OHCI_HEADMASK) != \n\t\t    (le32toh(sed->ed.ed_headp) & OHCI_HEADMASK))\n\t\t\tprintf(\"ohci_close_pipe: pipe still not empty\\n\");\n\t}\n#endif\n\tohci_rem_ed(sed, head);\n\tsplx(s);\n\tohci_free_sed(sc, opipe->sed);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ohci_device_bulk_close: pipe=%p\\n\", pipe)"
          ],
          "line": 2787
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_open __P((usbd_pipe_handle));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_setup_isoc __P((usbd_pipe_handle pipe));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_root_ctrl_close __P((usbd_pipe_handle));\nStatic void;\nStatic void;\nStatic void;\nohci_root_intr_close __P((usbd_pipe_handle));\nStatic void;\nStatic void;\nStatic void;\nohci_device_ctrl_close __P((usbd_pipe_handle));\nStatic void;\nStatic void;\nStatic void;\nohci_device_bulk_close __P((usbd_pipe_handle));\nStatic void;\nStatic void;\nStatic void;\nohci_device_intr_close __P((usbd_pipe_handle));\nStatic void;\nStatic void;\nStatic void;\nohci_device_isoc_close __P((usbd_pipe_handle));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nohci_rhsc_able __P((ohci_softc_t *, int));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_device_clear_toggle __P((usbd_pipe_handle pipe));\nStatic void;\nohci_noop __P((usbd_pipe_handle pipe));\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nStatic int;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nStatic void\nohci_device_bulk_close(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tstruct ohci_pipe *opipe = (struct ohci_pipe *)pipe;\n\tohci_softc_t *sc = (ohci_softc_t *)pipe->device->bus;\n\n\tDPRINTF((\"ohci_device_bulk_close: pipe=%p\\n\", pipe));\n\tohci_close_pipe(pipe, sc->sc_bulk_head);\n\tohci_free_std(sc, opipe->tail.td);\n}"
  },
  {
    "function_name": "ohci_device_bulk_abort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "2769-2775",
    "snippet": "Static void\nohci_device_bulk_abort(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tDPRINTF((\"ohci_device_bulk_abort: xfer=%p\\n\", xfer));\n\tohci_abort_xfer(xfer, USBD_CANCELLED);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "ohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));",
      "ohci_device_request __P((usbd_xfer_handle xfer));",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "ohci_device_isoc_enter __P((usbd_xfer_handle));",
      "Static void",
      "Static usbd_xfer_handle",
      "Static void",
      "ohci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "ohci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "ohci_root_ctrl_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_root_ctrl_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_root_ctrl_done  __P((usbd_xfer_handle));",
      "ohci_root_intr_transfer __P((usbd_xfer_handle));",
      "ohci_root_intr_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_root_intr_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_root_intr_done  __P((usbd_xfer_handle));",
      "ohci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "ohci_device_ctrl_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_device_ctrl_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_device_ctrl_done  __P((usbd_xfer_handle));",
      "ohci_device_bulk_transfer __P((usbd_xfer_handle));",
      "ohci_device_bulk_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_device_bulk_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_device_bulk_done  __P((usbd_xfer_handle));",
      "ohci_device_intr_transfer __P((usbd_xfer_handle));",
      "ohci_device_intr_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_device_intr_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_device_intr_done  __P((usbd_xfer_handle));",
      "ohci_device_isoc_transfer __P((usbd_xfer_handle));",
      "ohci_device_isoc_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_device_isoc_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_device_isoc_done  __P((usbd_xfer_handle));",
      "Static int",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static int"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ohci_abort_xfer",
          "args": [
            "xfer",
            "USBD_CANCELLED"
          ],
          "line": 2774
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_abort_xfer_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "2059-2093",
          "snippet": "void\nohci_abort_xfer_end(v)\n\tvoid *v;\n{\n\tusbd_xfer_handle xfer = v;\n\tstruct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;\n\tohci_softc_t *sc = (ohci_softc_t *)opipe->pipe.device->bus;\n\tohci_soft_ed_t *sed;\n\tohci_soft_td_t *p, *n;\n\tint s;\n\n\ts = splusb();\n\n\tp = xfer->hcpriv;\n#ifdef DIAGNOSTIC\n\tif (p == NULL) {\n\t\tprintf(\"ohci_abort_xfer: hcpriv==0\\n\");\n\t\treturn;\n\t}\n#endif\n\tfor (; p->xfer == xfer; p = n) {\n\t\tn = p->nexttd;\n\t\tohci_free_std(sc, p);\n\t}\n\n\tsed = opipe->sed;\n\tDPRINTFN(2,(\"ohci_abort_xfer: set hd=%x, tl=%x\\n\",\n\t\t    (int)p->physaddr, (int)le32toh(sed->ed.ed_tailp)));\n\tsed->ed.ed_headp = htole32(p->physaddr); /* unlink TDs */\n\tsed->ed.ed_flags &= htole32(~OHCI_ED_SKIP); /* remove hardware skip */\n\n\tusb_transfer_complete(xfer);\n\n\tsplx(s);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static ohci_soft_ed_t",
            "ohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));",
            "Static ohci_soft_td_t",
            "ohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));",
            "ohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));",
            "ohci_shutdown __P((void *v));",
            "ohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));",
            "ohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));",
            "ohci_device_request __P((usbd_xfer_handle xfer));",
            "ohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
            "ohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
            "ohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));",
            "ohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));",
            "Static ohci_soft_td_t",
            "ohci_setup_isoc __P((usbd_pipe_handle pipe));",
            "ohci_device_isoc_enter __P((usbd_xfer_handle));",
            "Static usbd_xfer_handle",
            "ohci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
            "ohci_root_ctrl_transfer __P((usbd_xfer_handle));",
            "ohci_root_ctrl_start __P((usbd_xfer_handle));",
            "ohci_root_ctrl_abort __P((usbd_xfer_handle));",
            "ohci_root_ctrl_done  __P((usbd_xfer_handle));",
            "ohci_root_intr_transfer __P((usbd_xfer_handle));",
            "ohci_root_intr_start __P((usbd_xfer_handle));",
            "ohci_root_intr_abort __P((usbd_xfer_handle));",
            "ohci_root_intr_done  __P((usbd_xfer_handle));",
            "ohci_device_ctrl_transfer __P((usbd_xfer_handle));",
            "ohci_device_ctrl_start __P((usbd_xfer_handle));",
            "ohci_device_ctrl_abort __P((usbd_xfer_handle));",
            "ohci_device_ctrl_done  __P((usbd_xfer_handle));",
            "ohci_device_bulk_transfer __P((usbd_xfer_handle));",
            "ohci_device_bulk_start __P((usbd_xfer_handle));",
            "ohci_device_bulk_abort __P((usbd_xfer_handle));",
            "ohci_device_bulk_done  __P((usbd_xfer_handle));",
            "ohci_device_intr_transfer __P((usbd_xfer_handle));",
            "ohci_device_intr_start __P((usbd_xfer_handle));",
            "ohci_device_intr_abort __P((usbd_xfer_handle));",
            "ohci_device_intr_done  __P((usbd_xfer_handle));",
            "ohci_device_isoc_transfer __P((usbd_xfer_handle));",
            "ohci_device_isoc_start __P((usbd_xfer_handle));",
            "ohci_device_isoc_abort __P((usbd_xfer_handle));",
            "ohci_device_isoc_done  __P((usbd_xfer_handle));",
            "ohci_rhsc_able __P((ohci_softc_t *, int));",
            "ohci_device_clear_toggle __P((usbd_pipe_handle pipe));",
            "ohci_noop __P((usbd_pipe_handle pipe));",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
            "ohci_intr1 __P((ohci_softc_t *));",
            "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_ed_t;\nohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));\nStatic ohci_soft_td_t;\nohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));\nohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));\nohci_shutdown __P((void *v));\nohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));\nohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));\nohci_device_request __P((usbd_xfer_handle xfer));\nohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));\nohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));\nStatic ohci_soft_td_t;\nohci_setup_isoc __P((usbd_pipe_handle pipe));\nohci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_xfer_handle;\nohci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nohci_root_ctrl_transfer __P((usbd_xfer_handle));\nohci_root_ctrl_start __P((usbd_xfer_handle));\nohci_root_ctrl_abort __P((usbd_xfer_handle));\nohci_root_ctrl_done  __P((usbd_xfer_handle));\nohci_root_intr_transfer __P((usbd_xfer_handle));\nohci_root_intr_start __P((usbd_xfer_handle));\nohci_root_intr_abort __P((usbd_xfer_handle));\nohci_root_intr_done  __P((usbd_xfer_handle));\nohci_device_ctrl_transfer __P((usbd_xfer_handle));\nohci_device_ctrl_start __P((usbd_xfer_handle));\nohci_device_ctrl_abort __P((usbd_xfer_handle));\nohci_device_ctrl_done  __P((usbd_xfer_handle));\nohci_device_bulk_transfer __P((usbd_xfer_handle));\nohci_device_bulk_start __P((usbd_xfer_handle));\nohci_device_bulk_abort __P((usbd_xfer_handle));\nohci_device_bulk_done  __P((usbd_xfer_handle));\nohci_device_intr_transfer __P((usbd_xfer_handle));\nohci_device_intr_start __P((usbd_xfer_handle));\nohci_device_intr_abort __P((usbd_xfer_handle));\nohci_device_intr_done  __P((usbd_xfer_handle));\nohci_device_isoc_transfer __P((usbd_xfer_handle));\nohci_device_isoc_start __P((usbd_xfer_handle));\nohci_device_isoc_abort __P((usbd_xfer_handle));\nohci_device_isoc_done  __P((usbd_xfer_handle));\nohci_rhsc_able __P((ohci_softc_t *, int));\nohci_device_clear_toggle __P((usbd_pipe_handle pipe));\nohci_noop __P((usbd_pipe_handle pipe));\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nvoid\nohci_abort_xfer_end(v)\n\tvoid *v;\n{\n\tusbd_xfer_handle xfer = v;\n\tstruct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;\n\tohci_softc_t *sc = (ohci_softc_t *)opipe->pipe.device->bus;\n\tohci_soft_ed_t *sed;\n\tohci_soft_td_t *p, *n;\n\tint s;\n\n\ts = splusb();\n\n\tp = xfer->hcpriv;\n#ifdef DIAGNOSTIC\n\tif (p == NULL) {\n\t\tprintf(\"ohci_abort_xfer: hcpriv==0\\n\");\n\t\treturn;\n\t}\n#endif\n\tfor (; p->xfer == xfer; p = n) {\n\t\tn = p->nexttd;\n\t\tohci_free_std(sc, p);\n\t}\n\n\tsed = opipe->sed;\n\tDPRINTFN(2,(\"ohci_abort_xfer: set hd=%x, tl=%x\\n\",\n\t\t    (int)p->physaddr, (int)le32toh(sed->ed.ed_tailp)));\n\tsed->ed.ed_headp = htole32(p->physaddr); /* unlink TDs */\n\tsed->ed.ed_flags &= htole32(~OHCI_ED_SKIP); /* remove hardware skip */\n\n\tusb_transfer_complete(xfer);\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ohci_device_bulk_abort: xfer=%p\\n\", xfer)"
          ],
          "line": 2773
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));\nohci_device_request __P((usbd_xfer_handle xfer));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_device_isoc_enter __P((usbd_xfer_handle));\nStatic void;\nStatic usbd_xfer_handle;\nStatic void;\nohci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nohci_root_ctrl_transfer __P((usbd_xfer_handle));\nohci_root_ctrl_start __P((usbd_xfer_handle));\nStatic void;\nohci_root_ctrl_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_root_ctrl_done  __P((usbd_xfer_handle));\nohci_root_intr_transfer __P((usbd_xfer_handle));\nohci_root_intr_start __P((usbd_xfer_handle));\nStatic void;\nohci_root_intr_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_root_intr_done  __P((usbd_xfer_handle));\nohci_device_ctrl_transfer __P((usbd_xfer_handle));\nohci_device_ctrl_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_ctrl_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_ctrl_done  __P((usbd_xfer_handle));\nohci_device_bulk_transfer __P((usbd_xfer_handle));\nohci_device_bulk_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_bulk_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_bulk_done  __P((usbd_xfer_handle));\nohci_device_intr_transfer __P((usbd_xfer_handle));\nohci_device_intr_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_intr_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_intr_done  __P((usbd_xfer_handle));\nohci_device_isoc_transfer __P((usbd_xfer_handle));\nohci_device_isoc_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_isoc_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_isoc_done  __P((usbd_xfer_handle));\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\n\nStatic void\nohci_device_bulk_abort(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tDPRINTF((\"ohci_device_bulk_abort: xfer=%p\\n\", xfer));\n\tohci_abort_xfer(xfer, USBD_CANCELLED);\n}"
  },
  {
    "function_name": "ohci_device_bulk_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "2669-2767",
    "snippet": "Static usbd_status\nohci_device_bulk_start(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tstruct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;\n\tusbd_device_handle dev = opipe->pipe.device;\n\tohci_softc_t *sc = (ohci_softc_t *)dev->bus;\n\tint addr = dev->address;\n\tohci_soft_td_t *data, *tail, *tdp;\n\tohci_soft_ed_t *sed;\n\tint s, len, isread, endpt;\n\tusbd_status err;\n\n\tif (sc->sc_dying)\n\t\treturn (USBD_IOERROR);\n\n#ifdef DIAGNOSTIC\n\tif (xfer->rqflags & URQ_REQUEST) {\n\t\t/* XXX panic */\n\t\tprintf(\"ohci_device_bulk_start: a request\\n\");\n\t\treturn (USBD_INVAL);\n\t}\n#endif\n\n\tlen = xfer->length;\n\tendpt = xfer->pipe->endpoint->edesc->bEndpointAddress;\n\tisread = UE_GET_DIR(endpt) == UE_DIR_IN;\n\tsed = opipe->sed;\n\n\tDPRINTFN(4,(\"ohci_device_bulk_start: xfer=%p len=%d isread=%d \"\n\t\t    \"flags=%d endpt=%d\\n\", xfer, len, isread, xfer->flags,\n\t\t    endpt));\n\n\topipe->u.bulk.isread = isread;\n\topipe->u.bulk.length = len;\n\n\t/* Update device address */\n\tsed->ed.ed_flags = htole32(\n\t\t(le32toh(sed->ed.ed_flags) & ~OHCI_ED_ADDRMASK) |\n\t\tOHCI_ED_SET_FA(addr));\n\n\t/* Allocate a chain of new TDs (including a new tail). */\n\tdata = opipe->tail.td;\n\terr = ohci_alloc_std_chain(opipe, sc, len, isread, xfer,\n\t\t  data, &tail);\n\t/* We want interrupt at the end of the transfer. */\n\ttail->td.td_flags &= htole32(~OHCI_TD_INTR_MASK);\n\ttail->td.td_flags |= htole32(OHCI_TD_SET_DI(1));\n\ttail->flags |= OHCI_CALL_DONE;\n\ttail = tail->nexttd;\t/* point at sentinel */\n\tif (err)\n\t\treturn (err);\n\n\ttail->xfer = NULL;\n\txfer->hcpriv = data;\n\n\tDPRINTFN(4,(\"ohci_device_bulk_start: ed_flags=0x%08x td_flags=0x%08x \"\n\t\t    \"td_cbp=0x%08x td_be=0x%08x\\n\",\n\t\t    (int)le32toh(sed->ed.ed_flags),\n\t\t    (int)le32toh(data->td.td_flags),\n\t\t    (int)le32toh(data->td.td_cbp),\n\t\t    (int)le32toh(data->td.td_be)));\n\n#ifdef OHCI_DEBUG\n\tif (ohcidebug > 5) {\n\t\tohci_dump_ed(sed);\n\t\tohci_dump_tds(data);\n\t}\n#endif\n\n\t/* Insert ED in schedule */\n\ts = splusb();\n\tfor (tdp = data; tdp != tail; tdp = tdp->nexttd) {\n\t\ttdp->xfer = xfer;\n\t}\n\tsed->ed.ed_tailp = htole32(tail->physaddr);\n\topipe->tail.td = tail;\n\tsed->ed.ed_flags &= htole32(~OHCI_ED_SKIP);\n\tOWRITE4(sc, OHCI_COMMAND_STATUS, OHCI_BLF);\n\tif (xfer->timeout && !sc->sc_bus.use_polling) {\n                usb_callout(xfer->timeout_handle, MS_TO_TICKS(xfer->timeout),\n\t\t\t    ohci_timeout, xfer);\n\t}\n\n#if 0\n/* This goes wrong if we are too slow. */\n\tif (ohcidebug > 10) {\n\t\tdelay(10000);\n\t\tDPRINTF((\"ohci_device_intr_transfer: status=%x\\n\",\n\t\t\t OREAD4(sc, OHCI_COMMAND_STATUS)));\n\t\tohci_dump_ed(sed);\n\t\tohci_dump_tds(data);\n\t}\n#endif\n\n\tsplx(s);\n\n\treturn (USBD_IN_PROGRESS);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static ohci_soft_ed_t",
      "Static void",
      "ohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));",
      "Static ohci_soft_td_t",
      "Static void",
      "ohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));",
      "Static void",
      "Static usbd_status",
      "ohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));",
      "Static void",
      "Static void",
      "Static usbd_status",
      "Static void",
      "Static void",
      "Static void",
      "ohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_request __P((usbd_xfer_handle xfer));",
      "Static void",
      "ohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
      "Static void",
      "ohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
      "Static void",
      "ohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));",
      "Static void",
      "ohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));",
      "Static ohci_soft_td_t",
      "Static void",
      "Static void",
      "Static usbd_status",
      "ohci_setup_isoc __P((usbd_pipe_handle pipe));",
      "Static void",
      "ohci_device_isoc_enter __P((usbd_xfer_handle));",
      "Static usbd_status",
      "Static void",
      "Static usbd_xfer_handle",
      "Static void",
      "ohci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_root_ctrl_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_root_ctrl_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_root_ctrl_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_root_intr_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_root_intr_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_root_intr_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_root_intr_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_ctrl_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_device_ctrl_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_device_ctrl_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_bulk_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_bulk_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_device_bulk_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_device_bulk_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_intr_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_intr_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_device_intr_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_device_intr_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_isoc_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_isoc_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_device_isoc_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_device_isoc_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "Static int",
      "Static void",
      "Static void",
      "ohci_rhsc_able __P((ohci_softc_t *, int));",
      "Static void",
      "Static void",
      "ohci_abort_xfer __P((usbd_xfer_handle xfer,\n\t\t\t    usbd_status status));",
      "Static void",
      "Static void",
      "ohci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "Static void",
      "ohci_noop __P((usbd_pipe_handle pipe));",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
      "Static int",
      "ohci_intr1 __P((ohci_softc_t *));",
      "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
      "ohci_physaddr_t a;",
      "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;",
      "ohci_physaddr_t a;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 2764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ohci_dump_tds",
          "args": [
            "data"
          ],
          "line": 2760
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_dump_tds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "1787-1793",
          "snippet": "void\nohci_dump_tds(std)\n\tohci_soft_td_t *std;\n{\n\tfor (; std; std = std->nexttd)\n\t\tohci_dump_td(std);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static ohci_soft_td_t",
            "ohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));",
            "ohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));",
            "ohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));",
            "ohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));",
            "Static ohci_soft_td_t"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_td_t;\nohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));\nohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));\nohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));\nohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));\nStatic ohci_soft_td_t;\n\nvoid\nohci_dump_tds(std)\n\tohci_soft_td_t *std;\n{\n\tfor (; std; std = std->nexttd)\n\t\tohci_dump_td(std);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ohci_dump_ed",
          "args": [
            "sed"
          ],
          "line": 2759
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_dump_ed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "1842-1859",
          "snippet": "void\nohci_dump_ed(sed)\n\tohci_soft_ed_t *sed;\n{\n\tDPRINTF((\"ED(%p) at 0x%08lx: addr=%d endpt=%d maxp=%d %b\\ntailp=0x%08lx \"\n\t\t \"headflags=%b headp=0x%08lx nexted=0x%08lx\\n\",\n\t\t sed, (u_long)sed->physaddr, \n\t\t OHCI_ED_GET_FA(le32toh(sed->ed.ed_flags)),\n\t\t OHCI_ED_GET_EN(le32toh(sed->ed.ed_flags)),\n\t\t OHCI_ED_GET_MAXP(le32toh(sed->ed.ed_flags)),\n\t\t (int)le32toh(sed->ed.ed_flags),\n\t\t \"\\20\\14OUT\\15IN\\16LOWSPEED\\17SKIP\\20ISO\",\n\t\t (u_long)le32toh(sed->ed.ed_tailp),\n\t\t (u_long)le32toh(sed->ed.ed_headp),\n\t\t \"\\20\\1HALT\\2CARRY\",\n\t\t (u_long)le32toh(sed->ed.ed_headp),\n\t\t (u_long)le32toh(sed->ed.ed_nexted)));\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static ohci_soft_ed_t",
            "ohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));",
            "ohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
            "ohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_ed_t;\nohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));\nohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\n\nvoid\nohci_dump_ed(sed)\n\tohci_soft_ed_t *sed;\n{\n\tDPRINTF((\"ED(%p) at 0x%08lx: addr=%d endpt=%d maxp=%d %b\\ntailp=0x%08lx \"\n\t\t \"headflags=%b headp=0x%08lx nexted=0x%08lx\\n\",\n\t\t sed, (u_long)sed->physaddr, \n\t\t OHCI_ED_GET_FA(le32toh(sed->ed.ed_flags)),\n\t\t OHCI_ED_GET_EN(le32toh(sed->ed.ed_flags)),\n\t\t OHCI_ED_GET_MAXP(le32toh(sed->ed.ed_flags)),\n\t\t (int)le32toh(sed->ed.ed_flags),\n\t\t \"\\20\\14OUT\\15IN\\16LOWSPEED\\17SKIP\\20ISO\",\n\t\t (u_long)le32toh(sed->ed.ed_tailp),\n\t\t (u_long)le32toh(sed->ed.ed_headp),\n\t\t \"\\20\\1HALT\\2CARRY\",\n\t\t (u_long)le32toh(sed->ed.ed_headp),\n\t\t (u_long)le32toh(sed->ed.ed_nexted)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ohci_device_intr_transfer: status=%x\\n\",\n\t\t\t OREAD4(sc, OHCI_COMMAND_STATUS))"
          ],
          "line": 2757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OREAD4",
          "args": [
            "sc",
            "OHCI_COMMAND_STATUS"
          ],
          "line": 2758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "10000"
          ],
          "line": 2756
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_delay_ms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "316-322",
          "snippet": "void\nusbd_delay_ms(dev, ms)\n\tusbd_device_handle dev;\n\tu_int ms;\n{\n\tusb_delay_ms(dev->bus, ms);\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_set_config __P((usbd_device_handle, int));",
            "usbd_getnewaddr __P((usbd_bus_handle bus));",
            "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_set_config __P((usbd_device_handle, int));\nusbd_getnewaddr __P((usbd_bus_handle bus));\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\n\nvoid\nusbd_delay_ms(dev, ms)\n\tusbd_device_handle dev;\n\tu_int ms;\n{\n\tusb_delay_ms(dev->bus, ms);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usb_callout",
          "args": [
            "xfer->timeout_handle",
            "MS_TO_TICKS(xfer->timeout)",
            "ohci_timeout",
            "xfer"
          ],
          "line": 2749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MS_TO_TICKS",
          "args": [
            "xfer->timeout"
          ],
          "line": 2749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OWRITE4",
          "args": [
            "sc",
            "OHCI_COMMAND_STATUS",
            "OHCI_BLF"
          ],
          "line": 2747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "~OHCI_ED_SKIP"
          ],
          "line": 2746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "tail->physaddr"
          ],
          "line": 2744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 2740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "4",
            "(\"ohci_device_bulk_start: ed_flags=0x%08x td_flags=0x%08x \"\n\t\t    \"td_cbp=0x%08x td_be=0x%08x\\n\",\n\t\t    (int)le32toh(sed->ed.ed_flags),\n\t\t    (int)le32toh(data->td.td_flags),\n\t\t    (int)le32toh(data->td.td_cbp),\n\t\t    (int)le32toh(data->td.td_be))"
          ],
          "line": 2725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "data->td.td_be"
          ],
          "line": 2730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "data->td.td_cbp"
          ],
          "line": 2729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "data->td.td_flags"
          ],
          "line": 2728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "sed->ed.ed_flags"
          ],
          "line": 2727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "OHCI_TD_SET_DI(1)"
          ],
          "line": 2716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OHCI_TD_SET_DI",
          "args": [
            "1"
          ],
          "line": 2716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "~OHCI_TD_INTR_MASK"
          ],
          "line": 2715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ohci_alloc_std_chain",
          "args": [
            "opipe",
            "sc",
            "len",
            "isread",
            "xfer",
            "data",
            "&tail"
          ],
          "line": 2712
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_alloc_std_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "479-574",
          "snippet": "usbd_status\nohci_alloc_std_chain(opipe, sc, alen, rd, xfer, sp, ep)\n\tstruct ohci_pipe *opipe;\n\tohci_softc_t *sc;\n\tint alen, rd;\n\tusbd_xfer_handle xfer;\n\tohci_soft_td_t *sp, **ep;\n{\n\tohci_soft_td_t *next, *cur;\n\tohci_physaddr_t dataphys, dataphysend;\n\tu_int32_t tdflags;\n\tint len, curlen;\n\tusb_dma_t *dma = &xfer->dmabuf;\n\tu_int16_t flags = xfer->flags;\n\n\tDPRINTFN(alen < 4096,(\"ohci_alloc_std_chain: start len=%d\\n\", alen));\n\n\tlen = alen;\n\tcur = sp;\n\tdataphys = DMAADDR(dma);\n\tdataphysend = OHCI_PAGE(dataphys + len - 1);\n\ttdflags = htole32(\n\t    (rd ? OHCI_TD_IN : OHCI_TD_OUT) | \n\t    (flags & USBD_SHORT_XFER_OK ? OHCI_TD_R : 0) |\n\t    OHCI_TD_NOCC | OHCI_TD_TOGGLE_CARRY | OHCI_TD_NOINTR);\n\n\tfor (;;) {\n\t\tnext = ohci_alloc_std(sc);\n\t\tif (next == NULL)\n\t\t\tgoto nomem;\n\n\t\t/* The OHCI hardware can handle at most one page crossing. */\n\t\tif (OHCI_PAGE(dataphys) == dataphysend ||\n\t\t    OHCI_PAGE(dataphys) + OHCI_PAGE_SIZE == dataphysend) {\n\t\t\t/* we can handle it in this TD */\n\t\t\tcurlen = len;\n\t\t} else {\n\t\t\t/* must use multiple TDs, fill as much as possible. */\n\t\t\tcurlen = 2 * OHCI_PAGE_SIZE - \n\t\t\t\t (dataphys & (OHCI_PAGE_SIZE-1));\n\t\t\t/* the length must be a multiple of the max size */\n\t\t\tcurlen -= curlen % UGETW(opipe->pipe.endpoint->edesc->wMaxPacketSize);\n#ifdef DIAGNOSTIC\n\t\t\tif (curlen == 0)\n\t\t\t\tpanic(\"ohci_alloc_std: curlen == 0\\n\");\n#endif\n\t\t}\n\t\tDPRINTFN(4,(\"ohci_alloc_std_chain: dataphys=0x%08x \"\n\t\t\t    \"dataphysend=0x%08x len=%d curlen=%d\\n\",\n\t\t\t    dataphys, dataphysend,\n\t\t\t    len, curlen));\n\t\tlen -= curlen;\n\n\t\tcur->td.td_flags = tdflags;\n\t\tcur->td.td_cbp = htole32(dataphys);\n\t\tcur->nexttd = next;\n\t\tcur->td.td_nexttd = htole32(next->physaddr);\n\t\tcur->td.td_be = htole32(dataphys + curlen - 1);\n\t\tcur->len = curlen;\n\t\tcur->flags = OHCI_ADD_LEN;\n\t\tcur->xfer = xfer;\n\t\tDPRINTFN(10,(\"ohci_alloc_std_chain: cbp=0x%08x be=0x%08x\\n\",\n\t\t\t    dataphys, dataphys + curlen - 1));\n\t\tif (len == 0)\n\t\t\tbreak;\n\t\tDPRINTFN(10,(\"ohci_alloc_std_chain: extend chain\\n\"));\n\t\tdataphys += curlen;\n\t\tcur = next;\n\t}\n\tif ((flags & USBD_FORCE_SHORT_XFER) &&\n\t    alen % UGETW(opipe->pipe.endpoint->edesc->wMaxPacketSize) == 0) {\n\t\t/* Force a 0 length transfer at the end. */\n\n\t\tcur = next;\n\t\tnext = ohci_alloc_std(sc);\n\t\tif (next == NULL)\n\t\t\tgoto nomem;\n\n\t\tcur->td.td_flags = tdflags;\n\t\tcur->td.td_cbp = 0; /* indicate 0 length packet */\n\t\tcur->nexttd = next;\n\t\tcur->td.td_nexttd = htole32(next->physaddr);\n\t\tcur->td.td_be = ~0;\n\t\tcur->len = 0;\n\t\tcur->flags = 0;\n\t\tcur->xfer = xfer;\n\t\tDPRINTFN(2,(\"ohci_alloc_std_chain: add 0 xfer\\n\"));\n\t}\n\t*ep = cur;\n\n\treturn (USBD_NORMAL_COMPLETION);\n\n nomem:\n\t/* XXX free chain */\n\treturn (USBD_NOMEM);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static ohci_soft_td_t",
            "ohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));",
            "Static usbd_status",
            "ohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));",
            "Static usbd_status",
            "ohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));",
            "ohci_add_done __P((ohci_softc_t *, ohci_physaddr_t));",
            "ohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_request __P((usbd_xfer_handle xfer));",
            "ohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));",
            "ohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));",
            "Static ohci_soft_td_t",
            "Static usbd_status",
            "ohci_setup_isoc __P((usbd_pipe_handle pipe));",
            "ohci_device_isoc_enter __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));",
            "ohci_freem __P((struct usbd_bus *, usb_dma_t *));",
            "Static usbd_xfer_handle",
            "ohci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_root_ctrl_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_root_ctrl_start __P((usbd_xfer_handle));",
            "ohci_root_ctrl_abort __P((usbd_xfer_handle));",
            "ohci_root_ctrl_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_root_intr_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_root_intr_start __P((usbd_xfer_handle));",
            "ohci_root_intr_abort __P((usbd_xfer_handle));",
            "ohci_root_intr_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_ctrl_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_ctrl_start __P((usbd_xfer_handle));",
            "ohci_device_ctrl_abort __P((usbd_xfer_handle));",
            "ohci_device_ctrl_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_bulk_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_bulk_start __P((usbd_xfer_handle));",
            "ohci_device_bulk_abort __P((usbd_xfer_handle));",
            "ohci_device_bulk_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_intr_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_intr_start __P((usbd_xfer_handle));",
            "ohci_device_intr_abort __P((usbd_xfer_handle));",
            "ohci_device_intr_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_isoc_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_isoc_start __P((usbd_xfer_handle));",
            "ohci_device_isoc_abort __P((usbd_xfer_handle));",
            "ohci_device_isoc_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_rhsc_able __P((ohci_softc_t *, int));",
            "ohci_device_clear_toggle __P((usbd_pipe_handle pipe));",
            "ohci_noop __P((usbd_pipe_handle pipe));",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
            "ohci_intr1 __P((ohci_softc_t *));",
            "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
            "ohci_physaddr_t a;",
            "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;",
            "ohci_physaddr_t a;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_td_t;\nohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));\nStatic usbd_status;\nohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));\nStatic usbd_status;\nohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));\nohci_add_done __P((ohci_softc_t *, ohci_physaddr_t));\nohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));\nStatic usbd_status;\nohci_device_request __P((usbd_xfer_handle xfer));\nohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));\nohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));\nStatic ohci_soft_td_t;\nStatic usbd_status;\nohci_setup_isoc __P((usbd_pipe_handle pipe));\nohci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));\nohci_freem __P((struct usbd_bus *, usb_dma_t *));\nStatic usbd_xfer_handle;\nohci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nStatic usbd_status;\nohci_root_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_ctrl_start __P((usbd_xfer_handle));\nohci_root_ctrl_abort __P((usbd_xfer_handle));\nohci_root_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_intr_start __P((usbd_xfer_handle));\nohci_root_intr_abort __P((usbd_xfer_handle));\nohci_root_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_ctrl_start __P((usbd_xfer_handle));\nohci_device_ctrl_abort __P((usbd_xfer_handle));\nohci_device_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_bulk_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_bulk_start __P((usbd_xfer_handle));\nohci_device_bulk_abort __P((usbd_xfer_handle));\nohci_device_bulk_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_intr_start __P((usbd_xfer_handle));\nohci_device_intr_abort __P((usbd_xfer_handle));\nohci_device_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_isoc_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_isoc_start __P((usbd_xfer_handle));\nohci_device_isoc_abort __P((usbd_xfer_handle));\nohci_device_isoc_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_rhsc_able __P((ohci_softc_t *, int));\nohci_device_clear_toggle __P((usbd_pipe_handle pipe));\nohci_noop __P((usbd_pipe_handle pipe));\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_physaddr_t a;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\nohci_physaddr_t a;\n\nusbd_status\nohci_alloc_std_chain(opipe, sc, alen, rd, xfer, sp, ep)\n\tstruct ohci_pipe *opipe;\n\tohci_softc_t *sc;\n\tint alen, rd;\n\tusbd_xfer_handle xfer;\n\tohci_soft_td_t *sp, **ep;\n{\n\tohci_soft_td_t *next, *cur;\n\tohci_physaddr_t dataphys, dataphysend;\n\tu_int32_t tdflags;\n\tint len, curlen;\n\tusb_dma_t *dma = &xfer->dmabuf;\n\tu_int16_t flags = xfer->flags;\n\n\tDPRINTFN(alen < 4096,(\"ohci_alloc_std_chain: start len=%d\\n\", alen));\n\n\tlen = alen;\n\tcur = sp;\n\tdataphys = DMAADDR(dma);\n\tdataphysend = OHCI_PAGE(dataphys + len - 1);\n\ttdflags = htole32(\n\t    (rd ? OHCI_TD_IN : OHCI_TD_OUT) | \n\t    (flags & USBD_SHORT_XFER_OK ? OHCI_TD_R : 0) |\n\t    OHCI_TD_NOCC | OHCI_TD_TOGGLE_CARRY | OHCI_TD_NOINTR);\n\n\tfor (;;) {\n\t\tnext = ohci_alloc_std(sc);\n\t\tif (next == NULL)\n\t\t\tgoto nomem;\n\n\t\t/* The OHCI hardware can handle at most one page crossing. */\n\t\tif (OHCI_PAGE(dataphys) == dataphysend ||\n\t\t    OHCI_PAGE(dataphys) + OHCI_PAGE_SIZE == dataphysend) {\n\t\t\t/* we can handle it in this TD */\n\t\t\tcurlen = len;\n\t\t} else {\n\t\t\t/* must use multiple TDs, fill as much as possible. */\n\t\t\tcurlen = 2 * OHCI_PAGE_SIZE - \n\t\t\t\t (dataphys & (OHCI_PAGE_SIZE-1));\n\t\t\t/* the length must be a multiple of the max size */\n\t\t\tcurlen -= curlen % UGETW(opipe->pipe.endpoint->edesc->wMaxPacketSize);\n#ifdef DIAGNOSTIC\n\t\t\tif (curlen == 0)\n\t\t\t\tpanic(\"ohci_alloc_std: curlen == 0\\n\");\n#endif\n\t\t}\n\t\tDPRINTFN(4,(\"ohci_alloc_std_chain: dataphys=0x%08x \"\n\t\t\t    \"dataphysend=0x%08x len=%d curlen=%d\\n\",\n\t\t\t    dataphys, dataphysend,\n\t\t\t    len, curlen));\n\t\tlen -= curlen;\n\n\t\tcur->td.td_flags = tdflags;\n\t\tcur->td.td_cbp = htole32(dataphys);\n\t\tcur->nexttd = next;\n\t\tcur->td.td_nexttd = htole32(next->physaddr);\n\t\tcur->td.td_be = htole32(dataphys + curlen - 1);\n\t\tcur->len = curlen;\n\t\tcur->flags = OHCI_ADD_LEN;\n\t\tcur->xfer = xfer;\n\t\tDPRINTFN(10,(\"ohci_alloc_std_chain: cbp=0x%08x be=0x%08x\\n\",\n\t\t\t    dataphys, dataphys + curlen - 1));\n\t\tif (len == 0)\n\t\t\tbreak;\n\t\tDPRINTFN(10,(\"ohci_alloc_std_chain: extend chain\\n\"));\n\t\tdataphys += curlen;\n\t\tcur = next;\n\t}\n\tif ((flags & USBD_FORCE_SHORT_XFER) &&\n\t    alen % UGETW(opipe->pipe.endpoint->edesc->wMaxPacketSize) == 0) {\n\t\t/* Force a 0 length transfer at the end. */\n\n\t\tcur = next;\n\t\tnext = ohci_alloc_std(sc);\n\t\tif (next == NULL)\n\t\t\tgoto nomem;\n\n\t\tcur->td.td_flags = tdflags;\n\t\tcur->td.td_cbp = 0; /* indicate 0 length packet */\n\t\tcur->nexttd = next;\n\t\tcur->td.td_nexttd = htole32(next->physaddr);\n\t\tcur->td.td_be = ~0;\n\t\tcur->len = 0;\n\t\tcur->flags = 0;\n\t\tcur->xfer = xfer;\n\t\tDPRINTFN(2,(\"ohci_alloc_std_chain: add 0 xfer\\n\"));\n\t}\n\t*ep = cur;\n\n\treturn (USBD_NORMAL_COMPLETION);\n\n nomem:\n\t/* XXX free chain */\n\treturn (USBD_NOMEM);\n}"
        }
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "(le32toh(sed->ed.ed_flags) & ~OHCI_ED_ADDRMASK) |\n\t\tOHCI_ED_SET_FA(addr)"
          ],
          "line": 2706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OHCI_ED_SET_FA",
          "args": [
            "addr"
          ],
          "line": 2708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "sed->ed.ed_flags"
          ],
          "line": 2707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "4",
            "(\"ohci_device_bulk_start: xfer=%p len=%d isread=%d \"\n\t\t    \"flags=%d endpt=%d\\n\", xfer, len, isread, xfer->flags,\n\t\t    endpt)"
          ],
          "line": 2698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UE_GET_DIR",
          "args": [
            "endpt"
          ],
          "line": 2695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ohci_device_bulk_start: a request\\n\""
          ],
          "line": 2688
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_ed_t;\nStatic void;\nohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));\nStatic ohci_soft_td_t;\nStatic void;\nohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));\nStatic void;\nStatic usbd_status;\nohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));\nStatic void;\nStatic void;\nStatic usbd_status;\nStatic void;\nStatic void;\nStatic void;\nohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));\nStatic usbd_status;\nohci_device_request __P((usbd_xfer_handle xfer));\nStatic void;\nohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nStatic void;\nohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nStatic void;\nohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));\nStatic void;\nohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));\nStatic ohci_soft_td_t;\nStatic void;\nStatic void;\nStatic usbd_status;\nohci_setup_isoc __P((usbd_pipe_handle pipe));\nStatic void;\nohci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic void;\nStatic usbd_xfer_handle;\nStatic void;\nohci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nStatic usbd_status;\nohci_root_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_ctrl_start __P((usbd_xfer_handle));\nStatic void;\nohci_root_ctrl_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_root_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_intr_start __P((usbd_xfer_handle));\nStatic void;\nohci_root_intr_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_root_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_ctrl_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_ctrl_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_bulk_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_bulk_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_bulk_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_bulk_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_intr_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_intr_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_isoc_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_isoc_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_isoc_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_isoc_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic int;\nStatic void;\nStatic void;\nohci_rhsc_able __P((ohci_softc_t *, int));\nStatic void;\nStatic void;\nohci_abort_xfer __P((usbd_xfer_handle xfer,\n\t\t\t    usbd_status status));\nStatic void;\nStatic void;\nohci_device_clear_toggle __P((usbd_pipe_handle pipe));\nStatic void;\nohci_noop __P((usbd_pipe_handle pipe));\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nStatic int;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_physaddr_t a;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\nohci_physaddr_t a;\n\nStatic usbd_status\nohci_device_bulk_start(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tstruct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;\n\tusbd_device_handle dev = opipe->pipe.device;\n\tohci_softc_t *sc = (ohci_softc_t *)dev->bus;\n\tint addr = dev->address;\n\tohci_soft_td_t *data, *tail, *tdp;\n\tohci_soft_ed_t *sed;\n\tint s, len, isread, endpt;\n\tusbd_status err;\n\n\tif (sc->sc_dying)\n\t\treturn (USBD_IOERROR);\n\n#ifdef DIAGNOSTIC\n\tif (xfer->rqflags & URQ_REQUEST) {\n\t\t/* XXX panic */\n\t\tprintf(\"ohci_device_bulk_start: a request\\n\");\n\t\treturn (USBD_INVAL);\n\t}\n#endif\n\n\tlen = xfer->length;\n\tendpt = xfer->pipe->endpoint->edesc->bEndpointAddress;\n\tisread = UE_GET_DIR(endpt) == UE_DIR_IN;\n\tsed = opipe->sed;\n\n\tDPRINTFN(4,(\"ohci_device_bulk_start: xfer=%p len=%d isread=%d \"\n\t\t    \"flags=%d endpt=%d\\n\", xfer, len, isread, xfer->flags,\n\t\t    endpt));\n\n\topipe->u.bulk.isread = isread;\n\topipe->u.bulk.length = len;\n\n\t/* Update device address */\n\tsed->ed.ed_flags = htole32(\n\t\t(le32toh(sed->ed.ed_flags) & ~OHCI_ED_ADDRMASK) |\n\t\tOHCI_ED_SET_FA(addr));\n\n\t/* Allocate a chain of new TDs (including a new tail). */\n\tdata = opipe->tail.td;\n\terr = ohci_alloc_std_chain(opipe, sc, len, isread, xfer,\n\t\t  data, &tail);\n\t/* We want interrupt at the end of the transfer. */\n\ttail->td.td_flags &= htole32(~OHCI_TD_INTR_MASK);\n\ttail->td.td_flags |= htole32(OHCI_TD_SET_DI(1));\n\ttail->flags |= OHCI_CALL_DONE;\n\ttail = tail->nexttd;\t/* point at sentinel */\n\tif (err)\n\t\treturn (err);\n\n\ttail->xfer = NULL;\n\txfer->hcpriv = data;\n\n\tDPRINTFN(4,(\"ohci_device_bulk_start: ed_flags=0x%08x td_flags=0x%08x \"\n\t\t    \"td_cbp=0x%08x td_be=0x%08x\\n\",\n\t\t    (int)le32toh(sed->ed.ed_flags),\n\t\t    (int)le32toh(data->td.td_flags),\n\t\t    (int)le32toh(data->td.td_cbp),\n\t\t    (int)le32toh(data->td.td_be)));\n\n#ifdef OHCI_DEBUG\n\tif (ohcidebug > 5) {\n\t\tohci_dump_ed(sed);\n\t\tohci_dump_tds(data);\n\t}\n#endif\n\n\t/* Insert ED in schedule */\n\ts = splusb();\n\tfor (tdp = data; tdp != tail; tdp = tdp->nexttd) {\n\t\ttdp->xfer = xfer;\n\t}\n\tsed->ed.ed_tailp = htole32(tail->physaddr);\n\topipe->tail.td = tail;\n\tsed->ed.ed_flags &= htole32(~OHCI_ED_SKIP);\n\tOWRITE4(sc, OHCI_COMMAND_STATUS, OHCI_BLF);\n\tif (xfer->timeout && !sc->sc_bus.use_polling) {\n                usb_callout(xfer->timeout_handle, MS_TO_TICKS(xfer->timeout),\n\t\t\t    ohci_timeout, xfer);\n\t}\n\n#if 0\n/* This goes wrong if we are too slow. */\n\tif (ohcidebug > 10) {\n\t\tdelay(10000);\n\t\tDPRINTF((\"ohci_device_intr_transfer: status=%x\\n\",\n\t\t\t OREAD4(sc, OHCI_COMMAND_STATUS)));\n\t\tohci_dump_ed(sed);\n\t\tohci_dump_tds(data);\n\t}\n#endif\n\n\tsplx(s);\n\n\treturn (USBD_IN_PROGRESS);\n}"
  },
  {
    "function_name": "ohci_device_bulk_transfer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "2654-2667",
    "snippet": "Static usbd_status\nohci_device_bulk_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_status err;\n\n\t/* Insert last in queue. */\n\terr = usb_insert_transfer(xfer);\n\tif (err)\n\t\treturn (err);\n\n\t/* Pipe isn't running, start first */\n\treturn (ohci_device_bulk_start(SIMPLEQ_FIRST(&xfer->pipe->queue)));\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static void",
      "Static void",
      "Static void",
      "Static usbd_status",
      "Static void",
      "Static void",
      "Static usbd_status",
      "Static void",
      "Static void",
      "Static void",
      "ohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_request __P((usbd_xfer_handle xfer));",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static usbd_status",
      "ohci_setup_isoc __P((usbd_pipe_handle pipe));",
      "Static void",
      "ohci_device_isoc_enter __P((usbd_xfer_handle));",
      "Static usbd_status",
      "Static void",
      "Static usbd_xfer_handle",
      "Static void",
      "ohci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_root_ctrl_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_root_ctrl_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_root_ctrl_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_root_intr_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_root_intr_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_root_intr_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_root_intr_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_ctrl_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_device_ctrl_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_device_ctrl_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_bulk_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_bulk_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_device_bulk_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_device_bulk_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_intr_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_intr_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_device_intr_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_device_intr_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_isoc_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_isoc_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_device_isoc_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_device_isoc_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "Static int",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "ohci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "Static void",
      "ohci_noop __P((usbd_pipe_handle pipe));",
      "Static int"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ohci_device_bulk_start",
          "args": [
            "SIMPLEQ_FIRST(&xfer->pipe->queue)"
          ],
          "line": 2666
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_device_bulk_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "2669-2767",
          "snippet": "Static usbd_status\nohci_device_bulk_start(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tstruct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;\n\tusbd_device_handle dev = opipe->pipe.device;\n\tohci_softc_t *sc = (ohci_softc_t *)dev->bus;\n\tint addr = dev->address;\n\tohci_soft_td_t *data, *tail, *tdp;\n\tohci_soft_ed_t *sed;\n\tint s, len, isread, endpt;\n\tusbd_status err;\n\n\tif (sc->sc_dying)\n\t\treturn (USBD_IOERROR);\n\n#ifdef DIAGNOSTIC\n\tif (xfer->rqflags & URQ_REQUEST) {\n\t\t/* XXX panic */\n\t\tprintf(\"ohci_device_bulk_start: a request\\n\");\n\t\treturn (USBD_INVAL);\n\t}\n#endif\n\n\tlen = xfer->length;\n\tendpt = xfer->pipe->endpoint->edesc->bEndpointAddress;\n\tisread = UE_GET_DIR(endpt) == UE_DIR_IN;\n\tsed = opipe->sed;\n\n\tDPRINTFN(4,(\"ohci_device_bulk_start: xfer=%p len=%d isread=%d \"\n\t\t    \"flags=%d endpt=%d\\n\", xfer, len, isread, xfer->flags,\n\t\t    endpt));\n\n\topipe->u.bulk.isread = isread;\n\topipe->u.bulk.length = len;\n\n\t/* Update device address */\n\tsed->ed.ed_flags = htole32(\n\t\t(le32toh(sed->ed.ed_flags) & ~OHCI_ED_ADDRMASK) |\n\t\tOHCI_ED_SET_FA(addr));\n\n\t/* Allocate a chain of new TDs (including a new tail). */\n\tdata = opipe->tail.td;\n\terr = ohci_alloc_std_chain(opipe, sc, len, isread, xfer,\n\t\t  data, &tail);\n\t/* We want interrupt at the end of the transfer. */\n\ttail->td.td_flags &= htole32(~OHCI_TD_INTR_MASK);\n\ttail->td.td_flags |= htole32(OHCI_TD_SET_DI(1));\n\ttail->flags |= OHCI_CALL_DONE;\n\ttail = tail->nexttd;\t/* point at sentinel */\n\tif (err)\n\t\treturn (err);\n\n\ttail->xfer = NULL;\n\txfer->hcpriv = data;\n\n\tDPRINTFN(4,(\"ohci_device_bulk_start: ed_flags=0x%08x td_flags=0x%08x \"\n\t\t    \"td_cbp=0x%08x td_be=0x%08x\\n\",\n\t\t    (int)le32toh(sed->ed.ed_flags),\n\t\t    (int)le32toh(data->td.td_flags),\n\t\t    (int)le32toh(data->td.td_cbp),\n\t\t    (int)le32toh(data->td.td_be)));\n\n#ifdef OHCI_DEBUG\n\tif (ohcidebug > 5) {\n\t\tohci_dump_ed(sed);\n\t\tohci_dump_tds(data);\n\t}\n#endif\n\n\t/* Insert ED in schedule */\n\ts = splusb();\n\tfor (tdp = data; tdp != tail; tdp = tdp->nexttd) {\n\t\ttdp->xfer = xfer;\n\t}\n\tsed->ed.ed_tailp = htole32(tail->physaddr);\n\topipe->tail.td = tail;\n\tsed->ed.ed_flags &= htole32(~OHCI_ED_SKIP);\n\tOWRITE4(sc, OHCI_COMMAND_STATUS, OHCI_BLF);\n\tif (xfer->timeout && !sc->sc_bus.use_polling) {\n                usb_callout(xfer->timeout_handle, MS_TO_TICKS(xfer->timeout),\n\t\t\t    ohci_timeout, xfer);\n\t}\n\n#if 0\n/* This goes wrong if we are too slow. */\n\tif (ohcidebug > 10) {\n\t\tdelay(10000);\n\t\tDPRINTF((\"ohci_device_intr_transfer: status=%x\\n\",\n\t\t\t OREAD4(sc, OHCI_COMMAND_STATUS)));\n\t\tohci_dump_ed(sed);\n\t\tohci_dump_tds(data);\n\t}\n#endif\n\n\tsplx(s);\n\n\treturn (USBD_IN_PROGRESS);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static ohci_soft_ed_t",
            "Static void",
            "ohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));",
            "Static ohci_soft_td_t",
            "Static void",
            "ohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));",
            "Static void",
            "Static usbd_status",
            "ohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));",
            "Static void",
            "Static void",
            "Static usbd_status",
            "Static void",
            "Static void",
            "Static void",
            "ohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));",
            "Static void",
            "Static void",
            "ohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_request __P((usbd_xfer_handle xfer));",
            "Static void",
            "ohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
            "Static void",
            "ohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
            "Static void",
            "ohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));",
            "Static void",
            "ohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));",
            "Static ohci_soft_td_t",
            "Static void",
            "Static void",
            "Static usbd_status",
            "ohci_setup_isoc __P((usbd_pipe_handle pipe));",
            "Static void",
            "ohci_device_isoc_enter __P((usbd_xfer_handle));",
            "Static usbd_status",
            "Static void",
            "Static usbd_xfer_handle",
            "Static void",
            "ohci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_root_ctrl_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_root_ctrl_start __P((usbd_xfer_handle));",
            "Static void",
            "ohci_root_ctrl_abort __P((usbd_xfer_handle));",
            "Static void",
            "Static void",
            "ohci_root_ctrl_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_root_intr_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_root_intr_start __P((usbd_xfer_handle));",
            "Static void",
            "ohci_root_intr_abort __P((usbd_xfer_handle));",
            "Static void",
            "Static void",
            "ohci_root_intr_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_ctrl_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_ctrl_start __P((usbd_xfer_handle));",
            "Static void",
            "ohci_device_ctrl_abort __P((usbd_xfer_handle));",
            "Static void",
            "Static void",
            "ohci_device_ctrl_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_bulk_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_bulk_start __P((usbd_xfer_handle));",
            "Static void",
            "ohci_device_bulk_abort __P((usbd_xfer_handle));",
            "Static void",
            "Static void",
            "ohci_device_bulk_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_intr_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_intr_start __P((usbd_xfer_handle));",
            "Static void",
            "ohci_device_intr_abort __P((usbd_xfer_handle));",
            "Static void",
            "Static void",
            "ohci_device_intr_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_isoc_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_isoc_start __P((usbd_xfer_handle));",
            "Static void",
            "ohci_device_isoc_abort __P((usbd_xfer_handle));",
            "Static void",
            "Static void",
            "ohci_device_isoc_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "Static int",
            "Static void",
            "Static void",
            "ohci_rhsc_able __P((ohci_softc_t *, int));",
            "Static void",
            "Static void",
            "ohci_abort_xfer __P((usbd_xfer_handle xfer,\n\t\t\t    usbd_status status));",
            "Static void",
            "Static void",
            "ohci_device_clear_toggle __P((usbd_pipe_handle pipe));",
            "Static void",
            "ohci_noop __P((usbd_pipe_handle pipe));",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
            "Static int",
            "ohci_intr1 __P((ohci_softc_t *));",
            "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
            "ohci_physaddr_t a;",
            "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;",
            "ohci_physaddr_t a;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_ed_t;\nStatic void;\nohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));\nStatic ohci_soft_td_t;\nStatic void;\nohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));\nStatic void;\nStatic usbd_status;\nohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));\nStatic void;\nStatic void;\nStatic usbd_status;\nStatic void;\nStatic void;\nStatic void;\nohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));\nStatic usbd_status;\nohci_device_request __P((usbd_xfer_handle xfer));\nStatic void;\nohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nStatic void;\nohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nStatic void;\nohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));\nStatic void;\nohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));\nStatic ohci_soft_td_t;\nStatic void;\nStatic void;\nStatic usbd_status;\nohci_setup_isoc __P((usbd_pipe_handle pipe));\nStatic void;\nohci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic void;\nStatic usbd_xfer_handle;\nStatic void;\nohci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nStatic usbd_status;\nohci_root_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_ctrl_start __P((usbd_xfer_handle));\nStatic void;\nohci_root_ctrl_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_root_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_intr_start __P((usbd_xfer_handle));\nStatic void;\nohci_root_intr_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_root_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_ctrl_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_ctrl_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_bulk_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_bulk_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_bulk_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_bulk_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_intr_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_intr_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_isoc_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_isoc_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_isoc_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_isoc_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic int;\nStatic void;\nStatic void;\nohci_rhsc_able __P((ohci_softc_t *, int));\nStatic void;\nStatic void;\nohci_abort_xfer __P((usbd_xfer_handle xfer,\n\t\t\t    usbd_status status));\nStatic void;\nStatic void;\nohci_device_clear_toggle __P((usbd_pipe_handle pipe));\nStatic void;\nohci_noop __P((usbd_pipe_handle pipe));\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nStatic int;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_physaddr_t a;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\nohci_physaddr_t a;\n\nStatic usbd_status\nohci_device_bulk_start(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tstruct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;\n\tusbd_device_handle dev = opipe->pipe.device;\n\tohci_softc_t *sc = (ohci_softc_t *)dev->bus;\n\tint addr = dev->address;\n\tohci_soft_td_t *data, *tail, *tdp;\n\tohci_soft_ed_t *sed;\n\tint s, len, isread, endpt;\n\tusbd_status err;\n\n\tif (sc->sc_dying)\n\t\treturn (USBD_IOERROR);\n\n#ifdef DIAGNOSTIC\n\tif (xfer->rqflags & URQ_REQUEST) {\n\t\t/* XXX panic */\n\t\tprintf(\"ohci_device_bulk_start: a request\\n\");\n\t\treturn (USBD_INVAL);\n\t}\n#endif\n\n\tlen = xfer->length;\n\tendpt = xfer->pipe->endpoint->edesc->bEndpointAddress;\n\tisread = UE_GET_DIR(endpt) == UE_DIR_IN;\n\tsed = opipe->sed;\n\n\tDPRINTFN(4,(\"ohci_device_bulk_start: xfer=%p len=%d isread=%d \"\n\t\t    \"flags=%d endpt=%d\\n\", xfer, len, isread, xfer->flags,\n\t\t    endpt));\n\n\topipe->u.bulk.isread = isread;\n\topipe->u.bulk.length = len;\n\n\t/* Update device address */\n\tsed->ed.ed_flags = htole32(\n\t\t(le32toh(sed->ed.ed_flags) & ~OHCI_ED_ADDRMASK) |\n\t\tOHCI_ED_SET_FA(addr));\n\n\t/* Allocate a chain of new TDs (including a new tail). */\n\tdata = opipe->tail.td;\n\terr = ohci_alloc_std_chain(opipe, sc, len, isread, xfer,\n\t\t  data, &tail);\n\t/* We want interrupt at the end of the transfer. */\n\ttail->td.td_flags &= htole32(~OHCI_TD_INTR_MASK);\n\ttail->td.td_flags |= htole32(OHCI_TD_SET_DI(1));\n\ttail->flags |= OHCI_CALL_DONE;\n\ttail = tail->nexttd;\t/* point at sentinel */\n\tif (err)\n\t\treturn (err);\n\n\ttail->xfer = NULL;\n\txfer->hcpriv = data;\n\n\tDPRINTFN(4,(\"ohci_device_bulk_start: ed_flags=0x%08x td_flags=0x%08x \"\n\t\t    \"td_cbp=0x%08x td_be=0x%08x\\n\",\n\t\t    (int)le32toh(sed->ed.ed_flags),\n\t\t    (int)le32toh(data->td.td_flags),\n\t\t    (int)le32toh(data->td.td_cbp),\n\t\t    (int)le32toh(data->td.td_be)));\n\n#ifdef OHCI_DEBUG\n\tif (ohcidebug > 5) {\n\t\tohci_dump_ed(sed);\n\t\tohci_dump_tds(data);\n\t}\n#endif\n\n\t/* Insert ED in schedule */\n\ts = splusb();\n\tfor (tdp = data; tdp != tail; tdp = tdp->nexttd) {\n\t\ttdp->xfer = xfer;\n\t}\n\tsed->ed.ed_tailp = htole32(tail->physaddr);\n\topipe->tail.td = tail;\n\tsed->ed.ed_flags &= htole32(~OHCI_ED_SKIP);\n\tOWRITE4(sc, OHCI_COMMAND_STATUS, OHCI_BLF);\n\tif (xfer->timeout && !sc->sc_bus.use_polling) {\n                usb_callout(xfer->timeout_handle, MS_TO_TICKS(xfer->timeout),\n\t\t\t    ohci_timeout, xfer);\n\t}\n\n#if 0\n/* This goes wrong if we are too slow. */\n\tif (ohcidebug > 10) {\n\t\tdelay(10000);\n\t\tDPRINTF((\"ohci_device_intr_transfer: status=%x\\n\",\n\t\t\t OREAD4(sc, OHCI_COMMAND_STATUS)));\n\t\tohci_dump_ed(sed);\n\t\tohci_dump_tds(data);\n\t}\n#endif\n\n\tsplx(s);\n\n\treturn (USBD_IN_PROGRESS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_FIRST",
          "args": [
            "&xfer->pipe->queue"
          ],
          "line": 2666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_insert_transfer",
          "args": [
            "xfer"
          ],
          "line": 2661
        },
        "resolved": true,
        "details": {
          "function_name": "usb_insert_transfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "885-905",
          "snippet": "usbd_status\nusb_insert_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusbd_status err;\n\tint s;\n\n\tDPRINTFN(5,(\"usb_insert_transfer: pipe=%p running=%d timeout=%d\\n\", \n\t\t    pipe, pipe->running, xfer->timeout));\n\ts = splusb();\n\tSIMPLEQ_INSERT_TAIL(&pipe->queue, xfer, next);\n\tif (pipe->running)\n\t\terr = USBD_IN_PROGRESS;\n\telse {\n\t\tpipe->running = 1;\n\t\terr = USBD_NORMAL_COMPLETION;\n\t}\n\tsplx(s);\n\treturn (err);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nusbd_status\nusb_insert_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusbd_status err;\n\tint s;\n\n\tDPRINTFN(5,(\"usb_insert_transfer: pipe=%p running=%d timeout=%d\\n\", \n\t\t    pipe, pipe->running, xfer->timeout));\n\ts = splusb();\n\tSIMPLEQ_INSERT_TAIL(&pipe->queue, xfer, next);\n\tif (pipe->running)\n\t\terr = USBD_IN_PROGRESS;\n\telse {\n\t\tpipe->running = 1;\n\t\terr = USBD_NORMAL_COMPLETION;\n\t}\n\tsplx(s);\n\treturn (err);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nStatic void;\nStatic void;\nStatic usbd_status;\nStatic void;\nStatic void;\nStatic usbd_status;\nStatic void;\nStatic void;\nStatic void;\nohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));\nStatic usbd_status;\nohci_device_request __P((usbd_xfer_handle xfer));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic usbd_status;\nohci_setup_isoc __P((usbd_pipe_handle pipe));\nStatic void;\nohci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic void;\nStatic usbd_xfer_handle;\nStatic void;\nohci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nStatic usbd_status;\nohci_root_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_ctrl_start __P((usbd_xfer_handle));\nStatic void;\nohci_root_ctrl_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_root_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_intr_start __P((usbd_xfer_handle));\nStatic void;\nohci_root_intr_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_root_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_ctrl_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_ctrl_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_bulk_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_bulk_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_bulk_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_bulk_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_intr_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_intr_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_isoc_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_isoc_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_isoc_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_isoc_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_device_clear_toggle __P((usbd_pipe_handle pipe));\nStatic void;\nohci_noop __P((usbd_pipe_handle pipe));\nStatic int;\n\nStatic usbd_status\nohci_device_bulk_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_status err;\n\n\t/* Insert last in queue. */\n\terr = usb_insert_transfer(xfer);\n\tif (err)\n\t\treturn (err);\n\n\t/* Pipe isn't running, start first */\n\treturn (ohci_device_bulk_start(SIMPLEQ_FIRST(&xfer->pipe->queue)));\n}"
  },
  {
    "function_name": "ohci_noop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "2648-2652",
    "snippet": "Static void\nohci_noop(pipe)\n\tusbd_pipe_handle pipe;\n{\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "ohci_open __P((usbd_pipe_handle));",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "ohci_setup_isoc __P((usbd_pipe_handle pipe));",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "ohci_root_ctrl_close __P((usbd_pipe_handle));",
      "Static void",
      "Static void",
      "Static void",
      "ohci_root_intr_close __P((usbd_pipe_handle));",
      "Static void",
      "Static void",
      "Static void",
      "ohci_device_ctrl_close __P((usbd_pipe_handle));",
      "Static void",
      "Static void",
      "Static void",
      "ohci_device_bulk_close __P((usbd_pipe_handle));",
      "Static void",
      "Static void",
      "Static void",
      "ohci_device_intr_close __P((usbd_pipe_handle));",
      "Static void",
      "Static void",
      "Static void",
      "ohci_device_isoc_close __P((usbd_pipe_handle));",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "ohci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "Static void",
      "ohci_noop __P((usbd_pipe_handle pipe));",
      "Static int"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_open __P((usbd_pipe_handle));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_setup_isoc __P((usbd_pipe_handle pipe));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_root_ctrl_close __P((usbd_pipe_handle));\nStatic void;\nStatic void;\nStatic void;\nohci_root_intr_close __P((usbd_pipe_handle));\nStatic void;\nStatic void;\nStatic void;\nohci_device_ctrl_close __P((usbd_pipe_handle));\nStatic void;\nStatic void;\nStatic void;\nohci_device_bulk_close __P((usbd_pipe_handle));\nStatic void;\nStatic void;\nStatic void;\nohci_device_intr_close __P((usbd_pipe_handle));\nStatic void;\nStatic void;\nStatic void;\nohci_device_isoc_close __P((usbd_pipe_handle));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_device_clear_toggle __P((usbd_pipe_handle pipe));\nStatic void;\nohci_noop __P((usbd_pipe_handle pipe));\nStatic int;\n\nStatic void\nohci_noop(pipe)\n\tusbd_pipe_handle pipe;\n{\n}"
  },
  {
    "function_name": "ohci_device_clear_toggle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "2639-2646",
    "snippet": "Static void\nohci_device_clear_toggle(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tstruct ohci_pipe *opipe = (struct ohci_pipe *)pipe;\n\n\topipe->sed->ed.ed_headp &= htole32(~OHCI_TOGGLECARRY);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "ohci_open __P((usbd_pipe_handle));",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "ohci_setup_isoc __P((usbd_pipe_handle pipe));",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "ohci_root_ctrl_close __P((usbd_pipe_handle));",
      "Static void",
      "Static void",
      "Static void",
      "ohci_root_intr_close __P((usbd_pipe_handle));",
      "Static void",
      "Static void",
      "Static void",
      "ohci_device_ctrl_close __P((usbd_pipe_handle));",
      "Static void",
      "Static void",
      "Static void",
      "ohci_device_bulk_close __P((usbd_pipe_handle));",
      "Static void",
      "Static void",
      "Static void",
      "ohci_device_intr_close __P((usbd_pipe_handle));",
      "Static void",
      "Static void",
      "Static void",
      "ohci_device_isoc_close __P((usbd_pipe_handle));",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "ohci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "Static void",
      "ohci_noop __P((usbd_pipe_handle pipe));",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static int"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "~OHCI_TOGGLECARRY"
          ],
          "line": 2645
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_open __P((usbd_pipe_handle));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_setup_isoc __P((usbd_pipe_handle pipe));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_root_ctrl_close __P((usbd_pipe_handle));\nStatic void;\nStatic void;\nStatic void;\nohci_root_intr_close __P((usbd_pipe_handle));\nStatic void;\nStatic void;\nStatic void;\nohci_device_ctrl_close __P((usbd_pipe_handle));\nStatic void;\nStatic void;\nStatic void;\nohci_device_bulk_close __P((usbd_pipe_handle));\nStatic void;\nStatic void;\nStatic void;\nohci_device_intr_close __P((usbd_pipe_handle));\nStatic void;\nStatic void;\nStatic void;\nohci_device_isoc_close __P((usbd_pipe_handle));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_device_clear_toggle __P((usbd_pipe_handle pipe));\nStatic void;\nohci_noop __P((usbd_pipe_handle pipe));\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic int;\n\nStatic void\nohci_device_clear_toggle(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tstruct ohci_pipe *opipe = (struct ohci_pipe *)pipe;\n\n\topipe->sed->ed.ed_headp &= htole32(~OHCI_TOGGLECARRY);\n}"
  },
  {
    "function_name": "ohci_device_ctrl_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "2625-2635",
    "snippet": "Static void\nohci_device_ctrl_close(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tstruct ohci_pipe *opipe = (struct ohci_pipe *)pipe;\n\tohci_softc_t *sc = (ohci_softc_t *)pipe->device->bus;\n\n\tDPRINTF((\"ohci_device_ctrl_close: pipe=%p\\n\", pipe));\n\tohci_close_pipe(pipe, sc->sc_ctrl_head);\n\tohci_free_std(sc, opipe->tail.td);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "ohci_open __P((usbd_pipe_handle));",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "ohci_setup_isoc __P((usbd_pipe_handle pipe));",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "ohci_root_ctrl_close __P((usbd_pipe_handle));",
      "Static void",
      "Static void",
      "Static void",
      "ohci_root_intr_close __P((usbd_pipe_handle));",
      "Static void",
      "Static void",
      "Static void",
      "ohci_device_ctrl_close __P((usbd_pipe_handle));",
      "Static void",
      "Static void",
      "Static void",
      "ohci_device_bulk_close __P((usbd_pipe_handle));",
      "Static void",
      "Static void",
      "Static void",
      "ohci_device_intr_close __P((usbd_pipe_handle));",
      "Static void",
      "Static void",
      "Static void",
      "ohci_device_isoc_close __P((usbd_pipe_handle));",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "ohci_rhsc_able __P((ohci_softc_t *, int));",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "ohci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "Static void",
      "ohci_noop __P((usbd_pipe_handle pipe));",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
      "Static int",
      "ohci_intr1 __P((ohci_softc_t *));",
      "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ohci_free_std",
          "args": [
            "sc",
            "opipe->tail.td"
          ],
          "line": 2634
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_free_std_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "577-589",
          "snippet": "Static void\nohci_free_std_chain(sc, std, stdend)\n\tohci_softc_t *sc;\n\tohci_soft_td_t *std;\n\tohci_soft_td_t *stdend;\n{\n\tohci_soft_td_t *p;\n\n\tfor (; std != stdend; std = p) {\n\t\tp = std->nexttd;\n\t\tohci_free_std(sc, std);\n\t}\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static void",
            "Static ohci_soft_td_t",
            "Static void",
            "ohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));",
            "Static void",
            "ohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "ohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));",
            "Static void",
            "ohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));",
            "Static ohci_soft_td_t",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "ohci_rhsc_able __P((ohci_softc_t *, int));",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
            "Static int",
            "ohci_intr1 __P((ohci_softc_t *));",
            "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nStatic ohci_soft_td_t;\nStatic void;\nohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));\nStatic void;\nohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));\nStatic void;\nohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));\nStatic ohci_soft_td_t;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nohci_rhsc_able __P((ohci_softc_t *, int));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nStatic int;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nStatic void\nohci_free_std_chain(sc, std, stdend)\n\tohci_softc_t *sc;\n\tohci_soft_td_t *std;\n\tohci_soft_td_t *stdend;\n{\n\tohci_soft_td_t *p;\n\n\tfor (; std != stdend; std = p) {\n\t\tp = std->nexttd;\n\t\tohci_free_std(sc, std);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ohci_close_pipe",
          "args": [
            "pipe",
            "sc->sc_ctrl_head"
          ],
          "line": 2633
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_close_pipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "1974-2010",
          "snippet": "void\nohci_close_pipe(pipe, head)\n\tusbd_pipe_handle pipe;\n\tohci_soft_ed_t *head;\n{\n\tstruct ohci_pipe *opipe = (struct ohci_pipe *)pipe;\n\tohci_softc_t *sc = (ohci_softc_t *)pipe->device->bus;\n\tohci_soft_ed_t *sed = opipe->sed;\n\tint s;\n\n\ts = splusb();\n#ifdef DIAGNOSTIC\n\tsed->ed.ed_flags |= htole32(OHCI_ED_SKIP);\n\tif ((le32toh(sed->ed.ed_tailp) & OHCI_HEADMASK) != \n\t    (le32toh(sed->ed.ed_headp) & OHCI_HEADMASK)) {\n\t\tohci_physaddr_t td = le32toh(sed->ed.ed_headp);\n\t\tohci_soft_td_t *std;\n\t\tfor (std = LIST_FIRST(&sc->sc_hash_tds[HASH(td)]); \n\t\t     std != NULL;\n\t\t     std = LIST_NEXT(std, hnext))\n\t\t    if (std->physaddr == td)\n\t\t\tbreak;\n\t\tprintf(\"ohci_close_pipe: pipe not empty sed=%p hd=0x%x \"\n\t\t       \"tl=0x%x pipe=%p, std=%p\\n\", sed,\n\t\t       (int)le32toh(sed->ed.ed_headp),\n\t\t       (int)le32toh(sed->ed.ed_tailp),\n\t\t       pipe, std);\n\t\tusb_delay_ms(&sc->sc_bus, 2);\n\t\tif ((le32toh(sed->ed.ed_tailp) & OHCI_HEADMASK) != \n\t\t    (le32toh(sed->ed.ed_headp) & OHCI_HEADMASK))\n\t\t\tprintf(\"ohci_close_pipe: pipe still not empty\\n\");\n\t}\n#endif\n\tohci_rem_ed(sed, head);\n\tsplx(s);\n\tohci_free_sed(sc, opipe->sed);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static ohci_soft_ed_t",
            "ohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));",
            "Static ohci_soft_td_t",
            "ohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));",
            "ohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));",
            "ohci_open __P((usbd_pipe_handle));",
            "ohci_add_done __P((ohci_softc_t *, ohci_physaddr_t));",
            "ohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
            "ohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
            "ohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));",
            "ohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));",
            "Static ohci_soft_td_t",
            "ohci_setup_isoc __P((usbd_pipe_handle pipe));",
            "ohci_root_ctrl_close __P((usbd_pipe_handle));",
            "ohci_root_intr_close __P((usbd_pipe_handle));",
            "ohci_device_ctrl_close __P((usbd_pipe_handle));",
            "ohci_device_bulk_close __P((usbd_pipe_handle));",
            "ohci_device_intr_close __P((usbd_pipe_handle));",
            "ohci_device_isoc_close __P((usbd_pipe_handle));",
            "ohci_rhsc_able __P((ohci_softc_t *, int));",
            "ohci_close_pipe __P((usbd_pipe_handle pipe, \n\t\t\t    ohci_soft_ed_t *head));",
            "ohci_device_clear_toggle __P((usbd_pipe_handle pipe));",
            "ohci_noop __P((usbd_pipe_handle pipe));",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
            "ohci_intr1 __P((ohci_softc_t *));",
            "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_ed_t;\nohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));\nStatic ohci_soft_td_t;\nohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));\nohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));\nohci_open __P((usbd_pipe_handle));\nohci_add_done __P((ohci_softc_t *, ohci_physaddr_t));\nohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));\nohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));\nStatic ohci_soft_td_t;\nohci_setup_isoc __P((usbd_pipe_handle pipe));\nohci_root_ctrl_close __P((usbd_pipe_handle));\nohci_root_intr_close __P((usbd_pipe_handle));\nohci_device_ctrl_close __P((usbd_pipe_handle));\nohci_device_bulk_close __P((usbd_pipe_handle));\nohci_device_intr_close __P((usbd_pipe_handle));\nohci_device_isoc_close __P((usbd_pipe_handle));\nohci_rhsc_able __P((ohci_softc_t *, int));\nohci_close_pipe __P((usbd_pipe_handle pipe, \n\t\t\t    ohci_soft_ed_t *head));\nohci_device_clear_toggle __P((usbd_pipe_handle pipe));\nohci_noop __P((usbd_pipe_handle pipe));\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nvoid\nohci_close_pipe(pipe, head)\n\tusbd_pipe_handle pipe;\n\tohci_soft_ed_t *head;\n{\n\tstruct ohci_pipe *opipe = (struct ohci_pipe *)pipe;\n\tohci_softc_t *sc = (ohci_softc_t *)pipe->device->bus;\n\tohci_soft_ed_t *sed = opipe->sed;\n\tint s;\n\n\ts = splusb();\n#ifdef DIAGNOSTIC\n\tsed->ed.ed_flags |= htole32(OHCI_ED_SKIP);\n\tif ((le32toh(sed->ed.ed_tailp) & OHCI_HEADMASK) != \n\t    (le32toh(sed->ed.ed_headp) & OHCI_HEADMASK)) {\n\t\tohci_physaddr_t td = le32toh(sed->ed.ed_headp);\n\t\tohci_soft_td_t *std;\n\t\tfor (std = LIST_FIRST(&sc->sc_hash_tds[HASH(td)]); \n\t\t     std != NULL;\n\t\t     std = LIST_NEXT(std, hnext))\n\t\t    if (std->physaddr == td)\n\t\t\tbreak;\n\t\tprintf(\"ohci_close_pipe: pipe not empty sed=%p hd=0x%x \"\n\t\t       \"tl=0x%x pipe=%p, std=%p\\n\", sed,\n\t\t       (int)le32toh(sed->ed.ed_headp),\n\t\t       (int)le32toh(sed->ed.ed_tailp),\n\t\t       pipe, std);\n\t\tusb_delay_ms(&sc->sc_bus, 2);\n\t\tif ((le32toh(sed->ed.ed_tailp) & OHCI_HEADMASK) != \n\t\t    (le32toh(sed->ed.ed_headp) & OHCI_HEADMASK))\n\t\t\tprintf(\"ohci_close_pipe: pipe still not empty\\n\");\n\t}\n#endif\n\tohci_rem_ed(sed, head);\n\tsplx(s);\n\tohci_free_sed(sc, opipe->sed);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ohci_device_ctrl_close: pipe=%p\\n\", pipe)"
          ],
          "line": 2632
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_open __P((usbd_pipe_handle));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_setup_isoc __P((usbd_pipe_handle pipe));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_root_ctrl_close __P((usbd_pipe_handle));\nStatic void;\nStatic void;\nStatic void;\nohci_root_intr_close __P((usbd_pipe_handle));\nStatic void;\nStatic void;\nStatic void;\nohci_device_ctrl_close __P((usbd_pipe_handle));\nStatic void;\nStatic void;\nStatic void;\nohci_device_bulk_close __P((usbd_pipe_handle));\nStatic void;\nStatic void;\nStatic void;\nohci_device_intr_close __P((usbd_pipe_handle));\nStatic void;\nStatic void;\nStatic void;\nohci_device_isoc_close __P((usbd_pipe_handle));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nohci_rhsc_able __P((ohci_softc_t *, int));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_device_clear_toggle __P((usbd_pipe_handle pipe));\nStatic void;\nohci_noop __P((usbd_pipe_handle pipe));\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nStatic int;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nStatic void\nohci_device_ctrl_close(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tstruct ohci_pipe *opipe = (struct ohci_pipe *)pipe;\n\tohci_softc_t *sc = (ohci_softc_t *)pipe->device->bus;\n\n\tDPRINTF((\"ohci_device_ctrl_close: pipe=%p\\n\", pipe));\n\tohci_close_pipe(pipe, sc->sc_ctrl_head);\n\tohci_free_std(sc, opipe->tail.td);\n}"
  },
  {
    "function_name": "ohci_device_ctrl_abort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "2616-2622",
    "snippet": "Static void\nohci_device_ctrl_abort(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tDPRINTF((\"ohci_device_ctrl_abort: xfer=%p\\n\", xfer));\n\tohci_abort_xfer(xfer, USBD_CANCELLED);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "ohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));",
      "ohci_device_request __P((usbd_xfer_handle xfer));",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "ohci_device_isoc_enter __P((usbd_xfer_handle));",
      "Static void",
      "Static usbd_xfer_handle",
      "Static void",
      "ohci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "ohci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "ohci_root_ctrl_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_root_ctrl_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_root_ctrl_done  __P((usbd_xfer_handle));",
      "ohci_root_intr_transfer __P((usbd_xfer_handle));",
      "ohci_root_intr_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_root_intr_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_root_intr_done  __P((usbd_xfer_handle));",
      "ohci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "ohci_device_ctrl_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_device_ctrl_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_device_ctrl_done  __P((usbd_xfer_handle));",
      "ohci_device_bulk_transfer __P((usbd_xfer_handle));",
      "ohci_device_bulk_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_device_bulk_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_device_bulk_done  __P((usbd_xfer_handle));",
      "ohci_device_intr_transfer __P((usbd_xfer_handle));",
      "ohci_device_intr_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_device_intr_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_device_intr_done  __P((usbd_xfer_handle));",
      "ohci_device_isoc_transfer __P((usbd_xfer_handle));",
      "ohci_device_isoc_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_device_isoc_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_device_isoc_done  __P((usbd_xfer_handle));",
      "Static int",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static int"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ohci_abort_xfer",
          "args": [
            "xfer",
            "USBD_CANCELLED"
          ],
          "line": 2621
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_abort_xfer_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "2059-2093",
          "snippet": "void\nohci_abort_xfer_end(v)\n\tvoid *v;\n{\n\tusbd_xfer_handle xfer = v;\n\tstruct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;\n\tohci_softc_t *sc = (ohci_softc_t *)opipe->pipe.device->bus;\n\tohci_soft_ed_t *sed;\n\tohci_soft_td_t *p, *n;\n\tint s;\n\n\ts = splusb();\n\n\tp = xfer->hcpriv;\n#ifdef DIAGNOSTIC\n\tif (p == NULL) {\n\t\tprintf(\"ohci_abort_xfer: hcpriv==0\\n\");\n\t\treturn;\n\t}\n#endif\n\tfor (; p->xfer == xfer; p = n) {\n\t\tn = p->nexttd;\n\t\tohci_free_std(sc, p);\n\t}\n\n\tsed = opipe->sed;\n\tDPRINTFN(2,(\"ohci_abort_xfer: set hd=%x, tl=%x\\n\",\n\t\t    (int)p->physaddr, (int)le32toh(sed->ed.ed_tailp)));\n\tsed->ed.ed_headp = htole32(p->physaddr); /* unlink TDs */\n\tsed->ed.ed_flags &= htole32(~OHCI_ED_SKIP); /* remove hardware skip */\n\n\tusb_transfer_complete(xfer);\n\n\tsplx(s);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static ohci_soft_ed_t",
            "ohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));",
            "Static ohci_soft_td_t",
            "ohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));",
            "ohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));",
            "ohci_shutdown __P((void *v));",
            "ohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));",
            "ohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));",
            "ohci_device_request __P((usbd_xfer_handle xfer));",
            "ohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
            "ohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
            "ohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));",
            "ohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));",
            "Static ohci_soft_td_t",
            "ohci_setup_isoc __P((usbd_pipe_handle pipe));",
            "ohci_device_isoc_enter __P((usbd_xfer_handle));",
            "Static usbd_xfer_handle",
            "ohci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
            "ohci_root_ctrl_transfer __P((usbd_xfer_handle));",
            "ohci_root_ctrl_start __P((usbd_xfer_handle));",
            "ohci_root_ctrl_abort __P((usbd_xfer_handle));",
            "ohci_root_ctrl_done  __P((usbd_xfer_handle));",
            "ohci_root_intr_transfer __P((usbd_xfer_handle));",
            "ohci_root_intr_start __P((usbd_xfer_handle));",
            "ohci_root_intr_abort __P((usbd_xfer_handle));",
            "ohci_root_intr_done  __P((usbd_xfer_handle));",
            "ohci_device_ctrl_transfer __P((usbd_xfer_handle));",
            "ohci_device_ctrl_start __P((usbd_xfer_handle));",
            "ohci_device_ctrl_abort __P((usbd_xfer_handle));",
            "ohci_device_ctrl_done  __P((usbd_xfer_handle));",
            "ohci_device_bulk_transfer __P((usbd_xfer_handle));",
            "ohci_device_bulk_start __P((usbd_xfer_handle));",
            "ohci_device_bulk_abort __P((usbd_xfer_handle));",
            "ohci_device_bulk_done  __P((usbd_xfer_handle));",
            "ohci_device_intr_transfer __P((usbd_xfer_handle));",
            "ohci_device_intr_start __P((usbd_xfer_handle));",
            "ohci_device_intr_abort __P((usbd_xfer_handle));",
            "ohci_device_intr_done  __P((usbd_xfer_handle));",
            "ohci_device_isoc_transfer __P((usbd_xfer_handle));",
            "ohci_device_isoc_start __P((usbd_xfer_handle));",
            "ohci_device_isoc_abort __P((usbd_xfer_handle));",
            "ohci_device_isoc_done  __P((usbd_xfer_handle));",
            "ohci_rhsc_able __P((ohci_softc_t *, int));",
            "ohci_device_clear_toggle __P((usbd_pipe_handle pipe));",
            "ohci_noop __P((usbd_pipe_handle pipe));",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
            "ohci_intr1 __P((ohci_softc_t *));",
            "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_ed_t;\nohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));\nStatic ohci_soft_td_t;\nohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));\nohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));\nohci_shutdown __P((void *v));\nohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));\nohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));\nohci_device_request __P((usbd_xfer_handle xfer));\nohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));\nohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));\nStatic ohci_soft_td_t;\nohci_setup_isoc __P((usbd_pipe_handle pipe));\nohci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_xfer_handle;\nohci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nohci_root_ctrl_transfer __P((usbd_xfer_handle));\nohci_root_ctrl_start __P((usbd_xfer_handle));\nohci_root_ctrl_abort __P((usbd_xfer_handle));\nohci_root_ctrl_done  __P((usbd_xfer_handle));\nohci_root_intr_transfer __P((usbd_xfer_handle));\nohci_root_intr_start __P((usbd_xfer_handle));\nohci_root_intr_abort __P((usbd_xfer_handle));\nohci_root_intr_done  __P((usbd_xfer_handle));\nohci_device_ctrl_transfer __P((usbd_xfer_handle));\nohci_device_ctrl_start __P((usbd_xfer_handle));\nohci_device_ctrl_abort __P((usbd_xfer_handle));\nohci_device_ctrl_done  __P((usbd_xfer_handle));\nohci_device_bulk_transfer __P((usbd_xfer_handle));\nohci_device_bulk_start __P((usbd_xfer_handle));\nohci_device_bulk_abort __P((usbd_xfer_handle));\nohci_device_bulk_done  __P((usbd_xfer_handle));\nohci_device_intr_transfer __P((usbd_xfer_handle));\nohci_device_intr_start __P((usbd_xfer_handle));\nohci_device_intr_abort __P((usbd_xfer_handle));\nohci_device_intr_done  __P((usbd_xfer_handle));\nohci_device_isoc_transfer __P((usbd_xfer_handle));\nohci_device_isoc_start __P((usbd_xfer_handle));\nohci_device_isoc_abort __P((usbd_xfer_handle));\nohci_device_isoc_done  __P((usbd_xfer_handle));\nohci_rhsc_able __P((ohci_softc_t *, int));\nohci_device_clear_toggle __P((usbd_pipe_handle pipe));\nohci_noop __P((usbd_pipe_handle pipe));\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nvoid\nohci_abort_xfer_end(v)\n\tvoid *v;\n{\n\tusbd_xfer_handle xfer = v;\n\tstruct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;\n\tohci_softc_t *sc = (ohci_softc_t *)opipe->pipe.device->bus;\n\tohci_soft_ed_t *sed;\n\tohci_soft_td_t *p, *n;\n\tint s;\n\n\ts = splusb();\n\n\tp = xfer->hcpriv;\n#ifdef DIAGNOSTIC\n\tif (p == NULL) {\n\t\tprintf(\"ohci_abort_xfer: hcpriv==0\\n\");\n\t\treturn;\n\t}\n#endif\n\tfor (; p->xfer == xfer; p = n) {\n\t\tn = p->nexttd;\n\t\tohci_free_std(sc, p);\n\t}\n\n\tsed = opipe->sed;\n\tDPRINTFN(2,(\"ohci_abort_xfer: set hd=%x, tl=%x\\n\",\n\t\t    (int)p->physaddr, (int)le32toh(sed->ed.ed_tailp)));\n\tsed->ed.ed_headp = htole32(p->physaddr); /* unlink TDs */\n\tsed->ed.ed_flags &= htole32(~OHCI_ED_SKIP); /* remove hardware skip */\n\n\tusb_transfer_complete(xfer);\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ohci_device_ctrl_abort: xfer=%p\\n\", xfer)"
          ],
          "line": 2620
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));\nohci_device_request __P((usbd_xfer_handle xfer));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_device_isoc_enter __P((usbd_xfer_handle));\nStatic void;\nStatic usbd_xfer_handle;\nStatic void;\nohci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nohci_root_ctrl_transfer __P((usbd_xfer_handle));\nohci_root_ctrl_start __P((usbd_xfer_handle));\nStatic void;\nohci_root_ctrl_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_root_ctrl_done  __P((usbd_xfer_handle));\nohci_root_intr_transfer __P((usbd_xfer_handle));\nohci_root_intr_start __P((usbd_xfer_handle));\nStatic void;\nohci_root_intr_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_root_intr_done  __P((usbd_xfer_handle));\nohci_device_ctrl_transfer __P((usbd_xfer_handle));\nohci_device_ctrl_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_ctrl_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_ctrl_done  __P((usbd_xfer_handle));\nohci_device_bulk_transfer __P((usbd_xfer_handle));\nohci_device_bulk_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_bulk_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_bulk_done  __P((usbd_xfer_handle));\nohci_device_intr_transfer __P((usbd_xfer_handle));\nohci_device_intr_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_intr_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_intr_done  __P((usbd_xfer_handle));\nohci_device_isoc_transfer __P((usbd_xfer_handle));\nohci_device_isoc_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_isoc_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_isoc_done  __P((usbd_xfer_handle));\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\n\nStatic void\nohci_device_ctrl_abort(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tDPRINTF((\"ohci_device_ctrl_abort: xfer=%p\\n\", xfer));\n\tohci_abort_xfer(xfer, USBD_CANCELLED);\n}"
  },
  {
    "function_name": "ohci_device_ctrl_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "2588-2613",
    "snippet": "Static usbd_status\nohci_device_ctrl_start(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tohci_softc_t *sc = (ohci_softc_t *)xfer->pipe->device->bus;\n\tusbd_status err;\n\n\tif (sc->sc_dying)\n\t\treturn (USBD_IOERROR);\n\n#ifdef DIAGNOSTIC\n\tif (!(xfer->rqflags & URQ_REQUEST)) {\n\t\t/* XXX panic */\n\t\tprintf(\"ohci_device_ctrl_transfer: not a request\\n\");\n\t\treturn (USBD_INVAL);\n\t}\n#endif\n\n\terr = ohci_device_request(xfer);\n\tif (err)\n\t\treturn (err);\n\n\tif (sc->sc_bus.use_polling)\n\t\tohci_waitintr(sc, xfer);\n\treturn (USBD_IN_PROGRESS);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static void",
      "Static void",
      "Static void",
      "Static usbd_status",
      "Static void",
      "Static void",
      "Static usbd_status",
      "Static void",
      "Static void",
      "Static void",
      "ohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_request __P((usbd_xfer_handle xfer));",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static usbd_status",
      "ohci_setup_isoc __P((usbd_pipe_handle pipe));",
      "Static void",
      "ohci_device_isoc_enter __P((usbd_xfer_handle));",
      "Static usbd_status",
      "Static void",
      "Static usbd_xfer_handle",
      "Static void",
      "ohci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_root_ctrl_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_root_ctrl_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_root_ctrl_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_root_intr_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_root_intr_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_root_intr_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_root_intr_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_ctrl_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_device_ctrl_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_device_ctrl_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_bulk_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_bulk_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_device_bulk_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_device_bulk_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_intr_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_intr_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_device_intr_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_device_intr_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_isoc_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_isoc_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_device_isoc_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_device_isoc_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "Static int",
      "Static void",
      "Static void",
      "ohci_rhsc_able __P((ohci_softc_t *, int));",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "ohci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "Static void",
      "ohci_noop __P((usbd_pipe_handle pipe));",
      "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
      "Static int",
      "ohci_intr1 __P((ohci_softc_t *));",
      "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
      "ohci_physaddr_t a;",
      "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;",
      "ohci_physaddr_t a;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ohci_waitintr",
          "args": [
            "sc",
            "xfer"
          ],
          "line": 2611
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_waitintr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "1467-1497",
          "snippet": "void\nohci_waitintr(sc, xfer)\n\tohci_softc_t *sc;\n\tusbd_xfer_handle xfer;\n{\n\tint timo = xfer->timeout;\n\tint usecs;\n\tu_int32_t intrs;\n\n\txfer->status = USBD_IN_PROGRESS;\n\tfor (usecs = timo * 1000000 / hz; usecs > 0; usecs -= 1000) {\n\t\tusb_delay_ms(&sc->sc_bus, 1);\n\t\tintrs = OREAD4(sc, OHCI_INTERRUPT_STATUS) & sc->sc_eintrs;\n\t\tDPRINTFN(15,(\"ohci_waitintr: 0x%04x\\n\", intrs));\n#ifdef OHCI_DEBUG\n\t\tif (ohcidebug > 15)\n\t\t\tohci_dumpregs(sc);\n#endif\n\t\tif (intrs) {\n\t\t\tohci_intr1(sc);\n\t\t\tif (xfer->status != USBD_IN_PROGRESS)\n\t\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Timeout */\n\tDPRINTF((\"ohci_waitintr: timeout\\n\"));\n\txfer->status = USBD_TIMEOUT;\n\tusb_transfer_complete(xfer);\n\t/* XXX should free TD */\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "ohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));",
            "ohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));",
            "ohci_device_request __P((usbd_xfer_handle xfer));",
            "ohci_device_isoc_enter __P((usbd_xfer_handle));",
            "ohci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));",
            "Static usbd_xfer_handle",
            "ohci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
            "ohci_root_ctrl_transfer __P((usbd_xfer_handle));",
            "ohci_root_ctrl_start __P((usbd_xfer_handle));",
            "ohci_root_ctrl_abort __P((usbd_xfer_handle));",
            "ohci_root_ctrl_done  __P((usbd_xfer_handle));",
            "ohci_root_intr_transfer __P((usbd_xfer_handle));",
            "ohci_root_intr_start __P((usbd_xfer_handle));",
            "ohci_root_intr_abort __P((usbd_xfer_handle));",
            "ohci_root_intr_done  __P((usbd_xfer_handle));",
            "ohci_device_ctrl_transfer __P((usbd_xfer_handle));",
            "ohci_device_ctrl_start __P((usbd_xfer_handle));",
            "ohci_device_ctrl_abort __P((usbd_xfer_handle));",
            "ohci_device_ctrl_done  __P((usbd_xfer_handle));",
            "ohci_device_bulk_transfer __P((usbd_xfer_handle));",
            "ohci_device_bulk_start __P((usbd_xfer_handle));",
            "ohci_device_bulk_abort __P((usbd_xfer_handle));",
            "ohci_device_bulk_done  __P((usbd_xfer_handle));",
            "ohci_device_intr_transfer __P((usbd_xfer_handle));",
            "ohci_device_intr_start __P((usbd_xfer_handle));",
            "ohci_device_intr_abort __P((usbd_xfer_handle));",
            "ohci_device_intr_done  __P((usbd_xfer_handle));",
            "ohci_device_isoc_transfer __P((usbd_xfer_handle));",
            "ohci_device_isoc_start __P((usbd_xfer_handle));",
            "ohci_device_isoc_abort __P((usbd_xfer_handle));",
            "ohci_device_isoc_done  __P((usbd_xfer_handle));",
            "ohci_rhsc_able __P((ohci_softc_t *, int));",
            "ohci_abort_xfer __P((usbd_xfer_handle xfer,\n\t\t\t    usbd_status status));",
            "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
            "ohci_intr1 __P((ohci_softc_t *));",
            "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));\nohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));\nohci_device_request __P((usbd_xfer_handle xfer));\nohci_device_isoc_enter __P((usbd_xfer_handle));\nohci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));\nStatic usbd_xfer_handle;\nohci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nohci_root_ctrl_transfer __P((usbd_xfer_handle));\nohci_root_ctrl_start __P((usbd_xfer_handle));\nohci_root_ctrl_abort __P((usbd_xfer_handle));\nohci_root_ctrl_done  __P((usbd_xfer_handle));\nohci_root_intr_transfer __P((usbd_xfer_handle));\nohci_root_intr_start __P((usbd_xfer_handle));\nohci_root_intr_abort __P((usbd_xfer_handle));\nohci_root_intr_done  __P((usbd_xfer_handle));\nohci_device_ctrl_transfer __P((usbd_xfer_handle));\nohci_device_ctrl_start __P((usbd_xfer_handle));\nohci_device_ctrl_abort __P((usbd_xfer_handle));\nohci_device_ctrl_done  __P((usbd_xfer_handle));\nohci_device_bulk_transfer __P((usbd_xfer_handle));\nohci_device_bulk_start __P((usbd_xfer_handle));\nohci_device_bulk_abort __P((usbd_xfer_handle));\nohci_device_bulk_done  __P((usbd_xfer_handle));\nohci_device_intr_transfer __P((usbd_xfer_handle));\nohci_device_intr_start __P((usbd_xfer_handle));\nohci_device_intr_abort __P((usbd_xfer_handle));\nohci_device_intr_done  __P((usbd_xfer_handle));\nohci_device_isoc_transfer __P((usbd_xfer_handle));\nohci_device_isoc_start __P((usbd_xfer_handle));\nohci_device_isoc_abort __P((usbd_xfer_handle));\nohci_device_isoc_done  __P((usbd_xfer_handle));\nohci_rhsc_able __P((ohci_softc_t *, int));\nohci_abort_xfer __P((usbd_xfer_handle xfer,\n\t\t\t    usbd_status status));\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nvoid\nohci_waitintr(sc, xfer)\n\tohci_softc_t *sc;\n\tusbd_xfer_handle xfer;\n{\n\tint timo = xfer->timeout;\n\tint usecs;\n\tu_int32_t intrs;\n\n\txfer->status = USBD_IN_PROGRESS;\n\tfor (usecs = timo * 1000000 / hz; usecs > 0; usecs -= 1000) {\n\t\tusb_delay_ms(&sc->sc_bus, 1);\n\t\tintrs = OREAD4(sc, OHCI_INTERRUPT_STATUS) & sc->sc_eintrs;\n\t\tDPRINTFN(15,(\"ohci_waitintr: 0x%04x\\n\", intrs));\n#ifdef OHCI_DEBUG\n\t\tif (ohcidebug > 15)\n\t\t\tohci_dumpregs(sc);\n#endif\n\t\tif (intrs) {\n\t\t\tohci_intr1(sc);\n\t\t\tif (xfer->status != USBD_IN_PROGRESS)\n\t\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Timeout */\n\tDPRINTF((\"ohci_waitintr: timeout\\n\"));\n\txfer->status = USBD_TIMEOUT;\n\tusb_transfer_complete(xfer);\n\t/* XXX should free TD */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ohci_device_request",
          "args": [
            "xfer"
          ],
          "line": 2606
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_device_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "1509-1635",
          "snippet": "usbd_status\nohci_device_request(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tstruct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;\n\tusb_device_request_t *req = &xfer->request;\n\tusbd_device_handle dev = opipe->pipe.device;\n\tohci_softc_t *sc = (ohci_softc_t *)dev->bus;\n\tint addr = dev->address;\n\tohci_soft_td_t *setup, *stat, *next, *tail;\n\tohci_soft_ed_t *sed;\n\tint isread;\n\tint len;\n\tusbd_status err;\n\tint s;\n\n\tisread = req->bmRequestType & UT_READ;\n\tlen = UGETW(req->wLength);\n\n\tDPRINTFN(3,(\"ohci_device_control type=0x%02x, request=0x%02x, \"\n\t\t    \"wValue=0x%04x, wIndex=0x%04x len=%d, addr=%d, endpt=%d\\n\",\n\t\t    req->bmRequestType, req->bRequest, UGETW(req->wValue),\n\t\t    UGETW(req->wIndex), len, addr, \n\t\t    opipe->pipe.endpoint->edesc->bEndpointAddress));\n\n\tsetup = opipe->tail.td;\n\tstat = ohci_alloc_std(sc);\n\tif (stat == NULL) {\n\t\terr = USBD_NOMEM;\n\t\tgoto bad1;\n\t}\n\ttail = ohci_alloc_std(sc);\n\tif (tail == NULL) {\n\t\terr = USBD_NOMEM;\n\t\tgoto bad2;\n\t}\n\ttail->xfer = NULL;\n\n\tsed = opipe->sed;\n\topipe->u.ctl.length = len;\n\n\t/* Update device address and length since they may have changed. */\n\t/* XXX This only needs to be done once, but it's too early in open. */\n\t/* XXXX Should not touch ED here! */\n\tsed->ed.ed_flags = htole32(\n\t (le32toh(sed->ed.ed_flags) & ~(OHCI_ED_ADDRMASK | OHCI_ED_MAXPMASK)) |\n\t OHCI_ED_SET_FA(addr) |\n\t OHCI_ED_SET_MAXP(UGETW(opipe->pipe.endpoint->edesc->wMaxPacketSize)));\n\n\tnext = stat;\n\n\t/* Set up data transaction */\n\tif (len != 0) {\n\t\tohci_soft_td_t *std = stat;\n\n\t\terr = ohci_alloc_std_chain(opipe, sc, len, isread, xfer,\n\t\t\t  std, &stat);\n\t\tstat = stat->nexttd; /* point at free TD */\n\t\tif (err)\n\t\t\tgoto bad3;\n\t\t/* Start toggle at 1 and then use the carried toggle. */\n\t\tstd->td.td_flags &= htole32(~OHCI_TD_TOGGLE_MASK);\n\t\tstd->td.td_flags |= htole32(OHCI_TD_TOGGLE_1);\n\t}\n\n\tmemcpy(KERNADDR(&opipe->u.ctl.reqdma), req, sizeof *req);\n\n\tsetup->td.td_flags = htole32(OHCI_TD_SETUP | OHCI_TD_NOCC |\n\t\t\t\t     OHCI_TD_TOGGLE_0 | OHCI_TD_NOINTR);\n\tsetup->td.td_cbp = htole32(DMAADDR(&opipe->u.ctl.reqdma));\n\tsetup->nexttd = next;\n\tsetup->td.td_nexttd = htole32(next->physaddr);\n\tsetup->td.td_be = htole32(le32toh(setup->td.td_cbp) + sizeof *req - 1);\n\tsetup->len = 0;\n\tsetup->xfer = xfer;\n\tsetup->flags = 0;\n\txfer->hcpriv = setup;\n\n\tstat->td.td_flags = htole32(\n\t\t(isread ? OHCI_TD_OUT : OHCI_TD_IN) |\n\t\tOHCI_TD_NOCC | OHCI_TD_TOGGLE_1 | OHCI_TD_SET_DI(1));\n\tstat->td.td_cbp = 0;\n\tstat->nexttd = tail;\n\tstat->td.td_nexttd = htole32(tail->physaddr);\n\tstat->td.td_be = 0;\n\tstat->flags = OHCI_CALL_DONE;\n\tstat->len = 0;\n\tstat->xfer = xfer;\n\n#ifdef OHCI_DEBUG\n\tif (ohcidebug > 5) {\n\t\tDPRINTF((\"ohci_device_request:\\n\"));\n\t\tohci_dump_ed(sed);\n\t\tohci_dump_tds(setup);\n\t}\n#endif\n\n\t/* Insert ED in schedule */\n\ts = splusb();\n\tsed->ed.ed_tailp = htole32(tail->physaddr);\n\topipe->tail.td = tail;\n\tOWRITE4(sc, OHCI_COMMAND_STATUS, OHCI_CLF);\n\tif (xfer->timeout && !sc->sc_bus.use_polling) {\n                usb_callout(xfer->timeout_handle, MS_TO_TICKS(xfer->timeout),\n\t\t\t    ohci_timeout, xfer);\n\t}\n\tsplx(s);\n\n#if 0\n\tif (ohcidebug > 10) {\n\t\tdelay(10000);\n\t\tDPRINTF((\"ohci_device_request: status=%x\\n\",\n\t\t\t OREAD4(sc, OHCI_COMMAND_STATUS)));\n\t\tohci_dump_ed(sed);\n\t\tohci_dump_tds(setup);\n\t}\n#endif\n\n\treturn (USBD_NORMAL_COMPLETION);\n\n bad3:\n\tohci_free_std(sc, tail);\n bad2:\n\tohci_free_std(sc, stat);\n bad1:\n\treturn (err);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static ohci_soft_ed_t",
            "ohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));",
            "Static ohci_soft_td_t",
            "ohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));",
            "Static usbd_status",
            "ohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));",
            "Static usbd_status",
            "ohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));",
            "ohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_request __P((usbd_xfer_handle xfer));",
            "ohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
            "ohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
            "ohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));",
            "ohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));",
            "Static ohci_soft_td_t",
            "Static usbd_status",
            "ohci_setup_isoc __P((usbd_pipe_handle pipe));",
            "ohci_device_isoc_enter __P((usbd_xfer_handle));",
            "Static usbd_status",
            "Static usbd_xfer_handle",
            "ohci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_root_ctrl_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_root_ctrl_start __P((usbd_xfer_handle));",
            "ohci_root_ctrl_abort __P((usbd_xfer_handle));",
            "ohci_root_ctrl_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_root_intr_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_root_intr_start __P((usbd_xfer_handle));",
            "ohci_root_intr_abort __P((usbd_xfer_handle));",
            "ohci_root_intr_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_ctrl_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_ctrl_start __P((usbd_xfer_handle));",
            "ohci_device_ctrl_abort __P((usbd_xfer_handle));",
            "ohci_device_ctrl_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_bulk_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_bulk_start __P((usbd_xfer_handle));",
            "ohci_device_bulk_abort __P((usbd_xfer_handle));",
            "ohci_device_bulk_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_intr_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_intr_start __P((usbd_xfer_handle));",
            "ohci_device_intr_abort __P((usbd_xfer_handle));",
            "ohci_device_intr_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_isoc_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_isoc_start __P((usbd_xfer_handle));",
            "ohci_device_isoc_abort __P((usbd_xfer_handle));",
            "ohci_device_isoc_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_rhsc_able __P((ohci_softc_t *, int));",
            "ohci_abort_xfer __P((usbd_xfer_handle xfer,\n\t\t\t    usbd_status status));",
            "ohci_device_clear_toggle __P((usbd_pipe_handle pipe));",
            "ohci_noop __P((usbd_pipe_handle pipe));",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
            "ohci_intr1 __P((ohci_softc_t *));",
            "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_ed_t;\nohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));\nStatic ohci_soft_td_t;\nohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));\nStatic usbd_status;\nohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));\nStatic usbd_status;\nohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));\nohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));\nStatic usbd_status;\nohci_device_request __P((usbd_xfer_handle xfer));\nohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));\nohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));\nStatic ohci_soft_td_t;\nStatic usbd_status;\nohci_setup_isoc __P((usbd_pipe_handle pipe));\nohci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic usbd_xfer_handle;\nohci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nStatic usbd_status;\nohci_root_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_ctrl_start __P((usbd_xfer_handle));\nohci_root_ctrl_abort __P((usbd_xfer_handle));\nohci_root_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_intr_start __P((usbd_xfer_handle));\nohci_root_intr_abort __P((usbd_xfer_handle));\nohci_root_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_ctrl_start __P((usbd_xfer_handle));\nohci_device_ctrl_abort __P((usbd_xfer_handle));\nohci_device_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_bulk_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_bulk_start __P((usbd_xfer_handle));\nohci_device_bulk_abort __P((usbd_xfer_handle));\nohci_device_bulk_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_intr_start __P((usbd_xfer_handle));\nohci_device_intr_abort __P((usbd_xfer_handle));\nohci_device_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_isoc_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_isoc_start __P((usbd_xfer_handle));\nohci_device_isoc_abort __P((usbd_xfer_handle));\nohci_device_isoc_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_rhsc_able __P((ohci_softc_t *, int));\nohci_abort_xfer __P((usbd_xfer_handle xfer,\n\t\t\t    usbd_status status));\nohci_device_clear_toggle __P((usbd_pipe_handle pipe));\nohci_noop __P((usbd_pipe_handle pipe));\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nusbd_status\nohci_device_request(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tstruct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;\n\tusb_device_request_t *req = &xfer->request;\n\tusbd_device_handle dev = opipe->pipe.device;\n\tohci_softc_t *sc = (ohci_softc_t *)dev->bus;\n\tint addr = dev->address;\n\tohci_soft_td_t *setup, *stat, *next, *tail;\n\tohci_soft_ed_t *sed;\n\tint isread;\n\tint len;\n\tusbd_status err;\n\tint s;\n\n\tisread = req->bmRequestType & UT_READ;\n\tlen = UGETW(req->wLength);\n\n\tDPRINTFN(3,(\"ohci_device_control type=0x%02x, request=0x%02x, \"\n\t\t    \"wValue=0x%04x, wIndex=0x%04x len=%d, addr=%d, endpt=%d\\n\",\n\t\t    req->bmRequestType, req->bRequest, UGETW(req->wValue),\n\t\t    UGETW(req->wIndex), len, addr, \n\t\t    opipe->pipe.endpoint->edesc->bEndpointAddress));\n\n\tsetup = opipe->tail.td;\n\tstat = ohci_alloc_std(sc);\n\tif (stat == NULL) {\n\t\terr = USBD_NOMEM;\n\t\tgoto bad1;\n\t}\n\ttail = ohci_alloc_std(sc);\n\tif (tail == NULL) {\n\t\terr = USBD_NOMEM;\n\t\tgoto bad2;\n\t}\n\ttail->xfer = NULL;\n\n\tsed = opipe->sed;\n\topipe->u.ctl.length = len;\n\n\t/* Update device address and length since they may have changed. */\n\t/* XXX This only needs to be done once, but it's too early in open. */\n\t/* XXXX Should not touch ED here! */\n\tsed->ed.ed_flags = htole32(\n\t (le32toh(sed->ed.ed_flags) & ~(OHCI_ED_ADDRMASK | OHCI_ED_MAXPMASK)) |\n\t OHCI_ED_SET_FA(addr) |\n\t OHCI_ED_SET_MAXP(UGETW(opipe->pipe.endpoint->edesc->wMaxPacketSize)));\n\n\tnext = stat;\n\n\t/* Set up data transaction */\n\tif (len != 0) {\n\t\tohci_soft_td_t *std = stat;\n\n\t\terr = ohci_alloc_std_chain(opipe, sc, len, isread, xfer,\n\t\t\t  std, &stat);\n\t\tstat = stat->nexttd; /* point at free TD */\n\t\tif (err)\n\t\t\tgoto bad3;\n\t\t/* Start toggle at 1 and then use the carried toggle. */\n\t\tstd->td.td_flags &= htole32(~OHCI_TD_TOGGLE_MASK);\n\t\tstd->td.td_flags |= htole32(OHCI_TD_TOGGLE_1);\n\t}\n\n\tmemcpy(KERNADDR(&opipe->u.ctl.reqdma), req, sizeof *req);\n\n\tsetup->td.td_flags = htole32(OHCI_TD_SETUP | OHCI_TD_NOCC |\n\t\t\t\t     OHCI_TD_TOGGLE_0 | OHCI_TD_NOINTR);\n\tsetup->td.td_cbp = htole32(DMAADDR(&opipe->u.ctl.reqdma));\n\tsetup->nexttd = next;\n\tsetup->td.td_nexttd = htole32(next->physaddr);\n\tsetup->td.td_be = htole32(le32toh(setup->td.td_cbp) + sizeof *req - 1);\n\tsetup->len = 0;\n\tsetup->xfer = xfer;\n\tsetup->flags = 0;\n\txfer->hcpriv = setup;\n\n\tstat->td.td_flags = htole32(\n\t\t(isread ? OHCI_TD_OUT : OHCI_TD_IN) |\n\t\tOHCI_TD_NOCC | OHCI_TD_TOGGLE_1 | OHCI_TD_SET_DI(1));\n\tstat->td.td_cbp = 0;\n\tstat->nexttd = tail;\n\tstat->td.td_nexttd = htole32(tail->physaddr);\n\tstat->td.td_be = 0;\n\tstat->flags = OHCI_CALL_DONE;\n\tstat->len = 0;\n\tstat->xfer = xfer;\n\n#ifdef OHCI_DEBUG\n\tif (ohcidebug > 5) {\n\t\tDPRINTF((\"ohci_device_request:\\n\"));\n\t\tohci_dump_ed(sed);\n\t\tohci_dump_tds(setup);\n\t}\n#endif\n\n\t/* Insert ED in schedule */\n\ts = splusb();\n\tsed->ed.ed_tailp = htole32(tail->physaddr);\n\topipe->tail.td = tail;\n\tOWRITE4(sc, OHCI_COMMAND_STATUS, OHCI_CLF);\n\tif (xfer->timeout && !sc->sc_bus.use_polling) {\n                usb_callout(xfer->timeout_handle, MS_TO_TICKS(xfer->timeout),\n\t\t\t    ohci_timeout, xfer);\n\t}\n\tsplx(s);\n\n#if 0\n\tif (ohcidebug > 10) {\n\t\tdelay(10000);\n\t\tDPRINTF((\"ohci_device_request: status=%x\\n\",\n\t\t\t OREAD4(sc, OHCI_COMMAND_STATUS)));\n\t\tohci_dump_ed(sed);\n\t\tohci_dump_tds(setup);\n\t}\n#endif\n\n\treturn (USBD_NORMAL_COMPLETION);\n\n bad3:\n\tohci_free_std(sc, tail);\n bad2:\n\tohci_free_std(sc, stat);\n bad1:\n\treturn (err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ohci_device_ctrl_transfer: not a request\\n\""
          ],
          "line": 2601
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nStatic void;\nStatic void;\nStatic usbd_status;\nStatic void;\nStatic void;\nStatic usbd_status;\nStatic void;\nStatic void;\nStatic void;\nohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));\nStatic usbd_status;\nohci_device_request __P((usbd_xfer_handle xfer));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic usbd_status;\nohci_setup_isoc __P((usbd_pipe_handle pipe));\nStatic void;\nohci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic void;\nStatic usbd_xfer_handle;\nStatic void;\nohci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nStatic usbd_status;\nohci_root_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_ctrl_start __P((usbd_xfer_handle));\nStatic void;\nohci_root_ctrl_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_root_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_intr_start __P((usbd_xfer_handle));\nStatic void;\nohci_root_intr_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_root_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_ctrl_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_ctrl_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_bulk_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_bulk_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_bulk_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_bulk_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_intr_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_intr_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_isoc_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_isoc_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_isoc_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_isoc_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic int;\nStatic void;\nStatic void;\nohci_rhsc_able __P((ohci_softc_t *, int));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_device_clear_toggle __P((usbd_pipe_handle pipe));\nStatic void;\nohci_noop __P((usbd_pipe_handle pipe));\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nStatic int;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_physaddr_t a;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\nohci_physaddr_t a;\n\nStatic usbd_status\nohci_device_ctrl_start(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tohci_softc_t *sc = (ohci_softc_t *)xfer->pipe->device->bus;\n\tusbd_status err;\n\n\tif (sc->sc_dying)\n\t\treturn (USBD_IOERROR);\n\n#ifdef DIAGNOSTIC\n\tif (!(xfer->rqflags & URQ_REQUEST)) {\n\t\t/* XXX panic */\n\t\tprintf(\"ohci_device_ctrl_transfer: not a request\\n\");\n\t\treturn (USBD_INVAL);\n\t}\n#endif\n\n\terr = ohci_device_request(xfer);\n\tif (err)\n\t\treturn (err);\n\n\tif (sc->sc_bus.use_polling)\n\t\tohci_waitintr(sc, xfer);\n\treturn (USBD_IN_PROGRESS);\n}"
  },
  {
    "function_name": "ohci_device_ctrl_transfer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "2573-2586",
    "snippet": "Static usbd_status\nohci_device_ctrl_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_status err;\n\n\t/* Insert last in queue. */\n\terr = usb_insert_transfer(xfer);\n\tif (err)\n\t\treturn (err);\n\n\t/* Pipe isn't running, start first */\n\treturn (ohci_device_ctrl_start(SIMPLEQ_FIRST(&xfer->pipe->queue)));\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static void",
      "Static void",
      "Static void",
      "Static usbd_status",
      "Static void",
      "Static void",
      "Static usbd_status",
      "Static void",
      "Static void",
      "Static void",
      "ohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_request __P((usbd_xfer_handle xfer));",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static usbd_status",
      "ohci_setup_isoc __P((usbd_pipe_handle pipe));",
      "Static void",
      "ohci_device_isoc_enter __P((usbd_xfer_handle));",
      "Static usbd_status",
      "Static void",
      "Static usbd_xfer_handle",
      "Static void",
      "ohci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_root_ctrl_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_root_ctrl_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_root_ctrl_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_root_intr_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_root_intr_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_root_intr_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_root_intr_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_ctrl_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_device_ctrl_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_device_ctrl_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_bulk_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_bulk_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_device_bulk_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_device_bulk_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_intr_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_intr_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_device_intr_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_device_intr_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_isoc_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_isoc_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_device_isoc_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_device_isoc_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "Static int",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "ohci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "Static void",
      "ohci_noop __P((usbd_pipe_handle pipe));",
      "Static int"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ohci_device_ctrl_start",
          "args": [
            "SIMPLEQ_FIRST(&xfer->pipe->queue)"
          ],
          "line": 2585
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_device_ctrl_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "2588-2613",
          "snippet": "Static usbd_status\nohci_device_ctrl_start(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tohci_softc_t *sc = (ohci_softc_t *)xfer->pipe->device->bus;\n\tusbd_status err;\n\n\tif (sc->sc_dying)\n\t\treturn (USBD_IOERROR);\n\n#ifdef DIAGNOSTIC\n\tif (!(xfer->rqflags & URQ_REQUEST)) {\n\t\t/* XXX panic */\n\t\tprintf(\"ohci_device_ctrl_transfer: not a request\\n\");\n\t\treturn (USBD_INVAL);\n\t}\n#endif\n\n\terr = ohci_device_request(xfer);\n\tif (err)\n\t\treturn (err);\n\n\tif (sc->sc_bus.use_polling)\n\t\tohci_waitintr(sc, xfer);\n\treturn (USBD_IN_PROGRESS);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static void",
            "Static void",
            "Static void",
            "Static usbd_status",
            "Static void",
            "Static void",
            "Static usbd_status",
            "Static void",
            "Static void",
            "Static void",
            "ohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));",
            "Static void",
            "Static void",
            "ohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_request __P((usbd_xfer_handle xfer));",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static usbd_status",
            "ohci_setup_isoc __P((usbd_pipe_handle pipe));",
            "Static void",
            "ohci_device_isoc_enter __P((usbd_xfer_handle));",
            "Static usbd_status",
            "Static void",
            "Static usbd_xfer_handle",
            "Static void",
            "ohci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_root_ctrl_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_root_ctrl_start __P((usbd_xfer_handle));",
            "Static void",
            "ohci_root_ctrl_abort __P((usbd_xfer_handle));",
            "Static void",
            "Static void",
            "ohci_root_ctrl_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_root_intr_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_root_intr_start __P((usbd_xfer_handle));",
            "Static void",
            "ohci_root_intr_abort __P((usbd_xfer_handle));",
            "Static void",
            "Static void",
            "ohci_root_intr_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_ctrl_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_ctrl_start __P((usbd_xfer_handle));",
            "Static void",
            "ohci_device_ctrl_abort __P((usbd_xfer_handle));",
            "Static void",
            "Static void",
            "ohci_device_ctrl_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_bulk_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_bulk_start __P((usbd_xfer_handle));",
            "Static void",
            "ohci_device_bulk_abort __P((usbd_xfer_handle));",
            "Static void",
            "Static void",
            "ohci_device_bulk_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_intr_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_intr_start __P((usbd_xfer_handle));",
            "Static void",
            "ohci_device_intr_abort __P((usbd_xfer_handle));",
            "Static void",
            "Static void",
            "ohci_device_intr_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_isoc_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_isoc_start __P((usbd_xfer_handle));",
            "Static void",
            "ohci_device_isoc_abort __P((usbd_xfer_handle));",
            "Static void",
            "Static void",
            "ohci_device_isoc_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "Static int",
            "Static void",
            "Static void",
            "ohci_rhsc_able __P((ohci_softc_t *, int));",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "ohci_device_clear_toggle __P((usbd_pipe_handle pipe));",
            "Static void",
            "ohci_noop __P((usbd_pipe_handle pipe));",
            "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
            "Static int",
            "ohci_intr1 __P((ohci_softc_t *));",
            "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
            "ohci_physaddr_t a;",
            "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;",
            "ohci_physaddr_t a;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nStatic void;\nStatic void;\nStatic usbd_status;\nStatic void;\nStatic void;\nStatic usbd_status;\nStatic void;\nStatic void;\nStatic void;\nohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));\nStatic usbd_status;\nohci_device_request __P((usbd_xfer_handle xfer));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic usbd_status;\nohci_setup_isoc __P((usbd_pipe_handle pipe));\nStatic void;\nohci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic void;\nStatic usbd_xfer_handle;\nStatic void;\nohci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nStatic usbd_status;\nohci_root_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_ctrl_start __P((usbd_xfer_handle));\nStatic void;\nohci_root_ctrl_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_root_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_intr_start __P((usbd_xfer_handle));\nStatic void;\nohci_root_intr_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_root_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_ctrl_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_ctrl_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_bulk_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_bulk_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_bulk_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_bulk_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_intr_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_intr_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_isoc_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_isoc_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_isoc_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_isoc_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic int;\nStatic void;\nStatic void;\nohci_rhsc_able __P((ohci_softc_t *, int));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_device_clear_toggle __P((usbd_pipe_handle pipe));\nStatic void;\nohci_noop __P((usbd_pipe_handle pipe));\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nStatic int;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_physaddr_t a;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\nohci_physaddr_t a;\n\nStatic usbd_status\nohci_device_ctrl_start(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tohci_softc_t *sc = (ohci_softc_t *)xfer->pipe->device->bus;\n\tusbd_status err;\n\n\tif (sc->sc_dying)\n\t\treturn (USBD_IOERROR);\n\n#ifdef DIAGNOSTIC\n\tif (!(xfer->rqflags & URQ_REQUEST)) {\n\t\t/* XXX panic */\n\t\tprintf(\"ohci_device_ctrl_transfer: not a request\\n\");\n\t\treturn (USBD_INVAL);\n\t}\n#endif\n\n\terr = ohci_device_request(xfer);\n\tif (err)\n\t\treturn (err);\n\n\tif (sc->sc_bus.use_polling)\n\t\tohci_waitintr(sc, xfer);\n\treturn (USBD_IN_PROGRESS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_FIRST",
          "args": [
            "&xfer->pipe->queue"
          ],
          "line": 2585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_insert_transfer",
          "args": [
            "xfer"
          ],
          "line": 2580
        },
        "resolved": true,
        "details": {
          "function_name": "usb_insert_transfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "885-905",
          "snippet": "usbd_status\nusb_insert_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusbd_status err;\n\tint s;\n\n\tDPRINTFN(5,(\"usb_insert_transfer: pipe=%p running=%d timeout=%d\\n\", \n\t\t    pipe, pipe->running, xfer->timeout));\n\ts = splusb();\n\tSIMPLEQ_INSERT_TAIL(&pipe->queue, xfer, next);\n\tif (pipe->running)\n\t\terr = USBD_IN_PROGRESS;\n\telse {\n\t\tpipe->running = 1;\n\t\terr = USBD_NORMAL_COMPLETION;\n\t}\n\tsplx(s);\n\treturn (err);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nusbd_status\nusb_insert_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusbd_status err;\n\tint s;\n\n\tDPRINTFN(5,(\"usb_insert_transfer: pipe=%p running=%d timeout=%d\\n\", \n\t\t    pipe, pipe->running, xfer->timeout));\n\ts = splusb();\n\tSIMPLEQ_INSERT_TAIL(&pipe->queue, xfer, next);\n\tif (pipe->running)\n\t\terr = USBD_IN_PROGRESS;\n\telse {\n\t\tpipe->running = 1;\n\t\terr = USBD_NORMAL_COMPLETION;\n\t}\n\tsplx(s);\n\treturn (err);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nStatic void;\nStatic void;\nStatic usbd_status;\nStatic void;\nStatic void;\nStatic usbd_status;\nStatic void;\nStatic void;\nStatic void;\nohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));\nStatic usbd_status;\nohci_device_request __P((usbd_xfer_handle xfer));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic usbd_status;\nohci_setup_isoc __P((usbd_pipe_handle pipe));\nStatic void;\nohci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic void;\nStatic usbd_xfer_handle;\nStatic void;\nohci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nStatic usbd_status;\nohci_root_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_ctrl_start __P((usbd_xfer_handle));\nStatic void;\nohci_root_ctrl_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_root_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_intr_start __P((usbd_xfer_handle));\nStatic void;\nohci_root_intr_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_root_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_ctrl_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_ctrl_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_bulk_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_bulk_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_bulk_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_bulk_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_intr_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_intr_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_isoc_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_isoc_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_isoc_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_isoc_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_device_clear_toggle __P((usbd_pipe_handle pipe));\nStatic void;\nohci_noop __P((usbd_pipe_handle pipe));\nStatic int;\n\nStatic usbd_status\nohci_device_ctrl_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_status err;\n\n\t/* Insert last in queue. */\n\terr = usb_insert_transfer(xfer);\n\tif (err)\n\t\treturn (err);\n\n\t/* Pipe isn't running, start first */\n\treturn (ohci_device_ctrl_start(SIMPLEQ_FIRST(&xfer->pipe->queue)));\n}"
  },
  {
    "function_name": "ohci_root_intr_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "2560-2569",
    "snippet": "Static void\nohci_root_intr_close(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tohci_softc_t *sc = (ohci_softc_t *)pipe->device->bus;\n\t\n\tDPRINTF((\"ohci_root_intr_close\\n\"));\n\n\tsc->sc_intrxfer = NULL;\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "ohci_open __P((usbd_pipe_handle));",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "ohci_setup_isoc __P((usbd_pipe_handle pipe));",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "ohci_root_ctrl_close __P((usbd_pipe_handle));",
      "Static void",
      "Static void",
      "Static void",
      "ohci_root_intr_close __P((usbd_pipe_handle));",
      "Static void",
      "Static void",
      "Static void",
      "ohci_device_ctrl_close __P((usbd_pipe_handle));",
      "Static void",
      "Static void",
      "Static void",
      "ohci_device_bulk_close __P((usbd_pipe_handle));",
      "Static void",
      "Static void",
      "Static void",
      "ohci_device_intr_close __P((usbd_pipe_handle));",
      "Static void",
      "Static void",
      "Static void",
      "ohci_device_isoc_close __P((usbd_pipe_handle));",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "ohci_rhsc_able __P((ohci_softc_t *, int));",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "ohci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "Static void",
      "ohci_noop __P((usbd_pipe_handle pipe));",
      "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
      "Static int",
      "ohci_intr1 __P((ohci_softc_t *));",
      "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ohci_root_intr_close\\n\")"
          ],
          "line": 2566
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_open __P((usbd_pipe_handle));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_setup_isoc __P((usbd_pipe_handle pipe));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_root_ctrl_close __P((usbd_pipe_handle));\nStatic void;\nStatic void;\nStatic void;\nohci_root_intr_close __P((usbd_pipe_handle));\nStatic void;\nStatic void;\nStatic void;\nohci_device_ctrl_close __P((usbd_pipe_handle));\nStatic void;\nStatic void;\nStatic void;\nohci_device_bulk_close __P((usbd_pipe_handle));\nStatic void;\nStatic void;\nStatic void;\nohci_device_intr_close __P((usbd_pipe_handle));\nStatic void;\nStatic void;\nStatic void;\nohci_device_isoc_close __P((usbd_pipe_handle));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nohci_rhsc_able __P((ohci_softc_t *, int));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_device_clear_toggle __P((usbd_pipe_handle pipe));\nStatic void;\nohci_noop __P((usbd_pipe_handle pipe));\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nStatic int;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nStatic void\nohci_root_intr_close(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tohci_softc_t *sc = (ohci_softc_t *)pipe->device->bus;\n\t\n\tDPRINTF((\"ohci_root_intr_close\\n\"));\n\n\tsc->sc_intrxfer = NULL;\n}"
  },
  {
    "function_name": "ohci_root_intr_abort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "2543-2557",
    "snippet": "Static void\nohci_root_intr_abort(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tint s;\n\n\tif (xfer->pipe->intrxfer == xfer) {\n\t\tDPRINTF((\"ohci_root_intr_abort: remove\\n\"));\n\t\txfer->pipe->intrxfer = NULL;\n\t}\n\txfer->status = USBD_CANCELLED;\n\ts = splusb();\n\tusb_transfer_complete(xfer);\n\tsplx(s);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "ohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));",
      "ohci_device_request __P((usbd_xfer_handle xfer));",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "ohci_setup_isoc __P((usbd_pipe_handle pipe));",
      "Static void",
      "ohci_device_isoc_enter __P((usbd_xfer_handle));",
      "Static void",
      "Static usbd_xfer_handle",
      "Static void",
      "ohci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "ohci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "ohci_root_ctrl_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_root_ctrl_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_root_ctrl_done  __P((usbd_xfer_handle));",
      "ohci_root_intr_transfer __P((usbd_xfer_handle));",
      "ohci_root_intr_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_root_intr_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_root_intr_done  __P((usbd_xfer_handle));",
      "ohci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "ohci_device_ctrl_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_device_ctrl_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_device_ctrl_done  __P((usbd_xfer_handle));",
      "ohci_device_bulk_transfer __P((usbd_xfer_handle));",
      "ohci_device_bulk_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_device_bulk_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_device_bulk_done  __P((usbd_xfer_handle));",
      "ohci_device_intr_transfer __P((usbd_xfer_handle));",
      "ohci_device_intr_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_device_intr_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_device_intr_done  __P((usbd_xfer_handle));",
      "ohci_device_isoc_transfer __P((usbd_xfer_handle));",
      "ohci_device_isoc_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_device_isoc_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_device_isoc_done  __P((usbd_xfer_handle));",
      "Static int",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "ohci_abort_xfer __P((usbd_xfer_handle xfer,\n\t\t\t    usbd_status status));",
      "Static void",
      "Static void",
      "ohci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "Static void",
      "ohci_noop __P((usbd_pipe_handle pipe));",
      "Static int"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 2556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_transfer_complete",
          "args": [
            "xfer"
          ],
          "line": 2555
        },
        "resolved": true,
        "details": {
          "function_name": "usb_transfer_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "789-883",
          "snippet": "void\nusb_transfer_complete(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tint repeat = pipe->repeat;\n\tint polling;\n\n\tSPLUSBCHECK;\n\n\tDPRINTFN(5, (\"usb_transfer_complete: pipe=%p xfer=%p status=%d \"\n\t\t     \"actlen=%d\\n\", pipe, xfer, xfer->status, xfer->actlen));\n\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_transfer_cb: pipe==0, xfer=%p\\n\", xfer);\n\t\treturn;\n\t}\n#endif\n\tpolling = pipe->device->bus->use_polling;\n\t/* XXXX */\n\tif (polling)\n\t\tpipe->running = 0;\n\n\tif (!(xfer->flags & USBD_NO_COPY) && xfer->actlen != 0 &&\n\t    usbd_xfer_isread(xfer)) {\n#ifdef DIAGNOSTIC\n\t\tif (xfer->actlen > xfer->length) {\n\t\t\tprintf(\"usb_transfer_complete: actlen > len %d > %d\\n\",\n\t\t\t       xfer->actlen, xfer->length);\n\t\t\txfer->actlen = xfer->length;\n\t\t}\n#endif\n\t\tmemcpy(xfer->buffer, KERNADDR(dmap), xfer->actlen);\n\t}\n\n\t/* if we allocated the buffer in usbd_transfer() we free it here. */\n\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\tif (!repeat) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\t\t\tbus->methods->freem(bus, dmap);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!repeat) {\n\t\t/* Remove request from queue. */\n#ifdef DIAGNOSTIC\n\t\tif (xfer != SIMPLEQ_FIRST(&pipe->queue))\n\t\t\tprintf(\"usb_transfer_complete: bad dequeue %p != %p\\n\",\n\t\t\t       xfer, SIMPLEQ_FIRST(&pipe->queue));\n#endif\n\t\tSIMPLEQ_REMOVE_HEAD(&pipe->queue, xfer, next);\n\t}\n\tDPRINTFN(5,(\"usb_transfer_complete: repeat=%d new head=%p\\n\", \n\t\t    repeat, SIMPLEQ_FIRST(&pipe->queue)));\n\n\t/* Count completed transfers. */\n\t++pipe->device->bus->stats.requests\n\t\t[pipe->endpoint->edesc->bmAttributes & UE_XFERTYPE];\n\n\txfer->done = 1;\n\tif (!xfer->status && xfer->actlen < xfer->length &&\n\t    !(xfer->flags & USBD_SHORT_XFER_OK)) {\n\t\tDPRINTFN(-1,(\"usbd_transfer_cb: short transfer %d<%d\\n\",\n\t\t\t     xfer->actlen, xfer->length));\n\t\txfer->status = USBD_SHORT_XFER;\n\t}\n\n\tif (xfer->callback)\n\t\txfer->callback(xfer, xfer->priv, xfer->status);\n\n#ifdef DIAGNOSTIC\n\tif (pipe->methods->done != NULL)\n\t\tpipe->methods->done(xfer);\n\telse\n\t\tprintf(\"usb_transfer_complete: pipe->methods->done == NULL\\n\");\n#else\n\tpipe->methods->done(xfer);\n#endif\n\n\tif ((xfer->flags & USBD_SYNCHRONOUS) && !polling)\n\t\twakeup(xfer);\n\n\tif (!repeat) {\n\t\t/* XXX should we stop the queue on all errors? */\n\t\tif ((xfer->status == USBD_CANCELLED ||\n\t\t     xfer->status == USBD_TIMEOUT) &&\n\t\t    pipe->iface != NULL)\t\t/* not control pipe */\n\t\t\tpipe->running = 0;\n\t\telse\n\t\t\tusbd_start_next(pipe);\n\t}\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "usb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;",
            "usb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);",
            "usb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_start_next __P((usbd_pipe_handle pipe));\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nusb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;\nusb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\nusb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;\n\nvoid\nusb_transfer_complete(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tint repeat = pipe->repeat;\n\tint polling;\n\n\tSPLUSBCHECK;\n\n\tDPRINTFN(5, (\"usb_transfer_complete: pipe=%p xfer=%p status=%d \"\n\t\t     \"actlen=%d\\n\", pipe, xfer, xfer->status, xfer->actlen));\n\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_transfer_cb: pipe==0, xfer=%p\\n\", xfer);\n\t\treturn;\n\t}\n#endif\n\tpolling = pipe->device->bus->use_polling;\n\t/* XXXX */\n\tif (polling)\n\t\tpipe->running = 0;\n\n\tif (!(xfer->flags & USBD_NO_COPY) && xfer->actlen != 0 &&\n\t    usbd_xfer_isread(xfer)) {\n#ifdef DIAGNOSTIC\n\t\tif (xfer->actlen > xfer->length) {\n\t\t\tprintf(\"usb_transfer_complete: actlen > len %d > %d\\n\",\n\t\t\t       xfer->actlen, xfer->length);\n\t\t\txfer->actlen = xfer->length;\n\t\t}\n#endif\n\t\tmemcpy(xfer->buffer, KERNADDR(dmap), xfer->actlen);\n\t}\n\n\t/* if we allocated the buffer in usbd_transfer() we free it here. */\n\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\tif (!repeat) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\t\t\tbus->methods->freem(bus, dmap);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!repeat) {\n\t\t/* Remove request from queue. */\n#ifdef DIAGNOSTIC\n\t\tif (xfer != SIMPLEQ_FIRST(&pipe->queue))\n\t\t\tprintf(\"usb_transfer_complete: bad dequeue %p != %p\\n\",\n\t\t\t       xfer, SIMPLEQ_FIRST(&pipe->queue));\n#endif\n\t\tSIMPLEQ_REMOVE_HEAD(&pipe->queue, xfer, next);\n\t}\n\tDPRINTFN(5,(\"usb_transfer_complete: repeat=%d new head=%p\\n\", \n\t\t    repeat, SIMPLEQ_FIRST(&pipe->queue)));\n\n\t/* Count completed transfers. */\n\t++pipe->device->bus->stats.requests\n\t\t[pipe->endpoint->edesc->bmAttributes & UE_XFERTYPE];\n\n\txfer->done = 1;\n\tif (!xfer->status && xfer->actlen < xfer->length &&\n\t    !(xfer->flags & USBD_SHORT_XFER_OK)) {\n\t\tDPRINTFN(-1,(\"usbd_transfer_cb: short transfer %d<%d\\n\",\n\t\t\t     xfer->actlen, xfer->length));\n\t\txfer->status = USBD_SHORT_XFER;\n\t}\n\n\tif (xfer->callback)\n\t\txfer->callback(xfer, xfer->priv, xfer->status);\n\n#ifdef DIAGNOSTIC\n\tif (pipe->methods->done != NULL)\n\t\tpipe->methods->done(xfer);\n\telse\n\t\tprintf(\"usb_transfer_complete: pipe->methods->done == NULL\\n\");\n#else\n\tpipe->methods->done(xfer);\n#endif\n\n\tif ((xfer->flags & USBD_SYNCHRONOUS) && !polling)\n\t\twakeup(xfer);\n\n\tif (!repeat) {\n\t\t/* XXX should we stop the queue on all errors? */\n\t\tif ((xfer->status == USBD_CANCELLED ||\n\t\t     xfer->status == USBD_TIMEOUT) &&\n\t\t    pipe->iface != NULL)\t\t/* not control pipe */\n\t\t\tpipe->running = 0;\n\t\telse\n\t\t\tusbd_start_next(pipe);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 2554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ohci_root_intr_abort: remove\\n\")"
          ],
          "line": 2550
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));\nohci_device_request __P((usbd_xfer_handle xfer));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_setup_isoc __P((usbd_pipe_handle pipe));\nStatic void;\nohci_device_isoc_enter __P((usbd_xfer_handle));\nStatic void;\nStatic usbd_xfer_handle;\nStatic void;\nohci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nohci_root_ctrl_transfer __P((usbd_xfer_handle));\nohci_root_ctrl_start __P((usbd_xfer_handle));\nStatic void;\nohci_root_ctrl_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_root_ctrl_done  __P((usbd_xfer_handle));\nohci_root_intr_transfer __P((usbd_xfer_handle));\nohci_root_intr_start __P((usbd_xfer_handle));\nStatic void;\nohci_root_intr_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_root_intr_done  __P((usbd_xfer_handle));\nohci_device_ctrl_transfer __P((usbd_xfer_handle));\nohci_device_ctrl_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_ctrl_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_ctrl_done  __P((usbd_xfer_handle));\nohci_device_bulk_transfer __P((usbd_xfer_handle));\nohci_device_bulk_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_bulk_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_bulk_done  __P((usbd_xfer_handle));\nohci_device_intr_transfer __P((usbd_xfer_handle));\nohci_device_intr_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_intr_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_intr_done  __P((usbd_xfer_handle));\nohci_device_isoc_transfer __P((usbd_xfer_handle));\nohci_device_isoc_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_isoc_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_isoc_done  __P((usbd_xfer_handle));\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_abort_xfer __P((usbd_xfer_handle xfer,\n\t\t\t    usbd_status status));\nStatic void;\nStatic void;\nohci_device_clear_toggle __P((usbd_pipe_handle pipe));\nStatic void;\nohci_noop __P((usbd_pipe_handle pipe));\nStatic int;\n\nStatic void\nohci_root_intr_abort(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tint s;\n\n\tif (xfer->pipe->intrxfer == xfer) {\n\t\tDPRINTF((\"ohci_root_intr_abort: remove\\n\"));\n\t\txfer->pipe->intrxfer = NULL;\n\t}\n\txfer->status = USBD_CANCELLED;\n\ts = splusb();\n\tusb_transfer_complete(xfer);\n\tsplx(s);\n}"
  },
  {
    "function_name": "ohci_root_intr_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "2527-2540",
    "snippet": "Static usbd_status\nohci_root_intr_start(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tohci_softc_t *sc = (ohci_softc_t *)pipe->device->bus;\n\n\tif (sc->sc_dying)\n\t\treturn (USBD_IOERROR);\n\n\tsc->sc_intrxfer = xfer;\n\n\treturn (USBD_IN_PROGRESS);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static void",
      "Static void",
      "Static void",
      "Static usbd_status",
      "Static void",
      "Static void",
      "Static usbd_status",
      "ohci_open __P((usbd_pipe_handle));",
      "Static void",
      "Static void",
      "Static void",
      "ohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_request __P((usbd_xfer_handle xfer));",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static usbd_status",
      "ohci_setup_isoc __P((usbd_pipe_handle pipe));",
      "Static void",
      "ohci_device_isoc_enter __P((usbd_xfer_handle));",
      "Static usbd_status",
      "Static void",
      "Static usbd_xfer_handle",
      "Static void",
      "ohci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_root_ctrl_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_root_ctrl_abort __P((usbd_xfer_handle));",
      "Static void",
      "ohci_root_ctrl_close __P((usbd_pipe_handle));",
      "Static void",
      "ohci_root_ctrl_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_root_intr_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_root_intr_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_root_intr_abort __P((usbd_xfer_handle));",
      "Static void",
      "ohci_root_intr_close __P((usbd_pipe_handle));",
      "Static void",
      "ohci_root_intr_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_ctrl_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_device_ctrl_abort __P((usbd_xfer_handle));",
      "Static void",
      "ohci_device_ctrl_close __P((usbd_pipe_handle));",
      "Static void",
      "ohci_device_ctrl_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_bulk_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_bulk_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_device_bulk_abort __P((usbd_xfer_handle));",
      "Static void",
      "ohci_device_bulk_close __P((usbd_pipe_handle));",
      "Static void",
      "ohci_device_bulk_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_intr_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_intr_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_device_intr_abort __P((usbd_xfer_handle));",
      "Static void",
      "ohci_device_intr_close __P((usbd_pipe_handle));",
      "Static void",
      "ohci_device_intr_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_isoc_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_isoc_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_device_isoc_abort __P((usbd_xfer_handle));",
      "Static void",
      "ohci_device_isoc_close __P((usbd_pipe_handle));",
      "Static void",
      "ohci_device_isoc_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "Static int",
      "Static void",
      "Static void",
      "ohci_rhsc_able __P((ohci_softc_t *, int));",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "ohci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "Static void",
      "ohci_noop __P((usbd_pipe_handle pipe));",
      "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
      "Static int",
      "ohci_intr1 __P((ohci_softc_t *));",
      "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nStatic void;\nStatic void;\nStatic usbd_status;\nStatic void;\nStatic void;\nStatic usbd_status;\nohci_open __P((usbd_pipe_handle));\nStatic void;\nStatic void;\nStatic void;\nohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));\nStatic usbd_status;\nohci_device_request __P((usbd_xfer_handle xfer));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic usbd_status;\nohci_setup_isoc __P((usbd_pipe_handle pipe));\nStatic void;\nohci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic void;\nStatic usbd_xfer_handle;\nStatic void;\nohci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nStatic usbd_status;\nohci_root_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_ctrl_start __P((usbd_xfer_handle));\nStatic void;\nohci_root_ctrl_abort __P((usbd_xfer_handle));\nStatic void;\nohci_root_ctrl_close __P((usbd_pipe_handle));\nStatic void;\nohci_root_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_intr_start __P((usbd_xfer_handle));\nStatic void;\nohci_root_intr_abort __P((usbd_xfer_handle));\nStatic void;\nohci_root_intr_close __P((usbd_pipe_handle));\nStatic void;\nohci_root_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_ctrl_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_ctrl_abort __P((usbd_xfer_handle));\nStatic void;\nohci_device_ctrl_close __P((usbd_pipe_handle));\nStatic void;\nohci_device_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_bulk_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_bulk_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_bulk_abort __P((usbd_xfer_handle));\nStatic void;\nohci_device_bulk_close __P((usbd_pipe_handle));\nStatic void;\nohci_device_bulk_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_intr_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_intr_abort __P((usbd_xfer_handle));\nStatic void;\nohci_device_intr_close __P((usbd_pipe_handle));\nStatic void;\nohci_device_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_isoc_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_isoc_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_isoc_abort __P((usbd_xfer_handle));\nStatic void;\nohci_device_isoc_close __P((usbd_pipe_handle));\nStatic void;\nohci_device_isoc_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic int;\nStatic void;\nStatic void;\nohci_rhsc_able __P((ohci_softc_t *, int));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_device_clear_toggle __P((usbd_pipe_handle pipe));\nStatic void;\nohci_noop __P((usbd_pipe_handle pipe));\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nStatic int;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nStatic usbd_status\nohci_root_intr_start(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tohci_softc_t *sc = (ohci_softc_t *)pipe->device->bus;\n\n\tif (sc->sc_dying)\n\t\treturn (USBD_IOERROR);\n\n\tsc->sc_intrxfer = xfer;\n\n\treturn (USBD_IN_PROGRESS);\n}"
  },
  {
    "function_name": "ohci_root_intr_transfer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "2512-2525",
    "snippet": "Static usbd_status\nohci_root_intr_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_status err;\n\n\t/* Insert last in queue. */\n\terr = usb_insert_transfer(xfer);\n\tif (err)\n\t\treturn (err);\n\n\t/* Pipe isn't running, start first */\n\treturn (ohci_root_intr_start(SIMPLEQ_FIRST(&xfer->pipe->queue)));\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static void",
      "Static void",
      "Static void",
      "Static usbd_status",
      "Static void",
      "Static void",
      "Static usbd_status",
      "Static void",
      "Static void",
      "Static void",
      "ohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_request __P((usbd_xfer_handle xfer));",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static usbd_status",
      "ohci_setup_isoc __P((usbd_pipe_handle pipe));",
      "Static void",
      "ohci_device_isoc_enter __P((usbd_xfer_handle));",
      "Static usbd_status",
      "Static void",
      "Static usbd_xfer_handle",
      "Static void",
      "ohci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_root_ctrl_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_root_ctrl_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_root_ctrl_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_root_intr_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_root_intr_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_root_intr_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_root_intr_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_ctrl_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_device_ctrl_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_device_ctrl_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_bulk_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_bulk_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_device_bulk_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_device_bulk_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_intr_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_intr_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_device_intr_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_device_intr_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_isoc_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_isoc_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_device_isoc_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_device_isoc_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "Static int",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "ohci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "Static void",
      "ohci_noop __P((usbd_pipe_handle pipe));",
      "Static int"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ohci_root_intr_start",
          "args": [
            "SIMPLEQ_FIRST(&xfer->pipe->queue)"
          ],
          "line": 2524
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_root_intr_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "2527-2540",
          "snippet": "Static usbd_status\nohci_root_intr_start(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tohci_softc_t *sc = (ohci_softc_t *)pipe->device->bus;\n\n\tif (sc->sc_dying)\n\t\treturn (USBD_IOERROR);\n\n\tsc->sc_intrxfer = xfer;\n\n\treturn (USBD_IN_PROGRESS);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static void",
            "Static void",
            "Static void",
            "Static usbd_status",
            "Static void",
            "Static void",
            "Static usbd_status",
            "ohci_open __P((usbd_pipe_handle));",
            "Static void",
            "Static void",
            "Static void",
            "ohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));",
            "Static void",
            "Static void",
            "ohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_request __P((usbd_xfer_handle xfer));",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static usbd_status",
            "ohci_setup_isoc __P((usbd_pipe_handle pipe));",
            "Static void",
            "ohci_device_isoc_enter __P((usbd_xfer_handle));",
            "Static usbd_status",
            "Static void",
            "Static usbd_xfer_handle",
            "Static void",
            "ohci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_root_ctrl_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_root_ctrl_start __P((usbd_xfer_handle));",
            "Static void",
            "ohci_root_ctrl_abort __P((usbd_xfer_handle));",
            "Static void",
            "ohci_root_ctrl_close __P((usbd_pipe_handle));",
            "Static void",
            "ohci_root_ctrl_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_root_intr_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_root_intr_start __P((usbd_xfer_handle));",
            "Static void",
            "ohci_root_intr_abort __P((usbd_xfer_handle));",
            "Static void",
            "ohci_root_intr_close __P((usbd_pipe_handle));",
            "Static void",
            "ohci_root_intr_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_ctrl_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_ctrl_start __P((usbd_xfer_handle));",
            "Static void",
            "ohci_device_ctrl_abort __P((usbd_xfer_handle));",
            "Static void",
            "ohci_device_ctrl_close __P((usbd_pipe_handle));",
            "Static void",
            "ohci_device_ctrl_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_bulk_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_bulk_start __P((usbd_xfer_handle));",
            "Static void",
            "ohci_device_bulk_abort __P((usbd_xfer_handle));",
            "Static void",
            "ohci_device_bulk_close __P((usbd_pipe_handle));",
            "Static void",
            "ohci_device_bulk_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_intr_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_intr_start __P((usbd_xfer_handle));",
            "Static void",
            "ohci_device_intr_abort __P((usbd_xfer_handle));",
            "Static void",
            "ohci_device_intr_close __P((usbd_pipe_handle));",
            "Static void",
            "ohci_device_intr_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_isoc_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_isoc_start __P((usbd_xfer_handle));",
            "Static void",
            "ohci_device_isoc_abort __P((usbd_xfer_handle));",
            "Static void",
            "ohci_device_isoc_close __P((usbd_pipe_handle));",
            "Static void",
            "ohci_device_isoc_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "Static int",
            "Static void",
            "Static void",
            "ohci_rhsc_able __P((ohci_softc_t *, int));",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "ohci_device_clear_toggle __P((usbd_pipe_handle pipe));",
            "Static void",
            "ohci_noop __P((usbd_pipe_handle pipe));",
            "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
            "Static int",
            "ohci_intr1 __P((ohci_softc_t *));",
            "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nStatic void;\nStatic void;\nStatic usbd_status;\nStatic void;\nStatic void;\nStatic usbd_status;\nohci_open __P((usbd_pipe_handle));\nStatic void;\nStatic void;\nStatic void;\nohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));\nStatic usbd_status;\nohci_device_request __P((usbd_xfer_handle xfer));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic usbd_status;\nohci_setup_isoc __P((usbd_pipe_handle pipe));\nStatic void;\nohci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic void;\nStatic usbd_xfer_handle;\nStatic void;\nohci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nStatic usbd_status;\nohci_root_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_ctrl_start __P((usbd_xfer_handle));\nStatic void;\nohci_root_ctrl_abort __P((usbd_xfer_handle));\nStatic void;\nohci_root_ctrl_close __P((usbd_pipe_handle));\nStatic void;\nohci_root_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_intr_start __P((usbd_xfer_handle));\nStatic void;\nohci_root_intr_abort __P((usbd_xfer_handle));\nStatic void;\nohci_root_intr_close __P((usbd_pipe_handle));\nStatic void;\nohci_root_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_ctrl_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_ctrl_abort __P((usbd_xfer_handle));\nStatic void;\nohci_device_ctrl_close __P((usbd_pipe_handle));\nStatic void;\nohci_device_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_bulk_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_bulk_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_bulk_abort __P((usbd_xfer_handle));\nStatic void;\nohci_device_bulk_close __P((usbd_pipe_handle));\nStatic void;\nohci_device_bulk_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_intr_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_intr_abort __P((usbd_xfer_handle));\nStatic void;\nohci_device_intr_close __P((usbd_pipe_handle));\nStatic void;\nohci_device_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_isoc_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_isoc_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_isoc_abort __P((usbd_xfer_handle));\nStatic void;\nohci_device_isoc_close __P((usbd_pipe_handle));\nStatic void;\nohci_device_isoc_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic int;\nStatic void;\nStatic void;\nohci_rhsc_able __P((ohci_softc_t *, int));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_device_clear_toggle __P((usbd_pipe_handle pipe));\nStatic void;\nohci_noop __P((usbd_pipe_handle pipe));\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nStatic int;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nStatic usbd_status\nohci_root_intr_start(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tohci_softc_t *sc = (ohci_softc_t *)pipe->device->bus;\n\n\tif (sc->sc_dying)\n\t\treturn (USBD_IOERROR);\n\n\tsc->sc_intrxfer = xfer;\n\n\treturn (USBD_IN_PROGRESS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_FIRST",
          "args": [
            "&xfer->pipe->queue"
          ],
          "line": 2524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_insert_transfer",
          "args": [
            "xfer"
          ],
          "line": 2519
        },
        "resolved": true,
        "details": {
          "function_name": "usb_insert_transfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "885-905",
          "snippet": "usbd_status\nusb_insert_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusbd_status err;\n\tint s;\n\n\tDPRINTFN(5,(\"usb_insert_transfer: pipe=%p running=%d timeout=%d\\n\", \n\t\t    pipe, pipe->running, xfer->timeout));\n\ts = splusb();\n\tSIMPLEQ_INSERT_TAIL(&pipe->queue, xfer, next);\n\tif (pipe->running)\n\t\terr = USBD_IN_PROGRESS;\n\telse {\n\t\tpipe->running = 1;\n\t\terr = USBD_NORMAL_COMPLETION;\n\t}\n\tsplx(s);\n\treturn (err);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nusbd_status\nusb_insert_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusbd_status err;\n\tint s;\n\n\tDPRINTFN(5,(\"usb_insert_transfer: pipe=%p running=%d timeout=%d\\n\", \n\t\t    pipe, pipe->running, xfer->timeout));\n\ts = splusb();\n\tSIMPLEQ_INSERT_TAIL(&pipe->queue, xfer, next);\n\tif (pipe->running)\n\t\terr = USBD_IN_PROGRESS;\n\telse {\n\t\tpipe->running = 1;\n\t\terr = USBD_NORMAL_COMPLETION;\n\t}\n\tsplx(s);\n\treturn (err);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nStatic void;\nStatic void;\nStatic usbd_status;\nStatic void;\nStatic void;\nStatic usbd_status;\nStatic void;\nStatic void;\nStatic void;\nohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));\nStatic usbd_status;\nohci_device_request __P((usbd_xfer_handle xfer));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic usbd_status;\nohci_setup_isoc __P((usbd_pipe_handle pipe));\nStatic void;\nohci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic void;\nStatic usbd_xfer_handle;\nStatic void;\nohci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nStatic usbd_status;\nohci_root_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_ctrl_start __P((usbd_xfer_handle));\nStatic void;\nohci_root_ctrl_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_root_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_intr_start __P((usbd_xfer_handle));\nStatic void;\nohci_root_intr_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_root_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_ctrl_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_ctrl_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_bulk_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_bulk_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_bulk_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_bulk_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_intr_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_intr_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_isoc_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_isoc_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_isoc_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_isoc_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_device_clear_toggle __P((usbd_pipe_handle pipe));\nStatic void;\nohci_noop __P((usbd_pipe_handle pipe));\nStatic int;\n\nStatic usbd_status\nohci_root_intr_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_status err;\n\n\t/* Insert last in queue. */\n\terr = usb_insert_transfer(xfer);\n\tif (err)\n\t\treturn (err);\n\n\t/* Pipe isn't running, start first */\n\treturn (ohci_root_intr_start(SIMPLEQ_FIRST(&xfer->pipe->queue)));\n}"
  },
  {
    "function_name": "ohci_root_ctrl_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "2504-2510",
    "snippet": "Static void\nohci_root_ctrl_close(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tDPRINTF((\"ohci_root_ctrl_close\\n\"));\n\t/* Nothing to do. */\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "ohci_open __P((usbd_pipe_handle));",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "ohci_setup_isoc __P((usbd_pipe_handle pipe));",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "ohci_root_ctrl_close __P((usbd_pipe_handle));",
      "Static void",
      "Static void",
      "Static void",
      "ohci_root_intr_close __P((usbd_pipe_handle));",
      "Static void",
      "Static void",
      "Static void",
      "ohci_device_ctrl_close __P((usbd_pipe_handle));",
      "Static void",
      "Static void",
      "Static void",
      "ohci_device_bulk_close __P((usbd_pipe_handle));",
      "Static void",
      "Static void",
      "Static void",
      "ohci_device_intr_close __P((usbd_pipe_handle));",
      "Static void",
      "Static void",
      "Static void",
      "ohci_device_isoc_close __P((usbd_pipe_handle));",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "ohci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "Static void",
      "ohci_noop __P((usbd_pipe_handle pipe));",
      "Static int"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ohci_root_ctrl_close\\n\")"
          ],
          "line": 2508
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_open __P((usbd_pipe_handle));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_setup_isoc __P((usbd_pipe_handle pipe));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_root_ctrl_close __P((usbd_pipe_handle));\nStatic void;\nStatic void;\nStatic void;\nohci_root_intr_close __P((usbd_pipe_handle));\nStatic void;\nStatic void;\nStatic void;\nohci_device_ctrl_close __P((usbd_pipe_handle));\nStatic void;\nStatic void;\nStatic void;\nohci_device_bulk_close __P((usbd_pipe_handle));\nStatic void;\nStatic void;\nStatic void;\nohci_device_intr_close __P((usbd_pipe_handle));\nStatic void;\nStatic void;\nStatic void;\nohci_device_isoc_close __P((usbd_pipe_handle));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_device_clear_toggle __P((usbd_pipe_handle pipe));\nStatic void;\nohci_noop __P((usbd_pipe_handle pipe));\nStatic int;\n\nStatic void\nohci_root_ctrl_close(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tDPRINTF((\"ohci_root_ctrl_close\\n\"));\n\t/* Nothing to do. */\n}"
  },
  {
    "function_name": "ohci_root_ctrl_abort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "2496-2501",
    "snippet": "Static void\nohci_root_ctrl_abort(xfer)\n\tusbd_xfer_handle xfer;\n{\n\t/* Nothing to do, all transfers are synchronous. */\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "ohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));",
      "ohci_device_request __P((usbd_xfer_handle xfer));",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "ohci_device_isoc_enter __P((usbd_xfer_handle));",
      "Static void",
      "Static usbd_xfer_handle",
      "Static void",
      "ohci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "ohci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "ohci_root_ctrl_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_root_ctrl_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_root_ctrl_done  __P((usbd_xfer_handle));",
      "ohci_root_intr_transfer __P((usbd_xfer_handle));",
      "ohci_root_intr_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_root_intr_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_root_intr_done  __P((usbd_xfer_handle));",
      "ohci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "ohci_device_ctrl_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_device_ctrl_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_device_ctrl_done  __P((usbd_xfer_handle));",
      "ohci_device_bulk_transfer __P((usbd_xfer_handle));",
      "ohci_device_bulk_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_device_bulk_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_device_bulk_done  __P((usbd_xfer_handle));",
      "ohci_device_intr_transfer __P((usbd_xfer_handle));",
      "ohci_device_intr_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_device_intr_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_device_intr_done  __P((usbd_xfer_handle));",
      "ohci_device_isoc_transfer __P((usbd_xfer_handle));",
      "ohci_device_isoc_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_device_isoc_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_device_isoc_done  __P((usbd_xfer_handle));",
      "Static int",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static int"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));\nohci_device_request __P((usbd_xfer_handle xfer));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_device_isoc_enter __P((usbd_xfer_handle));\nStatic void;\nStatic usbd_xfer_handle;\nStatic void;\nohci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nohci_root_ctrl_transfer __P((usbd_xfer_handle));\nohci_root_ctrl_start __P((usbd_xfer_handle));\nStatic void;\nohci_root_ctrl_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_root_ctrl_done  __P((usbd_xfer_handle));\nohci_root_intr_transfer __P((usbd_xfer_handle));\nohci_root_intr_start __P((usbd_xfer_handle));\nStatic void;\nohci_root_intr_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_root_intr_done  __P((usbd_xfer_handle));\nohci_device_ctrl_transfer __P((usbd_xfer_handle));\nohci_device_ctrl_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_ctrl_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_ctrl_done  __P((usbd_xfer_handle));\nohci_device_bulk_transfer __P((usbd_xfer_handle));\nohci_device_bulk_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_bulk_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_bulk_done  __P((usbd_xfer_handle));\nohci_device_intr_transfer __P((usbd_xfer_handle));\nohci_device_intr_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_intr_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_intr_done  __P((usbd_xfer_handle));\nohci_device_isoc_transfer __P((usbd_xfer_handle));\nohci_device_isoc_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_isoc_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_isoc_done  __P((usbd_xfer_handle));\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\n\nStatic void\nohci_root_ctrl_abort(xfer)\n\tusbd_xfer_handle xfer;\n{\n\t/* Nothing to do, all transfers are synchronous. */\n}"
  },
  {
    "function_name": "ohci_root_ctrl_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "2193-2493",
    "snippet": "Static usbd_status\nohci_root_ctrl_start(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tohci_softc_t *sc = (ohci_softc_t *)xfer->pipe->device->bus;\n\tusb_device_request_t *req;\n\tvoid *buf = NULL;\n\tint port, i;\n\tint s, len, value, index, l, totlen = 0;\n\tusb_port_status_t ps;\n\tusb_hub_descriptor_t hubd;\n\tusbd_status err;\n\tu_int32_t v;\n\n\tif (sc->sc_dying)\n\t\treturn (USBD_IOERROR);\n\n#ifdef DIAGNOSTIC\n\tif (!(xfer->rqflags & URQ_REQUEST))\n\t\t/* XXX panic */\n\t\treturn (USBD_INVAL);\n#endif\n\treq = &xfer->request;\n\n\tDPRINTFN(4,(\"ohci_root_ctrl_control type=0x%02x request=%02x\\n\", \n\t\t    req->bmRequestType, req->bRequest));\n\n\tlen = UGETW(req->wLength);\n\tvalue = UGETW(req->wValue);\n\tindex = UGETW(req->wIndex);\n\n\tif (len != 0)\n\t\tbuf = KERNADDR(&xfer->dmabuf);\n\n#define C(x,y) ((x) | ((y) << 8))\n\tswitch(C(req->bRequest, req->bmRequestType)) {\n\tcase C(UR_CLEAR_FEATURE, UT_WRITE_DEVICE):\n\tcase C(UR_CLEAR_FEATURE, UT_WRITE_INTERFACE):\n\tcase C(UR_CLEAR_FEATURE, UT_WRITE_ENDPOINT):\n\t\t/* \n\t\t * DEVICE_REMOTE_WAKEUP and ENDPOINT_HALT are no-ops\n\t\t * for the integrated root hub.\n\t\t */\n\t\tbreak;\n\tcase C(UR_GET_CONFIG, UT_READ_DEVICE):\n\t\tif (len > 0) {\n\t\t\t*(u_int8_t *)buf = sc->sc_conf;\n\t\t\ttotlen = 1;\n\t\t}\n\t\tbreak;\n\tcase C(UR_GET_DESCRIPTOR, UT_READ_DEVICE):\n\t\tDPRINTFN(8,(\"ohci_root_ctrl_control wValue=0x%04x\\n\", value));\n\t\tswitch(value >> 8) {\n\t\tcase UDESC_DEVICE:\n\t\t\tif ((value & 0xff) != 0) {\n\t\t\t\terr = USBD_IOERROR;\n\t\t\t\tgoto ret;\n\t\t\t}\n\t\t\ttotlen = l = min(len, USB_DEVICE_DESCRIPTOR_SIZE);\n\t\t\tUSETW(ohci_devd.idVendor, sc->sc_id_vendor);\n\t\t\tmemcpy(buf, &ohci_devd, l);\n\t\t\tbreak;\n\t\tcase UDESC_CONFIG:\n\t\t\tif ((value & 0xff) != 0) {\n\t\t\t\terr = USBD_IOERROR;\n\t\t\t\tgoto ret;\n\t\t\t}\n\t\t\ttotlen = l = min(len, USB_CONFIG_DESCRIPTOR_SIZE);\n\t\t\tmemcpy(buf, &ohci_confd, l);\n\t\t\tbuf = (char *)buf + l;\n\t\t\tlen -= l;\n\t\t\tl = min(len, USB_INTERFACE_DESCRIPTOR_SIZE);\n\t\t\ttotlen += l;\n\t\t\tmemcpy(buf, &ohci_ifcd, l);\n\t\t\tbuf = (char *)buf + l;\n\t\t\tlen -= l;\n\t\t\tl = min(len, USB_ENDPOINT_DESCRIPTOR_SIZE);\n\t\t\ttotlen += l;\n\t\t\tmemcpy(buf, &ohci_endpd, l);\n\t\t\tbreak;\n\t\tcase UDESC_STRING:\n\t\t\tif (len == 0)\n\t\t\t\tbreak;\n\t\t\t*(u_int8_t *)buf = 0;\n\t\t\ttotlen = 1;\n\t\t\tswitch (value & 0xff) {\n\t\t\tcase 1: /* Vendor */\n\t\t\t\ttotlen = ohci_str(buf, len, sc->sc_vendor);\n\t\t\t\tbreak;\n\t\t\tcase 2: /* Product */\n\t\t\t\ttotlen = ohci_str(buf, len, \"OHCI root hub\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tbreak;\n\tcase C(UR_GET_INTERFACE, UT_READ_INTERFACE):\n\t\tif (len > 0) {\n\t\t\t*(u_int8_t *)buf = 0;\n\t\t\ttotlen = 1;\n\t\t}\n\t\tbreak;\n\tcase C(UR_GET_STATUS, UT_READ_DEVICE):\n\t\tif (len > 1) {\n\t\t\tUSETW(((usb_status_t *)buf)->wStatus,UDS_SELF_POWERED);\n\t\t\ttotlen = 2;\n\t\t}\n\t\tbreak;\n\tcase C(UR_GET_STATUS, UT_READ_INTERFACE):\n\tcase C(UR_GET_STATUS, UT_READ_ENDPOINT):\n\t\tif (len > 1) {\n\t\t\tUSETW(((usb_status_t *)buf)->wStatus, 0);\n\t\t\ttotlen = 2;\n\t\t}\n\t\tbreak;\n\tcase C(UR_SET_ADDRESS, UT_WRITE_DEVICE):\n\t\tif (value >= USB_MAX_DEVICES) {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tsc->sc_addr = value;\n\t\tbreak;\n\tcase C(UR_SET_CONFIG, UT_WRITE_DEVICE):\n\t\tif (value != 0 && value != 1) {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tsc->sc_conf = value;\n\t\tbreak;\n\tcase C(UR_SET_DESCRIPTOR, UT_WRITE_DEVICE):\n\t\tbreak;\n\tcase C(UR_SET_FEATURE, UT_WRITE_DEVICE):\n\tcase C(UR_SET_FEATURE, UT_WRITE_INTERFACE):\n\tcase C(UR_SET_FEATURE, UT_WRITE_ENDPOINT):\n\t\terr = USBD_IOERROR;\n\t\tgoto ret;\n\tcase C(UR_SET_INTERFACE, UT_WRITE_INTERFACE):\n\t\tbreak;\n\tcase C(UR_SYNCH_FRAME, UT_WRITE_ENDPOINT):\n\t\tbreak;\n\t/* Hub requests */\n\tcase C(UR_CLEAR_FEATURE, UT_WRITE_CLASS_DEVICE):\n\t\tbreak;\n\tcase C(UR_CLEAR_FEATURE, UT_WRITE_CLASS_OTHER):\n\t\tDPRINTFN(8, (\"ohci_root_ctrl_control: UR_CLEAR_PORT_FEATURE \"\n\t\t\t     \"port=%d feature=%d\\n\",\n\t\t\t     index, value));\n\t\tif (index < 1 || index > sc->sc_noport) {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tport = OHCI_RH_PORT_STATUS(index);\n\t\tswitch(value) {\n\t\tcase UHF_PORT_ENABLE:\n\t\t\tOWRITE4(sc, port, UPS_CURRENT_CONNECT_STATUS);\n\t\t\tbreak;\n\t\tcase UHF_PORT_SUSPEND:\n\t\t\tOWRITE4(sc, port, UPS_OVERCURRENT_INDICATOR);\n\t\t\tbreak;\n\t\tcase UHF_PORT_POWER:\n\t\t\tOWRITE4(sc, port, UPS_LOW_SPEED);\n\t\t\tbreak;\n\t\tcase UHF_C_PORT_CONNECTION:\n\t\t\tOWRITE4(sc, port, UPS_C_CONNECT_STATUS << 16);\n\t\t\tbreak;\n\t\tcase UHF_C_PORT_ENABLE:\n\t\t\tOWRITE4(sc, port, UPS_C_PORT_ENABLED << 16);\n\t\t\tbreak;\n\t\tcase UHF_C_PORT_SUSPEND:\n\t\t\tOWRITE4(sc, port, UPS_C_SUSPEND << 16);\n\t\t\tbreak;\n\t\tcase UHF_C_PORT_OVER_CURRENT:\n\t\t\tOWRITE4(sc, port, UPS_C_OVERCURRENT_INDICATOR << 16);\n\t\t\tbreak;\n\t\tcase UHF_C_PORT_RESET:\n\t\t\tOWRITE4(sc, port, UPS_C_PORT_RESET << 16);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tswitch(value) {\n\t\tcase UHF_C_PORT_CONNECTION:\n\t\tcase UHF_C_PORT_ENABLE:\n\t\tcase UHF_C_PORT_SUSPEND:\n\t\tcase UHF_C_PORT_OVER_CURRENT:\n\t\tcase UHF_C_PORT_RESET:\n\t\t\t/* Enable RHSC interrupt if condition is cleared. */\n\t\t\tif ((OREAD4(sc, port) >> 16) == 0)\n\t\t\t\tohci_rhsc_able(sc, 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase C(UR_GET_DESCRIPTOR, UT_READ_CLASS_DEVICE):\n\t\tif (value != 0) {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tv = OREAD4(sc, OHCI_RH_DESCRIPTOR_A);\n\t\thubd = ohci_hubd;\n\t\thubd.bNbrPorts = sc->sc_noport;\n\t\tUSETW(hubd.wHubCharacteristics,\n\t\t      (v & OHCI_NPS ? UHD_PWR_NO_SWITCH : \n\t\t       v & OHCI_PSM ? UHD_PWR_GANGED : UHD_PWR_INDIVIDUAL)\n\t\t      /* XXX overcurrent */\n\t\t      );\n\t\thubd.bPwrOn2PwrGood = OHCI_GET_POTPGT(v);\n\t\tv = OREAD4(sc, OHCI_RH_DESCRIPTOR_B);\n\t\tfor (i = 0, l = sc->sc_noport; l > 0; i++, l -= 8, v >>= 8) \n\t\t\thubd.DeviceRemovable[i++] = (u_int8_t)v;\n\t\thubd.bDescLength = USB_HUB_DESCRIPTOR_SIZE + i;\n\t\tl = min(len, hubd.bDescLength);\n\t\ttotlen = l;\n\t\tmemcpy(buf, &hubd, l);\n\t\tbreak;\n\tcase C(UR_GET_STATUS, UT_READ_CLASS_DEVICE):\n\t\tif (len != 4) {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tmemset(buf, 0, len); /* ? XXX */\n\t\ttotlen = len;\n\t\tbreak;\n\tcase C(UR_GET_STATUS, UT_READ_CLASS_OTHER):\n\t\tDPRINTFN(8,(\"ohci_root_ctrl_transfer: get port status i=%d\\n\",\n\t\t\t    index));\n\t\tif (index < 1 || index > sc->sc_noport) {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tif (len != 4) {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tv = OREAD4(sc, OHCI_RH_PORT_STATUS(index));\n\t\tDPRINTFN(8,(\"ohci_root_ctrl_transfer: port status=0x%04x\\n\",\n\t\t\t    v));\n\t\tUSETW(ps.wPortStatus, v);\n\t\tUSETW(ps.wPortChange, v >> 16);\n\t\tl = min(len, sizeof ps);\n\t\tmemcpy(buf, &ps, l);\n\t\ttotlen = l;\n\t\tbreak;\n\tcase C(UR_SET_DESCRIPTOR, UT_WRITE_CLASS_DEVICE):\n\t\terr = USBD_IOERROR;\n\t\tgoto ret;\n\tcase C(UR_SET_FEATURE, UT_WRITE_CLASS_DEVICE):\n\t\tbreak;\n\tcase C(UR_SET_FEATURE, UT_WRITE_CLASS_OTHER):\n\t\tif (index < 1 || index > sc->sc_noport) {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tport = OHCI_RH_PORT_STATUS(index);\n\t\tswitch(value) {\n\t\tcase UHF_PORT_ENABLE:\n\t\t\tOWRITE4(sc, port, UPS_PORT_ENABLED);\n\t\t\tbreak;\n\t\tcase UHF_PORT_SUSPEND:\n\t\t\tOWRITE4(sc, port, UPS_SUSPEND);\n\t\t\tbreak;\n\t\tcase UHF_PORT_RESET:\n\t\t\tDPRINTFN(5,(\"ohci_root_ctrl_transfer: reset port %d\\n\",\n\t\t\t\t    index));\n\t\t\tOWRITE4(sc, port, UPS_RESET);\n\t\t\tfor (i = 0; i < 10; i++) {\n\t\t\t\tusb_delay_ms(&sc->sc_bus, 10);\n\t\t\t\tif ((OREAD4(sc, port) & UPS_RESET) == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tDPRINTFN(8,(\"ohci port %d reset, status = 0x%04x\\n\",\n\t\t\t\t    index, OREAD4(sc, port)));\n\t\t\tbreak;\n\t\tcase UHF_PORT_POWER:\n\t\t\tDPRINTFN(2,(\"ohci_root_ctrl_transfer: set port power \"\n\t\t\t\t    \"%d\\n\", index));\n\t\t\tOWRITE4(sc, port, UPS_PORT_POWER);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\terr = USBD_IOERROR;\n\t\tgoto ret;\n\t}\n\txfer->actlen = totlen;\n\terr = USBD_NORMAL_COMPLETION;\n ret:\n\txfer->status = err;\n\ts = splusb();\n\tusb_transfer_complete(xfer);\n\tsplx(s);\n\treturn (USBD_IN_PROGRESS);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static void",
      "Static void",
      "Static void",
      "Static usbd_status",
      "Static void",
      "ohci_shutdown __P((void *v));",
      "Static void",
      "Static usbd_status",
      "Static void",
      "Static void",
      "Static void",
      "ohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_request __P((usbd_xfer_handle xfer));",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static usbd_status",
      "ohci_setup_isoc __P((usbd_pipe_handle pipe));",
      "Static void",
      "ohci_device_isoc_enter __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));",
      "Static void",
      "Static usbd_xfer_handle",
      "Static void",
      "ohci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_root_ctrl_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_root_ctrl_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_root_ctrl_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_root_intr_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_root_intr_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_root_intr_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_root_intr_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_ctrl_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_device_ctrl_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_device_ctrl_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_bulk_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_bulk_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_device_bulk_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_device_bulk_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_intr_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_intr_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_device_intr_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_device_intr_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_isoc_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_isoc_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_device_isoc_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_device_isoc_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "Static int",
      "Static void",
      "Static void",
      "ohci_rhsc_able __P((ohci_softc_t *, int));",
      "Static void",
      "Static void",
      "ohci_abort_xfer __P((usbd_xfer_handle xfer,\n\t\t\t    usbd_status status));",
      "Static void",
      "Static void",
      "ohci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "Static void",
      "ohci_noop __P((usbd_pipe_handle pipe));",
      "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
      "Static int",
      "ohci_intr1 __P((ohci_softc_t *));",
      "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;",
      "Static usb_device_descriptor_t ohci_devd = {\n\tUSB_DEVICE_DESCRIPTOR_SIZE,\n\tUDESC_DEVICE,\t\t/* type */\n\t{0x00, 0x01},\t\t/* USB version */\n\tUDCLASS_HUB,\t\t/* class */\n\tUDSUBCLASS_HUB,\t\t/* subclass */\n\t0,\t\t\t/* protocol */\n\t64,\t\t\t/* max packet */\n\t{0},{0},{0x00,0x01},\t/* device id */\n\t1,2,0,\t\t\t/* string indicies */\n\t1\t\t\t/* # of configurations */\n};",
      "Static usb_config_descriptor_t ohci_confd = {\n\tUSB_CONFIG_DESCRIPTOR_SIZE,\n\tUDESC_CONFIG,\n\t{USB_CONFIG_DESCRIPTOR_SIZE +\n\t USB_INTERFACE_DESCRIPTOR_SIZE +\n\t USB_ENDPOINT_DESCRIPTOR_SIZE},\n\t1,\n\t1,\n\t0,\n\tUC_SELF_POWERED,\n\t0\t\t\t/* max power */\n};",
      "Static usb_interface_descriptor_t ohci_ifcd = {\n\tUSB_INTERFACE_DESCRIPTOR_SIZE,\n\tUDESC_INTERFACE,\n\t0,\n\t0,\n\t1,\n\tUICLASS_HUB,\n\tUISUBCLASS_HUB,\n\t0,\n\t0\n};",
      "Static usb_endpoint_descriptor_t ohci_endpd = {\n\tUSB_ENDPOINT_DESCRIPTOR_SIZE,\n\tUDESC_ENDPOINT,\n\tUE_DIR_IN | OHCI_INTR_ENDPT,\n\tUE_INTERRUPT,\n\t{8, 0},\t\t\t/* max packet */\n\t255\n};",
      "Static usb_hub_descriptor_t ohci_hubd = {\n\tUSB_HUB_DESCRIPTOR_SIZE,\n\tUDESC_HUB,\n\t0,\n\t{0,0},\n\t0,\n\t0,\n\t{0},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 2491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_transfer_complete",
          "args": [
            "xfer"
          ],
          "line": 2490
        },
        "resolved": true,
        "details": {
          "function_name": "usb_transfer_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "789-883",
          "snippet": "void\nusb_transfer_complete(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tint repeat = pipe->repeat;\n\tint polling;\n\n\tSPLUSBCHECK;\n\n\tDPRINTFN(5, (\"usb_transfer_complete: pipe=%p xfer=%p status=%d \"\n\t\t     \"actlen=%d\\n\", pipe, xfer, xfer->status, xfer->actlen));\n\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_transfer_cb: pipe==0, xfer=%p\\n\", xfer);\n\t\treturn;\n\t}\n#endif\n\tpolling = pipe->device->bus->use_polling;\n\t/* XXXX */\n\tif (polling)\n\t\tpipe->running = 0;\n\n\tif (!(xfer->flags & USBD_NO_COPY) && xfer->actlen != 0 &&\n\t    usbd_xfer_isread(xfer)) {\n#ifdef DIAGNOSTIC\n\t\tif (xfer->actlen > xfer->length) {\n\t\t\tprintf(\"usb_transfer_complete: actlen > len %d > %d\\n\",\n\t\t\t       xfer->actlen, xfer->length);\n\t\t\txfer->actlen = xfer->length;\n\t\t}\n#endif\n\t\tmemcpy(xfer->buffer, KERNADDR(dmap), xfer->actlen);\n\t}\n\n\t/* if we allocated the buffer in usbd_transfer() we free it here. */\n\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\tif (!repeat) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\t\t\tbus->methods->freem(bus, dmap);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!repeat) {\n\t\t/* Remove request from queue. */\n#ifdef DIAGNOSTIC\n\t\tif (xfer != SIMPLEQ_FIRST(&pipe->queue))\n\t\t\tprintf(\"usb_transfer_complete: bad dequeue %p != %p\\n\",\n\t\t\t       xfer, SIMPLEQ_FIRST(&pipe->queue));\n#endif\n\t\tSIMPLEQ_REMOVE_HEAD(&pipe->queue, xfer, next);\n\t}\n\tDPRINTFN(5,(\"usb_transfer_complete: repeat=%d new head=%p\\n\", \n\t\t    repeat, SIMPLEQ_FIRST(&pipe->queue)));\n\n\t/* Count completed transfers. */\n\t++pipe->device->bus->stats.requests\n\t\t[pipe->endpoint->edesc->bmAttributes & UE_XFERTYPE];\n\n\txfer->done = 1;\n\tif (!xfer->status && xfer->actlen < xfer->length &&\n\t    !(xfer->flags & USBD_SHORT_XFER_OK)) {\n\t\tDPRINTFN(-1,(\"usbd_transfer_cb: short transfer %d<%d\\n\",\n\t\t\t     xfer->actlen, xfer->length));\n\t\txfer->status = USBD_SHORT_XFER;\n\t}\n\n\tif (xfer->callback)\n\t\txfer->callback(xfer, xfer->priv, xfer->status);\n\n#ifdef DIAGNOSTIC\n\tif (pipe->methods->done != NULL)\n\t\tpipe->methods->done(xfer);\n\telse\n\t\tprintf(\"usb_transfer_complete: pipe->methods->done == NULL\\n\");\n#else\n\tpipe->methods->done(xfer);\n#endif\n\n\tif ((xfer->flags & USBD_SYNCHRONOUS) && !polling)\n\t\twakeup(xfer);\n\n\tif (!repeat) {\n\t\t/* XXX should we stop the queue on all errors? */\n\t\tif ((xfer->status == USBD_CANCELLED ||\n\t\t     xfer->status == USBD_TIMEOUT) &&\n\t\t    pipe->iface != NULL)\t\t/* not control pipe */\n\t\t\tpipe->running = 0;\n\t\telse\n\t\t\tusbd_start_next(pipe);\n\t}\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "usb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;",
            "usb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);",
            "usb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_start_next __P((usbd_pipe_handle pipe));\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nusb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;\nusb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\nusb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;\n\nvoid\nusb_transfer_complete(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tint repeat = pipe->repeat;\n\tint polling;\n\n\tSPLUSBCHECK;\n\n\tDPRINTFN(5, (\"usb_transfer_complete: pipe=%p xfer=%p status=%d \"\n\t\t     \"actlen=%d\\n\", pipe, xfer, xfer->status, xfer->actlen));\n\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_transfer_cb: pipe==0, xfer=%p\\n\", xfer);\n\t\treturn;\n\t}\n#endif\n\tpolling = pipe->device->bus->use_polling;\n\t/* XXXX */\n\tif (polling)\n\t\tpipe->running = 0;\n\n\tif (!(xfer->flags & USBD_NO_COPY) && xfer->actlen != 0 &&\n\t    usbd_xfer_isread(xfer)) {\n#ifdef DIAGNOSTIC\n\t\tif (xfer->actlen > xfer->length) {\n\t\t\tprintf(\"usb_transfer_complete: actlen > len %d > %d\\n\",\n\t\t\t       xfer->actlen, xfer->length);\n\t\t\txfer->actlen = xfer->length;\n\t\t}\n#endif\n\t\tmemcpy(xfer->buffer, KERNADDR(dmap), xfer->actlen);\n\t}\n\n\t/* if we allocated the buffer in usbd_transfer() we free it here. */\n\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\tif (!repeat) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\t\t\tbus->methods->freem(bus, dmap);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!repeat) {\n\t\t/* Remove request from queue. */\n#ifdef DIAGNOSTIC\n\t\tif (xfer != SIMPLEQ_FIRST(&pipe->queue))\n\t\t\tprintf(\"usb_transfer_complete: bad dequeue %p != %p\\n\",\n\t\t\t       xfer, SIMPLEQ_FIRST(&pipe->queue));\n#endif\n\t\tSIMPLEQ_REMOVE_HEAD(&pipe->queue, xfer, next);\n\t}\n\tDPRINTFN(5,(\"usb_transfer_complete: repeat=%d new head=%p\\n\", \n\t\t    repeat, SIMPLEQ_FIRST(&pipe->queue)));\n\n\t/* Count completed transfers. */\n\t++pipe->device->bus->stats.requests\n\t\t[pipe->endpoint->edesc->bmAttributes & UE_XFERTYPE];\n\n\txfer->done = 1;\n\tif (!xfer->status && xfer->actlen < xfer->length &&\n\t    !(xfer->flags & USBD_SHORT_XFER_OK)) {\n\t\tDPRINTFN(-1,(\"usbd_transfer_cb: short transfer %d<%d\\n\",\n\t\t\t     xfer->actlen, xfer->length));\n\t\txfer->status = USBD_SHORT_XFER;\n\t}\n\n\tif (xfer->callback)\n\t\txfer->callback(xfer, xfer->priv, xfer->status);\n\n#ifdef DIAGNOSTIC\n\tif (pipe->methods->done != NULL)\n\t\tpipe->methods->done(xfer);\n\telse\n\t\tprintf(\"usb_transfer_complete: pipe->methods->done == NULL\\n\");\n#else\n\tpipe->methods->done(xfer);\n#endif\n\n\tif ((xfer->flags & USBD_SYNCHRONOUS) && !polling)\n\t\twakeup(xfer);\n\n\tif (!repeat) {\n\t\t/* XXX should we stop the queue on all errors? */\n\t\tif ((xfer->status == USBD_CANCELLED ||\n\t\t     xfer->status == USBD_TIMEOUT) &&\n\t\t    pipe->iface != NULL)\t\t/* not control pipe */\n\t\t\tpipe->running = 0;\n\t\telse\n\t\t\tusbd_start_next(pipe);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 2489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OWRITE4",
          "args": [
            "sc",
            "port",
            "UPS_PORT_POWER"
          ],
          "line": 2474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "2",
            "(\"ohci_root_ctrl_transfer: set port power \"\n\t\t\t\t    \"%d\\n\", index)"
          ],
          "line": 2472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "8",
            "(\"ohci port %d reset, status = 0x%04x\\n\",\n\t\t\t\t    index, OREAD4(sc, port))"
          ],
          "line": 2468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OREAD4",
          "args": [
            "sc",
            "port"
          ],
          "line": 2469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OREAD4",
          "args": [
            "sc",
            "port"
          ],
          "line": 2465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_delay_ms",
          "args": [
            "&sc->sc_bus",
            "10"
          ],
          "line": 2464
        },
        "resolved": true,
        "details": {
          "function_name": "usb_delay_ms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "301-313",
          "snippet": "void\nusb_delay_ms(bus, ms)\n\tusbd_bus_handle bus;\n\tu_int ms;\n{\n\textern int cold;\n\n\t/* Wait at least two clock ticks so we know the time has passed. */\n\tif (bus->use_polling || cold)\n\t\tdelay((ms+1) * 1000);\n\telse\n\t\ttsleep(&ms, PRIBIO, \"usbdly\", (ms*hz+999)/1000 + 1);\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_getnewaddr __P((usbd_bus_handle bus));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_getnewaddr __P((usbd_bus_handle bus));\n\nvoid\nusb_delay_ms(bus, ms)\n\tusbd_bus_handle bus;\n\tu_int ms;\n{\n\textern int cold;\n\n\t/* Wait at least two clock ticks so we know the time has passed. */\n\tif (bus->use_polling || cold)\n\t\tdelay((ms+1) * 1000);\n\telse\n\t\ttsleep(&ms, PRIBIO, \"usbdly\", (ms*hz+999)/1000 + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OWRITE4",
          "args": [
            "sc",
            "port",
            "UPS_RESET"
          ],
          "line": 2462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"ohci_root_ctrl_transfer: reset port %d\\n\",\n\t\t\t\t    index)"
          ],
          "line": 2460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OWRITE4",
          "args": [
            "sc",
            "port",
            "UPS_SUSPEND"
          ],
          "line": 2457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OWRITE4",
          "args": [
            "sc",
            "port",
            "UPS_PORT_ENABLED"
          ],
          "line": 2454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OHCI_RH_PORT_STATUS",
          "args": [
            "index"
          ],
          "line": 2451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "C",
          "args": [
            "UR_SET_FEATURE",
            "UT_WRITE_CLASS_OTHER"
          ],
          "line": 2446
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_printBCD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "266-272",
          "snippet": "int\nusbd_printBCD(cp, bcd)\n\tchar *cp;\n\tint bcd;\n{\n\treturn (sprintf(cp, \"%x.%02x\", bcd >> 8, bcd & 0xff));\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nusbd_printBCD(cp, bcd)\n\tchar *cp;\n\tint bcd;\n{\n\treturn (sprintf(cp, \"%x.%02x\", bcd >> 8, bcd & 0xff));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "&ps",
            "l"
          ],
          "line": 2438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "len",
            "sizeof ps"
          ],
          "line": 2437
        },
        "resolved": true,
        "details": {
          "function_name": "umass_scsipi_minphys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
          "lines": "3240-3247",
          "snippet": "Static void\numass_scsipi_minphys(bp)\n\tstruct buf *bp;\n{\n\tif (bp->b_bcount > UMASS_MAX_TRANSFER_SIZE)\n\t\tbp->b_bcount = UMASS_MAX_TRANSFER_SIZE;\n\tminphys(bp);\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/ata/atavar.h>\t/* XXX */",
            "#include <dev/scsipi/scsi_changer.h>",
            "#include <dev/scsipi/scsi_disk.h>",
            "#include <dev/scsipi/scsipi_disk.h>",
            "#include <dev/scsipi/atapiconf.h>",
            "#include <dev/scsipi/scsiconf.h>",
            "#include <dev/scsipi/scsipi_all.h>",
            "#include <dev/scsipi/scsi_all.h>",
            "#include <sys/scsiio.h>",
            "#include <cam/cam_periph.h>",
            "#include <sys/devicestat.h>",
            "#include <cam/scsi/scsi_da.h>",
            "#include <cam/scsi/scsi_all.h>",
            "#include <cam/cam_xpt_sim.h>",
            "#include <cam/cam_sim.h>",
            "#include <cam/cam_ccb.h>",
            "#include <cam/cam.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/clock.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/malloc.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"atapibus.h\""
          ],
          "macros_used": [
            "#define UMASS_MAX_TRANSFER_SIZE\tMAXBSIZE",
            "#define UMASS_MAX_TRANSFER_SIZE\t\t65536"
          ],
          "globals_used": [
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "Static void"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define UMASS_MAX_TRANSFER_SIZE\tMAXBSIZE\n#define UMASS_MAX_TRANSFER_SIZE\t\t65536\n\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\n\nStatic void\numass_scsipi_minphys(bp)\n\tstruct buf *bp;\n{\n\tif (bp->b_bcount > UMASS_MAX_TRANSFER_SIZE)\n\t\tbp->b_bcount = UMASS_MAX_TRANSFER_SIZE;\n\tminphys(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "ps.wPortChange",
            "v >> 16"
          ],
          "line": 2436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "ps.wPortStatus",
            "v"
          ],
          "line": 2435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "8",
            "(\"ohci_root_ctrl_transfer: port status=0x%04x\\n\",\n\t\t\t    v)"
          ],
          "line": 2433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OREAD4",
          "args": [
            "sc",
            "OHCI_RH_PORT_STATUS(index)"
          ],
          "line": 2432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OHCI_RH_PORT_STATUS",
          "args": [
            "index"
          ],
          "line": 2432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "8",
            "(\"ohci_root_ctrl_transfer: get port status i=%d\\n\",\n\t\t\t    index)"
          ],
          "line": 2422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buf",
            "0",
            "len"
          ],
          "line": 2418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "&hubd",
            "l"
          ],
          "line": 2411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OREAD4",
          "args": [
            "sc",
            "OHCI_RH_DESCRIPTOR_B"
          ],
          "line": 2405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OHCI_GET_POTPGT",
          "args": [
            "v"
          ],
          "line": 2404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "hubd.wHubCharacteristics",
            "(v & OHCI_NPS ? UHD_PWR_NO_SWITCH : \n\t\t       v & OHCI_PSM ? UHD_PWR_GANGED : UHD_PWR_INDIVIDUAL)/* XXX overcurrent */"
          ],
          "line": 2399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OREAD4",
          "args": [
            "sc",
            "OHCI_RH_DESCRIPTOR_A"
          ],
          "line": 2396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ohci_rhsc_able",
          "args": [
            "sc",
            "1"
          ],
          "line": 2385
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_rhsc_able",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "1122-1135",
          "snippet": "void\nohci_rhsc_able(sc, on)\n\tohci_softc_t *sc;\n\tint on;\n{\n\tDPRINTFN(4, (\"ohci_rhsc_able: on=%d\\n\", on));\n\tif (on) {\n\t\tsc->sc_eintrs |= OHCI_RHSC;\n\t\tOWRITE4(sc, OHCI_INTERRUPT_ENABLE, OHCI_RHSC);\n\t} else {\n\t\tsc->sc_eintrs &= ~OHCI_RHSC;\n\t\tOWRITE4(sc, OHCI_INTERRUPT_DISABLE, OHCI_RHSC);\n\t}\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "ohci_rhsc_able __P((ohci_softc_t *, int));",
            "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
            "ohci_intr1 __P((ohci_softc_t *));",
            "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nohci_rhsc_able __P((ohci_softc_t *, int));\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nvoid\nohci_rhsc_able(sc, on)\n\tohci_softc_t *sc;\n\tint on;\n{\n\tDPRINTFN(4, (\"ohci_rhsc_able: on=%d\\n\", on));\n\tif (on) {\n\t\tsc->sc_eintrs |= OHCI_RHSC;\n\t\tOWRITE4(sc, OHCI_INTERRUPT_ENABLE, OHCI_RHSC);\n\t} else {\n\t\tsc->sc_eintrs &= ~OHCI_RHSC;\n\t\tOWRITE4(sc, OHCI_INTERRUPT_DISABLE, OHCI_RHSC);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "OREAD4",
          "args": [
            "sc",
            "port"
          ],
          "line": 2384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OWRITE4",
          "args": [
            "sc",
            "port",
            "UPS_C_PORT_RESET << 16"
          ],
          "line": 2371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OWRITE4",
          "args": [
            "sc",
            "port",
            "UPS_C_OVERCURRENT_INDICATOR << 16"
          ],
          "line": 2368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OWRITE4",
          "args": [
            "sc",
            "port",
            "UPS_C_SUSPEND << 16"
          ],
          "line": 2365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OWRITE4",
          "args": [
            "sc",
            "port",
            "UPS_C_PORT_ENABLED << 16"
          ],
          "line": 2362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OWRITE4",
          "args": [
            "sc",
            "port",
            "UPS_C_CONNECT_STATUS << 16"
          ],
          "line": 2359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OWRITE4",
          "args": [
            "sc",
            "port",
            "UPS_LOW_SPEED"
          ],
          "line": 2356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OWRITE4",
          "args": [
            "sc",
            "port",
            "UPS_OVERCURRENT_INDICATOR"
          ],
          "line": 2353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OWRITE4",
          "args": [
            "sc",
            "port",
            "UPS_CURRENT_CONNECT_STATUS"
          ],
          "line": 2350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OHCI_RH_PORT_STATUS",
          "args": [
            "index"
          ],
          "line": 2347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "8",
            "(\"ohci_root_ctrl_control: UR_CLEAR_PORT_FEATURE \"\n\t\t\t     \"port=%d feature=%d\\n\",\n\t\t\t     index, value)"
          ],
          "line": 2340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "((usb_status_t *)buf)->wStatus",
            "0"
          ],
          "line": 2307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "((usb_status_t *)buf)->wStatus",
            "UDS_SELF_POWERED"
          ],
          "line": 2300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ohci_str",
          "args": [
            "buf",
            "len",
            "\"OHCI root hub\""
          ],
          "line": 2283
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "2155-2173",
          "snippet": "Static int\nohci_str(p, l, s)\n\tusb_string_descriptor_t *p;\n\tint l;\n\tchar *s;\n{\n\tint i;\n\n\tif (l == 0)\n\t\treturn (0);\n\tp->bLength = 2 * strlen(s) + 2;\n\tif (l == 1)\n\t\treturn (1);\n\tp->bDescriptorType = UDESC_STRING;\n\tl -= 2;\n\tfor (i = 0; s[i] && l > 1; i++, l -= 2)\n\t\tUSETW2(p->bString[i], 0, s[i]);\n\treturn (2*i+2);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static int",
            "ohci_str __P((usb_string_descriptor_t *, int, char *));",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static int"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nohci_str __P((usb_string_descriptor_t *, int, char *));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\n\nStatic int\nohci_str(p, l, s)\n\tusb_string_descriptor_t *p;\n\tint l;\n\tchar *s;\n{\n\tint i;\n\n\tif (l == 0)\n\t\treturn (0);\n\tp->bLength = 2 * strlen(s) + 2;\n\tif (l == 1)\n\t\treturn (1);\n\tp->bDescriptorType = UDESC_STRING;\n\tl -= 2;\n\tfor (i = 0; s[i] && l > 1; i++, l -= 2)\n\t\tUSETW2(p->bString[i], 0, s[i]);\n\treturn (2*i+2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "&ohci_endpd",
            "l"
          ],
          "line": 2271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "&ohci_ifcd",
            "l"
          ],
          "line": 2266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "&ohci_confd",
            "l"
          ],
          "line": 2261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "&ohci_devd",
            "l"
          ],
          "line": 2253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "ohci_devd.idVendor",
            "sc->sc_id_vendor"
          ],
          "line": 2252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "8",
            "(\"ohci_root_ctrl_control wValue=0x%04x\\n\", value)"
          ],
          "line": 2244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KERNADDR",
          "args": [
            "&xfer->dmabuf"
          ],
          "line": 2225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "req->wIndex"
          ],
          "line": 2222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "req->wValue"
          ],
          "line": 2221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "req->wLength"
          ],
          "line": 2220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "4",
            "(\"ohci_root_ctrl_control type=0x%02x request=%02x\\n\", \n\t\t    req->bmRequestType, req->bRequest)"
          ],
          "line": 2217
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nStatic void;\nStatic void;\nStatic usbd_status;\nStatic void;\nohci_shutdown __P((void *v));\nStatic void;\nStatic usbd_status;\nStatic void;\nStatic void;\nStatic void;\nohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));\nStatic usbd_status;\nohci_device_request __P((usbd_xfer_handle xfer));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic usbd_status;\nohci_setup_isoc __P((usbd_pipe_handle pipe));\nStatic void;\nohci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));\nStatic void;\nStatic usbd_xfer_handle;\nStatic void;\nohci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nStatic usbd_status;\nohci_root_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_ctrl_start __P((usbd_xfer_handle));\nStatic void;\nohci_root_ctrl_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_root_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_intr_start __P((usbd_xfer_handle));\nStatic void;\nohci_root_intr_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_root_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_ctrl_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_ctrl_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_bulk_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_bulk_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_bulk_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_bulk_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_intr_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_intr_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_isoc_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_isoc_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_isoc_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_isoc_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic int;\nStatic void;\nStatic void;\nohci_rhsc_able __P((ohci_softc_t *, int));\nStatic void;\nStatic void;\nohci_abort_xfer __P((usbd_xfer_handle xfer,\n\t\t\t    usbd_status status));\nStatic void;\nStatic void;\nohci_device_clear_toggle __P((usbd_pipe_handle pipe));\nStatic void;\nohci_noop __P((usbd_pipe_handle pipe));\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nStatic int;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\nStatic usb_device_descriptor_t ohci_devd = {\n\tUSB_DEVICE_DESCRIPTOR_SIZE,\n\tUDESC_DEVICE,\t\t/* type */\n\t{0x00, 0x01},\t\t/* USB version */\n\tUDCLASS_HUB,\t\t/* class */\n\tUDSUBCLASS_HUB,\t\t/* subclass */\n\t0,\t\t\t/* protocol */\n\t64,\t\t\t/* max packet */\n\t{0},{0},{0x00,0x01},\t/* device id */\n\t1,2,0,\t\t\t/* string indicies */\n\t1\t\t\t/* # of configurations */\n};\nStatic usb_config_descriptor_t ohci_confd = {\n\tUSB_CONFIG_DESCRIPTOR_SIZE,\n\tUDESC_CONFIG,\n\t{USB_CONFIG_DESCRIPTOR_SIZE +\n\t USB_INTERFACE_DESCRIPTOR_SIZE +\n\t USB_ENDPOINT_DESCRIPTOR_SIZE},\n\t1,\n\t1,\n\t0,\n\tUC_SELF_POWERED,\n\t0\t\t\t/* max power */\n};\nStatic usb_interface_descriptor_t ohci_ifcd = {\n\tUSB_INTERFACE_DESCRIPTOR_SIZE,\n\tUDESC_INTERFACE,\n\t0,\n\t0,\n\t1,\n\tUICLASS_HUB,\n\tUISUBCLASS_HUB,\n\t0,\n\t0\n};\nStatic usb_endpoint_descriptor_t ohci_endpd = {\n\tUSB_ENDPOINT_DESCRIPTOR_SIZE,\n\tUDESC_ENDPOINT,\n\tUE_DIR_IN | OHCI_INTR_ENDPT,\n\tUE_INTERRUPT,\n\t{8, 0},\t\t\t/* max packet */\n\t255\n};\nStatic usb_hub_descriptor_t ohci_hubd = {\n\tUSB_HUB_DESCRIPTOR_SIZE,\n\tUDESC_HUB,\n\t0,\n\t{0,0},\n\t0,\n\t0,\n\t{0},\n};\n\nStatic usbd_status\nohci_root_ctrl_start(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tohci_softc_t *sc = (ohci_softc_t *)xfer->pipe->device->bus;\n\tusb_device_request_t *req;\n\tvoid *buf = NULL;\n\tint port, i;\n\tint s, len, value, index, l, totlen = 0;\n\tusb_port_status_t ps;\n\tusb_hub_descriptor_t hubd;\n\tusbd_status err;\n\tu_int32_t v;\n\n\tif (sc->sc_dying)\n\t\treturn (USBD_IOERROR);\n\n#ifdef DIAGNOSTIC\n\tif (!(xfer->rqflags & URQ_REQUEST))\n\t\t/* XXX panic */\n\t\treturn (USBD_INVAL);\n#endif\n\treq = &xfer->request;\n\n\tDPRINTFN(4,(\"ohci_root_ctrl_control type=0x%02x request=%02x\\n\", \n\t\t    req->bmRequestType, req->bRequest));\n\n\tlen = UGETW(req->wLength);\n\tvalue = UGETW(req->wValue);\n\tindex = UGETW(req->wIndex);\n\n\tif (len != 0)\n\t\tbuf = KERNADDR(&xfer->dmabuf);\n\n#define C(x,y) ((x) | ((y) << 8))\n\tswitch(C(req->bRequest, req->bmRequestType)) {\n\tcase C(UR_CLEAR_FEATURE, UT_WRITE_DEVICE):\n\tcase C(UR_CLEAR_FEATURE, UT_WRITE_INTERFACE):\n\tcase C(UR_CLEAR_FEATURE, UT_WRITE_ENDPOINT):\n\t\t/* \n\t\t * DEVICE_REMOTE_WAKEUP and ENDPOINT_HALT are no-ops\n\t\t * for the integrated root hub.\n\t\t */\n\t\tbreak;\n\tcase C(UR_GET_CONFIG, UT_READ_DEVICE):\n\t\tif (len > 0) {\n\t\t\t*(u_int8_t *)buf = sc->sc_conf;\n\t\t\ttotlen = 1;\n\t\t}\n\t\tbreak;\n\tcase C(UR_GET_DESCRIPTOR, UT_READ_DEVICE):\n\t\tDPRINTFN(8,(\"ohci_root_ctrl_control wValue=0x%04x\\n\", value));\n\t\tswitch(value >> 8) {\n\t\tcase UDESC_DEVICE:\n\t\t\tif ((value & 0xff) != 0) {\n\t\t\t\terr = USBD_IOERROR;\n\t\t\t\tgoto ret;\n\t\t\t}\n\t\t\ttotlen = l = min(len, USB_DEVICE_DESCRIPTOR_SIZE);\n\t\t\tUSETW(ohci_devd.idVendor, sc->sc_id_vendor);\n\t\t\tmemcpy(buf, &ohci_devd, l);\n\t\t\tbreak;\n\t\tcase UDESC_CONFIG:\n\t\t\tif ((value & 0xff) != 0) {\n\t\t\t\terr = USBD_IOERROR;\n\t\t\t\tgoto ret;\n\t\t\t}\n\t\t\ttotlen = l = min(len, USB_CONFIG_DESCRIPTOR_SIZE);\n\t\t\tmemcpy(buf, &ohci_confd, l);\n\t\t\tbuf = (char *)buf + l;\n\t\t\tlen -= l;\n\t\t\tl = min(len, USB_INTERFACE_DESCRIPTOR_SIZE);\n\t\t\ttotlen += l;\n\t\t\tmemcpy(buf, &ohci_ifcd, l);\n\t\t\tbuf = (char *)buf + l;\n\t\t\tlen -= l;\n\t\t\tl = min(len, USB_ENDPOINT_DESCRIPTOR_SIZE);\n\t\t\ttotlen += l;\n\t\t\tmemcpy(buf, &ohci_endpd, l);\n\t\t\tbreak;\n\t\tcase UDESC_STRING:\n\t\t\tif (len == 0)\n\t\t\t\tbreak;\n\t\t\t*(u_int8_t *)buf = 0;\n\t\t\ttotlen = 1;\n\t\t\tswitch (value & 0xff) {\n\t\t\tcase 1: /* Vendor */\n\t\t\t\ttotlen = ohci_str(buf, len, sc->sc_vendor);\n\t\t\t\tbreak;\n\t\t\tcase 2: /* Product */\n\t\t\t\ttotlen = ohci_str(buf, len, \"OHCI root hub\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tbreak;\n\tcase C(UR_GET_INTERFACE, UT_READ_INTERFACE):\n\t\tif (len > 0) {\n\t\t\t*(u_int8_t *)buf = 0;\n\t\t\ttotlen = 1;\n\t\t}\n\t\tbreak;\n\tcase C(UR_GET_STATUS, UT_READ_DEVICE):\n\t\tif (len > 1) {\n\t\t\tUSETW(((usb_status_t *)buf)->wStatus,UDS_SELF_POWERED);\n\t\t\ttotlen = 2;\n\t\t}\n\t\tbreak;\n\tcase C(UR_GET_STATUS, UT_READ_INTERFACE):\n\tcase C(UR_GET_STATUS, UT_READ_ENDPOINT):\n\t\tif (len > 1) {\n\t\t\tUSETW(((usb_status_t *)buf)->wStatus, 0);\n\t\t\ttotlen = 2;\n\t\t}\n\t\tbreak;\n\tcase C(UR_SET_ADDRESS, UT_WRITE_DEVICE):\n\t\tif (value >= USB_MAX_DEVICES) {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tsc->sc_addr = value;\n\t\tbreak;\n\tcase C(UR_SET_CONFIG, UT_WRITE_DEVICE):\n\t\tif (value != 0 && value != 1) {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tsc->sc_conf = value;\n\t\tbreak;\n\tcase C(UR_SET_DESCRIPTOR, UT_WRITE_DEVICE):\n\t\tbreak;\n\tcase C(UR_SET_FEATURE, UT_WRITE_DEVICE):\n\tcase C(UR_SET_FEATURE, UT_WRITE_INTERFACE):\n\tcase C(UR_SET_FEATURE, UT_WRITE_ENDPOINT):\n\t\terr = USBD_IOERROR;\n\t\tgoto ret;\n\tcase C(UR_SET_INTERFACE, UT_WRITE_INTERFACE):\n\t\tbreak;\n\tcase C(UR_SYNCH_FRAME, UT_WRITE_ENDPOINT):\n\t\tbreak;\n\t/* Hub requests */\n\tcase C(UR_CLEAR_FEATURE, UT_WRITE_CLASS_DEVICE):\n\t\tbreak;\n\tcase C(UR_CLEAR_FEATURE, UT_WRITE_CLASS_OTHER):\n\t\tDPRINTFN(8, (\"ohci_root_ctrl_control: UR_CLEAR_PORT_FEATURE \"\n\t\t\t     \"port=%d feature=%d\\n\",\n\t\t\t     index, value));\n\t\tif (index < 1 || index > sc->sc_noport) {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tport = OHCI_RH_PORT_STATUS(index);\n\t\tswitch(value) {\n\t\tcase UHF_PORT_ENABLE:\n\t\t\tOWRITE4(sc, port, UPS_CURRENT_CONNECT_STATUS);\n\t\t\tbreak;\n\t\tcase UHF_PORT_SUSPEND:\n\t\t\tOWRITE4(sc, port, UPS_OVERCURRENT_INDICATOR);\n\t\t\tbreak;\n\t\tcase UHF_PORT_POWER:\n\t\t\tOWRITE4(sc, port, UPS_LOW_SPEED);\n\t\t\tbreak;\n\t\tcase UHF_C_PORT_CONNECTION:\n\t\t\tOWRITE4(sc, port, UPS_C_CONNECT_STATUS << 16);\n\t\t\tbreak;\n\t\tcase UHF_C_PORT_ENABLE:\n\t\t\tOWRITE4(sc, port, UPS_C_PORT_ENABLED << 16);\n\t\t\tbreak;\n\t\tcase UHF_C_PORT_SUSPEND:\n\t\t\tOWRITE4(sc, port, UPS_C_SUSPEND << 16);\n\t\t\tbreak;\n\t\tcase UHF_C_PORT_OVER_CURRENT:\n\t\t\tOWRITE4(sc, port, UPS_C_OVERCURRENT_INDICATOR << 16);\n\t\t\tbreak;\n\t\tcase UHF_C_PORT_RESET:\n\t\t\tOWRITE4(sc, port, UPS_C_PORT_RESET << 16);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tswitch(value) {\n\t\tcase UHF_C_PORT_CONNECTION:\n\t\tcase UHF_C_PORT_ENABLE:\n\t\tcase UHF_C_PORT_SUSPEND:\n\t\tcase UHF_C_PORT_OVER_CURRENT:\n\t\tcase UHF_C_PORT_RESET:\n\t\t\t/* Enable RHSC interrupt if condition is cleared. */\n\t\t\tif ((OREAD4(sc, port) >> 16) == 0)\n\t\t\t\tohci_rhsc_able(sc, 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase C(UR_GET_DESCRIPTOR, UT_READ_CLASS_DEVICE):\n\t\tif (value != 0) {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tv = OREAD4(sc, OHCI_RH_DESCRIPTOR_A);\n\t\thubd = ohci_hubd;\n\t\thubd.bNbrPorts = sc->sc_noport;\n\t\tUSETW(hubd.wHubCharacteristics,\n\t\t      (v & OHCI_NPS ? UHD_PWR_NO_SWITCH : \n\t\t       v & OHCI_PSM ? UHD_PWR_GANGED : UHD_PWR_INDIVIDUAL)\n\t\t      /* XXX overcurrent */\n\t\t      );\n\t\thubd.bPwrOn2PwrGood = OHCI_GET_POTPGT(v);\n\t\tv = OREAD4(sc, OHCI_RH_DESCRIPTOR_B);\n\t\tfor (i = 0, l = sc->sc_noport; l > 0; i++, l -= 8, v >>= 8) \n\t\t\thubd.DeviceRemovable[i++] = (u_int8_t)v;\n\t\thubd.bDescLength = USB_HUB_DESCRIPTOR_SIZE + i;\n\t\tl = min(len, hubd.bDescLength);\n\t\ttotlen = l;\n\t\tmemcpy(buf, &hubd, l);\n\t\tbreak;\n\tcase C(UR_GET_STATUS, UT_READ_CLASS_DEVICE):\n\t\tif (len != 4) {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tmemset(buf, 0, len); /* ? XXX */\n\t\ttotlen = len;\n\t\tbreak;\n\tcase C(UR_GET_STATUS, UT_READ_CLASS_OTHER):\n\t\tDPRINTFN(8,(\"ohci_root_ctrl_transfer: get port status i=%d\\n\",\n\t\t\t    index));\n\t\tif (index < 1 || index > sc->sc_noport) {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tif (len != 4) {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tv = OREAD4(sc, OHCI_RH_PORT_STATUS(index));\n\t\tDPRINTFN(8,(\"ohci_root_ctrl_transfer: port status=0x%04x\\n\",\n\t\t\t    v));\n\t\tUSETW(ps.wPortStatus, v);\n\t\tUSETW(ps.wPortChange, v >> 16);\n\t\tl = min(len, sizeof ps);\n\t\tmemcpy(buf, &ps, l);\n\t\ttotlen = l;\n\t\tbreak;\n\tcase C(UR_SET_DESCRIPTOR, UT_WRITE_CLASS_DEVICE):\n\t\terr = USBD_IOERROR;\n\t\tgoto ret;\n\tcase C(UR_SET_FEATURE, UT_WRITE_CLASS_DEVICE):\n\t\tbreak;\n\tcase C(UR_SET_FEATURE, UT_WRITE_CLASS_OTHER):\n\t\tif (index < 1 || index > sc->sc_noport) {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tport = OHCI_RH_PORT_STATUS(index);\n\t\tswitch(value) {\n\t\tcase UHF_PORT_ENABLE:\n\t\t\tOWRITE4(sc, port, UPS_PORT_ENABLED);\n\t\t\tbreak;\n\t\tcase UHF_PORT_SUSPEND:\n\t\t\tOWRITE4(sc, port, UPS_SUSPEND);\n\t\t\tbreak;\n\t\tcase UHF_PORT_RESET:\n\t\t\tDPRINTFN(5,(\"ohci_root_ctrl_transfer: reset port %d\\n\",\n\t\t\t\t    index));\n\t\t\tOWRITE4(sc, port, UPS_RESET);\n\t\t\tfor (i = 0; i < 10; i++) {\n\t\t\t\tusb_delay_ms(&sc->sc_bus, 10);\n\t\t\t\tif ((OREAD4(sc, port) & UPS_RESET) == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tDPRINTFN(8,(\"ohci port %d reset, status = 0x%04x\\n\",\n\t\t\t\t    index, OREAD4(sc, port)));\n\t\t\tbreak;\n\t\tcase UHF_PORT_POWER:\n\t\t\tDPRINTFN(2,(\"ohci_root_ctrl_transfer: set port power \"\n\t\t\t\t    \"%d\\n\", index));\n\t\t\tOWRITE4(sc, port, UPS_PORT_POWER);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\terr = USBD_IOERROR;\n\t\tgoto ret;\n\t}\n\txfer->actlen = totlen;\n\terr = USBD_NORMAL_COMPLETION;\n ret:\n\txfer->status = err;\n\ts = splusb();\n\tusb_transfer_complete(xfer);\n\tsplx(s);\n\treturn (USBD_IN_PROGRESS);\n}"
  },
  {
    "function_name": "ohci_root_ctrl_transfer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "2178-2191",
    "snippet": "Static usbd_status\nohci_root_ctrl_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_status err;\n\n\t/* Insert last in queue. */\n\terr = usb_insert_transfer(xfer);\n\tif (err)\n\t\treturn (err);\n\n\t/* Pipe isn't running, start first */\n\treturn (ohci_root_ctrl_start(SIMPLEQ_FIRST(&xfer->pipe->queue)));\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static void",
      "Static void",
      "Static void",
      "Static usbd_status",
      "Static void",
      "Static void",
      "Static usbd_status",
      "Static void",
      "Static void",
      "Static void",
      "ohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_request __P((usbd_xfer_handle xfer));",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static usbd_status",
      "ohci_setup_isoc __P((usbd_pipe_handle pipe));",
      "Static void",
      "ohci_device_isoc_enter __P((usbd_xfer_handle));",
      "Static usbd_status",
      "Static void",
      "Static usbd_xfer_handle",
      "Static void",
      "ohci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_root_ctrl_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_root_ctrl_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_root_ctrl_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_root_intr_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_root_intr_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_root_intr_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_root_intr_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_ctrl_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_device_ctrl_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_device_ctrl_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_bulk_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_bulk_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_device_bulk_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_device_bulk_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_intr_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_intr_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_device_intr_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_device_intr_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_isoc_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_isoc_start __P((usbd_xfer_handle));",
      "Static void",
      "ohci_device_isoc_abort __P((usbd_xfer_handle));",
      "Static void",
      "Static void",
      "ohci_device_isoc_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "Static int",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "ohci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "Static void",
      "ohci_noop __P((usbd_pipe_handle pipe));",
      "Static int"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ohci_root_ctrl_start",
          "args": [
            "SIMPLEQ_FIRST(&xfer->pipe->queue)"
          ],
          "line": 2190
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_root_ctrl_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "2193-2493",
          "snippet": "Static usbd_status\nohci_root_ctrl_start(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tohci_softc_t *sc = (ohci_softc_t *)xfer->pipe->device->bus;\n\tusb_device_request_t *req;\n\tvoid *buf = NULL;\n\tint port, i;\n\tint s, len, value, index, l, totlen = 0;\n\tusb_port_status_t ps;\n\tusb_hub_descriptor_t hubd;\n\tusbd_status err;\n\tu_int32_t v;\n\n\tif (sc->sc_dying)\n\t\treturn (USBD_IOERROR);\n\n#ifdef DIAGNOSTIC\n\tif (!(xfer->rqflags & URQ_REQUEST))\n\t\t/* XXX panic */\n\t\treturn (USBD_INVAL);\n#endif\n\treq = &xfer->request;\n\n\tDPRINTFN(4,(\"ohci_root_ctrl_control type=0x%02x request=%02x\\n\", \n\t\t    req->bmRequestType, req->bRequest));\n\n\tlen = UGETW(req->wLength);\n\tvalue = UGETW(req->wValue);\n\tindex = UGETW(req->wIndex);\n\n\tif (len != 0)\n\t\tbuf = KERNADDR(&xfer->dmabuf);\n\n#define C(x,y) ((x) | ((y) << 8))\n\tswitch(C(req->bRequest, req->bmRequestType)) {\n\tcase C(UR_CLEAR_FEATURE, UT_WRITE_DEVICE):\n\tcase C(UR_CLEAR_FEATURE, UT_WRITE_INTERFACE):\n\tcase C(UR_CLEAR_FEATURE, UT_WRITE_ENDPOINT):\n\t\t/* \n\t\t * DEVICE_REMOTE_WAKEUP and ENDPOINT_HALT are no-ops\n\t\t * for the integrated root hub.\n\t\t */\n\t\tbreak;\n\tcase C(UR_GET_CONFIG, UT_READ_DEVICE):\n\t\tif (len > 0) {\n\t\t\t*(u_int8_t *)buf = sc->sc_conf;\n\t\t\ttotlen = 1;\n\t\t}\n\t\tbreak;\n\tcase C(UR_GET_DESCRIPTOR, UT_READ_DEVICE):\n\t\tDPRINTFN(8,(\"ohci_root_ctrl_control wValue=0x%04x\\n\", value));\n\t\tswitch(value >> 8) {\n\t\tcase UDESC_DEVICE:\n\t\t\tif ((value & 0xff) != 0) {\n\t\t\t\terr = USBD_IOERROR;\n\t\t\t\tgoto ret;\n\t\t\t}\n\t\t\ttotlen = l = min(len, USB_DEVICE_DESCRIPTOR_SIZE);\n\t\t\tUSETW(ohci_devd.idVendor, sc->sc_id_vendor);\n\t\t\tmemcpy(buf, &ohci_devd, l);\n\t\t\tbreak;\n\t\tcase UDESC_CONFIG:\n\t\t\tif ((value & 0xff) != 0) {\n\t\t\t\terr = USBD_IOERROR;\n\t\t\t\tgoto ret;\n\t\t\t}\n\t\t\ttotlen = l = min(len, USB_CONFIG_DESCRIPTOR_SIZE);\n\t\t\tmemcpy(buf, &ohci_confd, l);\n\t\t\tbuf = (char *)buf + l;\n\t\t\tlen -= l;\n\t\t\tl = min(len, USB_INTERFACE_DESCRIPTOR_SIZE);\n\t\t\ttotlen += l;\n\t\t\tmemcpy(buf, &ohci_ifcd, l);\n\t\t\tbuf = (char *)buf + l;\n\t\t\tlen -= l;\n\t\t\tl = min(len, USB_ENDPOINT_DESCRIPTOR_SIZE);\n\t\t\ttotlen += l;\n\t\t\tmemcpy(buf, &ohci_endpd, l);\n\t\t\tbreak;\n\t\tcase UDESC_STRING:\n\t\t\tif (len == 0)\n\t\t\t\tbreak;\n\t\t\t*(u_int8_t *)buf = 0;\n\t\t\ttotlen = 1;\n\t\t\tswitch (value & 0xff) {\n\t\t\tcase 1: /* Vendor */\n\t\t\t\ttotlen = ohci_str(buf, len, sc->sc_vendor);\n\t\t\t\tbreak;\n\t\t\tcase 2: /* Product */\n\t\t\t\ttotlen = ohci_str(buf, len, \"OHCI root hub\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tbreak;\n\tcase C(UR_GET_INTERFACE, UT_READ_INTERFACE):\n\t\tif (len > 0) {\n\t\t\t*(u_int8_t *)buf = 0;\n\t\t\ttotlen = 1;\n\t\t}\n\t\tbreak;\n\tcase C(UR_GET_STATUS, UT_READ_DEVICE):\n\t\tif (len > 1) {\n\t\t\tUSETW(((usb_status_t *)buf)->wStatus,UDS_SELF_POWERED);\n\t\t\ttotlen = 2;\n\t\t}\n\t\tbreak;\n\tcase C(UR_GET_STATUS, UT_READ_INTERFACE):\n\tcase C(UR_GET_STATUS, UT_READ_ENDPOINT):\n\t\tif (len > 1) {\n\t\t\tUSETW(((usb_status_t *)buf)->wStatus, 0);\n\t\t\ttotlen = 2;\n\t\t}\n\t\tbreak;\n\tcase C(UR_SET_ADDRESS, UT_WRITE_DEVICE):\n\t\tif (value >= USB_MAX_DEVICES) {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tsc->sc_addr = value;\n\t\tbreak;\n\tcase C(UR_SET_CONFIG, UT_WRITE_DEVICE):\n\t\tif (value != 0 && value != 1) {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tsc->sc_conf = value;\n\t\tbreak;\n\tcase C(UR_SET_DESCRIPTOR, UT_WRITE_DEVICE):\n\t\tbreak;\n\tcase C(UR_SET_FEATURE, UT_WRITE_DEVICE):\n\tcase C(UR_SET_FEATURE, UT_WRITE_INTERFACE):\n\tcase C(UR_SET_FEATURE, UT_WRITE_ENDPOINT):\n\t\terr = USBD_IOERROR;\n\t\tgoto ret;\n\tcase C(UR_SET_INTERFACE, UT_WRITE_INTERFACE):\n\t\tbreak;\n\tcase C(UR_SYNCH_FRAME, UT_WRITE_ENDPOINT):\n\t\tbreak;\n\t/* Hub requests */\n\tcase C(UR_CLEAR_FEATURE, UT_WRITE_CLASS_DEVICE):\n\t\tbreak;\n\tcase C(UR_CLEAR_FEATURE, UT_WRITE_CLASS_OTHER):\n\t\tDPRINTFN(8, (\"ohci_root_ctrl_control: UR_CLEAR_PORT_FEATURE \"\n\t\t\t     \"port=%d feature=%d\\n\",\n\t\t\t     index, value));\n\t\tif (index < 1 || index > sc->sc_noport) {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tport = OHCI_RH_PORT_STATUS(index);\n\t\tswitch(value) {\n\t\tcase UHF_PORT_ENABLE:\n\t\t\tOWRITE4(sc, port, UPS_CURRENT_CONNECT_STATUS);\n\t\t\tbreak;\n\t\tcase UHF_PORT_SUSPEND:\n\t\t\tOWRITE4(sc, port, UPS_OVERCURRENT_INDICATOR);\n\t\t\tbreak;\n\t\tcase UHF_PORT_POWER:\n\t\t\tOWRITE4(sc, port, UPS_LOW_SPEED);\n\t\t\tbreak;\n\t\tcase UHF_C_PORT_CONNECTION:\n\t\t\tOWRITE4(sc, port, UPS_C_CONNECT_STATUS << 16);\n\t\t\tbreak;\n\t\tcase UHF_C_PORT_ENABLE:\n\t\t\tOWRITE4(sc, port, UPS_C_PORT_ENABLED << 16);\n\t\t\tbreak;\n\t\tcase UHF_C_PORT_SUSPEND:\n\t\t\tOWRITE4(sc, port, UPS_C_SUSPEND << 16);\n\t\t\tbreak;\n\t\tcase UHF_C_PORT_OVER_CURRENT:\n\t\t\tOWRITE4(sc, port, UPS_C_OVERCURRENT_INDICATOR << 16);\n\t\t\tbreak;\n\t\tcase UHF_C_PORT_RESET:\n\t\t\tOWRITE4(sc, port, UPS_C_PORT_RESET << 16);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tswitch(value) {\n\t\tcase UHF_C_PORT_CONNECTION:\n\t\tcase UHF_C_PORT_ENABLE:\n\t\tcase UHF_C_PORT_SUSPEND:\n\t\tcase UHF_C_PORT_OVER_CURRENT:\n\t\tcase UHF_C_PORT_RESET:\n\t\t\t/* Enable RHSC interrupt if condition is cleared. */\n\t\t\tif ((OREAD4(sc, port) >> 16) == 0)\n\t\t\t\tohci_rhsc_able(sc, 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase C(UR_GET_DESCRIPTOR, UT_READ_CLASS_DEVICE):\n\t\tif (value != 0) {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tv = OREAD4(sc, OHCI_RH_DESCRIPTOR_A);\n\t\thubd = ohci_hubd;\n\t\thubd.bNbrPorts = sc->sc_noport;\n\t\tUSETW(hubd.wHubCharacteristics,\n\t\t      (v & OHCI_NPS ? UHD_PWR_NO_SWITCH : \n\t\t       v & OHCI_PSM ? UHD_PWR_GANGED : UHD_PWR_INDIVIDUAL)\n\t\t      /* XXX overcurrent */\n\t\t      );\n\t\thubd.bPwrOn2PwrGood = OHCI_GET_POTPGT(v);\n\t\tv = OREAD4(sc, OHCI_RH_DESCRIPTOR_B);\n\t\tfor (i = 0, l = sc->sc_noport; l > 0; i++, l -= 8, v >>= 8) \n\t\t\thubd.DeviceRemovable[i++] = (u_int8_t)v;\n\t\thubd.bDescLength = USB_HUB_DESCRIPTOR_SIZE + i;\n\t\tl = min(len, hubd.bDescLength);\n\t\ttotlen = l;\n\t\tmemcpy(buf, &hubd, l);\n\t\tbreak;\n\tcase C(UR_GET_STATUS, UT_READ_CLASS_DEVICE):\n\t\tif (len != 4) {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tmemset(buf, 0, len); /* ? XXX */\n\t\ttotlen = len;\n\t\tbreak;\n\tcase C(UR_GET_STATUS, UT_READ_CLASS_OTHER):\n\t\tDPRINTFN(8,(\"ohci_root_ctrl_transfer: get port status i=%d\\n\",\n\t\t\t    index));\n\t\tif (index < 1 || index > sc->sc_noport) {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tif (len != 4) {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tv = OREAD4(sc, OHCI_RH_PORT_STATUS(index));\n\t\tDPRINTFN(8,(\"ohci_root_ctrl_transfer: port status=0x%04x\\n\",\n\t\t\t    v));\n\t\tUSETW(ps.wPortStatus, v);\n\t\tUSETW(ps.wPortChange, v >> 16);\n\t\tl = min(len, sizeof ps);\n\t\tmemcpy(buf, &ps, l);\n\t\ttotlen = l;\n\t\tbreak;\n\tcase C(UR_SET_DESCRIPTOR, UT_WRITE_CLASS_DEVICE):\n\t\terr = USBD_IOERROR;\n\t\tgoto ret;\n\tcase C(UR_SET_FEATURE, UT_WRITE_CLASS_DEVICE):\n\t\tbreak;\n\tcase C(UR_SET_FEATURE, UT_WRITE_CLASS_OTHER):\n\t\tif (index < 1 || index > sc->sc_noport) {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tport = OHCI_RH_PORT_STATUS(index);\n\t\tswitch(value) {\n\t\tcase UHF_PORT_ENABLE:\n\t\t\tOWRITE4(sc, port, UPS_PORT_ENABLED);\n\t\t\tbreak;\n\t\tcase UHF_PORT_SUSPEND:\n\t\t\tOWRITE4(sc, port, UPS_SUSPEND);\n\t\t\tbreak;\n\t\tcase UHF_PORT_RESET:\n\t\t\tDPRINTFN(5,(\"ohci_root_ctrl_transfer: reset port %d\\n\",\n\t\t\t\t    index));\n\t\t\tOWRITE4(sc, port, UPS_RESET);\n\t\t\tfor (i = 0; i < 10; i++) {\n\t\t\t\tusb_delay_ms(&sc->sc_bus, 10);\n\t\t\t\tif ((OREAD4(sc, port) & UPS_RESET) == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tDPRINTFN(8,(\"ohci port %d reset, status = 0x%04x\\n\",\n\t\t\t\t    index, OREAD4(sc, port)));\n\t\t\tbreak;\n\t\tcase UHF_PORT_POWER:\n\t\t\tDPRINTFN(2,(\"ohci_root_ctrl_transfer: set port power \"\n\t\t\t\t    \"%d\\n\", index));\n\t\t\tOWRITE4(sc, port, UPS_PORT_POWER);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\terr = USBD_IOERROR;\n\t\tgoto ret;\n\t}\n\txfer->actlen = totlen;\n\terr = USBD_NORMAL_COMPLETION;\n ret:\n\txfer->status = err;\n\ts = splusb();\n\tusb_transfer_complete(xfer);\n\tsplx(s);\n\treturn (USBD_IN_PROGRESS);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static void",
            "Static void",
            "Static void",
            "Static usbd_status",
            "Static void",
            "ohci_shutdown __P((void *v));",
            "Static void",
            "Static usbd_status",
            "Static void",
            "Static void",
            "Static void",
            "ohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));",
            "Static void",
            "Static void",
            "ohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_request __P((usbd_xfer_handle xfer));",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static usbd_status",
            "ohci_setup_isoc __P((usbd_pipe_handle pipe));",
            "Static void",
            "ohci_device_isoc_enter __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));",
            "Static void",
            "Static usbd_xfer_handle",
            "Static void",
            "ohci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_root_ctrl_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_root_ctrl_start __P((usbd_xfer_handle));",
            "Static void",
            "ohci_root_ctrl_abort __P((usbd_xfer_handle));",
            "Static void",
            "Static void",
            "ohci_root_ctrl_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_root_intr_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_root_intr_start __P((usbd_xfer_handle));",
            "Static void",
            "ohci_root_intr_abort __P((usbd_xfer_handle));",
            "Static void",
            "Static void",
            "ohci_root_intr_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_ctrl_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_ctrl_start __P((usbd_xfer_handle));",
            "Static void",
            "ohci_device_ctrl_abort __P((usbd_xfer_handle));",
            "Static void",
            "Static void",
            "ohci_device_ctrl_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_bulk_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_bulk_start __P((usbd_xfer_handle));",
            "Static void",
            "ohci_device_bulk_abort __P((usbd_xfer_handle));",
            "Static void",
            "Static void",
            "ohci_device_bulk_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_intr_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_intr_start __P((usbd_xfer_handle));",
            "Static void",
            "ohci_device_intr_abort __P((usbd_xfer_handle));",
            "Static void",
            "Static void",
            "ohci_device_intr_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_isoc_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_isoc_start __P((usbd_xfer_handle));",
            "Static void",
            "ohci_device_isoc_abort __P((usbd_xfer_handle));",
            "Static void",
            "Static void",
            "ohci_device_isoc_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "Static int",
            "Static void",
            "Static void",
            "ohci_rhsc_able __P((ohci_softc_t *, int));",
            "Static void",
            "Static void",
            "ohci_abort_xfer __P((usbd_xfer_handle xfer,\n\t\t\t    usbd_status status));",
            "Static void",
            "Static void",
            "ohci_device_clear_toggle __P((usbd_pipe_handle pipe));",
            "Static void",
            "ohci_noop __P((usbd_pipe_handle pipe));",
            "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
            "Static int",
            "ohci_intr1 __P((ohci_softc_t *));",
            "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;",
            "Static usb_device_descriptor_t ohci_devd = {\n\tUSB_DEVICE_DESCRIPTOR_SIZE,\n\tUDESC_DEVICE,\t\t/* type */\n\t{0x00, 0x01},\t\t/* USB version */\n\tUDCLASS_HUB,\t\t/* class */\n\tUDSUBCLASS_HUB,\t\t/* subclass */\n\t0,\t\t\t/* protocol */\n\t64,\t\t\t/* max packet */\n\t{0},{0},{0x00,0x01},\t/* device id */\n\t1,2,0,\t\t\t/* string indicies */\n\t1\t\t\t/* # of configurations */\n};",
            "Static usb_config_descriptor_t ohci_confd = {\n\tUSB_CONFIG_DESCRIPTOR_SIZE,\n\tUDESC_CONFIG,\n\t{USB_CONFIG_DESCRIPTOR_SIZE +\n\t USB_INTERFACE_DESCRIPTOR_SIZE +\n\t USB_ENDPOINT_DESCRIPTOR_SIZE},\n\t1,\n\t1,\n\t0,\n\tUC_SELF_POWERED,\n\t0\t\t\t/* max power */\n};",
            "Static usb_interface_descriptor_t ohci_ifcd = {\n\tUSB_INTERFACE_DESCRIPTOR_SIZE,\n\tUDESC_INTERFACE,\n\t0,\n\t0,\n\t1,\n\tUICLASS_HUB,\n\tUISUBCLASS_HUB,\n\t0,\n\t0\n};",
            "Static usb_endpoint_descriptor_t ohci_endpd = {\n\tUSB_ENDPOINT_DESCRIPTOR_SIZE,\n\tUDESC_ENDPOINT,\n\tUE_DIR_IN | OHCI_INTR_ENDPT,\n\tUE_INTERRUPT,\n\t{8, 0},\t\t\t/* max packet */\n\t255\n};",
            "Static usb_hub_descriptor_t ohci_hubd = {\n\tUSB_HUB_DESCRIPTOR_SIZE,\n\tUDESC_HUB,\n\t0,\n\t{0,0},\n\t0,\n\t0,\n\t{0},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nStatic void;\nStatic void;\nStatic usbd_status;\nStatic void;\nohci_shutdown __P((void *v));\nStatic void;\nStatic usbd_status;\nStatic void;\nStatic void;\nStatic void;\nohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));\nStatic usbd_status;\nohci_device_request __P((usbd_xfer_handle xfer));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic usbd_status;\nohci_setup_isoc __P((usbd_pipe_handle pipe));\nStatic void;\nohci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));\nStatic void;\nStatic usbd_xfer_handle;\nStatic void;\nohci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nStatic usbd_status;\nohci_root_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_ctrl_start __P((usbd_xfer_handle));\nStatic void;\nohci_root_ctrl_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_root_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_intr_start __P((usbd_xfer_handle));\nStatic void;\nohci_root_intr_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_root_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_ctrl_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_ctrl_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_bulk_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_bulk_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_bulk_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_bulk_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_intr_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_intr_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_isoc_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_isoc_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_isoc_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_isoc_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic int;\nStatic void;\nStatic void;\nohci_rhsc_able __P((ohci_softc_t *, int));\nStatic void;\nStatic void;\nohci_abort_xfer __P((usbd_xfer_handle xfer,\n\t\t\t    usbd_status status));\nStatic void;\nStatic void;\nohci_device_clear_toggle __P((usbd_pipe_handle pipe));\nStatic void;\nohci_noop __P((usbd_pipe_handle pipe));\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nStatic int;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\nStatic usb_device_descriptor_t ohci_devd = {\n\tUSB_DEVICE_DESCRIPTOR_SIZE,\n\tUDESC_DEVICE,\t\t/* type */\n\t{0x00, 0x01},\t\t/* USB version */\n\tUDCLASS_HUB,\t\t/* class */\n\tUDSUBCLASS_HUB,\t\t/* subclass */\n\t0,\t\t\t/* protocol */\n\t64,\t\t\t/* max packet */\n\t{0},{0},{0x00,0x01},\t/* device id */\n\t1,2,0,\t\t\t/* string indicies */\n\t1\t\t\t/* # of configurations */\n};\nStatic usb_config_descriptor_t ohci_confd = {\n\tUSB_CONFIG_DESCRIPTOR_SIZE,\n\tUDESC_CONFIG,\n\t{USB_CONFIG_DESCRIPTOR_SIZE +\n\t USB_INTERFACE_DESCRIPTOR_SIZE +\n\t USB_ENDPOINT_DESCRIPTOR_SIZE},\n\t1,\n\t1,\n\t0,\n\tUC_SELF_POWERED,\n\t0\t\t\t/* max power */\n};\nStatic usb_interface_descriptor_t ohci_ifcd = {\n\tUSB_INTERFACE_DESCRIPTOR_SIZE,\n\tUDESC_INTERFACE,\n\t0,\n\t0,\n\t1,\n\tUICLASS_HUB,\n\tUISUBCLASS_HUB,\n\t0,\n\t0\n};\nStatic usb_endpoint_descriptor_t ohci_endpd = {\n\tUSB_ENDPOINT_DESCRIPTOR_SIZE,\n\tUDESC_ENDPOINT,\n\tUE_DIR_IN | OHCI_INTR_ENDPT,\n\tUE_INTERRUPT,\n\t{8, 0},\t\t\t/* max packet */\n\t255\n};\nStatic usb_hub_descriptor_t ohci_hubd = {\n\tUSB_HUB_DESCRIPTOR_SIZE,\n\tUDESC_HUB,\n\t0,\n\t{0,0},\n\t0,\n\t0,\n\t{0},\n};\n\nStatic usbd_status\nohci_root_ctrl_start(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tohci_softc_t *sc = (ohci_softc_t *)xfer->pipe->device->bus;\n\tusb_device_request_t *req;\n\tvoid *buf = NULL;\n\tint port, i;\n\tint s, len, value, index, l, totlen = 0;\n\tusb_port_status_t ps;\n\tusb_hub_descriptor_t hubd;\n\tusbd_status err;\n\tu_int32_t v;\n\n\tif (sc->sc_dying)\n\t\treturn (USBD_IOERROR);\n\n#ifdef DIAGNOSTIC\n\tif (!(xfer->rqflags & URQ_REQUEST))\n\t\t/* XXX panic */\n\t\treturn (USBD_INVAL);\n#endif\n\treq = &xfer->request;\n\n\tDPRINTFN(4,(\"ohci_root_ctrl_control type=0x%02x request=%02x\\n\", \n\t\t    req->bmRequestType, req->bRequest));\n\n\tlen = UGETW(req->wLength);\n\tvalue = UGETW(req->wValue);\n\tindex = UGETW(req->wIndex);\n\n\tif (len != 0)\n\t\tbuf = KERNADDR(&xfer->dmabuf);\n\n#define C(x,y) ((x) | ((y) << 8))\n\tswitch(C(req->bRequest, req->bmRequestType)) {\n\tcase C(UR_CLEAR_FEATURE, UT_WRITE_DEVICE):\n\tcase C(UR_CLEAR_FEATURE, UT_WRITE_INTERFACE):\n\tcase C(UR_CLEAR_FEATURE, UT_WRITE_ENDPOINT):\n\t\t/* \n\t\t * DEVICE_REMOTE_WAKEUP and ENDPOINT_HALT are no-ops\n\t\t * for the integrated root hub.\n\t\t */\n\t\tbreak;\n\tcase C(UR_GET_CONFIG, UT_READ_DEVICE):\n\t\tif (len > 0) {\n\t\t\t*(u_int8_t *)buf = sc->sc_conf;\n\t\t\ttotlen = 1;\n\t\t}\n\t\tbreak;\n\tcase C(UR_GET_DESCRIPTOR, UT_READ_DEVICE):\n\t\tDPRINTFN(8,(\"ohci_root_ctrl_control wValue=0x%04x\\n\", value));\n\t\tswitch(value >> 8) {\n\t\tcase UDESC_DEVICE:\n\t\t\tif ((value & 0xff) != 0) {\n\t\t\t\terr = USBD_IOERROR;\n\t\t\t\tgoto ret;\n\t\t\t}\n\t\t\ttotlen = l = min(len, USB_DEVICE_DESCRIPTOR_SIZE);\n\t\t\tUSETW(ohci_devd.idVendor, sc->sc_id_vendor);\n\t\t\tmemcpy(buf, &ohci_devd, l);\n\t\t\tbreak;\n\t\tcase UDESC_CONFIG:\n\t\t\tif ((value & 0xff) != 0) {\n\t\t\t\terr = USBD_IOERROR;\n\t\t\t\tgoto ret;\n\t\t\t}\n\t\t\ttotlen = l = min(len, USB_CONFIG_DESCRIPTOR_SIZE);\n\t\t\tmemcpy(buf, &ohci_confd, l);\n\t\t\tbuf = (char *)buf + l;\n\t\t\tlen -= l;\n\t\t\tl = min(len, USB_INTERFACE_DESCRIPTOR_SIZE);\n\t\t\ttotlen += l;\n\t\t\tmemcpy(buf, &ohci_ifcd, l);\n\t\t\tbuf = (char *)buf + l;\n\t\t\tlen -= l;\n\t\t\tl = min(len, USB_ENDPOINT_DESCRIPTOR_SIZE);\n\t\t\ttotlen += l;\n\t\t\tmemcpy(buf, &ohci_endpd, l);\n\t\t\tbreak;\n\t\tcase UDESC_STRING:\n\t\t\tif (len == 0)\n\t\t\t\tbreak;\n\t\t\t*(u_int8_t *)buf = 0;\n\t\t\ttotlen = 1;\n\t\t\tswitch (value & 0xff) {\n\t\t\tcase 1: /* Vendor */\n\t\t\t\ttotlen = ohci_str(buf, len, sc->sc_vendor);\n\t\t\t\tbreak;\n\t\t\tcase 2: /* Product */\n\t\t\t\ttotlen = ohci_str(buf, len, \"OHCI root hub\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tbreak;\n\tcase C(UR_GET_INTERFACE, UT_READ_INTERFACE):\n\t\tif (len > 0) {\n\t\t\t*(u_int8_t *)buf = 0;\n\t\t\ttotlen = 1;\n\t\t}\n\t\tbreak;\n\tcase C(UR_GET_STATUS, UT_READ_DEVICE):\n\t\tif (len > 1) {\n\t\t\tUSETW(((usb_status_t *)buf)->wStatus,UDS_SELF_POWERED);\n\t\t\ttotlen = 2;\n\t\t}\n\t\tbreak;\n\tcase C(UR_GET_STATUS, UT_READ_INTERFACE):\n\tcase C(UR_GET_STATUS, UT_READ_ENDPOINT):\n\t\tif (len > 1) {\n\t\t\tUSETW(((usb_status_t *)buf)->wStatus, 0);\n\t\t\ttotlen = 2;\n\t\t}\n\t\tbreak;\n\tcase C(UR_SET_ADDRESS, UT_WRITE_DEVICE):\n\t\tif (value >= USB_MAX_DEVICES) {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tsc->sc_addr = value;\n\t\tbreak;\n\tcase C(UR_SET_CONFIG, UT_WRITE_DEVICE):\n\t\tif (value != 0 && value != 1) {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tsc->sc_conf = value;\n\t\tbreak;\n\tcase C(UR_SET_DESCRIPTOR, UT_WRITE_DEVICE):\n\t\tbreak;\n\tcase C(UR_SET_FEATURE, UT_WRITE_DEVICE):\n\tcase C(UR_SET_FEATURE, UT_WRITE_INTERFACE):\n\tcase C(UR_SET_FEATURE, UT_WRITE_ENDPOINT):\n\t\terr = USBD_IOERROR;\n\t\tgoto ret;\n\tcase C(UR_SET_INTERFACE, UT_WRITE_INTERFACE):\n\t\tbreak;\n\tcase C(UR_SYNCH_FRAME, UT_WRITE_ENDPOINT):\n\t\tbreak;\n\t/* Hub requests */\n\tcase C(UR_CLEAR_FEATURE, UT_WRITE_CLASS_DEVICE):\n\t\tbreak;\n\tcase C(UR_CLEAR_FEATURE, UT_WRITE_CLASS_OTHER):\n\t\tDPRINTFN(8, (\"ohci_root_ctrl_control: UR_CLEAR_PORT_FEATURE \"\n\t\t\t     \"port=%d feature=%d\\n\",\n\t\t\t     index, value));\n\t\tif (index < 1 || index > sc->sc_noport) {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tport = OHCI_RH_PORT_STATUS(index);\n\t\tswitch(value) {\n\t\tcase UHF_PORT_ENABLE:\n\t\t\tOWRITE4(sc, port, UPS_CURRENT_CONNECT_STATUS);\n\t\t\tbreak;\n\t\tcase UHF_PORT_SUSPEND:\n\t\t\tOWRITE4(sc, port, UPS_OVERCURRENT_INDICATOR);\n\t\t\tbreak;\n\t\tcase UHF_PORT_POWER:\n\t\t\tOWRITE4(sc, port, UPS_LOW_SPEED);\n\t\t\tbreak;\n\t\tcase UHF_C_PORT_CONNECTION:\n\t\t\tOWRITE4(sc, port, UPS_C_CONNECT_STATUS << 16);\n\t\t\tbreak;\n\t\tcase UHF_C_PORT_ENABLE:\n\t\t\tOWRITE4(sc, port, UPS_C_PORT_ENABLED << 16);\n\t\t\tbreak;\n\t\tcase UHF_C_PORT_SUSPEND:\n\t\t\tOWRITE4(sc, port, UPS_C_SUSPEND << 16);\n\t\t\tbreak;\n\t\tcase UHF_C_PORT_OVER_CURRENT:\n\t\t\tOWRITE4(sc, port, UPS_C_OVERCURRENT_INDICATOR << 16);\n\t\t\tbreak;\n\t\tcase UHF_C_PORT_RESET:\n\t\t\tOWRITE4(sc, port, UPS_C_PORT_RESET << 16);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tswitch(value) {\n\t\tcase UHF_C_PORT_CONNECTION:\n\t\tcase UHF_C_PORT_ENABLE:\n\t\tcase UHF_C_PORT_SUSPEND:\n\t\tcase UHF_C_PORT_OVER_CURRENT:\n\t\tcase UHF_C_PORT_RESET:\n\t\t\t/* Enable RHSC interrupt if condition is cleared. */\n\t\t\tif ((OREAD4(sc, port) >> 16) == 0)\n\t\t\t\tohci_rhsc_able(sc, 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase C(UR_GET_DESCRIPTOR, UT_READ_CLASS_DEVICE):\n\t\tif (value != 0) {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tv = OREAD4(sc, OHCI_RH_DESCRIPTOR_A);\n\t\thubd = ohci_hubd;\n\t\thubd.bNbrPorts = sc->sc_noport;\n\t\tUSETW(hubd.wHubCharacteristics,\n\t\t      (v & OHCI_NPS ? UHD_PWR_NO_SWITCH : \n\t\t       v & OHCI_PSM ? UHD_PWR_GANGED : UHD_PWR_INDIVIDUAL)\n\t\t      /* XXX overcurrent */\n\t\t      );\n\t\thubd.bPwrOn2PwrGood = OHCI_GET_POTPGT(v);\n\t\tv = OREAD4(sc, OHCI_RH_DESCRIPTOR_B);\n\t\tfor (i = 0, l = sc->sc_noport; l > 0; i++, l -= 8, v >>= 8) \n\t\t\thubd.DeviceRemovable[i++] = (u_int8_t)v;\n\t\thubd.bDescLength = USB_HUB_DESCRIPTOR_SIZE + i;\n\t\tl = min(len, hubd.bDescLength);\n\t\ttotlen = l;\n\t\tmemcpy(buf, &hubd, l);\n\t\tbreak;\n\tcase C(UR_GET_STATUS, UT_READ_CLASS_DEVICE):\n\t\tif (len != 4) {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tmemset(buf, 0, len); /* ? XXX */\n\t\ttotlen = len;\n\t\tbreak;\n\tcase C(UR_GET_STATUS, UT_READ_CLASS_OTHER):\n\t\tDPRINTFN(8,(\"ohci_root_ctrl_transfer: get port status i=%d\\n\",\n\t\t\t    index));\n\t\tif (index < 1 || index > sc->sc_noport) {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tif (len != 4) {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tv = OREAD4(sc, OHCI_RH_PORT_STATUS(index));\n\t\tDPRINTFN(8,(\"ohci_root_ctrl_transfer: port status=0x%04x\\n\",\n\t\t\t    v));\n\t\tUSETW(ps.wPortStatus, v);\n\t\tUSETW(ps.wPortChange, v >> 16);\n\t\tl = min(len, sizeof ps);\n\t\tmemcpy(buf, &ps, l);\n\t\ttotlen = l;\n\t\tbreak;\n\tcase C(UR_SET_DESCRIPTOR, UT_WRITE_CLASS_DEVICE):\n\t\terr = USBD_IOERROR;\n\t\tgoto ret;\n\tcase C(UR_SET_FEATURE, UT_WRITE_CLASS_DEVICE):\n\t\tbreak;\n\tcase C(UR_SET_FEATURE, UT_WRITE_CLASS_OTHER):\n\t\tif (index < 1 || index > sc->sc_noport) {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tport = OHCI_RH_PORT_STATUS(index);\n\t\tswitch(value) {\n\t\tcase UHF_PORT_ENABLE:\n\t\t\tOWRITE4(sc, port, UPS_PORT_ENABLED);\n\t\t\tbreak;\n\t\tcase UHF_PORT_SUSPEND:\n\t\t\tOWRITE4(sc, port, UPS_SUSPEND);\n\t\t\tbreak;\n\t\tcase UHF_PORT_RESET:\n\t\t\tDPRINTFN(5,(\"ohci_root_ctrl_transfer: reset port %d\\n\",\n\t\t\t\t    index));\n\t\t\tOWRITE4(sc, port, UPS_RESET);\n\t\t\tfor (i = 0; i < 10; i++) {\n\t\t\t\tusb_delay_ms(&sc->sc_bus, 10);\n\t\t\t\tif ((OREAD4(sc, port) & UPS_RESET) == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tDPRINTFN(8,(\"ohci port %d reset, status = 0x%04x\\n\",\n\t\t\t\t    index, OREAD4(sc, port)));\n\t\t\tbreak;\n\t\tcase UHF_PORT_POWER:\n\t\t\tDPRINTFN(2,(\"ohci_root_ctrl_transfer: set port power \"\n\t\t\t\t    \"%d\\n\", index));\n\t\t\tOWRITE4(sc, port, UPS_PORT_POWER);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\terr = USBD_IOERROR;\n\t\tgoto ret;\n\t}\n\txfer->actlen = totlen;\n\terr = USBD_NORMAL_COMPLETION;\n ret:\n\txfer->status = err;\n\ts = splusb();\n\tusb_transfer_complete(xfer);\n\tsplx(s);\n\treturn (USBD_IN_PROGRESS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_FIRST",
          "args": [
            "&xfer->pipe->queue"
          ],
          "line": 2190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_insert_transfer",
          "args": [
            "xfer"
          ],
          "line": 2185
        },
        "resolved": true,
        "details": {
          "function_name": "usb_insert_transfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "885-905",
          "snippet": "usbd_status\nusb_insert_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusbd_status err;\n\tint s;\n\n\tDPRINTFN(5,(\"usb_insert_transfer: pipe=%p running=%d timeout=%d\\n\", \n\t\t    pipe, pipe->running, xfer->timeout));\n\ts = splusb();\n\tSIMPLEQ_INSERT_TAIL(&pipe->queue, xfer, next);\n\tif (pipe->running)\n\t\terr = USBD_IN_PROGRESS;\n\telse {\n\t\tpipe->running = 1;\n\t\terr = USBD_NORMAL_COMPLETION;\n\t}\n\tsplx(s);\n\treturn (err);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nusbd_status\nusb_insert_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusbd_status err;\n\tint s;\n\n\tDPRINTFN(5,(\"usb_insert_transfer: pipe=%p running=%d timeout=%d\\n\", \n\t\t    pipe, pipe->running, xfer->timeout));\n\ts = splusb();\n\tSIMPLEQ_INSERT_TAIL(&pipe->queue, xfer, next);\n\tif (pipe->running)\n\t\terr = USBD_IN_PROGRESS;\n\telse {\n\t\tpipe->running = 1;\n\t\terr = USBD_NORMAL_COMPLETION;\n\t}\n\tsplx(s);\n\treturn (err);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nStatic void;\nStatic void;\nStatic usbd_status;\nStatic void;\nStatic void;\nStatic usbd_status;\nStatic void;\nStatic void;\nStatic void;\nohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));\nStatic usbd_status;\nohci_device_request __P((usbd_xfer_handle xfer));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic usbd_status;\nohci_setup_isoc __P((usbd_pipe_handle pipe));\nStatic void;\nohci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic void;\nStatic usbd_xfer_handle;\nStatic void;\nohci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nStatic usbd_status;\nohci_root_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_ctrl_start __P((usbd_xfer_handle));\nStatic void;\nohci_root_ctrl_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_root_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_intr_start __P((usbd_xfer_handle));\nStatic void;\nohci_root_intr_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_root_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_ctrl_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_ctrl_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_bulk_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_bulk_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_bulk_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_bulk_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_intr_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_intr_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_isoc_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_isoc_start __P((usbd_xfer_handle));\nStatic void;\nohci_device_isoc_abort __P((usbd_xfer_handle));\nStatic void;\nStatic void;\nohci_device_isoc_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_device_clear_toggle __P((usbd_pipe_handle pipe));\nStatic void;\nohci_noop __P((usbd_pipe_handle pipe));\nStatic int;\n\nStatic usbd_status\nohci_root_ctrl_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_status err;\n\n\t/* Insert last in queue. */\n\terr = usb_insert_transfer(xfer);\n\tif (err)\n\t\treturn (err);\n\n\t/* Pipe isn't running, start first */\n\treturn (ohci_root_ctrl_start(SIMPLEQ_FIRST(&xfer->pipe->queue)));\n}"
  },
  {
    "function_name": "ohci_str",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "2155-2173",
    "snippet": "Static int\nohci_str(p, l, s)\n\tusb_string_descriptor_t *p;\n\tint l;\n\tchar *s;\n{\n\tint i;\n\n\tif (l == 0)\n\t\treturn (0);\n\tp->bLength = 2 * strlen(s) + 2;\n\tif (l == 1)\n\t\treturn (1);\n\tp->bDescriptorType = UDESC_STRING;\n\tl -= 2;\n\tfor (i = 0; s[i] && l > 1; i++, l -= 2)\n\t\tUSETW2(p->bString[i], 0, s[i]);\n\treturn (2*i+2);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static int",
      "ohci_str __P((usb_string_descriptor_t *, int, char *));",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static int"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "USETW2",
          "args": [
            "p->bString[i]",
            "0",
            "s[i]"
          ],
          "line": 2171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "s"
          ],
          "line": 2165
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nohci_str __P((usb_string_descriptor_t *, int, char *));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\n\nStatic int\nohci_str(p, l, s)\n\tusb_string_descriptor_t *p;\n\tint l;\n\tchar *s;\n{\n\tint i;\n\n\tif (l == 0)\n\t\treturn (0);\n\tp->bLength = 2 * strlen(s) + 2;\n\tif (l == 1)\n\t\treturn (1);\n\tp->bDescriptorType = UDESC_STRING;\n\tl -= 2;\n\tfor (i = 0; s[i] && l > 1; i++, l -= 2)\n\t\tUSETW2(p->bString[i], 0, s[i]);\n\treturn (2*i+2);\n}"
  },
  {
    "function_name": "ohci_abort_xfer_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "2059-2093",
    "snippet": "void\nohci_abort_xfer_end(v)\n\tvoid *v;\n{\n\tusbd_xfer_handle xfer = v;\n\tstruct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;\n\tohci_softc_t *sc = (ohci_softc_t *)opipe->pipe.device->bus;\n\tohci_soft_ed_t *sed;\n\tohci_soft_td_t *p, *n;\n\tint s;\n\n\ts = splusb();\n\n\tp = xfer->hcpriv;\n#ifdef DIAGNOSTIC\n\tif (p == NULL) {\n\t\tprintf(\"ohci_abort_xfer: hcpriv==0\\n\");\n\t\treturn;\n\t}\n#endif\n\tfor (; p->xfer == xfer; p = n) {\n\t\tn = p->nexttd;\n\t\tohci_free_std(sc, p);\n\t}\n\n\tsed = opipe->sed;\n\tDPRINTFN(2,(\"ohci_abort_xfer: set hd=%x, tl=%x\\n\",\n\t\t    (int)p->physaddr, (int)le32toh(sed->ed.ed_tailp)));\n\tsed->ed.ed_headp = htole32(p->physaddr); /* unlink TDs */\n\tsed->ed.ed_flags &= htole32(~OHCI_ED_SKIP); /* remove hardware skip */\n\n\tusb_transfer_complete(xfer);\n\n\tsplx(s);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static ohci_soft_ed_t",
      "ohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));",
      "Static ohci_soft_td_t",
      "ohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));",
      "ohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));",
      "ohci_shutdown __P((void *v));",
      "ohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));",
      "ohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));",
      "ohci_device_request __P((usbd_xfer_handle xfer));",
      "ohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
      "ohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
      "ohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));",
      "ohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));",
      "Static ohci_soft_td_t",
      "ohci_setup_isoc __P((usbd_pipe_handle pipe));",
      "ohci_device_isoc_enter __P((usbd_xfer_handle));",
      "Static usbd_xfer_handle",
      "ohci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "ohci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "ohci_root_ctrl_start __P((usbd_xfer_handle));",
      "ohci_root_ctrl_abort __P((usbd_xfer_handle));",
      "ohci_root_ctrl_done  __P((usbd_xfer_handle));",
      "ohci_root_intr_transfer __P((usbd_xfer_handle));",
      "ohci_root_intr_start __P((usbd_xfer_handle));",
      "ohci_root_intr_abort __P((usbd_xfer_handle));",
      "ohci_root_intr_done  __P((usbd_xfer_handle));",
      "ohci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "ohci_device_ctrl_start __P((usbd_xfer_handle));",
      "ohci_device_ctrl_abort __P((usbd_xfer_handle));",
      "ohci_device_ctrl_done  __P((usbd_xfer_handle));",
      "ohci_device_bulk_transfer __P((usbd_xfer_handle));",
      "ohci_device_bulk_start __P((usbd_xfer_handle));",
      "ohci_device_bulk_abort __P((usbd_xfer_handle));",
      "ohci_device_bulk_done  __P((usbd_xfer_handle));",
      "ohci_device_intr_transfer __P((usbd_xfer_handle));",
      "ohci_device_intr_start __P((usbd_xfer_handle));",
      "ohci_device_intr_abort __P((usbd_xfer_handle));",
      "ohci_device_intr_done  __P((usbd_xfer_handle));",
      "ohci_device_isoc_transfer __P((usbd_xfer_handle));",
      "ohci_device_isoc_start __P((usbd_xfer_handle));",
      "ohci_device_isoc_abort __P((usbd_xfer_handle));",
      "ohci_device_isoc_done  __P((usbd_xfer_handle));",
      "ohci_rhsc_able __P((ohci_softc_t *, int));",
      "ohci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "ohci_noop __P((usbd_pipe_handle pipe));",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
      "ohci_intr1 __P((ohci_softc_t *));",
      "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 2092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_transfer_complete",
          "args": [
            "xfer"
          ],
          "line": 2090
        },
        "resolved": true,
        "details": {
          "function_name": "usb_transfer_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "789-883",
          "snippet": "void\nusb_transfer_complete(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tint repeat = pipe->repeat;\n\tint polling;\n\n\tSPLUSBCHECK;\n\n\tDPRINTFN(5, (\"usb_transfer_complete: pipe=%p xfer=%p status=%d \"\n\t\t     \"actlen=%d\\n\", pipe, xfer, xfer->status, xfer->actlen));\n\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_transfer_cb: pipe==0, xfer=%p\\n\", xfer);\n\t\treturn;\n\t}\n#endif\n\tpolling = pipe->device->bus->use_polling;\n\t/* XXXX */\n\tif (polling)\n\t\tpipe->running = 0;\n\n\tif (!(xfer->flags & USBD_NO_COPY) && xfer->actlen != 0 &&\n\t    usbd_xfer_isread(xfer)) {\n#ifdef DIAGNOSTIC\n\t\tif (xfer->actlen > xfer->length) {\n\t\t\tprintf(\"usb_transfer_complete: actlen > len %d > %d\\n\",\n\t\t\t       xfer->actlen, xfer->length);\n\t\t\txfer->actlen = xfer->length;\n\t\t}\n#endif\n\t\tmemcpy(xfer->buffer, KERNADDR(dmap), xfer->actlen);\n\t}\n\n\t/* if we allocated the buffer in usbd_transfer() we free it here. */\n\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\tif (!repeat) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\t\t\tbus->methods->freem(bus, dmap);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!repeat) {\n\t\t/* Remove request from queue. */\n#ifdef DIAGNOSTIC\n\t\tif (xfer != SIMPLEQ_FIRST(&pipe->queue))\n\t\t\tprintf(\"usb_transfer_complete: bad dequeue %p != %p\\n\",\n\t\t\t       xfer, SIMPLEQ_FIRST(&pipe->queue));\n#endif\n\t\tSIMPLEQ_REMOVE_HEAD(&pipe->queue, xfer, next);\n\t}\n\tDPRINTFN(5,(\"usb_transfer_complete: repeat=%d new head=%p\\n\", \n\t\t    repeat, SIMPLEQ_FIRST(&pipe->queue)));\n\n\t/* Count completed transfers. */\n\t++pipe->device->bus->stats.requests\n\t\t[pipe->endpoint->edesc->bmAttributes & UE_XFERTYPE];\n\n\txfer->done = 1;\n\tif (!xfer->status && xfer->actlen < xfer->length &&\n\t    !(xfer->flags & USBD_SHORT_XFER_OK)) {\n\t\tDPRINTFN(-1,(\"usbd_transfer_cb: short transfer %d<%d\\n\",\n\t\t\t     xfer->actlen, xfer->length));\n\t\txfer->status = USBD_SHORT_XFER;\n\t}\n\n\tif (xfer->callback)\n\t\txfer->callback(xfer, xfer->priv, xfer->status);\n\n#ifdef DIAGNOSTIC\n\tif (pipe->methods->done != NULL)\n\t\tpipe->methods->done(xfer);\n\telse\n\t\tprintf(\"usb_transfer_complete: pipe->methods->done == NULL\\n\");\n#else\n\tpipe->methods->done(xfer);\n#endif\n\n\tif ((xfer->flags & USBD_SYNCHRONOUS) && !polling)\n\t\twakeup(xfer);\n\n\tif (!repeat) {\n\t\t/* XXX should we stop the queue on all errors? */\n\t\tif ((xfer->status == USBD_CANCELLED ||\n\t\t     xfer->status == USBD_TIMEOUT) &&\n\t\t    pipe->iface != NULL)\t\t/* not control pipe */\n\t\t\tpipe->running = 0;\n\t\telse\n\t\t\tusbd_start_next(pipe);\n\t}\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "usb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;",
            "usb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);",
            "usb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_start_next __P((usbd_pipe_handle pipe));\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nusb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;\nusb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\nusb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;\n\nvoid\nusb_transfer_complete(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tint repeat = pipe->repeat;\n\tint polling;\n\n\tSPLUSBCHECK;\n\n\tDPRINTFN(5, (\"usb_transfer_complete: pipe=%p xfer=%p status=%d \"\n\t\t     \"actlen=%d\\n\", pipe, xfer, xfer->status, xfer->actlen));\n\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_transfer_cb: pipe==0, xfer=%p\\n\", xfer);\n\t\treturn;\n\t}\n#endif\n\tpolling = pipe->device->bus->use_polling;\n\t/* XXXX */\n\tif (polling)\n\t\tpipe->running = 0;\n\n\tif (!(xfer->flags & USBD_NO_COPY) && xfer->actlen != 0 &&\n\t    usbd_xfer_isread(xfer)) {\n#ifdef DIAGNOSTIC\n\t\tif (xfer->actlen > xfer->length) {\n\t\t\tprintf(\"usb_transfer_complete: actlen > len %d > %d\\n\",\n\t\t\t       xfer->actlen, xfer->length);\n\t\t\txfer->actlen = xfer->length;\n\t\t}\n#endif\n\t\tmemcpy(xfer->buffer, KERNADDR(dmap), xfer->actlen);\n\t}\n\n\t/* if we allocated the buffer in usbd_transfer() we free it here. */\n\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\tif (!repeat) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\t\t\tbus->methods->freem(bus, dmap);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!repeat) {\n\t\t/* Remove request from queue. */\n#ifdef DIAGNOSTIC\n\t\tif (xfer != SIMPLEQ_FIRST(&pipe->queue))\n\t\t\tprintf(\"usb_transfer_complete: bad dequeue %p != %p\\n\",\n\t\t\t       xfer, SIMPLEQ_FIRST(&pipe->queue));\n#endif\n\t\tSIMPLEQ_REMOVE_HEAD(&pipe->queue, xfer, next);\n\t}\n\tDPRINTFN(5,(\"usb_transfer_complete: repeat=%d new head=%p\\n\", \n\t\t    repeat, SIMPLEQ_FIRST(&pipe->queue)));\n\n\t/* Count completed transfers. */\n\t++pipe->device->bus->stats.requests\n\t\t[pipe->endpoint->edesc->bmAttributes & UE_XFERTYPE];\n\n\txfer->done = 1;\n\tif (!xfer->status && xfer->actlen < xfer->length &&\n\t    !(xfer->flags & USBD_SHORT_XFER_OK)) {\n\t\tDPRINTFN(-1,(\"usbd_transfer_cb: short transfer %d<%d\\n\",\n\t\t\t     xfer->actlen, xfer->length));\n\t\txfer->status = USBD_SHORT_XFER;\n\t}\n\n\tif (xfer->callback)\n\t\txfer->callback(xfer, xfer->priv, xfer->status);\n\n#ifdef DIAGNOSTIC\n\tif (pipe->methods->done != NULL)\n\t\tpipe->methods->done(xfer);\n\telse\n\t\tprintf(\"usb_transfer_complete: pipe->methods->done == NULL\\n\");\n#else\n\tpipe->methods->done(xfer);\n#endif\n\n\tif ((xfer->flags & USBD_SYNCHRONOUS) && !polling)\n\t\twakeup(xfer);\n\n\tif (!repeat) {\n\t\t/* XXX should we stop the queue on all errors? */\n\t\tif ((xfer->status == USBD_CANCELLED ||\n\t\t     xfer->status == USBD_TIMEOUT) &&\n\t\t    pipe->iface != NULL)\t\t/* not control pipe */\n\t\t\tpipe->running = 0;\n\t\telse\n\t\t\tusbd_start_next(pipe);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "~OHCI_ED_SKIP"
          ],
          "line": 2088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "p->physaddr"
          ],
          "line": 2087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "2",
            "(\"ohci_abort_xfer: set hd=%x, tl=%x\\n\",\n\t\t    (int)p->physaddr, (int)le32toh(sed->ed.ed_tailp))"
          ],
          "line": 2085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "sed->ed.ed_tailp"
          ],
          "line": 2086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ohci_free_std",
          "args": [
            "sc",
            "p"
          ],
          "line": 2081
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_free_std_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "577-589",
          "snippet": "Static void\nohci_free_std_chain(sc, std, stdend)\n\tohci_softc_t *sc;\n\tohci_soft_td_t *std;\n\tohci_soft_td_t *stdend;\n{\n\tohci_soft_td_t *p;\n\n\tfor (; std != stdend; std = p) {\n\t\tp = std->nexttd;\n\t\tohci_free_std(sc, std);\n\t}\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static void",
            "Static ohci_soft_td_t",
            "Static void",
            "ohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));",
            "Static void",
            "ohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "ohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));",
            "Static void",
            "ohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));",
            "Static ohci_soft_td_t",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "ohci_rhsc_able __P((ohci_softc_t *, int));",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
            "Static int",
            "ohci_intr1 __P((ohci_softc_t *));",
            "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nStatic ohci_soft_td_t;\nStatic void;\nohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));\nStatic void;\nohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));\nStatic void;\nohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));\nStatic ohci_soft_td_t;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nohci_rhsc_able __P((ohci_softc_t *, int));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nStatic int;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nStatic void\nohci_free_std_chain(sc, std, stdend)\n\tohci_softc_t *sc;\n\tohci_soft_td_t *std;\n\tohci_soft_td_t *stdend;\n{\n\tohci_soft_td_t *p;\n\n\tfor (; std != stdend; std = p) {\n\t\tp = std->nexttd;\n\t\tohci_free_std(sc, std);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ohci_abort_xfer: hcpriv==0\\n\""
          ],
          "line": 2075
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 2070
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_ed_t;\nohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));\nStatic ohci_soft_td_t;\nohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));\nohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));\nohci_shutdown __P((void *v));\nohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));\nohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));\nohci_device_request __P((usbd_xfer_handle xfer));\nohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));\nohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));\nStatic ohci_soft_td_t;\nohci_setup_isoc __P((usbd_pipe_handle pipe));\nohci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_xfer_handle;\nohci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nohci_root_ctrl_transfer __P((usbd_xfer_handle));\nohci_root_ctrl_start __P((usbd_xfer_handle));\nohci_root_ctrl_abort __P((usbd_xfer_handle));\nohci_root_ctrl_done  __P((usbd_xfer_handle));\nohci_root_intr_transfer __P((usbd_xfer_handle));\nohci_root_intr_start __P((usbd_xfer_handle));\nohci_root_intr_abort __P((usbd_xfer_handle));\nohci_root_intr_done  __P((usbd_xfer_handle));\nohci_device_ctrl_transfer __P((usbd_xfer_handle));\nohci_device_ctrl_start __P((usbd_xfer_handle));\nohci_device_ctrl_abort __P((usbd_xfer_handle));\nohci_device_ctrl_done  __P((usbd_xfer_handle));\nohci_device_bulk_transfer __P((usbd_xfer_handle));\nohci_device_bulk_start __P((usbd_xfer_handle));\nohci_device_bulk_abort __P((usbd_xfer_handle));\nohci_device_bulk_done  __P((usbd_xfer_handle));\nohci_device_intr_transfer __P((usbd_xfer_handle));\nohci_device_intr_start __P((usbd_xfer_handle));\nohci_device_intr_abort __P((usbd_xfer_handle));\nohci_device_intr_done  __P((usbd_xfer_handle));\nohci_device_isoc_transfer __P((usbd_xfer_handle));\nohci_device_isoc_start __P((usbd_xfer_handle));\nohci_device_isoc_abort __P((usbd_xfer_handle));\nohci_device_isoc_done  __P((usbd_xfer_handle));\nohci_rhsc_able __P((ohci_softc_t *, int));\nohci_device_clear_toggle __P((usbd_pipe_handle pipe));\nohci_noop __P((usbd_pipe_handle pipe));\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nvoid\nohci_abort_xfer_end(v)\n\tvoid *v;\n{\n\tusbd_xfer_handle xfer = v;\n\tstruct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;\n\tohci_softc_t *sc = (ohci_softc_t *)opipe->pipe.device->bus;\n\tohci_soft_ed_t *sed;\n\tohci_soft_td_t *p, *n;\n\tint s;\n\n\ts = splusb();\n\n\tp = xfer->hcpriv;\n#ifdef DIAGNOSTIC\n\tif (p == NULL) {\n\t\tprintf(\"ohci_abort_xfer: hcpriv==0\\n\");\n\t\treturn;\n\t}\n#endif\n\tfor (; p->xfer == xfer; p = n) {\n\t\tn = p->nexttd;\n\t\tohci_free_std(sc, p);\n\t}\n\n\tsed = opipe->sed;\n\tDPRINTFN(2,(\"ohci_abort_xfer: set hd=%x, tl=%x\\n\",\n\t\t    (int)p->physaddr, (int)le32toh(sed->ed.ed_tailp)));\n\tsed->ed.ed_headp = htole32(p->physaddr); /* unlink TDs */\n\tsed->ed.ed_flags &= htole32(~OHCI_ED_SKIP); /* remove hardware skip */\n\n\tusb_transfer_complete(xfer);\n\n\tsplx(s);\n}"
  },
  {
    "function_name": "ohci_abort_xfer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "2022-2057",
    "snippet": "void\nohci_abort_xfer(xfer, status)\n\tusbd_xfer_handle xfer;\n\tusbd_status status;\n{\n\tstruct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;\n\tohci_soft_ed_t *sed;\n\n\tDPRINTF((\"ohci_abort_xfer: xfer=%p pipe=%p\\n\", xfer, opipe));\n\n\txfer->status = status;\n\n\tusb_uncallout(xfer->timeout_handle, ohci_timeout, xfer);\n\n\tsed = opipe->sed;\n\tDPRINTFN(1,(\"ohci_abort_xfer: stop ed=%p\\n\", sed));\n\tsed->ed.ed_flags |= htole32(OHCI_ED_SKIP); /* force hardware skip */\n\n#if 1\n\tif (xfer->device->bus->intr_context) {\n\t\t/* We have no process context, so we can't use tsleep(). */\n\t\tusb_callout(xfer->pipe->abort_handle,\n\t\t    hz / USB_FRAMES_PER_SECOND, ohci_abort_xfer_end, xfer);\n\t} else {\n#if defined(DIAGNOSTIC) && defined(__i386__) && defined(__FreeBSD__)\n\t\tKASSERT(intr_nesting_level == 0,\n\t        \t(\"ohci_abort_req in interrupt context\"));\n#endif\n\t\tusb_delay_ms(opipe->pipe.device->bus, 1);\n\t\tohci_abort_xfer_end(xfer);\n\t}\n#else\n\tdelay(1000);\n\tohci_abort_xfer_end(xfer);\n#endif\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static ohci_soft_ed_t",
      "ohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));",
      "Static usbd_status",
      "Static usbd_status",
      "ohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));",
      "ohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_request __P((usbd_xfer_handle xfer));",
      "ohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
      "ohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
      "Static usbd_status",
      "ohci_setup_isoc __P((usbd_pipe_handle pipe));",
      "ohci_device_isoc_enter __P((usbd_xfer_handle));",
      "Static usbd_status",
      "Static usbd_xfer_handle",
      "ohci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_root_ctrl_start __P((usbd_xfer_handle));",
      "ohci_root_ctrl_abort __P((usbd_xfer_handle));",
      "ohci_root_ctrl_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_root_intr_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_root_intr_start __P((usbd_xfer_handle));",
      "ohci_root_intr_abort __P((usbd_xfer_handle));",
      "ohci_root_intr_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_ctrl_start __P((usbd_xfer_handle));",
      "ohci_device_ctrl_abort __P((usbd_xfer_handle));",
      "ohci_device_ctrl_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_bulk_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_bulk_start __P((usbd_xfer_handle));",
      "ohci_device_bulk_abort __P((usbd_xfer_handle));",
      "ohci_device_bulk_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_intr_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_intr_start __P((usbd_xfer_handle));",
      "ohci_device_intr_abort __P((usbd_xfer_handle));",
      "ohci_device_intr_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_isoc_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_isoc_start __P((usbd_xfer_handle));",
      "ohci_device_isoc_abort __P((usbd_xfer_handle));",
      "ohci_device_isoc_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_abort_xfer __P((usbd_xfer_handle xfer,\n\t\t\t    usbd_status status));",
      "ohci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "ohci_noop __P((usbd_pipe_handle pipe));",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ohci_abort_xfer_end",
          "args": [
            "xfer"
          ],
          "line": 2055
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_abort_xfer_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "2059-2093",
          "snippet": "void\nohci_abort_xfer_end(v)\n\tvoid *v;\n{\n\tusbd_xfer_handle xfer = v;\n\tstruct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;\n\tohci_softc_t *sc = (ohci_softc_t *)opipe->pipe.device->bus;\n\tohci_soft_ed_t *sed;\n\tohci_soft_td_t *p, *n;\n\tint s;\n\n\ts = splusb();\n\n\tp = xfer->hcpriv;\n#ifdef DIAGNOSTIC\n\tif (p == NULL) {\n\t\tprintf(\"ohci_abort_xfer: hcpriv==0\\n\");\n\t\treturn;\n\t}\n#endif\n\tfor (; p->xfer == xfer; p = n) {\n\t\tn = p->nexttd;\n\t\tohci_free_std(sc, p);\n\t}\n\n\tsed = opipe->sed;\n\tDPRINTFN(2,(\"ohci_abort_xfer: set hd=%x, tl=%x\\n\",\n\t\t    (int)p->physaddr, (int)le32toh(sed->ed.ed_tailp)));\n\tsed->ed.ed_headp = htole32(p->physaddr); /* unlink TDs */\n\tsed->ed.ed_flags &= htole32(~OHCI_ED_SKIP); /* remove hardware skip */\n\n\tusb_transfer_complete(xfer);\n\n\tsplx(s);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static ohci_soft_ed_t",
            "ohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));",
            "Static ohci_soft_td_t",
            "ohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));",
            "ohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));",
            "ohci_shutdown __P((void *v));",
            "ohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));",
            "ohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));",
            "ohci_device_request __P((usbd_xfer_handle xfer));",
            "ohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
            "ohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
            "ohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));",
            "ohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));",
            "Static ohci_soft_td_t",
            "ohci_setup_isoc __P((usbd_pipe_handle pipe));",
            "ohci_device_isoc_enter __P((usbd_xfer_handle));",
            "Static usbd_xfer_handle",
            "ohci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
            "ohci_root_ctrl_transfer __P((usbd_xfer_handle));",
            "ohci_root_ctrl_start __P((usbd_xfer_handle));",
            "ohci_root_ctrl_abort __P((usbd_xfer_handle));",
            "ohci_root_ctrl_done  __P((usbd_xfer_handle));",
            "ohci_root_intr_transfer __P((usbd_xfer_handle));",
            "ohci_root_intr_start __P((usbd_xfer_handle));",
            "ohci_root_intr_abort __P((usbd_xfer_handle));",
            "ohci_root_intr_done  __P((usbd_xfer_handle));",
            "ohci_device_ctrl_transfer __P((usbd_xfer_handle));",
            "ohci_device_ctrl_start __P((usbd_xfer_handle));",
            "ohci_device_ctrl_abort __P((usbd_xfer_handle));",
            "ohci_device_ctrl_done  __P((usbd_xfer_handle));",
            "ohci_device_bulk_transfer __P((usbd_xfer_handle));",
            "ohci_device_bulk_start __P((usbd_xfer_handle));",
            "ohci_device_bulk_abort __P((usbd_xfer_handle));",
            "ohci_device_bulk_done  __P((usbd_xfer_handle));",
            "ohci_device_intr_transfer __P((usbd_xfer_handle));",
            "ohci_device_intr_start __P((usbd_xfer_handle));",
            "ohci_device_intr_abort __P((usbd_xfer_handle));",
            "ohci_device_intr_done  __P((usbd_xfer_handle));",
            "ohci_device_isoc_transfer __P((usbd_xfer_handle));",
            "ohci_device_isoc_start __P((usbd_xfer_handle));",
            "ohci_device_isoc_abort __P((usbd_xfer_handle));",
            "ohci_device_isoc_done  __P((usbd_xfer_handle));",
            "ohci_rhsc_able __P((ohci_softc_t *, int));",
            "ohci_device_clear_toggle __P((usbd_pipe_handle pipe));",
            "ohci_noop __P((usbd_pipe_handle pipe));",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
            "ohci_intr1 __P((ohci_softc_t *));",
            "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_ed_t;\nohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));\nStatic ohci_soft_td_t;\nohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));\nohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));\nohci_shutdown __P((void *v));\nohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));\nohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));\nohci_device_request __P((usbd_xfer_handle xfer));\nohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));\nohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));\nStatic ohci_soft_td_t;\nohci_setup_isoc __P((usbd_pipe_handle pipe));\nohci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_xfer_handle;\nohci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nohci_root_ctrl_transfer __P((usbd_xfer_handle));\nohci_root_ctrl_start __P((usbd_xfer_handle));\nohci_root_ctrl_abort __P((usbd_xfer_handle));\nohci_root_ctrl_done  __P((usbd_xfer_handle));\nohci_root_intr_transfer __P((usbd_xfer_handle));\nohci_root_intr_start __P((usbd_xfer_handle));\nohci_root_intr_abort __P((usbd_xfer_handle));\nohci_root_intr_done  __P((usbd_xfer_handle));\nohci_device_ctrl_transfer __P((usbd_xfer_handle));\nohci_device_ctrl_start __P((usbd_xfer_handle));\nohci_device_ctrl_abort __P((usbd_xfer_handle));\nohci_device_ctrl_done  __P((usbd_xfer_handle));\nohci_device_bulk_transfer __P((usbd_xfer_handle));\nohci_device_bulk_start __P((usbd_xfer_handle));\nohci_device_bulk_abort __P((usbd_xfer_handle));\nohci_device_bulk_done  __P((usbd_xfer_handle));\nohci_device_intr_transfer __P((usbd_xfer_handle));\nohci_device_intr_start __P((usbd_xfer_handle));\nohci_device_intr_abort __P((usbd_xfer_handle));\nohci_device_intr_done  __P((usbd_xfer_handle));\nohci_device_isoc_transfer __P((usbd_xfer_handle));\nohci_device_isoc_start __P((usbd_xfer_handle));\nohci_device_isoc_abort __P((usbd_xfer_handle));\nohci_device_isoc_done  __P((usbd_xfer_handle));\nohci_rhsc_able __P((ohci_softc_t *, int));\nohci_device_clear_toggle __P((usbd_pipe_handle pipe));\nohci_noop __P((usbd_pipe_handle pipe));\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nvoid\nohci_abort_xfer_end(v)\n\tvoid *v;\n{\n\tusbd_xfer_handle xfer = v;\n\tstruct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;\n\tohci_softc_t *sc = (ohci_softc_t *)opipe->pipe.device->bus;\n\tohci_soft_ed_t *sed;\n\tohci_soft_td_t *p, *n;\n\tint s;\n\n\ts = splusb();\n\n\tp = xfer->hcpriv;\n#ifdef DIAGNOSTIC\n\tif (p == NULL) {\n\t\tprintf(\"ohci_abort_xfer: hcpriv==0\\n\");\n\t\treturn;\n\t}\n#endif\n\tfor (; p->xfer == xfer; p = n) {\n\t\tn = p->nexttd;\n\t\tohci_free_std(sc, p);\n\t}\n\n\tsed = opipe->sed;\n\tDPRINTFN(2,(\"ohci_abort_xfer: set hd=%x, tl=%x\\n\",\n\t\t    (int)p->physaddr, (int)le32toh(sed->ed.ed_tailp)));\n\tsed->ed.ed_headp = htole32(p->physaddr); /* unlink TDs */\n\tsed->ed.ed_flags &= htole32(~OHCI_ED_SKIP); /* remove hardware skip */\n\n\tusb_transfer_complete(xfer);\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "1000"
          ],
          "line": 2054
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_delay_ms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "316-322",
          "snippet": "void\nusbd_delay_ms(dev, ms)\n\tusbd_device_handle dev;\n\tu_int ms;\n{\n\tusb_delay_ms(dev->bus, ms);\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_set_config __P((usbd_device_handle, int));",
            "usbd_getnewaddr __P((usbd_bus_handle bus));",
            "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_set_config __P((usbd_device_handle, int));\nusbd_getnewaddr __P((usbd_bus_handle bus));\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\n\nvoid\nusbd_delay_ms(dev, ms)\n\tusbd_device_handle dev;\n\tu_int ms;\n{\n\tusb_delay_ms(dev->bus, ms);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usb_delay_ms",
          "args": [
            "opipe->pipe.device->bus",
            "1"
          ],
          "line": 2050
        },
        "resolved": true,
        "details": {
          "function_name": "usb_delay_ms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "301-313",
          "snippet": "void\nusb_delay_ms(bus, ms)\n\tusbd_bus_handle bus;\n\tu_int ms;\n{\n\textern int cold;\n\n\t/* Wait at least two clock ticks so we know the time has passed. */\n\tif (bus->use_polling || cold)\n\t\tdelay((ms+1) * 1000);\n\telse\n\t\ttsleep(&ms, PRIBIO, \"usbdly\", (ms*hz+999)/1000 + 1);\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_getnewaddr __P((usbd_bus_handle bus));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_getnewaddr __P((usbd_bus_handle bus));\n\nvoid\nusb_delay_ms(bus, ms)\n\tusbd_bus_handle bus;\n\tu_int ms;\n{\n\textern int cold;\n\n\t/* Wait at least two clock ticks so we know the time has passed. */\n\tif (bus->use_polling || cold)\n\t\tdelay((ms+1) * 1000);\n\telse\n\t\ttsleep(&ms, PRIBIO, \"usbdly\", (ms*hz+999)/1000 + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KASSERT",
          "args": [
            "intr_nesting_level == 0",
            "(\"ohci_abort_req in interrupt context\")"
          ],
          "line": 2047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_callout",
          "args": [
            "xfer->pipe->abort_handle",
            "hz / USB_FRAMES_PER_SECOND",
            "ohci_abort_xfer_end",
            "xfer"
          ],
          "line": 2043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "OHCI_ED_SKIP"
          ],
          "line": 2038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"ohci_abort_xfer: stop ed=%p\\n\", sed)"
          ],
          "line": 2037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_uncallout",
          "args": [
            "xfer->timeout_handle",
            "ohci_timeout",
            "xfer"
          ],
          "line": 2034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ohci_abort_xfer: xfer=%p pipe=%p\\n\", xfer, opipe)"
          ],
          "line": 2030
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_ed_t;\nohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));\nStatic usbd_status;\nStatic usbd_status;\nohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));\nohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));\nStatic usbd_status;\nohci_device_request __P((usbd_xfer_handle xfer));\nohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nStatic usbd_status;\nohci_setup_isoc __P((usbd_pipe_handle pipe));\nohci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic usbd_xfer_handle;\nohci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nStatic usbd_status;\nohci_root_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_ctrl_start __P((usbd_xfer_handle));\nohci_root_ctrl_abort __P((usbd_xfer_handle));\nohci_root_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_intr_start __P((usbd_xfer_handle));\nohci_root_intr_abort __P((usbd_xfer_handle));\nohci_root_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_ctrl_start __P((usbd_xfer_handle));\nohci_device_ctrl_abort __P((usbd_xfer_handle));\nohci_device_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_bulk_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_bulk_start __P((usbd_xfer_handle));\nohci_device_bulk_abort __P((usbd_xfer_handle));\nohci_device_bulk_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_intr_start __P((usbd_xfer_handle));\nohci_device_intr_abort __P((usbd_xfer_handle));\nohci_device_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_isoc_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_isoc_start __P((usbd_xfer_handle));\nohci_device_isoc_abort __P((usbd_xfer_handle));\nohci_device_isoc_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_abort_xfer __P((usbd_xfer_handle xfer,\n\t\t\t    usbd_status status));\nohci_device_clear_toggle __P((usbd_pipe_handle pipe));\nohci_noop __P((usbd_pipe_handle pipe));\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\n\nvoid\nohci_abort_xfer(xfer, status)\n\tusbd_xfer_handle xfer;\n\tusbd_status status;\n{\n\tstruct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;\n\tohci_soft_ed_t *sed;\n\n\tDPRINTF((\"ohci_abort_xfer: xfer=%p pipe=%p\\n\", xfer, opipe));\n\n\txfer->status = status;\n\n\tusb_uncallout(xfer->timeout_handle, ohci_timeout, xfer);\n\n\tsed = opipe->sed;\n\tDPRINTFN(1,(\"ohci_abort_xfer: stop ed=%p\\n\", sed));\n\tsed->ed.ed_flags |= htole32(OHCI_ED_SKIP); /* force hardware skip */\n\n#if 1\n\tif (xfer->device->bus->intr_context) {\n\t\t/* We have no process context, so we can't use tsleep(). */\n\t\tusb_callout(xfer->pipe->abort_handle,\n\t\t    hz / USB_FRAMES_PER_SECOND, ohci_abort_xfer_end, xfer);\n\t} else {\n#if defined(DIAGNOSTIC) && defined(__i386__) && defined(__FreeBSD__)\n\t\tKASSERT(intr_nesting_level == 0,\n\t        \t(\"ohci_abort_req in interrupt context\"));\n#endif\n\t\tusb_delay_ms(opipe->pipe.device->bus, 1);\n\t\tohci_abort_xfer_end(xfer);\n\t}\n#else\n\tdelay(1000);\n\tohci_abort_xfer_end(xfer);\n#endif\n}"
  },
  {
    "function_name": "ohci_close_pipe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "1974-2010",
    "snippet": "void\nohci_close_pipe(pipe, head)\n\tusbd_pipe_handle pipe;\n\tohci_soft_ed_t *head;\n{\n\tstruct ohci_pipe *opipe = (struct ohci_pipe *)pipe;\n\tohci_softc_t *sc = (ohci_softc_t *)pipe->device->bus;\n\tohci_soft_ed_t *sed = opipe->sed;\n\tint s;\n\n\ts = splusb();\n#ifdef DIAGNOSTIC\n\tsed->ed.ed_flags |= htole32(OHCI_ED_SKIP);\n\tif ((le32toh(sed->ed.ed_tailp) & OHCI_HEADMASK) != \n\t    (le32toh(sed->ed.ed_headp) & OHCI_HEADMASK)) {\n\t\tohci_physaddr_t td = le32toh(sed->ed.ed_headp);\n\t\tohci_soft_td_t *std;\n\t\tfor (std = LIST_FIRST(&sc->sc_hash_tds[HASH(td)]); \n\t\t     std != NULL;\n\t\t     std = LIST_NEXT(std, hnext))\n\t\t    if (std->physaddr == td)\n\t\t\tbreak;\n\t\tprintf(\"ohci_close_pipe: pipe not empty sed=%p hd=0x%x \"\n\t\t       \"tl=0x%x pipe=%p, std=%p\\n\", sed,\n\t\t       (int)le32toh(sed->ed.ed_headp),\n\t\t       (int)le32toh(sed->ed.ed_tailp),\n\t\t       pipe, std);\n\t\tusb_delay_ms(&sc->sc_bus, 2);\n\t\tif ((le32toh(sed->ed.ed_tailp) & OHCI_HEADMASK) != \n\t\t    (le32toh(sed->ed.ed_headp) & OHCI_HEADMASK))\n\t\t\tprintf(\"ohci_close_pipe: pipe still not empty\\n\");\n\t}\n#endif\n\tohci_rem_ed(sed, head);\n\tsplx(s);\n\tohci_free_sed(sc, opipe->sed);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static ohci_soft_ed_t",
      "ohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));",
      "Static ohci_soft_td_t",
      "ohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));",
      "ohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));",
      "ohci_open __P((usbd_pipe_handle));",
      "ohci_add_done __P((ohci_softc_t *, ohci_physaddr_t));",
      "ohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
      "ohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
      "ohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));",
      "ohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));",
      "Static ohci_soft_td_t",
      "ohci_setup_isoc __P((usbd_pipe_handle pipe));",
      "ohci_root_ctrl_close __P((usbd_pipe_handle));",
      "ohci_root_intr_close __P((usbd_pipe_handle));",
      "ohci_device_ctrl_close __P((usbd_pipe_handle));",
      "ohci_device_bulk_close __P((usbd_pipe_handle));",
      "ohci_device_intr_close __P((usbd_pipe_handle));",
      "ohci_device_isoc_close __P((usbd_pipe_handle));",
      "ohci_rhsc_able __P((ohci_softc_t *, int));",
      "ohci_close_pipe __P((usbd_pipe_handle pipe, \n\t\t\t    ohci_soft_ed_t *head));",
      "ohci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "ohci_noop __P((usbd_pipe_handle pipe));",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
      "ohci_intr1 __P((ohci_softc_t *));",
      "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ohci_free_sed",
          "args": [
            "sc",
            "opipe->sed"
          ],
          "line": 2009
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_free_sed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "417-424",
          "snippet": "void\nohci_free_sed(sc, sed)\n\tohci_softc_t *sc;\n\tohci_soft_ed_t *sed;\n{\n\tsed->next = sc->sc_freeeds;\n\tsc->sc_freeeds = sed;\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static ohci_soft_ed_t",
            "ohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));",
            "ohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
            "ohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
            "ohci_rhsc_able __P((ohci_softc_t *, int));",
            "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
            "ohci_intr1 __P((ohci_softc_t *));",
            "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_ed_t;\nohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));\nohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nohci_rhsc_able __P((ohci_softc_t *, int));\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nvoid\nohci_free_sed(sc, sed)\n\tohci_softc_t *sc;\n\tohci_soft_ed_t *sed;\n{\n\tsed->next = sc->sc_freeeds;\n\tsc->sc_freeeds = sed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 2008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ohci_rem_ed",
          "args": [
            "sed",
            "head"
          ],
          "line": 2007
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_rem_ed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "1655-1671",
          "snippet": "void\nohci_rem_ed(sed, head)\n\tohci_soft_ed_t *sed; \n\tohci_soft_ed_t *head; \n{\n\tohci_soft_ed_t *p; \n\n\tSPLUSBCHECK;\n\n\t/* XXX */\n\tfor (p = head; p == NULL && p->next != sed; p = p->next)\n\t\t;\n\tif (p == NULL)\n\t\tpanic(\"ohci_rem_ed: ED not found\\n\");\n\tp->next = sed->next;\n\tp->ed.ed_nexted = sed->ed.ed_nexted;\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static ohci_soft_ed_t",
            "ohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));",
            "ohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
            "ohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
            "ohci_close_pipe __P((usbd_pipe_handle pipe, \n\t\t\t    ohci_soft_ed_t *head));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_ed_t;\nohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));\nohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nohci_close_pipe __P((usbd_pipe_handle pipe, \n\t\t\t    ohci_soft_ed_t *head));\n\nvoid\nohci_rem_ed(sed, head)\n\tohci_soft_ed_t *sed; \n\tohci_soft_ed_t *head; \n{\n\tohci_soft_ed_t *p; \n\n\tSPLUSBCHECK;\n\n\t/* XXX */\n\tfor (p = head; p == NULL && p->next != sed; p = p->next)\n\t\t;\n\tif (p == NULL)\n\t\tpanic(\"ohci_rem_ed: ED not found\\n\");\n\tp->next = sed->next;\n\tp->ed.ed_nexted = sed->ed.ed_nexted;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ohci_close_pipe: pipe still not empty\\n\""
          ],
          "line": 2004
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "sed->ed.ed_headp"
          ],
          "line": 2003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "sed->ed.ed_tailp"
          ],
          "line": 2002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_delay_ms",
          "args": [
            "&sc->sc_bus",
            "2"
          ],
          "line": 2001
        },
        "resolved": true,
        "details": {
          "function_name": "usb_delay_ms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "301-313",
          "snippet": "void\nusb_delay_ms(bus, ms)\n\tusbd_bus_handle bus;\n\tu_int ms;\n{\n\textern int cold;\n\n\t/* Wait at least two clock ticks so we know the time has passed. */\n\tif (bus->use_polling || cold)\n\t\tdelay((ms+1) * 1000);\n\telse\n\t\ttsleep(&ms, PRIBIO, \"usbdly\", (ms*hz+999)/1000 + 1);\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_getnewaddr __P((usbd_bus_handle bus));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_getnewaddr __P((usbd_bus_handle bus));\n\nvoid\nusb_delay_ms(bus, ms)\n\tusbd_bus_handle bus;\n\tu_int ms;\n{\n\textern int cold;\n\n\t/* Wait at least two clock ticks so we know the time has passed. */\n\tif (bus->use_polling || cold)\n\t\tdelay((ms+1) * 1000);\n\telse\n\t\ttsleep(&ms, PRIBIO, \"usbdly\", (ms*hz+999)/1000 + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "sed->ed.ed_tailp"
          ],
          "line": 1999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "sed->ed.ed_headp"
          ],
          "line": 1998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_NEXT",
          "args": [
            "std",
            "hnext"
          ],
          "line": 1993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_FIRST",
          "args": [
            "&sc->sc_hash_tds[HASH(td)]"
          ],
          "line": 1991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HASH",
          "args": [
            "td"
          ],
          "line": 1991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "sed->ed.ed_headp"
          ],
          "line": 1989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "sed->ed.ed_headp"
          ],
          "line": 1988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "sed->ed.ed_tailp"
          ],
          "line": 1987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "OHCI_ED_SKIP"
          ],
          "line": 1986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 1984
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_ed_t;\nohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));\nStatic ohci_soft_td_t;\nohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));\nohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));\nohci_open __P((usbd_pipe_handle));\nohci_add_done __P((ohci_softc_t *, ohci_physaddr_t));\nohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));\nohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));\nStatic ohci_soft_td_t;\nohci_setup_isoc __P((usbd_pipe_handle pipe));\nohci_root_ctrl_close __P((usbd_pipe_handle));\nohci_root_intr_close __P((usbd_pipe_handle));\nohci_device_ctrl_close __P((usbd_pipe_handle));\nohci_device_bulk_close __P((usbd_pipe_handle));\nohci_device_intr_close __P((usbd_pipe_handle));\nohci_device_isoc_close __P((usbd_pipe_handle));\nohci_rhsc_able __P((ohci_softc_t *, int));\nohci_close_pipe __P((usbd_pipe_handle pipe, \n\t\t\t    ohci_soft_ed_t *head));\nohci_device_clear_toggle __P((usbd_pipe_handle pipe));\nohci_noop __P((usbd_pipe_handle pipe));\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nvoid\nohci_close_pipe(pipe, head)\n\tusbd_pipe_handle pipe;\n\tohci_soft_ed_t *head;\n{\n\tstruct ohci_pipe *opipe = (struct ohci_pipe *)pipe;\n\tohci_softc_t *sc = (ohci_softc_t *)pipe->device->bus;\n\tohci_soft_ed_t *sed = opipe->sed;\n\tint s;\n\n\ts = splusb();\n#ifdef DIAGNOSTIC\n\tsed->ed.ed_flags |= htole32(OHCI_ED_SKIP);\n\tif ((le32toh(sed->ed.ed_tailp) & OHCI_HEADMASK) != \n\t    (le32toh(sed->ed.ed_headp) & OHCI_HEADMASK)) {\n\t\tohci_physaddr_t td = le32toh(sed->ed.ed_headp);\n\t\tohci_soft_td_t *std;\n\t\tfor (std = LIST_FIRST(&sc->sc_hash_tds[HASH(td)]); \n\t\t     std != NULL;\n\t\t     std = LIST_NEXT(std, hnext))\n\t\t    if (std->physaddr == td)\n\t\t\tbreak;\n\t\tprintf(\"ohci_close_pipe: pipe not empty sed=%p hd=0x%x \"\n\t\t       \"tl=0x%x pipe=%p, std=%p\\n\", sed,\n\t\t       (int)le32toh(sed->ed.ed_headp),\n\t\t       (int)le32toh(sed->ed.ed_tailp),\n\t\t       pipe, std);\n\t\tusb_delay_ms(&sc->sc_bus, 2);\n\t\tif ((le32toh(sed->ed.ed_tailp) & OHCI_HEADMASK) != \n\t\t    (le32toh(sed->ed.ed_headp) & OHCI_HEADMASK))\n\t\t\tprintf(\"ohci_close_pipe: pipe still not empty\\n\");\n\t}\n#endif\n\tohci_rem_ed(sed, head);\n\tsplx(s);\n\tohci_free_sed(sc, opipe->sed);\n}"
  },
  {
    "function_name": "ohci_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "1862-1968",
    "snippet": "usbd_status\nohci_open(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tusbd_device_handle dev = pipe->device;\n\tohci_softc_t *sc = (ohci_softc_t *)dev->bus;\n\tusb_endpoint_descriptor_t *ed = pipe->endpoint->edesc;\n\tstruct ohci_pipe *opipe = (struct ohci_pipe *)pipe;\n\tu_int8_t addr = dev->address;\n\tu_int8_t xfertype = ed->bmAttributes & UE_XFERTYPE;\n\tohci_soft_ed_t *sed;\n\tohci_soft_td_t *std;\n\tohci_soft_itd_t *sitd;\n\tohci_physaddr_t tdphys;\n\tu_int32_t fmt;\n\tusbd_status err;\n\tint s;\n\tint ival;\n\n\tDPRINTFN(1, (\"ohci_open: pipe=%p, addr=%d, endpt=%d (%d)\\n\",\n\t\t     pipe, addr, ed->bEndpointAddress, sc->sc_addr));\n\n\tif (addr == sc->sc_addr) {\n\t\tswitch (ed->bEndpointAddress) {\n\t\tcase USB_CONTROL_ENDPOINT:\n\t\t\tpipe->methods = &ohci_root_ctrl_methods;\n\t\t\tbreak;\n\t\tcase UE_DIR_IN | OHCI_INTR_ENDPT:\n\t\t\tpipe->methods = &ohci_root_intr_methods;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn (USBD_INVAL);\n\t\t}\n\t} else {\n\t\tsed = ohci_alloc_sed(sc);\n\t\tif (sed == NULL)\n\t\t\tgoto bad0;\n\t\topipe->sed = sed;\n\t\tif (xfertype == UE_ISOCHRONOUS) {\n\t\t\tsitd = ohci_alloc_sitd(sc);\n\t\t\tif (sitd == NULL) {\n\t\t\t\tohci_free_sitd(sc, sitd);\n\t\t\t\tgoto bad1;\n\t\t\t}\n\t\t\topipe->tail.itd = sitd;\n\t\t\ttdphys = sitd->physaddr;\n\t\t\tfmt = OHCI_ED_FORMAT_ISO;\n\t\t\tif (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN)\n\t\t\t\tfmt |= OHCI_ED_DIR_IN;\n\t\t\telse\n\t\t\t\tfmt |= OHCI_ED_DIR_OUT;\n\t\t} else {\n\t\t\tstd = ohci_alloc_std(sc);\n\t\t\tif (std == NULL) {\n\t\t\t\tohci_free_std(sc, std);\n\t\t\t\tgoto bad1;\n\t\t\t}\n\t\t\topipe->tail.td = std;\n\t\t\ttdphys = std->physaddr;\n\t\t\tfmt = OHCI_ED_FORMAT_GEN | OHCI_ED_DIR_TD;\n\t\t}\n\t\tsed->ed.ed_flags = htole32(\n\t\t\tOHCI_ED_SET_FA(addr) | \n\t\t\tOHCI_ED_SET_EN(ed->bEndpointAddress) |\n\t\t\t(dev->lowspeed ? OHCI_ED_SPEED : 0) | fmt |\n\t\t\tOHCI_ED_SET_MAXP(UGETW(ed->wMaxPacketSize)));\n\t\tsed->ed.ed_headp = sed->ed.ed_tailp = htole32(tdphys);\n\n\t\tswitch (xfertype) {\n\t\tcase UE_CONTROL:\n\t\t\tpipe->methods = &ohci_device_ctrl_methods;\n\t\t\terr = usb_allocmem(&sc->sc_bus, \n\t\t\t\t  sizeof(usb_device_request_t), \n\t\t\t\t  0, &opipe->u.ctl.reqdma);\n\t\t\tif (err)\n\t\t\t\tgoto bad;\n\t\t\ts = splusb();\n\t\t\tohci_add_ed(sed, sc->sc_ctrl_head);\n\t\t\tsplx(s);\n\t\t\tbreak;\n\t\tcase UE_INTERRUPT:\n\t\t\tpipe->methods = &ohci_device_intr_methods;\n\t\t\tival = pipe->interval;\n\t\t\tif (ival == USBD_DEFAULT_INTERVAL)\n\t\t\t\tival = ed->bInterval;\n\t\t\treturn (ohci_device_setintr(sc, opipe, ival));\n\t\tcase UE_ISOCHRONOUS:\n\t\t\tpipe->methods = &ohci_device_isoc_methods;\n\t\t\treturn (ohci_setup_isoc(pipe));\n\t\tcase UE_BULK:\n\t\t\tpipe->methods = &ohci_device_bulk_methods;\n\t\t\ts = splusb();\n\t\t\tohci_add_ed(sed, sc->sc_bulk_head);\n\t\t\tsplx(s);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn (USBD_NORMAL_COMPLETION);\n\n bad:\n\tohci_free_std(sc, std);\n bad1:\n\tohci_free_sed(sc, sed);\n bad0:\n\treturn (USBD_NOMEM);\n\t\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define OHCI_INTR_ENDPT 1"
    ],
    "globals_used": [
      "Static ohci_soft_ed_t",
      "ohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));",
      "Static ohci_soft_td_t",
      "ohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));",
      "Static ohci_soft_itd_t",
      "ohci_free_sitd __P((ohci_softc_t *,ohci_soft_itd_t *));",
      "Static usbd_status",
      "ohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));",
      "Static usbd_status",
      "ohci_open __P((usbd_pipe_handle));",
      "ohci_add_done __P((ohci_softc_t *, ohci_physaddr_t));",
      "Static usbd_status",
      "ohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
      "ohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
      "ohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));",
      "ohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));",
      "Static ohci_soft_td_t",
      "ohci_hash_add_itd __P((ohci_softc_t *, \n\t\t\t    ohci_soft_itd_t *));",
      "ohci_hash_rem_itd __P((ohci_softc_t *,\n\t\t\t    ohci_soft_itd_t *));",
      "Static ohci_soft_itd_t",
      "Static usbd_status",
      "ohci_setup_isoc __P((usbd_pipe_handle pipe));",
      "Static usbd_status",
      "ohci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));",
      "Static usbd_status",
      "Static usbd_status",
      "ohci_root_ctrl_close __P((usbd_pipe_handle));",
      "Static usbd_status",
      "Static usbd_status",
      "ohci_root_intr_close __P((usbd_pipe_handle));",
      "Static usbd_status",
      "Static usbd_status",
      "ohci_device_ctrl_close __P((usbd_pipe_handle));",
      "Static usbd_status",
      "Static usbd_status",
      "ohci_device_bulk_close __P((usbd_pipe_handle));",
      "Static usbd_status",
      "Static usbd_status",
      "ohci_device_intr_close __P((usbd_pipe_handle));",
      "Static usbd_status",
      "Static usbd_status",
      "ohci_device_isoc_close __P((usbd_pipe_handle));",
      "Static usbd_status",
      "ohci_device_setintr __P((ohci_softc_t *sc, \n\t\t\t    struct ohci_pipe *pipe, int ival));",
      "ohci_rhsc_able __P((ohci_softc_t *, int));",
      "ohci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "ohci_noop __P((usbd_pipe_handle pipe));",
      "Static struct",
      "Static struct",
      "usbd_pipe_methods ohci_root_ctrl_methods = {\t\n\tohci_root_ctrl_transfer,\n\tohci_root_ctrl_start,\n\tohci_root_ctrl_abort,\n\tohci_root_ctrl_close,\n\tohci_noop,\n\tohci_root_ctrl_done,\n};",
      "Static struct",
      "usbd_pipe_methods ohci_root_intr_methods = {\t\n\tohci_root_intr_transfer,\n\tohci_root_intr_start,\n\tohci_root_intr_abort,\n\tohci_root_intr_close,\n\tohci_noop,\n\tohci_root_intr_done,\n};",
      "Static struct",
      "usbd_pipe_methods ohci_device_ctrl_methods = {\t\n\tohci_device_ctrl_transfer,\n\tohci_device_ctrl_start,\n\tohci_device_ctrl_abort,\n\tohci_device_ctrl_close,\n\tohci_noop,\n\tohci_device_ctrl_done,\n};",
      "Static struct",
      "usbd_pipe_methods ohci_device_intr_methods = {\t\n\tohci_device_intr_transfer,\n\tohci_device_intr_start,\n\tohci_device_intr_abort,\n\tohci_device_intr_close,\n\tohci_device_clear_toggle,\n\tohci_device_intr_done,\n};",
      "Static struct",
      "usbd_pipe_methods ohci_device_bulk_methods = {\t\n\tohci_device_bulk_transfer,\n\tohci_device_bulk_start,\n\tohci_device_bulk_abort,\n\tohci_device_bulk_close,\n\tohci_device_clear_toggle,\n\tohci_device_bulk_done,\n};",
      "Static struct",
      "usbd_pipe_methods ohci_device_isoc_methods = {\n\tohci_device_isoc_transfer,\n\tohci_device_isoc_start,\n\tohci_device_isoc_abort,\n\tohci_device_isoc_close,\n\tohci_noop,\n\tohci_device_isoc_done,\n};",
      "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
      "ohci_intr1 __P((ohci_softc_t *));",
      "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ohci_free_sed",
          "args": [
            "sc",
            "sed"
          ],
          "line": 1964
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_free_sed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "417-424",
          "snippet": "void\nohci_free_sed(sc, sed)\n\tohci_softc_t *sc;\n\tohci_soft_ed_t *sed;\n{\n\tsed->next = sc->sc_freeeds;\n\tsc->sc_freeeds = sed;\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static ohci_soft_ed_t",
            "ohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));",
            "ohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
            "ohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
            "ohci_rhsc_able __P((ohci_softc_t *, int));",
            "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
            "ohci_intr1 __P((ohci_softc_t *));",
            "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_ed_t;\nohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));\nohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nohci_rhsc_able __P((ohci_softc_t *, int));\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nvoid\nohci_free_sed(sc, sed)\n\tohci_softc_t *sc;\n\tohci_soft_ed_t *sed;\n{\n\tsed->next = sc->sc_freeeds;\n\tsc->sc_freeeds = sed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ohci_free_std",
          "args": [
            "sc",
            "std"
          ],
          "line": 1962
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_free_std_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "577-589",
          "snippet": "Static void\nohci_free_std_chain(sc, std, stdend)\n\tohci_softc_t *sc;\n\tohci_soft_td_t *std;\n\tohci_soft_td_t *stdend;\n{\n\tohci_soft_td_t *p;\n\n\tfor (; std != stdend; std = p) {\n\t\tp = std->nexttd;\n\t\tohci_free_std(sc, std);\n\t}\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static void",
            "Static ohci_soft_td_t",
            "Static void",
            "ohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));",
            "Static void",
            "ohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "ohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));",
            "Static void",
            "ohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));",
            "Static ohci_soft_td_t",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "ohci_rhsc_able __P((ohci_softc_t *, int));",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
            "Static int",
            "ohci_intr1 __P((ohci_softc_t *));",
            "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nStatic ohci_soft_td_t;\nStatic void;\nohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));\nStatic void;\nohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));\nStatic void;\nohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));\nStatic ohci_soft_td_t;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nohci_rhsc_able __P((ohci_softc_t *, int));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nStatic int;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nStatic void\nohci_free_std_chain(sc, std, stdend)\n\tohci_softc_t *sc;\n\tohci_soft_td_t *std;\n\tohci_soft_td_t *stdend;\n{\n\tohci_soft_td_t *p;\n\n\tfor (; std != stdend; std = p) {\n\t\tp = std->nexttd;\n\t\tohci_free_std(sc, std);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ohci_add_ed",
          "args": [
            "sed",
            "sc->sc_bulk_head"
          ],
          "line": 1954
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_add_ed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "1640-1650",
          "snippet": "void\nohci_add_ed(sed, head)\n\tohci_soft_ed_t *sed; \n\tohci_soft_ed_t *head; \n{\n\tSPLUSBCHECK;\n\tsed->next = head->next;\n\tsed->ed.ed_nexted = head->ed.ed_nexted;\n\thead->next = sed;\n\thead->ed.ed_nexted = htole32(sed->physaddr);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static ohci_soft_ed_t",
            "ohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));",
            "ohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
            "ohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
            "ohci_close_pipe __P((usbd_pipe_handle pipe, \n\t\t\t    ohci_soft_ed_t *head));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_ed_t;\nohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));\nohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nohci_close_pipe __P((usbd_pipe_handle pipe, \n\t\t\t    ohci_soft_ed_t *head));\n\nvoid\nohci_add_ed(sed, head)\n\tohci_soft_ed_t *sed; \n\tohci_soft_ed_t *head; \n{\n\tSPLUSBCHECK;\n\tsed->next = head->next;\n\tsed->ed.ed_nexted = head->ed.ed_nexted;\n\thead->next = sed;\n\thead->ed.ed_nexted = htole32(sed->physaddr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 1953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ohci_setup_isoc",
          "args": [
            "pipe"
          ],
          "line": 1950
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_setup_isoc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "3253-3270",
          "snippet": "usbd_status\nohci_setup_isoc(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tstruct ohci_pipe *opipe = (struct ohci_pipe *)pipe;\n\tohci_softc_t *sc = (ohci_softc_t *)pipe->device->bus;\n\tstruct iso *iso = &opipe->u.iso;\n\tint s;\n\n\tiso->next = -1;\n\tiso->inuse = 0;\n\n\ts = splusb();\n\tohci_add_ed(opipe->sed, sc->sc_isoc_head);\n\tsplx(s);\n\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "Static usbd_status",
            "ohci_open __P((usbd_pipe_handle));",
            "Static usbd_status",
            "Static usbd_status",
            "ohci_setup_isoc __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "ohci_root_ctrl_close __P((usbd_pipe_handle));",
            "Static usbd_status",
            "Static usbd_status",
            "ohci_root_intr_close __P((usbd_pipe_handle));",
            "Static usbd_status",
            "Static usbd_status",
            "ohci_device_ctrl_close __P((usbd_pipe_handle));",
            "Static usbd_status",
            "Static usbd_status",
            "ohci_device_bulk_close __P((usbd_pipe_handle));",
            "Static usbd_status",
            "Static usbd_status",
            "ohci_device_intr_close __P((usbd_pipe_handle));",
            "Static usbd_status",
            "Static usbd_status",
            "ohci_device_isoc_close __P((usbd_pipe_handle));",
            "Static usbd_status",
            "ohci_rhsc_able __P((ohci_softc_t *, int));",
            "ohci_device_clear_toggle __P((usbd_pipe_handle pipe));",
            "ohci_noop __P((usbd_pipe_handle pipe));",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
            "ohci_intr1 __P((ohci_softc_t *));",
            "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nStatic usbd_status;\nohci_open __P((usbd_pipe_handle));\nStatic usbd_status;\nStatic usbd_status;\nohci_setup_isoc __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nohci_root_ctrl_close __P((usbd_pipe_handle));\nStatic usbd_status;\nStatic usbd_status;\nohci_root_intr_close __P((usbd_pipe_handle));\nStatic usbd_status;\nStatic usbd_status;\nohci_device_ctrl_close __P((usbd_pipe_handle));\nStatic usbd_status;\nStatic usbd_status;\nohci_device_bulk_close __P((usbd_pipe_handle));\nStatic usbd_status;\nStatic usbd_status;\nohci_device_intr_close __P((usbd_pipe_handle));\nStatic usbd_status;\nStatic usbd_status;\nohci_device_isoc_close __P((usbd_pipe_handle));\nStatic usbd_status;\nohci_rhsc_able __P((ohci_softc_t *, int));\nohci_device_clear_toggle __P((usbd_pipe_handle pipe));\nohci_noop __P((usbd_pipe_handle pipe));\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nusbd_status\nohci_setup_isoc(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tstruct ohci_pipe *opipe = (struct ohci_pipe *)pipe;\n\tohci_softc_t *sc = (ohci_softc_t *)pipe->device->bus;\n\tstruct iso *iso = &opipe->u.iso;\n\tint s;\n\n\tiso->next = -1;\n\tiso->inuse = 0;\n\n\ts = splusb();\n\tohci_add_ed(opipe->sed, sc->sc_isoc_head);\n\tsplx(s);\n\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ohci_device_setintr",
          "args": [
            "sc",
            "opipe",
            "ival"
          ],
          "line": 1947
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_device_setintr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "2938-3001",
          "snippet": "Static usbd_status\nohci_device_setintr(sc, opipe, ival)\n\tohci_softc_t *sc;\n\tstruct ohci_pipe *opipe;\n\tint ival;\n{\n\tint i, j, s, best;\n\tu_int npoll, slow, shigh, nslots;\n\tu_int bestbw, bw;\n\tohci_soft_ed_t *hsed, *sed = opipe->sed;\n\n\tDPRINTFN(2, (\"ohci_setintr: pipe=%p\\n\", opipe));\n\tif (ival == 0) {\n\t\tprintf(\"ohci_setintr: 0 interval\\n\");\n\t\treturn (USBD_INVAL);\n\t}\n\n\tnpoll = OHCI_NO_INTRS;\n\twhile (npoll > ival)\n\t\tnpoll /= 2;\n\tDPRINTFN(2, (\"ohci_setintr: ival=%d npoll=%d\\n\", ival, npoll));\n\n\t/*\n\t * We now know which level in the tree the ED must go into.\n\t * Figure out which slot has most bandwidth left over.\n\t * Slots to examine:\n\t * npoll\n\t * 1\t0\n\t * 2\t1 2\n\t * 4\t3 4 5 6\n\t * 8\t7 8 9 10 11 12 13 14\n\t * N    (N-1) .. (N-1+N-1)\n\t */\n\tslow = npoll-1;\n\tshigh = slow + npoll;\n\tnslots = OHCI_NO_INTRS / npoll;\n\tfor (best = i = slow, bestbw = ~0; i < shigh; i++) {\n\t\tbw = 0;\n\t\tfor (j = 0; j < nslots; j++)\n\t\t\tbw += sc->sc_bws[(i * nslots + j) % OHCI_NO_INTRS];\n\t\tif (bw < bestbw) {\n\t\t\tbest = i;\n\t\t\tbestbw = bw;\n\t\t}\n\t}\n\tDPRINTFN(2, (\"ohci_setintr: best=%d(%d..%d) bestbw=%d\\n\", \n\t\t     best, slow, shigh, bestbw));\n\n\ts = splusb();\n\thsed = sc->sc_eds[best];\n\tsed->next = hsed->next;\n\tsed->ed.ed_nexted = hsed->ed.ed_nexted;\n\thsed->next = sed;\n\thsed->ed.ed_nexted = htole32(sed->physaddr);\n\tsplx(s);\n\n\tfor (j = 0; j < nslots; j++)\n\t\t++sc->sc_bws[(best * nslots + j) % OHCI_NO_INTRS];\n\topipe->u.intr.nslots = nslots;\n\topipe->u.intr.pos = best;\n\n\tDPRINTFN(5, (\"ohci_setintr: returns %p\\n\", opipe));\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static ohci_soft_ed_t",
            "Static void",
            "ohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));",
            "Static void",
            "Static void",
            "Static usbd_status",
            "Static void",
            "Static void",
            "Static usbd_status",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static usbd_status",
            "Static void",
            "ohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
            "Static void",
            "ohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static usbd_status",
            "ohci_setup_isoc __P((usbd_pipe_handle pipe));",
            "Static void",
            "Static usbd_status",
            "Static void",
            "Static void",
            "Static usbd_status",
            "Static usbd_status",
            "Static void",
            "Static void",
            "Static void",
            "Static usbd_status",
            "Static usbd_status",
            "Static void",
            "Static void",
            "Static void",
            "Static usbd_status",
            "Static usbd_status",
            "Static void",
            "Static void",
            "Static void",
            "Static usbd_status",
            "Static usbd_status",
            "Static void",
            "Static void",
            "Static void",
            "Static usbd_status",
            "Static usbd_status",
            "Static void",
            "Static void",
            "Static void",
            "Static usbd_status",
            "Static usbd_status",
            "Static void",
            "Static void",
            "Static void",
            "Static usbd_status",
            "ohci_device_setintr __P((ohci_softc_t *sc, \n\t\t\t    struct ohci_pipe *pipe, int ival));",
            "Static int",
            "Static void",
            "Static void",
            "ohci_rhsc_able __P((ohci_softc_t *, int));",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "ohci_device_clear_toggle __P((usbd_pipe_handle pipe));",
            "Static void",
            "ohci_noop __P((usbd_pipe_handle pipe));",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
            "Static int",
            "ohci_intr1 __P((ohci_softc_t *));",
            "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_ed_t;\nStatic void;\nohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));\nStatic void;\nStatic void;\nStatic usbd_status;\nStatic void;\nStatic void;\nStatic usbd_status;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic usbd_status;\nStatic void;\nohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nStatic void;\nohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic usbd_status;\nohci_setup_isoc __P((usbd_pipe_handle pipe));\nStatic void;\nStatic usbd_status;\nStatic void;\nStatic void;\nStatic usbd_status;\nStatic usbd_status;\nStatic void;\nStatic void;\nStatic void;\nStatic usbd_status;\nStatic usbd_status;\nStatic void;\nStatic void;\nStatic void;\nStatic usbd_status;\nStatic usbd_status;\nStatic void;\nStatic void;\nStatic void;\nStatic usbd_status;\nStatic usbd_status;\nStatic void;\nStatic void;\nStatic void;\nStatic usbd_status;\nStatic usbd_status;\nStatic void;\nStatic void;\nStatic void;\nStatic usbd_status;\nStatic usbd_status;\nStatic void;\nStatic void;\nStatic void;\nStatic usbd_status;\nohci_device_setintr __P((ohci_softc_t *sc, \n\t\t\t    struct ohci_pipe *pipe, int ival));\nStatic int;\nStatic void;\nStatic void;\nohci_rhsc_able __P((ohci_softc_t *, int));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_device_clear_toggle __P((usbd_pipe_handle pipe));\nStatic void;\nohci_noop __P((usbd_pipe_handle pipe));\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nStatic int;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nStatic usbd_status\nohci_device_setintr(sc, opipe, ival)\n\tohci_softc_t *sc;\n\tstruct ohci_pipe *opipe;\n\tint ival;\n{\n\tint i, j, s, best;\n\tu_int npoll, slow, shigh, nslots;\n\tu_int bestbw, bw;\n\tohci_soft_ed_t *hsed, *sed = opipe->sed;\n\n\tDPRINTFN(2, (\"ohci_setintr: pipe=%p\\n\", opipe));\n\tif (ival == 0) {\n\t\tprintf(\"ohci_setintr: 0 interval\\n\");\n\t\treturn (USBD_INVAL);\n\t}\n\n\tnpoll = OHCI_NO_INTRS;\n\twhile (npoll > ival)\n\t\tnpoll /= 2;\n\tDPRINTFN(2, (\"ohci_setintr: ival=%d npoll=%d\\n\", ival, npoll));\n\n\t/*\n\t * We now know which level in the tree the ED must go into.\n\t * Figure out which slot has most bandwidth left over.\n\t * Slots to examine:\n\t * npoll\n\t * 1\t0\n\t * 2\t1 2\n\t * 4\t3 4 5 6\n\t * 8\t7 8 9 10 11 12 13 14\n\t * N    (N-1) .. (N-1+N-1)\n\t */\n\tslow = npoll-1;\n\tshigh = slow + npoll;\n\tnslots = OHCI_NO_INTRS / npoll;\n\tfor (best = i = slow, bestbw = ~0; i < shigh; i++) {\n\t\tbw = 0;\n\t\tfor (j = 0; j < nslots; j++)\n\t\t\tbw += sc->sc_bws[(i * nslots + j) % OHCI_NO_INTRS];\n\t\tif (bw < bestbw) {\n\t\t\tbest = i;\n\t\t\tbestbw = bw;\n\t\t}\n\t}\n\tDPRINTFN(2, (\"ohci_setintr: best=%d(%d..%d) bestbw=%d\\n\", \n\t\t     best, slow, shigh, bestbw));\n\n\ts = splusb();\n\thsed = sc->sc_eds[best];\n\tsed->next = hsed->next;\n\tsed->ed.ed_nexted = hsed->ed.ed_nexted;\n\thsed->next = sed;\n\thsed->ed.ed_nexted = htole32(sed->physaddr);\n\tsplx(s);\n\n\tfor (j = 0; j < nslots; j++)\n\t\t++sc->sc_bws[(best * nslots + j) % OHCI_NO_INTRS];\n\topipe->u.intr.nslots = nslots;\n\topipe->u.intr.pos = best;\n\n\tDPRINTFN(5, (\"ohci_setintr: returns %p\\n\", opipe));\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 1938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_allocmem",
          "args": [
            "&sc->sc_bus",
            "sizeof(usb_device_request_t)",
            "0",
            "&opipe->u.ctl.reqdma"
          ],
          "line": 1933
        },
        "resolved": true,
        "details": {
          "function_name": "usb_allocmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_mem.c",
          "lines": "216-269",
          "snippet": "usbd_status\nusb_allocmem(bus, size, align, p)\n\tusbd_bus_handle bus;\n\tsize_t size;\n\tsize_t align;\n        usb_dma_t *p;\n{\n\tbus_dma_tag_t tag = bus->dmatag;\n\tusbd_status err;\n\tstruct usb_frag_dma *f;\n\tusb_dma_block_t *b;\n\tint i;\n\tint s;\n\n\t/* If the request is large then just use a full block. */\n\tif (size > USB_MEM_SMALL || align > USB_MEM_SMALL) {\n\t\tDPRINTFN(1, (\"usb_allocmem: large alloc %d\\n\", (int)size));\n\t\tsize = (size + USB_MEM_BLOCK - 1) & ~(USB_MEM_BLOCK - 1);\n\t\terr = usb_block_allocmem(tag, size, align, &p->block);\n\t\tif (!err) {\n\t\t\tp->block->fullblock = 1;\n\t\t\tp->offs = 0;\n\t\t}\n\t\treturn (err);\n\t}\n\t\n\ts = splusb();\n\t/* Check for free fragments. */\n\tfor (f = LIST_FIRST(&usb_frag_freelist); f; f = LIST_NEXT(f, next))\n\t\tif (f->block->tag == tag)\n\t\t\tbreak;\n\tif (f == NULL) {\n\t\tDPRINTFN(1, (\"usb_allocmem: adding fragments\\n\"));\n\t\terr = usb_block_allocmem(tag, USB_MEM_BLOCK, USB_MEM_SMALL,&b);\n\t\tif (err) {\n\t\t\tsplx(s);\n\t\t\treturn (err);\n\t\t}\n\t\tb->fullblock = 0;\n\t\tfor (i = 0; i < USB_MEM_BLOCK; i += USB_MEM_SMALL) {\n\t\t\tf = (struct usb_frag_dma *)(b->kaddr + i);\n\t\t\tf->block = b;\n\t\t\tf->offs = i;\n\t\t\tLIST_INSERT_HEAD(&usb_frag_freelist, f, next);\n\t\t}\n\t\tf = LIST_FIRST(&usb_frag_freelist);\n\t}\n\tp->block = f->block;\n\tp->offs = f->offs;\n\tLIST_REMOVE(f, next);\n\tsplx(s);\n\tDPRINTFN(5, (\"usb_allocmem: use frag=%p size=%d\\n\", f, (int)size));\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>\t/* just for usb_dma_t */",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/proc.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>\t\t/* for usbdivar.h */",
            "#include <sys/queue.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define USB_MEM_BLOCK (USB_MEM_SMALL * USB_MEM_CHUNKS)",
            "#define USB_MEM_SMALL 64"
          ],
          "globals_used": [
            "Static usbd_status",
            "usb_block_allocmem __P((bus_dma_tag_t, size_t, size_t,\n\t\t\t\t\t\tusb_dma_block_t **));",
            "usb_block_freemem  __P((usb_dma_block_t *));",
            "Static LIST_HEAD(, usb_frag_dma) usb_frag_freelist =\n\tLIST_HEAD_INITIALIZER(usb_frag_freelist);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\t/* just for usb_dma_t */\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/proc.h>\n#include <machine/bus.h>\n#include <sys/device.h>\t\t/* for usbdivar.h */\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define USB_MEM_BLOCK (USB_MEM_SMALL * USB_MEM_CHUNKS)\n#define USB_MEM_SMALL 64\n\nStatic usbd_status;\nusb_block_allocmem __P((bus_dma_tag_t, size_t, size_t,\n\t\t\t\t\t\tusb_dma_block_t **));\nusb_block_freemem  __P((usb_dma_block_t *));\nStatic LIST_HEAD(, usb_frag_dma) usb_frag_freelist =\n\tLIST_HEAD_INITIALIZER(usb_frag_freelist);\n\nusbd_status\nusb_allocmem(bus, size, align, p)\n\tusbd_bus_handle bus;\n\tsize_t size;\n\tsize_t align;\n        usb_dma_t *p;\n{\n\tbus_dma_tag_t tag = bus->dmatag;\n\tusbd_status err;\n\tstruct usb_frag_dma *f;\n\tusb_dma_block_t *b;\n\tint i;\n\tint s;\n\n\t/* If the request is large then just use a full block. */\n\tif (size > USB_MEM_SMALL || align > USB_MEM_SMALL) {\n\t\tDPRINTFN(1, (\"usb_allocmem: large alloc %d\\n\", (int)size));\n\t\tsize = (size + USB_MEM_BLOCK - 1) & ~(USB_MEM_BLOCK - 1);\n\t\terr = usb_block_allocmem(tag, size, align, &p->block);\n\t\tif (!err) {\n\t\t\tp->block->fullblock = 1;\n\t\t\tp->offs = 0;\n\t\t}\n\t\treturn (err);\n\t}\n\t\n\ts = splusb();\n\t/* Check for free fragments. */\n\tfor (f = LIST_FIRST(&usb_frag_freelist); f; f = LIST_NEXT(f, next))\n\t\tif (f->block->tag == tag)\n\t\t\tbreak;\n\tif (f == NULL) {\n\t\tDPRINTFN(1, (\"usb_allocmem: adding fragments\\n\"));\n\t\terr = usb_block_allocmem(tag, USB_MEM_BLOCK, USB_MEM_SMALL,&b);\n\t\tif (err) {\n\t\t\tsplx(s);\n\t\t\treturn (err);\n\t\t}\n\t\tb->fullblock = 0;\n\t\tfor (i = 0; i < USB_MEM_BLOCK; i += USB_MEM_SMALL) {\n\t\t\tf = (struct usb_frag_dma *)(b->kaddr + i);\n\t\t\tf->block = b;\n\t\t\tf->offs = i;\n\t\t\tLIST_INSERT_HEAD(&usb_frag_freelist, f, next);\n\t\t}\n\t\tf = LIST_FIRST(&usb_frag_freelist);\n\t}\n\tp->block = f->block;\n\tp->offs = f->offs;\n\tLIST_REMOVE(f, next);\n\tsplx(s);\n\tDPRINTFN(5, (\"usb_allocmem: use frag=%p size=%d\\n\", f, (int)size));\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "tdphys"
          ],
          "line": 1928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "OHCI_ED_SET_FA(addr) | \n\t\t\tOHCI_ED_SET_EN(ed->bEndpointAddress) |\n\t\t\t(dev->lowspeed ? OHCI_ED_SPEED : 0) | fmt |\n\t\t\tOHCI_ED_SET_MAXP(UGETW(ed->wMaxPacketSize))"
          ],
          "line": 1923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OHCI_ED_SET_MAXP",
          "args": [
            "UGETW(ed->wMaxPacketSize)"
          ],
          "line": 1927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "ed->wMaxPacketSize"
          ],
          "line": 1927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OHCI_ED_SET_EN",
          "args": [
            "ed->bEndpointAddress"
          ],
          "line": 1925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OHCI_ED_SET_FA",
          "args": [
            "addr"
          ],
          "line": 1924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ohci_alloc_std",
          "args": [
            "sc"
          ],
          "line": 1914
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_alloc_std_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "479-574",
          "snippet": "usbd_status\nohci_alloc_std_chain(opipe, sc, alen, rd, xfer, sp, ep)\n\tstruct ohci_pipe *opipe;\n\tohci_softc_t *sc;\n\tint alen, rd;\n\tusbd_xfer_handle xfer;\n\tohci_soft_td_t *sp, **ep;\n{\n\tohci_soft_td_t *next, *cur;\n\tohci_physaddr_t dataphys, dataphysend;\n\tu_int32_t tdflags;\n\tint len, curlen;\n\tusb_dma_t *dma = &xfer->dmabuf;\n\tu_int16_t flags = xfer->flags;\n\n\tDPRINTFN(alen < 4096,(\"ohci_alloc_std_chain: start len=%d\\n\", alen));\n\n\tlen = alen;\n\tcur = sp;\n\tdataphys = DMAADDR(dma);\n\tdataphysend = OHCI_PAGE(dataphys + len - 1);\n\ttdflags = htole32(\n\t    (rd ? OHCI_TD_IN : OHCI_TD_OUT) | \n\t    (flags & USBD_SHORT_XFER_OK ? OHCI_TD_R : 0) |\n\t    OHCI_TD_NOCC | OHCI_TD_TOGGLE_CARRY | OHCI_TD_NOINTR);\n\n\tfor (;;) {\n\t\tnext = ohci_alloc_std(sc);\n\t\tif (next == NULL)\n\t\t\tgoto nomem;\n\n\t\t/* The OHCI hardware can handle at most one page crossing. */\n\t\tif (OHCI_PAGE(dataphys) == dataphysend ||\n\t\t    OHCI_PAGE(dataphys) + OHCI_PAGE_SIZE == dataphysend) {\n\t\t\t/* we can handle it in this TD */\n\t\t\tcurlen = len;\n\t\t} else {\n\t\t\t/* must use multiple TDs, fill as much as possible. */\n\t\t\tcurlen = 2 * OHCI_PAGE_SIZE - \n\t\t\t\t (dataphys & (OHCI_PAGE_SIZE-1));\n\t\t\t/* the length must be a multiple of the max size */\n\t\t\tcurlen -= curlen % UGETW(opipe->pipe.endpoint->edesc->wMaxPacketSize);\n#ifdef DIAGNOSTIC\n\t\t\tif (curlen == 0)\n\t\t\t\tpanic(\"ohci_alloc_std: curlen == 0\\n\");\n#endif\n\t\t}\n\t\tDPRINTFN(4,(\"ohci_alloc_std_chain: dataphys=0x%08x \"\n\t\t\t    \"dataphysend=0x%08x len=%d curlen=%d\\n\",\n\t\t\t    dataphys, dataphysend,\n\t\t\t    len, curlen));\n\t\tlen -= curlen;\n\n\t\tcur->td.td_flags = tdflags;\n\t\tcur->td.td_cbp = htole32(dataphys);\n\t\tcur->nexttd = next;\n\t\tcur->td.td_nexttd = htole32(next->physaddr);\n\t\tcur->td.td_be = htole32(dataphys + curlen - 1);\n\t\tcur->len = curlen;\n\t\tcur->flags = OHCI_ADD_LEN;\n\t\tcur->xfer = xfer;\n\t\tDPRINTFN(10,(\"ohci_alloc_std_chain: cbp=0x%08x be=0x%08x\\n\",\n\t\t\t    dataphys, dataphys + curlen - 1));\n\t\tif (len == 0)\n\t\t\tbreak;\n\t\tDPRINTFN(10,(\"ohci_alloc_std_chain: extend chain\\n\"));\n\t\tdataphys += curlen;\n\t\tcur = next;\n\t}\n\tif ((flags & USBD_FORCE_SHORT_XFER) &&\n\t    alen % UGETW(opipe->pipe.endpoint->edesc->wMaxPacketSize) == 0) {\n\t\t/* Force a 0 length transfer at the end. */\n\n\t\tcur = next;\n\t\tnext = ohci_alloc_std(sc);\n\t\tif (next == NULL)\n\t\t\tgoto nomem;\n\n\t\tcur->td.td_flags = tdflags;\n\t\tcur->td.td_cbp = 0; /* indicate 0 length packet */\n\t\tcur->nexttd = next;\n\t\tcur->td.td_nexttd = htole32(next->physaddr);\n\t\tcur->td.td_be = ~0;\n\t\tcur->len = 0;\n\t\tcur->flags = 0;\n\t\tcur->xfer = xfer;\n\t\tDPRINTFN(2,(\"ohci_alloc_std_chain: add 0 xfer\\n\"));\n\t}\n\t*ep = cur;\n\n\treturn (USBD_NORMAL_COMPLETION);\n\n nomem:\n\t/* XXX free chain */\n\treturn (USBD_NOMEM);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static ohci_soft_td_t",
            "ohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));",
            "Static usbd_status",
            "ohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));",
            "Static usbd_status",
            "ohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));",
            "ohci_add_done __P((ohci_softc_t *, ohci_physaddr_t));",
            "ohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_request __P((usbd_xfer_handle xfer));",
            "ohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));",
            "ohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));",
            "Static ohci_soft_td_t",
            "Static usbd_status",
            "ohci_setup_isoc __P((usbd_pipe_handle pipe));",
            "ohci_device_isoc_enter __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));",
            "ohci_freem __P((struct usbd_bus *, usb_dma_t *));",
            "Static usbd_xfer_handle",
            "ohci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_root_ctrl_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_root_ctrl_start __P((usbd_xfer_handle));",
            "ohci_root_ctrl_abort __P((usbd_xfer_handle));",
            "ohci_root_ctrl_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_root_intr_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_root_intr_start __P((usbd_xfer_handle));",
            "ohci_root_intr_abort __P((usbd_xfer_handle));",
            "ohci_root_intr_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_ctrl_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_ctrl_start __P((usbd_xfer_handle));",
            "ohci_device_ctrl_abort __P((usbd_xfer_handle));",
            "ohci_device_ctrl_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_bulk_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_bulk_start __P((usbd_xfer_handle));",
            "ohci_device_bulk_abort __P((usbd_xfer_handle));",
            "ohci_device_bulk_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_intr_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_intr_start __P((usbd_xfer_handle));",
            "ohci_device_intr_abort __P((usbd_xfer_handle));",
            "ohci_device_intr_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_isoc_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_isoc_start __P((usbd_xfer_handle));",
            "ohci_device_isoc_abort __P((usbd_xfer_handle));",
            "ohci_device_isoc_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_rhsc_able __P((ohci_softc_t *, int));",
            "ohci_device_clear_toggle __P((usbd_pipe_handle pipe));",
            "ohci_noop __P((usbd_pipe_handle pipe));",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
            "ohci_intr1 __P((ohci_softc_t *));",
            "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
            "ohci_physaddr_t a;",
            "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;",
            "ohci_physaddr_t a;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_td_t;\nohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));\nStatic usbd_status;\nohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));\nStatic usbd_status;\nohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));\nohci_add_done __P((ohci_softc_t *, ohci_physaddr_t));\nohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));\nStatic usbd_status;\nohci_device_request __P((usbd_xfer_handle xfer));\nohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));\nohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));\nStatic ohci_soft_td_t;\nStatic usbd_status;\nohci_setup_isoc __P((usbd_pipe_handle pipe));\nohci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));\nohci_freem __P((struct usbd_bus *, usb_dma_t *));\nStatic usbd_xfer_handle;\nohci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nStatic usbd_status;\nohci_root_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_ctrl_start __P((usbd_xfer_handle));\nohci_root_ctrl_abort __P((usbd_xfer_handle));\nohci_root_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_intr_start __P((usbd_xfer_handle));\nohci_root_intr_abort __P((usbd_xfer_handle));\nohci_root_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_ctrl_start __P((usbd_xfer_handle));\nohci_device_ctrl_abort __P((usbd_xfer_handle));\nohci_device_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_bulk_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_bulk_start __P((usbd_xfer_handle));\nohci_device_bulk_abort __P((usbd_xfer_handle));\nohci_device_bulk_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_intr_start __P((usbd_xfer_handle));\nohci_device_intr_abort __P((usbd_xfer_handle));\nohci_device_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_isoc_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_isoc_start __P((usbd_xfer_handle));\nohci_device_isoc_abort __P((usbd_xfer_handle));\nohci_device_isoc_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_rhsc_able __P((ohci_softc_t *, int));\nohci_device_clear_toggle __P((usbd_pipe_handle pipe));\nohci_noop __P((usbd_pipe_handle pipe));\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_physaddr_t a;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\nohci_physaddr_t a;\n\nusbd_status\nohci_alloc_std_chain(opipe, sc, alen, rd, xfer, sp, ep)\n\tstruct ohci_pipe *opipe;\n\tohci_softc_t *sc;\n\tint alen, rd;\n\tusbd_xfer_handle xfer;\n\tohci_soft_td_t *sp, **ep;\n{\n\tohci_soft_td_t *next, *cur;\n\tohci_physaddr_t dataphys, dataphysend;\n\tu_int32_t tdflags;\n\tint len, curlen;\n\tusb_dma_t *dma = &xfer->dmabuf;\n\tu_int16_t flags = xfer->flags;\n\n\tDPRINTFN(alen < 4096,(\"ohci_alloc_std_chain: start len=%d\\n\", alen));\n\n\tlen = alen;\n\tcur = sp;\n\tdataphys = DMAADDR(dma);\n\tdataphysend = OHCI_PAGE(dataphys + len - 1);\n\ttdflags = htole32(\n\t    (rd ? OHCI_TD_IN : OHCI_TD_OUT) | \n\t    (flags & USBD_SHORT_XFER_OK ? OHCI_TD_R : 0) |\n\t    OHCI_TD_NOCC | OHCI_TD_TOGGLE_CARRY | OHCI_TD_NOINTR);\n\n\tfor (;;) {\n\t\tnext = ohci_alloc_std(sc);\n\t\tif (next == NULL)\n\t\t\tgoto nomem;\n\n\t\t/* The OHCI hardware can handle at most one page crossing. */\n\t\tif (OHCI_PAGE(dataphys) == dataphysend ||\n\t\t    OHCI_PAGE(dataphys) + OHCI_PAGE_SIZE == dataphysend) {\n\t\t\t/* we can handle it in this TD */\n\t\t\tcurlen = len;\n\t\t} else {\n\t\t\t/* must use multiple TDs, fill as much as possible. */\n\t\t\tcurlen = 2 * OHCI_PAGE_SIZE - \n\t\t\t\t (dataphys & (OHCI_PAGE_SIZE-1));\n\t\t\t/* the length must be a multiple of the max size */\n\t\t\tcurlen -= curlen % UGETW(opipe->pipe.endpoint->edesc->wMaxPacketSize);\n#ifdef DIAGNOSTIC\n\t\t\tif (curlen == 0)\n\t\t\t\tpanic(\"ohci_alloc_std: curlen == 0\\n\");\n#endif\n\t\t}\n\t\tDPRINTFN(4,(\"ohci_alloc_std_chain: dataphys=0x%08x \"\n\t\t\t    \"dataphysend=0x%08x len=%d curlen=%d\\n\",\n\t\t\t    dataphys, dataphysend,\n\t\t\t    len, curlen));\n\t\tlen -= curlen;\n\n\t\tcur->td.td_flags = tdflags;\n\t\tcur->td.td_cbp = htole32(dataphys);\n\t\tcur->nexttd = next;\n\t\tcur->td.td_nexttd = htole32(next->physaddr);\n\t\tcur->td.td_be = htole32(dataphys + curlen - 1);\n\t\tcur->len = curlen;\n\t\tcur->flags = OHCI_ADD_LEN;\n\t\tcur->xfer = xfer;\n\t\tDPRINTFN(10,(\"ohci_alloc_std_chain: cbp=0x%08x be=0x%08x\\n\",\n\t\t\t    dataphys, dataphys + curlen - 1));\n\t\tif (len == 0)\n\t\t\tbreak;\n\t\tDPRINTFN(10,(\"ohci_alloc_std_chain: extend chain\\n\"));\n\t\tdataphys += curlen;\n\t\tcur = next;\n\t}\n\tif ((flags & USBD_FORCE_SHORT_XFER) &&\n\t    alen % UGETW(opipe->pipe.endpoint->edesc->wMaxPacketSize) == 0) {\n\t\t/* Force a 0 length transfer at the end. */\n\n\t\tcur = next;\n\t\tnext = ohci_alloc_std(sc);\n\t\tif (next == NULL)\n\t\t\tgoto nomem;\n\n\t\tcur->td.td_flags = tdflags;\n\t\tcur->td.td_cbp = 0; /* indicate 0 length packet */\n\t\tcur->nexttd = next;\n\t\tcur->td.td_nexttd = htole32(next->physaddr);\n\t\tcur->td.td_be = ~0;\n\t\tcur->len = 0;\n\t\tcur->flags = 0;\n\t\tcur->xfer = xfer;\n\t\tDPRINTFN(2,(\"ohci_alloc_std_chain: add 0 xfer\\n\"));\n\t}\n\t*ep = cur;\n\n\treturn (USBD_NORMAL_COMPLETION);\n\n nomem:\n\t/* XXX free chain */\n\treturn (USBD_NOMEM);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UE_GET_DIR",
          "args": [
            "ed->bEndpointAddress"
          ],
          "line": 1909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ohci_free_sitd",
          "args": [
            "sc",
            "sitd"
          ],
          "line": 1903
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_free_sitd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "632-653",
          "snippet": "void\nohci_free_sitd(sc, sitd)\n\tohci_softc_t *sc;\n\tohci_soft_itd_t *sitd;\n{\n\tint s;\n\n\tDPRINTFN(10,(\"ohci_free_sitd: sitd=%p\\n\", sitd));\n\n#ifdef DIAGNOSTIC\n\tif (!sitd->isdone) {\n\t\tpanic(\"ohci_free_sitd: sitd=%p not done\\n\", sitd);\n\t\treturn;\n\t}\n#endif\n\n\ts = splusb();\n\tohci_hash_rem_itd(sc, sitd);\n\tsitd->nextitd = sc->sc_freeitds;\n\tsc->sc_freeitds = sitd;\n\tsplx(s);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static ohci_soft_itd_t",
            "ohci_free_sitd __P((ohci_softc_t *,ohci_soft_itd_t *));",
            "ohci_hash_add_itd __P((ohci_softc_t *, \n\t\t\t    ohci_soft_itd_t *));",
            "ohci_hash_rem_itd __P((ohci_softc_t *,\n\t\t\t    ohci_soft_itd_t *));",
            "Static ohci_soft_itd_t",
            "ohci_rhsc_able __P((ohci_softc_t *, int));",
            "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
            "ohci_intr1 __P((ohci_softc_t *));",
            "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_itd_t;\nohci_free_sitd __P((ohci_softc_t *,ohci_soft_itd_t *));\nohci_hash_add_itd __P((ohci_softc_t *, \n\t\t\t    ohci_soft_itd_t *));\nohci_hash_rem_itd __P((ohci_softc_t *,\n\t\t\t    ohci_soft_itd_t *));\nStatic ohci_soft_itd_t;\nohci_rhsc_able __P((ohci_softc_t *, int));\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nvoid\nohci_free_sitd(sc, sitd)\n\tohci_softc_t *sc;\n\tohci_soft_itd_t *sitd;\n{\n\tint s;\n\n\tDPRINTFN(10,(\"ohci_free_sitd: sitd=%p\\n\", sitd));\n\n#ifdef DIAGNOSTIC\n\tif (!sitd->isdone) {\n\t\tpanic(\"ohci_free_sitd: sitd=%p not done\\n\", sitd);\n\t\treturn;\n\t}\n#endif\n\n\ts = splusb();\n\tohci_hash_rem_itd(sc, sitd);\n\tsitd->nextitd = sc->sc_freeitds;\n\tsc->sc_freeitds = sitd;\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ohci_alloc_sitd",
          "args": [
            "sc"
          ],
          "line": 1901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ohci_alloc_sed",
          "args": [
            "sc"
          ],
          "line": 1896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"ohci_open: pipe=%p, addr=%d, endpt=%d (%d)\\n\",\n\t\t     pipe, addr, ed->bEndpointAddress, sc->sc_addr)"
          ],
          "line": 1881
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define OHCI_INTR_ENDPT 1\n\nStatic ohci_soft_ed_t;\nohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));\nStatic ohci_soft_td_t;\nohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));\nStatic ohci_soft_itd_t;\nohci_free_sitd __P((ohci_softc_t *,ohci_soft_itd_t *));\nStatic usbd_status;\nohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));\nStatic usbd_status;\nohci_open __P((usbd_pipe_handle));\nohci_add_done __P((ohci_softc_t *, ohci_physaddr_t));\nStatic usbd_status;\nohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));\nohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));\nStatic ohci_soft_td_t;\nohci_hash_add_itd __P((ohci_softc_t *, \n\t\t\t    ohci_soft_itd_t *));\nohci_hash_rem_itd __P((ohci_softc_t *,\n\t\t\t    ohci_soft_itd_t *));\nStatic ohci_soft_itd_t;\nStatic usbd_status;\nohci_setup_isoc __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nohci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));\nStatic usbd_status;\nStatic usbd_status;\nohci_root_ctrl_close __P((usbd_pipe_handle));\nStatic usbd_status;\nStatic usbd_status;\nohci_root_intr_close __P((usbd_pipe_handle));\nStatic usbd_status;\nStatic usbd_status;\nohci_device_ctrl_close __P((usbd_pipe_handle));\nStatic usbd_status;\nStatic usbd_status;\nohci_device_bulk_close __P((usbd_pipe_handle));\nStatic usbd_status;\nStatic usbd_status;\nohci_device_intr_close __P((usbd_pipe_handle));\nStatic usbd_status;\nStatic usbd_status;\nohci_device_isoc_close __P((usbd_pipe_handle));\nStatic usbd_status;\nohci_device_setintr __P((ohci_softc_t *sc, \n\t\t\t    struct ohci_pipe *pipe, int ival));\nohci_rhsc_able __P((ohci_softc_t *, int));\nohci_device_clear_toggle __P((usbd_pipe_handle pipe));\nohci_noop __P((usbd_pipe_handle pipe));\nStatic struct;\nStatic struct;\nusbd_pipe_methods ohci_root_ctrl_methods = {\t\n\tohci_root_ctrl_transfer,\n\tohci_root_ctrl_start,\n\tohci_root_ctrl_abort,\n\tohci_root_ctrl_close,\n\tohci_noop,\n\tohci_root_ctrl_done,\n};\nStatic struct;\nusbd_pipe_methods ohci_root_intr_methods = {\t\n\tohci_root_intr_transfer,\n\tohci_root_intr_start,\n\tohci_root_intr_abort,\n\tohci_root_intr_close,\n\tohci_noop,\n\tohci_root_intr_done,\n};\nStatic struct;\nusbd_pipe_methods ohci_device_ctrl_methods = {\t\n\tohci_device_ctrl_transfer,\n\tohci_device_ctrl_start,\n\tohci_device_ctrl_abort,\n\tohci_device_ctrl_close,\n\tohci_noop,\n\tohci_device_ctrl_done,\n};\nStatic struct;\nusbd_pipe_methods ohci_device_intr_methods = {\t\n\tohci_device_intr_transfer,\n\tohci_device_intr_start,\n\tohci_device_intr_abort,\n\tohci_device_intr_close,\n\tohci_device_clear_toggle,\n\tohci_device_intr_done,\n};\nStatic struct;\nusbd_pipe_methods ohci_device_bulk_methods = {\t\n\tohci_device_bulk_transfer,\n\tohci_device_bulk_start,\n\tohci_device_bulk_abort,\n\tohci_device_bulk_close,\n\tohci_device_clear_toggle,\n\tohci_device_bulk_done,\n};\nStatic struct;\nusbd_pipe_methods ohci_device_isoc_methods = {\n\tohci_device_isoc_transfer,\n\tohci_device_isoc_start,\n\tohci_device_isoc_abort,\n\tohci_device_isoc_close,\n\tohci_noop,\n\tohci_device_isoc_done,\n};\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nusbd_status\nohci_open(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tusbd_device_handle dev = pipe->device;\n\tohci_softc_t *sc = (ohci_softc_t *)dev->bus;\n\tusb_endpoint_descriptor_t *ed = pipe->endpoint->edesc;\n\tstruct ohci_pipe *opipe = (struct ohci_pipe *)pipe;\n\tu_int8_t addr = dev->address;\n\tu_int8_t xfertype = ed->bmAttributes & UE_XFERTYPE;\n\tohci_soft_ed_t *sed;\n\tohci_soft_td_t *std;\n\tohci_soft_itd_t *sitd;\n\tohci_physaddr_t tdphys;\n\tu_int32_t fmt;\n\tusbd_status err;\n\tint s;\n\tint ival;\n\n\tDPRINTFN(1, (\"ohci_open: pipe=%p, addr=%d, endpt=%d (%d)\\n\",\n\t\t     pipe, addr, ed->bEndpointAddress, sc->sc_addr));\n\n\tif (addr == sc->sc_addr) {\n\t\tswitch (ed->bEndpointAddress) {\n\t\tcase USB_CONTROL_ENDPOINT:\n\t\t\tpipe->methods = &ohci_root_ctrl_methods;\n\t\t\tbreak;\n\t\tcase UE_DIR_IN | OHCI_INTR_ENDPT:\n\t\t\tpipe->methods = &ohci_root_intr_methods;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn (USBD_INVAL);\n\t\t}\n\t} else {\n\t\tsed = ohci_alloc_sed(sc);\n\t\tif (sed == NULL)\n\t\t\tgoto bad0;\n\t\topipe->sed = sed;\n\t\tif (xfertype == UE_ISOCHRONOUS) {\n\t\t\tsitd = ohci_alloc_sitd(sc);\n\t\t\tif (sitd == NULL) {\n\t\t\t\tohci_free_sitd(sc, sitd);\n\t\t\t\tgoto bad1;\n\t\t\t}\n\t\t\topipe->tail.itd = sitd;\n\t\t\ttdphys = sitd->physaddr;\n\t\t\tfmt = OHCI_ED_FORMAT_ISO;\n\t\t\tif (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN)\n\t\t\t\tfmt |= OHCI_ED_DIR_IN;\n\t\t\telse\n\t\t\t\tfmt |= OHCI_ED_DIR_OUT;\n\t\t} else {\n\t\t\tstd = ohci_alloc_std(sc);\n\t\t\tif (std == NULL) {\n\t\t\t\tohci_free_std(sc, std);\n\t\t\t\tgoto bad1;\n\t\t\t}\n\t\t\topipe->tail.td = std;\n\t\t\ttdphys = std->physaddr;\n\t\t\tfmt = OHCI_ED_FORMAT_GEN | OHCI_ED_DIR_TD;\n\t\t}\n\t\tsed->ed.ed_flags = htole32(\n\t\t\tOHCI_ED_SET_FA(addr) | \n\t\t\tOHCI_ED_SET_EN(ed->bEndpointAddress) |\n\t\t\t(dev->lowspeed ? OHCI_ED_SPEED : 0) | fmt |\n\t\t\tOHCI_ED_SET_MAXP(UGETW(ed->wMaxPacketSize)));\n\t\tsed->ed.ed_headp = sed->ed.ed_tailp = htole32(tdphys);\n\n\t\tswitch (xfertype) {\n\t\tcase UE_CONTROL:\n\t\t\tpipe->methods = &ohci_device_ctrl_methods;\n\t\t\terr = usb_allocmem(&sc->sc_bus, \n\t\t\t\t  sizeof(usb_device_request_t), \n\t\t\t\t  0, &opipe->u.ctl.reqdma);\n\t\t\tif (err)\n\t\t\t\tgoto bad;\n\t\t\ts = splusb();\n\t\t\tohci_add_ed(sed, sc->sc_ctrl_head);\n\t\t\tsplx(s);\n\t\t\tbreak;\n\t\tcase UE_INTERRUPT:\n\t\t\tpipe->methods = &ohci_device_intr_methods;\n\t\t\tival = pipe->interval;\n\t\t\tif (ival == USBD_DEFAULT_INTERVAL)\n\t\t\t\tival = ed->bInterval;\n\t\t\treturn (ohci_device_setintr(sc, opipe, ival));\n\t\tcase UE_ISOCHRONOUS:\n\t\t\tpipe->methods = &ohci_device_isoc_methods;\n\t\t\treturn (ohci_setup_isoc(pipe));\n\t\tcase UE_BULK:\n\t\t\tpipe->methods = &ohci_device_bulk_methods;\n\t\t\ts = splusb();\n\t\t\tohci_add_ed(sed, sc->sc_bulk_head);\n\t\t\tsplx(s);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn (USBD_NORMAL_COMPLETION);\n\n bad:\n\tohci_free_std(sc, std);\n bad1:\n\tohci_free_sed(sc, sed);\n bad0:\n\treturn (USBD_NOMEM);\n\t\n}"
  },
  {
    "function_name": "ohci_dump_ed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "1842-1859",
    "snippet": "void\nohci_dump_ed(sed)\n\tohci_soft_ed_t *sed;\n{\n\tDPRINTF((\"ED(%p) at 0x%08lx: addr=%d endpt=%d maxp=%d %b\\ntailp=0x%08lx \"\n\t\t \"headflags=%b headp=0x%08lx nexted=0x%08lx\\n\",\n\t\t sed, (u_long)sed->physaddr, \n\t\t OHCI_ED_GET_FA(le32toh(sed->ed.ed_flags)),\n\t\t OHCI_ED_GET_EN(le32toh(sed->ed.ed_flags)),\n\t\t OHCI_ED_GET_MAXP(le32toh(sed->ed.ed_flags)),\n\t\t (int)le32toh(sed->ed.ed_flags),\n\t\t \"\\20\\14OUT\\15IN\\16LOWSPEED\\17SKIP\\20ISO\",\n\t\t (u_long)le32toh(sed->ed.ed_tailp),\n\t\t (u_long)le32toh(sed->ed.ed_headp),\n\t\t \"\\20\\1HALT\\2CARRY\",\n\t\t (u_long)le32toh(sed->ed.ed_headp),\n\t\t (u_long)le32toh(sed->ed.ed_nexted)));\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static ohci_soft_ed_t",
      "ohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));",
      "ohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
      "ohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ED(%p) at 0x%08lx: addr=%d endpt=%d maxp=%d %b\\ntailp=0x%08lx \"\n\t\t \"headflags=%b headp=0x%08lx nexted=0x%08lx\\n\",\n\t\t sed, (u_long)sed->physaddr, \n\t\t OHCI_ED_GET_FA(le32toh(sed->ed.ed_flags)),\n\t\t OHCI_ED_GET_EN(le32toh(sed->ed.ed_flags)),\n\t\t OHCI_ED_GET_MAXP(le32toh(sed->ed.ed_flags)),\n\t\t (int)le32toh(sed->ed.ed_flags),\n\t\t \"\\20\\14OUT\\15IN\\16LOWSPEED\\17SKIP\\20ISO\",\n\t\t (u_long)le32toh(sed->ed.ed_tailp),\n\t\t (u_long)le32toh(sed->ed.ed_headp),\n\t\t \"\\20\\1HALT\\2CARRY\",\n\t\t (u_long)le32toh(sed->ed.ed_headp),\n\t\t (u_long)le32toh(sed->ed.ed_nexted))"
          ],
          "line": 1846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "sed->ed.ed_nexted"
          ],
          "line": 1858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "sed->ed.ed_headp"
          ],
          "line": 1857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "sed->ed.ed_headp"
          ],
          "line": 1855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "sed->ed.ed_tailp"
          ],
          "line": 1854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "sed->ed.ed_flags"
          ],
          "line": 1852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OHCI_ED_GET_MAXP",
          "args": [
            "le32toh(sed->ed.ed_flags)"
          ],
          "line": 1851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "sed->ed.ed_flags"
          ],
          "line": 1851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OHCI_ED_GET_EN",
          "args": [
            "le32toh(sed->ed.ed_flags)"
          ],
          "line": 1850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "sed->ed.ed_flags"
          ],
          "line": 1850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OHCI_ED_GET_FA",
          "args": [
            "le32toh(sed->ed.ed_flags)"
          ],
          "line": 1849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "sed->ed.ed_flags"
          ],
          "line": 1849
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_ed_t;\nohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));\nohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\n\nvoid\nohci_dump_ed(sed)\n\tohci_soft_ed_t *sed;\n{\n\tDPRINTF((\"ED(%p) at 0x%08lx: addr=%d endpt=%d maxp=%d %b\\ntailp=0x%08lx \"\n\t\t \"headflags=%b headp=0x%08lx nexted=0x%08lx\\n\",\n\t\t sed, (u_long)sed->physaddr, \n\t\t OHCI_ED_GET_FA(le32toh(sed->ed.ed_flags)),\n\t\t OHCI_ED_GET_EN(le32toh(sed->ed.ed_flags)),\n\t\t OHCI_ED_GET_MAXP(le32toh(sed->ed.ed_flags)),\n\t\t (int)le32toh(sed->ed.ed_flags),\n\t\t \"\\20\\14OUT\\15IN\\16LOWSPEED\\17SKIP\\20ISO\",\n\t\t (u_long)le32toh(sed->ed.ed_tailp),\n\t\t (u_long)le32toh(sed->ed.ed_headp),\n\t\t \"\\20\\1HALT\\2CARRY\",\n\t\t (u_long)le32toh(sed->ed.ed_headp),\n\t\t (u_long)le32toh(sed->ed.ed_nexted)));\n}"
  },
  {
    "function_name": "ohci_dump_itds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "1834-1840",
    "snippet": "void\nohci_dump_itds(sitd)\n\tohci_soft_itd_t *sitd;\n{\n\tfor (; sitd; sitd = sitd->nextitd)\n\t\tohci_dump_itd(sitd);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static ohci_soft_itd_t",
      "ohci_free_sitd __P((ohci_softc_t *,ohci_soft_itd_t *));",
      "ohci_hash_add_itd __P((ohci_softc_t *, \n\t\t\t    ohci_soft_itd_t *));",
      "ohci_hash_rem_itd __P((ohci_softc_t *,\n\t\t\t    ohci_soft_itd_t *));",
      "Static ohci_soft_itd_t"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ohci_dump_itd",
          "args": [
            "sitd"
          ],
          "line": 1839
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_dump_itds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "1834-1840",
          "snippet": "void\nohci_dump_itds(sitd)\n\tohci_soft_itd_t *sitd;\n{\n\tfor (; sitd; sitd = sitd->nextitd)\n\t\tohci_dump_itd(sitd);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_itd_t;\nohci_free_sitd __P((ohci_softc_t *,ohci_soft_itd_t *));\nohci_hash_add_itd __P((ohci_softc_t *, \n\t\t\t    ohci_soft_itd_t *));\nohci_hash_rem_itd __P((ohci_softc_t *,\n\t\t\t    ohci_soft_itd_t *));\nStatic ohci_soft_itd_t;\n\nvoid\nohci_dump_itds(sitd)\n\tohci_soft_itd_t *sitd;\n{\n\tfor (; sitd; sitd = sitd->nextitd)\n\t\tohci_dump_itd(sitd);\n}"
  },
  {
    "function_name": "ohci_dump_itd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "1812-1832",
    "snippet": "void\nohci_dump_itd(sitd)\n\tohci_soft_itd_t *sitd;\n{\n\tint i;\n\n\tDPRINTF((\"ITD(%p) at %08lx: sf=%d di=%d fc=%d cc=%d\\n\"\n\t\t \"bp0=0x%08lx next=0x%08lx be=0x%08lx\\n\", \n\t\t sitd, (u_long)sitd->physaddr,\n\t\t OHCI_ITD_GET_SF(le32toh(sitd->itd.itd_flags)),\n\t\t OHCI_ITD_GET_DI(le32toh(sitd->itd.itd_flags)),\n\t\t OHCI_ITD_GET_FC(le32toh(sitd->itd.itd_flags)),\n\t\t OHCI_ITD_GET_CC(le32toh(sitd->itd.itd_flags)),\n\t\t (u_long)le32toh(sitd->itd.itd_bp0),\n\t\t (u_long)le32toh(sitd->itd.itd_nextitd),\n\t\t (u_long)le32toh(sitd->itd.itd_be)));\n\tfor (i = 0; i < OHCI_ITD_NOFFSET; i++)\n\t\tDPRINTF((\"offs[%d]=0x%04x \", i,\n\t\t\t (u_int)le16toh(sitd->itd.itd_offset[i])));\n\tDPRINTF((\"\\n\"));\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static ohci_soft_itd_t",
      "ohci_free_sitd __P((ohci_softc_t *,ohci_soft_itd_t *));",
      "ohci_hash_add_itd __P((ohci_softc_t *, \n\t\t\t    ohci_soft_itd_t *));",
      "ohci_hash_rem_itd __P((ohci_softc_t *,\n\t\t\t    ohci_soft_itd_t *));",
      "Static ohci_soft_itd_t"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"\\n\")"
          ],
          "line": 1831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"offs[%d]=0x%04x \", i,\n\t\t\t (u_int)le16toh(sitd->itd.itd_offset[i]))"
          ],
          "line": 1829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16toh",
          "args": [
            "sitd->itd.itd_offset[i]"
          ],
          "line": 1830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ITD(%p) at %08lx: sf=%d di=%d fc=%d cc=%d\\n\"\n\t\t \"bp0=0x%08lx next=0x%08lx be=0x%08lx\\n\", \n\t\t sitd, (u_long)sitd->physaddr,\n\t\t OHCI_ITD_GET_SF(le32toh(sitd->itd.itd_flags)),\n\t\t OHCI_ITD_GET_DI(le32toh(sitd->itd.itd_flags)),\n\t\t OHCI_ITD_GET_FC(le32toh(sitd->itd.itd_flags)),\n\t\t OHCI_ITD_GET_CC(le32toh(sitd->itd.itd_flags)),\n\t\t (u_long)le32toh(sitd->itd.itd_bp0),\n\t\t (u_long)le32toh(sitd->itd.itd_nextitd),\n\t\t (u_long)le32toh(sitd->itd.itd_be))"
          ],
          "line": 1818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "sitd->itd.itd_be"
          ],
          "line": 1827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "sitd->itd.itd_nextitd"
          ],
          "line": 1826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "sitd->itd.itd_bp0"
          ],
          "line": 1825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OHCI_ITD_GET_CC",
          "args": [
            "le32toh(sitd->itd.itd_flags)"
          ],
          "line": 1824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "sitd->itd.itd_flags"
          ],
          "line": 1824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OHCI_ITD_GET_FC",
          "args": [
            "le32toh(sitd->itd.itd_flags)"
          ],
          "line": 1823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "sitd->itd.itd_flags"
          ],
          "line": 1823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OHCI_ITD_GET_DI",
          "args": [
            "le32toh(sitd->itd.itd_flags)"
          ],
          "line": 1822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "sitd->itd.itd_flags"
          ],
          "line": 1822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OHCI_ITD_GET_SF",
          "args": [
            "le32toh(sitd->itd.itd_flags)"
          ],
          "line": 1821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "sitd->itd.itd_flags"
          ],
          "line": 1821
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_itd_t;\nohci_free_sitd __P((ohci_softc_t *,ohci_soft_itd_t *));\nohci_hash_add_itd __P((ohci_softc_t *, \n\t\t\t    ohci_soft_itd_t *));\nohci_hash_rem_itd __P((ohci_softc_t *,\n\t\t\t    ohci_soft_itd_t *));\nStatic ohci_soft_itd_t;\n\nvoid\nohci_dump_itd(sitd)\n\tohci_soft_itd_t *sitd;\n{\n\tint i;\n\n\tDPRINTF((\"ITD(%p) at %08lx: sf=%d di=%d fc=%d cc=%d\\n\"\n\t\t \"bp0=0x%08lx next=0x%08lx be=0x%08lx\\n\", \n\t\t sitd, (u_long)sitd->physaddr,\n\t\t OHCI_ITD_GET_SF(le32toh(sitd->itd.itd_flags)),\n\t\t OHCI_ITD_GET_DI(le32toh(sitd->itd.itd_flags)),\n\t\t OHCI_ITD_GET_FC(le32toh(sitd->itd.itd_flags)),\n\t\t OHCI_ITD_GET_CC(le32toh(sitd->itd.itd_flags)),\n\t\t (u_long)le32toh(sitd->itd.itd_bp0),\n\t\t (u_long)le32toh(sitd->itd.itd_nextitd),\n\t\t (u_long)le32toh(sitd->itd.itd_be)));\n\tfor (i = 0; i < OHCI_ITD_NOFFSET; i++)\n\t\tDPRINTF((\"offs[%d]=0x%04x \", i,\n\t\t\t (u_int)le16toh(sitd->itd.itd_offset[i])));\n\tDPRINTF((\"\\n\"));\n}"
  },
  {
    "function_name": "ohci_dump_td",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "1795-1810",
    "snippet": "void\nohci_dump_td(std)\n\tohci_soft_td_t *std;\n{\n\tDPRINTF((\"TD(%p) at %08lx: %b delay=%d ec=%d cc=%d\\ncbp=0x%08lx \"\n\t\t \"nexttd=0x%08lx be=0x%08lx\\n\", \n\t\t std, (u_long)std->physaddr,\n\t\t (int)le32toh(std->td.td_flags),\n\t\t \"\\20\\23R\\24OUT\\25IN\\31TOG1\\32SETTOGGLE\",\n\t\t OHCI_TD_GET_DI(le32toh(std->td.td_flags)),\n\t\t OHCI_TD_GET_EC(le32toh(std->td.td_flags)),\n\t\t OHCI_TD_GET_CC(le32toh(std->td.td_flags)),\n\t\t (u_long)le32toh(std->td.td_cbp),\n\t\t (u_long)le32toh(std->td.td_nexttd),\n\t\t (u_long)le32toh(std->td.td_be)));\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static ohci_soft_td_t",
      "ohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));",
      "ohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));",
      "ohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));",
      "ohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));",
      "Static ohci_soft_td_t"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"TD(%p) at %08lx: %b delay=%d ec=%d cc=%d\\ncbp=0x%08lx \"\n\t\t \"nexttd=0x%08lx be=0x%08lx\\n\", \n\t\t std, (u_long)std->physaddr,\n\t\t (int)le32toh(std->td.td_flags),\n\t\t \"\\20\\23R\\24OUT\\25IN\\31TOG1\\32SETTOGGLE\",\n\t\t OHCI_TD_GET_DI(le32toh(std->td.td_flags)),\n\t\t OHCI_TD_GET_EC(le32toh(std->td.td_flags)),\n\t\t OHCI_TD_GET_CC(le32toh(std->td.td_flags)),\n\t\t (u_long)le32toh(std->td.td_cbp),\n\t\t (u_long)le32toh(std->td.td_nexttd),\n\t\t (u_long)le32toh(std->td.td_be))"
          ],
          "line": 1799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "std->td.td_be"
          ],
          "line": 1809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "std->td.td_nexttd"
          ],
          "line": 1808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "std->td.td_cbp"
          ],
          "line": 1807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OHCI_TD_GET_CC",
          "args": [
            "le32toh(std->td.td_flags)"
          ],
          "line": 1806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "std->td.td_flags"
          ],
          "line": 1806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OHCI_TD_GET_EC",
          "args": [
            "le32toh(std->td.td_flags)"
          ],
          "line": 1805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "std->td.td_flags"
          ],
          "line": 1805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OHCI_TD_GET_DI",
          "args": [
            "le32toh(std->td.td_flags)"
          ],
          "line": 1804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "std->td.td_flags"
          ],
          "line": 1804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "std->td.td_flags"
          ],
          "line": 1802
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_td_t;\nohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));\nohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));\nohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));\nohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));\nStatic ohci_soft_td_t;\n\nvoid\nohci_dump_td(std)\n\tohci_soft_td_t *std;\n{\n\tDPRINTF((\"TD(%p) at %08lx: %b delay=%d ec=%d cc=%d\\ncbp=0x%08lx \"\n\t\t \"nexttd=0x%08lx be=0x%08lx\\n\", \n\t\t std, (u_long)std->physaddr,\n\t\t (int)le32toh(std->td.td_flags),\n\t\t \"\\20\\23R\\24OUT\\25IN\\31TOG1\\32SETTOGGLE\",\n\t\t OHCI_TD_GET_DI(le32toh(std->td.td_flags)),\n\t\t OHCI_TD_GET_EC(le32toh(std->td.td_flags)),\n\t\t OHCI_TD_GET_CC(le32toh(std->td.td_flags)),\n\t\t (u_long)le32toh(std->td.td_cbp),\n\t\t (u_long)le32toh(std->td.td_nexttd),\n\t\t (u_long)le32toh(std->td.td_be)));\n}"
  },
  {
    "function_name": "ohci_dump_tds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "1787-1793",
    "snippet": "void\nohci_dump_tds(std)\n\tohci_soft_td_t *std;\n{\n\tfor (; std; std = std->nexttd)\n\t\tohci_dump_td(std);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static ohci_soft_td_t",
      "ohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));",
      "ohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));",
      "ohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));",
      "ohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));",
      "Static ohci_soft_td_t"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ohci_dump_td",
          "args": [
            "std"
          ],
          "line": 1792
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_dump_td",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "1795-1810",
          "snippet": "void\nohci_dump_td(std)\n\tohci_soft_td_t *std;\n{\n\tDPRINTF((\"TD(%p) at %08lx: %b delay=%d ec=%d cc=%d\\ncbp=0x%08lx \"\n\t\t \"nexttd=0x%08lx be=0x%08lx\\n\", \n\t\t std, (u_long)std->physaddr,\n\t\t (int)le32toh(std->td.td_flags),\n\t\t \"\\20\\23R\\24OUT\\25IN\\31TOG1\\32SETTOGGLE\",\n\t\t OHCI_TD_GET_DI(le32toh(std->td.td_flags)),\n\t\t OHCI_TD_GET_EC(le32toh(std->td.td_flags)),\n\t\t OHCI_TD_GET_CC(le32toh(std->td.td_flags)),\n\t\t (u_long)le32toh(std->td.td_cbp),\n\t\t (u_long)le32toh(std->td.td_nexttd),\n\t\t (u_long)le32toh(std->td.td_be)));\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static ohci_soft_td_t",
            "ohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));",
            "ohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));",
            "ohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));",
            "ohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));",
            "Static ohci_soft_td_t"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_td_t;\nohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));\nohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));\nohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));\nohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));\nStatic ohci_soft_td_t;\n\nvoid\nohci_dump_td(std)\n\tohci_soft_td_t *std;\n{\n\tDPRINTF((\"TD(%p) at %08lx: %b delay=%d ec=%d cc=%d\\ncbp=0x%08lx \"\n\t\t \"nexttd=0x%08lx be=0x%08lx\\n\", \n\t\t std, (u_long)std->physaddr,\n\t\t (int)le32toh(std->td.td_flags),\n\t\t \"\\20\\23R\\24OUT\\25IN\\31TOG1\\32SETTOGGLE\",\n\t\t OHCI_TD_GET_DI(le32toh(std->td.td_flags)),\n\t\t OHCI_TD_GET_EC(le32toh(std->td.td_flags)),\n\t\t OHCI_TD_GET_CC(le32toh(std->td.td_flags)),\n\t\t (u_long)le32toh(std->td.td_cbp),\n\t\t (u_long)le32toh(std->td.td_nexttd),\n\t\t (u_long)le32toh(std->td.td_be)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_td_t;\nohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));\nohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));\nohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));\nohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));\nStatic ohci_soft_td_t;\n\nvoid\nohci_dump_tds(std)\n\tohci_soft_td_t *std;\n{\n\tfor (; std; std = std->nexttd)\n\t\tohci_dump_td(std);\n}"
  },
  {
    "function_name": "ohci_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "1770-1784",
    "snippet": "void\nohci_timeout(addr)\n\tvoid *addr;\n{\n\tusbd_xfer_handle xfer = addr;\n\tint s;\n\n\tDPRINTF((\"ohci_timeout: xfer=%p\\n\", xfer));\n\n\ts = splusb();\n\txfer->device->bus->intr_context++;\n\tohci_abort_xfer(xfer, USBD_TIMEOUT);\n\txfer->device->bus->intr_context--;\n\tsplx(s);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "ohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));",
      "ohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));",
      "ohci_device_request __P((usbd_xfer_handle xfer));",
      "ohci_device_isoc_enter __P((usbd_xfer_handle));",
      "Static usbd_xfer_handle",
      "ohci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "ohci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "ohci_root_ctrl_start __P((usbd_xfer_handle));",
      "ohci_root_ctrl_abort __P((usbd_xfer_handle));",
      "ohci_root_ctrl_done  __P((usbd_xfer_handle));",
      "ohci_root_intr_transfer __P((usbd_xfer_handle));",
      "ohci_root_intr_start __P((usbd_xfer_handle));",
      "ohci_root_intr_abort __P((usbd_xfer_handle));",
      "ohci_root_intr_done  __P((usbd_xfer_handle));",
      "ohci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "ohci_device_ctrl_start __P((usbd_xfer_handle));",
      "ohci_device_ctrl_abort __P((usbd_xfer_handle));",
      "ohci_device_ctrl_done  __P((usbd_xfer_handle));",
      "ohci_device_bulk_transfer __P((usbd_xfer_handle));",
      "ohci_device_bulk_start __P((usbd_xfer_handle));",
      "ohci_device_bulk_abort __P((usbd_xfer_handle));",
      "ohci_device_bulk_done  __P((usbd_xfer_handle));",
      "ohci_device_intr_transfer __P((usbd_xfer_handle));",
      "ohci_device_intr_start __P((usbd_xfer_handle));",
      "ohci_device_intr_abort __P((usbd_xfer_handle));",
      "ohci_device_intr_done  __P((usbd_xfer_handle));",
      "ohci_device_isoc_transfer __P((usbd_xfer_handle));",
      "ohci_device_isoc_start __P((usbd_xfer_handle));",
      "ohci_device_isoc_abort __P((usbd_xfer_handle));",
      "ohci_device_isoc_done  __P((usbd_xfer_handle));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ohci_abort_xfer",
          "args": [
            "xfer",
            "USBD_TIMEOUT"
          ],
          "line": 1781
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_abort_xfer_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "2059-2093",
          "snippet": "void\nohci_abort_xfer_end(v)\n\tvoid *v;\n{\n\tusbd_xfer_handle xfer = v;\n\tstruct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;\n\tohci_softc_t *sc = (ohci_softc_t *)opipe->pipe.device->bus;\n\tohci_soft_ed_t *sed;\n\tohci_soft_td_t *p, *n;\n\tint s;\n\n\ts = splusb();\n\n\tp = xfer->hcpriv;\n#ifdef DIAGNOSTIC\n\tif (p == NULL) {\n\t\tprintf(\"ohci_abort_xfer: hcpriv==0\\n\");\n\t\treturn;\n\t}\n#endif\n\tfor (; p->xfer == xfer; p = n) {\n\t\tn = p->nexttd;\n\t\tohci_free_std(sc, p);\n\t}\n\n\tsed = opipe->sed;\n\tDPRINTFN(2,(\"ohci_abort_xfer: set hd=%x, tl=%x\\n\",\n\t\t    (int)p->physaddr, (int)le32toh(sed->ed.ed_tailp)));\n\tsed->ed.ed_headp = htole32(p->physaddr); /* unlink TDs */\n\tsed->ed.ed_flags &= htole32(~OHCI_ED_SKIP); /* remove hardware skip */\n\n\tusb_transfer_complete(xfer);\n\n\tsplx(s);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static ohci_soft_ed_t",
            "ohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));",
            "Static ohci_soft_td_t",
            "ohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));",
            "ohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));",
            "ohci_shutdown __P((void *v));",
            "ohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));",
            "ohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));",
            "ohci_device_request __P((usbd_xfer_handle xfer));",
            "ohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
            "ohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
            "ohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));",
            "ohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));",
            "Static ohci_soft_td_t",
            "ohci_setup_isoc __P((usbd_pipe_handle pipe));",
            "ohci_device_isoc_enter __P((usbd_xfer_handle));",
            "Static usbd_xfer_handle",
            "ohci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
            "ohci_root_ctrl_transfer __P((usbd_xfer_handle));",
            "ohci_root_ctrl_start __P((usbd_xfer_handle));",
            "ohci_root_ctrl_abort __P((usbd_xfer_handle));",
            "ohci_root_ctrl_done  __P((usbd_xfer_handle));",
            "ohci_root_intr_transfer __P((usbd_xfer_handle));",
            "ohci_root_intr_start __P((usbd_xfer_handle));",
            "ohci_root_intr_abort __P((usbd_xfer_handle));",
            "ohci_root_intr_done  __P((usbd_xfer_handle));",
            "ohci_device_ctrl_transfer __P((usbd_xfer_handle));",
            "ohci_device_ctrl_start __P((usbd_xfer_handle));",
            "ohci_device_ctrl_abort __P((usbd_xfer_handle));",
            "ohci_device_ctrl_done  __P((usbd_xfer_handle));",
            "ohci_device_bulk_transfer __P((usbd_xfer_handle));",
            "ohci_device_bulk_start __P((usbd_xfer_handle));",
            "ohci_device_bulk_abort __P((usbd_xfer_handle));",
            "ohci_device_bulk_done  __P((usbd_xfer_handle));",
            "ohci_device_intr_transfer __P((usbd_xfer_handle));",
            "ohci_device_intr_start __P((usbd_xfer_handle));",
            "ohci_device_intr_abort __P((usbd_xfer_handle));",
            "ohci_device_intr_done  __P((usbd_xfer_handle));",
            "ohci_device_isoc_transfer __P((usbd_xfer_handle));",
            "ohci_device_isoc_start __P((usbd_xfer_handle));",
            "ohci_device_isoc_abort __P((usbd_xfer_handle));",
            "ohci_device_isoc_done  __P((usbd_xfer_handle));",
            "ohci_rhsc_able __P((ohci_softc_t *, int));",
            "ohci_device_clear_toggle __P((usbd_pipe_handle pipe));",
            "ohci_noop __P((usbd_pipe_handle pipe));",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
            "ohci_intr1 __P((ohci_softc_t *));",
            "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_ed_t;\nohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));\nStatic ohci_soft_td_t;\nohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));\nohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));\nohci_shutdown __P((void *v));\nohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));\nohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));\nohci_device_request __P((usbd_xfer_handle xfer));\nohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));\nohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));\nStatic ohci_soft_td_t;\nohci_setup_isoc __P((usbd_pipe_handle pipe));\nohci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_xfer_handle;\nohci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nohci_root_ctrl_transfer __P((usbd_xfer_handle));\nohci_root_ctrl_start __P((usbd_xfer_handle));\nohci_root_ctrl_abort __P((usbd_xfer_handle));\nohci_root_ctrl_done  __P((usbd_xfer_handle));\nohci_root_intr_transfer __P((usbd_xfer_handle));\nohci_root_intr_start __P((usbd_xfer_handle));\nohci_root_intr_abort __P((usbd_xfer_handle));\nohci_root_intr_done  __P((usbd_xfer_handle));\nohci_device_ctrl_transfer __P((usbd_xfer_handle));\nohci_device_ctrl_start __P((usbd_xfer_handle));\nohci_device_ctrl_abort __P((usbd_xfer_handle));\nohci_device_ctrl_done  __P((usbd_xfer_handle));\nohci_device_bulk_transfer __P((usbd_xfer_handle));\nohci_device_bulk_start __P((usbd_xfer_handle));\nohci_device_bulk_abort __P((usbd_xfer_handle));\nohci_device_bulk_done  __P((usbd_xfer_handle));\nohci_device_intr_transfer __P((usbd_xfer_handle));\nohci_device_intr_start __P((usbd_xfer_handle));\nohci_device_intr_abort __P((usbd_xfer_handle));\nohci_device_intr_done  __P((usbd_xfer_handle));\nohci_device_isoc_transfer __P((usbd_xfer_handle));\nohci_device_isoc_start __P((usbd_xfer_handle));\nohci_device_isoc_abort __P((usbd_xfer_handle));\nohci_device_isoc_done  __P((usbd_xfer_handle));\nohci_rhsc_able __P((ohci_softc_t *, int));\nohci_device_clear_toggle __P((usbd_pipe_handle pipe));\nohci_noop __P((usbd_pipe_handle pipe));\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nvoid\nohci_abort_xfer_end(v)\n\tvoid *v;\n{\n\tusbd_xfer_handle xfer = v;\n\tstruct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;\n\tohci_softc_t *sc = (ohci_softc_t *)opipe->pipe.device->bus;\n\tohci_soft_ed_t *sed;\n\tohci_soft_td_t *p, *n;\n\tint s;\n\n\ts = splusb();\n\n\tp = xfer->hcpriv;\n#ifdef DIAGNOSTIC\n\tif (p == NULL) {\n\t\tprintf(\"ohci_abort_xfer: hcpriv==0\\n\");\n\t\treturn;\n\t}\n#endif\n\tfor (; p->xfer == xfer; p = n) {\n\t\tn = p->nexttd;\n\t\tohci_free_std(sc, p);\n\t}\n\n\tsed = opipe->sed;\n\tDPRINTFN(2,(\"ohci_abort_xfer: set hd=%x, tl=%x\\n\",\n\t\t    (int)p->physaddr, (int)le32toh(sed->ed.ed_tailp)));\n\tsed->ed.ed_headp = htole32(p->physaddr); /* unlink TDs */\n\tsed->ed.ed_flags &= htole32(~OHCI_ED_SKIP); /* remove hardware skip */\n\n\tusb_transfer_complete(xfer);\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 1779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ohci_timeout: xfer=%p\\n\", xfer)"
          ],
          "line": 1777
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));\nohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));\nohci_device_request __P((usbd_xfer_handle xfer));\nohci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_xfer_handle;\nohci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nohci_root_ctrl_transfer __P((usbd_xfer_handle));\nohci_root_ctrl_start __P((usbd_xfer_handle));\nohci_root_ctrl_abort __P((usbd_xfer_handle));\nohci_root_ctrl_done  __P((usbd_xfer_handle));\nohci_root_intr_transfer __P((usbd_xfer_handle));\nohci_root_intr_start __P((usbd_xfer_handle));\nohci_root_intr_abort __P((usbd_xfer_handle));\nohci_root_intr_done  __P((usbd_xfer_handle));\nohci_device_ctrl_transfer __P((usbd_xfer_handle));\nohci_device_ctrl_start __P((usbd_xfer_handle));\nohci_device_ctrl_abort __P((usbd_xfer_handle));\nohci_device_ctrl_done  __P((usbd_xfer_handle));\nohci_device_bulk_transfer __P((usbd_xfer_handle));\nohci_device_bulk_start __P((usbd_xfer_handle));\nohci_device_bulk_abort __P((usbd_xfer_handle));\nohci_device_bulk_done  __P((usbd_xfer_handle));\nohci_device_intr_transfer __P((usbd_xfer_handle));\nohci_device_intr_start __P((usbd_xfer_handle));\nohci_device_intr_abort __P((usbd_xfer_handle));\nohci_device_intr_done  __P((usbd_xfer_handle));\nohci_device_isoc_transfer __P((usbd_xfer_handle));\nohci_device_isoc_start __P((usbd_xfer_handle));\nohci_device_isoc_abort __P((usbd_xfer_handle));\nohci_device_isoc_done  __P((usbd_xfer_handle));\n\nvoid\nohci_timeout(addr)\n\tvoid *addr;\n{\n\tusbd_xfer_handle xfer = addr;\n\tint s;\n\n\tDPRINTF((\"ohci_timeout: xfer=%p\\n\", xfer));\n\n\ts = splusb();\n\txfer->device->bus->intr_context++;\n\tohci_abort_xfer(xfer, USBD_TIMEOUT);\n\txfer->device->bus->intr_context--;\n\tsplx(s);\n}"
  },
  {
    "function_name": "ohci_hash_rem_itd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "1741-1752",
    "snippet": "void\nohci_hash_rem_itd(sc, sitd)\n\tohci_softc_t *sc;\n\tohci_soft_itd_t *sitd;\n{\n\tSPLUSBCHECK;\n\n\tDPRINTFN(10,(\"ohci_hash_rem_itd: sitd=%p physaddr=0x%08lx\\n\", \n\t\t    sitd, (u_long)sitd->physaddr));\n\n\tLIST_REMOVE(sitd, hnext);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static ohci_soft_itd_t",
      "ohci_free_sitd __P((ohci_softc_t *,ohci_soft_itd_t *));",
      "ohci_hash_add_itd __P((ohci_softc_t *, \n\t\t\t    ohci_soft_itd_t *));",
      "ohci_hash_rem_itd __P((ohci_softc_t *,\n\t\t\t    ohci_soft_itd_t *));",
      "Static ohci_soft_itd_t",
      "ohci_rhsc_able __P((ohci_softc_t *, int));",
      "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
      "ohci_intr1 __P((ohci_softc_t *));",
      "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LIST_REMOVE",
          "args": [
            "sitd",
            "hnext"
          ],
          "line": 1751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "10",
            "(\"ohci_hash_rem_itd: sitd=%p physaddr=0x%08lx\\n\", \n\t\t    sitd, (u_long)sitd->physaddr)"
          ],
          "line": 1748
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_itd_t;\nohci_free_sitd __P((ohci_softc_t *,ohci_soft_itd_t *));\nohci_hash_add_itd __P((ohci_softc_t *, \n\t\t\t    ohci_soft_itd_t *));\nohci_hash_rem_itd __P((ohci_softc_t *,\n\t\t\t    ohci_soft_itd_t *));\nStatic ohci_soft_itd_t;\nohci_rhsc_able __P((ohci_softc_t *, int));\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nvoid\nohci_hash_rem_itd(sc, sitd)\n\tohci_softc_t *sc;\n\tohci_soft_itd_t *sitd;\n{\n\tSPLUSBCHECK;\n\n\tDPRINTFN(10,(\"ohci_hash_rem_itd: sitd=%p physaddr=0x%08lx\\n\", \n\t\t    sitd, (u_long)sitd->physaddr));\n\n\tLIST_REMOVE(sitd, hnext);\n}"
  },
  {
    "function_name": "ohci_hash_add_itd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "1725-1738",
    "snippet": "void\nohci_hash_add_itd(sc, sitd)\n\tohci_softc_t *sc;\n\tohci_soft_itd_t *sitd;\n{\n\tint h = HASH(sitd->physaddr);\n\n\tSPLUSBCHECK;\n\n\tDPRINTFN(10,(\"ohci_hash_add_itd: sitd=%p physaddr=0x%08lx\\n\", \n\t\t    sitd, (u_long)sitd->physaddr));\n\n\tLIST_INSERT_HEAD(&sc->sc_hash_itds[h], sitd, hnext);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static ohci_soft_itd_t",
      "ohci_free_sitd __P((ohci_softc_t *,ohci_soft_itd_t *));",
      "ohci_hash_add_itd __P((ohci_softc_t *, \n\t\t\t    ohci_soft_itd_t *));",
      "ohci_hash_rem_itd __P((ohci_softc_t *,\n\t\t\t    ohci_soft_itd_t *));",
      "Static ohci_soft_itd_t",
      "ohci_rhsc_able __P((ohci_softc_t *, int));",
      "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
      "ohci_intr1 __P((ohci_softc_t *));",
      "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LIST_INSERT_HEAD",
          "args": [
            "&sc->sc_hash_itds[h]",
            "sitd",
            "hnext"
          ],
          "line": 1737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "10",
            "(\"ohci_hash_add_itd: sitd=%p physaddr=0x%08lx\\n\", \n\t\t    sitd, (u_long)sitd->physaddr)"
          ],
          "line": 1734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HASH",
          "args": [
            "sitd->physaddr"
          ],
          "line": 1730
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_itd_t;\nohci_free_sitd __P((ohci_softc_t *,ohci_soft_itd_t *));\nohci_hash_add_itd __P((ohci_softc_t *, \n\t\t\t    ohci_soft_itd_t *));\nohci_hash_rem_itd __P((ohci_softc_t *,\n\t\t\t    ohci_soft_itd_t *));\nStatic ohci_soft_itd_t;\nohci_rhsc_able __P((ohci_softc_t *, int));\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nvoid\nohci_hash_add_itd(sc, sitd)\n\tohci_softc_t *sc;\n\tohci_soft_itd_t *sitd;\n{\n\tint h = HASH(sitd->physaddr);\n\n\tSPLUSBCHECK;\n\n\tDPRINTFN(10,(\"ohci_hash_add_itd: sitd=%p physaddr=0x%08lx\\n\", \n\t\t    sitd, (u_long)sitd->physaddr));\n\n\tLIST_INSERT_HEAD(&sc->sc_hash_itds[h], sitd, hnext);\n}"
  },
  {
    "function_name": "ohci_hash_rem_td",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "1698-1706",
    "snippet": "void\nohci_hash_rem_td(sc, std)\n\tohci_softc_t *sc;\n\tohci_soft_td_t *std;\n{\n\tSPLUSBCHECK;\n\n\tLIST_REMOVE(std, hnext);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static ohci_soft_td_t",
      "ohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));",
      "ohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));",
      "ohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));",
      "ohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));",
      "Static ohci_soft_td_t",
      "ohci_rhsc_able __P((ohci_softc_t *, int));",
      "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
      "ohci_intr1 __P((ohci_softc_t *));",
      "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LIST_REMOVE",
          "args": [
            "std",
            "hnext"
          ],
          "line": 1705
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_td_t;\nohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));\nohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));\nohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));\nohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));\nStatic ohci_soft_td_t;\nohci_rhsc_able __P((ohci_softc_t *, int));\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nvoid\nohci_hash_rem_td(sc, std)\n\tohci_softc_t *sc;\n\tohci_soft_td_t *std;\n{\n\tSPLUSBCHECK;\n\n\tLIST_REMOVE(std, hnext);\n}"
  },
  {
    "function_name": "ohci_hash_add_td",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "1685-1695",
    "snippet": "void\nohci_hash_add_td(sc, std)\n\tohci_softc_t *sc;\n\tohci_soft_td_t *std;\n{\n\tint h = HASH(std->physaddr);\n\n\tSPLUSBCHECK;\n\n\tLIST_INSERT_HEAD(&sc->sc_hash_tds[h], std, hnext);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static ohci_soft_td_t",
      "ohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));",
      "ohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));",
      "ohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));",
      "ohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));",
      "Static ohci_soft_td_t",
      "ohci_rhsc_able __P((ohci_softc_t *, int));",
      "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
      "ohci_intr1 __P((ohci_softc_t *));",
      "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LIST_INSERT_HEAD",
          "args": [
            "&sc->sc_hash_tds[h]",
            "std",
            "hnext"
          ],
          "line": 1694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HASH",
          "args": [
            "std->physaddr"
          ],
          "line": 1690
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_td_t;\nohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));\nohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));\nohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));\nohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));\nStatic ohci_soft_td_t;\nohci_rhsc_able __P((ohci_softc_t *, int));\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nvoid\nohci_hash_add_td(sc, std)\n\tohci_softc_t *sc;\n\tohci_soft_td_t *std;\n{\n\tint h = HASH(std->physaddr);\n\n\tSPLUSBCHECK;\n\n\tLIST_INSERT_HEAD(&sc->sc_hash_tds[h], std, hnext);\n}"
  },
  {
    "function_name": "ohci_rem_ed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "1655-1671",
    "snippet": "void\nohci_rem_ed(sed, head)\n\tohci_soft_ed_t *sed; \n\tohci_soft_ed_t *head; \n{\n\tohci_soft_ed_t *p; \n\n\tSPLUSBCHECK;\n\n\t/* XXX */\n\tfor (p = head; p == NULL && p->next != sed; p = p->next)\n\t\t;\n\tif (p == NULL)\n\t\tpanic(\"ohci_rem_ed: ED not found\\n\");\n\tp->next = sed->next;\n\tp->ed.ed_nexted = sed->ed.ed_nexted;\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static ohci_soft_ed_t",
      "ohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));",
      "ohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
      "ohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
      "ohci_close_pipe __P((usbd_pipe_handle pipe, \n\t\t\t    ohci_soft_ed_t *head));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"ohci_rem_ed: ED not found\\n\""
          ],
          "line": 1668
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_ed_t;\nohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));\nohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nohci_close_pipe __P((usbd_pipe_handle pipe, \n\t\t\t    ohci_soft_ed_t *head));\n\nvoid\nohci_rem_ed(sed, head)\n\tohci_soft_ed_t *sed; \n\tohci_soft_ed_t *head; \n{\n\tohci_soft_ed_t *p; \n\n\tSPLUSBCHECK;\n\n\t/* XXX */\n\tfor (p = head; p == NULL && p->next != sed; p = p->next)\n\t\t;\n\tif (p == NULL)\n\t\tpanic(\"ohci_rem_ed: ED not found\\n\");\n\tp->next = sed->next;\n\tp->ed.ed_nexted = sed->ed.ed_nexted;\n}"
  },
  {
    "function_name": "ohci_add_ed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "1640-1650",
    "snippet": "void\nohci_add_ed(sed, head)\n\tohci_soft_ed_t *sed; \n\tohci_soft_ed_t *head; \n{\n\tSPLUSBCHECK;\n\tsed->next = head->next;\n\tsed->ed.ed_nexted = head->ed.ed_nexted;\n\thead->next = sed;\n\thead->ed.ed_nexted = htole32(sed->physaddr);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static ohci_soft_ed_t",
      "ohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));",
      "ohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
      "ohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
      "ohci_close_pipe __P((usbd_pipe_handle pipe, \n\t\t\t    ohci_soft_ed_t *head));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "sed->physaddr"
          ],
          "line": 1649
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_ed_t;\nohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));\nohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nohci_close_pipe __P((usbd_pipe_handle pipe, \n\t\t\t    ohci_soft_ed_t *head));\n\nvoid\nohci_add_ed(sed, head)\n\tohci_soft_ed_t *sed; \n\tohci_soft_ed_t *head; \n{\n\tSPLUSBCHECK;\n\tsed->next = head->next;\n\tsed->ed.ed_nexted = head->ed.ed_nexted;\n\thead->next = sed;\n\thead->ed.ed_nexted = htole32(sed->physaddr);\n}"
  },
  {
    "function_name": "ohci_device_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "1509-1635",
    "snippet": "usbd_status\nohci_device_request(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tstruct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;\n\tusb_device_request_t *req = &xfer->request;\n\tusbd_device_handle dev = opipe->pipe.device;\n\tohci_softc_t *sc = (ohci_softc_t *)dev->bus;\n\tint addr = dev->address;\n\tohci_soft_td_t *setup, *stat, *next, *tail;\n\tohci_soft_ed_t *sed;\n\tint isread;\n\tint len;\n\tusbd_status err;\n\tint s;\n\n\tisread = req->bmRequestType & UT_READ;\n\tlen = UGETW(req->wLength);\n\n\tDPRINTFN(3,(\"ohci_device_control type=0x%02x, request=0x%02x, \"\n\t\t    \"wValue=0x%04x, wIndex=0x%04x len=%d, addr=%d, endpt=%d\\n\",\n\t\t    req->bmRequestType, req->bRequest, UGETW(req->wValue),\n\t\t    UGETW(req->wIndex), len, addr, \n\t\t    opipe->pipe.endpoint->edesc->bEndpointAddress));\n\n\tsetup = opipe->tail.td;\n\tstat = ohci_alloc_std(sc);\n\tif (stat == NULL) {\n\t\terr = USBD_NOMEM;\n\t\tgoto bad1;\n\t}\n\ttail = ohci_alloc_std(sc);\n\tif (tail == NULL) {\n\t\terr = USBD_NOMEM;\n\t\tgoto bad2;\n\t}\n\ttail->xfer = NULL;\n\n\tsed = opipe->sed;\n\topipe->u.ctl.length = len;\n\n\t/* Update device address and length since they may have changed. */\n\t/* XXX This only needs to be done once, but it's too early in open. */\n\t/* XXXX Should not touch ED here! */\n\tsed->ed.ed_flags = htole32(\n\t (le32toh(sed->ed.ed_flags) & ~(OHCI_ED_ADDRMASK | OHCI_ED_MAXPMASK)) |\n\t OHCI_ED_SET_FA(addr) |\n\t OHCI_ED_SET_MAXP(UGETW(opipe->pipe.endpoint->edesc->wMaxPacketSize)));\n\n\tnext = stat;\n\n\t/* Set up data transaction */\n\tif (len != 0) {\n\t\tohci_soft_td_t *std = stat;\n\n\t\terr = ohci_alloc_std_chain(opipe, sc, len, isread, xfer,\n\t\t\t  std, &stat);\n\t\tstat = stat->nexttd; /* point at free TD */\n\t\tif (err)\n\t\t\tgoto bad3;\n\t\t/* Start toggle at 1 and then use the carried toggle. */\n\t\tstd->td.td_flags &= htole32(~OHCI_TD_TOGGLE_MASK);\n\t\tstd->td.td_flags |= htole32(OHCI_TD_TOGGLE_1);\n\t}\n\n\tmemcpy(KERNADDR(&opipe->u.ctl.reqdma), req, sizeof *req);\n\n\tsetup->td.td_flags = htole32(OHCI_TD_SETUP | OHCI_TD_NOCC |\n\t\t\t\t     OHCI_TD_TOGGLE_0 | OHCI_TD_NOINTR);\n\tsetup->td.td_cbp = htole32(DMAADDR(&opipe->u.ctl.reqdma));\n\tsetup->nexttd = next;\n\tsetup->td.td_nexttd = htole32(next->physaddr);\n\tsetup->td.td_be = htole32(le32toh(setup->td.td_cbp) + sizeof *req - 1);\n\tsetup->len = 0;\n\tsetup->xfer = xfer;\n\tsetup->flags = 0;\n\txfer->hcpriv = setup;\n\n\tstat->td.td_flags = htole32(\n\t\t(isread ? OHCI_TD_OUT : OHCI_TD_IN) |\n\t\tOHCI_TD_NOCC | OHCI_TD_TOGGLE_1 | OHCI_TD_SET_DI(1));\n\tstat->td.td_cbp = 0;\n\tstat->nexttd = tail;\n\tstat->td.td_nexttd = htole32(tail->physaddr);\n\tstat->td.td_be = 0;\n\tstat->flags = OHCI_CALL_DONE;\n\tstat->len = 0;\n\tstat->xfer = xfer;\n\n#ifdef OHCI_DEBUG\n\tif (ohcidebug > 5) {\n\t\tDPRINTF((\"ohci_device_request:\\n\"));\n\t\tohci_dump_ed(sed);\n\t\tohci_dump_tds(setup);\n\t}\n#endif\n\n\t/* Insert ED in schedule */\n\ts = splusb();\n\tsed->ed.ed_tailp = htole32(tail->physaddr);\n\topipe->tail.td = tail;\n\tOWRITE4(sc, OHCI_COMMAND_STATUS, OHCI_CLF);\n\tif (xfer->timeout && !sc->sc_bus.use_polling) {\n                usb_callout(xfer->timeout_handle, MS_TO_TICKS(xfer->timeout),\n\t\t\t    ohci_timeout, xfer);\n\t}\n\tsplx(s);\n\n#if 0\n\tif (ohcidebug > 10) {\n\t\tdelay(10000);\n\t\tDPRINTF((\"ohci_device_request: status=%x\\n\",\n\t\t\t OREAD4(sc, OHCI_COMMAND_STATUS)));\n\t\tohci_dump_ed(sed);\n\t\tohci_dump_tds(setup);\n\t}\n#endif\n\n\treturn (USBD_NORMAL_COMPLETION);\n\n bad3:\n\tohci_free_std(sc, tail);\n bad2:\n\tohci_free_std(sc, stat);\n bad1:\n\treturn (err);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static ohci_soft_ed_t",
      "ohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));",
      "Static ohci_soft_td_t",
      "ohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));",
      "Static usbd_status",
      "ohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));",
      "Static usbd_status",
      "ohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));",
      "ohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_request __P((usbd_xfer_handle xfer));",
      "ohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
      "ohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
      "ohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));",
      "ohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));",
      "Static ohci_soft_td_t",
      "Static usbd_status",
      "ohci_setup_isoc __P((usbd_pipe_handle pipe));",
      "ohci_device_isoc_enter __P((usbd_xfer_handle));",
      "Static usbd_status",
      "Static usbd_xfer_handle",
      "ohci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_root_ctrl_start __P((usbd_xfer_handle));",
      "ohci_root_ctrl_abort __P((usbd_xfer_handle));",
      "ohci_root_ctrl_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_root_intr_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_root_intr_start __P((usbd_xfer_handle));",
      "ohci_root_intr_abort __P((usbd_xfer_handle));",
      "ohci_root_intr_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_ctrl_start __P((usbd_xfer_handle));",
      "ohci_device_ctrl_abort __P((usbd_xfer_handle));",
      "ohci_device_ctrl_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_bulk_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_bulk_start __P((usbd_xfer_handle));",
      "ohci_device_bulk_abort __P((usbd_xfer_handle));",
      "ohci_device_bulk_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_intr_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_intr_start __P((usbd_xfer_handle));",
      "ohci_device_intr_abort __P((usbd_xfer_handle));",
      "ohci_device_intr_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_isoc_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_isoc_start __P((usbd_xfer_handle));",
      "ohci_device_isoc_abort __P((usbd_xfer_handle));",
      "ohci_device_isoc_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_rhsc_able __P((ohci_softc_t *, int));",
      "ohci_abort_xfer __P((usbd_xfer_handle xfer,\n\t\t\t    usbd_status status));",
      "ohci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "ohci_noop __P((usbd_pipe_handle pipe));",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
      "ohci_intr1 __P((ohci_softc_t *));",
      "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ohci_free_std",
          "args": [
            "sc",
            "stat"
          ],
          "line": 1632
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_free_std_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "577-589",
          "snippet": "Static void\nohci_free_std_chain(sc, std, stdend)\n\tohci_softc_t *sc;\n\tohci_soft_td_t *std;\n\tohci_soft_td_t *stdend;\n{\n\tohci_soft_td_t *p;\n\n\tfor (; std != stdend; std = p) {\n\t\tp = std->nexttd;\n\t\tohci_free_std(sc, std);\n\t}\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static void",
            "Static ohci_soft_td_t",
            "Static void",
            "ohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));",
            "Static void",
            "ohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "ohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));",
            "Static void",
            "ohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));",
            "Static ohci_soft_td_t",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "ohci_rhsc_able __P((ohci_softc_t *, int));",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
            "Static int",
            "ohci_intr1 __P((ohci_softc_t *));",
            "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nStatic ohci_soft_td_t;\nStatic void;\nohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));\nStatic void;\nohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));\nStatic void;\nohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));\nStatic ohci_soft_td_t;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nohci_rhsc_able __P((ohci_softc_t *, int));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nStatic int;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nStatic void\nohci_free_std_chain(sc, std, stdend)\n\tohci_softc_t *sc;\n\tohci_soft_td_t *std;\n\tohci_soft_td_t *stdend;\n{\n\tohci_soft_td_t *p;\n\n\tfor (; std != stdend; std = p) {\n\t\tp = std->nexttd;\n\t\tohci_free_std(sc, std);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ohci_dump_tds",
          "args": [
            "setup"
          ],
          "line": 1623
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_dump_tds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "1787-1793",
          "snippet": "void\nohci_dump_tds(std)\n\tohci_soft_td_t *std;\n{\n\tfor (; std; std = std->nexttd)\n\t\tohci_dump_td(std);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static ohci_soft_td_t",
            "ohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));",
            "ohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));",
            "ohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));",
            "ohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));",
            "Static ohci_soft_td_t"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_td_t;\nohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));\nohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));\nohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));\nohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));\nStatic ohci_soft_td_t;\n\nvoid\nohci_dump_tds(std)\n\tohci_soft_td_t *std;\n{\n\tfor (; std; std = std->nexttd)\n\t\tohci_dump_td(std);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ohci_dump_ed",
          "args": [
            "sed"
          ],
          "line": 1622
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_dump_ed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "1842-1859",
          "snippet": "void\nohci_dump_ed(sed)\n\tohci_soft_ed_t *sed;\n{\n\tDPRINTF((\"ED(%p) at 0x%08lx: addr=%d endpt=%d maxp=%d %b\\ntailp=0x%08lx \"\n\t\t \"headflags=%b headp=0x%08lx nexted=0x%08lx\\n\",\n\t\t sed, (u_long)sed->physaddr, \n\t\t OHCI_ED_GET_FA(le32toh(sed->ed.ed_flags)),\n\t\t OHCI_ED_GET_EN(le32toh(sed->ed.ed_flags)),\n\t\t OHCI_ED_GET_MAXP(le32toh(sed->ed.ed_flags)),\n\t\t (int)le32toh(sed->ed.ed_flags),\n\t\t \"\\20\\14OUT\\15IN\\16LOWSPEED\\17SKIP\\20ISO\",\n\t\t (u_long)le32toh(sed->ed.ed_tailp),\n\t\t (u_long)le32toh(sed->ed.ed_headp),\n\t\t \"\\20\\1HALT\\2CARRY\",\n\t\t (u_long)le32toh(sed->ed.ed_headp),\n\t\t (u_long)le32toh(sed->ed.ed_nexted)));\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static ohci_soft_ed_t",
            "ohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));",
            "ohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
            "ohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_ed_t;\nohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));\nohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\n\nvoid\nohci_dump_ed(sed)\n\tohci_soft_ed_t *sed;\n{\n\tDPRINTF((\"ED(%p) at 0x%08lx: addr=%d endpt=%d maxp=%d %b\\ntailp=0x%08lx \"\n\t\t \"headflags=%b headp=0x%08lx nexted=0x%08lx\\n\",\n\t\t sed, (u_long)sed->physaddr, \n\t\t OHCI_ED_GET_FA(le32toh(sed->ed.ed_flags)),\n\t\t OHCI_ED_GET_EN(le32toh(sed->ed.ed_flags)),\n\t\t OHCI_ED_GET_MAXP(le32toh(sed->ed.ed_flags)),\n\t\t (int)le32toh(sed->ed.ed_flags),\n\t\t \"\\20\\14OUT\\15IN\\16LOWSPEED\\17SKIP\\20ISO\",\n\t\t (u_long)le32toh(sed->ed.ed_tailp),\n\t\t (u_long)le32toh(sed->ed.ed_headp),\n\t\t \"\\20\\1HALT\\2CARRY\",\n\t\t (u_long)le32toh(sed->ed.ed_headp),\n\t\t (u_long)le32toh(sed->ed.ed_nexted)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ohci_device_request: status=%x\\n\",\n\t\t\t OREAD4(sc, OHCI_COMMAND_STATUS))"
          ],
          "line": 1620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OREAD4",
          "args": [
            "sc",
            "OHCI_COMMAND_STATUS"
          ],
          "line": 1621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "10000"
          ],
          "line": 1619
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_delay_ms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "316-322",
          "snippet": "void\nusbd_delay_ms(dev, ms)\n\tusbd_device_handle dev;\n\tu_int ms;\n{\n\tusb_delay_ms(dev->bus, ms);\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_set_config __P((usbd_device_handle, int));",
            "usbd_getnewaddr __P((usbd_bus_handle bus));",
            "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_set_config __P((usbd_device_handle, int));\nusbd_getnewaddr __P((usbd_bus_handle bus));\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\n\nvoid\nusbd_delay_ms(dev, ms)\n\tusbd_device_handle dev;\n\tu_int ms;\n{\n\tusb_delay_ms(dev->bus, ms);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_callout",
          "args": [
            "xfer->timeout_handle",
            "MS_TO_TICKS(xfer->timeout)",
            "ohci_timeout",
            "xfer"
          ],
          "line": 1612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MS_TO_TICKS",
          "args": [
            "xfer->timeout"
          ],
          "line": 1612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OWRITE4",
          "args": [
            "sc",
            "OHCI_COMMAND_STATUS",
            "OHCI_CLF"
          ],
          "line": 1610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "tail->physaddr"
          ],
          "line": 1608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 1607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ohci_device_request:\\n\")"
          ],
          "line": 1600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "tail->physaddr"
          ],
          "line": 1592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "(isread ? OHCI_TD_OUT : OHCI_TD_IN) |\n\t\tOHCI_TD_NOCC | OHCI_TD_TOGGLE_1 | OHCI_TD_SET_DI(1)"
          ],
          "line": 1587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OHCI_TD_SET_DI",
          "args": [
            "1"
          ],
          "line": 1589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "le32toh(setup->td.td_cbp) + sizeof *req - 1"
          ],
          "line": 1581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "setup->td.td_cbp"
          ],
          "line": 1581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "next->physaddr"
          ],
          "line": 1580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "DMAADDR(&opipe->u.ctl.reqdma)"
          ],
          "line": 1578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DMAADDR",
          "args": [
            "&opipe->u.ctl.reqdma"
          ],
          "line": 1578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "OHCI_TD_SETUP | OHCI_TD_NOCC |\n\t\t\t\t     OHCI_TD_TOGGLE_0 | OHCI_TD_NOINTR"
          ],
          "line": 1576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "KERNADDR(&opipe->u.ctl.reqdma)",
            "req",
            "sizeof *req"
          ],
          "line": 1574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KERNADDR",
          "args": [
            "&opipe->u.ctl.reqdma"
          ],
          "line": 1574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "OHCI_TD_TOGGLE_1"
          ],
          "line": 1571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "~OHCI_TD_TOGGLE_MASK"
          ],
          "line": 1570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ohci_alloc_std_chain",
          "args": [
            "opipe",
            "sc",
            "len",
            "isread",
            "xfer",
            "std",
            "&stat"
          ],
          "line": 1564
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_alloc_std_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "479-574",
          "snippet": "usbd_status\nohci_alloc_std_chain(opipe, sc, alen, rd, xfer, sp, ep)\n\tstruct ohci_pipe *opipe;\n\tohci_softc_t *sc;\n\tint alen, rd;\n\tusbd_xfer_handle xfer;\n\tohci_soft_td_t *sp, **ep;\n{\n\tohci_soft_td_t *next, *cur;\n\tohci_physaddr_t dataphys, dataphysend;\n\tu_int32_t tdflags;\n\tint len, curlen;\n\tusb_dma_t *dma = &xfer->dmabuf;\n\tu_int16_t flags = xfer->flags;\n\n\tDPRINTFN(alen < 4096,(\"ohci_alloc_std_chain: start len=%d\\n\", alen));\n\n\tlen = alen;\n\tcur = sp;\n\tdataphys = DMAADDR(dma);\n\tdataphysend = OHCI_PAGE(dataphys + len - 1);\n\ttdflags = htole32(\n\t    (rd ? OHCI_TD_IN : OHCI_TD_OUT) | \n\t    (flags & USBD_SHORT_XFER_OK ? OHCI_TD_R : 0) |\n\t    OHCI_TD_NOCC | OHCI_TD_TOGGLE_CARRY | OHCI_TD_NOINTR);\n\n\tfor (;;) {\n\t\tnext = ohci_alloc_std(sc);\n\t\tif (next == NULL)\n\t\t\tgoto nomem;\n\n\t\t/* The OHCI hardware can handle at most one page crossing. */\n\t\tif (OHCI_PAGE(dataphys) == dataphysend ||\n\t\t    OHCI_PAGE(dataphys) + OHCI_PAGE_SIZE == dataphysend) {\n\t\t\t/* we can handle it in this TD */\n\t\t\tcurlen = len;\n\t\t} else {\n\t\t\t/* must use multiple TDs, fill as much as possible. */\n\t\t\tcurlen = 2 * OHCI_PAGE_SIZE - \n\t\t\t\t (dataphys & (OHCI_PAGE_SIZE-1));\n\t\t\t/* the length must be a multiple of the max size */\n\t\t\tcurlen -= curlen % UGETW(opipe->pipe.endpoint->edesc->wMaxPacketSize);\n#ifdef DIAGNOSTIC\n\t\t\tif (curlen == 0)\n\t\t\t\tpanic(\"ohci_alloc_std: curlen == 0\\n\");\n#endif\n\t\t}\n\t\tDPRINTFN(4,(\"ohci_alloc_std_chain: dataphys=0x%08x \"\n\t\t\t    \"dataphysend=0x%08x len=%d curlen=%d\\n\",\n\t\t\t    dataphys, dataphysend,\n\t\t\t    len, curlen));\n\t\tlen -= curlen;\n\n\t\tcur->td.td_flags = tdflags;\n\t\tcur->td.td_cbp = htole32(dataphys);\n\t\tcur->nexttd = next;\n\t\tcur->td.td_nexttd = htole32(next->physaddr);\n\t\tcur->td.td_be = htole32(dataphys + curlen - 1);\n\t\tcur->len = curlen;\n\t\tcur->flags = OHCI_ADD_LEN;\n\t\tcur->xfer = xfer;\n\t\tDPRINTFN(10,(\"ohci_alloc_std_chain: cbp=0x%08x be=0x%08x\\n\",\n\t\t\t    dataphys, dataphys + curlen - 1));\n\t\tif (len == 0)\n\t\t\tbreak;\n\t\tDPRINTFN(10,(\"ohci_alloc_std_chain: extend chain\\n\"));\n\t\tdataphys += curlen;\n\t\tcur = next;\n\t}\n\tif ((flags & USBD_FORCE_SHORT_XFER) &&\n\t    alen % UGETW(opipe->pipe.endpoint->edesc->wMaxPacketSize) == 0) {\n\t\t/* Force a 0 length transfer at the end. */\n\n\t\tcur = next;\n\t\tnext = ohci_alloc_std(sc);\n\t\tif (next == NULL)\n\t\t\tgoto nomem;\n\n\t\tcur->td.td_flags = tdflags;\n\t\tcur->td.td_cbp = 0; /* indicate 0 length packet */\n\t\tcur->nexttd = next;\n\t\tcur->td.td_nexttd = htole32(next->physaddr);\n\t\tcur->td.td_be = ~0;\n\t\tcur->len = 0;\n\t\tcur->flags = 0;\n\t\tcur->xfer = xfer;\n\t\tDPRINTFN(2,(\"ohci_alloc_std_chain: add 0 xfer\\n\"));\n\t}\n\t*ep = cur;\n\n\treturn (USBD_NORMAL_COMPLETION);\n\n nomem:\n\t/* XXX free chain */\n\treturn (USBD_NOMEM);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static ohci_soft_td_t",
            "ohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));",
            "Static usbd_status",
            "ohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));",
            "Static usbd_status",
            "ohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));",
            "ohci_add_done __P((ohci_softc_t *, ohci_physaddr_t));",
            "ohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_request __P((usbd_xfer_handle xfer));",
            "ohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));",
            "ohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));",
            "Static ohci_soft_td_t",
            "Static usbd_status",
            "ohci_setup_isoc __P((usbd_pipe_handle pipe));",
            "ohci_device_isoc_enter __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));",
            "ohci_freem __P((struct usbd_bus *, usb_dma_t *));",
            "Static usbd_xfer_handle",
            "ohci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_root_ctrl_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_root_ctrl_start __P((usbd_xfer_handle));",
            "ohci_root_ctrl_abort __P((usbd_xfer_handle));",
            "ohci_root_ctrl_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_root_intr_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_root_intr_start __P((usbd_xfer_handle));",
            "ohci_root_intr_abort __P((usbd_xfer_handle));",
            "ohci_root_intr_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_ctrl_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_ctrl_start __P((usbd_xfer_handle));",
            "ohci_device_ctrl_abort __P((usbd_xfer_handle));",
            "ohci_device_ctrl_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_bulk_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_bulk_start __P((usbd_xfer_handle));",
            "ohci_device_bulk_abort __P((usbd_xfer_handle));",
            "ohci_device_bulk_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_intr_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_intr_start __P((usbd_xfer_handle));",
            "ohci_device_intr_abort __P((usbd_xfer_handle));",
            "ohci_device_intr_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_isoc_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_isoc_start __P((usbd_xfer_handle));",
            "ohci_device_isoc_abort __P((usbd_xfer_handle));",
            "ohci_device_isoc_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_rhsc_able __P((ohci_softc_t *, int));",
            "ohci_device_clear_toggle __P((usbd_pipe_handle pipe));",
            "ohci_noop __P((usbd_pipe_handle pipe));",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
            "ohci_intr1 __P((ohci_softc_t *));",
            "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
            "ohci_physaddr_t a;",
            "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;",
            "ohci_physaddr_t a;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_td_t;\nohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));\nStatic usbd_status;\nohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));\nStatic usbd_status;\nohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));\nohci_add_done __P((ohci_softc_t *, ohci_physaddr_t));\nohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));\nStatic usbd_status;\nohci_device_request __P((usbd_xfer_handle xfer));\nohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));\nohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));\nStatic ohci_soft_td_t;\nStatic usbd_status;\nohci_setup_isoc __P((usbd_pipe_handle pipe));\nohci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));\nohci_freem __P((struct usbd_bus *, usb_dma_t *));\nStatic usbd_xfer_handle;\nohci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nStatic usbd_status;\nohci_root_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_ctrl_start __P((usbd_xfer_handle));\nohci_root_ctrl_abort __P((usbd_xfer_handle));\nohci_root_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_intr_start __P((usbd_xfer_handle));\nohci_root_intr_abort __P((usbd_xfer_handle));\nohci_root_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_ctrl_start __P((usbd_xfer_handle));\nohci_device_ctrl_abort __P((usbd_xfer_handle));\nohci_device_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_bulk_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_bulk_start __P((usbd_xfer_handle));\nohci_device_bulk_abort __P((usbd_xfer_handle));\nohci_device_bulk_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_intr_start __P((usbd_xfer_handle));\nohci_device_intr_abort __P((usbd_xfer_handle));\nohci_device_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_isoc_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_isoc_start __P((usbd_xfer_handle));\nohci_device_isoc_abort __P((usbd_xfer_handle));\nohci_device_isoc_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_rhsc_able __P((ohci_softc_t *, int));\nohci_device_clear_toggle __P((usbd_pipe_handle pipe));\nohci_noop __P((usbd_pipe_handle pipe));\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_physaddr_t a;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\nohci_physaddr_t a;\n\nusbd_status\nohci_alloc_std_chain(opipe, sc, alen, rd, xfer, sp, ep)\n\tstruct ohci_pipe *opipe;\n\tohci_softc_t *sc;\n\tint alen, rd;\n\tusbd_xfer_handle xfer;\n\tohci_soft_td_t *sp, **ep;\n{\n\tohci_soft_td_t *next, *cur;\n\tohci_physaddr_t dataphys, dataphysend;\n\tu_int32_t tdflags;\n\tint len, curlen;\n\tusb_dma_t *dma = &xfer->dmabuf;\n\tu_int16_t flags = xfer->flags;\n\n\tDPRINTFN(alen < 4096,(\"ohci_alloc_std_chain: start len=%d\\n\", alen));\n\n\tlen = alen;\n\tcur = sp;\n\tdataphys = DMAADDR(dma);\n\tdataphysend = OHCI_PAGE(dataphys + len - 1);\n\ttdflags = htole32(\n\t    (rd ? OHCI_TD_IN : OHCI_TD_OUT) | \n\t    (flags & USBD_SHORT_XFER_OK ? OHCI_TD_R : 0) |\n\t    OHCI_TD_NOCC | OHCI_TD_TOGGLE_CARRY | OHCI_TD_NOINTR);\n\n\tfor (;;) {\n\t\tnext = ohci_alloc_std(sc);\n\t\tif (next == NULL)\n\t\t\tgoto nomem;\n\n\t\t/* The OHCI hardware can handle at most one page crossing. */\n\t\tif (OHCI_PAGE(dataphys) == dataphysend ||\n\t\t    OHCI_PAGE(dataphys) + OHCI_PAGE_SIZE == dataphysend) {\n\t\t\t/* we can handle it in this TD */\n\t\t\tcurlen = len;\n\t\t} else {\n\t\t\t/* must use multiple TDs, fill as much as possible. */\n\t\t\tcurlen = 2 * OHCI_PAGE_SIZE - \n\t\t\t\t (dataphys & (OHCI_PAGE_SIZE-1));\n\t\t\t/* the length must be a multiple of the max size */\n\t\t\tcurlen -= curlen % UGETW(opipe->pipe.endpoint->edesc->wMaxPacketSize);\n#ifdef DIAGNOSTIC\n\t\t\tif (curlen == 0)\n\t\t\t\tpanic(\"ohci_alloc_std: curlen == 0\\n\");\n#endif\n\t\t}\n\t\tDPRINTFN(4,(\"ohci_alloc_std_chain: dataphys=0x%08x \"\n\t\t\t    \"dataphysend=0x%08x len=%d curlen=%d\\n\",\n\t\t\t    dataphys, dataphysend,\n\t\t\t    len, curlen));\n\t\tlen -= curlen;\n\n\t\tcur->td.td_flags = tdflags;\n\t\tcur->td.td_cbp = htole32(dataphys);\n\t\tcur->nexttd = next;\n\t\tcur->td.td_nexttd = htole32(next->physaddr);\n\t\tcur->td.td_be = htole32(dataphys + curlen - 1);\n\t\tcur->len = curlen;\n\t\tcur->flags = OHCI_ADD_LEN;\n\t\tcur->xfer = xfer;\n\t\tDPRINTFN(10,(\"ohci_alloc_std_chain: cbp=0x%08x be=0x%08x\\n\",\n\t\t\t    dataphys, dataphys + curlen - 1));\n\t\tif (len == 0)\n\t\t\tbreak;\n\t\tDPRINTFN(10,(\"ohci_alloc_std_chain: extend chain\\n\"));\n\t\tdataphys += curlen;\n\t\tcur = next;\n\t}\n\tif ((flags & USBD_FORCE_SHORT_XFER) &&\n\t    alen % UGETW(opipe->pipe.endpoint->edesc->wMaxPacketSize) == 0) {\n\t\t/* Force a 0 length transfer at the end. */\n\n\t\tcur = next;\n\t\tnext = ohci_alloc_std(sc);\n\t\tif (next == NULL)\n\t\t\tgoto nomem;\n\n\t\tcur->td.td_flags = tdflags;\n\t\tcur->td.td_cbp = 0; /* indicate 0 length packet */\n\t\tcur->nexttd = next;\n\t\tcur->td.td_nexttd = htole32(next->physaddr);\n\t\tcur->td.td_be = ~0;\n\t\tcur->len = 0;\n\t\tcur->flags = 0;\n\t\tcur->xfer = xfer;\n\t\tDPRINTFN(2,(\"ohci_alloc_std_chain: add 0 xfer\\n\"));\n\t}\n\t*ep = cur;\n\n\treturn (USBD_NORMAL_COMPLETION);\n\n nomem:\n\t/* XXX free chain */\n\treturn (USBD_NOMEM);\n}"
        }
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "(le32toh(sed->ed.ed_flags) & ~(OHCI_ED_ADDRMASK | OHCI_ED_MAXPMASK)) |\n\t OHCI_ED_SET_FA(addr) |\n\t OHCI_ED_SET_MAXP(UGETW(opipe->pipe.endpoint->edesc->wMaxPacketSize))"
          ],
          "line": 1553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OHCI_ED_SET_MAXP",
          "args": [
            "UGETW(opipe->pipe.endpoint->edesc->wMaxPacketSize)"
          ],
          "line": 1556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "opipe->pipe.endpoint->edesc->wMaxPacketSize"
          ],
          "line": 1556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OHCI_ED_SET_FA",
          "args": [
            "addr"
          ],
          "line": 1555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "sed->ed.ed_flags"
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "3",
            "(\"ohci_device_control type=0x%02x, request=0x%02x, \"\n\t\t    \"wValue=0x%04x, wIndex=0x%04x len=%d, addr=%d, endpt=%d\\n\",\n\t\t    req->bmRequestType, req->bRequest, UGETW(req->wValue),\n\t\t    UGETW(req->wIndex), len, addr, \n\t\t    opipe->pipe.endpoint->edesc->bEndpointAddress)"
          ],
          "line": 1528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "req->wIndex"
          ],
          "line": 1531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "req->wValue"
          ],
          "line": 1530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "req->wLength"
          ],
          "line": 1526
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_ed_t;\nohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));\nStatic ohci_soft_td_t;\nohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));\nStatic usbd_status;\nohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));\nStatic usbd_status;\nohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));\nohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));\nStatic usbd_status;\nohci_device_request __P((usbd_xfer_handle xfer));\nohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));\nohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));\nStatic ohci_soft_td_t;\nStatic usbd_status;\nohci_setup_isoc __P((usbd_pipe_handle pipe));\nohci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic usbd_xfer_handle;\nohci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nStatic usbd_status;\nohci_root_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_ctrl_start __P((usbd_xfer_handle));\nohci_root_ctrl_abort __P((usbd_xfer_handle));\nohci_root_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_intr_start __P((usbd_xfer_handle));\nohci_root_intr_abort __P((usbd_xfer_handle));\nohci_root_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_ctrl_start __P((usbd_xfer_handle));\nohci_device_ctrl_abort __P((usbd_xfer_handle));\nohci_device_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_bulk_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_bulk_start __P((usbd_xfer_handle));\nohci_device_bulk_abort __P((usbd_xfer_handle));\nohci_device_bulk_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_intr_start __P((usbd_xfer_handle));\nohci_device_intr_abort __P((usbd_xfer_handle));\nohci_device_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_isoc_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_isoc_start __P((usbd_xfer_handle));\nohci_device_isoc_abort __P((usbd_xfer_handle));\nohci_device_isoc_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_rhsc_able __P((ohci_softc_t *, int));\nohci_abort_xfer __P((usbd_xfer_handle xfer,\n\t\t\t    usbd_status status));\nohci_device_clear_toggle __P((usbd_pipe_handle pipe));\nohci_noop __P((usbd_pipe_handle pipe));\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nusbd_status\nohci_device_request(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tstruct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;\n\tusb_device_request_t *req = &xfer->request;\n\tusbd_device_handle dev = opipe->pipe.device;\n\tohci_softc_t *sc = (ohci_softc_t *)dev->bus;\n\tint addr = dev->address;\n\tohci_soft_td_t *setup, *stat, *next, *tail;\n\tohci_soft_ed_t *sed;\n\tint isread;\n\tint len;\n\tusbd_status err;\n\tint s;\n\n\tisread = req->bmRequestType & UT_READ;\n\tlen = UGETW(req->wLength);\n\n\tDPRINTFN(3,(\"ohci_device_control type=0x%02x, request=0x%02x, \"\n\t\t    \"wValue=0x%04x, wIndex=0x%04x len=%d, addr=%d, endpt=%d\\n\",\n\t\t    req->bmRequestType, req->bRequest, UGETW(req->wValue),\n\t\t    UGETW(req->wIndex), len, addr, \n\t\t    opipe->pipe.endpoint->edesc->bEndpointAddress));\n\n\tsetup = opipe->tail.td;\n\tstat = ohci_alloc_std(sc);\n\tif (stat == NULL) {\n\t\terr = USBD_NOMEM;\n\t\tgoto bad1;\n\t}\n\ttail = ohci_alloc_std(sc);\n\tif (tail == NULL) {\n\t\terr = USBD_NOMEM;\n\t\tgoto bad2;\n\t}\n\ttail->xfer = NULL;\n\n\tsed = opipe->sed;\n\topipe->u.ctl.length = len;\n\n\t/* Update device address and length since they may have changed. */\n\t/* XXX This only needs to be done once, but it's too early in open. */\n\t/* XXXX Should not touch ED here! */\n\tsed->ed.ed_flags = htole32(\n\t (le32toh(sed->ed.ed_flags) & ~(OHCI_ED_ADDRMASK | OHCI_ED_MAXPMASK)) |\n\t OHCI_ED_SET_FA(addr) |\n\t OHCI_ED_SET_MAXP(UGETW(opipe->pipe.endpoint->edesc->wMaxPacketSize)));\n\n\tnext = stat;\n\n\t/* Set up data transaction */\n\tif (len != 0) {\n\t\tohci_soft_td_t *std = stat;\n\n\t\terr = ohci_alloc_std_chain(opipe, sc, len, isread, xfer,\n\t\t\t  std, &stat);\n\t\tstat = stat->nexttd; /* point at free TD */\n\t\tif (err)\n\t\t\tgoto bad3;\n\t\t/* Start toggle at 1 and then use the carried toggle. */\n\t\tstd->td.td_flags &= htole32(~OHCI_TD_TOGGLE_MASK);\n\t\tstd->td.td_flags |= htole32(OHCI_TD_TOGGLE_1);\n\t}\n\n\tmemcpy(KERNADDR(&opipe->u.ctl.reqdma), req, sizeof *req);\n\n\tsetup->td.td_flags = htole32(OHCI_TD_SETUP | OHCI_TD_NOCC |\n\t\t\t\t     OHCI_TD_TOGGLE_0 | OHCI_TD_NOINTR);\n\tsetup->td.td_cbp = htole32(DMAADDR(&opipe->u.ctl.reqdma));\n\tsetup->nexttd = next;\n\tsetup->td.td_nexttd = htole32(next->physaddr);\n\tsetup->td.td_be = htole32(le32toh(setup->td.td_cbp) + sizeof *req - 1);\n\tsetup->len = 0;\n\tsetup->xfer = xfer;\n\tsetup->flags = 0;\n\txfer->hcpriv = setup;\n\n\tstat->td.td_flags = htole32(\n\t\t(isread ? OHCI_TD_OUT : OHCI_TD_IN) |\n\t\tOHCI_TD_NOCC | OHCI_TD_TOGGLE_1 | OHCI_TD_SET_DI(1));\n\tstat->td.td_cbp = 0;\n\tstat->nexttd = tail;\n\tstat->td.td_nexttd = htole32(tail->physaddr);\n\tstat->td.td_be = 0;\n\tstat->flags = OHCI_CALL_DONE;\n\tstat->len = 0;\n\tstat->xfer = xfer;\n\n#ifdef OHCI_DEBUG\n\tif (ohcidebug > 5) {\n\t\tDPRINTF((\"ohci_device_request:\\n\"));\n\t\tohci_dump_ed(sed);\n\t\tohci_dump_tds(setup);\n\t}\n#endif\n\n\t/* Insert ED in schedule */\n\ts = splusb();\n\tsed->ed.ed_tailp = htole32(tail->physaddr);\n\topipe->tail.td = tail;\n\tOWRITE4(sc, OHCI_COMMAND_STATUS, OHCI_CLF);\n\tif (xfer->timeout && !sc->sc_bus.use_polling) {\n                usb_callout(xfer->timeout_handle, MS_TO_TICKS(xfer->timeout),\n\t\t\t    ohci_timeout, xfer);\n\t}\n\tsplx(s);\n\n#if 0\n\tif (ohcidebug > 10) {\n\t\tdelay(10000);\n\t\tDPRINTF((\"ohci_device_request: status=%x\\n\",\n\t\t\t OREAD4(sc, OHCI_COMMAND_STATUS)));\n\t\tohci_dump_ed(sed);\n\t\tohci_dump_tds(setup);\n\t}\n#endif\n\n\treturn (USBD_NORMAL_COMPLETION);\n\n bad3:\n\tohci_free_std(sc, tail);\n bad2:\n\tohci_free_std(sc, stat);\n bad1:\n\treturn (err);\n}"
  },
  {
    "function_name": "ohci_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "1499-1507",
    "snippet": "void\nohci_poll(bus)\n\tstruct usbd_bus *bus;\n{\n\tohci_softc_t *sc = (ohci_softc_t *)bus;\n\n\tif (OREAD4(sc, OHCI_INTERRUPT_STATUS) & sc->sc_eintrs)\n\t\tohci_intr1(sc);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "ohci_poll __P((struct usbd_bus *));",
      "ohci_softintr __P((struct usbd_bus *));",
      "ohci_allocx __P((struct usbd_bus *));",
      "ohci_rhsc_able __P((ohci_softc_t *, int));",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
      "ohci_intr1 __P((ohci_softc_t *));",
      "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ohci_intr1",
          "args": [
            "sc"
          ],
          "line": 1506
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_intr1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "1041-1120",
          "snippet": "Static int\nohci_intr1(sc)\n\tohci_softc_t *sc;\n{\n\tu_int32_t intrs, eintrs;\n\tohci_physaddr_t done;\n\n\t/* In case the interrupt occurs before initialization has completed. */\n\tif (sc == NULL || sc->sc_hcca == NULL) {\n#ifdef DIAGNOSTIC\n\t\tprintf(\"ohci_intr: sc->sc_hcca == NULL\\n\");\n#endif\n\t\treturn (0);\n\t}\n\n        intrs = 0;\n\tdone = le32toh(sc->sc_hcca->hcca_done_head);\n\tif (done != 0) {\n\t\tif (done & ~OHCI_DONE_INTRS)\n\t\t\tintrs = OHCI_WDH;\n\t\tif (done & OHCI_DONE_INTRS)\n\t\t\tintrs |= OREAD4(sc, OHCI_INTERRUPT_STATUS);\n\t} else\n\t\tintrs = OREAD4(sc, OHCI_INTERRUPT_STATUS);\n\n\tif (!intrs)\n\t\treturn (0);\n\n\tintrs &= ~OHCI_MIE;\n\tOWRITE4(sc, OHCI_INTERRUPT_STATUS, intrs); /* Acknowledge */\n\teintrs = intrs & sc->sc_eintrs;\n\tif (!eintrs)\n\t\treturn (0);\n\n\tsc->sc_bus.intr_context++;\n\tsc->sc_bus.no_intrs++;\n\tDPRINTFN(7, (\"ohci_intr: sc=%p intrs=0x%x(0x%x) eintrs=0x%x\\n\", \n\t\t     sc, (u_int)intrs, OREAD4(sc, OHCI_INTERRUPT_STATUS),\n\t\t     (u_int)eintrs));\n\n\tif (eintrs & OHCI_SO) {\n\t\tprintf(\"%s: scheduling overrun\\n\",USBDEVNAME(sc->sc_bus.bdev));\n\t\t/* XXX do what */\n\t\tintrs &= ~OHCI_SO;\n\t}\n\tif (eintrs & OHCI_WDH) {\n\t\tohci_add_done(sc, done &~ OHCI_DONE_INTRS);\n\t\tsc->sc_hcca->hcca_done_head = 0;\n\t\tusb_schedsoftintr(&sc->sc_bus);\n\t\tintrs &= ~OHCI_WDH;\n\t}\n\tif (eintrs & OHCI_RD) {\n\t\tprintf(\"%s: resume detect\\n\", USBDEVNAME(sc->sc_bus.bdev));\n\t\t/* XXX process resume detect */\n\t}\n\tif (eintrs & OHCI_UE) {\n\t\tprintf(\"%s: unrecoverable error, controller halted\\n\",\n\t\t       USBDEVNAME(sc->sc_bus.bdev));\n\t\tOWRITE4(sc, OHCI_CONTROL, OHCI_HCFS_RESET);\n\t\t/* XXX what else */\n\t}\n\tif (eintrs & OHCI_RHSC) {\n\t\tohci_rhsc(sc, sc->sc_intrxfer);\n\t\tintrs &= ~OHCI_RHSC;\n\n\t\t/* \n\t\t * Disable RHSC interrupt for now, because it will be\n\t\t * on until the port has been reset.\n\t\t */\n\t\tohci_rhsc_able(sc, 0);\n\t}\n\n\tsc->sc_bus.intr_context--;\n\n\t/* Block unprocessed interrupts. XXX */\n\tOWRITE4(sc, OHCI_INTERRUPT_DISABLE, intrs);\n\tsc->sc_eintrs &= ~intrs;\n\n\treturn (1);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "ohci_add_done __P((ohci_softc_t *, ohci_physaddr_t));",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "ohci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "ohci_rhsc_able __P((ohci_softc_t *, int));",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
            "Static int",
            "ohci_intr1 __P((ohci_softc_t *));",
            "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_add_done __P((ohci_softc_t *, ohci_physaddr_t));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nohci_rhsc_able __P((ohci_softc_t *, int));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nStatic int;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nStatic int\nohci_intr1(sc)\n\tohci_softc_t *sc;\n{\n\tu_int32_t intrs, eintrs;\n\tohci_physaddr_t done;\n\n\t/* In case the interrupt occurs before initialization has completed. */\n\tif (sc == NULL || sc->sc_hcca == NULL) {\n#ifdef DIAGNOSTIC\n\t\tprintf(\"ohci_intr: sc->sc_hcca == NULL\\n\");\n#endif\n\t\treturn (0);\n\t}\n\n        intrs = 0;\n\tdone = le32toh(sc->sc_hcca->hcca_done_head);\n\tif (done != 0) {\n\t\tif (done & ~OHCI_DONE_INTRS)\n\t\t\tintrs = OHCI_WDH;\n\t\tif (done & OHCI_DONE_INTRS)\n\t\t\tintrs |= OREAD4(sc, OHCI_INTERRUPT_STATUS);\n\t} else\n\t\tintrs = OREAD4(sc, OHCI_INTERRUPT_STATUS);\n\n\tif (!intrs)\n\t\treturn (0);\n\n\tintrs &= ~OHCI_MIE;\n\tOWRITE4(sc, OHCI_INTERRUPT_STATUS, intrs); /* Acknowledge */\n\teintrs = intrs & sc->sc_eintrs;\n\tif (!eintrs)\n\t\treturn (0);\n\n\tsc->sc_bus.intr_context++;\n\tsc->sc_bus.no_intrs++;\n\tDPRINTFN(7, (\"ohci_intr: sc=%p intrs=0x%x(0x%x) eintrs=0x%x\\n\", \n\t\t     sc, (u_int)intrs, OREAD4(sc, OHCI_INTERRUPT_STATUS),\n\t\t     (u_int)eintrs));\n\n\tif (eintrs & OHCI_SO) {\n\t\tprintf(\"%s: scheduling overrun\\n\",USBDEVNAME(sc->sc_bus.bdev));\n\t\t/* XXX do what */\n\t\tintrs &= ~OHCI_SO;\n\t}\n\tif (eintrs & OHCI_WDH) {\n\t\tohci_add_done(sc, done &~ OHCI_DONE_INTRS);\n\t\tsc->sc_hcca->hcca_done_head = 0;\n\t\tusb_schedsoftintr(&sc->sc_bus);\n\t\tintrs &= ~OHCI_WDH;\n\t}\n\tif (eintrs & OHCI_RD) {\n\t\tprintf(\"%s: resume detect\\n\", USBDEVNAME(sc->sc_bus.bdev));\n\t\t/* XXX process resume detect */\n\t}\n\tif (eintrs & OHCI_UE) {\n\t\tprintf(\"%s: unrecoverable error, controller halted\\n\",\n\t\t       USBDEVNAME(sc->sc_bus.bdev));\n\t\tOWRITE4(sc, OHCI_CONTROL, OHCI_HCFS_RESET);\n\t\t/* XXX what else */\n\t}\n\tif (eintrs & OHCI_RHSC) {\n\t\tohci_rhsc(sc, sc->sc_intrxfer);\n\t\tintrs &= ~OHCI_RHSC;\n\n\t\t/* \n\t\t * Disable RHSC interrupt for now, because it will be\n\t\t * on until the port has been reset.\n\t\t */\n\t\tohci_rhsc_able(sc, 0);\n\t}\n\n\tsc->sc_bus.intr_context--;\n\n\t/* Block unprocessed interrupts. XXX */\n\tOWRITE4(sc, OHCI_INTERRUPT_DISABLE, intrs);\n\tsc->sc_eintrs &= ~intrs;\n\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OREAD4",
          "args": [
            "sc",
            "OHCI_INTERRUPT_STATUS"
          ],
          "line": 1505
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nohci_poll __P((struct usbd_bus *));\nohci_softintr __P((struct usbd_bus *));\nohci_allocx __P((struct usbd_bus *));\nohci_rhsc_able __P((ohci_softc_t *, int));\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nvoid\nohci_poll(bus)\n\tstruct usbd_bus *bus;\n{\n\tohci_softc_t *sc = (ohci_softc_t *)bus;\n\n\tif (OREAD4(sc, OHCI_INTERRUPT_STATUS) & sc->sc_eintrs)\n\t\tohci_intr1(sc);\n}"
  },
  {
    "function_name": "ohci_waitintr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "1467-1497",
    "snippet": "void\nohci_waitintr(sc, xfer)\n\tohci_softc_t *sc;\n\tusbd_xfer_handle xfer;\n{\n\tint timo = xfer->timeout;\n\tint usecs;\n\tu_int32_t intrs;\n\n\txfer->status = USBD_IN_PROGRESS;\n\tfor (usecs = timo * 1000000 / hz; usecs > 0; usecs -= 1000) {\n\t\tusb_delay_ms(&sc->sc_bus, 1);\n\t\tintrs = OREAD4(sc, OHCI_INTERRUPT_STATUS) & sc->sc_eintrs;\n\t\tDPRINTFN(15,(\"ohci_waitintr: 0x%04x\\n\", intrs));\n#ifdef OHCI_DEBUG\n\t\tif (ohcidebug > 15)\n\t\t\tohci_dumpregs(sc);\n#endif\n\t\tif (intrs) {\n\t\t\tohci_intr1(sc);\n\t\t\tif (xfer->status != USBD_IN_PROGRESS)\n\t\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Timeout */\n\tDPRINTF((\"ohci_waitintr: timeout\\n\"));\n\txfer->status = USBD_TIMEOUT;\n\tusb_transfer_complete(xfer);\n\t/* XXX should free TD */\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "ohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));",
      "ohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));",
      "ohci_device_request __P((usbd_xfer_handle xfer));",
      "ohci_device_isoc_enter __P((usbd_xfer_handle));",
      "ohci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));",
      "Static usbd_xfer_handle",
      "ohci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "ohci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "ohci_root_ctrl_start __P((usbd_xfer_handle));",
      "ohci_root_ctrl_abort __P((usbd_xfer_handle));",
      "ohci_root_ctrl_done  __P((usbd_xfer_handle));",
      "ohci_root_intr_transfer __P((usbd_xfer_handle));",
      "ohci_root_intr_start __P((usbd_xfer_handle));",
      "ohci_root_intr_abort __P((usbd_xfer_handle));",
      "ohci_root_intr_done  __P((usbd_xfer_handle));",
      "ohci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "ohci_device_ctrl_start __P((usbd_xfer_handle));",
      "ohci_device_ctrl_abort __P((usbd_xfer_handle));",
      "ohci_device_ctrl_done  __P((usbd_xfer_handle));",
      "ohci_device_bulk_transfer __P((usbd_xfer_handle));",
      "ohci_device_bulk_start __P((usbd_xfer_handle));",
      "ohci_device_bulk_abort __P((usbd_xfer_handle));",
      "ohci_device_bulk_done  __P((usbd_xfer_handle));",
      "ohci_device_intr_transfer __P((usbd_xfer_handle));",
      "ohci_device_intr_start __P((usbd_xfer_handle));",
      "ohci_device_intr_abort __P((usbd_xfer_handle));",
      "ohci_device_intr_done  __P((usbd_xfer_handle));",
      "ohci_device_isoc_transfer __P((usbd_xfer_handle));",
      "ohci_device_isoc_start __P((usbd_xfer_handle));",
      "ohci_device_isoc_abort __P((usbd_xfer_handle));",
      "ohci_device_isoc_done  __P((usbd_xfer_handle));",
      "ohci_rhsc_able __P((ohci_softc_t *, int));",
      "ohci_abort_xfer __P((usbd_xfer_handle xfer,\n\t\t\t    usbd_status status));",
      "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
      "ohci_intr1 __P((ohci_softc_t *));",
      "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usb_transfer_complete",
          "args": [
            "xfer"
          ],
          "line": 1495
        },
        "resolved": true,
        "details": {
          "function_name": "usb_transfer_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "789-883",
          "snippet": "void\nusb_transfer_complete(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tint repeat = pipe->repeat;\n\tint polling;\n\n\tSPLUSBCHECK;\n\n\tDPRINTFN(5, (\"usb_transfer_complete: pipe=%p xfer=%p status=%d \"\n\t\t     \"actlen=%d\\n\", pipe, xfer, xfer->status, xfer->actlen));\n\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_transfer_cb: pipe==0, xfer=%p\\n\", xfer);\n\t\treturn;\n\t}\n#endif\n\tpolling = pipe->device->bus->use_polling;\n\t/* XXXX */\n\tif (polling)\n\t\tpipe->running = 0;\n\n\tif (!(xfer->flags & USBD_NO_COPY) && xfer->actlen != 0 &&\n\t    usbd_xfer_isread(xfer)) {\n#ifdef DIAGNOSTIC\n\t\tif (xfer->actlen > xfer->length) {\n\t\t\tprintf(\"usb_transfer_complete: actlen > len %d > %d\\n\",\n\t\t\t       xfer->actlen, xfer->length);\n\t\t\txfer->actlen = xfer->length;\n\t\t}\n#endif\n\t\tmemcpy(xfer->buffer, KERNADDR(dmap), xfer->actlen);\n\t}\n\n\t/* if we allocated the buffer in usbd_transfer() we free it here. */\n\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\tif (!repeat) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\t\t\tbus->methods->freem(bus, dmap);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!repeat) {\n\t\t/* Remove request from queue. */\n#ifdef DIAGNOSTIC\n\t\tif (xfer != SIMPLEQ_FIRST(&pipe->queue))\n\t\t\tprintf(\"usb_transfer_complete: bad dequeue %p != %p\\n\",\n\t\t\t       xfer, SIMPLEQ_FIRST(&pipe->queue));\n#endif\n\t\tSIMPLEQ_REMOVE_HEAD(&pipe->queue, xfer, next);\n\t}\n\tDPRINTFN(5,(\"usb_transfer_complete: repeat=%d new head=%p\\n\", \n\t\t    repeat, SIMPLEQ_FIRST(&pipe->queue)));\n\n\t/* Count completed transfers. */\n\t++pipe->device->bus->stats.requests\n\t\t[pipe->endpoint->edesc->bmAttributes & UE_XFERTYPE];\n\n\txfer->done = 1;\n\tif (!xfer->status && xfer->actlen < xfer->length &&\n\t    !(xfer->flags & USBD_SHORT_XFER_OK)) {\n\t\tDPRINTFN(-1,(\"usbd_transfer_cb: short transfer %d<%d\\n\",\n\t\t\t     xfer->actlen, xfer->length));\n\t\txfer->status = USBD_SHORT_XFER;\n\t}\n\n\tif (xfer->callback)\n\t\txfer->callback(xfer, xfer->priv, xfer->status);\n\n#ifdef DIAGNOSTIC\n\tif (pipe->methods->done != NULL)\n\t\tpipe->methods->done(xfer);\n\telse\n\t\tprintf(\"usb_transfer_complete: pipe->methods->done == NULL\\n\");\n#else\n\tpipe->methods->done(xfer);\n#endif\n\n\tif ((xfer->flags & USBD_SYNCHRONOUS) && !polling)\n\t\twakeup(xfer);\n\n\tif (!repeat) {\n\t\t/* XXX should we stop the queue on all errors? */\n\t\tif ((xfer->status == USBD_CANCELLED ||\n\t\t     xfer->status == USBD_TIMEOUT) &&\n\t\t    pipe->iface != NULL)\t\t/* not control pipe */\n\t\t\tpipe->running = 0;\n\t\telse\n\t\t\tusbd_start_next(pipe);\n\t}\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "usb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;",
            "usb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);",
            "usb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_start_next __P((usbd_pipe_handle pipe));\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nusb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;\nusb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\nusb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;\n\nvoid\nusb_transfer_complete(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tint repeat = pipe->repeat;\n\tint polling;\n\n\tSPLUSBCHECK;\n\n\tDPRINTFN(5, (\"usb_transfer_complete: pipe=%p xfer=%p status=%d \"\n\t\t     \"actlen=%d\\n\", pipe, xfer, xfer->status, xfer->actlen));\n\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_transfer_cb: pipe==0, xfer=%p\\n\", xfer);\n\t\treturn;\n\t}\n#endif\n\tpolling = pipe->device->bus->use_polling;\n\t/* XXXX */\n\tif (polling)\n\t\tpipe->running = 0;\n\n\tif (!(xfer->flags & USBD_NO_COPY) && xfer->actlen != 0 &&\n\t    usbd_xfer_isread(xfer)) {\n#ifdef DIAGNOSTIC\n\t\tif (xfer->actlen > xfer->length) {\n\t\t\tprintf(\"usb_transfer_complete: actlen > len %d > %d\\n\",\n\t\t\t       xfer->actlen, xfer->length);\n\t\t\txfer->actlen = xfer->length;\n\t\t}\n#endif\n\t\tmemcpy(xfer->buffer, KERNADDR(dmap), xfer->actlen);\n\t}\n\n\t/* if we allocated the buffer in usbd_transfer() we free it here. */\n\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\tif (!repeat) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\t\t\tbus->methods->freem(bus, dmap);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!repeat) {\n\t\t/* Remove request from queue. */\n#ifdef DIAGNOSTIC\n\t\tif (xfer != SIMPLEQ_FIRST(&pipe->queue))\n\t\t\tprintf(\"usb_transfer_complete: bad dequeue %p != %p\\n\",\n\t\t\t       xfer, SIMPLEQ_FIRST(&pipe->queue));\n#endif\n\t\tSIMPLEQ_REMOVE_HEAD(&pipe->queue, xfer, next);\n\t}\n\tDPRINTFN(5,(\"usb_transfer_complete: repeat=%d new head=%p\\n\", \n\t\t    repeat, SIMPLEQ_FIRST(&pipe->queue)));\n\n\t/* Count completed transfers. */\n\t++pipe->device->bus->stats.requests\n\t\t[pipe->endpoint->edesc->bmAttributes & UE_XFERTYPE];\n\n\txfer->done = 1;\n\tif (!xfer->status && xfer->actlen < xfer->length &&\n\t    !(xfer->flags & USBD_SHORT_XFER_OK)) {\n\t\tDPRINTFN(-1,(\"usbd_transfer_cb: short transfer %d<%d\\n\",\n\t\t\t     xfer->actlen, xfer->length));\n\t\txfer->status = USBD_SHORT_XFER;\n\t}\n\n\tif (xfer->callback)\n\t\txfer->callback(xfer, xfer->priv, xfer->status);\n\n#ifdef DIAGNOSTIC\n\tif (pipe->methods->done != NULL)\n\t\tpipe->methods->done(xfer);\n\telse\n\t\tprintf(\"usb_transfer_complete: pipe->methods->done == NULL\\n\");\n#else\n\tpipe->methods->done(xfer);\n#endif\n\n\tif ((xfer->flags & USBD_SYNCHRONOUS) && !polling)\n\t\twakeup(xfer);\n\n\tif (!repeat) {\n\t\t/* XXX should we stop the queue on all errors? */\n\t\tif ((xfer->status == USBD_CANCELLED ||\n\t\t     xfer->status == USBD_TIMEOUT) &&\n\t\t    pipe->iface != NULL)\t\t/* not control pipe */\n\t\t\tpipe->running = 0;\n\t\telse\n\t\t\tusbd_start_next(pipe);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ohci_waitintr: timeout\\n\")"
          ],
          "line": 1493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ohci_intr1",
          "args": [
            "sc"
          ],
          "line": 1486
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_intr1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "1041-1120",
          "snippet": "Static int\nohci_intr1(sc)\n\tohci_softc_t *sc;\n{\n\tu_int32_t intrs, eintrs;\n\tohci_physaddr_t done;\n\n\t/* In case the interrupt occurs before initialization has completed. */\n\tif (sc == NULL || sc->sc_hcca == NULL) {\n#ifdef DIAGNOSTIC\n\t\tprintf(\"ohci_intr: sc->sc_hcca == NULL\\n\");\n#endif\n\t\treturn (0);\n\t}\n\n        intrs = 0;\n\tdone = le32toh(sc->sc_hcca->hcca_done_head);\n\tif (done != 0) {\n\t\tif (done & ~OHCI_DONE_INTRS)\n\t\t\tintrs = OHCI_WDH;\n\t\tif (done & OHCI_DONE_INTRS)\n\t\t\tintrs |= OREAD4(sc, OHCI_INTERRUPT_STATUS);\n\t} else\n\t\tintrs = OREAD4(sc, OHCI_INTERRUPT_STATUS);\n\n\tif (!intrs)\n\t\treturn (0);\n\n\tintrs &= ~OHCI_MIE;\n\tOWRITE4(sc, OHCI_INTERRUPT_STATUS, intrs); /* Acknowledge */\n\teintrs = intrs & sc->sc_eintrs;\n\tif (!eintrs)\n\t\treturn (0);\n\n\tsc->sc_bus.intr_context++;\n\tsc->sc_bus.no_intrs++;\n\tDPRINTFN(7, (\"ohci_intr: sc=%p intrs=0x%x(0x%x) eintrs=0x%x\\n\", \n\t\t     sc, (u_int)intrs, OREAD4(sc, OHCI_INTERRUPT_STATUS),\n\t\t     (u_int)eintrs));\n\n\tif (eintrs & OHCI_SO) {\n\t\tprintf(\"%s: scheduling overrun\\n\",USBDEVNAME(sc->sc_bus.bdev));\n\t\t/* XXX do what */\n\t\tintrs &= ~OHCI_SO;\n\t}\n\tif (eintrs & OHCI_WDH) {\n\t\tohci_add_done(sc, done &~ OHCI_DONE_INTRS);\n\t\tsc->sc_hcca->hcca_done_head = 0;\n\t\tusb_schedsoftintr(&sc->sc_bus);\n\t\tintrs &= ~OHCI_WDH;\n\t}\n\tif (eintrs & OHCI_RD) {\n\t\tprintf(\"%s: resume detect\\n\", USBDEVNAME(sc->sc_bus.bdev));\n\t\t/* XXX process resume detect */\n\t}\n\tif (eintrs & OHCI_UE) {\n\t\tprintf(\"%s: unrecoverable error, controller halted\\n\",\n\t\t       USBDEVNAME(sc->sc_bus.bdev));\n\t\tOWRITE4(sc, OHCI_CONTROL, OHCI_HCFS_RESET);\n\t\t/* XXX what else */\n\t}\n\tif (eintrs & OHCI_RHSC) {\n\t\tohci_rhsc(sc, sc->sc_intrxfer);\n\t\tintrs &= ~OHCI_RHSC;\n\n\t\t/* \n\t\t * Disable RHSC interrupt for now, because it will be\n\t\t * on until the port has been reset.\n\t\t */\n\t\tohci_rhsc_able(sc, 0);\n\t}\n\n\tsc->sc_bus.intr_context--;\n\n\t/* Block unprocessed interrupts. XXX */\n\tOWRITE4(sc, OHCI_INTERRUPT_DISABLE, intrs);\n\tsc->sc_eintrs &= ~intrs;\n\n\treturn (1);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "ohci_add_done __P((ohci_softc_t *, ohci_physaddr_t));",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "ohci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "ohci_rhsc_able __P((ohci_softc_t *, int));",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
            "Static int",
            "ohci_intr1 __P((ohci_softc_t *));",
            "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_add_done __P((ohci_softc_t *, ohci_physaddr_t));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nohci_rhsc_able __P((ohci_softc_t *, int));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nStatic int;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nStatic int\nohci_intr1(sc)\n\tohci_softc_t *sc;\n{\n\tu_int32_t intrs, eintrs;\n\tohci_physaddr_t done;\n\n\t/* In case the interrupt occurs before initialization has completed. */\n\tif (sc == NULL || sc->sc_hcca == NULL) {\n#ifdef DIAGNOSTIC\n\t\tprintf(\"ohci_intr: sc->sc_hcca == NULL\\n\");\n#endif\n\t\treturn (0);\n\t}\n\n        intrs = 0;\n\tdone = le32toh(sc->sc_hcca->hcca_done_head);\n\tif (done != 0) {\n\t\tif (done & ~OHCI_DONE_INTRS)\n\t\t\tintrs = OHCI_WDH;\n\t\tif (done & OHCI_DONE_INTRS)\n\t\t\tintrs |= OREAD4(sc, OHCI_INTERRUPT_STATUS);\n\t} else\n\t\tintrs = OREAD4(sc, OHCI_INTERRUPT_STATUS);\n\n\tif (!intrs)\n\t\treturn (0);\n\n\tintrs &= ~OHCI_MIE;\n\tOWRITE4(sc, OHCI_INTERRUPT_STATUS, intrs); /* Acknowledge */\n\teintrs = intrs & sc->sc_eintrs;\n\tif (!eintrs)\n\t\treturn (0);\n\n\tsc->sc_bus.intr_context++;\n\tsc->sc_bus.no_intrs++;\n\tDPRINTFN(7, (\"ohci_intr: sc=%p intrs=0x%x(0x%x) eintrs=0x%x\\n\", \n\t\t     sc, (u_int)intrs, OREAD4(sc, OHCI_INTERRUPT_STATUS),\n\t\t     (u_int)eintrs));\n\n\tif (eintrs & OHCI_SO) {\n\t\tprintf(\"%s: scheduling overrun\\n\",USBDEVNAME(sc->sc_bus.bdev));\n\t\t/* XXX do what */\n\t\tintrs &= ~OHCI_SO;\n\t}\n\tif (eintrs & OHCI_WDH) {\n\t\tohci_add_done(sc, done &~ OHCI_DONE_INTRS);\n\t\tsc->sc_hcca->hcca_done_head = 0;\n\t\tusb_schedsoftintr(&sc->sc_bus);\n\t\tintrs &= ~OHCI_WDH;\n\t}\n\tif (eintrs & OHCI_RD) {\n\t\tprintf(\"%s: resume detect\\n\", USBDEVNAME(sc->sc_bus.bdev));\n\t\t/* XXX process resume detect */\n\t}\n\tif (eintrs & OHCI_UE) {\n\t\tprintf(\"%s: unrecoverable error, controller halted\\n\",\n\t\t       USBDEVNAME(sc->sc_bus.bdev));\n\t\tOWRITE4(sc, OHCI_CONTROL, OHCI_HCFS_RESET);\n\t\t/* XXX what else */\n\t}\n\tif (eintrs & OHCI_RHSC) {\n\t\tohci_rhsc(sc, sc->sc_intrxfer);\n\t\tintrs &= ~OHCI_RHSC;\n\n\t\t/* \n\t\t * Disable RHSC interrupt for now, because it will be\n\t\t * on until the port has been reset.\n\t\t */\n\t\tohci_rhsc_able(sc, 0);\n\t}\n\n\tsc->sc_bus.intr_context--;\n\n\t/* Block unprocessed interrupts. XXX */\n\tOWRITE4(sc, OHCI_INTERRUPT_DISABLE, intrs);\n\tsc->sc_eintrs &= ~intrs;\n\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ohci_dumpregs",
          "args": [
            "sc"
          ],
          "line": 1483
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_dumpregs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "981-1019",
          "snippet": "void\nohci_dumpregs(sc)\n\tohci_softc_t *sc;\n{\n\tDPRINTF((\"ohci_dumpregs: rev=0x%08x control=0x%08x command=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_REVISION),\n\t\t OREAD4(sc, OHCI_CONTROL),\n\t\t OREAD4(sc, OHCI_COMMAND_STATUS)));\n\tDPRINTF((\"               intrstat=0x%08x intre=0x%08x intrd=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_INTERRUPT_STATUS),\n\t\t OREAD4(sc, OHCI_INTERRUPT_ENABLE),\n\t\t OREAD4(sc, OHCI_INTERRUPT_DISABLE)));\n\tDPRINTF((\"               hcca=0x%08x percur=0x%08x ctrlhd=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_HCCA),\n\t\t OREAD4(sc, OHCI_PERIOD_CURRENT_ED),\n\t\t OREAD4(sc, OHCI_CONTROL_HEAD_ED)));\n\tDPRINTF((\"               ctrlcur=0x%08x bulkhd=0x%08x bulkcur=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_CONTROL_CURRENT_ED),\n\t\t OREAD4(sc, OHCI_BULK_HEAD_ED),\n\t\t OREAD4(sc, OHCI_BULK_CURRENT_ED)));\n\tDPRINTF((\"               done=0x%08x fmival=0x%08x fmrem=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_DONE_HEAD),\n\t\t OREAD4(sc, OHCI_FM_INTERVAL),\n\t\t OREAD4(sc, OHCI_FM_REMAINING)));\n\tDPRINTF((\"               fmnum=0x%08x perst=0x%08x lsthrs=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_FM_NUMBER),\n\t\t OREAD4(sc, OHCI_PERIODIC_START),\n\t\t OREAD4(sc, OHCI_LS_THRESHOLD)));\n\tDPRINTF((\"               desca=0x%08x descb=0x%08x stat=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_RH_DESCRIPTOR_A),\n\t\t OREAD4(sc, OHCI_RH_DESCRIPTOR_B),\n\t\t OREAD4(sc, OHCI_RH_STATUS)));\n\tDPRINTF((\"               port1=0x%08x port2=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_RH_PORT_STATUS(1)),\n\t\t OREAD4(sc, OHCI_RH_PORT_STATUS(2))));\n\tDPRINTF((\"         HCCA: frame_number=0x%04x done_head=0x%08x\\n\",\n\t\t le32toh(sc->sc_hcca->hcca_frame_number),\n\t\t le32toh(sc->sc_hcca->hcca_done_head)));\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "ohci_rhsc_able __P((ohci_softc_t *, int));",
            "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
            "ohci_intr1 __P((ohci_softc_t *));",
            "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nohci_rhsc_able __P((ohci_softc_t *, int));\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nvoid\nohci_dumpregs(sc)\n\tohci_softc_t *sc;\n{\n\tDPRINTF((\"ohci_dumpregs: rev=0x%08x control=0x%08x command=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_REVISION),\n\t\t OREAD4(sc, OHCI_CONTROL),\n\t\t OREAD4(sc, OHCI_COMMAND_STATUS)));\n\tDPRINTF((\"               intrstat=0x%08x intre=0x%08x intrd=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_INTERRUPT_STATUS),\n\t\t OREAD4(sc, OHCI_INTERRUPT_ENABLE),\n\t\t OREAD4(sc, OHCI_INTERRUPT_DISABLE)));\n\tDPRINTF((\"               hcca=0x%08x percur=0x%08x ctrlhd=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_HCCA),\n\t\t OREAD4(sc, OHCI_PERIOD_CURRENT_ED),\n\t\t OREAD4(sc, OHCI_CONTROL_HEAD_ED)));\n\tDPRINTF((\"               ctrlcur=0x%08x bulkhd=0x%08x bulkcur=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_CONTROL_CURRENT_ED),\n\t\t OREAD4(sc, OHCI_BULK_HEAD_ED),\n\t\t OREAD4(sc, OHCI_BULK_CURRENT_ED)));\n\tDPRINTF((\"               done=0x%08x fmival=0x%08x fmrem=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_DONE_HEAD),\n\t\t OREAD4(sc, OHCI_FM_INTERVAL),\n\t\t OREAD4(sc, OHCI_FM_REMAINING)));\n\tDPRINTF((\"               fmnum=0x%08x perst=0x%08x lsthrs=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_FM_NUMBER),\n\t\t OREAD4(sc, OHCI_PERIODIC_START),\n\t\t OREAD4(sc, OHCI_LS_THRESHOLD)));\n\tDPRINTF((\"               desca=0x%08x descb=0x%08x stat=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_RH_DESCRIPTOR_A),\n\t\t OREAD4(sc, OHCI_RH_DESCRIPTOR_B),\n\t\t OREAD4(sc, OHCI_RH_STATUS)));\n\tDPRINTF((\"               port1=0x%08x port2=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_RH_PORT_STATUS(1)),\n\t\t OREAD4(sc, OHCI_RH_PORT_STATUS(2))));\n\tDPRINTF((\"         HCCA: frame_number=0x%04x done_head=0x%08x\\n\",\n\t\t le32toh(sc->sc_hcca->hcca_frame_number),\n\t\t le32toh(sc->sc_hcca->hcca_done_head)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "15",
            "(\"ohci_waitintr: 0x%04x\\n\", intrs)"
          ],
          "line": 1480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OREAD4",
          "args": [
            "sc",
            "OHCI_INTERRUPT_STATUS"
          ],
          "line": 1479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_delay_ms",
          "args": [
            "&sc->sc_bus",
            "1"
          ],
          "line": 1478
        },
        "resolved": true,
        "details": {
          "function_name": "usb_delay_ms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "301-313",
          "snippet": "void\nusb_delay_ms(bus, ms)\n\tusbd_bus_handle bus;\n\tu_int ms;\n{\n\textern int cold;\n\n\t/* Wait at least two clock ticks so we know the time has passed. */\n\tif (bus->use_polling || cold)\n\t\tdelay((ms+1) * 1000);\n\telse\n\t\ttsleep(&ms, PRIBIO, \"usbdly\", (ms*hz+999)/1000 + 1);\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_getnewaddr __P((usbd_bus_handle bus));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_getnewaddr __P((usbd_bus_handle bus));\n\nvoid\nusb_delay_ms(bus, ms)\n\tusbd_bus_handle bus;\n\tu_int ms;\n{\n\textern int cold;\n\n\t/* Wait at least two clock ticks so we know the time has passed. */\n\tif (bus->use_polling || cold)\n\t\tdelay((ms+1) * 1000);\n\telse\n\t\ttsleep(&ms, PRIBIO, \"usbdly\", (ms*hz+999)/1000 + 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));\nohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));\nohci_device_request __P((usbd_xfer_handle xfer));\nohci_device_isoc_enter __P((usbd_xfer_handle));\nohci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));\nStatic usbd_xfer_handle;\nohci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nohci_root_ctrl_transfer __P((usbd_xfer_handle));\nohci_root_ctrl_start __P((usbd_xfer_handle));\nohci_root_ctrl_abort __P((usbd_xfer_handle));\nohci_root_ctrl_done  __P((usbd_xfer_handle));\nohci_root_intr_transfer __P((usbd_xfer_handle));\nohci_root_intr_start __P((usbd_xfer_handle));\nohci_root_intr_abort __P((usbd_xfer_handle));\nohci_root_intr_done  __P((usbd_xfer_handle));\nohci_device_ctrl_transfer __P((usbd_xfer_handle));\nohci_device_ctrl_start __P((usbd_xfer_handle));\nohci_device_ctrl_abort __P((usbd_xfer_handle));\nohci_device_ctrl_done  __P((usbd_xfer_handle));\nohci_device_bulk_transfer __P((usbd_xfer_handle));\nohci_device_bulk_start __P((usbd_xfer_handle));\nohci_device_bulk_abort __P((usbd_xfer_handle));\nohci_device_bulk_done  __P((usbd_xfer_handle));\nohci_device_intr_transfer __P((usbd_xfer_handle));\nohci_device_intr_start __P((usbd_xfer_handle));\nohci_device_intr_abort __P((usbd_xfer_handle));\nohci_device_intr_done  __P((usbd_xfer_handle));\nohci_device_isoc_transfer __P((usbd_xfer_handle));\nohci_device_isoc_start __P((usbd_xfer_handle));\nohci_device_isoc_abort __P((usbd_xfer_handle));\nohci_device_isoc_done  __P((usbd_xfer_handle));\nohci_rhsc_able __P((ohci_softc_t *, int));\nohci_abort_xfer __P((usbd_xfer_handle xfer,\n\t\t\t    usbd_status status));\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nvoid\nohci_waitintr(sc, xfer)\n\tohci_softc_t *sc;\n\tusbd_xfer_handle xfer;\n{\n\tint timo = xfer->timeout;\n\tint usecs;\n\tu_int32_t intrs;\n\n\txfer->status = USBD_IN_PROGRESS;\n\tfor (usecs = timo * 1000000 / hz; usecs > 0; usecs -= 1000) {\n\t\tusb_delay_ms(&sc->sc_bus, 1);\n\t\tintrs = OREAD4(sc, OHCI_INTERRUPT_STATUS) & sc->sc_eintrs;\n\t\tDPRINTFN(15,(\"ohci_waitintr: 0x%04x\\n\", intrs));\n#ifdef OHCI_DEBUG\n\t\tif (ohcidebug > 15)\n\t\t\tohci_dumpregs(sc);\n#endif\n\t\tif (intrs) {\n\t\t\tohci_intr1(sc);\n\t\t\tif (xfer->status != USBD_IN_PROGRESS)\n\t\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Timeout */\n\tDPRINTF((\"ohci_waitintr: timeout\\n\"));\n\txfer->status = USBD_TIMEOUT;\n\tusb_transfer_complete(xfer);\n\t/* XXX should free TD */\n}"
  },
  {
    "function_name": "ohci_root_ctrl_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "1455-1460",
    "snippet": "void\nohci_root_ctrl_done(xfer)\n\tusbd_xfer_handle xfer;\n{\n\txfer->hcpriv = NULL;\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "ohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));",
      "ohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));",
      "ohci_device_request __P((usbd_xfer_handle xfer));",
      "ohci_device_isoc_enter __P((usbd_xfer_handle));",
      "Static usbd_xfer_handle",
      "ohci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "ohci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "ohci_root_ctrl_start __P((usbd_xfer_handle));",
      "ohci_root_ctrl_abort __P((usbd_xfer_handle));",
      "ohci_root_ctrl_done  __P((usbd_xfer_handle));",
      "ohci_root_intr_transfer __P((usbd_xfer_handle));",
      "ohci_root_intr_start __P((usbd_xfer_handle));",
      "ohci_root_intr_abort __P((usbd_xfer_handle));",
      "ohci_root_intr_done  __P((usbd_xfer_handle));",
      "ohci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "ohci_device_ctrl_start __P((usbd_xfer_handle));",
      "ohci_device_ctrl_abort __P((usbd_xfer_handle));",
      "ohci_device_ctrl_done  __P((usbd_xfer_handle));",
      "ohci_device_bulk_transfer __P((usbd_xfer_handle));",
      "ohci_device_bulk_start __P((usbd_xfer_handle));",
      "ohci_device_bulk_abort __P((usbd_xfer_handle));",
      "ohci_device_bulk_done  __P((usbd_xfer_handle));",
      "ohci_device_intr_transfer __P((usbd_xfer_handle));",
      "ohci_device_intr_start __P((usbd_xfer_handle));",
      "ohci_device_intr_abort __P((usbd_xfer_handle));",
      "ohci_device_intr_done  __P((usbd_xfer_handle));",
      "ohci_device_isoc_transfer __P((usbd_xfer_handle));",
      "ohci_device_isoc_start __P((usbd_xfer_handle));",
      "ohci_device_isoc_abort __P((usbd_xfer_handle));",
      "ohci_device_isoc_done  __P((usbd_xfer_handle));"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));\nohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));\nohci_device_request __P((usbd_xfer_handle xfer));\nohci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_xfer_handle;\nohci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nohci_root_ctrl_transfer __P((usbd_xfer_handle));\nohci_root_ctrl_start __P((usbd_xfer_handle));\nohci_root_ctrl_abort __P((usbd_xfer_handle));\nohci_root_ctrl_done  __P((usbd_xfer_handle));\nohci_root_intr_transfer __P((usbd_xfer_handle));\nohci_root_intr_start __P((usbd_xfer_handle));\nohci_root_intr_abort __P((usbd_xfer_handle));\nohci_root_intr_done  __P((usbd_xfer_handle));\nohci_device_ctrl_transfer __P((usbd_xfer_handle));\nohci_device_ctrl_start __P((usbd_xfer_handle));\nohci_device_ctrl_abort __P((usbd_xfer_handle));\nohci_device_ctrl_done  __P((usbd_xfer_handle));\nohci_device_bulk_transfer __P((usbd_xfer_handle));\nohci_device_bulk_start __P((usbd_xfer_handle));\nohci_device_bulk_abort __P((usbd_xfer_handle));\nohci_device_bulk_done  __P((usbd_xfer_handle));\nohci_device_intr_transfer __P((usbd_xfer_handle));\nohci_device_intr_start __P((usbd_xfer_handle));\nohci_device_intr_abort __P((usbd_xfer_handle));\nohci_device_intr_done  __P((usbd_xfer_handle));\nohci_device_isoc_transfer __P((usbd_xfer_handle));\nohci_device_isoc_start __P((usbd_xfer_handle));\nohci_device_isoc_abort __P((usbd_xfer_handle));\nohci_device_isoc_done  __P((usbd_xfer_handle));\n\nvoid\nohci_root_ctrl_done(xfer)\n\tusbd_xfer_handle xfer;\n{\n\txfer->hcpriv = NULL;\n}"
  },
  {
    "function_name": "ohci_root_intr_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "1448-1453",
    "snippet": "void\nohci_root_intr_done(xfer)\n\tusbd_xfer_handle xfer;\n{\n\txfer->hcpriv = NULL;\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "ohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));",
      "ohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));",
      "ohci_device_request __P((usbd_xfer_handle xfer));",
      "ohci_device_isoc_enter __P((usbd_xfer_handle));",
      "Static usbd_xfer_handle",
      "ohci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "ohci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "ohci_root_ctrl_start __P((usbd_xfer_handle));",
      "ohci_root_ctrl_abort __P((usbd_xfer_handle));",
      "ohci_root_ctrl_done  __P((usbd_xfer_handle));",
      "ohci_root_intr_transfer __P((usbd_xfer_handle));",
      "ohci_root_intr_start __P((usbd_xfer_handle));",
      "ohci_root_intr_abort __P((usbd_xfer_handle));",
      "ohci_root_intr_done  __P((usbd_xfer_handle));",
      "ohci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "ohci_device_ctrl_start __P((usbd_xfer_handle));",
      "ohci_device_ctrl_abort __P((usbd_xfer_handle));",
      "ohci_device_ctrl_done  __P((usbd_xfer_handle));",
      "ohci_device_bulk_transfer __P((usbd_xfer_handle));",
      "ohci_device_bulk_start __P((usbd_xfer_handle));",
      "ohci_device_bulk_abort __P((usbd_xfer_handle));",
      "ohci_device_bulk_done  __P((usbd_xfer_handle));",
      "ohci_device_intr_transfer __P((usbd_xfer_handle));",
      "ohci_device_intr_start __P((usbd_xfer_handle));",
      "ohci_device_intr_abort __P((usbd_xfer_handle));",
      "ohci_device_intr_done  __P((usbd_xfer_handle));",
      "ohci_device_isoc_transfer __P((usbd_xfer_handle));",
      "ohci_device_isoc_start __P((usbd_xfer_handle));",
      "ohci_device_isoc_abort __P((usbd_xfer_handle));",
      "ohci_device_isoc_done  __P((usbd_xfer_handle));"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));\nohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));\nohci_device_request __P((usbd_xfer_handle xfer));\nohci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_xfer_handle;\nohci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nohci_root_ctrl_transfer __P((usbd_xfer_handle));\nohci_root_ctrl_start __P((usbd_xfer_handle));\nohci_root_ctrl_abort __P((usbd_xfer_handle));\nohci_root_ctrl_done  __P((usbd_xfer_handle));\nohci_root_intr_transfer __P((usbd_xfer_handle));\nohci_root_intr_start __P((usbd_xfer_handle));\nohci_root_intr_abort __P((usbd_xfer_handle));\nohci_root_intr_done  __P((usbd_xfer_handle));\nohci_device_ctrl_transfer __P((usbd_xfer_handle));\nohci_device_ctrl_start __P((usbd_xfer_handle));\nohci_device_ctrl_abort __P((usbd_xfer_handle));\nohci_device_ctrl_done  __P((usbd_xfer_handle));\nohci_device_bulk_transfer __P((usbd_xfer_handle));\nohci_device_bulk_start __P((usbd_xfer_handle));\nohci_device_bulk_abort __P((usbd_xfer_handle));\nohci_device_bulk_done  __P((usbd_xfer_handle));\nohci_device_intr_transfer __P((usbd_xfer_handle));\nohci_device_intr_start __P((usbd_xfer_handle));\nohci_device_intr_abort __P((usbd_xfer_handle));\nohci_device_intr_done  __P((usbd_xfer_handle));\nohci_device_isoc_transfer __P((usbd_xfer_handle));\nohci_device_isoc_start __P((usbd_xfer_handle));\nohci_device_isoc_abort __P((usbd_xfer_handle));\nohci_device_isoc_done  __P((usbd_xfer_handle));\n\nvoid\nohci_root_intr_done(xfer)\n\tusbd_xfer_handle xfer;\n{\n\txfer->hcpriv = NULL;\n}"
  },
  {
    "function_name": "ohci_rhsc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "1411-1446",
    "snippet": "void\nohci_rhsc(sc, xfer)\n\tohci_softc_t *sc;\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe;\n\tstruct ohci_pipe *opipe;\n\tu_char *p;\n\tint i, m;\n\tint hstatus;\n\n\thstatus = OREAD4(sc, OHCI_RH_STATUS);\n\tDPRINTF((\"ohci_rhsc: sc=%p xfer=%p hstatus=0x%08x\\n\", \n\t\t sc, xfer, hstatus));\n\n\tif (xfer == NULL) {\n\t\t/* Just ignore the change. */\n\t\treturn;\n\t}\n\n\tpipe = xfer->pipe;\n\topipe = (struct ohci_pipe *)pipe;\n\n\tp = KERNADDR(&xfer->dmabuf);\n\tm = min(sc->sc_noport, xfer->length * 8 - 1);\n\tmemset(p, 0, xfer->length);\n\tfor (i = 1; i <= m; i++) {\n\t\tif (OREAD4(sc, OHCI_RH_PORT_STATUS(i)) >> 16)\n\t\t\tp[i/8] |= 1 << (i%8);\n\t}\n\tDPRINTF((\"ohci_rhsc: change=0x%02x\\n\", *p));\n\txfer->actlen = xfer->length;\n\txfer->status = USBD_NORMAL_COMPLETION;\n\n\tusb_transfer_complete(xfer);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "ohci_open __P((usbd_pipe_handle));",
      "ohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));",
      "ohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));",
      "ohci_device_request __P((usbd_xfer_handle xfer));",
      "ohci_setup_isoc __P((usbd_pipe_handle pipe));",
      "ohci_device_isoc_enter __P((usbd_xfer_handle));",
      "Static usbd_xfer_handle",
      "ohci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "ohci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "ohci_root_ctrl_start __P((usbd_xfer_handle));",
      "ohci_root_ctrl_abort __P((usbd_xfer_handle));",
      "ohci_root_ctrl_close __P((usbd_pipe_handle));",
      "ohci_root_ctrl_done  __P((usbd_xfer_handle));",
      "ohci_root_intr_transfer __P((usbd_xfer_handle));",
      "ohci_root_intr_start __P((usbd_xfer_handle));",
      "ohci_root_intr_abort __P((usbd_xfer_handle));",
      "ohci_root_intr_close __P((usbd_pipe_handle));",
      "ohci_root_intr_done  __P((usbd_xfer_handle));",
      "ohci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "ohci_device_ctrl_start __P((usbd_xfer_handle));",
      "ohci_device_ctrl_abort __P((usbd_xfer_handle));",
      "ohci_device_ctrl_close __P((usbd_pipe_handle));",
      "ohci_device_ctrl_done  __P((usbd_xfer_handle));",
      "ohci_device_bulk_transfer __P((usbd_xfer_handle));",
      "ohci_device_bulk_start __P((usbd_xfer_handle));",
      "ohci_device_bulk_abort __P((usbd_xfer_handle));",
      "ohci_device_bulk_close __P((usbd_pipe_handle));",
      "ohci_device_bulk_done  __P((usbd_xfer_handle));",
      "ohci_device_intr_transfer __P((usbd_xfer_handle));",
      "ohci_device_intr_start __P((usbd_xfer_handle));",
      "ohci_device_intr_abort __P((usbd_xfer_handle));",
      "ohci_device_intr_close __P((usbd_pipe_handle));",
      "ohci_device_intr_done  __P((usbd_xfer_handle));",
      "ohci_device_isoc_transfer __P((usbd_xfer_handle));",
      "ohci_device_isoc_start __P((usbd_xfer_handle));",
      "ohci_device_isoc_abort __P((usbd_xfer_handle));",
      "ohci_device_isoc_close __P((usbd_pipe_handle));",
      "ohci_device_isoc_done  __P((usbd_xfer_handle));",
      "ohci_rhsc_able __P((ohci_softc_t *, int));",
      "ohci_abort_xfer __P((usbd_xfer_handle xfer,\n\t\t\t    usbd_status status));",
      "ohci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "ohci_noop __P((usbd_pipe_handle pipe));",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
      "ohci_intr1 __P((ohci_softc_t *));",
      "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usb_transfer_complete",
          "args": [
            "xfer"
          ],
          "line": 1445
        },
        "resolved": true,
        "details": {
          "function_name": "usb_transfer_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "789-883",
          "snippet": "void\nusb_transfer_complete(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tint repeat = pipe->repeat;\n\tint polling;\n\n\tSPLUSBCHECK;\n\n\tDPRINTFN(5, (\"usb_transfer_complete: pipe=%p xfer=%p status=%d \"\n\t\t     \"actlen=%d\\n\", pipe, xfer, xfer->status, xfer->actlen));\n\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_transfer_cb: pipe==0, xfer=%p\\n\", xfer);\n\t\treturn;\n\t}\n#endif\n\tpolling = pipe->device->bus->use_polling;\n\t/* XXXX */\n\tif (polling)\n\t\tpipe->running = 0;\n\n\tif (!(xfer->flags & USBD_NO_COPY) && xfer->actlen != 0 &&\n\t    usbd_xfer_isread(xfer)) {\n#ifdef DIAGNOSTIC\n\t\tif (xfer->actlen > xfer->length) {\n\t\t\tprintf(\"usb_transfer_complete: actlen > len %d > %d\\n\",\n\t\t\t       xfer->actlen, xfer->length);\n\t\t\txfer->actlen = xfer->length;\n\t\t}\n#endif\n\t\tmemcpy(xfer->buffer, KERNADDR(dmap), xfer->actlen);\n\t}\n\n\t/* if we allocated the buffer in usbd_transfer() we free it here. */\n\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\tif (!repeat) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\t\t\tbus->methods->freem(bus, dmap);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!repeat) {\n\t\t/* Remove request from queue. */\n#ifdef DIAGNOSTIC\n\t\tif (xfer != SIMPLEQ_FIRST(&pipe->queue))\n\t\t\tprintf(\"usb_transfer_complete: bad dequeue %p != %p\\n\",\n\t\t\t       xfer, SIMPLEQ_FIRST(&pipe->queue));\n#endif\n\t\tSIMPLEQ_REMOVE_HEAD(&pipe->queue, xfer, next);\n\t}\n\tDPRINTFN(5,(\"usb_transfer_complete: repeat=%d new head=%p\\n\", \n\t\t    repeat, SIMPLEQ_FIRST(&pipe->queue)));\n\n\t/* Count completed transfers. */\n\t++pipe->device->bus->stats.requests\n\t\t[pipe->endpoint->edesc->bmAttributes & UE_XFERTYPE];\n\n\txfer->done = 1;\n\tif (!xfer->status && xfer->actlen < xfer->length &&\n\t    !(xfer->flags & USBD_SHORT_XFER_OK)) {\n\t\tDPRINTFN(-1,(\"usbd_transfer_cb: short transfer %d<%d\\n\",\n\t\t\t     xfer->actlen, xfer->length));\n\t\txfer->status = USBD_SHORT_XFER;\n\t}\n\n\tif (xfer->callback)\n\t\txfer->callback(xfer, xfer->priv, xfer->status);\n\n#ifdef DIAGNOSTIC\n\tif (pipe->methods->done != NULL)\n\t\tpipe->methods->done(xfer);\n\telse\n\t\tprintf(\"usb_transfer_complete: pipe->methods->done == NULL\\n\");\n#else\n\tpipe->methods->done(xfer);\n#endif\n\n\tif ((xfer->flags & USBD_SYNCHRONOUS) && !polling)\n\t\twakeup(xfer);\n\n\tif (!repeat) {\n\t\t/* XXX should we stop the queue on all errors? */\n\t\tif ((xfer->status == USBD_CANCELLED ||\n\t\t     xfer->status == USBD_TIMEOUT) &&\n\t\t    pipe->iface != NULL)\t\t/* not control pipe */\n\t\t\tpipe->running = 0;\n\t\telse\n\t\t\tusbd_start_next(pipe);\n\t}\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "usb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;",
            "usb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);",
            "usb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_start_next __P((usbd_pipe_handle pipe));\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nusb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;\nusb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\nusb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;\n\nvoid\nusb_transfer_complete(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tint repeat = pipe->repeat;\n\tint polling;\n\n\tSPLUSBCHECK;\n\n\tDPRINTFN(5, (\"usb_transfer_complete: pipe=%p xfer=%p status=%d \"\n\t\t     \"actlen=%d\\n\", pipe, xfer, xfer->status, xfer->actlen));\n\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_transfer_cb: pipe==0, xfer=%p\\n\", xfer);\n\t\treturn;\n\t}\n#endif\n\tpolling = pipe->device->bus->use_polling;\n\t/* XXXX */\n\tif (polling)\n\t\tpipe->running = 0;\n\n\tif (!(xfer->flags & USBD_NO_COPY) && xfer->actlen != 0 &&\n\t    usbd_xfer_isread(xfer)) {\n#ifdef DIAGNOSTIC\n\t\tif (xfer->actlen > xfer->length) {\n\t\t\tprintf(\"usb_transfer_complete: actlen > len %d > %d\\n\",\n\t\t\t       xfer->actlen, xfer->length);\n\t\t\txfer->actlen = xfer->length;\n\t\t}\n#endif\n\t\tmemcpy(xfer->buffer, KERNADDR(dmap), xfer->actlen);\n\t}\n\n\t/* if we allocated the buffer in usbd_transfer() we free it here. */\n\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\tif (!repeat) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\t\t\tbus->methods->freem(bus, dmap);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!repeat) {\n\t\t/* Remove request from queue. */\n#ifdef DIAGNOSTIC\n\t\tif (xfer != SIMPLEQ_FIRST(&pipe->queue))\n\t\t\tprintf(\"usb_transfer_complete: bad dequeue %p != %p\\n\",\n\t\t\t       xfer, SIMPLEQ_FIRST(&pipe->queue));\n#endif\n\t\tSIMPLEQ_REMOVE_HEAD(&pipe->queue, xfer, next);\n\t}\n\tDPRINTFN(5,(\"usb_transfer_complete: repeat=%d new head=%p\\n\", \n\t\t    repeat, SIMPLEQ_FIRST(&pipe->queue)));\n\n\t/* Count completed transfers. */\n\t++pipe->device->bus->stats.requests\n\t\t[pipe->endpoint->edesc->bmAttributes & UE_XFERTYPE];\n\n\txfer->done = 1;\n\tif (!xfer->status && xfer->actlen < xfer->length &&\n\t    !(xfer->flags & USBD_SHORT_XFER_OK)) {\n\t\tDPRINTFN(-1,(\"usbd_transfer_cb: short transfer %d<%d\\n\",\n\t\t\t     xfer->actlen, xfer->length));\n\t\txfer->status = USBD_SHORT_XFER;\n\t}\n\n\tif (xfer->callback)\n\t\txfer->callback(xfer, xfer->priv, xfer->status);\n\n#ifdef DIAGNOSTIC\n\tif (pipe->methods->done != NULL)\n\t\tpipe->methods->done(xfer);\n\telse\n\t\tprintf(\"usb_transfer_complete: pipe->methods->done == NULL\\n\");\n#else\n\tpipe->methods->done(xfer);\n#endif\n\n\tif ((xfer->flags & USBD_SYNCHRONOUS) && !polling)\n\t\twakeup(xfer);\n\n\tif (!repeat) {\n\t\t/* XXX should we stop the queue on all errors? */\n\t\tif ((xfer->status == USBD_CANCELLED ||\n\t\t     xfer->status == USBD_TIMEOUT) &&\n\t\t    pipe->iface != NULL)\t\t/* not control pipe */\n\t\t\tpipe->running = 0;\n\t\telse\n\t\t\tusbd_start_next(pipe);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ohci_rhsc: change=0x%02x\\n\", *p)"
          ],
          "line": 1441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OREAD4",
          "args": [
            "sc",
            "OHCI_RH_PORT_STATUS(i)"
          ],
          "line": 1438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OHCI_RH_PORT_STATUS",
          "args": [
            "i"
          ],
          "line": 1438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "p",
            "0",
            "xfer->length"
          ],
          "line": 1436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "sc->sc_noport",
            "xfer->length * 8 - 1"
          ],
          "line": 1435
        },
        "resolved": true,
        "details": {
          "function_name": "umass_scsipi_minphys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
          "lines": "3240-3247",
          "snippet": "Static void\numass_scsipi_minphys(bp)\n\tstruct buf *bp;\n{\n\tif (bp->b_bcount > UMASS_MAX_TRANSFER_SIZE)\n\t\tbp->b_bcount = UMASS_MAX_TRANSFER_SIZE;\n\tminphys(bp);\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/ata/atavar.h>\t/* XXX */",
            "#include <dev/scsipi/scsi_changer.h>",
            "#include <dev/scsipi/scsi_disk.h>",
            "#include <dev/scsipi/scsipi_disk.h>",
            "#include <dev/scsipi/atapiconf.h>",
            "#include <dev/scsipi/scsiconf.h>",
            "#include <dev/scsipi/scsipi_all.h>",
            "#include <dev/scsipi/scsi_all.h>",
            "#include <sys/scsiio.h>",
            "#include <cam/cam_periph.h>",
            "#include <sys/devicestat.h>",
            "#include <cam/scsi/scsi_da.h>",
            "#include <cam/scsi/scsi_all.h>",
            "#include <cam/cam_xpt_sim.h>",
            "#include <cam/cam_sim.h>",
            "#include <cam/cam_ccb.h>",
            "#include <cam/cam.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/clock.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/malloc.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"atapibus.h\""
          ],
          "macros_used": [
            "#define UMASS_MAX_TRANSFER_SIZE\tMAXBSIZE",
            "#define UMASS_MAX_TRANSFER_SIZE\t\t65536"
          ],
          "globals_used": [
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "Static void"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define UMASS_MAX_TRANSFER_SIZE\tMAXBSIZE\n#define UMASS_MAX_TRANSFER_SIZE\t\t65536\n\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\n\nStatic void\numass_scsipi_minphys(bp)\n\tstruct buf *bp;\n{\n\tif (bp->b_bcount > UMASS_MAX_TRANSFER_SIZE)\n\t\tbp->b_bcount = UMASS_MAX_TRANSFER_SIZE;\n\tminphys(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KERNADDR",
          "args": [
            "&xfer->dmabuf"
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ohci_rhsc: sc=%p xfer=%p hstatus=0x%08x\\n\", \n\t\t sc, xfer, hstatus)"
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OREAD4",
          "args": [
            "sc",
            "OHCI_RH_STATUS"
          ],
          "line": 1422
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nohci_open __P((usbd_pipe_handle));\nohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));\nohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));\nohci_device_request __P((usbd_xfer_handle xfer));\nohci_setup_isoc __P((usbd_pipe_handle pipe));\nohci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_xfer_handle;\nohci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nohci_root_ctrl_transfer __P((usbd_xfer_handle));\nohci_root_ctrl_start __P((usbd_xfer_handle));\nohci_root_ctrl_abort __P((usbd_xfer_handle));\nohci_root_ctrl_close __P((usbd_pipe_handle));\nohci_root_ctrl_done  __P((usbd_xfer_handle));\nohci_root_intr_transfer __P((usbd_xfer_handle));\nohci_root_intr_start __P((usbd_xfer_handle));\nohci_root_intr_abort __P((usbd_xfer_handle));\nohci_root_intr_close __P((usbd_pipe_handle));\nohci_root_intr_done  __P((usbd_xfer_handle));\nohci_device_ctrl_transfer __P((usbd_xfer_handle));\nohci_device_ctrl_start __P((usbd_xfer_handle));\nohci_device_ctrl_abort __P((usbd_xfer_handle));\nohci_device_ctrl_close __P((usbd_pipe_handle));\nohci_device_ctrl_done  __P((usbd_xfer_handle));\nohci_device_bulk_transfer __P((usbd_xfer_handle));\nohci_device_bulk_start __P((usbd_xfer_handle));\nohci_device_bulk_abort __P((usbd_xfer_handle));\nohci_device_bulk_close __P((usbd_pipe_handle));\nohci_device_bulk_done  __P((usbd_xfer_handle));\nohci_device_intr_transfer __P((usbd_xfer_handle));\nohci_device_intr_start __P((usbd_xfer_handle));\nohci_device_intr_abort __P((usbd_xfer_handle));\nohci_device_intr_close __P((usbd_pipe_handle));\nohci_device_intr_done  __P((usbd_xfer_handle));\nohci_device_isoc_transfer __P((usbd_xfer_handle));\nohci_device_isoc_start __P((usbd_xfer_handle));\nohci_device_isoc_abort __P((usbd_xfer_handle));\nohci_device_isoc_close __P((usbd_pipe_handle));\nohci_device_isoc_done  __P((usbd_xfer_handle));\nohci_rhsc_able __P((ohci_softc_t *, int));\nohci_abort_xfer __P((usbd_xfer_handle xfer,\n\t\t\t    usbd_status status));\nohci_device_clear_toggle __P((usbd_pipe_handle pipe));\nohci_noop __P((usbd_pipe_handle pipe));\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nvoid\nohci_rhsc(sc, xfer)\n\tohci_softc_t *sc;\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe;\n\tstruct ohci_pipe *opipe;\n\tu_char *p;\n\tint i, m;\n\tint hstatus;\n\n\thstatus = OREAD4(sc, OHCI_RH_STATUS);\n\tDPRINTF((\"ohci_rhsc: sc=%p xfer=%p hstatus=0x%08x\\n\", \n\t\t sc, xfer, hstatus));\n\n\tif (xfer == NULL) {\n\t\t/* Just ignore the change. */\n\t\treturn;\n\t}\n\n\tpipe = xfer->pipe;\n\topipe = (struct ohci_pipe *)pipe;\n\n\tp = KERNADDR(&xfer->dmabuf);\n\tm = min(sc->sc_noport, xfer->length * 8 - 1);\n\tmemset(p, 0, xfer->length);\n\tfor (i = 1; i <= m; i++) {\n\t\tif (OREAD4(sc, OHCI_RH_PORT_STATUS(i)) >> 16)\n\t\t\tp[i/8] |= 1 << (i%8);\n\t}\n\tDPRINTF((\"ohci_rhsc: change=0x%02x\\n\", *p));\n\txfer->actlen = xfer->length;\n\txfer->status = USBD_NORMAL_COMPLETION;\n\n\tusb_transfer_complete(xfer);\n}"
  },
  {
    "function_name": "ohci_device_bulk_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "1401-1409",
    "snippet": "void\nohci_device_bulk_done(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tDPRINTFN(10,(\"ohci_bulk_done: xfer=%p, actlen=%d\\n\", \n\t\t     xfer, xfer->actlen));\n\n\txfer->hcpriv = NULL;\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "ohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));",
      "ohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));",
      "ohci_device_request __P((usbd_xfer_handle xfer));",
      "ohci_device_isoc_enter __P((usbd_xfer_handle));",
      "Static usbd_xfer_handle",
      "ohci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "ohci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "ohci_root_ctrl_start __P((usbd_xfer_handle));",
      "ohci_root_ctrl_abort __P((usbd_xfer_handle));",
      "ohci_root_ctrl_done  __P((usbd_xfer_handle));",
      "ohci_root_intr_transfer __P((usbd_xfer_handle));",
      "ohci_root_intr_start __P((usbd_xfer_handle));",
      "ohci_root_intr_abort __P((usbd_xfer_handle));",
      "ohci_root_intr_done  __P((usbd_xfer_handle));",
      "ohci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "ohci_device_ctrl_start __P((usbd_xfer_handle));",
      "ohci_device_ctrl_abort __P((usbd_xfer_handle));",
      "ohci_device_ctrl_done  __P((usbd_xfer_handle));",
      "ohci_device_bulk_transfer __P((usbd_xfer_handle));",
      "ohci_device_bulk_start __P((usbd_xfer_handle));",
      "ohci_device_bulk_abort __P((usbd_xfer_handle));",
      "ohci_device_bulk_done  __P((usbd_xfer_handle));",
      "ohci_device_intr_transfer __P((usbd_xfer_handle));",
      "ohci_device_intr_start __P((usbd_xfer_handle));",
      "ohci_device_intr_abort __P((usbd_xfer_handle));",
      "ohci_device_intr_done  __P((usbd_xfer_handle));",
      "ohci_device_isoc_transfer __P((usbd_xfer_handle));",
      "ohci_device_isoc_start __P((usbd_xfer_handle));",
      "ohci_device_isoc_abort __P((usbd_xfer_handle));",
      "ohci_device_isoc_done  __P((usbd_xfer_handle));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "10",
            "(\"ohci_bulk_done: xfer=%p, actlen=%d\\n\", \n\t\t     xfer, xfer->actlen)"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));\nohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));\nohci_device_request __P((usbd_xfer_handle xfer));\nohci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_xfer_handle;\nohci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nohci_root_ctrl_transfer __P((usbd_xfer_handle));\nohci_root_ctrl_start __P((usbd_xfer_handle));\nohci_root_ctrl_abort __P((usbd_xfer_handle));\nohci_root_ctrl_done  __P((usbd_xfer_handle));\nohci_root_intr_transfer __P((usbd_xfer_handle));\nohci_root_intr_start __P((usbd_xfer_handle));\nohci_root_intr_abort __P((usbd_xfer_handle));\nohci_root_intr_done  __P((usbd_xfer_handle));\nohci_device_ctrl_transfer __P((usbd_xfer_handle));\nohci_device_ctrl_start __P((usbd_xfer_handle));\nohci_device_ctrl_abort __P((usbd_xfer_handle));\nohci_device_ctrl_done  __P((usbd_xfer_handle));\nohci_device_bulk_transfer __P((usbd_xfer_handle));\nohci_device_bulk_start __P((usbd_xfer_handle));\nohci_device_bulk_abort __P((usbd_xfer_handle));\nohci_device_bulk_done  __P((usbd_xfer_handle));\nohci_device_intr_transfer __P((usbd_xfer_handle));\nohci_device_intr_start __P((usbd_xfer_handle));\nohci_device_intr_abort __P((usbd_xfer_handle));\nohci_device_intr_done  __P((usbd_xfer_handle));\nohci_device_isoc_transfer __P((usbd_xfer_handle));\nohci_device_isoc_start __P((usbd_xfer_handle));\nohci_device_isoc_abort __P((usbd_xfer_handle));\nohci_device_isoc_done  __P((usbd_xfer_handle));\n\nvoid\nohci_device_bulk_done(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tDPRINTFN(10,(\"ohci_bulk_done: xfer=%p, actlen=%d\\n\", \n\t\t     xfer, xfer->actlen));\n\n\txfer->hcpriv = NULL;\n}"
  },
  {
    "function_name": "ohci_device_intr_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "1356-1399",
    "snippet": "void\nohci_device_intr_done(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tstruct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;\n\tohci_softc_t *sc = (ohci_softc_t *)opipe->pipe.device->bus;\n\tohci_soft_ed_t *sed = opipe->sed;\n\tohci_soft_td_t *data, *tail;\n\n\n\tDPRINTFN(10,(\"ohci_intr_done: xfer=%p, actlen=%d\\n\", \n\t\t     xfer, xfer->actlen));\n\n\txfer->hcpriv = NULL;\n\n\tif (xfer->pipe->repeat) {\n\t\tdata = opipe->tail.td;\n\t\ttail = ohci_alloc_std(sc); /* XXX should reuse TD */\n\t\tif (tail == NULL) {\n\t\t\txfer->status = USBD_NOMEM;\n\t\t\treturn;\n\t\t}\n\t\ttail->xfer = NULL;\n\t\t\n\t\tdata->td.td_flags = htole32(\n\t\t\tOHCI_TD_IN | OHCI_TD_NOCC | \n\t\t\tOHCI_TD_SET_DI(1) | OHCI_TD_TOGGLE_CARRY);\n\t\tif (xfer->flags & USBD_SHORT_XFER_OK)\n\t\t\tdata->td.td_flags |= htole32(OHCI_TD_R);\n\t\tdata->td.td_cbp = htole32(DMAADDR(&xfer->dmabuf));\n\t\tdata->nexttd = tail;\n\t\tdata->td.td_nexttd = htole32(tail->physaddr);\n\t\tdata->td.td_be = htole32(le32toh(data->td.td_cbp) +\n\t\t\txfer->length - 1);\n\t\tdata->len = xfer->length;\n\t\tdata->xfer = xfer;\n\t\tdata->flags = OHCI_CALL_DONE | OHCI_ADD_LEN;\n\t\txfer->hcpriv = data;\n\t\txfer->actlen = 0;\n\n\t\tsed->ed.ed_tailp = htole32(tail->physaddr);\n\t\topipe->tail.td = tail;\n\t}\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static ohci_soft_ed_t",
      "ohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));",
      "Static ohci_soft_td_t",
      "ohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));",
      "ohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));",
      "ohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));",
      "ohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));",
      "ohci_device_request __P((usbd_xfer_handle xfer));",
      "ohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
      "ohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
      "ohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));",
      "ohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));",
      "Static ohci_soft_td_t",
      "ohci_setup_isoc __P((usbd_pipe_handle pipe));",
      "ohci_device_isoc_enter __P((usbd_xfer_handle));",
      "Static usbd_xfer_handle",
      "ohci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "ohci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "ohci_root_ctrl_start __P((usbd_xfer_handle));",
      "ohci_root_ctrl_abort __P((usbd_xfer_handle));",
      "ohci_root_ctrl_done  __P((usbd_xfer_handle));",
      "ohci_root_intr_transfer __P((usbd_xfer_handle));",
      "ohci_root_intr_start __P((usbd_xfer_handle));",
      "ohci_root_intr_abort __P((usbd_xfer_handle));",
      "ohci_root_intr_done  __P((usbd_xfer_handle));",
      "ohci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "ohci_device_ctrl_start __P((usbd_xfer_handle));",
      "ohci_device_ctrl_abort __P((usbd_xfer_handle));",
      "ohci_device_ctrl_done  __P((usbd_xfer_handle));",
      "ohci_device_bulk_transfer __P((usbd_xfer_handle));",
      "ohci_device_bulk_start __P((usbd_xfer_handle));",
      "ohci_device_bulk_abort __P((usbd_xfer_handle));",
      "ohci_device_bulk_done  __P((usbd_xfer_handle));",
      "ohci_device_intr_transfer __P((usbd_xfer_handle));",
      "ohci_device_intr_start __P((usbd_xfer_handle));",
      "ohci_device_intr_abort __P((usbd_xfer_handle));",
      "ohci_device_intr_done  __P((usbd_xfer_handle));",
      "ohci_device_isoc_transfer __P((usbd_xfer_handle));",
      "ohci_device_isoc_start __P((usbd_xfer_handle));",
      "ohci_device_isoc_abort __P((usbd_xfer_handle));",
      "ohci_device_isoc_done  __P((usbd_xfer_handle));",
      "ohci_rhsc_able __P((ohci_softc_t *, int));",
      "ohci_abort_xfer __P((usbd_xfer_handle xfer,\n\t\t\t    usbd_status status));",
      "ohci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "ohci_noop __P((usbd_pipe_handle pipe));",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
      "ohci_intr1 __P((ohci_softc_t *));",
      "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "tail->physaddr"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "le32toh(data->td.td_cbp) +\n\t\t\txfer->length - 1"
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "data->td.td_cbp"
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "tail->physaddr"
          ],
          "line": 1387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "DMAADDR(&xfer->dmabuf)"
          ],
          "line": 1385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DMAADDR",
          "args": [
            "&xfer->dmabuf"
          ],
          "line": 1385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "OHCI_TD_R"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "OHCI_TD_IN | OHCI_TD_NOCC | \n\t\t\tOHCI_TD_SET_DI(1) | OHCI_TD_TOGGLE_CARRY"
          ],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OHCI_TD_SET_DI",
          "args": [
            "1"
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ohci_alloc_std",
          "args": [
            "sc"
          ],
          "line": 1373
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_alloc_std_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "479-574",
          "snippet": "usbd_status\nohci_alloc_std_chain(opipe, sc, alen, rd, xfer, sp, ep)\n\tstruct ohci_pipe *opipe;\n\tohci_softc_t *sc;\n\tint alen, rd;\n\tusbd_xfer_handle xfer;\n\tohci_soft_td_t *sp, **ep;\n{\n\tohci_soft_td_t *next, *cur;\n\tohci_physaddr_t dataphys, dataphysend;\n\tu_int32_t tdflags;\n\tint len, curlen;\n\tusb_dma_t *dma = &xfer->dmabuf;\n\tu_int16_t flags = xfer->flags;\n\n\tDPRINTFN(alen < 4096,(\"ohci_alloc_std_chain: start len=%d\\n\", alen));\n\n\tlen = alen;\n\tcur = sp;\n\tdataphys = DMAADDR(dma);\n\tdataphysend = OHCI_PAGE(dataphys + len - 1);\n\ttdflags = htole32(\n\t    (rd ? OHCI_TD_IN : OHCI_TD_OUT) | \n\t    (flags & USBD_SHORT_XFER_OK ? OHCI_TD_R : 0) |\n\t    OHCI_TD_NOCC | OHCI_TD_TOGGLE_CARRY | OHCI_TD_NOINTR);\n\n\tfor (;;) {\n\t\tnext = ohci_alloc_std(sc);\n\t\tif (next == NULL)\n\t\t\tgoto nomem;\n\n\t\t/* The OHCI hardware can handle at most one page crossing. */\n\t\tif (OHCI_PAGE(dataphys) == dataphysend ||\n\t\t    OHCI_PAGE(dataphys) + OHCI_PAGE_SIZE == dataphysend) {\n\t\t\t/* we can handle it in this TD */\n\t\t\tcurlen = len;\n\t\t} else {\n\t\t\t/* must use multiple TDs, fill as much as possible. */\n\t\t\tcurlen = 2 * OHCI_PAGE_SIZE - \n\t\t\t\t (dataphys & (OHCI_PAGE_SIZE-1));\n\t\t\t/* the length must be a multiple of the max size */\n\t\t\tcurlen -= curlen % UGETW(opipe->pipe.endpoint->edesc->wMaxPacketSize);\n#ifdef DIAGNOSTIC\n\t\t\tif (curlen == 0)\n\t\t\t\tpanic(\"ohci_alloc_std: curlen == 0\\n\");\n#endif\n\t\t}\n\t\tDPRINTFN(4,(\"ohci_alloc_std_chain: dataphys=0x%08x \"\n\t\t\t    \"dataphysend=0x%08x len=%d curlen=%d\\n\",\n\t\t\t    dataphys, dataphysend,\n\t\t\t    len, curlen));\n\t\tlen -= curlen;\n\n\t\tcur->td.td_flags = tdflags;\n\t\tcur->td.td_cbp = htole32(dataphys);\n\t\tcur->nexttd = next;\n\t\tcur->td.td_nexttd = htole32(next->physaddr);\n\t\tcur->td.td_be = htole32(dataphys + curlen - 1);\n\t\tcur->len = curlen;\n\t\tcur->flags = OHCI_ADD_LEN;\n\t\tcur->xfer = xfer;\n\t\tDPRINTFN(10,(\"ohci_alloc_std_chain: cbp=0x%08x be=0x%08x\\n\",\n\t\t\t    dataphys, dataphys + curlen - 1));\n\t\tif (len == 0)\n\t\t\tbreak;\n\t\tDPRINTFN(10,(\"ohci_alloc_std_chain: extend chain\\n\"));\n\t\tdataphys += curlen;\n\t\tcur = next;\n\t}\n\tif ((flags & USBD_FORCE_SHORT_XFER) &&\n\t    alen % UGETW(opipe->pipe.endpoint->edesc->wMaxPacketSize) == 0) {\n\t\t/* Force a 0 length transfer at the end. */\n\n\t\tcur = next;\n\t\tnext = ohci_alloc_std(sc);\n\t\tif (next == NULL)\n\t\t\tgoto nomem;\n\n\t\tcur->td.td_flags = tdflags;\n\t\tcur->td.td_cbp = 0; /* indicate 0 length packet */\n\t\tcur->nexttd = next;\n\t\tcur->td.td_nexttd = htole32(next->physaddr);\n\t\tcur->td.td_be = ~0;\n\t\tcur->len = 0;\n\t\tcur->flags = 0;\n\t\tcur->xfer = xfer;\n\t\tDPRINTFN(2,(\"ohci_alloc_std_chain: add 0 xfer\\n\"));\n\t}\n\t*ep = cur;\n\n\treturn (USBD_NORMAL_COMPLETION);\n\n nomem:\n\t/* XXX free chain */\n\treturn (USBD_NOMEM);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static ohci_soft_td_t",
            "ohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));",
            "Static usbd_status",
            "ohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));",
            "Static usbd_status",
            "ohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));",
            "ohci_add_done __P((ohci_softc_t *, ohci_physaddr_t));",
            "ohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_request __P((usbd_xfer_handle xfer));",
            "ohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));",
            "ohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));",
            "Static ohci_soft_td_t",
            "Static usbd_status",
            "ohci_setup_isoc __P((usbd_pipe_handle pipe));",
            "ohci_device_isoc_enter __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));",
            "ohci_freem __P((struct usbd_bus *, usb_dma_t *));",
            "Static usbd_xfer_handle",
            "ohci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_root_ctrl_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_root_ctrl_start __P((usbd_xfer_handle));",
            "ohci_root_ctrl_abort __P((usbd_xfer_handle));",
            "ohci_root_ctrl_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_root_intr_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_root_intr_start __P((usbd_xfer_handle));",
            "ohci_root_intr_abort __P((usbd_xfer_handle));",
            "ohci_root_intr_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_ctrl_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_ctrl_start __P((usbd_xfer_handle));",
            "ohci_device_ctrl_abort __P((usbd_xfer_handle));",
            "ohci_device_ctrl_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_bulk_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_bulk_start __P((usbd_xfer_handle));",
            "ohci_device_bulk_abort __P((usbd_xfer_handle));",
            "ohci_device_bulk_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_intr_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_intr_start __P((usbd_xfer_handle));",
            "ohci_device_intr_abort __P((usbd_xfer_handle));",
            "ohci_device_intr_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_isoc_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_device_isoc_start __P((usbd_xfer_handle));",
            "ohci_device_isoc_abort __P((usbd_xfer_handle));",
            "ohci_device_isoc_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "ohci_rhsc_able __P((ohci_softc_t *, int));",
            "ohci_device_clear_toggle __P((usbd_pipe_handle pipe));",
            "ohci_noop __P((usbd_pipe_handle pipe));",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
            "ohci_intr1 __P((ohci_softc_t *));",
            "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
            "ohci_physaddr_t a;",
            "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;",
            "ohci_physaddr_t a;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_td_t;\nohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));\nStatic usbd_status;\nohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));\nStatic usbd_status;\nohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));\nohci_add_done __P((ohci_softc_t *, ohci_physaddr_t));\nohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));\nStatic usbd_status;\nohci_device_request __P((usbd_xfer_handle xfer));\nohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));\nohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));\nStatic ohci_soft_td_t;\nStatic usbd_status;\nohci_setup_isoc __P((usbd_pipe_handle pipe));\nohci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));\nohci_freem __P((struct usbd_bus *, usb_dma_t *));\nStatic usbd_xfer_handle;\nohci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nStatic usbd_status;\nohci_root_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_ctrl_start __P((usbd_xfer_handle));\nohci_root_ctrl_abort __P((usbd_xfer_handle));\nohci_root_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_intr_start __P((usbd_xfer_handle));\nohci_root_intr_abort __P((usbd_xfer_handle));\nohci_root_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_ctrl_start __P((usbd_xfer_handle));\nohci_device_ctrl_abort __P((usbd_xfer_handle));\nohci_device_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_bulk_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_bulk_start __P((usbd_xfer_handle));\nohci_device_bulk_abort __P((usbd_xfer_handle));\nohci_device_bulk_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_intr_start __P((usbd_xfer_handle));\nohci_device_intr_abort __P((usbd_xfer_handle));\nohci_device_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_isoc_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_isoc_start __P((usbd_xfer_handle));\nohci_device_isoc_abort __P((usbd_xfer_handle));\nohci_device_isoc_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_rhsc_able __P((ohci_softc_t *, int));\nohci_device_clear_toggle __P((usbd_pipe_handle pipe));\nohci_noop __P((usbd_pipe_handle pipe));\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_physaddr_t a;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\nohci_physaddr_t a;\n\nusbd_status\nohci_alloc_std_chain(opipe, sc, alen, rd, xfer, sp, ep)\n\tstruct ohci_pipe *opipe;\n\tohci_softc_t *sc;\n\tint alen, rd;\n\tusbd_xfer_handle xfer;\n\tohci_soft_td_t *sp, **ep;\n{\n\tohci_soft_td_t *next, *cur;\n\tohci_physaddr_t dataphys, dataphysend;\n\tu_int32_t tdflags;\n\tint len, curlen;\n\tusb_dma_t *dma = &xfer->dmabuf;\n\tu_int16_t flags = xfer->flags;\n\n\tDPRINTFN(alen < 4096,(\"ohci_alloc_std_chain: start len=%d\\n\", alen));\n\n\tlen = alen;\n\tcur = sp;\n\tdataphys = DMAADDR(dma);\n\tdataphysend = OHCI_PAGE(dataphys + len - 1);\n\ttdflags = htole32(\n\t    (rd ? OHCI_TD_IN : OHCI_TD_OUT) | \n\t    (flags & USBD_SHORT_XFER_OK ? OHCI_TD_R : 0) |\n\t    OHCI_TD_NOCC | OHCI_TD_TOGGLE_CARRY | OHCI_TD_NOINTR);\n\n\tfor (;;) {\n\t\tnext = ohci_alloc_std(sc);\n\t\tif (next == NULL)\n\t\t\tgoto nomem;\n\n\t\t/* The OHCI hardware can handle at most one page crossing. */\n\t\tif (OHCI_PAGE(dataphys) == dataphysend ||\n\t\t    OHCI_PAGE(dataphys) + OHCI_PAGE_SIZE == dataphysend) {\n\t\t\t/* we can handle it in this TD */\n\t\t\tcurlen = len;\n\t\t} else {\n\t\t\t/* must use multiple TDs, fill as much as possible. */\n\t\t\tcurlen = 2 * OHCI_PAGE_SIZE - \n\t\t\t\t (dataphys & (OHCI_PAGE_SIZE-1));\n\t\t\t/* the length must be a multiple of the max size */\n\t\t\tcurlen -= curlen % UGETW(opipe->pipe.endpoint->edesc->wMaxPacketSize);\n#ifdef DIAGNOSTIC\n\t\t\tif (curlen == 0)\n\t\t\t\tpanic(\"ohci_alloc_std: curlen == 0\\n\");\n#endif\n\t\t}\n\t\tDPRINTFN(4,(\"ohci_alloc_std_chain: dataphys=0x%08x \"\n\t\t\t    \"dataphysend=0x%08x len=%d curlen=%d\\n\",\n\t\t\t    dataphys, dataphysend,\n\t\t\t    len, curlen));\n\t\tlen -= curlen;\n\n\t\tcur->td.td_flags = tdflags;\n\t\tcur->td.td_cbp = htole32(dataphys);\n\t\tcur->nexttd = next;\n\t\tcur->td.td_nexttd = htole32(next->physaddr);\n\t\tcur->td.td_be = htole32(dataphys + curlen - 1);\n\t\tcur->len = curlen;\n\t\tcur->flags = OHCI_ADD_LEN;\n\t\tcur->xfer = xfer;\n\t\tDPRINTFN(10,(\"ohci_alloc_std_chain: cbp=0x%08x be=0x%08x\\n\",\n\t\t\t    dataphys, dataphys + curlen - 1));\n\t\tif (len == 0)\n\t\t\tbreak;\n\t\tDPRINTFN(10,(\"ohci_alloc_std_chain: extend chain\\n\"));\n\t\tdataphys += curlen;\n\t\tcur = next;\n\t}\n\tif ((flags & USBD_FORCE_SHORT_XFER) &&\n\t    alen % UGETW(opipe->pipe.endpoint->edesc->wMaxPacketSize) == 0) {\n\t\t/* Force a 0 length transfer at the end. */\n\n\t\tcur = next;\n\t\tnext = ohci_alloc_std(sc);\n\t\tif (next == NULL)\n\t\t\tgoto nomem;\n\n\t\tcur->td.td_flags = tdflags;\n\t\tcur->td.td_cbp = 0; /* indicate 0 length packet */\n\t\tcur->nexttd = next;\n\t\tcur->td.td_nexttd = htole32(next->physaddr);\n\t\tcur->td.td_be = ~0;\n\t\tcur->len = 0;\n\t\tcur->flags = 0;\n\t\tcur->xfer = xfer;\n\t\tDPRINTFN(2,(\"ohci_alloc_std_chain: add 0 xfer\\n\"));\n\t}\n\t*ep = cur;\n\n\treturn (USBD_NORMAL_COMPLETION);\n\n nomem:\n\t/* XXX free chain */\n\treturn (USBD_NOMEM);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "10",
            "(\"ohci_intr_done: xfer=%p, actlen=%d\\n\", \n\t\t     xfer, xfer->actlen)"
          ],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_ed_t;\nohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));\nStatic ohci_soft_td_t;\nohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));\nohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));\nohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));\nohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));\nohci_device_request __P((usbd_xfer_handle xfer));\nohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));\nohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));\nStatic ohci_soft_td_t;\nohci_setup_isoc __P((usbd_pipe_handle pipe));\nohci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_xfer_handle;\nohci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nohci_root_ctrl_transfer __P((usbd_xfer_handle));\nohci_root_ctrl_start __P((usbd_xfer_handle));\nohci_root_ctrl_abort __P((usbd_xfer_handle));\nohci_root_ctrl_done  __P((usbd_xfer_handle));\nohci_root_intr_transfer __P((usbd_xfer_handle));\nohci_root_intr_start __P((usbd_xfer_handle));\nohci_root_intr_abort __P((usbd_xfer_handle));\nohci_root_intr_done  __P((usbd_xfer_handle));\nohci_device_ctrl_transfer __P((usbd_xfer_handle));\nohci_device_ctrl_start __P((usbd_xfer_handle));\nohci_device_ctrl_abort __P((usbd_xfer_handle));\nohci_device_ctrl_done  __P((usbd_xfer_handle));\nohci_device_bulk_transfer __P((usbd_xfer_handle));\nohci_device_bulk_start __P((usbd_xfer_handle));\nohci_device_bulk_abort __P((usbd_xfer_handle));\nohci_device_bulk_done  __P((usbd_xfer_handle));\nohci_device_intr_transfer __P((usbd_xfer_handle));\nohci_device_intr_start __P((usbd_xfer_handle));\nohci_device_intr_abort __P((usbd_xfer_handle));\nohci_device_intr_done  __P((usbd_xfer_handle));\nohci_device_isoc_transfer __P((usbd_xfer_handle));\nohci_device_isoc_start __P((usbd_xfer_handle));\nohci_device_isoc_abort __P((usbd_xfer_handle));\nohci_device_isoc_done  __P((usbd_xfer_handle));\nohci_rhsc_able __P((ohci_softc_t *, int));\nohci_abort_xfer __P((usbd_xfer_handle xfer,\n\t\t\t    usbd_status status));\nohci_device_clear_toggle __P((usbd_pipe_handle pipe));\nohci_noop __P((usbd_pipe_handle pipe));\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nvoid\nohci_device_intr_done(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tstruct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;\n\tohci_softc_t *sc = (ohci_softc_t *)opipe->pipe.device->bus;\n\tohci_soft_ed_t *sed = opipe->sed;\n\tohci_soft_td_t *data, *tail;\n\n\n\tDPRINTFN(10,(\"ohci_intr_done: xfer=%p, actlen=%d\\n\", \n\t\t     xfer, xfer->actlen));\n\n\txfer->hcpriv = NULL;\n\n\tif (xfer->pipe->repeat) {\n\t\tdata = opipe->tail.td;\n\t\ttail = ohci_alloc_std(sc); /* XXX should reuse TD */\n\t\tif (tail == NULL) {\n\t\t\txfer->status = USBD_NOMEM;\n\t\t\treturn;\n\t\t}\n\t\ttail->xfer = NULL;\n\t\t\n\t\tdata->td.td_flags = htole32(\n\t\t\tOHCI_TD_IN | OHCI_TD_NOCC | \n\t\t\tOHCI_TD_SET_DI(1) | OHCI_TD_TOGGLE_CARRY);\n\t\tif (xfer->flags & USBD_SHORT_XFER_OK)\n\t\t\tdata->td.td_flags |= htole32(OHCI_TD_R);\n\t\tdata->td.td_cbp = htole32(DMAADDR(&xfer->dmabuf));\n\t\tdata->nexttd = tail;\n\t\tdata->td.td_nexttd = htole32(tail->physaddr);\n\t\tdata->td.td_be = htole32(le32toh(data->td.td_cbp) +\n\t\t\txfer->length - 1);\n\t\tdata->len = xfer->length;\n\t\tdata->xfer = xfer;\n\t\tdata->flags = OHCI_CALL_DONE | OHCI_ADD_LEN;\n\t\txfer->hcpriv = data;\n\t\txfer->actlen = 0;\n\n\t\tsed->ed.ed_tailp = htole32(tail->physaddr);\n\t\topipe->tail.td = tail;\n\t}\n}"
  },
  {
    "function_name": "ohci_device_ctrl_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "1342-1354",
    "snippet": "void\nohci_device_ctrl_done(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tDPRINTFN(10,(\"ohci_ctrl_done: xfer=%p\\n\", xfer));\n\n#ifdef DIAGNOSTIC\n\tif (!(xfer->rqflags & URQ_REQUEST)) {\n\t\tpanic(\"ohci_ctrl_done: not a request\\n\");\n\t}\n#endif\n\txfer->hcpriv = NULL;\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "ohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));",
      "ohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));",
      "ohci_device_request __P((usbd_xfer_handle xfer));",
      "ohci_device_isoc_enter __P((usbd_xfer_handle));",
      "Static usbd_xfer_handle",
      "ohci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "ohci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "ohci_root_ctrl_start __P((usbd_xfer_handle));",
      "ohci_root_ctrl_abort __P((usbd_xfer_handle));",
      "ohci_root_ctrl_done  __P((usbd_xfer_handle));",
      "ohci_root_intr_transfer __P((usbd_xfer_handle));",
      "ohci_root_intr_start __P((usbd_xfer_handle));",
      "ohci_root_intr_abort __P((usbd_xfer_handle));",
      "ohci_root_intr_done  __P((usbd_xfer_handle));",
      "ohci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "ohci_device_ctrl_start __P((usbd_xfer_handle));",
      "ohci_device_ctrl_abort __P((usbd_xfer_handle));",
      "ohci_device_ctrl_done  __P((usbd_xfer_handle));",
      "ohci_device_bulk_transfer __P((usbd_xfer_handle));",
      "ohci_device_bulk_start __P((usbd_xfer_handle));",
      "ohci_device_bulk_abort __P((usbd_xfer_handle));",
      "ohci_device_bulk_done  __P((usbd_xfer_handle));",
      "ohci_device_intr_transfer __P((usbd_xfer_handle));",
      "ohci_device_intr_start __P((usbd_xfer_handle));",
      "ohci_device_intr_abort __P((usbd_xfer_handle));",
      "ohci_device_intr_done  __P((usbd_xfer_handle));",
      "ohci_device_isoc_transfer __P((usbd_xfer_handle));",
      "ohci_device_isoc_start __P((usbd_xfer_handle));",
      "ohci_device_isoc_abort __P((usbd_xfer_handle));",
      "ohci_device_isoc_done  __P((usbd_xfer_handle));",
      "ohci_physaddr_t a;",
      "ohci_physaddr_t a;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"ohci_ctrl_done: not a request\\n\""
          ],
          "line": 1350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "10",
            "(\"ohci_ctrl_done: xfer=%p\\n\", xfer)"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));\nohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));\nohci_device_request __P((usbd_xfer_handle xfer));\nohci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_xfer_handle;\nohci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nohci_root_ctrl_transfer __P((usbd_xfer_handle));\nohci_root_ctrl_start __P((usbd_xfer_handle));\nohci_root_ctrl_abort __P((usbd_xfer_handle));\nohci_root_ctrl_done  __P((usbd_xfer_handle));\nohci_root_intr_transfer __P((usbd_xfer_handle));\nohci_root_intr_start __P((usbd_xfer_handle));\nohci_root_intr_abort __P((usbd_xfer_handle));\nohci_root_intr_done  __P((usbd_xfer_handle));\nohci_device_ctrl_transfer __P((usbd_xfer_handle));\nohci_device_ctrl_start __P((usbd_xfer_handle));\nohci_device_ctrl_abort __P((usbd_xfer_handle));\nohci_device_ctrl_done  __P((usbd_xfer_handle));\nohci_device_bulk_transfer __P((usbd_xfer_handle));\nohci_device_bulk_start __P((usbd_xfer_handle));\nohci_device_bulk_abort __P((usbd_xfer_handle));\nohci_device_bulk_done  __P((usbd_xfer_handle));\nohci_device_intr_transfer __P((usbd_xfer_handle));\nohci_device_intr_start __P((usbd_xfer_handle));\nohci_device_intr_abort __P((usbd_xfer_handle));\nohci_device_intr_done  __P((usbd_xfer_handle));\nohci_device_isoc_transfer __P((usbd_xfer_handle));\nohci_device_isoc_start __P((usbd_xfer_handle));\nohci_device_isoc_abort __P((usbd_xfer_handle));\nohci_device_isoc_done  __P((usbd_xfer_handle));\nohci_physaddr_t a;\nohci_physaddr_t a;\n\nvoid\nohci_device_ctrl_done(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tDPRINTFN(10,(\"ohci_ctrl_done: xfer=%p\\n\", xfer));\n\n#ifdef DIAGNOSTIC\n\tif (!(xfer->rqflags & URQ_REQUEST)) {\n\t\tpanic(\"ohci_ctrl_done: not a request\\n\");\n\t}\n#endif\n\txfer->hcpriv = NULL;\n}"
  },
  {
    "function_name": "ohci_softintr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "1200-1340",
    "snippet": "void\nohci_softintr(bus)\n\tstruct usbd_bus *bus;\n{\n\tohci_softc_t *sc = (ohci_softc_t *)bus;\n\tohci_soft_itd_t *sitd, *sidone, *sitdnext;\n\tohci_soft_td_t  *std,  *sdone,  *stdnext;\n\tusbd_xfer_handle xfer;\n\tint len, cc, s;\n\n\tsc->sc_bus.intr_context++;\n\n\ts = splhardusb();\n\tsdone = sc->sc_sdone;\n\tsc->sc_sdone = NULL;\n\tsidone = sc->sc_sidone;\n\tsc->sc_sidone = NULL;\n\tsplx(s);\n\n\tDPRINTFN(10,(\"ohci_process_done: sdone=%p sidone=%p\\n\", sdone, sidone));\n\n#ifdef OHCI_DEBUG\n\tif (ohcidebug > 10) {\n\t\tDPRINTF((\"ohci_process_done: TD done:\\n\"));\n\t\tohci_dump_tds(sdone);\n\t}\n#endif\n\n\tfor (std = sdone; std; std = stdnext) {\n\t\txfer = std->xfer;\n\t\tstdnext = std->dnext;\n\t\tDPRINTFN(10, (\"ohci_process_done: std=%p xfer=%p hcpriv=%p\\n\",\n\t\t\t\tstd, xfer, xfer ? xfer->hcpriv : 0));\n\t\tif (xfer == NULL) {\n\t\t\t/* xfer == NULL: There seems to be no xfer associated\n\t\t\t * with this TD. It is tailp that happened to end up on\n\t\t\t * the done queue.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\t\tif (xfer->status == USBD_CANCELLED ||\n\t\t    xfer->status == USBD_TIMEOUT) {\n\t\t\tDPRINTF((\"ohci_process_done: cancel/timeout %p\\n\",\n\t\t\t\t xfer));\n\t\t\t/* Handled by abort routine. */\n\t\t\tcontinue;\n\t\t}\n\t\tusb_uncallout(xfer->timeout_handle, ohci_timeout, xfer);\n\t\tcc = OHCI_TD_GET_CC(le32toh(std->td.td_flags));\n\t\tif (cc == OHCI_CC_NO_ERROR) {\n\t\t\tlen = std->len;\n\t\t\tif (std->td.td_cbp != 0)\n\t\t\t\tlen -= le32toh(std->td.td_be) -\n\t\t\t\t       le32toh(std->td.td_cbp) + 1;\n\t\t\tDPRINTFN(10, (\"ohci_process_done: len=%d, flags=0x%x\\n\",\n\t\t\t\t      len, std->flags));\n\t\t\tif (std->flags & OHCI_ADD_LEN)\n\t\t\t\txfer->actlen += len;\n\t\t\tif (std->flags & OHCI_CALL_DONE) {\n\t\t\t\txfer->status = USBD_NORMAL_COMPLETION;\n\t\t\t\tusb_transfer_complete(xfer);\n\t\t\t}\n\t\t\tohci_free_std(sc, std);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Endpoint is halted.  First unlink all the TDs\n\t\t\t * belonging to the failed transfer, and then restart\n\t\t\t * the endpoint.\n\t\t\t */\n\t\t\tohci_soft_td_t *p, *n;\n\t\t\tstruct ohci_pipe *opipe = \n\t\t\t\t(struct ohci_pipe *)xfer->pipe;\n\n\t\t\tDPRINTFN(15,(\"ohci_process_done: error cc=%d (%s)\\n\",\n\t\t\t  OHCI_TD_GET_CC(le32toh(std->td.td_flags)),\n\t\t\t  ohci_cc_strs[OHCI_TD_GET_CC(le32toh(std->td.td_flags))]));\n\n\t\t\t/* remove TDs */\n\t\t\tfor (p = std; p->xfer == xfer; p = n) {\n\t\t\t\tn = p->nexttd;\n\t\t\t\tohci_free_std(sc, p);\n\t\t\t}\n\n\t\t\t/* clear halt */\n\t\t\topipe->sed->ed.ed_headp = htole32(p->physaddr);\n\t\t\tOWRITE4(sc, OHCI_COMMAND_STATUS, OHCI_CLF);\n\n\t\t\tif (cc == OHCI_CC_STALL)\n\t\t\t\txfer->status = USBD_STALLED;\n\t\t\telse\n\t\t\t\txfer->status = USBD_IOERROR;\n\t\t\tusb_transfer_complete(xfer);\n\t\t}\n\t}\n\n#ifdef OHCI_DEBUG\n\tif (ohcidebug > 10) {\n\t\tDPRINTF((\"ohci_process_done: ITD done:\\n\"));\n\t\tohci_dump_itds(sidone);\n\t}\n#endif\n\n\tfor (sitd = sidone; sitd != NULL; sitd = sitdnext) {\n\t\txfer = sitd->xfer;\n\t\tsitdnext = sitd->dnext;\n\t\tDPRINTFN(1, (\"ohci_process_done: sitd=%p xfer=%p hcpriv=%p\\n\",\n\t\t\t     sitd, xfer, xfer ? xfer->hcpriv : 0));\n\t\tif (xfer == NULL)\n\t\t\tcontinue;\n\t\tif (xfer->status == USBD_CANCELLED ||\n\t\t    xfer->status == USBD_TIMEOUT) {\n\t\t\tDPRINTF((\"ohci_process_done: cancel/timeout %p\\n\",\n\t\t\t\t xfer));\n\t\t\t/* Handled by abort routine. */\n\t\t\tcontinue;\n\t\t}\n#ifdef DIAGNOSTIC\n\t\tif (sitd->isdone)\n\t\t\tprintf(\"ohci_softintr: sitd=%p is done\\n\", sitd);\n\t\tsitd->isdone = 1;\n#endif\n\t\tcc = OHCI_ITD_GET_CC(le32toh(sitd->itd.itd_flags));\n\t\tif (cc == OHCI_CC_NO_ERROR) {\n\t\t\t/* XXX compute length for input */\n\t\t\tstruct ohci_pipe *opipe = \n\t\t\t\t(struct ohci_pipe *)xfer->pipe;\n\t\t\tif (sitd->flags & OHCI_CALL_DONE) {\n\t\t\t\topipe->u.iso.inuse -= xfer->nframes;\n\t\t\t\t/* XXX xfer->actlen = actlen; */\n\t\t\t\txfer->status = USBD_NORMAL_COMPLETION;\n\t\t\t\tusb_transfer_complete(xfer);\n\t\t\t}\n\t\t} else {\n\t\t\t/* XXX Do more */\n\t\t\txfer->status = USBD_IOERROR;\n\t\t\tusb_transfer_complete(xfer);\n\t\t}\n\t}\n\n\tsc->sc_bus.intr_context--;\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static ohci_soft_td_t",
      "ohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));",
      "Static ohci_soft_itd_t",
      "ohci_free_sitd __P((ohci_softc_t *,ohci_soft_itd_t *));",
      "ohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));",
      "ohci_poll __P((struct usbd_bus *));",
      "ohci_softintr __P((struct usbd_bus *));",
      "ohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));",
      "ohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));",
      "ohci_device_request __P((usbd_xfer_handle xfer));",
      "ohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));",
      "ohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));",
      "Static ohci_soft_td_t",
      "ohci_hash_add_itd __P((ohci_softc_t *, \n\t\t\t    ohci_soft_itd_t *));",
      "ohci_hash_rem_itd __P((ohci_softc_t *,\n\t\t\t    ohci_soft_itd_t *));",
      "Static ohci_soft_itd_t",
      "ohci_setup_isoc __P((usbd_pipe_handle pipe));",
      "ohci_device_isoc_enter __P((usbd_xfer_handle));",
      "Static usbd_xfer_handle",
      "ohci_allocx __P((struct usbd_bus *));",
      "ohci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "ohci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "ohci_root_ctrl_start __P((usbd_xfer_handle));",
      "ohci_root_ctrl_abort __P((usbd_xfer_handle));",
      "ohci_root_ctrl_done  __P((usbd_xfer_handle));",
      "ohci_root_intr_transfer __P((usbd_xfer_handle));",
      "ohci_root_intr_start __P((usbd_xfer_handle));",
      "ohci_root_intr_abort __P((usbd_xfer_handle));",
      "ohci_root_intr_done  __P((usbd_xfer_handle));",
      "ohci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "ohci_device_ctrl_start __P((usbd_xfer_handle));",
      "ohci_device_ctrl_abort __P((usbd_xfer_handle));",
      "ohci_device_ctrl_done  __P((usbd_xfer_handle));",
      "ohci_device_bulk_transfer __P((usbd_xfer_handle));",
      "ohci_device_bulk_start __P((usbd_xfer_handle));",
      "ohci_device_bulk_abort __P((usbd_xfer_handle));",
      "ohci_device_bulk_done  __P((usbd_xfer_handle));",
      "ohci_device_intr_transfer __P((usbd_xfer_handle));",
      "ohci_device_intr_start __P((usbd_xfer_handle));",
      "ohci_device_intr_abort __P((usbd_xfer_handle));",
      "ohci_device_intr_done  __P((usbd_xfer_handle));",
      "ohci_device_isoc_transfer __P((usbd_xfer_handle));",
      "ohci_device_isoc_start __P((usbd_xfer_handle));",
      "ohci_device_isoc_abort __P((usbd_xfer_handle));",
      "ohci_device_isoc_done  __P((usbd_xfer_handle));",
      "ohci_rhsc_able __P((ohci_softc_t *, int));",
      "ohci_abort_xfer __P((usbd_xfer_handle xfer,\n\t\t\t    usbd_status status));",
      "ohci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "ohci_noop __P((usbd_pipe_handle pipe));",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
      "ohci_intr1 __P((ohci_softc_t *));",
      "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usb_transfer_complete",
          "args": [
            "xfer"
          ],
          "line": 1335
        },
        "resolved": true,
        "details": {
          "function_name": "usb_transfer_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "789-883",
          "snippet": "void\nusb_transfer_complete(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tint repeat = pipe->repeat;\n\tint polling;\n\n\tSPLUSBCHECK;\n\n\tDPRINTFN(5, (\"usb_transfer_complete: pipe=%p xfer=%p status=%d \"\n\t\t     \"actlen=%d\\n\", pipe, xfer, xfer->status, xfer->actlen));\n\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_transfer_cb: pipe==0, xfer=%p\\n\", xfer);\n\t\treturn;\n\t}\n#endif\n\tpolling = pipe->device->bus->use_polling;\n\t/* XXXX */\n\tif (polling)\n\t\tpipe->running = 0;\n\n\tif (!(xfer->flags & USBD_NO_COPY) && xfer->actlen != 0 &&\n\t    usbd_xfer_isread(xfer)) {\n#ifdef DIAGNOSTIC\n\t\tif (xfer->actlen > xfer->length) {\n\t\t\tprintf(\"usb_transfer_complete: actlen > len %d > %d\\n\",\n\t\t\t       xfer->actlen, xfer->length);\n\t\t\txfer->actlen = xfer->length;\n\t\t}\n#endif\n\t\tmemcpy(xfer->buffer, KERNADDR(dmap), xfer->actlen);\n\t}\n\n\t/* if we allocated the buffer in usbd_transfer() we free it here. */\n\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\tif (!repeat) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\t\t\tbus->methods->freem(bus, dmap);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!repeat) {\n\t\t/* Remove request from queue. */\n#ifdef DIAGNOSTIC\n\t\tif (xfer != SIMPLEQ_FIRST(&pipe->queue))\n\t\t\tprintf(\"usb_transfer_complete: bad dequeue %p != %p\\n\",\n\t\t\t       xfer, SIMPLEQ_FIRST(&pipe->queue));\n#endif\n\t\tSIMPLEQ_REMOVE_HEAD(&pipe->queue, xfer, next);\n\t}\n\tDPRINTFN(5,(\"usb_transfer_complete: repeat=%d new head=%p\\n\", \n\t\t    repeat, SIMPLEQ_FIRST(&pipe->queue)));\n\n\t/* Count completed transfers. */\n\t++pipe->device->bus->stats.requests\n\t\t[pipe->endpoint->edesc->bmAttributes & UE_XFERTYPE];\n\n\txfer->done = 1;\n\tif (!xfer->status && xfer->actlen < xfer->length &&\n\t    !(xfer->flags & USBD_SHORT_XFER_OK)) {\n\t\tDPRINTFN(-1,(\"usbd_transfer_cb: short transfer %d<%d\\n\",\n\t\t\t     xfer->actlen, xfer->length));\n\t\txfer->status = USBD_SHORT_XFER;\n\t}\n\n\tif (xfer->callback)\n\t\txfer->callback(xfer, xfer->priv, xfer->status);\n\n#ifdef DIAGNOSTIC\n\tif (pipe->methods->done != NULL)\n\t\tpipe->methods->done(xfer);\n\telse\n\t\tprintf(\"usb_transfer_complete: pipe->methods->done == NULL\\n\");\n#else\n\tpipe->methods->done(xfer);\n#endif\n\n\tif ((xfer->flags & USBD_SYNCHRONOUS) && !polling)\n\t\twakeup(xfer);\n\n\tif (!repeat) {\n\t\t/* XXX should we stop the queue on all errors? */\n\t\tif ((xfer->status == USBD_CANCELLED ||\n\t\t     xfer->status == USBD_TIMEOUT) &&\n\t\t    pipe->iface != NULL)\t\t/* not control pipe */\n\t\t\tpipe->running = 0;\n\t\telse\n\t\t\tusbd_start_next(pipe);\n\t}\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "usb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;",
            "usb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);",
            "usb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_start_next __P((usbd_pipe_handle pipe));\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nusb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;\nusb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\nusb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;\n\nvoid\nusb_transfer_complete(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tint repeat = pipe->repeat;\n\tint polling;\n\n\tSPLUSBCHECK;\n\n\tDPRINTFN(5, (\"usb_transfer_complete: pipe=%p xfer=%p status=%d \"\n\t\t     \"actlen=%d\\n\", pipe, xfer, xfer->status, xfer->actlen));\n\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_transfer_cb: pipe==0, xfer=%p\\n\", xfer);\n\t\treturn;\n\t}\n#endif\n\tpolling = pipe->device->bus->use_polling;\n\t/* XXXX */\n\tif (polling)\n\t\tpipe->running = 0;\n\n\tif (!(xfer->flags & USBD_NO_COPY) && xfer->actlen != 0 &&\n\t    usbd_xfer_isread(xfer)) {\n#ifdef DIAGNOSTIC\n\t\tif (xfer->actlen > xfer->length) {\n\t\t\tprintf(\"usb_transfer_complete: actlen > len %d > %d\\n\",\n\t\t\t       xfer->actlen, xfer->length);\n\t\t\txfer->actlen = xfer->length;\n\t\t}\n#endif\n\t\tmemcpy(xfer->buffer, KERNADDR(dmap), xfer->actlen);\n\t}\n\n\t/* if we allocated the buffer in usbd_transfer() we free it here. */\n\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\tif (!repeat) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\t\t\tbus->methods->freem(bus, dmap);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!repeat) {\n\t\t/* Remove request from queue. */\n#ifdef DIAGNOSTIC\n\t\tif (xfer != SIMPLEQ_FIRST(&pipe->queue))\n\t\t\tprintf(\"usb_transfer_complete: bad dequeue %p != %p\\n\",\n\t\t\t       xfer, SIMPLEQ_FIRST(&pipe->queue));\n#endif\n\t\tSIMPLEQ_REMOVE_HEAD(&pipe->queue, xfer, next);\n\t}\n\tDPRINTFN(5,(\"usb_transfer_complete: repeat=%d new head=%p\\n\", \n\t\t    repeat, SIMPLEQ_FIRST(&pipe->queue)));\n\n\t/* Count completed transfers. */\n\t++pipe->device->bus->stats.requests\n\t\t[pipe->endpoint->edesc->bmAttributes & UE_XFERTYPE];\n\n\txfer->done = 1;\n\tif (!xfer->status && xfer->actlen < xfer->length &&\n\t    !(xfer->flags & USBD_SHORT_XFER_OK)) {\n\t\tDPRINTFN(-1,(\"usbd_transfer_cb: short transfer %d<%d\\n\",\n\t\t\t     xfer->actlen, xfer->length));\n\t\txfer->status = USBD_SHORT_XFER;\n\t}\n\n\tif (xfer->callback)\n\t\txfer->callback(xfer, xfer->priv, xfer->status);\n\n#ifdef DIAGNOSTIC\n\tif (pipe->methods->done != NULL)\n\t\tpipe->methods->done(xfer);\n\telse\n\t\tprintf(\"usb_transfer_complete: pipe->methods->done == NULL\\n\");\n#else\n\tpipe->methods->done(xfer);\n#endif\n\n\tif ((xfer->flags & USBD_SYNCHRONOUS) && !polling)\n\t\twakeup(xfer);\n\n\tif (!repeat) {\n\t\t/* XXX should we stop the queue on all errors? */\n\t\tif ((xfer->status == USBD_CANCELLED ||\n\t\t     xfer->status == USBD_TIMEOUT) &&\n\t\t    pipe->iface != NULL)\t\t/* not control pipe */\n\t\t\tpipe->running = 0;\n\t\telse\n\t\t\tusbd_start_next(pipe);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "OHCI_ITD_GET_CC",
          "args": [
            "le32toh(sitd->itd.itd_flags)"
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "sitd->itd.itd_flags"
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ohci_softintr: sitd=%p is done\\n\"",
            "sitd"
          ],
          "line": 1318
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ohci_process_done: cancel/timeout %p\\n\",\n\t\t\t\t xfer)"
          ],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"ohci_process_done: sitd=%p xfer=%p hcpriv=%p\\n\",\n\t\t\t     sitd, xfer, xfer ? xfer->hcpriv : 0)"
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ohci_dump_itds",
          "args": [
            "sidone"
          ],
          "line": 1298
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_dump_itds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "1834-1840",
          "snippet": "void\nohci_dump_itds(sitd)\n\tohci_soft_itd_t *sitd;\n{\n\tfor (; sitd; sitd = sitd->nextitd)\n\t\tohci_dump_itd(sitd);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static ohci_soft_itd_t",
            "ohci_free_sitd __P((ohci_softc_t *,ohci_soft_itd_t *));",
            "ohci_hash_add_itd __P((ohci_softc_t *, \n\t\t\t    ohci_soft_itd_t *));",
            "ohci_hash_rem_itd __P((ohci_softc_t *,\n\t\t\t    ohci_soft_itd_t *));",
            "Static ohci_soft_itd_t"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_itd_t;\nohci_free_sitd __P((ohci_softc_t *,ohci_soft_itd_t *));\nohci_hash_add_itd __P((ohci_softc_t *, \n\t\t\t    ohci_soft_itd_t *));\nohci_hash_rem_itd __P((ohci_softc_t *,\n\t\t\t    ohci_soft_itd_t *));\nStatic ohci_soft_itd_t;\n\nvoid\nohci_dump_itds(sitd)\n\tohci_soft_itd_t *sitd;\n{\n\tfor (; sitd; sitd = sitd->nextitd)\n\t\tohci_dump_itd(sitd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ohci_process_done: ITD done:\\n\")"
          ],
          "line": 1297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OWRITE4",
          "args": [
            "sc",
            "OHCI_COMMAND_STATUS",
            "OHCI_CLF"
          ],
          "line": 1285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "p->physaddr"
          ],
          "line": 1284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ohci_free_std",
          "args": [
            "sc",
            "p"
          ],
          "line": 1280
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_free_std_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "577-589",
          "snippet": "Static void\nohci_free_std_chain(sc, std, stdend)\n\tohci_softc_t *sc;\n\tohci_soft_td_t *std;\n\tohci_soft_td_t *stdend;\n{\n\tohci_soft_td_t *p;\n\n\tfor (; std != stdend; std = p) {\n\t\tp = std->nexttd;\n\t\tohci_free_std(sc, std);\n\t}\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static void",
            "Static ohci_soft_td_t",
            "Static void",
            "ohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));",
            "Static void",
            "ohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "ohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));",
            "Static void",
            "ohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));",
            "Static ohci_soft_td_t",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "ohci_rhsc_able __P((ohci_softc_t *, int));",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
            "Static int",
            "ohci_intr1 __P((ohci_softc_t *));",
            "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nStatic ohci_soft_td_t;\nStatic void;\nohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));\nStatic void;\nohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));\nStatic void;\nohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));\nStatic ohci_soft_td_t;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nohci_rhsc_able __P((ohci_softc_t *, int));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nStatic int;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nStatic void\nohci_free_std_chain(sc, std, stdend)\n\tohci_softc_t *sc;\n\tohci_soft_td_t *std;\n\tohci_soft_td_t *stdend;\n{\n\tohci_soft_td_t *p;\n\n\tfor (; std != stdend; std = p) {\n\t\tp = std->nexttd;\n\t\tohci_free_std(sc, std);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "15",
            "(\"ohci_process_done: error cc=%d (%s)\\n\",\n\t\t\t  OHCI_TD_GET_CC(le32toh(std->td.td_flags)),\n\t\t\t  ohci_cc_strs[OHCI_TD_GET_CC(le32toh(std->td.td_flags))])"
          ],
          "line": 1273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OHCI_TD_GET_CC",
          "args": [
            "le32toh(std->td.td_flags)"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "std->td.td_flags"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OHCI_TD_GET_CC",
          "args": [
            "le32toh(std->td.td_flags)"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "std->td.td_flags"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "10",
            "(\"ohci_process_done: len=%d, flags=0x%x\\n\",\n\t\t\t\t      len, std->flags)"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "std->td.td_cbp"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "std->td.td_be"
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OHCI_TD_GET_CC",
          "args": [
            "le32toh(std->td.td_flags)"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "std->td.td_flags"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_uncallout",
          "args": [
            "xfer->timeout_handle",
            "ohci_timeout",
            "xfer"
          ],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ohci_process_done: cancel/timeout %p\\n\",\n\t\t\t\t xfer)"
          ],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "10",
            "(\"ohci_process_done: std=%p xfer=%p hcpriv=%p\\n\",\n\t\t\t\tstd, xfer, xfer ? xfer->hcpriv : 0)"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ohci_dump_tds",
          "args": [
            "sdone"
          ],
          "line": 1224
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_dump_tds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "1787-1793",
          "snippet": "void\nohci_dump_tds(std)\n\tohci_soft_td_t *std;\n{\n\tfor (; std; std = std->nexttd)\n\t\tohci_dump_td(std);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static ohci_soft_td_t",
            "ohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));",
            "ohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));",
            "ohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));",
            "ohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));",
            "Static ohci_soft_td_t"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_td_t;\nohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));\nohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));\nohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));\nohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));\nStatic ohci_soft_td_t;\n\nvoid\nohci_dump_tds(std)\n\tohci_soft_td_t *std;\n{\n\tfor (; std; std = std->nexttd)\n\t\tohci_dump_td(std);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ohci_process_done: TD done:\\n\")"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "10",
            "(\"ohci_process_done: sdone=%p sidone=%p\\n\", sdone, sidone)"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splhardusb",
          "args": [],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_td_t;\nohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));\nStatic ohci_soft_itd_t;\nohci_free_sitd __P((ohci_softc_t *,ohci_soft_itd_t *));\nohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));\nohci_poll __P((struct usbd_bus *));\nohci_softintr __P((struct usbd_bus *));\nohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));\nohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));\nohci_device_request __P((usbd_xfer_handle xfer));\nohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));\nohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));\nStatic ohci_soft_td_t;\nohci_hash_add_itd __P((ohci_softc_t *, \n\t\t\t    ohci_soft_itd_t *));\nohci_hash_rem_itd __P((ohci_softc_t *,\n\t\t\t    ohci_soft_itd_t *));\nStatic ohci_soft_itd_t;\nohci_setup_isoc __P((usbd_pipe_handle pipe));\nohci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_xfer_handle;\nohci_allocx __P((struct usbd_bus *));\nohci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nohci_root_ctrl_transfer __P((usbd_xfer_handle));\nohci_root_ctrl_start __P((usbd_xfer_handle));\nohci_root_ctrl_abort __P((usbd_xfer_handle));\nohci_root_ctrl_done  __P((usbd_xfer_handle));\nohci_root_intr_transfer __P((usbd_xfer_handle));\nohci_root_intr_start __P((usbd_xfer_handle));\nohci_root_intr_abort __P((usbd_xfer_handle));\nohci_root_intr_done  __P((usbd_xfer_handle));\nohci_device_ctrl_transfer __P((usbd_xfer_handle));\nohci_device_ctrl_start __P((usbd_xfer_handle));\nohci_device_ctrl_abort __P((usbd_xfer_handle));\nohci_device_ctrl_done  __P((usbd_xfer_handle));\nohci_device_bulk_transfer __P((usbd_xfer_handle));\nohci_device_bulk_start __P((usbd_xfer_handle));\nohci_device_bulk_abort __P((usbd_xfer_handle));\nohci_device_bulk_done  __P((usbd_xfer_handle));\nohci_device_intr_transfer __P((usbd_xfer_handle));\nohci_device_intr_start __P((usbd_xfer_handle));\nohci_device_intr_abort __P((usbd_xfer_handle));\nohci_device_intr_done  __P((usbd_xfer_handle));\nohci_device_isoc_transfer __P((usbd_xfer_handle));\nohci_device_isoc_start __P((usbd_xfer_handle));\nohci_device_isoc_abort __P((usbd_xfer_handle));\nohci_device_isoc_done  __P((usbd_xfer_handle));\nohci_rhsc_able __P((ohci_softc_t *, int));\nohci_abort_xfer __P((usbd_xfer_handle xfer,\n\t\t\t    usbd_status status));\nohci_device_clear_toggle __P((usbd_pipe_handle pipe));\nohci_noop __P((usbd_pipe_handle pipe));\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nvoid\nohci_softintr(bus)\n\tstruct usbd_bus *bus;\n{\n\tohci_softc_t *sc = (ohci_softc_t *)bus;\n\tohci_soft_itd_t *sitd, *sidone, *sitdnext;\n\tohci_soft_td_t  *std,  *sdone,  *stdnext;\n\tusbd_xfer_handle xfer;\n\tint len, cc, s;\n\n\tsc->sc_bus.intr_context++;\n\n\ts = splhardusb();\n\tsdone = sc->sc_sdone;\n\tsc->sc_sdone = NULL;\n\tsidone = sc->sc_sidone;\n\tsc->sc_sidone = NULL;\n\tsplx(s);\n\n\tDPRINTFN(10,(\"ohci_process_done: sdone=%p sidone=%p\\n\", sdone, sidone));\n\n#ifdef OHCI_DEBUG\n\tif (ohcidebug > 10) {\n\t\tDPRINTF((\"ohci_process_done: TD done:\\n\"));\n\t\tohci_dump_tds(sdone);\n\t}\n#endif\n\n\tfor (std = sdone; std; std = stdnext) {\n\t\txfer = std->xfer;\n\t\tstdnext = std->dnext;\n\t\tDPRINTFN(10, (\"ohci_process_done: std=%p xfer=%p hcpriv=%p\\n\",\n\t\t\t\tstd, xfer, xfer ? xfer->hcpriv : 0));\n\t\tif (xfer == NULL) {\n\t\t\t/* xfer == NULL: There seems to be no xfer associated\n\t\t\t * with this TD. It is tailp that happened to end up on\n\t\t\t * the done queue.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\t\tif (xfer->status == USBD_CANCELLED ||\n\t\t    xfer->status == USBD_TIMEOUT) {\n\t\t\tDPRINTF((\"ohci_process_done: cancel/timeout %p\\n\",\n\t\t\t\t xfer));\n\t\t\t/* Handled by abort routine. */\n\t\t\tcontinue;\n\t\t}\n\t\tusb_uncallout(xfer->timeout_handle, ohci_timeout, xfer);\n\t\tcc = OHCI_TD_GET_CC(le32toh(std->td.td_flags));\n\t\tif (cc == OHCI_CC_NO_ERROR) {\n\t\t\tlen = std->len;\n\t\t\tif (std->td.td_cbp != 0)\n\t\t\t\tlen -= le32toh(std->td.td_be) -\n\t\t\t\t       le32toh(std->td.td_cbp) + 1;\n\t\t\tDPRINTFN(10, (\"ohci_process_done: len=%d, flags=0x%x\\n\",\n\t\t\t\t      len, std->flags));\n\t\t\tif (std->flags & OHCI_ADD_LEN)\n\t\t\t\txfer->actlen += len;\n\t\t\tif (std->flags & OHCI_CALL_DONE) {\n\t\t\t\txfer->status = USBD_NORMAL_COMPLETION;\n\t\t\t\tusb_transfer_complete(xfer);\n\t\t\t}\n\t\t\tohci_free_std(sc, std);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Endpoint is halted.  First unlink all the TDs\n\t\t\t * belonging to the failed transfer, and then restart\n\t\t\t * the endpoint.\n\t\t\t */\n\t\t\tohci_soft_td_t *p, *n;\n\t\t\tstruct ohci_pipe *opipe = \n\t\t\t\t(struct ohci_pipe *)xfer->pipe;\n\n\t\t\tDPRINTFN(15,(\"ohci_process_done: error cc=%d (%s)\\n\",\n\t\t\t  OHCI_TD_GET_CC(le32toh(std->td.td_flags)),\n\t\t\t  ohci_cc_strs[OHCI_TD_GET_CC(le32toh(std->td.td_flags))]));\n\n\t\t\t/* remove TDs */\n\t\t\tfor (p = std; p->xfer == xfer; p = n) {\n\t\t\t\tn = p->nexttd;\n\t\t\t\tohci_free_std(sc, p);\n\t\t\t}\n\n\t\t\t/* clear halt */\n\t\t\topipe->sed->ed.ed_headp = htole32(p->physaddr);\n\t\t\tOWRITE4(sc, OHCI_COMMAND_STATUS, OHCI_CLF);\n\n\t\t\tif (cc == OHCI_CC_STALL)\n\t\t\t\txfer->status = USBD_STALLED;\n\t\t\telse\n\t\t\t\txfer->status = USBD_IOERROR;\n\t\t\tusb_transfer_complete(xfer);\n\t\t}\n\t}\n\n#ifdef OHCI_DEBUG\n\tif (ohcidebug > 10) {\n\t\tDPRINTF((\"ohci_process_done: ITD done:\\n\"));\n\t\tohci_dump_itds(sidone);\n\t}\n#endif\n\n\tfor (sitd = sidone; sitd != NULL; sitd = sitdnext) {\n\t\txfer = sitd->xfer;\n\t\tsitdnext = sitd->dnext;\n\t\tDPRINTFN(1, (\"ohci_process_done: sitd=%p xfer=%p hcpriv=%p\\n\",\n\t\t\t     sitd, xfer, xfer ? xfer->hcpriv : 0));\n\t\tif (xfer == NULL)\n\t\t\tcontinue;\n\t\tif (xfer->status == USBD_CANCELLED ||\n\t\t    xfer->status == USBD_TIMEOUT) {\n\t\t\tDPRINTF((\"ohci_process_done: cancel/timeout %p\\n\",\n\t\t\t\t xfer));\n\t\t\t/* Handled by abort routine. */\n\t\t\tcontinue;\n\t\t}\n#ifdef DIAGNOSTIC\n\t\tif (sitd->isdone)\n\t\t\tprintf(\"ohci_softintr: sitd=%p is done\\n\", sitd);\n\t\tsitd->isdone = 1;\n#endif\n\t\tcc = OHCI_ITD_GET_CC(le32toh(sitd->itd.itd_flags));\n\t\tif (cc == OHCI_CC_NO_ERROR) {\n\t\t\t/* XXX compute length for input */\n\t\t\tstruct ohci_pipe *opipe = \n\t\t\t\t(struct ohci_pipe *)xfer->pipe;\n\t\t\tif (sitd->flags & OHCI_CALL_DONE) {\n\t\t\t\topipe->u.iso.inuse -= xfer->nframes;\n\t\t\t\t/* XXX xfer->actlen = actlen; */\n\t\t\t\txfer->status = USBD_NORMAL_COMPLETION;\n\t\t\t\tusb_transfer_complete(xfer);\n\t\t\t}\n\t\t} else {\n\t\t\t/* XXX Do more */\n\t\t\txfer->status = USBD_IOERROR;\n\t\t\tusb_transfer_complete(xfer);\n\t\t}\n\t}\n\n\tsc->sc_bus.intr_context--;\n}"
  },
  {
    "function_name": "baaz",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "1198-1198",
    "snippet": "void baaz(void) {}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void baaz(void);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid baaz(void);\n\nvoid baaz(void) {}"
  },
  {
    "function_name": "ohci_add_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "1158-1195",
    "snippet": "void\nohci_add_done(sc, done)\n\tohci_softc_t *sc;\n\tohci_physaddr_t done;\n{\n\tohci_soft_itd_t *sitd, *sidone, **ip;\n\tohci_soft_td_t  *std,  *sdone,  **p;\n\n\t/* Reverse the done list. */\n\tfor (sdone = NULL, sidone = NULL; done != 0; ) {\n\t\tstd = ohci_hash_find_td(sc, done);\n\t\tif (std != NULL) {\n\t\t\tstd->dnext = sdone;\n\t\t\tdone = le32toh(std->td.td_nexttd);\n\t\t\tsdone = std;\n\t\t\tDPRINTFN(10,(\"add TD %p\\n\", std));\n\t\t\tcontinue;\n\t\t}\n\t\tsitd = ohci_hash_find_itd(sc, done);\n\t\tif (sitd != NULL) {\n\t\t\tsitd->dnext = sidone;\n\t\t\tdone = le32toh(sitd->itd.itd_nextitd);\n\t\t\tsidone = sitd;\n\t\t\tDPRINTFN(5,(\"add ITD %p\\n\", sitd));\n\t\t\tcontinue;\n\t\t}\n\t\tpanic(\"ohci_add_done: addr 0x%08lx not found\\n\", (u_long)done);\n\t}\n\n\t/* sdone & sidone now hold the done lists. */\n\t/* Put them on the already processed lists. */\n\tfor (p = &sc->sc_sdone; *p != NULL; p = &(*p)->dnext)\n\t\t;\n\t*p = sdone;\n\tfor (ip = &sc->sc_sidone; *ip != NULL; ip = &(*ip)->dnext)\n\t\t;\n\t*ip = sidone;\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static ohci_soft_td_t",
      "ohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));",
      "Static ohci_soft_itd_t",
      "ohci_free_sitd __P((ohci_softc_t *,ohci_soft_itd_t *));",
      "ohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));",
      "ohci_add_done __P((ohci_softc_t *, ohci_physaddr_t));",
      "ohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));",
      "ohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));",
      "Static ohci_soft_td_t",
      "ohci_hash_add_itd __P((ohci_softc_t *, \n\t\t\t    ohci_soft_itd_t *));",
      "ohci_hash_rem_itd __P((ohci_softc_t *,\n\t\t\t    ohci_soft_itd_t *));",
      "Static ohci_soft_itd_t",
      "ohci_rhsc_able __P((ohci_softc_t *, int));",
      "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
      "ohci_intr1 __P((ohci_softc_t *));",
      "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"ohci_add_done: addr 0x%08lx not found\\n\"",
            "(u_long)done"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"add ITD %p\\n\", sitd)"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "sitd->itd.itd_nextitd"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ohci_hash_find_itd",
          "args": [
            "sc",
            "done"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "10",
            "(\"add TD %p\\n\", std)"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "std->td.td_nexttd"
          ],
          "line": 1171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ohci_hash_find_td",
          "args": [
            "sc",
            "done"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_td_t;\nohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));\nStatic ohci_soft_itd_t;\nohci_free_sitd __P((ohci_softc_t *,ohci_soft_itd_t *));\nohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));\nohci_add_done __P((ohci_softc_t *, ohci_physaddr_t));\nohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));\nohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));\nStatic ohci_soft_td_t;\nohci_hash_add_itd __P((ohci_softc_t *, \n\t\t\t    ohci_soft_itd_t *));\nohci_hash_rem_itd __P((ohci_softc_t *,\n\t\t\t    ohci_soft_itd_t *));\nStatic ohci_soft_itd_t;\nohci_rhsc_able __P((ohci_softc_t *, int));\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nvoid\nohci_add_done(sc, done)\n\tohci_softc_t *sc;\n\tohci_physaddr_t done;\n{\n\tohci_soft_itd_t *sitd, *sidone, **ip;\n\tohci_soft_td_t  *std,  *sdone,  **p;\n\n\t/* Reverse the done list. */\n\tfor (sdone = NULL, sidone = NULL; done != 0; ) {\n\t\tstd = ohci_hash_find_td(sc, done);\n\t\tif (std != NULL) {\n\t\t\tstd->dnext = sdone;\n\t\t\tdone = le32toh(std->td.td_nexttd);\n\t\t\tsdone = std;\n\t\t\tDPRINTFN(10,(\"add TD %p\\n\", std));\n\t\t\tcontinue;\n\t\t}\n\t\tsitd = ohci_hash_find_itd(sc, done);\n\t\tif (sitd != NULL) {\n\t\t\tsitd->dnext = sidone;\n\t\t\tdone = le32toh(sitd->itd.itd_nextitd);\n\t\t\tsidone = sitd;\n\t\t\tDPRINTFN(5,(\"add ITD %p\\n\", sitd));\n\t\t\tcontinue;\n\t\t}\n\t\tpanic(\"ohci_add_done: addr 0x%08lx not found\\n\", (u_long)done);\n\t}\n\n\t/* sdone & sidone now hold the done lists. */\n\t/* Put them on the already processed lists. */\n\tfor (p = &sc->sc_sdone; *p != NULL; p = &(*p)->dnext)\n\t\t;\n\t*p = sdone;\n\tfor (ip = &sc->sc_sidone; *ip != NULL; ip = &(*ip)->dnext)\n\t\t;\n\t*ip = sidone;\n}"
  },
  {
    "function_name": "ohci_rhsc_able",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "1122-1135",
    "snippet": "void\nohci_rhsc_able(sc, on)\n\tohci_softc_t *sc;\n\tint on;\n{\n\tDPRINTFN(4, (\"ohci_rhsc_able: on=%d\\n\", on));\n\tif (on) {\n\t\tsc->sc_eintrs |= OHCI_RHSC;\n\t\tOWRITE4(sc, OHCI_INTERRUPT_ENABLE, OHCI_RHSC);\n\t} else {\n\t\tsc->sc_eintrs &= ~OHCI_RHSC;\n\t\tOWRITE4(sc, OHCI_INTERRUPT_DISABLE, OHCI_RHSC);\n\t}\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "ohci_rhsc_able __P((ohci_softc_t *, int));",
      "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
      "ohci_intr1 __P((ohci_softc_t *));",
      "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "OWRITE4",
          "args": [
            "sc",
            "OHCI_INTERRUPT_DISABLE",
            "OHCI_RHSC"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OWRITE4",
          "args": [
            "sc",
            "OHCI_INTERRUPT_ENABLE",
            "OHCI_RHSC"
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "4",
            "(\"ohci_rhsc_able: on=%d\\n\", on)"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nohci_rhsc_able __P((ohci_softc_t *, int));\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nvoid\nohci_rhsc_able(sc, on)\n\tohci_softc_t *sc;\n\tint on;\n{\n\tDPRINTFN(4, (\"ohci_rhsc_able: on=%d\\n\", on));\n\tif (on) {\n\t\tsc->sc_eintrs |= OHCI_RHSC;\n\t\tOWRITE4(sc, OHCI_INTERRUPT_ENABLE, OHCI_RHSC);\n\t} else {\n\t\tsc->sc_eintrs &= ~OHCI_RHSC;\n\t\tOWRITE4(sc, OHCI_INTERRUPT_DISABLE, OHCI_RHSC);\n\t}\n}"
  },
  {
    "function_name": "ohci_intr1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "1041-1120",
    "snippet": "Static int\nohci_intr1(sc)\n\tohci_softc_t *sc;\n{\n\tu_int32_t intrs, eintrs;\n\tohci_physaddr_t done;\n\n\t/* In case the interrupt occurs before initialization has completed. */\n\tif (sc == NULL || sc->sc_hcca == NULL) {\n#ifdef DIAGNOSTIC\n\t\tprintf(\"ohci_intr: sc->sc_hcca == NULL\\n\");\n#endif\n\t\treturn (0);\n\t}\n\n        intrs = 0;\n\tdone = le32toh(sc->sc_hcca->hcca_done_head);\n\tif (done != 0) {\n\t\tif (done & ~OHCI_DONE_INTRS)\n\t\t\tintrs = OHCI_WDH;\n\t\tif (done & OHCI_DONE_INTRS)\n\t\t\tintrs |= OREAD4(sc, OHCI_INTERRUPT_STATUS);\n\t} else\n\t\tintrs = OREAD4(sc, OHCI_INTERRUPT_STATUS);\n\n\tif (!intrs)\n\t\treturn (0);\n\n\tintrs &= ~OHCI_MIE;\n\tOWRITE4(sc, OHCI_INTERRUPT_STATUS, intrs); /* Acknowledge */\n\teintrs = intrs & sc->sc_eintrs;\n\tif (!eintrs)\n\t\treturn (0);\n\n\tsc->sc_bus.intr_context++;\n\tsc->sc_bus.no_intrs++;\n\tDPRINTFN(7, (\"ohci_intr: sc=%p intrs=0x%x(0x%x) eintrs=0x%x\\n\", \n\t\t     sc, (u_int)intrs, OREAD4(sc, OHCI_INTERRUPT_STATUS),\n\t\t     (u_int)eintrs));\n\n\tif (eintrs & OHCI_SO) {\n\t\tprintf(\"%s: scheduling overrun\\n\",USBDEVNAME(sc->sc_bus.bdev));\n\t\t/* XXX do what */\n\t\tintrs &= ~OHCI_SO;\n\t}\n\tif (eintrs & OHCI_WDH) {\n\t\tohci_add_done(sc, done &~ OHCI_DONE_INTRS);\n\t\tsc->sc_hcca->hcca_done_head = 0;\n\t\tusb_schedsoftintr(&sc->sc_bus);\n\t\tintrs &= ~OHCI_WDH;\n\t}\n\tif (eintrs & OHCI_RD) {\n\t\tprintf(\"%s: resume detect\\n\", USBDEVNAME(sc->sc_bus.bdev));\n\t\t/* XXX process resume detect */\n\t}\n\tif (eintrs & OHCI_UE) {\n\t\tprintf(\"%s: unrecoverable error, controller halted\\n\",\n\t\t       USBDEVNAME(sc->sc_bus.bdev));\n\t\tOWRITE4(sc, OHCI_CONTROL, OHCI_HCFS_RESET);\n\t\t/* XXX what else */\n\t}\n\tif (eintrs & OHCI_RHSC) {\n\t\tohci_rhsc(sc, sc->sc_intrxfer);\n\t\tintrs &= ~OHCI_RHSC;\n\n\t\t/* \n\t\t * Disable RHSC interrupt for now, because it will be\n\t\t * on until the port has been reset.\n\t\t */\n\t\tohci_rhsc_able(sc, 0);\n\t}\n\n\tsc->sc_bus.intr_context--;\n\n\t/* Block unprocessed interrupts. XXX */\n\tOWRITE4(sc, OHCI_INTERRUPT_DISABLE, intrs);\n\tsc->sc_eintrs &= ~intrs;\n\n\treturn (1);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "ohci_add_done __P((ohci_softc_t *, ohci_physaddr_t));",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "ohci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "ohci_rhsc_able __P((ohci_softc_t *, int));",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
      "Static int",
      "ohci_intr1 __P((ohci_softc_t *));",
      "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "OWRITE4",
          "args": [
            "sc",
            "OHCI_INTERRUPT_DISABLE",
            "intrs"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ohci_rhsc_able",
          "args": [
            "sc",
            "0"
          ],
          "line": 1110
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_rhsc_able",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "1122-1135",
          "snippet": "void\nohci_rhsc_able(sc, on)\n\tohci_softc_t *sc;\n\tint on;\n{\n\tDPRINTFN(4, (\"ohci_rhsc_able: on=%d\\n\", on));\n\tif (on) {\n\t\tsc->sc_eintrs |= OHCI_RHSC;\n\t\tOWRITE4(sc, OHCI_INTERRUPT_ENABLE, OHCI_RHSC);\n\t} else {\n\t\tsc->sc_eintrs &= ~OHCI_RHSC;\n\t\tOWRITE4(sc, OHCI_INTERRUPT_DISABLE, OHCI_RHSC);\n\t}\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "ohci_rhsc_able __P((ohci_softc_t *, int));",
            "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
            "ohci_intr1 __P((ohci_softc_t *));",
            "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nohci_rhsc_able __P((ohci_softc_t *, int));\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nvoid\nohci_rhsc_able(sc, on)\n\tohci_softc_t *sc;\n\tint on;\n{\n\tDPRINTFN(4, (\"ohci_rhsc_able: on=%d\\n\", on));\n\tif (on) {\n\t\tsc->sc_eintrs |= OHCI_RHSC;\n\t\tOWRITE4(sc, OHCI_INTERRUPT_ENABLE, OHCI_RHSC);\n\t} else {\n\t\tsc->sc_eintrs &= ~OHCI_RHSC;\n\t\tOWRITE4(sc, OHCI_INTERRUPT_DISABLE, OHCI_RHSC);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ohci_rhsc",
          "args": [
            "sc",
            "sc->sc_intrxfer"
          ],
          "line": 1103
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_rhsc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "1411-1446",
          "snippet": "void\nohci_rhsc(sc, xfer)\n\tohci_softc_t *sc;\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe;\n\tstruct ohci_pipe *opipe;\n\tu_char *p;\n\tint i, m;\n\tint hstatus;\n\n\thstatus = OREAD4(sc, OHCI_RH_STATUS);\n\tDPRINTF((\"ohci_rhsc: sc=%p xfer=%p hstatus=0x%08x\\n\", \n\t\t sc, xfer, hstatus));\n\n\tif (xfer == NULL) {\n\t\t/* Just ignore the change. */\n\t\treturn;\n\t}\n\n\tpipe = xfer->pipe;\n\topipe = (struct ohci_pipe *)pipe;\n\n\tp = KERNADDR(&xfer->dmabuf);\n\tm = min(sc->sc_noport, xfer->length * 8 - 1);\n\tmemset(p, 0, xfer->length);\n\tfor (i = 1; i <= m; i++) {\n\t\tif (OREAD4(sc, OHCI_RH_PORT_STATUS(i)) >> 16)\n\t\t\tp[i/8] |= 1 << (i%8);\n\t}\n\tDPRINTF((\"ohci_rhsc: change=0x%02x\\n\", *p));\n\txfer->actlen = xfer->length;\n\txfer->status = USBD_NORMAL_COMPLETION;\n\n\tusb_transfer_complete(xfer);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "ohci_open __P((usbd_pipe_handle));",
            "ohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));",
            "ohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));",
            "ohci_device_request __P((usbd_xfer_handle xfer));",
            "ohci_setup_isoc __P((usbd_pipe_handle pipe));",
            "ohci_device_isoc_enter __P((usbd_xfer_handle));",
            "Static usbd_xfer_handle",
            "ohci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
            "ohci_root_ctrl_transfer __P((usbd_xfer_handle));",
            "ohci_root_ctrl_start __P((usbd_xfer_handle));",
            "ohci_root_ctrl_abort __P((usbd_xfer_handle));",
            "ohci_root_ctrl_close __P((usbd_pipe_handle));",
            "ohci_root_ctrl_done  __P((usbd_xfer_handle));",
            "ohci_root_intr_transfer __P((usbd_xfer_handle));",
            "ohci_root_intr_start __P((usbd_xfer_handle));",
            "ohci_root_intr_abort __P((usbd_xfer_handle));",
            "ohci_root_intr_close __P((usbd_pipe_handle));",
            "ohci_root_intr_done  __P((usbd_xfer_handle));",
            "ohci_device_ctrl_transfer __P((usbd_xfer_handle));",
            "ohci_device_ctrl_start __P((usbd_xfer_handle));",
            "ohci_device_ctrl_abort __P((usbd_xfer_handle));",
            "ohci_device_ctrl_close __P((usbd_pipe_handle));",
            "ohci_device_ctrl_done  __P((usbd_xfer_handle));",
            "ohci_device_bulk_transfer __P((usbd_xfer_handle));",
            "ohci_device_bulk_start __P((usbd_xfer_handle));",
            "ohci_device_bulk_abort __P((usbd_xfer_handle));",
            "ohci_device_bulk_close __P((usbd_pipe_handle));",
            "ohci_device_bulk_done  __P((usbd_xfer_handle));",
            "ohci_device_intr_transfer __P((usbd_xfer_handle));",
            "ohci_device_intr_start __P((usbd_xfer_handle));",
            "ohci_device_intr_abort __P((usbd_xfer_handle));",
            "ohci_device_intr_close __P((usbd_pipe_handle));",
            "ohci_device_intr_done  __P((usbd_xfer_handle));",
            "ohci_device_isoc_transfer __P((usbd_xfer_handle));",
            "ohci_device_isoc_start __P((usbd_xfer_handle));",
            "ohci_device_isoc_abort __P((usbd_xfer_handle));",
            "ohci_device_isoc_close __P((usbd_pipe_handle));",
            "ohci_device_isoc_done  __P((usbd_xfer_handle));",
            "ohci_rhsc_able __P((ohci_softc_t *, int));",
            "ohci_abort_xfer __P((usbd_xfer_handle xfer,\n\t\t\t    usbd_status status));",
            "ohci_device_clear_toggle __P((usbd_pipe_handle pipe));",
            "ohci_noop __P((usbd_pipe_handle pipe));",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "Static struct",
            "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
            "ohci_intr1 __P((ohci_softc_t *));",
            "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nohci_open __P((usbd_pipe_handle));\nohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));\nohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));\nohci_device_request __P((usbd_xfer_handle xfer));\nohci_setup_isoc __P((usbd_pipe_handle pipe));\nohci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_xfer_handle;\nohci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nohci_root_ctrl_transfer __P((usbd_xfer_handle));\nohci_root_ctrl_start __P((usbd_xfer_handle));\nohci_root_ctrl_abort __P((usbd_xfer_handle));\nohci_root_ctrl_close __P((usbd_pipe_handle));\nohci_root_ctrl_done  __P((usbd_xfer_handle));\nohci_root_intr_transfer __P((usbd_xfer_handle));\nohci_root_intr_start __P((usbd_xfer_handle));\nohci_root_intr_abort __P((usbd_xfer_handle));\nohci_root_intr_close __P((usbd_pipe_handle));\nohci_root_intr_done  __P((usbd_xfer_handle));\nohci_device_ctrl_transfer __P((usbd_xfer_handle));\nohci_device_ctrl_start __P((usbd_xfer_handle));\nohci_device_ctrl_abort __P((usbd_xfer_handle));\nohci_device_ctrl_close __P((usbd_pipe_handle));\nohci_device_ctrl_done  __P((usbd_xfer_handle));\nohci_device_bulk_transfer __P((usbd_xfer_handle));\nohci_device_bulk_start __P((usbd_xfer_handle));\nohci_device_bulk_abort __P((usbd_xfer_handle));\nohci_device_bulk_close __P((usbd_pipe_handle));\nohci_device_bulk_done  __P((usbd_xfer_handle));\nohci_device_intr_transfer __P((usbd_xfer_handle));\nohci_device_intr_start __P((usbd_xfer_handle));\nohci_device_intr_abort __P((usbd_xfer_handle));\nohci_device_intr_close __P((usbd_pipe_handle));\nohci_device_intr_done  __P((usbd_xfer_handle));\nohci_device_isoc_transfer __P((usbd_xfer_handle));\nohci_device_isoc_start __P((usbd_xfer_handle));\nohci_device_isoc_abort __P((usbd_xfer_handle));\nohci_device_isoc_close __P((usbd_pipe_handle));\nohci_device_isoc_done  __P((usbd_xfer_handle));\nohci_rhsc_able __P((ohci_softc_t *, int));\nohci_abort_xfer __P((usbd_xfer_handle xfer,\n\t\t\t    usbd_status status));\nohci_device_clear_toggle __P((usbd_pipe_handle pipe));\nohci_noop __P((usbd_pipe_handle pipe));\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nvoid\nohci_rhsc(sc, xfer)\n\tohci_softc_t *sc;\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe;\n\tstruct ohci_pipe *opipe;\n\tu_char *p;\n\tint i, m;\n\tint hstatus;\n\n\thstatus = OREAD4(sc, OHCI_RH_STATUS);\n\tDPRINTF((\"ohci_rhsc: sc=%p xfer=%p hstatus=0x%08x\\n\", \n\t\t sc, xfer, hstatus));\n\n\tif (xfer == NULL) {\n\t\t/* Just ignore the change. */\n\t\treturn;\n\t}\n\n\tpipe = xfer->pipe;\n\topipe = (struct ohci_pipe *)pipe;\n\n\tp = KERNADDR(&xfer->dmabuf);\n\tm = min(sc->sc_noport, xfer->length * 8 - 1);\n\tmemset(p, 0, xfer->length);\n\tfor (i = 1; i <= m; i++) {\n\t\tif (OREAD4(sc, OHCI_RH_PORT_STATUS(i)) >> 16)\n\t\t\tp[i/8] |= 1 << (i%8);\n\t}\n\tDPRINTF((\"ohci_rhsc: change=0x%02x\\n\", *p));\n\txfer->actlen = xfer->length;\n\txfer->status = USBD_NORMAL_COMPLETION;\n\n\tusb_transfer_complete(xfer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OWRITE4",
          "args": [
            "sc",
            "OHCI_CONTROL",
            "OHCI_HCFS_RESET"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: unrecoverable error, controller halted\\n\"",
            "USBDEVNAME(sc->sc_bus.bdev)"
          ],
          "line": 1097
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_bus.bdev"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_bus.bdev"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_schedsoftintr",
          "args": [
            "&sc->sc_bus"
          ],
          "line": 1089
        },
        "resolved": true,
        "details": {
          "function_name": "usb_schedsoftintr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb.c",
          "lines": "702-707",
          "snippet": "void\nusb_schedsoftintr(bus)\n\tstruct usbd_bus *bus;\n{\n\tbus->methods->soft_intr(bus);\n}",
          "includes": [
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <machine/bus.h>",
            "#include \"usb_if.h\"",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/vnode.h>",
            "#include <sys/select.h>",
            "#include <sys/poll.h>",
            "#include <sys/conf.h>",
            "#include <sys/uio.h>",
            "#include <sys/filio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/proc.h>",
            "#include <sys/kthread.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdivar.h>\n#include <machine/bus.h>\n#include \"usb_if.h\"\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/signalvar.h>\n#include <sys/vnode.h>\n#include <sys/select.h>\n#include <sys/poll.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/filio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/proc.h>\n#include <sys/kthread.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic struct;\nStatic struct;\n\nvoid\nusb_schedsoftintr(bus)\n\tstruct usbd_bus *bus;\n{\n\tbus->methods->soft_intr(bus);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ohci_add_done",
          "args": [
            "sc",
            "done &~ OHCI_DONE_INTRS"
          ],
          "line": 1087
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_add_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "1158-1195",
          "snippet": "void\nohci_add_done(sc, done)\n\tohci_softc_t *sc;\n\tohci_physaddr_t done;\n{\n\tohci_soft_itd_t *sitd, *sidone, **ip;\n\tohci_soft_td_t  *std,  *sdone,  **p;\n\n\t/* Reverse the done list. */\n\tfor (sdone = NULL, sidone = NULL; done != 0; ) {\n\t\tstd = ohci_hash_find_td(sc, done);\n\t\tif (std != NULL) {\n\t\t\tstd->dnext = sdone;\n\t\t\tdone = le32toh(std->td.td_nexttd);\n\t\t\tsdone = std;\n\t\t\tDPRINTFN(10,(\"add TD %p\\n\", std));\n\t\t\tcontinue;\n\t\t}\n\t\tsitd = ohci_hash_find_itd(sc, done);\n\t\tif (sitd != NULL) {\n\t\t\tsitd->dnext = sidone;\n\t\t\tdone = le32toh(sitd->itd.itd_nextitd);\n\t\t\tsidone = sitd;\n\t\t\tDPRINTFN(5,(\"add ITD %p\\n\", sitd));\n\t\t\tcontinue;\n\t\t}\n\t\tpanic(\"ohci_add_done: addr 0x%08lx not found\\n\", (u_long)done);\n\t}\n\n\t/* sdone & sidone now hold the done lists. */\n\t/* Put them on the already processed lists. */\n\tfor (p = &sc->sc_sdone; *p != NULL; p = &(*p)->dnext)\n\t\t;\n\t*p = sdone;\n\tfor (ip = &sc->sc_sidone; *ip != NULL; ip = &(*ip)->dnext)\n\t\t;\n\t*ip = sidone;\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static ohci_soft_td_t",
            "ohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));",
            "Static ohci_soft_itd_t",
            "ohci_free_sitd __P((ohci_softc_t *,ohci_soft_itd_t *));",
            "ohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));",
            "ohci_add_done __P((ohci_softc_t *, ohci_physaddr_t));",
            "ohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));",
            "ohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));",
            "Static ohci_soft_td_t",
            "ohci_hash_add_itd __P((ohci_softc_t *, \n\t\t\t    ohci_soft_itd_t *));",
            "ohci_hash_rem_itd __P((ohci_softc_t *,\n\t\t\t    ohci_soft_itd_t *));",
            "Static ohci_soft_itd_t",
            "ohci_rhsc_able __P((ohci_softc_t *, int));",
            "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
            "ohci_intr1 __P((ohci_softc_t *));",
            "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_td_t;\nohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));\nStatic ohci_soft_itd_t;\nohci_free_sitd __P((ohci_softc_t *,ohci_soft_itd_t *));\nohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));\nohci_add_done __P((ohci_softc_t *, ohci_physaddr_t));\nohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));\nohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));\nStatic ohci_soft_td_t;\nohci_hash_add_itd __P((ohci_softc_t *, \n\t\t\t    ohci_soft_itd_t *));\nohci_hash_rem_itd __P((ohci_softc_t *,\n\t\t\t    ohci_soft_itd_t *));\nStatic ohci_soft_itd_t;\nohci_rhsc_able __P((ohci_softc_t *, int));\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nvoid\nohci_add_done(sc, done)\n\tohci_softc_t *sc;\n\tohci_physaddr_t done;\n{\n\tohci_soft_itd_t *sitd, *sidone, **ip;\n\tohci_soft_td_t  *std,  *sdone,  **p;\n\n\t/* Reverse the done list. */\n\tfor (sdone = NULL, sidone = NULL; done != 0; ) {\n\t\tstd = ohci_hash_find_td(sc, done);\n\t\tif (std != NULL) {\n\t\t\tstd->dnext = sdone;\n\t\t\tdone = le32toh(std->td.td_nexttd);\n\t\t\tsdone = std;\n\t\t\tDPRINTFN(10,(\"add TD %p\\n\", std));\n\t\t\tcontinue;\n\t\t}\n\t\tsitd = ohci_hash_find_itd(sc, done);\n\t\tif (sitd != NULL) {\n\t\t\tsitd->dnext = sidone;\n\t\t\tdone = le32toh(sitd->itd.itd_nextitd);\n\t\t\tsidone = sitd;\n\t\t\tDPRINTFN(5,(\"add ITD %p\\n\", sitd));\n\t\t\tcontinue;\n\t\t}\n\t\tpanic(\"ohci_add_done: addr 0x%08lx not found\\n\", (u_long)done);\n\t}\n\n\t/* sdone & sidone now hold the done lists. */\n\t/* Put them on the already processed lists. */\n\tfor (p = &sc->sc_sdone; *p != NULL; p = &(*p)->dnext)\n\t\t;\n\t*p = sdone;\n\tfor (ip = &sc->sc_sidone; *ip != NULL; ip = &(*ip)->dnext)\n\t\t;\n\t*ip = sidone;\n}"
        }
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_bus.bdev"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "7",
            "(\"ohci_intr: sc=%p intrs=0x%x(0x%x) eintrs=0x%x\\n\", \n\t\t     sc, (u_int)intrs, OREAD4(sc, OHCI_INTERRUPT_STATUS),\n\t\t     (u_int)eintrs)"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OREAD4",
          "args": [
            "sc",
            "OHCI_INTERRUPT_STATUS"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OWRITE4",
          "args": [
            "sc",
            "OHCI_INTERRUPT_STATUS",
            "intrs"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OREAD4",
          "args": [
            "sc",
            "OHCI_INTERRUPT_STATUS"
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OREAD4",
          "args": [
            "sc",
            "OHCI_INTERRUPT_STATUS"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "sc->sc_hcca->hcca_done_head"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_add_done __P((ohci_softc_t *, ohci_physaddr_t));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nohci_rhsc_able __P((ohci_softc_t *, int));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nStatic int;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nStatic int\nohci_intr1(sc)\n\tohci_softc_t *sc;\n{\n\tu_int32_t intrs, eintrs;\n\tohci_physaddr_t done;\n\n\t/* In case the interrupt occurs before initialization has completed. */\n\tif (sc == NULL || sc->sc_hcca == NULL) {\n#ifdef DIAGNOSTIC\n\t\tprintf(\"ohci_intr: sc->sc_hcca == NULL\\n\");\n#endif\n\t\treturn (0);\n\t}\n\n        intrs = 0;\n\tdone = le32toh(sc->sc_hcca->hcca_done_head);\n\tif (done != 0) {\n\t\tif (done & ~OHCI_DONE_INTRS)\n\t\t\tintrs = OHCI_WDH;\n\t\tif (done & OHCI_DONE_INTRS)\n\t\t\tintrs |= OREAD4(sc, OHCI_INTERRUPT_STATUS);\n\t} else\n\t\tintrs = OREAD4(sc, OHCI_INTERRUPT_STATUS);\n\n\tif (!intrs)\n\t\treturn (0);\n\n\tintrs &= ~OHCI_MIE;\n\tOWRITE4(sc, OHCI_INTERRUPT_STATUS, intrs); /* Acknowledge */\n\teintrs = intrs & sc->sc_eintrs;\n\tif (!eintrs)\n\t\treturn (0);\n\n\tsc->sc_bus.intr_context++;\n\tsc->sc_bus.no_intrs++;\n\tDPRINTFN(7, (\"ohci_intr: sc=%p intrs=0x%x(0x%x) eintrs=0x%x\\n\", \n\t\t     sc, (u_int)intrs, OREAD4(sc, OHCI_INTERRUPT_STATUS),\n\t\t     (u_int)eintrs));\n\n\tif (eintrs & OHCI_SO) {\n\t\tprintf(\"%s: scheduling overrun\\n\",USBDEVNAME(sc->sc_bus.bdev));\n\t\t/* XXX do what */\n\t\tintrs &= ~OHCI_SO;\n\t}\n\tif (eintrs & OHCI_WDH) {\n\t\tohci_add_done(sc, done &~ OHCI_DONE_INTRS);\n\t\tsc->sc_hcca->hcca_done_head = 0;\n\t\tusb_schedsoftintr(&sc->sc_bus);\n\t\tintrs &= ~OHCI_WDH;\n\t}\n\tif (eintrs & OHCI_RD) {\n\t\tprintf(\"%s: resume detect\\n\", USBDEVNAME(sc->sc_bus.bdev));\n\t\t/* XXX process resume detect */\n\t}\n\tif (eintrs & OHCI_UE) {\n\t\tprintf(\"%s: unrecoverable error, controller halted\\n\",\n\t\t       USBDEVNAME(sc->sc_bus.bdev));\n\t\tOWRITE4(sc, OHCI_CONTROL, OHCI_HCFS_RESET);\n\t\t/* XXX what else */\n\t}\n\tif (eintrs & OHCI_RHSC) {\n\t\tohci_rhsc(sc, sc->sc_intrxfer);\n\t\tintrs &= ~OHCI_RHSC;\n\n\t\t/* \n\t\t * Disable RHSC interrupt for now, because it will be\n\t\t * on until the port has been reset.\n\t\t */\n\t\tohci_rhsc_able(sc, 0);\n\t}\n\n\tsc->sc_bus.intr_context--;\n\n\t/* Block unprocessed interrupts. XXX */\n\tOWRITE4(sc, OHCI_INTERRUPT_DISABLE, intrs);\n\tsc->sc_eintrs &= ~intrs;\n\n\treturn (1);\n}"
  },
  {
    "function_name": "ohci_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "1024-1039",
    "snippet": "int\nohci_intr(p)\n\tvoid *p;\n{\n\tohci_softc_t *sc = p;\n\n\t/* If we get an interrupt while polling, then just ignore it. */\n\tif (sc->sc_bus.use_polling) {\n#ifdef DIAGNOSTIC\n\t\tprintf(\"ohci_intr: ignored interrupt while polling\\n\");\n#endif\n\t\treturn (0);\n\t}\n\n\treturn (ohci_intr1(sc)); \n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "ohci_rhsc_able __P((ohci_softc_t *, int));",
      "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
      "ohci_intr1 __P((ohci_softc_t *));",
      "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ohci_intr1",
          "args": [
            "sc"
          ],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_intr1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "1041-1120",
          "snippet": "Static int\nohci_intr1(sc)\n\tohci_softc_t *sc;\n{\n\tu_int32_t intrs, eintrs;\n\tohci_physaddr_t done;\n\n\t/* In case the interrupt occurs before initialization has completed. */\n\tif (sc == NULL || sc->sc_hcca == NULL) {\n#ifdef DIAGNOSTIC\n\t\tprintf(\"ohci_intr: sc->sc_hcca == NULL\\n\");\n#endif\n\t\treturn (0);\n\t}\n\n        intrs = 0;\n\tdone = le32toh(sc->sc_hcca->hcca_done_head);\n\tif (done != 0) {\n\t\tif (done & ~OHCI_DONE_INTRS)\n\t\t\tintrs = OHCI_WDH;\n\t\tif (done & OHCI_DONE_INTRS)\n\t\t\tintrs |= OREAD4(sc, OHCI_INTERRUPT_STATUS);\n\t} else\n\t\tintrs = OREAD4(sc, OHCI_INTERRUPT_STATUS);\n\n\tif (!intrs)\n\t\treturn (0);\n\n\tintrs &= ~OHCI_MIE;\n\tOWRITE4(sc, OHCI_INTERRUPT_STATUS, intrs); /* Acknowledge */\n\teintrs = intrs & sc->sc_eintrs;\n\tif (!eintrs)\n\t\treturn (0);\n\n\tsc->sc_bus.intr_context++;\n\tsc->sc_bus.no_intrs++;\n\tDPRINTFN(7, (\"ohci_intr: sc=%p intrs=0x%x(0x%x) eintrs=0x%x\\n\", \n\t\t     sc, (u_int)intrs, OREAD4(sc, OHCI_INTERRUPT_STATUS),\n\t\t     (u_int)eintrs));\n\n\tif (eintrs & OHCI_SO) {\n\t\tprintf(\"%s: scheduling overrun\\n\",USBDEVNAME(sc->sc_bus.bdev));\n\t\t/* XXX do what */\n\t\tintrs &= ~OHCI_SO;\n\t}\n\tif (eintrs & OHCI_WDH) {\n\t\tohci_add_done(sc, done &~ OHCI_DONE_INTRS);\n\t\tsc->sc_hcca->hcca_done_head = 0;\n\t\tusb_schedsoftintr(&sc->sc_bus);\n\t\tintrs &= ~OHCI_WDH;\n\t}\n\tif (eintrs & OHCI_RD) {\n\t\tprintf(\"%s: resume detect\\n\", USBDEVNAME(sc->sc_bus.bdev));\n\t\t/* XXX process resume detect */\n\t}\n\tif (eintrs & OHCI_UE) {\n\t\tprintf(\"%s: unrecoverable error, controller halted\\n\",\n\t\t       USBDEVNAME(sc->sc_bus.bdev));\n\t\tOWRITE4(sc, OHCI_CONTROL, OHCI_HCFS_RESET);\n\t\t/* XXX what else */\n\t}\n\tif (eintrs & OHCI_RHSC) {\n\t\tohci_rhsc(sc, sc->sc_intrxfer);\n\t\tintrs &= ~OHCI_RHSC;\n\n\t\t/* \n\t\t * Disable RHSC interrupt for now, because it will be\n\t\t * on until the port has been reset.\n\t\t */\n\t\tohci_rhsc_able(sc, 0);\n\t}\n\n\tsc->sc_bus.intr_context--;\n\n\t/* Block unprocessed interrupts. XXX */\n\tOWRITE4(sc, OHCI_INTERRUPT_DISABLE, intrs);\n\tsc->sc_eintrs &= ~intrs;\n\n\treturn (1);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "ohci_add_done __P((ohci_softc_t *, ohci_physaddr_t));",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "ohci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "ohci_rhsc_able __P((ohci_softc_t *, int));",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
            "Static int",
            "ohci_intr1 __P((ohci_softc_t *));",
            "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_add_done __P((ohci_softc_t *, ohci_physaddr_t));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nohci_rhsc_able __P((ohci_softc_t *, int));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nStatic int;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nStatic int\nohci_intr1(sc)\n\tohci_softc_t *sc;\n{\n\tu_int32_t intrs, eintrs;\n\tohci_physaddr_t done;\n\n\t/* In case the interrupt occurs before initialization has completed. */\n\tif (sc == NULL || sc->sc_hcca == NULL) {\n#ifdef DIAGNOSTIC\n\t\tprintf(\"ohci_intr: sc->sc_hcca == NULL\\n\");\n#endif\n\t\treturn (0);\n\t}\n\n        intrs = 0;\n\tdone = le32toh(sc->sc_hcca->hcca_done_head);\n\tif (done != 0) {\n\t\tif (done & ~OHCI_DONE_INTRS)\n\t\t\tintrs = OHCI_WDH;\n\t\tif (done & OHCI_DONE_INTRS)\n\t\t\tintrs |= OREAD4(sc, OHCI_INTERRUPT_STATUS);\n\t} else\n\t\tintrs = OREAD4(sc, OHCI_INTERRUPT_STATUS);\n\n\tif (!intrs)\n\t\treturn (0);\n\n\tintrs &= ~OHCI_MIE;\n\tOWRITE4(sc, OHCI_INTERRUPT_STATUS, intrs); /* Acknowledge */\n\teintrs = intrs & sc->sc_eintrs;\n\tif (!eintrs)\n\t\treturn (0);\n\n\tsc->sc_bus.intr_context++;\n\tsc->sc_bus.no_intrs++;\n\tDPRINTFN(7, (\"ohci_intr: sc=%p intrs=0x%x(0x%x) eintrs=0x%x\\n\", \n\t\t     sc, (u_int)intrs, OREAD4(sc, OHCI_INTERRUPT_STATUS),\n\t\t     (u_int)eintrs));\n\n\tif (eintrs & OHCI_SO) {\n\t\tprintf(\"%s: scheduling overrun\\n\",USBDEVNAME(sc->sc_bus.bdev));\n\t\t/* XXX do what */\n\t\tintrs &= ~OHCI_SO;\n\t}\n\tif (eintrs & OHCI_WDH) {\n\t\tohci_add_done(sc, done &~ OHCI_DONE_INTRS);\n\t\tsc->sc_hcca->hcca_done_head = 0;\n\t\tusb_schedsoftintr(&sc->sc_bus);\n\t\tintrs &= ~OHCI_WDH;\n\t}\n\tif (eintrs & OHCI_RD) {\n\t\tprintf(\"%s: resume detect\\n\", USBDEVNAME(sc->sc_bus.bdev));\n\t\t/* XXX process resume detect */\n\t}\n\tif (eintrs & OHCI_UE) {\n\t\tprintf(\"%s: unrecoverable error, controller halted\\n\",\n\t\t       USBDEVNAME(sc->sc_bus.bdev));\n\t\tOWRITE4(sc, OHCI_CONTROL, OHCI_HCFS_RESET);\n\t\t/* XXX what else */\n\t}\n\tif (eintrs & OHCI_RHSC) {\n\t\tohci_rhsc(sc, sc->sc_intrxfer);\n\t\tintrs &= ~OHCI_RHSC;\n\n\t\t/* \n\t\t * Disable RHSC interrupt for now, because it will be\n\t\t * on until the port has been reset.\n\t\t */\n\t\tohci_rhsc_able(sc, 0);\n\t}\n\n\tsc->sc_bus.intr_context--;\n\n\t/* Block unprocessed interrupts. XXX */\n\tOWRITE4(sc, OHCI_INTERRUPT_DISABLE, intrs);\n\tsc->sc_eintrs &= ~intrs;\n\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ohci_intr: ignored interrupt while polling\\n\""
          ],
          "line": 1033
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nohci_rhsc_able __P((ohci_softc_t *, int));\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nint\nohci_intr(p)\n\tvoid *p;\n{\n\tohci_softc_t *sc = p;\n\n\t/* If we get an interrupt while polling, then just ignore it. */\n\tif (sc->sc_bus.use_polling) {\n#ifdef DIAGNOSTIC\n\t\tprintf(\"ohci_intr: ignored interrupt while polling\\n\");\n#endif\n\t\treturn (0);\n\t}\n\n\treturn (ohci_intr1(sc)); \n}"
  },
  {
    "function_name": "ohci_dumpregs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "981-1019",
    "snippet": "void\nohci_dumpregs(sc)\n\tohci_softc_t *sc;\n{\n\tDPRINTF((\"ohci_dumpregs: rev=0x%08x control=0x%08x command=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_REVISION),\n\t\t OREAD4(sc, OHCI_CONTROL),\n\t\t OREAD4(sc, OHCI_COMMAND_STATUS)));\n\tDPRINTF((\"               intrstat=0x%08x intre=0x%08x intrd=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_INTERRUPT_STATUS),\n\t\t OREAD4(sc, OHCI_INTERRUPT_ENABLE),\n\t\t OREAD4(sc, OHCI_INTERRUPT_DISABLE)));\n\tDPRINTF((\"               hcca=0x%08x percur=0x%08x ctrlhd=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_HCCA),\n\t\t OREAD4(sc, OHCI_PERIOD_CURRENT_ED),\n\t\t OREAD4(sc, OHCI_CONTROL_HEAD_ED)));\n\tDPRINTF((\"               ctrlcur=0x%08x bulkhd=0x%08x bulkcur=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_CONTROL_CURRENT_ED),\n\t\t OREAD4(sc, OHCI_BULK_HEAD_ED),\n\t\t OREAD4(sc, OHCI_BULK_CURRENT_ED)));\n\tDPRINTF((\"               done=0x%08x fmival=0x%08x fmrem=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_DONE_HEAD),\n\t\t OREAD4(sc, OHCI_FM_INTERVAL),\n\t\t OREAD4(sc, OHCI_FM_REMAINING)));\n\tDPRINTF((\"               fmnum=0x%08x perst=0x%08x lsthrs=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_FM_NUMBER),\n\t\t OREAD4(sc, OHCI_PERIODIC_START),\n\t\t OREAD4(sc, OHCI_LS_THRESHOLD)));\n\tDPRINTF((\"               desca=0x%08x descb=0x%08x stat=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_RH_DESCRIPTOR_A),\n\t\t OREAD4(sc, OHCI_RH_DESCRIPTOR_B),\n\t\t OREAD4(sc, OHCI_RH_STATUS)));\n\tDPRINTF((\"               port1=0x%08x port2=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_RH_PORT_STATUS(1)),\n\t\t OREAD4(sc, OHCI_RH_PORT_STATUS(2))));\n\tDPRINTF((\"         HCCA: frame_number=0x%04x done_head=0x%08x\\n\",\n\t\t le32toh(sc->sc_hcca->hcca_frame_number),\n\t\t le32toh(sc->sc_hcca->hcca_done_head)));\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "ohci_rhsc_able __P((ohci_softc_t *, int));",
      "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
      "ohci_intr1 __P((ohci_softc_t *));",
      "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"         HCCA: frame_number=0x%04x done_head=0x%08x\\n\",\n\t\t le32toh(sc->sc_hcca->hcca_frame_number),\n\t\t le32toh(sc->sc_hcca->hcca_done_head))"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "sc->sc_hcca->hcca_done_head"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "sc->sc_hcca->hcca_frame_number"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"               port1=0x%08x port2=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_RH_PORT_STATUS(1)),\n\t\t OREAD4(sc, OHCI_RH_PORT_STATUS(2)))"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OREAD4",
          "args": [
            "sc",
            "OHCI_RH_PORT_STATUS(2)"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OHCI_RH_PORT_STATUS",
          "args": [
            "2"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OREAD4",
          "args": [
            "sc",
            "OHCI_RH_PORT_STATUS(1)"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OHCI_RH_PORT_STATUS",
          "args": [
            "1"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"               desca=0x%08x descb=0x%08x stat=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_RH_DESCRIPTOR_A),\n\t\t OREAD4(sc, OHCI_RH_DESCRIPTOR_B),\n\t\t OREAD4(sc, OHCI_RH_STATUS))"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OREAD4",
          "args": [
            "sc",
            "OHCI_RH_STATUS"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OREAD4",
          "args": [
            "sc",
            "OHCI_RH_DESCRIPTOR_B"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OREAD4",
          "args": [
            "sc",
            "OHCI_RH_DESCRIPTOR_A"
          ],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"               fmnum=0x%08x perst=0x%08x lsthrs=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_FM_NUMBER),\n\t\t OREAD4(sc, OHCI_PERIODIC_START),\n\t\t OREAD4(sc, OHCI_LS_THRESHOLD))"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OREAD4",
          "args": [
            "sc",
            "OHCI_LS_THRESHOLD"
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OREAD4",
          "args": [
            "sc",
            "OHCI_PERIODIC_START"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OREAD4",
          "args": [
            "sc",
            "OHCI_FM_NUMBER"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"               done=0x%08x fmival=0x%08x fmrem=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_DONE_HEAD),\n\t\t OREAD4(sc, OHCI_FM_INTERVAL),\n\t\t OREAD4(sc, OHCI_FM_REMAINING))"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OREAD4",
          "args": [
            "sc",
            "OHCI_FM_REMAINING"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OREAD4",
          "args": [
            "sc",
            "OHCI_FM_INTERVAL"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OREAD4",
          "args": [
            "sc",
            "OHCI_DONE_HEAD"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"               ctrlcur=0x%08x bulkhd=0x%08x bulkcur=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_CONTROL_CURRENT_ED),\n\t\t OREAD4(sc, OHCI_BULK_HEAD_ED),\n\t\t OREAD4(sc, OHCI_BULK_CURRENT_ED))"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OREAD4",
          "args": [
            "sc",
            "OHCI_BULK_CURRENT_ED"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OREAD4",
          "args": [
            "sc",
            "OHCI_BULK_HEAD_ED"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OREAD4",
          "args": [
            "sc",
            "OHCI_CONTROL_CURRENT_ED"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"               hcca=0x%08x percur=0x%08x ctrlhd=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_HCCA),\n\t\t OREAD4(sc, OHCI_PERIOD_CURRENT_ED),\n\t\t OREAD4(sc, OHCI_CONTROL_HEAD_ED))"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OREAD4",
          "args": [
            "sc",
            "OHCI_CONTROL_HEAD_ED"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OREAD4",
          "args": [
            "sc",
            "OHCI_PERIOD_CURRENT_ED"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OREAD4",
          "args": [
            "sc",
            "OHCI_HCCA"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"               intrstat=0x%08x intre=0x%08x intrd=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_INTERRUPT_STATUS),\n\t\t OREAD4(sc, OHCI_INTERRUPT_ENABLE),\n\t\t OREAD4(sc, OHCI_INTERRUPT_DISABLE))"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OREAD4",
          "args": [
            "sc",
            "OHCI_INTERRUPT_DISABLE"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OREAD4",
          "args": [
            "sc",
            "OHCI_INTERRUPT_ENABLE"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OREAD4",
          "args": [
            "sc",
            "OHCI_INTERRUPT_STATUS"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ohci_dumpregs: rev=0x%08x control=0x%08x command=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_REVISION),\n\t\t OREAD4(sc, OHCI_CONTROL),\n\t\t OREAD4(sc, OHCI_COMMAND_STATUS))"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OREAD4",
          "args": [
            "sc",
            "OHCI_COMMAND_STATUS"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OREAD4",
          "args": [
            "sc",
            "OHCI_CONTROL"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OREAD4",
          "args": [
            "sc",
            "OHCI_REVISION"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nohci_rhsc_able __P((ohci_softc_t *, int));\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nvoid\nohci_dumpregs(sc)\n\tohci_softc_t *sc;\n{\n\tDPRINTF((\"ohci_dumpregs: rev=0x%08x control=0x%08x command=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_REVISION),\n\t\t OREAD4(sc, OHCI_CONTROL),\n\t\t OREAD4(sc, OHCI_COMMAND_STATUS)));\n\tDPRINTF((\"               intrstat=0x%08x intre=0x%08x intrd=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_INTERRUPT_STATUS),\n\t\t OREAD4(sc, OHCI_INTERRUPT_ENABLE),\n\t\t OREAD4(sc, OHCI_INTERRUPT_DISABLE)));\n\tDPRINTF((\"               hcca=0x%08x percur=0x%08x ctrlhd=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_HCCA),\n\t\t OREAD4(sc, OHCI_PERIOD_CURRENT_ED),\n\t\t OREAD4(sc, OHCI_CONTROL_HEAD_ED)));\n\tDPRINTF((\"               ctrlcur=0x%08x bulkhd=0x%08x bulkcur=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_CONTROL_CURRENT_ED),\n\t\t OREAD4(sc, OHCI_BULK_HEAD_ED),\n\t\t OREAD4(sc, OHCI_BULK_CURRENT_ED)));\n\tDPRINTF((\"               done=0x%08x fmival=0x%08x fmrem=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_DONE_HEAD),\n\t\t OREAD4(sc, OHCI_FM_INTERVAL),\n\t\t OREAD4(sc, OHCI_FM_REMAINING)));\n\tDPRINTF((\"               fmnum=0x%08x perst=0x%08x lsthrs=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_FM_NUMBER),\n\t\t OREAD4(sc, OHCI_PERIODIC_START),\n\t\t OREAD4(sc, OHCI_LS_THRESHOLD)));\n\tDPRINTF((\"               desca=0x%08x descb=0x%08x stat=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_RH_DESCRIPTOR_A),\n\t\t OREAD4(sc, OHCI_RH_DESCRIPTOR_B),\n\t\t OREAD4(sc, OHCI_RH_STATUS)));\n\tDPRINTF((\"               port1=0x%08x port2=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_RH_PORT_STATUS(1)),\n\t\t OREAD4(sc, OHCI_RH_PORT_STATUS(2))));\n\tDPRINTF((\"         HCCA: frame_number=0x%04x done_head=0x%08x\\n\",\n\t\t le32toh(sc->sc_hcca->hcca_frame_number),\n\t\t le32toh(sc->sc_hcca->hcca_done_head)));\n}"
  },
  {
    "function_name": "ohci_power",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "966-978",
    "snippet": "void\nohci_power(why, v)\n\tint why;\n\tvoid *v;\n{\n#ifdef OHCI_DEBUG\n\tohci_softc_t *sc = v;\n\n\tDPRINTF((\"ohci_power: sc=%p, why=%d\\n\", sc, why));\n\t/* XXX should suspend/resume */\n\tohci_dumpregs(sc);\n#endif\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "ohci_shutdown __P((void *v));",
      "ohci_rhsc_able __P((ohci_softc_t *, int));",
      "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
      "ohci_intr1 __P((ohci_softc_t *));",
      "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ohci_dumpregs",
          "args": [
            "sc"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_dumpregs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "981-1019",
          "snippet": "void\nohci_dumpregs(sc)\n\tohci_softc_t *sc;\n{\n\tDPRINTF((\"ohci_dumpregs: rev=0x%08x control=0x%08x command=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_REVISION),\n\t\t OREAD4(sc, OHCI_CONTROL),\n\t\t OREAD4(sc, OHCI_COMMAND_STATUS)));\n\tDPRINTF((\"               intrstat=0x%08x intre=0x%08x intrd=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_INTERRUPT_STATUS),\n\t\t OREAD4(sc, OHCI_INTERRUPT_ENABLE),\n\t\t OREAD4(sc, OHCI_INTERRUPT_DISABLE)));\n\tDPRINTF((\"               hcca=0x%08x percur=0x%08x ctrlhd=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_HCCA),\n\t\t OREAD4(sc, OHCI_PERIOD_CURRENT_ED),\n\t\t OREAD4(sc, OHCI_CONTROL_HEAD_ED)));\n\tDPRINTF((\"               ctrlcur=0x%08x bulkhd=0x%08x bulkcur=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_CONTROL_CURRENT_ED),\n\t\t OREAD4(sc, OHCI_BULK_HEAD_ED),\n\t\t OREAD4(sc, OHCI_BULK_CURRENT_ED)));\n\tDPRINTF((\"               done=0x%08x fmival=0x%08x fmrem=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_DONE_HEAD),\n\t\t OREAD4(sc, OHCI_FM_INTERVAL),\n\t\t OREAD4(sc, OHCI_FM_REMAINING)));\n\tDPRINTF((\"               fmnum=0x%08x perst=0x%08x lsthrs=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_FM_NUMBER),\n\t\t OREAD4(sc, OHCI_PERIODIC_START),\n\t\t OREAD4(sc, OHCI_LS_THRESHOLD)));\n\tDPRINTF((\"               desca=0x%08x descb=0x%08x stat=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_RH_DESCRIPTOR_A),\n\t\t OREAD4(sc, OHCI_RH_DESCRIPTOR_B),\n\t\t OREAD4(sc, OHCI_RH_STATUS)));\n\tDPRINTF((\"               port1=0x%08x port2=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_RH_PORT_STATUS(1)),\n\t\t OREAD4(sc, OHCI_RH_PORT_STATUS(2))));\n\tDPRINTF((\"         HCCA: frame_number=0x%04x done_head=0x%08x\\n\",\n\t\t le32toh(sc->sc_hcca->hcca_frame_number),\n\t\t le32toh(sc->sc_hcca->hcca_done_head)));\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "ohci_rhsc_able __P((ohci_softc_t *, int));",
            "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
            "ohci_intr1 __P((ohci_softc_t *));",
            "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nohci_rhsc_able __P((ohci_softc_t *, int));\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nvoid\nohci_dumpregs(sc)\n\tohci_softc_t *sc;\n{\n\tDPRINTF((\"ohci_dumpregs: rev=0x%08x control=0x%08x command=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_REVISION),\n\t\t OREAD4(sc, OHCI_CONTROL),\n\t\t OREAD4(sc, OHCI_COMMAND_STATUS)));\n\tDPRINTF((\"               intrstat=0x%08x intre=0x%08x intrd=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_INTERRUPT_STATUS),\n\t\t OREAD4(sc, OHCI_INTERRUPT_ENABLE),\n\t\t OREAD4(sc, OHCI_INTERRUPT_DISABLE)));\n\tDPRINTF((\"               hcca=0x%08x percur=0x%08x ctrlhd=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_HCCA),\n\t\t OREAD4(sc, OHCI_PERIOD_CURRENT_ED),\n\t\t OREAD4(sc, OHCI_CONTROL_HEAD_ED)));\n\tDPRINTF((\"               ctrlcur=0x%08x bulkhd=0x%08x bulkcur=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_CONTROL_CURRENT_ED),\n\t\t OREAD4(sc, OHCI_BULK_HEAD_ED),\n\t\t OREAD4(sc, OHCI_BULK_CURRENT_ED)));\n\tDPRINTF((\"               done=0x%08x fmival=0x%08x fmrem=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_DONE_HEAD),\n\t\t OREAD4(sc, OHCI_FM_INTERVAL),\n\t\t OREAD4(sc, OHCI_FM_REMAINING)));\n\tDPRINTF((\"               fmnum=0x%08x perst=0x%08x lsthrs=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_FM_NUMBER),\n\t\t OREAD4(sc, OHCI_PERIODIC_START),\n\t\t OREAD4(sc, OHCI_LS_THRESHOLD)));\n\tDPRINTF((\"               desca=0x%08x descb=0x%08x stat=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_RH_DESCRIPTOR_A),\n\t\t OREAD4(sc, OHCI_RH_DESCRIPTOR_B),\n\t\t OREAD4(sc, OHCI_RH_STATUS)));\n\tDPRINTF((\"               port1=0x%08x port2=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_RH_PORT_STATUS(1)),\n\t\t OREAD4(sc, OHCI_RH_PORT_STATUS(2))));\n\tDPRINTF((\"         HCCA: frame_number=0x%04x done_head=0x%08x\\n\",\n\t\t le32toh(sc->sc_hcca->hcca_frame_number),\n\t\t le32toh(sc->sc_hcca->hcca_done_head)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ohci_power: sc=%p, why=%d\\n\", sc, why)"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nohci_shutdown __P((void *v));\nohci_rhsc_able __P((ohci_softc_t *, int));\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nvoid\nohci_power(why, v)\n\tint why;\n\tvoid *v;\n{\n#ifdef OHCI_DEBUG\n\tohci_softc_t *sc = v;\n\n\tDPRINTF((\"ohci_power: sc=%p, why=%d\\n\", sc, why));\n\t/* XXX should suspend/resume */\n\tohci_dumpregs(sc);\n#endif\n}"
  },
  {
    "function_name": "ohci_shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "949-957",
    "snippet": "void\nohci_shutdown(v)\n\tvoid *v;\n{\n\tohci_softc_t *sc = v;\n\n\tDPRINTF((\"ohci_shutdown: stopping the HC\\n\"));\n\tOWRITE4(sc, OHCI_CONTROL, OHCI_HCFS_RESET);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "ohci_shutdown __P((void *v));",
      "ohci_rhsc_able __P((ohci_softc_t *, int));",
      "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
      "ohci_intr1 __P((ohci_softc_t *));",
      "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "OWRITE4",
          "args": [
            "sc",
            "OHCI_CONTROL",
            "OHCI_HCFS_RESET"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ohci_shutdown: stopping the HC\\n\")"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nohci_shutdown __P((void *v));\nohci_rhsc_able __P((ohci_softc_t *, int));\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nvoid\nohci_shutdown(v)\n\tvoid *v;\n{\n\tohci_softc_t *sc = v;\n\n\tDPRINTF((\"ohci_shutdown: stopping the HC\\n\"));\n\tOWRITE4(sc, OHCI_CONTROL, OHCI_HCFS_RESET);\n}"
  },
  {
    "function_name": "ohci_freex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "936-944",
    "snippet": "void\nohci_freex(bus, xfer)\n\tstruct usbd_bus *bus;\n\tusbd_xfer_handle xfer;\n{\n\tstruct ohci_softc *sc = (struct ohci_softc *)bus;\n\n\tSIMPLEQ_INSERT_HEAD(&sc->sc_free_xfers, xfer, next);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "ohci_poll __P((struct usbd_bus *));",
      "ohci_softintr __P((struct usbd_bus *));",
      "ohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));",
      "ohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));",
      "ohci_device_request __P((usbd_xfer_handle xfer));",
      "ohci_device_isoc_enter __P((usbd_xfer_handle));",
      "Static usbd_xfer_handle",
      "ohci_allocx __P((struct usbd_bus *));",
      "ohci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "ohci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "ohci_root_ctrl_start __P((usbd_xfer_handle));",
      "ohci_root_ctrl_abort __P((usbd_xfer_handle));",
      "ohci_root_ctrl_done  __P((usbd_xfer_handle));",
      "ohci_root_intr_transfer __P((usbd_xfer_handle));",
      "ohci_root_intr_start __P((usbd_xfer_handle));",
      "ohci_root_intr_abort __P((usbd_xfer_handle));",
      "ohci_root_intr_done  __P((usbd_xfer_handle));",
      "ohci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "ohci_device_ctrl_start __P((usbd_xfer_handle));",
      "ohci_device_ctrl_abort __P((usbd_xfer_handle));",
      "ohci_device_ctrl_done  __P((usbd_xfer_handle));",
      "ohci_device_bulk_transfer __P((usbd_xfer_handle));",
      "ohci_device_bulk_start __P((usbd_xfer_handle));",
      "ohci_device_bulk_abort __P((usbd_xfer_handle));",
      "ohci_device_bulk_done  __P((usbd_xfer_handle));",
      "ohci_device_intr_transfer __P((usbd_xfer_handle));",
      "ohci_device_intr_start __P((usbd_xfer_handle));",
      "ohci_device_intr_abort __P((usbd_xfer_handle));",
      "ohci_device_intr_done  __P((usbd_xfer_handle));",
      "ohci_device_isoc_transfer __P((usbd_xfer_handle));",
      "ohci_device_isoc_start __P((usbd_xfer_handle));",
      "ohci_device_isoc_abort __P((usbd_xfer_handle));",
      "ohci_device_isoc_done  __P((usbd_xfer_handle));",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SIMPLEQ_INSERT_HEAD",
          "args": [
            "&sc->sc_free_xfers",
            "xfer",
            "next"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nohci_poll __P((struct usbd_bus *));\nohci_softintr __P((struct usbd_bus *));\nohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));\nohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));\nohci_device_request __P((usbd_xfer_handle xfer));\nohci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_xfer_handle;\nohci_allocx __P((struct usbd_bus *));\nohci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nohci_root_ctrl_transfer __P((usbd_xfer_handle));\nohci_root_ctrl_start __P((usbd_xfer_handle));\nohci_root_ctrl_abort __P((usbd_xfer_handle));\nohci_root_ctrl_done  __P((usbd_xfer_handle));\nohci_root_intr_transfer __P((usbd_xfer_handle));\nohci_root_intr_start __P((usbd_xfer_handle));\nohci_root_intr_abort __P((usbd_xfer_handle));\nohci_root_intr_done  __P((usbd_xfer_handle));\nohci_device_ctrl_transfer __P((usbd_xfer_handle));\nohci_device_ctrl_start __P((usbd_xfer_handle));\nohci_device_ctrl_abort __P((usbd_xfer_handle));\nohci_device_ctrl_done  __P((usbd_xfer_handle));\nohci_device_bulk_transfer __P((usbd_xfer_handle));\nohci_device_bulk_start __P((usbd_xfer_handle));\nohci_device_bulk_abort __P((usbd_xfer_handle));\nohci_device_bulk_done  __P((usbd_xfer_handle));\nohci_device_intr_transfer __P((usbd_xfer_handle));\nohci_device_intr_start __P((usbd_xfer_handle));\nohci_device_intr_abort __P((usbd_xfer_handle));\nohci_device_intr_done  __P((usbd_xfer_handle));\nohci_device_isoc_transfer __P((usbd_xfer_handle));\nohci_device_isoc_start __P((usbd_xfer_handle));\nohci_device_isoc_abort __P((usbd_xfer_handle));\nohci_device_isoc_done  __P((usbd_xfer_handle));\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nvoid\nohci_freex(bus, xfer)\n\tstruct usbd_bus *bus;\n\tusbd_xfer_handle xfer;\n{\n\tstruct ohci_softc *sc = (struct ohci_softc *)bus;\n\n\tSIMPLEQ_INSERT_HEAD(&sc->sc_free_xfers, xfer, next);\n}"
  },
  {
    "function_name": "ohci_allocx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "919-934",
    "snippet": "usbd_xfer_handle\nohci_allocx(bus)\n\tstruct usbd_bus *bus;\n{\n\tstruct ohci_softc *sc = (struct ohci_softc *)bus;\n\tusbd_xfer_handle xfer;\n\n\txfer = SIMPLEQ_FIRST(&sc->sc_free_xfers);\n\tif (xfer != NULL)\n\t\tSIMPLEQ_REMOVE_HEAD(&sc->sc_free_xfers, xfer, next);\n\telse\n\t\txfer = malloc(sizeof(*xfer), M_USB, M_NOWAIT);\n\tif (xfer != NULL)\n\t\tmemset(xfer, 0, sizeof *xfer);\n\treturn (xfer);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "ohci_poll __P((struct usbd_bus *));",
      "ohci_softintr __P((struct usbd_bus *));",
      "ohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));",
      "ohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));",
      "ohci_device_request __P((usbd_xfer_handle xfer));",
      "ohci_device_isoc_enter __P((usbd_xfer_handle));",
      "Static usbd_xfer_handle",
      "ohci_allocx __P((struct usbd_bus *));",
      "ohci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "ohci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "ohci_root_ctrl_start __P((usbd_xfer_handle));",
      "ohci_root_ctrl_abort __P((usbd_xfer_handle));",
      "ohci_root_ctrl_done  __P((usbd_xfer_handle));",
      "ohci_root_intr_transfer __P((usbd_xfer_handle));",
      "ohci_root_intr_start __P((usbd_xfer_handle));",
      "ohci_root_intr_abort __P((usbd_xfer_handle));",
      "ohci_root_intr_done  __P((usbd_xfer_handle));",
      "ohci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "ohci_device_ctrl_start __P((usbd_xfer_handle));",
      "ohci_device_ctrl_abort __P((usbd_xfer_handle));",
      "ohci_device_ctrl_done  __P((usbd_xfer_handle));",
      "ohci_device_bulk_transfer __P((usbd_xfer_handle));",
      "ohci_device_bulk_start __P((usbd_xfer_handle));",
      "ohci_device_bulk_abort __P((usbd_xfer_handle));",
      "ohci_device_bulk_done  __P((usbd_xfer_handle));",
      "ohci_device_intr_transfer __P((usbd_xfer_handle));",
      "ohci_device_intr_start __P((usbd_xfer_handle));",
      "ohci_device_intr_abort __P((usbd_xfer_handle));",
      "ohci_device_intr_done  __P((usbd_xfer_handle));",
      "ohci_device_isoc_transfer __P((usbd_xfer_handle));",
      "ohci_device_isoc_start __P((usbd_xfer_handle));",
      "ohci_device_isoc_abort __P((usbd_xfer_handle));",
      "ohci_device_isoc_done  __P((usbd_xfer_handle));",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "xfer",
            "0",
            "sizeof *xfer"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(*xfer)",
            "M_USB",
            "M_NOWAIT"
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_REMOVE_HEAD",
          "args": [
            "&sc->sc_free_xfers",
            "xfer",
            "next"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_FIRST",
          "args": [
            "&sc->sc_free_xfers"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nohci_poll __P((struct usbd_bus *));\nohci_softintr __P((struct usbd_bus *));\nohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));\nohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));\nohci_device_request __P((usbd_xfer_handle xfer));\nohci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_xfer_handle;\nohci_allocx __P((struct usbd_bus *));\nohci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nohci_root_ctrl_transfer __P((usbd_xfer_handle));\nohci_root_ctrl_start __P((usbd_xfer_handle));\nohci_root_ctrl_abort __P((usbd_xfer_handle));\nohci_root_ctrl_done  __P((usbd_xfer_handle));\nohci_root_intr_transfer __P((usbd_xfer_handle));\nohci_root_intr_start __P((usbd_xfer_handle));\nohci_root_intr_abort __P((usbd_xfer_handle));\nohci_root_intr_done  __P((usbd_xfer_handle));\nohci_device_ctrl_transfer __P((usbd_xfer_handle));\nohci_device_ctrl_start __P((usbd_xfer_handle));\nohci_device_ctrl_abort __P((usbd_xfer_handle));\nohci_device_ctrl_done  __P((usbd_xfer_handle));\nohci_device_bulk_transfer __P((usbd_xfer_handle));\nohci_device_bulk_start __P((usbd_xfer_handle));\nohci_device_bulk_abort __P((usbd_xfer_handle));\nohci_device_bulk_done  __P((usbd_xfer_handle));\nohci_device_intr_transfer __P((usbd_xfer_handle));\nohci_device_intr_start __P((usbd_xfer_handle));\nohci_device_intr_abort __P((usbd_xfer_handle));\nohci_device_intr_done  __P((usbd_xfer_handle));\nohci_device_isoc_transfer __P((usbd_xfer_handle));\nohci_device_isoc_start __P((usbd_xfer_handle));\nohci_device_isoc_abort __P((usbd_xfer_handle));\nohci_device_isoc_done  __P((usbd_xfer_handle));\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nusbd_xfer_handle\nohci_allocx(bus)\n\tstruct usbd_bus *bus;\n{\n\tstruct ohci_softc *sc = (struct ohci_softc *)bus;\n\tusbd_xfer_handle xfer;\n\n\txfer = SIMPLEQ_FIRST(&sc->sc_free_xfers);\n\tif (xfer != NULL)\n\t\tSIMPLEQ_REMOVE_HEAD(&sc->sc_free_xfers, xfer, next);\n\telse\n\t\txfer = malloc(sizeof(*xfer), M_USB, M_NOWAIT);\n\tif (xfer != NULL)\n\t\tmemset(xfer, 0, sizeof *xfer);\n\treturn (xfer);\n}"
  },
  {
    "function_name": "ohci_freem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "907-917",
    "snippet": "void\nohci_freem(bus, dma)\n\tstruct usbd_bus *bus;\n\tusb_dma_t *dma;\n{\n#if defined(__NetBSD__) || defined(__OpenBSD__)\n\tstruct ohci_softc *sc = (struct ohci_softc *)bus;\n#endif\n\n\tusb_freemem(&sc->sc_bus, dma);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "ohci_poll __P((struct usbd_bus *));",
      "ohci_softintr __P((struct usbd_bus *));",
      "ohci_freem __P((struct usbd_bus *, usb_dma_t *));",
      "ohci_allocx __P((struct usbd_bus *));",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usb_freemem",
          "args": [
            "&sc->sc_bus",
            "dma"
          ],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "usb_freemem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_mem.c",
          "lines": "271-291",
          "snippet": "void\nusb_freemem(bus, p)\n\tusbd_bus_handle bus;\n        usb_dma_t *p;\n{\n\tstruct usb_frag_dma *f;\n\tint s;\n\n\tif (p->block->fullblock) {\n\t\tDPRINTFN(1, (\"usb_freemem: large free\\n\"));\n\t\tusb_block_freemem(p->block);\n\t\treturn;\n\t}\n\tf = KERNADDR(p);\n\tf->block = p->block;\n\tf->offs = p->offs;\n\ts = splusb();\n\tLIST_INSERT_HEAD(&usb_frag_freelist, f, next);\n\tsplx(s);\n\tDPRINTFN(5, (\"usb_freemem: frag=%p\\n\", f));\n}",
          "includes": [
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>\t/* just for usb_dma_t */",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/proc.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>\t\t/* for usbdivar.h */",
            "#include <sys/queue.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static LIST_HEAD(, usb_frag_dma) usb_frag_freelist =\n\tLIST_HEAD_INITIALIZER(usb_frag_freelist);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\t/* just for usb_dma_t */\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/proc.h>\n#include <machine/bus.h>\n#include <sys/device.h>\t\t/* for usbdivar.h */\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic LIST_HEAD(, usb_frag_dma) usb_frag_freelist =\n\tLIST_HEAD_INITIALIZER(usb_frag_freelist);\n\nvoid\nusb_freemem(bus, p)\n\tusbd_bus_handle bus;\n        usb_dma_t *p;\n{\n\tstruct usb_frag_dma *f;\n\tint s;\n\n\tif (p->block->fullblock) {\n\t\tDPRINTFN(1, (\"usb_freemem: large free\\n\"));\n\t\tusb_block_freemem(p->block);\n\t\treturn;\n\t}\n\tf = KERNADDR(p);\n\tf->block = p->block;\n\tf->offs = p->offs;\n\ts = splusb();\n\tLIST_INSERT_HEAD(&usb_frag_freelist, f, next);\n\tsplx(s);\n\tDPRINTFN(5, (\"usb_freemem: frag=%p\\n\", f));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nohci_poll __P((struct usbd_bus *));\nohci_softintr __P((struct usbd_bus *));\nohci_freem __P((struct usbd_bus *, usb_dma_t *));\nohci_allocx __P((struct usbd_bus *));\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nvoid\nohci_freem(bus, dma)\n\tstruct usbd_bus *bus;\n\tusb_dma_t *dma;\n{\n#if defined(__NetBSD__) || defined(__OpenBSD__)\n\tstruct ohci_softc *sc = (struct ohci_softc *)bus;\n#endif\n\n\tusb_freemem(&sc->sc_bus, dma);\n}"
  },
  {
    "function_name": "ohci_allocm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "894-905",
    "snippet": "usbd_status\nohci_allocm(bus, dma, size)\n\tstruct usbd_bus *bus;\n\tusb_dma_t *dma;\n\tu_int32_t size;\n{\n#if defined(__NetBSD__) || defined(__OpenBSD__)\n\tstruct ohci_softc *sc = (struct ohci_softc *)bus;\n#endif\n\n\treturn (usb_allocmem(&sc->sc_bus, size, 0, dma));\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static usbd_status",
      "Static usbd_status",
      "ohci_poll __P((struct usbd_bus *));",
      "ohci_softintr __P((struct usbd_bus *));",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "ohci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));",
      "ohci_freem __P((struct usbd_bus *, usb_dma_t *));",
      "ohci_allocx __P((struct usbd_bus *));",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usb_allocmem",
          "args": [
            "&sc->sc_bus",
            "size",
            "0",
            "dma"
          ],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "usb_allocmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_mem.c",
          "lines": "216-269",
          "snippet": "usbd_status\nusb_allocmem(bus, size, align, p)\n\tusbd_bus_handle bus;\n\tsize_t size;\n\tsize_t align;\n        usb_dma_t *p;\n{\n\tbus_dma_tag_t tag = bus->dmatag;\n\tusbd_status err;\n\tstruct usb_frag_dma *f;\n\tusb_dma_block_t *b;\n\tint i;\n\tint s;\n\n\t/* If the request is large then just use a full block. */\n\tif (size > USB_MEM_SMALL || align > USB_MEM_SMALL) {\n\t\tDPRINTFN(1, (\"usb_allocmem: large alloc %d\\n\", (int)size));\n\t\tsize = (size + USB_MEM_BLOCK - 1) & ~(USB_MEM_BLOCK - 1);\n\t\terr = usb_block_allocmem(tag, size, align, &p->block);\n\t\tif (!err) {\n\t\t\tp->block->fullblock = 1;\n\t\t\tp->offs = 0;\n\t\t}\n\t\treturn (err);\n\t}\n\t\n\ts = splusb();\n\t/* Check for free fragments. */\n\tfor (f = LIST_FIRST(&usb_frag_freelist); f; f = LIST_NEXT(f, next))\n\t\tif (f->block->tag == tag)\n\t\t\tbreak;\n\tif (f == NULL) {\n\t\tDPRINTFN(1, (\"usb_allocmem: adding fragments\\n\"));\n\t\terr = usb_block_allocmem(tag, USB_MEM_BLOCK, USB_MEM_SMALL,&b);\n\t\tif (err) {\n\t\t\tsplx(s);\n\t\t\treturn (err);\n\t\t}\n\t\tb->fullblock = 0;\n\t\tfor (i = 0; i < USB_MEM_BLOCK; i += USB_MEM_SMALL) {\n\t\t\tf = (struct usb_frag_dma *)(b->kaddr + i);\n\t\t\tf->block = b;\n\t\t\tf->offs = i;\n\t\t\tLIST_INSERT_HEAD(&usb_frag_freelist, f, next);\n\t\t}\n\t\tf = LIST_FIRST(&usb_frag_freelist);\n\t}\n\tp->block = f->block;\n\tp->offs = f->offs;\n\tLIST_REMOVE(f, next);\n\tsplx(s);\n\tDPRINTFN(5, (\"usb_allocmem: use frag=%p size=%d\\n\", f, (int)size));\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>\t/* just for usb_dma_t */",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/proc.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>\t\t/* for usbdivar.h */",
            "#include <sys/queue.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define USB_MEM_BLOCK (USB_MEM_SMALL * USB_MEM_CHUNKS)",
            "#define USB_MEM_SMALL 64"
          ],
          "globals_used": [
            "Static usbd_status",
            "usb_block_allocmem __P((bus_dma_tag_t, size_t, size_t,\n\t\t\t\t\t\tusb_dma_block_t **));",
            "usb_block_freemem  __P((usb_dma_block_t *));",
            "Static LIST_HEAD(, usb_frag_dma) usb_frag_freelist =\n\tLIST_HEAD_INITIALIZER(usb_frag_freelist);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\t/* just for usb_dma_t */\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/proc.h>\n#include <machine/bus.h>\n#include <sys/device.h>\t\t/* for usbdivar.h */\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define USB_MEM_BLOCK (USB_MEM_SMALL * USB_MEM_CHUNKS)\n#define USB_MEM_SMALL 64\n\nStatic usbd_status;\nusb_block_allocmem __P((bus_dma_tag_t, size_t, size_t,\n\t\t\t\t\t\tusb_dma_block_t **));\nusb_block_freemem  __P((usb_dma_block_t *));\nStatic LIST_HEAD(, usb_frag_dma) usb_frag_freelist =\n\tLIST_HEAD_INITIALIZER(usb_frag_freelist);\n\nusbd_status\nusb_allocmem(bus, size, align, p)\n\tusbd_bus_handle bus;\n\tsize_t size;\n\tsize_t align;\n        usb_dma_t *p;\n{\n\tbus_dma_tag_t tag = bus->dmatag;\n\tusbd_status err;\n\tstruct usb_frag_dma *f;\n\tusb_dma_block_t *b;\n\tint i;\n\tint s;\n\n\t/* If the request is large then just use a full block. */\n\tif (size > USB_MEM_SMALL || align > USB_MEM_SMALL) {\n\t\tDPRINTFN(1, (\"usb_allocmem: large alloc %d\\n\", (int)size));\n\t\tsize = (size + USB_MEM_BLOCK - 1) & ~(USB_MEM_BLOCK - 1);\n\t\terr = usb_block_allocmem(tag, size, align, &p->block);\n\t\tif (!err) {\n\t\t\tp->block->fullblock = 1;\n\t\t\tp->offs = 0;\n\t\t}\n\t\treturn (err);\n\t}\n\t\n\ts = splusb();\n\t/* Check for free fragments. */\n\tfor (f = LIST_FIRST(&usb_frag_freelist); f; f = LIST_NEXT(f, next))\n\t\tif (f->block->tag == tag)\n\t\t\tbreak;\n\tif (f == NULL) {\n\t\tDPRINTFN(1, (\"usb_allocmem: adding fragments\\n\"));\n\t\terr = usb_block_allocmem(tag, USB_MEM_BLOCK, USB_MEM_SMALL,&b);\n\t\tif (err) {\n\t\t\tsplx(s);\n\t\t\treturn (err);\n\t\t}\n\t\tb->fullblock = 0;\n\t\tfor (i = 0; i < USB_MEM_BLOCK; i += USB_MEM_SMALL) {\n\t\t\tf = (struct usb_frag_dma *)(b->kaddr + i);\n\t\t\tf->block = b;\n\t\t\tf->offs = i;\n\t\t\tLIST_INSERT_HEAD(&usb_frag_freelist, f, next);\n\t\t}\n\t\tf = LIST_FIRST(&usb_frag_freelist);\n\t}\n\tp->block = f->block;\n\tp->offs = f->offs;\n\tLIST_REMOVE(f, next);\n\tsplx(s);\n\tDPRINTFN(5, (\"usb_allocmem: use frag=%p size=%d\\n\", f, (int)size));\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nStatic usbd_status;\nohci_poll __P((struct usbd_bus *));\nohci_softintr __P((struct usbd_bus *));\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nohci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));\nohci_freem __P((struct usbd_bus *, usb_dma_t *));\nohci_allocx __P((struct usbd_bus *));\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nusbd_status\nohci_allocm(bus, dma, size)\n\tstruct usbd_bus *bus;\n\tusb_dma_t *dma;\n\tu_int32_t size;\n{\n#if defined(__NetBSD__) || defined(__OpenBSD__)\n\tstruct ohci_softc *sc = (struct ohci_softc *)bus;\n#endif\n\n\treturn (usb_allocmem(&sc->sc_bus, size, 0, dma));\n}"
  },
  {
    "function_name": "ohci_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "655-892",
    "snippet": "usbd_status\nohci_init(sc)\n\tohci_softc_t *sc;\n{\n\tohci_soft_ed_t *sed, *psed;\n\tusbd_status err;\n\tint i;\n\tu_int32_t s, ctl, ival, hcr, fm, per, rev, desca;\n\n\tDPRINTF((\"ohci_init: start\\n\"));\n#if defined(__OpenBSD__)\n\tprintf(\",\");\n#else\n\tprintf(\"%s:\", USBDEVNAME(sc->sc_bus.bdev));\n#endif\n\trev = OREAD4(sc, OHCI_REVISION);\n\tprintf(\" OHCI version %d.%d%s\\n\", OHCI_REV_HI(rev), OHCI_REV_LO(rev),\n\t       OHCI_REV_LEGACY(rev) ? \", legacy support\" : \"\");\n\n\tif (OHCI_REV_HI(rev) != 1 || OHCI_REV_LO(rev) != 0) {\n\t\tprintf(\"%s: unsupported OHCI revision\\n\", \n\t\t       USBDEVNAME(sc->sc_bus.bdev));\n\t\tsc->sc_bus.usbrev = USBREV_UNKNOWN;\n\t\treturn (USBD_INVAL);\n\t}\n\tsc->sc_bus.usbrev = USBREV_1_0;\n\n\tfor (i = 0; i < OHCI_HASH_SIZE; i++)\n\t\tLIST_INIT(&sc->sc_hash_tds[i]);\n\tfor (i = 0; i < OHCI_HASH_SIZE; i++)\n\t\tLIST_INIT(&sc->sc_hash_itds[i]);\n\n\tSIMPLEQ_INIT(&sc->sc_free_xfers);\n\n\t/* XXX determine alignment by R/W */\n\t/* Allocate the HCCA area. */\n\terr = usb_allocmem(&sc->sc_bus, OHCI_HCCA_SIZE, \n\t\t\t OHCI_HCCA_ALIGN, &sc->sc_hccadma);\n\tif (err)\n\t\treturn (err);\n\tsc->sc_hcca = (struct ohci_hcca *)KERNADDR(&sc->sc_hccadma);\n\tmemset(sc->sc_hcca, 0, OHCI_HCCA_SIZE);\n\n\tsc->sc_eintrs = OHCI_NORMAL_INTRS;\n\n\t/* Allocate dummy ED that starts the control list. */\n\tsc->sc_ctrl_head = ohci_alloc_sed(sc);\n\tif (sc->sc_ctrl_head == NULL) {\n\t\terr = USBD_NOMEM;\n\t\tgoto bad1;\n\t}\n\tsc->sc_ctrl_head->ed.ed_flags |= htole32(OHCI_ED_SKIP);\n\n\t/* Allocate dummy ED that starts the bulk list. */\n\tsc->sc_bulk_head = ohci_alloc_sed(sc);\n\tif (sc->sc_bulk_head == NULL) {\n\t\terr = USBD_NOMEM;\n\t\tgoto bad2;\n\t}\n\tsc->sc_bulk_head->ed.ed_flags |= htole32(OHCI_ED_SKIP);\n\n\t/* Allocate dummy ED that starts the isochronous list. */\n\tsc->sc_isoc_head = ohci_alloc_sed(sc);\n\tif (sc->sc_isoc_head == NULL) {\n\t\terr = USBD_NOMEM;\n\t\tgoto bad3;\n\t}\n\tsc->sc_isoc_head->ed.ed_flags |= htole32(OHCI_ED_SKIP);\n\n\t/* Allocate all the dummy EDs that make up the interrupt tree. */\n\tfor (i = 0; i < OHCI_NO_EDS; i++) {\n\t\tsed = ohci_alloc_sed(sc);\n\t\tif (sed == NULL) {\n\t\t\twhile (--i >= 0)\n\t\t\t\tohci_free_sed(sc, sc->sc_eds[i]);\n\t\t\terr = USBD_NOMEM;\n\t\t\tgoto bad4;\n\t\t}\n\t\t/* All ED fields are set to 0. */\n\t\tsc->sc_eds[i] = sed;\n\t\tsed->ed.ed_flags |= htole32(OHCI_ED_SKIP);\n\t\tif (i != 0)\n\t\t\tpsed = sc->sc_eds[(i-1) / 2];\n\t\telse\n\t\t\tpsed= sc->sc_isoc_head;\n\t\tsed->next = psed;\n\t\tsed->ed.ed_nexted = htole32(psed->physaddr);\n\t}\n\t/* \n\t * Fill HCCA interrupt table.  The bit reversal is to get\n\t * the tree set up properly to spread the interrupts.\n\t */\n\tfor (i = 0; i < OHCI_NO_INTRS; i++)\n\t\tsc->sc_hcca->hcca_interrupt_table[revbits[i]] = \n\t\t    htole32(sc->sc_eds[OHCI_NO_EDS-OHCI_NO_INTRS+i]->physaddr);\n\n#ifdef OHCI_DEBUG\n\tif (ohcidebug > 15) {\n\t\tfor (i = 0; i < OHCI_NO_EDS; i++) {\n\t\t\tprintf(\"ed#%d \", i);\n\t\t\tohci_dump_ed(sc->sc_eds[i]);\n\t\t}\n\t\tprintf(\"iso \");\n\t\tohci_dump_ed(sc->sc_isoc_head);\n\t}\n#endif\n\n\t/* Determine in what context we are running. */\n\tctl = OREAD4(sc, OHCI_CONTROL);\n\tif (ctl & OHCI_IR) {\n\t\t/* SMM active, request change */\n\t\tDPRINTF((\"ohci_init: SMM active, request owner change\\n\"));\n\t\ts = OREAD4(sc, OHCI_COMMAND_STATUS);\n\t\tOWRITE4(sc, OHCI_COMMAND_STATUS, s | OHCI_OCR);\n\t\tfor (i = 0; i < 100 && (ctl & OHCI_IR); i++) {\n\t\t\tusb_delay_ms(&sc->sc_bus, 1);\n\t\t\tctl = OREAD4(sc, OHCI_CONTROL);\n\t\t}\n\t\tif ((ctl & OHCI_IR) == 0) {\n\t\t\tprintf(\"%s: SMM does not respond, resetting\\n\",\n\t\t\t       USBDEVNAME(sc->sc_bus.bdev));\n\t\t\tOWRITE4(sc, OHCI_CONTROL, OHCI_HCFS_RESET);\n\t\t\tgoto reset;\n\t\t}\n\t} else if ((ctl & OHCI_HCFS_MASK) != OHCI_HCFS_RESET) {\n\t\t/* BIOS started controller. */\n\t\tDPRINTF((\"ohci_init: BIOS active\\n\"));\n\t\tif ((ctl & OHCI_HCFS_MASK) != OHCI_HCFS_OPERATIONAL) {\n\t\t\tOWRITE4(sc, OHCI_CONTROL, OHCI_HCFS_OPERATIONAL);\n\t\t\tusb_delay_ms(&sc->sc_bus, USB_RESUME_DELAY);\n\t\t}\n\t} else {\n\t\tDPRINTF((\"ohci_init: cold started\\n\"));\n\treset:\n\t\t/* Controller was cold started. */\n\t\tusb_delay_ms(&sc->sc_bus, USB_BUS_RESET_DELAY);\n\t}\n\n\t/*\n\t * This reset should not be necessary according to the OHCI spec, but\n\t * without it some controllers do not start.\n\t */\n\tDPRINTF((\"%s: resetting\\n\", USBDEVNAME(sc->sc_bus.bdev)));\n\tOWRITE4(sc, OHCI_CONTROL, OHCI_HCFS_RESET);\n\tusb_delay_ms(&sc->sc_bus, USB_BUS_RESET_DELAY);\n\n\t/* We now own the host controller and the bus has been reset. */\n\tival = OHCI_GET_IVAL(OREAD4(sc, OHCI_FM_INTERVAL));\n\n\tOWRITE4(sc, OHCI_COMMAND_STATUS, OHCI_HCR); /* Reset HC */\n\t/* Nominal time for a reset is 10 us. */\n\tfor (i = 0; i < 10; i++) {\n\t\tdelay(10);\n\t\thcr = OREAD4(sc, OHCI_COMMAND_STATUS) & OHCI_HCR;\n\t\tif (!hcr)\n\t\t\tbreak;\n\t}\n\tif (hcr) {\n\t\tprintf(\"%s: reset timeout\\n\", USBDEVNAME(sc->sc_bus.bdev));\n\t\terr = USBD_IOERROR;\n\t\tgoto bad5;\n\t}\n#ifdef OHCI_DEBUG\n\tif (ohcidebug > 15)\n\t\tohci_dumpregs(sc);\n#endif\n\n\t/* The controller is now in SUSPEND state, we have 2ms to finish. */\n\n\t/* Set up HC registers. */\n\tOWRITE4(sc, OHCI_HCCA, DMAADDR(&sc->sc_hccadma));\n\tOWRITE4(sc, OHCI_CONTROL_HEAD_ED, sc->sc_ctrl_head->physaddr);\n\tOWRITE4(sc, OHCI_BULK_HEAD_ED, sc->sc_bulk_head->physaddr);\n\t/* disable all interrupts and then switch on all desired interrupts */\n\tOWRITE4(sc, OHCI_INTERRUPT_DISABLE, OHCI_ALL_INTRS);\n\tOWRITE4(sc, OHCI_INTERRUPT_ENABLE, sc->sc_eintrs | OHCI_MIE);\n\t/* switch on desired functional features */\n\tctl = OREAD4(sc, OHCI_CONTROL);\n\tctl &= ~(OHCI_CBSR_MASK | OHCI_LES | OHCI_HCFS_MASK | OHCI_IR);\n\tctl |= OHCI_PLE | OHCI_IE | OHCI_CLE | OHCI_BLE |\n\t\tOHCI_RATIO_1_4 | OHCI_HCFS_OPERATIONAL;\n\t/* And finally start it! */\n\tOWRITE4(sc, OHCI_CONTROL, ctl);\n\n\t/*\n\t * The controller is now OPERATIONAL.  Set a some final\n\t * registers that should be set earlier, but that the\n\t * controller ignores when in the SUSPEND state.\n\t */\n\tfm = (OREAD4(sc, OHCI_FM_INTERVAL) & OHCI_FIT) ^ OHCI_FIT;\n\tfm |= OHCI_FSMPS(ival) | ival;\n\tOWRITE4(sc, OHCI_FM_INTERVAL, fm);\n\tper = OHCI_PERIODIC(ival); /* 90% periodic */\n\tOWRITE4(sc, OHCI_PERIODIC_START, per);\n\n\t/* Fiddle the No OverCurrent Protection bit to avoid chip bug. */\n\tdesca = OREAD4(sc, OHCI_RH_DESCRIPTOR_A);\n\tOWRITE4(sc, OHCI_RH_DESCRIPTOR_A, desca | OHCI_NOCP);\n\tOWRITE4(sc, OHCI_RH_STATUS, OHCI_LPSC); /* Enable port power */\n\tusb_delay_ms(&sc->sc_bus, OHCI_ENABLE_POWER_DELAY);\n\tOWRITE4(sc, OHCI_RH_DESCRIPTOR_A, desca);\n\n\t/*\n\t * The AMD756 requires a delay before re-reading the register,\n\t * otherwise it will occasionally report 0 ports.\n\t */\n\tusb_delay_ms(&sc->sc_bus, OHCI_READ_DESC_DELAY);\n\tsc->sc_noport = OHCI_GET_NDP(OREAD4(sc, OHCI_RH_DESCRIPTOR_A));\n\n#ifdef OHCI_DEBUG\n\tif (ohcidebug > 5)\n\t\tohci_dumpregs(sc);\n#endif\n\t\n\t/* Set up the bus struct. */\n\tsc->sc_bus.methods = &ohci_bus_methods;\n\tsc->sc_bus.pipe_size = sizeof(struct ohci_pipe);\n\n#if defined(__NetBSD__) || defined(__OpenBSD__)\n\tsc->sc_powerhook = powerhook_establish(ohci_power, sc);\n\tsc->sc_shutdownhook = shutdownhook_establish(ohci_shutdown, sc);\n#endif\n\n\treturn (USBD_NORMAL_COMPLETION);\n\n bad5:\n\tfor (i = 0; i < OHCI_NO_EDS; i++)\n\t\tohci_free_sed(sc, sc->sc_eds[i]);\n bad4:\n\tohci_free_sed(sc, sc->sc_isoc_head);\n bad3:\n\tohci_free_sed(sc, sc->sc_ctrl_head);\n bad2:\n\tohci_free_sed(sc, sc->sc_bulk_head);\n bad1:\n\tusb_freemem(&sc->sc_bus, &sc->sc_hccadma);\n\treturn (err);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static ohci_soft_ed_t",
      "ohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "ohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
      "ohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
      "Static usbd_status",
      "Static usbd_status",
      "ohci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "ohci_device_setintr __P((ohci_softc_t *sc, \n\t\t\t    struct ohci_pipe *pipe, int ival));",
      "ohci_rhsc_able __P((ohci_softc_t *, int));",
      "Static u_int8_t revbits[OHCI_NO_INTRS] = \n  { 0x00, 0x10, 0x08, 0x18, 0x04, 0x14, 0x0c, 0x1c,\n    0x02, 0x12, 0x0a, 0x1a, 0x06, 0x16, 0x0e, 0x1e,\n    0x01, 0x11, 0x09, 0x19, 0x05, 0x15, 0x0d, 0x1d,\n    0x03, 0x13, 0x0b, 0x1b, 0x07, 0x17, 0x0f, 0x1f };",
      "Static struct",
      "usbd_bus_methods ohci_bus_methods = {\n\tohci_open,\n\tohci_softintr,\n\tohci_poll,\n\tohci_allocm,\n\tohci_freem,\n\tohci_allocx,\n\tohci_freex,\n};",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
      "ohci_intr1 __P((ohci_softc_t *));",
      "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
      "ohci_physaddr_t a;",
      "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;",
      "ohci_physaddr_t a;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usb_freemem",
          "args": [
            "&sc->sc_bus",
            "&sc->sc_hccadma"
          ],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "usb_freemem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_mem.c",
          "lines": "271-291",
          "snippet": "void\nusb_freemem(bus, p)\n\tusbd_bus_handle bus;\n        usb_dma_t *p;\n{\n\tstruct usb_frag_dma *f;\n\tint s;\n\n\tif (p->block->fullblock) {\n\t\tDPRINTFN(1, (\"usb_freemem: large free\\n\"));\n\t\tusb_block_freemem(p->block);\n\t\treturn;\n\t}\n\tf = KERNADDR(p);\n\tf->block = p->block;\n\tf->offs = p->offs;\n\ts = splusb();\n\tLIST_INSERT_HEAD(&usb_frag_freelist, f, next);\n\tsplx(s);\n\tDPRINTFN(5, (\"usb_freemem: frag=%p\\n\", f));\n}",
          "includes": [
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>\t/* just for usb_dma_t */",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/proc.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>\t\t/* for usbdivar.h */",
            "#include <sys/queue.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static LIST_HEAD(, usb_frag_dma) usb_frag_freelist =\n\tLIST_HEAD_INITIALIZER(usb_frag_freelist);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\t/* just for usb_dma_t */\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/proc.h>\n#include <machine/bus.h>\n#include <sys/device.h>\t\t/* for usbdivar.h */\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic LIST_HEAD(, usb_frag_dma) usb_frag_freelist =\n\tLIST_HEAD_INITIALIZER(usb_frag_freelist);\n\nvoid\nusb_freemem(bus, p)\n\tusbd_bus_handle bus;\n        usb_dma_t *p;\n{\n\tstruct usb_frag_dma *f;\n\tint s;\n\n\tif (p->block->fullblock) {\n\t\tDPRINTFN(1, (\"usb_freemem: large free\\n\"));\n\t\tusb_block_freemem(p->block);\n\t\treturn;\n\t}\n\tf = KERNADDR(p);\n\tf->block = p->block;\n\tf->offs = p->offs;\n\ts = splusb();\n\tLIST_INSERT_HEAD(&usb_frag_freelist, f, next);\n\tsplx(s);\n\tDPRINTFN(5, (\"usb_freemem: frag=%p\\n\", f));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ohci_free_sed",
          "args": [
            "sc",
            "sc->sc_bulk_head"
          ],
          "line": 888
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_free_sed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "417-424",
          "snippet": "void\nohci_free_sed(sc, sed)\n\tohci_softc_t *sc;\n\tohci_soft_ed_t *sed;\n{\n\tsed->next = sc->sc_freeeds;\n\tsc->sc_freeeds = sed;\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static ohci_soft_ed_t",
            "ohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));",
            "ohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
            "ohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
            "ohci_rhsc_able __P((ohci_softc_t *, int));",
            "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
            "ohci_intr1 __P((ohci_softc_t *));",
            "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_ed_t;\nohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));\nohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nohci_rhsc_able __P((ohci_softc_t *, int));\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nvoid\nohci_free_sed(sc, sed)\n\tohci_softc_t *sc;\n\tohci_soft_ed_t *sed;\n{\n\tsed->next = sc->sc_freeeds;\n\tsc->sc_freeeds = sed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "shutdownhook_establish",
          "args": [
            "ohci_shutdown",
            "sc"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "powerhook_establish",
          "args": [
            "ohci_power",
            "sc"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ohci_dumpregs",
          "args": [
            "sc"
          ],
          "line": 866
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_dumpregs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "981-1019",
          "snippet": "void\nohci_dumpregs(sc)\n\tohci_softc_t *sc;\n{\n\tDPRINTF((\"ohci_dumpregs: rev=0x%08x control=0x%08x command=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_REVISION),\n\t\t OREAD4(sc, OHCI_CONTROL),\n\t\t OREAD4(sc, OHCI_COMMAND_STATUS)));\n\tDPRINTF((\"               intrstat=0x%08x intre=0x%08x intrd=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_INTERRUPT_STATUS),\n\t\t OREAD4(sc, OHCI_INTERRUPT_ENABLE),\n\t\t OREAD4(sc, OHCI_INTERRUPT_DISABLE)));\n\tDPRINTF((\"               hcca=0x%08x percur=0x%08x ctrlhd=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_HCCA),\n\t\t OREAD4(sc, OHCI_PERIOD_CURRENT_ED),\n\t\t OREAD4(sc, OHCI_CONTROL_HEAD_ED)));\n\tDPRINTF((\"               ctrlcur=0x%08x bulkhd=0x%08x bulkcur=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_CONTROL_CURRENT_ED),\n\t\t OREAD4(sc, OHCI_BULK_HEAD_ED),\n\t\t OREAD4(sc, OHCI_BULK_CURRENT_ED)));\n\tDPRINTF((\"               done=0x%08x fmival=0x%08x fmrem=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_DONE_HEAD),\n\t\t OREAD4(sc, OHCI_FM_INTERVAL),\n\t\t OREAD4(sc, OHCI_FM_REMAINING)));\n\tDPRINTF((\"               fmnum=0x%08x perst=0x%08x lsthrs=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_FM_NUMBER),\n\t\t OREAD4(sc, OHCI_PERIODIC_START),\n\t\t OREAD4(sc, OHCI_LS_THRESHOLD)));\n\tDPRINTF((\"               desca=0x%08x descb=0x%08x stat=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_RH_DESCRIPTOR_A),\n\t\t OREAD4(sc, OHCI_RH_DESCRIPTOR_B),\n\t\t OREAD4(sc, OHCI_RH_STATUS)));\n\tDPRINTF((\"               port1=0x%08x port2=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_RH_PORT_STATUS(1)),\n\t\t OREAD4(sc, OHCI_RH_PORT_STATUS(2))));\n\tDPRINTF((\"         HCCA: frame_number=0x%04x done_head=0x%08x\\n\",\n\t\t le32toh(sc->sc_hcca->hcca_frame_number),\n\t\t le32toh(sc->sc_hcca->hcca_done_head)));\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "ohci_rhsc_able __P((ohci_softc_t *, int));",
            "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
            "ohci_intr1 __P((ohci_softc_t *));",
            "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nohci_rhsc_able __P((ohci_softc_t *, int));\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nvoid\nohci_dumpregs(sc)\n\tohci_softc_t *sc;\n{\n\tDPRINTF((\"ohci_dumpregs: rev=0x%08x control=0x%08x command=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_REVISION),\n\t\t OREAD4(sc, OHCI_CONTROL),\n\t\t OREAD4(sc, OHCI_COMMAND_STATUS)));\n\tDPRINTF((\"               intrstat=0x%08x intre=0x%08x intrd=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_INTERRUPT_STATUS),\n\t\t OREAD4(sc, OHCI_INTERRUPT_ENABLE),\n\t\t OREAD4(sc, OHCI_INTERRUPT_DISABLE)));\n\tDPRINTF((\"               hcca=0x%08x percur=0x%08x ctrlhd=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_HCCA),\n\t\t OREAD4(sc, OHCI_PERIOD_CURRENT_ED),\n\t\t OREAD4(sc, OHCI_CONTROL_HEAD_ED)));\n\tDPRINTF((\"               ctrlcur=0x%08x bulkhd=0x%08x bulkcur=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_CONTROL_CURRENT_ED),\n\t\t OREAD4(sc, OHCI_BULK_HEAD_ED),\n\t\t OREAD4(sc, OHCI_BULK_CURRENT_ED)));\n\tDPRINTF((\"               done=0x%08x fmival=0x%08x fmrem=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_DONE_HEAD),\n\t\t OREAD4(sc, OHCI_FM_INTERVAL),\n\t\t OREAD4(sc, OHCI_FM_REMAINING)));\n\tDPRINTF((\"               fmnum=0x%08x perst=0x%08x lsthrs=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_FM_NUMBER),\n\t\t OREAD4(sc, OHCI_PERIODIC_START),\n\t\t OREAD4(sc, OHCI_LS_THRESHOLD)));\n\tDPRINTF((\"               desca=0x%08x descb=0x%08x stat=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_RH_DESCRIPTOR_A),\n\t\t OREAD4(sc, OHCI_RH_DESCRIPTOR_B),\n\t\t OREAD4(sc, OHCI_RH_STATUS)));\n\tDPRINTF((\"               port1=0x%08x port2=0x%08x\\n\",\n\t\t OREAD4(sc, OHCI_RH_PORT_STATUS(1)),\n\t\t OREAD4(sc, OHCI_RH_PORT_STATUS(2))));\n\tDPRINTF((\"         HCCA: frame_number=0x%04x done_head=0x%08x\\n\",\n\t\t le32toh(sc->sc_hcca->hcca_frame_number),\n\t\t le32toh(sc->sc_hcca->hcca_done_head)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "OHCI_GET_NDP",
          "args": [
            "OREAD4(sc, OHCI_RH_DESCRIPTOR_A)"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OREAD4",
          "args": [
            "sc",
            "OHCI_RH_DESCRIPTOR_A"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_delay_ms",
          "args": [
            "&sc->sc_bus",
            "OHCI_READ_DESC_DELAY"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "usb_delay_ms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "301-313",
          "snippet": "void\nusb_delay_ms(bus, ms)\n\tusbd_bus_handle bus;\n\tu_int ms;\n{\n\textern int cold;\n\n\t/* Wait at least two clock ticks so we know the time has passed. */\n\tif (bus->use_polling || cold)\n\t\tdelay((ms+1) * 1000);\n\telse\n\t\ttsleep(&ms, PRIBIO, \"usbdly\", (ms*hz+999)/1000 + 1);\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_getnewaddr __P((usbd_bus_handle bus));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_getnewaddr __P((usbd_bus_handle bus));\n\nvoid\nusb_delay_ms(bus, ms)\n\tusbd_bus_handle bus;\n\tu_int ms;\n{\n\textern int cold;\n\n\t/* Wait at least two clock ticks so we know the time has passed. */\n\tif (bus->use_polling || cold)\n\t\tdelay((ms+1) * 1000);\n\telse\n\t\ttsleep(&ms, PRIBIO, \"usbdly\", (ms*hz+999)/1000 + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OWRITE4",
          "args": [
            "sc",
            "OHCI_RH_DESCRIPTOR_A",
            "desca"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OWRITE4",
          "args": [
            "sc",
            "OHCI_RH_STATUS",
            "OHCI_LPSC"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OWRITE4",
          "args": [
            "sc",
            "OHCI_RH_DESCRIPTOR_A",
            "desca | OHCI_NOCP"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OREAD4",
          "args": [
            "sc",
            "OHCI_RH_DESCRIPTOR_A"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OWRITE4",
          "args": [
            "sc",
            "OHCI_PERIODIC_START",
            "per"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OHCI_PERIODIC",
          "args": [
            "ival"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OWRITE4",
          "args": [
            "sc",
            "OHCI_FM_INTERVAL",
            "fm"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OHCI_FSMPS",
          "args": [
            "ival"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OREAD4",
          "args": [
            "sc",
            "OHCI_FM_INTERVAL"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OWRITE4",
          "args": [
            "sc",
            "OHCI_CONTROL",
            "ctl"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OREAD4",
          "args": [
            "sc",
            "OHCI_CONTROL"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OWRITE4",
          "args": [
            "sc",
            "OHCI_INTERRUPT_ENABLE",
            "sc->sc_eintrs | OHCI_MIE"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OWRITE4",
          "args": [
            "sc",
            "OHCI_INTERRUPT_DISABLE",
            "OHCI_ALL_INTRS"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OWRITE4",
          "args": [
            "sc",
            "OHCI_BULK_HEAD_ED",
            "sc->sc_bulk_head->physaddr"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OWRITE4",
          "args": [
            "sc",
            "OHCI_CONTROL_HEAD_ED",
            "sc->sc_ctrl_head->physaddr"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OWRITE4",
          "args": [
            "sc",
            "OHCI_HCCA",
            "DMAADDR(&sc->sc_hccadma)"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DMAADDR",
          "args": [
            "&sc->sc_hccadma"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: reset timeout\\n\"",
            "USBDEVNAME(sc->sc_bus.bdev)"
          ],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_bus.bdev"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OREAD4",
          "args": [
            "sc",
            "OHCI_COMMAND_STATUS"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "10"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_delay_ms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "316-322",
          "snippet": "void\nusbd_delay_ms(dev, ms)\n\tusbd_device_handle dev;\n\tu_int ms;\n{\n\tusb_delay_ms(dev->bus, ms);\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_set_config __P((usbd_device_handle, int));",
            "usbd_getnewaddr __P((usbd_bus_handle bus));",
            "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_set_config __P((usbd_device_handle, int));\nusbd_getnewaddr __P((usbd_bus_handle bus));\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\n\nvoid\nusbd_delay_ms(dev, ms)\n\tusbd_device_handle dev;\n\tu_int ms;\n{\n\tusb_delay_ms(dev->bus, ms);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OWRITE4",
          "args": [
            "sc",
            "OHCI_COMMAND_STATUS",
            "OHCI_HCR"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OHCI_GET_IVAL",
          "args": [
            "OREAD4(sc, OHCI_FM_INTERVAL)"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OREAD4",
          "args": [
            "sc",
            "OHCI_FM_INTERVAL"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OWRITE4",
          "args": [
            "sc",
            "OHCI_CONTROL",
            "OHCI_HCFS_RESET"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: resetting\\n\", USBDEVNAME(sc->sc_bus.bdev))"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_bus.bdev"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ohci_init: cold started\\n\")"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OWRITE4",
          "args": [
            "sc",
            "OHCI_CONTROL",
            "OHCI_HCFS_OPERATIONAL"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ohci_init: BIOS active\\n\")"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OWRITE4",
          "args": [
            "sc",
            "OHCI_CONTROL",
            "OHCI_HCFS_RESET"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_bus.bdev"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OREAD4",
          "args": [
            "sc",
            "OHCI_CONTROL"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OWRITE4",
          "args": [
            "sc",
            "OHCI_COMMAND_STATUS",
            "s | OHCI_OCR"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OREAD4",
          "args": [
            "sc",
            "OHCI_COMMAND_STATUS"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ohci_init: SMM active, request owner change\\n\")"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OREAD4",
          "args": [
            "sc",
            "OHCI_CONTROL"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ohci_dump_ed",
          "args": [
            "sc->sc_isoc_head"
          ],
          "line": 758
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_dump_ed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "1842-1859",
          "snippet": "void\nohci_dump_ed(sed)\n\tohci_soft_ed_t *sed;\n{\n\tDPRINTF((\"ED(%p) at 0x%08lx: addr=%d endpt=%d maxp=%d %b\\ntailp=0x%08lx \"\n\t\t \"headflags=%b headp=0x%08lx nexted=0x%08lx\\n\",\n\t\t sed, (u_long)sed->physaddr, \n\t\t OHCI_ED_GET_FA(le32toh(sed->ed.ed_flags)),\n\t\t OHCI_ED_GET_EN(le32toh(sed->ed.ed_flags)),\n\t\t OHCI_ED_GET_MAXP(le32toh(sed->ed.ed_flags)),\n\t\t (int)le32toh(sed->ed.ed_flags),\n\t\t \"\\20\\14OUT\\15IN\\16LOWSPEED\\17SKIP\\20ISO\",\n\t\t (u_long)le32toh(sed->ed.ed_tailp),\n\t\t (u_long)le32toh(sed->ed.ed_headp),\n\t\t \"\\20\\1HALT\\2CARRY\",\n\t\t (u_long)le32toh(sed->ed.ed_headp),\n\t\t (u_long)le32toh(sed->ed.ed_nexted)));\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static ohci_soft_ed_t",
            "ohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));",
            "ohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
            "ohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_ed_t;\nohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));\nohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\n\nvoid\nohci_dump_ed(sed)\n\tohci_soft_ed_t *sed;\n{\n\tDPRINTF((\"ED(%p) at 0x%08lx: addr=%d endpt=%d maxp=%d %b\\ntailp=0x%08lx \"\n\t\t \"headflags=%b headp=0x%08lx nexted=0x%08lx\\n\",\n\t\t sed, (u_long)sed->physaddr, \n\t\t OHCI_ED_GET_FA(le32toh(sed->ed.ed_flags)),\n\t\t OHCI_ED_GET_EN(le32toh(sed->ed.ed_flags)),\n\t\t OHCI_ED_GET_MAXP(le32toh(sed->ed.ed_flags)),\n\t\t (int)le32toh(sed->ed.ed_flags),\n\t\t \"\\20\\14OUT\\15IN\\16LOWSPEED\\17SKIP\\20ISO\",\n\t\t (u_long)le32toh(sed->ed.ed_tailp),\n\t\t (u_long)le32toh(sed->ed.ed_headp),\n\t\t \"\\20\\1HALT\\2CARRY\",\n\t\t (u_long)le32toh(sed->ed.ed_headp),\n\t\t (u_long)le32toh(sed->ed.ed_nexted)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "sc->sc_eds[OHCI_NO_EDS-OHCI_NO_INTRS+i]->physaddr"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "psed->physaddr"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "OHCI_ED_SKIP"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ohci_alloc_sed",
          "args": [
            "sc"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "OHCI_ED_SKIP"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ohci_alloc_sed",
          "args": [
            "sc"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "OHCI_ED_SKIP"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ohci_alloc_sed",
          "args": [
            "sc"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "OHCI_ED_SKIP"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ohci_alloc_sed",
          "args": [
            "sc"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "sc->sc_hcca",
            "0",
            "OHCI_HCCA_SIZE"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KERNADDR",
          "args": [
            "&sc->sc_hccadma"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_allocmem",
          "args": [
            "&sc->sc_bus",
            "OHCI_HCCA_SIZE",
            "OHCI_HCCA_ALIGN",
            "&sc->sc_hccadma"
          ],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "usb_allocmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_mem.c",
          "lines": "216-269",
          "snippet": "usbd_status\nusb_allocmem(bus, size, align, p)\n\tusbd_bus_handle bus;\n\tsize_t size;\n\tsize_t align;\n        usb_dma_t *p;\n{\n\tbus_dma_tag_t tag = bus->dmatag;\n\tusbd_status err;\n\tstruct usb_frag_dma *f;\n\tusb_dma_block_t *b;\n\tint i;\n\tint s;\n\n\t/* If the request is large then just use a full block. */\n\tif (size > USB_MEM_SMALL || align > USB_MEM_SMALL) {\n\t\tDPRINTFN(1, (\"usb_allocmem: large alloc %d\\n\", (int)size));\n\t\tsize = (size + USB_MEM_BLOCK - 1) & ~(USB_MEM_BLOCK - 1);\n\t\terr = usb_block_allocmem(tag, size, align, &p->block);\n\t\tif (!err) {\n\t\t\tp->block->fullblock = 1;\n\t\t\tp->offs = 0;\n\t\t}\n\t\treturn (err);\n\t}\n\t\n\ts = splusb();\n\t/* Check for free fragments. */\n\tfor (f = LIST_FIRST(&usb_frag_freelist); f; f = LIST_NEXT(f, next))\n\t\tif (f->block->tag == tag)\n\t\t\tbreak;\n\tif (f == NULL) {\n\t\tDPRINTFN(1, (\"usb_allocmem: adding fragments\\n\"));\n\t\terr = usb_block_allocmem(tag, USB_MEM_BLOCK, USB_MEM_SMALL,&b);\n\t\tif (err) {\n\t\t\tsplx(s);\n\t\t\treturn (err);\n\t\t}\n\t\tb->fullblock = 0;\n\t\tfor (i = 0; i < USB_MEM_BLOCK; i += USB_MEM_SMALL) {\n\t\t\tf = (struct usb_frag_dma *)(b->kaddr + i);\n\t\t\tf->block = b;\n\t\t\tf->offs = i;\n\t\t\tLIST_INSERT_HEAD(&usb_frag_freelist, f, next);\n\t\t}\n\t\tf = LIST_FIRST(&usb_frag_freelist);\n\t}\n\tp->block = f->block;\n\tp->offs = f->offs;\n\tLIST_REMOVE(f, next);\n\tsplx(s);\n\tDPRINTFN(5, (\"usb_allocmem: use frag=%p size=%d\\n\", f, (int)size));\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>\t/* just for usb_dma_t */",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/proc.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>\t\t/* for usbdivar.h */",
            "#include <sys/queue.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define USB_MEM_BLOCK (USB_MEM_SMALL * USB_MEM_CHUNKS)",
            "#define USB_MEM_SMALL 64"
          ],
          "globals_used": [
            "Static usbd_status",
            "usb_block_allocmem __P((bus_dma_tag_t, size_t, size_t,\n\t\t\t\t\t\tusb_dma_block_t **));",
            "usb_block_freemem  __P((usb_dma_block_t *));",
            "Static LIST_HEAD(, usb_frag_dma) usb_frag_freelist =\n\tLIST_HEAD_INITIALIZER(usb_frag_freelist);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\t/* just for usb_dma_t */\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/proc.h>\n#include <machine/bus.h>\n#include <sys/device.h>\t\t/* for usbdivar.h */\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define USB_MEM_BLOCK (USB_MEM_SMALL * USB_MEM_CHUNKS)\n#define USB_MEM_SMALL 64\n\nStatic usbd_status;\nusb_block_allocmem __P((bus_dma_tag_t, size_t, size_t,\n\t\t\t\t\t\tusb_dma_block_t **));\nusb_block_freemem  __P((usb_dma_block_t *));\nStatic LIST_HEAD(, usb_frag_dma) usb_frag_freelist =\n\tLIST_HEAD_INITIALIZER(usb_frag_freelist);\n\nusbd_status\nusb_allocmem(bus, size, align, p)\n\tusbd_bus_handle bus;\n\tsize_t size;\n\tsize_t align;\n        usb_dma_t *p;\n{\n\tbus_dma_tag_t tag = bus->dmatag;\n\tusbd_status err;\n\tstruct usb_frag_dma *f;\n\tusb_dma_block_t *b;\n\tint i;\n\tint s;\n\n\t/* If the request is large then just use a full block. */\n\tif (size > USB_MEM_SMALL || align > USB_MEM_SMALL) {\n\t\tDPRINTFN(1, (\"usb_allocmem: large alloc %d\\n\", (int)size));\n\t\tsize = (size + USB_MEM_BLOCK - 1) & ~(USB_MEM_BLOCK - 1);\n\t\terr = usb_block_allocmem(tag, size, align, &p->block);\n\t\tif (!err) {\n\t\t\tp->block->fullblock = 1;\n\t\t\tp->offs = 0;\n\t\t}\n\t\treturn (err);\n\t}\n\t\n\ts = splusb();\n\t/* Check for free fragments. */\n\tfor (f = LIST_FIRST(&usb_frag_freelist); f; f = LIST_NEXT(f, next))\n\t\tif (f->block->tag == tag)\n\t\t\tbreak;\n\tif (f == NULL) {\n\t\tDPRINTFN(1, (\"usb_allocmem: adding fragments\\n\"));\n\t\terr = usb_block_allocmem(tag, USB_MEM_BLOCK, USB_MEM_SMALL,&b);\n\t\tif (err) {\n\t\t\tsplx(s);\n\t\t\treturn (err);\n\t\t}\n\t\tb->fullblock = 0;\n\t\tfor (i = 0; i < USB_MEM_BLOCK; i += USB_MEM_SMALL) {\n\t\t\tf = (struct usb_frag_dma *)(b->kaddr + i);\n\t\t\tf->block = b;\n\t\t\tf->offs = i;\n\t\t\tLIST_INSERT_HEAD(&usb_frag_freelist, f, next);\n\t\t}\n\t\tf = LIST_FIRST(&usb_frag_freelist);\n\t}\n\tp->block = f->block;\n\tp->offs = f->offs;\n\tLIST_REMOVE(f, next);\n\tsplx(s);\n\tDPRINTFN(5, (\"usb_allocmem: use frag=%p size=%d\\n\", f, (int)size));\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_INIT",
          "args": [
            "&sc->sc_free_xfers"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_INIT",
          "args": [
            "&sc->sc_hash_itds[i]"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_INIT",
          "args": [
            "&sc->sc_hash_tds[i]"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_bus.bdev"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OHCI_REV_LO",
          "args": [
            "rev"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OHCI_REV_HI",
          "args": [
            "rev"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OHCI_REV_LEGACY",
          "args": [
            "rev"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OHCI_REV_LO",
          "args": [
            "rev"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OHCI_REV_HI",
          "args": [
            "rev"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OREAD4",
          "args": [
            "sc",
            "OHCI_REVISION"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_bus.bdev"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ohci_init: start\\n\")"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_ed_t;\nohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nStatic usbd_status;\nStatic usbd_status;\nohci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nohci_device_setintr __P((ohci_softc_t *sc, \n\t\t\t    struct ohci_pipe *pipe, int ival));\nohci_rhsc_able __P((ohci_softc_t *, int));\nStatic u_int8_t revbits[OHCI_NO_INTRS] = \n  { 0x00, 0x10, 0x08, 0x18, 0x04, 0x14, 0x0c, 0x1c,\n    0x02, 0x12, 0x0a, 0x1a, 0x06, 0x16, 0x0e, 0x1e,\n    0x01, 0x11, 0x09, 0x19, 0x05, 0x15, 0x0d, 0x1d,\n    0x03, 0x13, 0x0b, 0x1b, 0x07, 0x17, 0x0f, 0x1f };\nStatic struct;\nusbd_bus_methods ohci_bus_methods = {\n\tohci_open,\n\tohci_softintr,\n\tohci_poll,\n\tohci_allocm,\n\tohci_freem,\n\tohci_allocx,\n\tohci_freex,\n};\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_physaddr_t a;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\nohci_physaddr_t a;\n\nusbd_status\nohci_init(sc)\n\tohci_softc_t *sc;\n{\n\tohci_soft_ed_t *sed, *psed;\n\tusbd_status err;\n\tint i;\n\tu_int32_t s, ctl, ival, hcr, fm, per, rev, desca;\n\n\tDPRINTF((\"ohci_init: start\\n\"));\n#if defined(__OpenBSD__)\n\tprintf(\",\");\n#else\n\tprintf(\"%s:\", USBDEVNAME(sc->sc_bus.bdev));\n#endif\n\trev = OREAD4(sc, OHCI_REVISION);\n\tprintf(\" OHCI version %d.%d%s\\n\", OHCI_REV_HI(rev), OHCI_REV_LO(rev),\n\t       OHCI_REV_LEGACY(rev) ? \", legacy support\" : \"\");\n\n\tif (OHCI_REV_HI(rev) != 1 || OHCI_REV_LO(rev) != 0) {\n\t\tprintf(\"%s: unsupported OHCI revision\\n\", \n\t\t       USBDEVNAME(sc->sc_bus.bdev));\n\t\tsc->sc_bus.usbrev = USBREV_UNKNOWN;\n\t\treturn (USBD_INVAL);\n\t}\n\tsc->sc_bus.usbrev = USBREV_1_0;\n\n\tfor (i = 0; i < OHCI_HASH_SIZE; i++)\n\t\tLIST_INIT(&sc->sc_hash_tds[i]);\n\tfor (i = 0; i < OHCI_HASH_SIZE; i++)\n\t\tLIST_INIT(&sc->sc_hash_itds[i]);\n\n\tSIMPLEQ_INIT(&sc->sc_free_xfers);\n\n\t/* XXX determine alignment by R/W */\n\t/* Allocate the HCCA area. */\n\terr = usb_allocmem(&sc->sc_bus, OHCI_HCCA_SIZE, \n\t\t\t OHCI_HCCA_ALIGN, &sc->sc_hccadma);\n\tif (err)\n\t\treturn (err);\n\tsc->sc_hcca = (struct ohci_hcca *)KERNADDR(&sc->sc_hccadma);\n\tmemset(sc->sc_hcca, 0, OHCI_HCCA_SIZE);\n\n\tsc->sc_eintrs = OHCI_NORMAL_INTRS;\n\n\t/* Allocate dummy ED that starts the control list. */\n\tsc->sc_ctrl_head = ohci_alloc_sed(sc);\n\tif (sc->sc_ctrl_head == NULL) {\n\t\terr = USBD_NOMEM;\n\t\tgoto bad1;\n\t}\n\tsc->sc_ctrl_head->ed.ed_flags |= htole32(OHCI_ED_SKIP);\n\n\t/* Allocate dummy ED that starts the bulk list. */\n\tsc->sc_bulk_head = ohci_alloc_sed(sc);\n\tif (sc->sc_bulk_head == NULL) {\n\t\terr = USBD_NOMEM;\n\t\tgoto bad2;\n\t}\n\tsc->sc_bulk_head->ed.ed_flags |= htole32(OHCI_ED_SKIP);\n\n\t/* Allocate dummy ED that starts the isochronous list. */\n\tsc->sc_isoc_head = ohci_alloc_sed(sc);\n\tif (sc->sc_isoc_head == NULL) {\n\t\terr = USBD_NOMEM;\n\t\tgoto bad3;\n\t}\n\tsc->sc_isoc_head->ed.ed_flags |= htole32(OHCI_ED_SKIP);\n\n\t/* Allocate all the dummy EDs that make up the interrupt tree. */\n\tfor (i = 0; i < OHCI_NO_EDS; i++) {\n\t\tsed = ohci_alloc_sed(sc);\n\t\tif (sed == NULL) {\n\t\t\twhile (--i >= 0)\n\t\t\t\tohci_free_sed(sc, sc->sc_eds[i]);\n\t\t\terr = USBD_NOMEM;\n\t\t\tgoto bad4;\n\t\t}\n\t\t/* All ED fields are set to 0. */\n\t\tsc->sc_eds[i] = sed;\n\t\tsed->ed.ed_flags |= htole32(OHCI_ED_SKIP);\n\t\tif (i != 0)\n\t\t\tpsed = sc->sc_eds[(i-1) / 2];\n\t\telse\n\t\t\tpsed= sc->sc_isoc_head;\n\t\tsed->next = psed;\n\t\tsed->ed.ed_nexted = htole32(psed->physaddr);\n\t}\n\t/* \n\t * Fill HCCA interrupt table.  The bit reversal is to get\n\t * the tree set up properly to spread the interrupts.\n\t */\n\tfor (i = 0; i < OHCI_NO_INTRS; i++)\n\t\tsc->sc_hcca->hcca_interrupt_table[revbits[i]] = \n\t\t    htole32(sc->sc_eds[OHCI_NO_EDS-OHCI_NO_INTRS+i]->physaddr);\n\n#ifdef OHCI_DEBUG\n\tif (ohcidebug > 15) {\n\t\tfor (i = 0; i < OHCI_NO_EDS; i++) {\n\t\t\tprintf(\"ed#%d \", i);\n\t\t\tohci_dump_ed(sc->sc_eds[i]);\n\t\t}\n\t\tprintf(\"iso \");\n\t\tohci_dump_ed(sc->sc_isoc_head);\n\t}\n#endif\n\n\t/* Determine in what context we are running. */\n\tctl = OREAD4(sc, OHCI_CONTROL);\n\tif (ctl & OHCI_IR) {\n\t\t/* SMM active, request change */\n\t\tDPRINTF((\"ohci_init: SMM active, request owner change\\n\"));\n\t\ts = OREAD4(sc, OHCI_COMMAND_STATUS);\n\t\tOWRITE4(sc, OHCI_COMMAND_STATUS, s | OHCI_OCR);\n\t\tfor (i = 0; i < 100 && (ctl & OHCI_IR); i++) {\n\t\t\tusb_delay_ms(&sc->sc_bus, 1);\n\t\t\tctl = OREAD4(sc, OHCI_CONTROL);\n\t\t}\n\t\tif ((ctl & OHCI_IR) == 0) {\n\t\t\tprintf(\"%s: SMM does not respond, resetting\\n\",\n\t\t\t       USBDEVNAME(sc->sc_bus.bdev));\n\t\t\tOWRITE4(sc, OHCI_CONTROL, OHCI_HCFS_RESET);\n\t\t\tgoto reset;\n\t\t}\n\t} else if ((ctl & OHCI_HCFS_MASK) != OHCI_HCFS_RESET) {\n\t\t/* BIOS started controller. */\n\t\tDPRINTF((\"ohci_init: BIOS active\\n\"));\n\t\tif ((ctl & OHCI_HCFS_MASK) != OHCI_HCFS_OPERATIONAL) {\n\t\t\tOWRITE4(sc, OHCI_CONTROL, OHCI_HCFS_OPERATIONAL);\n\t\t\tusb_delay_ms(&sc->sc_bus, USB_RESUME_DELAY);\n\t\t}\n\t} else {\n\t\tDPRINTF((\"ohci_init: cold started\\n\"));\n\treset:\n\t\t/* Controller was cold started. */\n\t\tusb_delay_ms(&sc->sc_bus, USB_BUS_RESET_DELAY);\n\t}\n\n\t/*\n\t * This reset should not be necessary according to the OHCI spec, but\n\t * without it some controllers do not start.\n\t */\n\tDPRINTF((\"%s: resetting\\n\", USBDEVNAME(sc->sc_bus.bdev)));\n\tOWRITE4(sc, OHCI_CONTROL, OHCI_HCFS_RESET);\n\tusb_delay_ms(&sc->sc_bus, USB_BUS_RESET_DELAY);\n\n\t/* We now own the host controller and the bus has been reset. */\n\tival = OHCI_GET_IVAL(OREAD4(sc, OHCI_FM_INTERVAL));\n\n\tOWRITE4(sc, OHCI_COMMAND_STATUS, OHCI_HCR); /* Reset HC */\n\t/* Nominal time for a reset is 10 us. */\n\tfor (i = 0; i < 10; i++) {\n\t\tdelay(10);\n\t\thcr = OREAD4(sc, OHCI_COMMAND_STATUS) & OHCI_HCR;\n\t\tif (!hcr)\n\t\t\tbreak;\n\t}\n\tif (hcr) {\n\t\tprintf(\"%s: reset timeout\\n\", USBDEVNAME(sc->sc_bus.bdev));\n\t\terr = USBD_IOERROR;\n\t\tgoto bad5;\n\t}\n#ifdef OHCI_DEBUG\n\tif (ohcidebug > 15)\n\t\tohci_dumpregs(sc);\n#endif\n\n\t/* The controller is now in SUSPEND state, we have 2ms to finish. */\n\n\t/* Set up HC registers. */\n\tOWRITE4(sc, OHCI_HCCA, DMAADDR(&sc->sc_hccadma));\n\tOWRITE4(sc, OHCI_CONTROL_HEAD_ED, sc->sc_ctrl_head->physaddr);\n\tOWRITE4(sc, OHCI_BULK_HEAD_ED, sc->sc_bulk_head->physaddr);\n\t/* disable all interrupts and then switch on all desired interrupts */\n\tOWRITE4(sc, OHCI_INTERRUPT_DISABLE, OHCI_ALL_INTRS);\n\tOWRITE4(sc, OHCI_INTERRUPT_ENABLE, sc->sc_eintrs | OHCI_MIE);\n\t/* switch on desired functional features */\n\tctl = OREAD4(sc, OHCI_CONTROL);\n\tctl &= ~(OHCI_CBSR_MASK | OHCI_LES | OHCI_HCFS_MASK | OHCI_IR);\n\tctl |= OHCI_PLE | OHCI_IE | OHCI_CLE | OHCI_BLE |\n\t\tOHCI_RATIO_1_4 | OHCI_HCFS_OPERATIONAL;\n\t/* And finally start it! */\n\tOWRITE4(sc, OHCI_CONTROL, ctl);\n\n\t/*\n\t * The controller is now OPERATIONAL.  Set a some final\n\t * registers that should be set earlier, but that the\n\t * controller ignores when in the SUSPEND state.\n\t */\n\tfm = (OREAD4(sc, OHCI_FM_INTERVAL) & OHCI_FIT) ^ OHCI_FIT;\n\tfm |= OHCI_FSMPS(ival) | ival;\n\tOWRITE4(sc, OHCI_FM_INTERVAL, fm);\n\tper = OHCI_PERIODIC(ival); /* 90% periodic */\n\tOWRITE4(sc, OHCI_PERIODIC_START, per);\n\n\t/* Fiddle the No OverCurrent Protection bit to avoid chip bug. */\n\tdesca = OREAD4(sc, OHCI_RH_DESCRIPTOR_A);\n\tOWRITE4(sc, OHCI_RH_DESCRIPTOR_A, desca | OHCI_NOCP);\n\tOWRITE4(sc, OHCI_RH_STATUS, OHCI_LPSC); /* Enable port power */\n\tusb_delay_ms(&sc->sc_bus, OHCI_ENABLE_POWER_DELAY);\n\tOWRITE4(sc, OHCI_RH_DESCRIPTOR_A, desca);\n\n\t/*\n\t * The AMD756 requires a delay before re-reading the register,\n\t * otherwise it will occasionally report 0 ports.\n\t */\n\tusb_delay_ms(&sc->sc_bus, OHCI_READ_DESC_DELAY);\n\tsc->sc_noport = OHCI_GET_NDP(OREAD4(sc, OHCI_RH_DESCRIPTOR_A));\n\n#ifdef OHCI_DEBUG\n\tif (ohcidebug > 5)\n\t\tohci_dumpregs(sc);\n#endif\n\t\n\t/* Set up the bus struct. */\n\tsc->sc_bus.methods = &ohci_bus_methods;\n\tsc->sc_bus.pipe_size = sizeof(struct ohci_pipe);\n\n#if defined(__NetBSD__) || defined(__OpenBSD__)\n\tsc->sc_powerhook = powerhook_establish(ohci_power, sc);\n\tsc->sc_shutdownhook = shutdownhook_establish(ohci_shutdown, sc);\n#endif\n\n\treturn (USBD_NORMAL_COMPLETION);\n\n bad5:\n\tfor (i = 0; i < OHCI_NO_EDS; i++)\n\t\tohci_free_sed(sc, sc->sc_eds[i]);\n bad4:\n\tohci_free_sed(sc, sc->sc_isoc_head);\n bad3:\n\tohci_free_sed(sc, sc->sc_ctrl_head);\n bad2:\n\tohci_free_sed(sc, sc->sc_bulk_head);\n bad1:\n\tusb_freemem(&sc->sc_bus, &sc->sc_hccadma);\n\treturn (err);\n}"
  },
  {
    "function_name": "ohci_free_sitd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "632-653",
    "snippet": "void\nohci_free_sitd(sc, sitd)\n\tohci_softc_t *sc;\n\tohci_soft_itd_t *sitd;\n{\n\tint s;\n\n\tDPRINTFN(10,(\"ohci_free_sitd: sitd=%p\\n\", sitd));\n\n#ifdef DIAGNOSTIC\n\tif (!sitd->isdone) {\n\t\tpanic(\"ohci_free_sitd: sitd=%p not done\\n\", sitd);\n\t\treturn;\n\t}\n#endif\n\n\ts = splusb();\n\tohci_hash_rem_itd(sc, sitd);\n\tsitd->nextitd = sc->sc_freeitds;\n\tsc->sc_freeitds = sitd;\n\tsplx(s);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static ohci_soft_itd_t",
      "ohci_free_sitd __P((ohci_softc_t *,ohci_soft_itd_t *));",
      "ohci_hash_add_itd __P((ohci_softc_t *, \n\t\t\t    ohci_soft_itd_t *));",
      "ohci_hash_rem_itd __P((ohci_softc_t *,\n\t\t\t    ohci_soft_itd_t *));",
      "Static ohci_soft_itd_t",
      "ohci_rhsc_able __P((ohci_softc_t *, int));",
      "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
      "ohci_intr1 __P((ohci_softc_t *));",
      "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ohci_hash_rem_itd",
          "args": [
            "sc",
            "sitd"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_hash_rem_itd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "1741-1752",
          "snippet": "void\nohci_hash_rem_itd(sc, sitd)\n\tohci_softc_t *sc;\n\tohci_soft_itd_t *sitd;\n{\n\tSPLUSBCHECK;\n\n\tDPRINTFN(10,(\"ohci_hash_rem_itd: sitd=%p physaddr=0x%08lx\\n\", \n\t\t    sitd, (u_long)sitd->physaddr));\n\n\tLIST_REMOVE(sitd, hnext);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static ohci_soft_itd_t",
            "ohci_free_sitd __P((ohci_softc_t *,ohci_soft_itd_t *));",
            "ohci_hash_add_itd __P((ohci_softc_t *, \n\t\t\t    ohci_soft_itd_t *));",
            "ohci_hash_rem_itd __P((ohci_softc_t *,\n\t\t\t    ohci_soft_itd_t *));",
            "Static ohci_soft_itd_t",
            "ohci_rhsc_able __P((ohci_softc_t *, int));",
            "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
            "ohci_intr1 __P((ohci_softc_t *));",
            "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_itd_t;\nohci_free_sitd __P((ohci_softc_t *,ohci_soft_itd_t *));\nohci_hash_add_itd __P((ohci_softc_t *, \n\t\t\t    ohci_soft_itd_t *));\nohci_hash_rem_itd __P((ohci_softc_t *,\n\t\t\t    ohci_soft_itd_t *));\nStatic ohci_soft_itd_t;\nohci_rhsc_able __P((ohci_softc_t *, int));\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nvoid\nohci_hash_rem_itd(sc, sitd)\n\tohci_softc_t *sc;\n\tohci_soft_itd_t *sitd;\n{\n\tSPLUSBCHECK;\n\n\tDPRINTFN(10,(\"ohci_hash_rem_itd: sitd=%p physaddr=0x%08lx\\n\", \n\t\t    sitd, (u_long)sitd->physaddr));\n\n\tLIST_REMOVE(sitd, hnext);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"ohci_free_sitd: sitd=%p not done\\n\"",
            "sitd"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "10",
            "(\"ohci_free_sitd: sitd=%p\\n\", sitd)"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_itd_t;\nohci_free_sitd __P((ohci_softc_t *,ohci_soft_itd_t *));\nohci_hash_add_itd __P((ohci_softc_t *, \n\t\t\t    ohci_soft_itd_t *));\nohci_hash_rem_itd __P((ohci_softc_t *,\n\t\t\t    ohci_soft_itd_t *));\nStatic ohci_soft_itd_t;\nohci_rhsc_able __P((ohci_softc_t *, int));\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nvoid\nohci_free_sitd(sc, sitd)\n\tohci_softc_t *sc;\n\tohci_soft_itd_t *sitd;\n{\n\tint s;\n\n\tDPRINTFN(10,(\"ohci_free_sitd: sitd=%p\\n\", sitd));\n\n#ifdef DIAGNOSTIC\n\tif (!sitd->isdone) {\n\t\tpanic(\"ohci_free_sitd: sitd=%p not done\\n\", sitd);\n\t\treturn;\n\t}\n#endif\n\n\ts = splusb();\n\tohci_hash_rem_itd(sc, sitd);\n\tsitd->nextitd = sc->sc_freeitds;\n\tsc->sc_freeitds = sitd;\n\tsplx(s);\n}"
  },
  {
    "function_name": "ohci_free_std_chain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "577-589",
    "snippet": "Static void\nohci_free_std_chain(sc, std, stdend)\n\tohci_softc_t *sc;\n\tohci_soft_td_t *std;\n\tohci_soft_td_t *stdend;\n{\n\tohci_soft_td_t *p;\n\n\tfor (; std != stdend; std = p) {\n\t\tp = std->nexttd;\n\t\tohci_free_std(sc, std);\n\t}\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static void",
      "Static ohci_soft_td_t",
      "Static void",
      "ohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));",
      "Static void",
      "ohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "ohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));",
      "Static void",
      "ohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));",
      "Static ohci_soft_td_t",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "ohci_rhsc_able __P((ohci_softc_t *, int));",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
      "Static int",
      "ohci_intr1 __P((ohci_softc_t *));",
      "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ohci_free_std",
          "args": [
            "sc",
            "std"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_free_std_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "577-589",
          "snippet": "Static void\nohci_free_std_chain(sc, std, stdend)\n\tohci_softc_t *sc;\n\tohci_soft_td_t *std;\n\tohci_soft_td_t *stdend;\n{\n\tohci_soft_td_t *p;\n\n\tfor (; std != stdend; std = p) {\n\t\tp = std->nexttd;\n\t\tohci_free_std(sc, std);\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nStatic ohci_soft_td_t;\nStatic void;\nohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));\nStatic void;\nohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));\nStatic void;\nohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));\nStatic ohci_soft_td_t;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nohci_rhsc_able __P((ohci_softc_t *, int));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nStatic int;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nStatic void\nohci_free_std_chain(sc, std, stdend)\n\tohci_softc_t *sc;\n\tohci_soft_td_t *std;\n\tohci_soft_td_t *stdend;\n{\n\tohci_soft_td_t *p;\n\n\tfor (; std != stdend; std = p) {\n\t\tp = std->nexttd;\n\t\tohci_free_std(sc, std);\n\t}\n}"
  },
  {
    "function_name": "ohci_alloc_std_chain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "479-574",
    "snippet": "usbd_status\nohci_alloc_std_chain(opipe, sc, alen, rd, xfer, sp, ep)\n\tstruct ohci_pipe *opipe;\n\tohci_softc_t *sc;\n\tint alen, rd;\n\tusbd_xfer_handle xfer;\n\tohci_soft_td_t *sp, **ep;\n{\n\tohci_soft_td_t *next, *cur;\n\tohci_physaddr_t dataphys, dataphysend;\n\tu_int32_t tdflags;\n\tint len, curlen;\n\tusb_dma_t *dma = &xfer->dmabuf;\n\tu_int16_t flags = xfer->flags;\n\n\tDPRINTFN(alen < 4096,(\"ohci_alloc_std_chain: start len=%d\\n\", alen));\n\n\tlen = alen;\n\tcur = sp;\n\tdataphys = DMAADDR(dma);\n\tdataphysend = OHCI_PAGE(dataphys + len - 1);\n\ttdflags = htole32(\n\t    (rd ? OHCI_TD_IN : OHCI_TD_OUT) | \n\t    (flags & USBD_SHORT_XFER_OK ? OHCI_TD_R : 0) |\n\t    OHCI_TD_NOCC | OHCI_TD_TOGGLE_CARRY | OHCI_TD_NOINTR);\n\n\tfor (;;) {\n\t\tnext = ohci_alloc_std(sc);\n\t\tif (next == NULL)\n\t\t\tgoto nomem;\n\n\t\t/* The OHCI hardware can handle at most one page crossing. */\n\t\tif (OHCI_PAGE(dataphys) == dataphysend ||\n\t\t    OHCI_PAGE(dataphys) + OHCI_PAGE_SIZE == dataphysend) {\n\t\t\t/* we can handle it in this TD */\n\t\t\tcurlen = len;\n\t\t} else {\n\t\t\t/* must use multiple TDs, fill as much as possible. */\n\t\t\tcurlen = 2 * OHCI_PAGE_SIZE - \n\t\t\t\t (dataphys & (OHCI_PAGE_SIZE-1));\n\t\t\t/* the length must be a multiple of the max size */\n\t\t\tcurlen -= curlen % UGETW(opipe->pipe.endpoint->edesc->wMaxPacketSize);\n#ifdef DIAGNOSTIC\n\t\t\tif (curlen == 0)\n\t\t\t\tpanic(\"ohci_alloc_std: curlen == 0\\n\");\n#endif\n\t\t}\n\t\tDPRINTFN(4,(\"ohci_alloc_std_chain: dataphys=0x%08x \"\n\t\t\t    \"dataphysend=0x%08x len=%d curlen=%d\\n\",\n\t\t\t    dataphys, dataphysend,\n\t\t\t    len, curlen));\n\t\tlen -= curlen;\n\n\t\tcur->td.td_flags = tdflags;\n\t\tcur->td.td_cbp = htole32(dataphys);\n\t\tcur->nexttd = next;\n\t\tcur->td.td_nexttd = htole32(next->physaddr);\n\t\tcur->td.td_be = htole32(dataphys + curlen - 1);\n\t\tcur->len = curlen;\n\t\tcur->flags = OHCI_ADD_LEN;\n\t\tcur->xfer = xfer;\n\t\tDPRINTFN(10,(\"ohci_alloc_std_chain: cbp=0x%08x be=0x%08x\\n\",\n\t\t\t    dataphys, dataphys + curlen - 1));\n\t\tif (len == 0)\n\t\t\tbreak;\n\t\tDPRINTFN(10,(\"ohci_alloc_std_chain: extend chain\\n\"));\n\t\tdataphys += curlen;\n\t\tcur = next;\n\t}\n\tif ((flags & USBD_FORCE_SHORT_XFER) &&\n\t    alen % UGETW(opipe->pipe.endpoint->edesc->wMaxPacketSize) == 0) {\n\t\t/* Force a 0 length transfer at the end. */\n\n\t\tcur = next;\n\t\tnext = ohci_alloc_std(sc);\n\t\tif (next == NULL)\n\t\t\tgoto nomem;\n\n\t\tcur->td.td_flags = tdflags;\n\t\tcur->td.td_cbp = 0; /* indicate 0 length packet */\n\t\tcur->nexttd = next;\n\t\tcur->td.td_nexttd = htole32(next->physaddr);\n\t\tcur->td.td_be = ~0;\n\t\tcur->len = 0;\n\t\tcur->flags = 0;\n\t\tcur->xfer = xfer;\n\t\tDPRINTFN(2,(\"ohci_alloc_std_chain: add 0 xfer\\n\"));\n\t}\n\t*ep = cur;\n\n\treturn (USBD_NORMAL_COMPLETION);\n\n nomem:\n\t/* XXX free chain */\n\treturn (USBD_NOMEM);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static ohci_soft_td_t",
      "ohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));",
      "Static usbd_status",
      "ohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));",
      "Static usbd_status",
      "ohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));",
      "ohci_add_done __P((ohci_softc_t *, ohci_physaddr_t));",
      "ohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_request __P((usbd_xfer_handle xfer));",
      "ohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));",
      "ohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));",
      "Static ohci_soft_td_t",
      "Static usbd_status",
      "ohci_setup_isoc __P((usbd_pipe_handle pipe));",
      "ohci_device_isoc_enter __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));",
      "ohci_freem __P((struct usbd_bus *, usb_dma_t *));",
      "Static usbd_xfer_handle",
      "ohci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_root_ctrl_start __P((usbd_xfer_handle));",
      "ohci_root_ctrl_abort __P((usbd_xfer_handle));",
      "ohci_root_ctrl_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_root_intr_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_root_intr_start __P((usbd_xfer_handle));",
      "ohci_root_intr_abort __P((usbd_xfer_handle));",
      "ohci_root_intr_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_ctrl_start __P((usbd_xfer_handle));",
      "ohci_device_ctrl_abort __P((usbd_xfer_handle));",
      "ohci_device_ctrl_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_bulk_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_bulk_start __P((usbd_xfer_handle));",
      "ohci_device_bulk_abort __P((usbd_xfer_handle));",
      "ohci_device_bulk_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_intr_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_intr_start __P((usbd_xfer_handle));",
      "ohci_device_intr_abort __P((usbd_xfer_handle));",
      "ohci_device_intr_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_isoc_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_device_isoc_start __P((usbd_xfer_handle));",
      "ohci_device_isoc_abort __P((usbd_xfer_handle));",
      "ohci_device_isoc_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "ohci_rhsc_able __P((ohci_softc_t *, int));",
      "ohci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "ohci_noop __P((usbd_pipe_handle pipe));",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
      "ohci_intr1 __P((ohci_softc_t *));",
      "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
      "ohci_physaddr_t a;",
      "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;",
      "ohci_physaddr_t a;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "2",
            "(\"ohci_alloc_std_chain: add 0 xfer\\n\")"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "next->physaddr"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ohci_alloc_std",
          "args": [
            "sc"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_alloc_std_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "479-574",
          "snippet": "usbd_status\nohci_alloc_std_chain(opipe, sc, alen, rd, xfer, sp, ep)\n\tstruct ohci_pipe *opipe;\n\tohci_softc_t *sc;\n\tint alen, rd;\n\tusbd_xfer_handle xfer;\n\tohci_soft_td_t *sp, **ep;\n{\n\tohci_soft_td_t *next, *cur;\n\tohci_physaddr_t dataphys, dataphysend;\n\tu_int32_t tdflags;\n\tint len, curlen;\n\tusb_dma_t *dma = &xfer->dmabuf;\n\tu_int16_t flags = xfer->flags;\n\n\tDPRINTFN(alen < 4096,(\"ohci_alloc_std_chain: start len=%d\\n\", alen));\n\n\tlen = alen;\n\tcur = sp;\n\tdataphys = DMAADDR(dma);\n\tdataphysend = OHCI_PAGE(dataphys + len - 1);\n\ttdflags = htole32(\n\t    (rd ? OHCI_TD_IN : OHCI_TD_OUT) | \n\t    (flags & USBD_SHORT_XFER_OK ? OHCI_TD_R : 0) |\n\t    OHCI_TD_NOCC | OHCI_TD_TOGGLE_CARRY | OHCI_TD_NOINTR);\n\n\tfor (;;) {\n\t\tnext = ohci_alloc_std(sc);\n\t\tif (next == NULL)\n\t\t\tgoto nomem;\n\n\t\t/* The OHCI hardware can handle at most one page crossing. */\n\t\tif (OHCI_PAGE(dataphys) == dataphysend ||\n\t\t    OHCI_PAGE(dataphys) + OHCI_PAGE_SIZE == dataphysend) {\n\t\t\t/* we can handle it in this TD */\n\t\t\tcurlen = len;\n\t\t} else {\n\t\t\t/* must use multiple TDs, fill as much as possible. */\n\t\t\tcurlen = 2 * OHCI_PAGE_SIZE - \n\t\t\t\t (dataphys & (OHCI_PAGE_SIZE-1));\n\t\t\t/* the length must be a multiple of the max size */\n\t\t\tcurlen -= curlen % UGETW(opipe->pipe.endpoint->edesc->wMaxPacketSize);\n#ifdef DIAGNOSTIC\n\t\t\tif (curlen == 0)\n\t\t\t\tpanic(\"ohci_alloc_std: curlen == 0\\n\");\n#endif\n\t\t}\n\t\tDPRINTFN(4,(\"ohci_alloc_std_chain: dataphys=0x%08x \"\n\t\t\t    \"dataphysend=0x%08x len=%d curlen=%d\\n\",\n\t\t\t    dataphys, dataphysend,\n\t\t\t    len, curlen));\n\t\tlen -= curlen;\n\n\t\tcur->td.td_flags = tdflags;\n\t\tcur->td.td_cbp = htole32(dataphys);\n\t\tcur->nexttd = next;\n\t\tcur->td.td_nexttd = htole32(next->physaddr);\n\t\tcur->td.td_be = htole32(dataphys + curlen - 1);\n\t\tcur->len = curlen;\n\t\tcur->flags = OHCI_ADD_LEN;\n\t\tcur->xfer = xfer;\n\t\tDPRINTFN(10,(\"ohci_alloc_std_chain: cbp=0x%08x be=0x%08x\\n\",\n\t\t\t    dataphys, dataphys + curlen - 1));\n\t\tif (len == 0)\n\t\t\tbreak;\n\t\tDPRINTFN(10,(\"ohci_alloc_std_chain: extend chain\\n\"));\n\t\tdataphys += curlen;\n\t\tcur = next;\n\t}\n\tif ((flags & USBD_FORCE_SHORT_XFER) &&\n\t    alen % UGETW(opipe->pipe.endpoint->edesc->wMaxPacketSize) == 0) {\n\t\t/* Force a 0 length transfer at the end. */\n\n\t\tcur = next;\n\t\tnext = ohci_alloc_std(sc);\n\t\tif (next == NULL)\n\t\t\tgoto nomem;\n\n\t\tcur->td.td_flags = tdflags;\n\t\tcur->td.td_cbp = 0; /* indicate 0 length packet */\n\t\tcur->nexttd = next;\n\t\tcur->td.td_nexttd = htole32(next->physaddr);\n\t\tcur->td.td_be = ~0;\n\t\tcur->len = 0;\n\t\tcur->flags = 0;\n\t\tcur->xfer = xfer;\n\t\tDPRINTFN(2,(\"ohci_alloc_std_chain: add 0 xfer\\n\"));\n\t}\n\t*ep = cur;\n\n\treturn (USBD_NORMAL_COMPLETION);\n\n nomem:\n\t/* XXX free chain */\n\treturn (USBD_NOMEM);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "opipe->pipe.endpoint->edesc->wMaxPacketSize"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "10",
            "(\"ohci_alloc_std_chain: extend chain\\n\")"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "10",
            "(\"ohci_alloc_std_chain: cbp=0x%08x be=0x%08x\\n\",\n\t\t\t    dataphys, dataphys + curlen - 1)"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "dataphys + curlen - 1"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "next->physaddr"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "dataphys"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "4",
            "(\"ohci_alloc_std_chain: dataphys=0x%08x \"\n\t\t\t    \"dataphysend=0x%08x len=%d curlen=%d\\n\",\n\t\t\t    dataphys, dataphysend,\n\t\t\t    len, curlen)"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"ohci_alloc_std: curlen == 0\\n\""
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "opipe->pipe.endpoint->edesc->wMaxPacketSize"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OHCI_PAGE",
          "args": [
            "dataphys"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OHCI_PAGE",
          "args": [
            "dataphys"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "(rd ? OHCI_TD_IN : OHCI_TD_OUT) | \n\t    (flags & USBD_SHORT_XFER_OK ? OHCI_TD_R : 0) |\n\t    OHCI_TD_NOCC | OHCI_TD_TOGGLE_CARRY | OHCI_TD_NOINTR"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OHCI_PAGE",
          "args": [
            "dataphys + len - 1"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DMAADDR",
          "args": [
            "dma"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "alen < 4096",
            "(\"ohci_alloc_std_chain: start len=%d\\n\", alen)"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_td_t;\nohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));\nStatic usbd_status;\nohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));\nStatic usbd_status;\nohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));\nohci_add_done __P((ohci_softc_t *, ohci_physaddr_t));\nohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));\nStatic usbd_status;\nohci_device_request __P((usbd_xfer_handle xfer));\nohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));\nohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));\nStatic ohci_soft_td_t;\nStatic usbd_status;\nohci_setup_isoc __P((usbd_pipe_handle pipe));\nohci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));\nohci_freem __P((struct usbd_bus *, usb_dma_t *));\nStatic usbd_xfer_handle;\nohci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nStatic usbd_status;\nohci_root_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_ctrl_start __P((usbd_xfer_handle));\nohci_root_ctrl_abort __P((usbd_xfer_handle));\nohci_root_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_root_intr_start __P((usbd_xfer_handle));\nohci_root_intr_abort __P((usbd_xfer_handle));\nohci_root_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_ctrl_start __P((usbd_xfer_handle));\nohci_device_ctrl_abort __P((usbd_xfer_handle));\nohci_device_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_bulk_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_bulk_start __P((usbd_xfer_handle));\nohci_device_bulk_abort __P((usbd_xfer_handle));\nohci_device_bulk_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_intr_start __P((usbd_xfer_handle));\nohci_device_intr_abort __P((usbd_xfer_handle));\nohci_device_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_isoc_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_device_isoc_start __P((usbd_xfer_handle));\nohci_device_isoc_abort __P((usbd_xfer_handle));\nohci_device_isoc_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nohci_rhsc_able __P((ohci_softc_t *, int));\nohci_device_clear_toggle __P((usbd_pipe_handle pipe));\nohci_noop __P((usbd_pipe_handle pipe));\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_physaddr_t a;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\nohci_physaddr_t a;\n\nusbd_status\nohci_alloc_std_chain(opipe, sc, alen, rd, xfer, sp, ep)\n\tstruct ohci_pipe *opipe;\n\tohci_softc_t *sc;\n\tint alen, rd;\n\tusbd_xfer_handle xfer;\n\tohci_soft_td_t *sp, **ep;\n{\n\tohci_soft_td_t *next, *cur;\n\tohci_physaddr_t dataphys, dataphysend;\n\tu_int32_t tdflags;\n\tint len, curlen;\n\tusb_dma_t *dma = &xfer->dmabuf;\n\tu_int16_t flags = xfer->flags;\n\n\tDPRINTFN(alen < 4096,(\"ohci_alloc_std_chain: start len=%d\\n\", alen));\n\n\tlen = alen;\n\tcur = sp;\n\tdataphys = DMAADDR(dma);\n\tdataphysend = OHCI_PAGE(dataphys + len - 1);\n\ttdflags = htole32(\n\t    (rd ? OHCI_TD_IN : OHCI_TD_OUT) | \n\t    (flags & USBD_SHORT_XFER_OK ? OHCI_TD_R : 0) |\n\t    OHCI_TD_NOCC | OHCI_TD_TOGGLE_CARRY | OHCI_TD_NOINTR);\n\n\tfor (;;) {\n\t\tnext = ohci_alloc_std(sc);\n\t\tif (next == NULL)\n\t\t\tgoto nomem;\n\n\t\t/* The OHCI hardware can handle at most one page crossing. */\n\t\tif (OHCI_PAGE(dataphys) == dataphysend ||\n\t\t    OHCI_PAGE(dataphys) + OHCI_PAGE_SIZE == dataphysend) {\n\t\t\t/* we can handle it in this TD */\n\t\t\tcurlen = len;\n\t\t} else {\n\t\t\t/* must use multiple TDs, fill as much as possible. */\n\t\t\tcurlen = 2 * OHCI_PAGE_SIZE - \n\t\t\t\t (dataphys & (OHCI_PAGE_SIZE-1));\n\t\t\t/* the length must be a multiple of the max size */\n\t\t\tcurlen -= curlen % UGETW(opipe->pipe.endpoint->edesc->wMaxPacketSize);\n#ifdef DIAGNOSTIC\n\t\t\tif (curlen == 0)\n\t\t\t\tpanic(\"ohci_alloc_std: curlen == 0\\n\");\n#endif\n\t\t}\n\t\tDPRINTFN(4,(\"ohci_alloc_std_chain: dataphys=0x%08x \"\n\t\t\t    \"dataphysend=0x%08x len=%d curlen=%d\\n\",\n\t\t\t    dataphys, dataphysend,\n\t\t\t    len, curlen));\n\t\tlen -= curlen;\n\n\t\tcur->td.td_flags = tdflags;\n\t\tcur->td.td_cbp = htole32(dataphys);\n\t\tcur->nexttd = next;\n\t\tcur->td.td_nexttd = htole32(next->physaddr);\n\t\tcur->td.td_be = htole32(dataphys + curlen - 1);\n\t\tcur->len = curlen;\n\t\tcur->flags = OHCI_ADD_LEN;\n\t\tcur->xfer = xfer;\n\t\tDPRINTFN(10,(\"ohci_alloc_std_chain: cbp=0x%08x be=0x%08x\\n\",\n\t\t\t    dataphys, dataphys + curlen - 1));\n\t\tif (len == 0)\n\t\t\tbreak;\n\t\tDPRINTFN(10,(\"ohci_alloc_std_chain: extend chain\\n\"));\n\t\tdataphys += curlen;\n\t\tcur = next;\n\t}\n\tif ((flags & USBD_FORCE_SHORT_XFER) &&\n\t    alen % UGETW(opipe->pipe.endpoint->edesc->wMaxPacketSize) == 0) {\n\t\t/* Force a 0 length transfer at the end. */\n\n\t\tcur = next;\n\t\tnext = ohci_alloc_std(sc);\n\t\tif (next == NULL)\n\t\t\tgoto nomem;\n\n\t\tcur->td.td_flags = tdflags;\n\t\tcur->td.td_cbp = 0; /* indicate 0 length packet */\n\t\tcur->nexttd = next;\n\t\tcur->td.td_nexttd = htole32(next->physaddr);\n\t\tcur->td.td_be = ~0;\n\t\tcur->len = 0;\n\t\tcur->flags = 0;\n\t\tcur->xfer = xfer;\n\t\tDPRINTFN(2,(\"ohci_alloc_std_chain: add 0 xfer\\n\"));\n\t}\n\t*ep = cur;\n\n\treturn (USBD_NORMAL_COMPLETION);\n\n nomem:\n\t/* XXX free chain */\n\treturn (USBD_NOMEM);\n}"
  },
  {
    "function_name": "ohci_free_std",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "465-477",
    "snippet": "void\nohci_free_std(sc, std)\n\tohci_softc_t *sc;\n\tohci_soft_td_t *std;\n{\n\tint s;\n\n\ts = splusb();\n\tohci_hash_rem_td(sc, std);\n\tstd->nexttd = sc->sc_freetds;\n\tsc->sc_freetds = std;\n\tsplx(s);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static ohci_soft_td_t",
      "ohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));",
      "ohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));",
      "ohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));",
      "ohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));",
      "Static ohci_soft_td_t",
      "ohci_rhsc_able __P((ohci_softc_t *, int));",
      "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
      "ohci_intr1 __P((ohci_softc_t *));",
      "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ohci_hash_rem_td",
          "args": [
            "sc",
            "std"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "ohci_hash_rem_td",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
          "lines": "1698-1706",
          "snippet": "void\nohci_hash_rem_td(sc, std)\n\tohci_softc_t *sc;\n\tohci_soft_td_t *std;\n{\n\tSPLUSBCHECK;\n\n\tLIST_REMOVE(std, hnext);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/ohcivar.h>",
            "#include <dev/usb/ohcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_memio.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static ohci_soft_td_t",
            "ohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));",
            "ohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));",
            "ohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));",
            "ohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));",
            "Static ohci_soft_td_t",
            "ohci_rhsc_able __P((ohci_softc_t *, int));",
            "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
            "ohci_intr1 __P((ohci_softc_t *));",
            "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
            "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_td_t;\nohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));\nohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));\nohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));\nohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));\nStatic ohci_soft_td_t;\nohci_rhsc_able __P((ohci_softc_t *, int));\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nvoid\nohci_hash_rem_td(sc, std)\n\tohci_softc_t *sc;\n\tohci_soft_td_t *std;\n{\n\tSPLUSBCHECK;\n\n\tLIST_REMOVE(std, hnext);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_td_t;\nohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));\nohci_alloc_std_chain __P((struct ohci_pipe *,\n\t\t\t    ohci_softc_t *, int, int, usbd_xfer_handle,\n\t\t\t    ohci_soft_td_t *, ohci_soft_td_t **));\nohci_hash_add_td __P((ohci_softc_t *, \n\t\t\t    ohci_soft_td_t *));\nohci_hash_rem_td __P((ohci_softc_t *,\n\t\t\t    ohci_soft_td_t *));\nStatic ohci_soft_td_t;\nohci_rhsc_able __P((ohci_softc_t *, int));\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nvoid\nohci_free_std(sc, std)\n\tohci_softc_t *sc;\n\tohci_soft_td_t *std;\n{\n\tint s;\n\n\ts = splusb();\n\tohci_hash_rem_td(sc, std);\n\tstd->nexttd = sc->sc_freetds;\n\tsc->sc_freetds = std;\n\tsplx(s);\n}"
  },
  {
    "function_name": "ohci_free_sed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "417-424",
    "snippet": "void\nohci_free_sed(sc, sed)\n\tohci_softc_t *sc;\n\tohci_soft_ed_t *sed;\n{\n\tsed->next = sc->sc_freeeds;\n\tsc->sc_freeeds = sed;\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static ohci_soft_ed_t",
      "ohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));",
      "ohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
      "ohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));",
      "ohci_rhsc_able __P((ohci_softc_t *, int));",
      "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
      "ohci_intr1 __P((ohci_softc_t *));",
      "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic ohci_soft_ed_t;\nohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));\nohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));\nohci_rhsc_able __P((ohci_softc_t *, int));\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_intr1 __P((ohci_softc_t *));\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nvoid\nohci_free_sed(sc, sed)\n\tohci_softc_t *sc;\n\tohci_soft_ed_t *sed;\n{\n\tsed->next = sc->sc_freeeds;\n\tsc->sc_freeeds = sed;\n}"
  },
  {
    "function_name": "ohci_detach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "363-384",
    "snippet": "int\nohci_detach(sc, flags)\n\tstruct ohci_softc *sc;\n\tint flags;\n{\n\tint rv = 0;\n\n\tif (sc->sc_child != NULL)\n\t\trv = config_detach(sc->sc_child, flags);\n\t\n\tif (rv != 0)\n\t\treturn (rv);\n\n#if defined(__NetBSD__) || defined(__OpenBSD__)\n\tpowerhook_disestablish(sc->sc_powerhook);\n\tshutdownhook_disestablish(sc->sc_shutdownhook);\n#endif\n\n\t/* free data structures XXX */\n\n\treturn (rv);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "shutdownhook_disestablish",
          "args": [
            "sc->sc_shutdownhook"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "powerhook_disestablish",
          "args": [
            "sc->sc_powerhook"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "config_detach",
          "args": [
            "sc->sc_child",
            "flags"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nint\nohci_detach(sc, flags)\n\tstruct ohci_softc *sc;\n\tint flags;\n{\n\tint rv = 0;\n\n\tif (sc->sc_child != NULL)\n\t\trv = config_detach(sc->sc_child, flags);\n\t\n\tif (rv != 0)\n\t\treturn (rv);\n\n#if defined(__NetBSD__) || defined(__OpenBSD__)\n\tpowerhook_disestablish(sc->sc_powerhook);\n\tshutdownhook_disestablish(sc->sc_shutdownhook);\n#endif\n\n\t/* free data structures XXX */\n\n\treturn (rv);\n}"
  },
  {
    "function_name": "ohci_activate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ohci.c",
    "lines": "341-361",
    "snippet": "int\nohci_activate(self, act)\n\tdevice_ptr_t self;\n\tenum devact act;\n{\n\tstruct ohci_softc *sc = (struct ohci_softc *)self;\n\tint rv = 0;\n\n\tswitch (act) {\n\tcase DVACT_ACTIVATE:\n\t\treturn (EOPNOTSUPP);\n\t\tbreak;\n\n\tcase DVACT_DEACTIVATE:\n\t\tif (sc->sc_child != NULL)\n\t\t\trv = config_deactivate(sc->sc_child);\n\t\tsc->sc_dying = 1;\n\t\tbreak;\n\t}\n\treturn (rv);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/ohcivar.h>",
      "#include <dev/usb/ohcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_memio.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "Static struct",
      "ohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;",
      "ohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;",
      "ohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "config_deactivate",
          "args": [
            "sc->sc_child"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/ohcivar.h>\n#include <dev/usb/ohcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_memio.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nStatic struct;\nohci_soft_ed_t *\nohci_alloc_sed(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_alloc_std(sc)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_alloc_sitd(sc)\n\tohci_softc_t *sc;\nohci_soft_td_t *\nohci_hash_find_td(sc, a)\n\tohci_softc_t *sc;\nohci_soft_itd_t *\nohci_hash_find_itd(sc, a)\n\tohci_softc_t *sc;\n\nint\nohci_activate(self, act)\n\tdevice_ptr_t self;\n\tenum devact act;\n{\n\tstruct ohci_softc *sc = (struct ohci_softc *)self;\n\tint rv = 0;\n\n\tswitch (act) {\n\tcase DVACT_ACTIVATE:\n\t\treturn (EOPNOTSUPP);\n\t\tbreak;\n\n\tcase DVACT_DEACTIVATE:\n\t\tif (sc->sc_child != NULL)\n\t\t\trv = config_deactivate(sc->sc_child);\n\t\tsc->sc_dying = 1;\n\t\tbreak;\n\t}\n\treturn (rv);\n}"
  }
]