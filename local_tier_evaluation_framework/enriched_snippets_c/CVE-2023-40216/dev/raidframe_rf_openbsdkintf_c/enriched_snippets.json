[
  {
    "function_name": "rf_ReconstructInPlaceThread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_openbsdkintf.c",
    "lines": "2321-2339",
    "snippet": "void\nrf_ReconstructInPlaceThread(req)\n\tstruct rf_recon_req *req;\n{\n\tint retcode;\n\tint s;\n\tRF_Raid_t *raidPtr;\n\t\n\ts = splbio();\n\traidPtr = req->raidPtr;\n\traidPtr->recon_in_progress = 1;\n\tretcode = rf_ReconstructInPlace(raidPtr, req->row, req->col);\n\tRF_Free(req, sizeof(*req));\n\traidPtr->recon_in_progress = 0;\n\tsplx(s);\n\n\t/* That's all... */\n\tkthread_exit(0);        /* does not return */\n}",
    "includes": [
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_kintf.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_dagflags.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_copyback.h\"",
      "#include \"rf_raidframe.h\"",
      "#include \"rf_raid.h\"",
      "#include \"raid.h\"",
      "#include <sys/user.h>",
      "#include <sys/buf.h>",
      "#include <sys/lock.h>",
      "#include <sys/conf.h>",
      "#include <sys/namei.h>",
      "#include <sys/systm.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/device.h>",
      "#include <sys/disk.h>",
      "#include <sys/queue.h>",
      "#include <sys/malloc.h>",
      "#include <sys/param.h>",
      "#include <sys/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void rf_ReconstructInPlaceThread"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kthread_exit",
          "args": [
            "0"
          ],
          "line": 2338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 2335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "req",
            "sizeof(*req)"
          ],
          "line": 2333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_ReconstructInPlace",
          "args": [
            "raidPtr",
            "req->row",
            "req->col"
          ],
          "line": 2332
        },
        "resolved": true,
        "details": {
          "function_name": "rf_ReconstructInPlaceThread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_openbsdkintf.c",
          "lines": "2321-2339",
          "snippet": "void\nrf_ReconstructInPlaceThread(req)\n\tstruct rf_recon_req *req;\n{\n\tint retcode;\n\tint s;\n\tRF_Raid_t *raidPtr;\n\t\n\ts = splbio();\n\traidPtr = req->raidPtr;\n\traidPtr->recon_in_progress = 1;\n\tretcode = rf_ReconstructInPlace(raidPtr, req->row, req->col);\n\tRF_Free(req, sizeof(*req));\n\traidPtr->recon_in_progress = 0;\n\tsplx(s);\n\n\t/* That's all... */\n\tkthread_exit(0);        /* does not return */\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 2329
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\nvoid rf_ReconstructInPlaceThread;\n\nvoid\nrf_ReconstructInPlaceThread(req)\n\tstruct rf_recon_req *req;\n{\n\tint retcode;\n\tint s;\n\tRF_Raid_t *raidPtr;\n\t\n\ts = splbio();\n\traidPtr = req->raidPtr;\n\traidPtr->recon_in_progress = 1;\n\tretcode = rf_ReconstructInPlace(raidPtr, req->row, req->col);\n\tRF_Free(req, sizeof(*req));\n\traidPtr->recon_in_progress = 0;\n\tsplx(s);\n\n\t/* That's all... */\n\tkthread_exit(0);        /* does not return */\n}"
  },
  {
    "function_name": "rf_CopybackThread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_openbsdkintf.c",
    "lines": "2304-2318",
    "snippet": "void\nrf_CopybackThread(raidPtr)\n\tRF_Raid_t *raidPtr;\n{\n\tint s;\n\n\traidPtr->copyback_in_progress = 1;\n\ts = splbio();\n\trf_CopybackReconstructedData(raidPtr);\n\tsplx(s);\n\traidPtr->copyback_in_progress = 0;\n\n\t/* That's all... */\n\tkthread_exit(0);        /* does not return */\n}",
    "includes": [
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_kintf.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_dagflags.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_copyback.h\"",
      "#include \"rf_raidframe.h\"",
      "#include \"rf_raid.h\"",
      "#include \"raid.h\"",
      "#include <sys/user.h>",
      "#include <sys/buf.h>",
      "#include <sys/lock.h>",
      "#include <sys/conf.h>",
      "#include <sys/namei.h>",
      "#include <sys/systm.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/device.h>",
      "#include <sys/disk.h>",
      "#include <sys/queue.h>",
      "#include <sys/malloc.h>",
      "#include <sys/param.h>",
      "#include <sys/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void rf_CopybackThread"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kthread_exit",
          "args": [
            "0"
          ],
          "line": 2317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 2313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_CopybackReconstructedData",
          "args": [
            "raidPtr"
          ],
          "line": 2312
        },
        "resolved": true,
        "details": {
          "function_name": "rf_CopybackReconstructedData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_copyback.c",
          "lines": "88-251",
          "snippet": "void \nrf_CopybackReconstructedData(raidPtr)\n\tRF_Raid_t *raidPtr;\n{\n\tRF_ComponentLabel_t c_label;\n\tint     done, retcode;\n\tRF_CopybackDesc_t *desc;\n\tRF_RowCol_t frow, fcol;\n\tRF_RaidDisk_t *badDisk;\n\tchar   *databuf;\n\n\tstruct partinfo dpart;\n\tstruct vnode *vp;\n\tstruct vattr va;\n\tstruct proc *proc;\n\n\tdone = 0;\n\tfcol = 0;\n\tfor (frow = 0; frow < raidPtr->numRow; frow++) {\n\t\tfor (fcol = 0; fcol < raidPtr->numCol; fcol++) {\n\t\t\tif (raidPtr->Disks[frow][fcol].status == rf_ds_dist_spared\n\t\t\t    || raidPtr->Disks[frow][fcol].status == rf_ds_spared) {\n\t\t\t\tdone = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (done)\n\t\t\tbreak;\n\t}\n\n\tif (frow == raidPtr->numRow) {\n\t\tprintf(\"COPYBACK:  no disks need copyback\\n\");\n\t\treturn;\n\t}\n\tbadDisk = &raidPtr->Disks[frow][fcol];\n\n\tproc = raidPtr->engine_thread;\n\n\t/* This device may have been opened successfully the first time. Close\n\t * it before trying to open it again.. */\n\n\tif (raidPtr->raid_cinfo[frow][fcol].ci_vp != NULL) {\n\t\tprintf(\"Closed the open device: %s\\n\",\n\t\t    raidPtr->Disks[frow][fcol].devname);\n\t\tVOP_UNLOCK(raidPtr->raid_cinfo[frow][fcol].ci_vp, 0, proc);\n\t\t(void) vn_close(raidPtr->raid_cinfo[frow][fcol].ci_vp,\n\t\t    FREAD | FWRITE, proc->p_ucred, proc);\n\t\traidPtr->raid_cinfo[frow][fcol].ci_vp = NULL;\n\t}\n\tprintf(\"About to (re-)open the device: %s\\n\",\n\t    raidPtr->Disks[frow][fcol].devname);\n\n\tretcode = raidlookup(raidPtr->Disks[frow][fcol].devname, proc, &vp);\n\n\tif (retcode) {\n\t\tprintf(\"COPYBACK: raidlookup on device: %s failed: %d!\\n\",\n\t\t    raidPtr->Disks[frow][fcol].devname, retcode);\n\n\t\t/* XXX the component isn't responding properly... must be\n\t\t * still dead :-( */\n\t\treturn;\n\n\t} else {\n\n\t\t/* Ok, so we can at least do a lookup... How about actually\n\t\t * getting a vp for it? */\n\n\t\tif ((retcode = VOP_GETATTR(vp, &va, proc->p_ucred, proc)) != 0) {\n\t\t\treturn;\n\t\t}\n\t\tretcode = VOP_IOCTL(vp, DIOCGPART, (caddr_t) & dpart,\n\t\t    FREAD, proc->p_ucred, proc);\n\t\tif (retcode) {\n\t\t\treturn;\n\t\t}\n\t\traidPtr->Disks[frow][fcol].blockSize = dpart.disklab->d_secsize;\n\n\t\traidPtr->Disks[frow][fcol].numBlocks = dpart.part->p_size -\n\t\t    rf_protectedSectors;\n\n\t\traidPtr->raid_cinfo[frow][fcol].ci_vp = vp;\n\t\traidPtr->raid_cinfo[frow][fcol].ci_dev = va.va_rdev;\n\n\t\traidPtr->Disks[frow][fcol].dev = va.va_rdev;\t/* XXX or the above? */\n\n\t\t/* we allow the user to specify that only a fraction of the\n\t\t * disks should be used this is just for debug:  it speeds up\n\t\t * the parity scan */\n\t\traidPtr->Disks[frow][fcol].numBlocks =\n\t\t    raidPtr->Disks[frow][fcol].numBlocks *\n\t\t    rf_sizePercentage / 100;\n\t}\n#if 0\n\t/* This is the way it was done before the CAM stuff was removed */\n\n\tif (rf_extract_ids(badDisk->devname, &bus, &targ, &lun)) {\n\t\tprintf(\"COPYBACK: unable to extract bus, target, lun from devname %s\\n\",\n\t\t    badDisk->devname);\n\t\treturn;\n\t}\n\t/* TUR the disk that's marked as bad to be sure that it's actually\n\t * alive */\n\trf_SCSI_AllocTUR(&tur_op);\n\tretcode = rf_SCSI_DoTUR(tur_op, bus, targ, lun, badDisk->dev);\n\trf_SCSI_FreeDiskOp(tur_op, 0);\n#endif\n\n\tif (retcode) {\n\t\tprintf(\"COPYBACK: target disk failed TUR\\n\");\n\t\treturn;\n\t}\n\t/* get a buffer to hold one SU  */\n\tRF_Malloc(databuf, rf_RaidAddressToByte(raidPtr, raidPtr->Layout.sectorsPerStripeUnit), (char *));\n\n\t/* create a descriptor */\n\tRF_Malloc(desc, sizeof(*desc), (RF_CopybackDesc_t *));\n\tdesc->raidPtr = raidPtr;\n\tdesc->status = 0;\n\tdesc->frow = frow;\n\tdesc->fcol = fcol;\n\tdesc->spRow = badDisk->spareRow;\n\tdesc->spCol = badDisk->spareCol;\n\tdesc->stripeAddr = 0;\n\tdesc->sectPerSU = raidPtr->Layout.sectorsPerStripeUnit;\n\tdesc->sectPerStripe = raidPtr->Layout.sectorsPerStripeUnit * raidPtr->Layout.numDataCol;\n\tdesc->databuf = databuf;\n\tdesc->mcpair = rf_AllocMCPair();\n\n\tprintf(\"COPYBACK: Quiescing the array\\n\");\n\t/* quiesce the array, since we don't want to code support for user\n\t * accs here */\n\trf_SuspendNewRequestsAndWait(raidPtr);\n\n\t/* adjust state of the array and of the disks */\n\tRF_LOCK_MUTEX(raidPtr->mutex);\n\traidPtr->Disks[desc->frow][desc->fcol].status = rf_ds_optimal;\n\traidPtr->status[desc->frow] = rf_rs_optimal;\n\trf_copyback_in_progress = 1;\t/* debug only */\n\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\n\tprintf(\"COPYBACK: Beginning\\n\");\n\tRF_GETTIME(desc->starttime);\n\trf_ContinueCopyback(desc);\n\n\t/* Data has been restored.  Fix up the component label. */\n\t/* Don't actually need the read here.. */\n\traidread_component_label( raidPtr->raid_cinfo[frow][fcol].ci_dev,\n\t\t\t\t  raidPtr->raid_cinfo[frow][fcol].ci_vp,\n\t\t\t\t  &c_label);\n\t\t\n\tc_label.version = RF_COMPONENT_LABEL_VERSION; \n\tc_label.mod_counter = raidPtr->mod_counter;\n\tc_label.serial_number = raidPtr->serial_number;\n\tc_label.row = frow;\n\tc_label.column = fcol;\n\tc_label.num_rows = raidPtr->numRow;\n\tc_label.num_columns = raidPtr->numCol;\n\tc_label.clean = RF_RAID_DIRTY;\n\tc_label.status = rf_ds_optimal;\n\t\n\traidwrite_component_label( raidPtr->raid_cinfo[frow][fcol].ci_dev,\n\t\t\t\t   raidPtr->raid_cinfo[frow][fcol].ci_vp,\n\t\t\t\t   &c_label);\n}",
          "includes": [
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"rf_kintf.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_decluster.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_mcpair.h\"",
            "#include \"rf_raid.h\"",
            "#include <sys/buf.h>",
            "#include <sys/time.h>",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int     rf_copyback_in_progress;",
            "static int rf_CopybackReadDoneProc(RF_CopybackDesc_t * desc, int status);",
            "static int rf_CopybackWriteDoneProc(RF_CopybackDesc_t * desc, int status);",
            "static void rf_CopybackComplete(RF_CopybackDesc_t * desc, int status);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_driver.h\"\n#include \"rf_decluster.h\"\n#include \"rf_copyback.h\"\n#include \"rf_utils.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_raid.h\"\n#include <sys/buf.h>\n#include <sys/time.h>\n#include \"rf_types.h\"\n\nint     rf_copyback_in_progress;\nstatic int rf_CopybackReadDoneProc(RF_CopybackDesc_t * desc, int status);\nstatic int rf_CopybackWriteDoneProc(RF_CopybackDesc_t * desc, int status);\nstatic void rf_CopybackComplete(RF_CopybackDesc_t * desc, int status);\n\nvoid \nrf_CopybackReconstructedData(raidPtr)\n\tRF_Raid_t *raidPtr;\n{\n\tRF_ComponentLabel_t c_label;\n\tint     done, retcode;\n\tRF_CopybackDesc_t *desc;\n\tRF_RowCol_t frow, fcol;\n\tRF_RaidDisk_t *badDisk;\n\tchar   *databuf;\n\n\tstruct partinfo dpart;\n\tstruct vnode *vp;\n\tstruct vattr va;\n\tstruct proc *proc;\n\n\tdone = 0;\n\tfcol = 0;\n\tfor (frow = 0; frow < raidPtr->numRow; frow++) {\n\t\tfor (fcol = 0; fcol < raidPtr->numCol; fcol++) {\n\t\t\tif (raidPtr->Disks[frow][fcol].status == rf_ds_dist_spared\n\t\t\t    || raidPtr->Disks[frow][fcol].status == rf_ds_spared) {\n\t\t\t\tdone = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (done)\n\t\t\tbreak;\n\t}\n\n\tif (frow == raidPtr->numRow) {\n\t\tprintf(\"COPYBACK:  no disks need copyback\\n\");\n\t\treturn;\n\t}\n\tbadDisk = &raidPtr->Disks[frow][fcol];\n\n\tproc = raidPtr->engine_thread;\n\n\t/* This device may have been opened successfully the first time. Close\n\t * it before trying to open it again.. */\n\n\tif (raidPtr->raid_cinfo[frow][fcol].ci_vp != NULL) {\n\t\tprintf(\"Closed the open device: %s\\n\",\n\t\t    raidPtr->Disks[frow][fcol].devname);\n\t\tVOP_UNLOCK(raidPtr->raid_cinfo[frow][fcol].ci_vp, 0, proc);\n\t\t(void) vn_close(raidPtr->raid_cinfo[frow][fcol].ci_vp,\n\t\t    FREAD | FWRITE, proc->p_ucred, proc);\n\t\traidPtr->raid_cinfo[frow][fcol].ci_vp = NULL;\n\t}\n\tprintf(\"About to (re-)open the device: %s\\n\",\n\t    raidPtr->Disks[frow][fcol].devname);\n\n\tretcode = raidlookup(raidPtr->Disks[frow][fcol].devname, proc, &vp);\n\n\tif (retcode) {\n\t\tprintf(\"COPYBACK: raidlookup on device: %s failed: %d!\\n\",\n\t\t    raidPtr->Disks[frow][fcol].devname, retcode);\n\n\t\t/* XXX the component isn't responding properly... must be\n\t\t * still dead :-( */\n\t\treturn;\n\n\t} else {\n\n\t\t/* Ok, so we can at least do a lookup... How about actually\n\t\t * getting a vp for it? */\n\n\t\tif ((retcode = VOP_GETATTR(vp, &va, proc->p_ucred, proc)) != 0) {\n\t\t\treturn;\n\t\t}\n\t\tretcode = VOP_IOCTL(vp, DIOCGPART, (caddr_t) & dpart,\n\t\t    FREAD, proc->p_ucred, proc);\n\t\tif (retcode) {\n\t\t\treturn;\n\t\t}\n\t\traidPtr->Disks[frow][fcol].blockSize = dpart.disklab->d_secsize;\n\n\t\traidPtr->Disks[frow][fcol].numBlocks = dpart.part->p_size -\n\t\t    rf_protectedSectors;\n\n\t\traidPtr->raid_cinfo[frow][fcol].ci_vp = vp;\n\t\traidPtr->raid_cinfo[frow][fcol].ci_dev = va.va_rdev;\n\n\t\traidPtr->Disks[frow][fcol].dev = va.va_rdev;\t/* XXX or the above? */\n\n\t\t/* we allow the user to specify that only a fraction of the\n\t\t * disks should be used this is just for debug:  it speeds up\n\t\t * the parity scan */\n\t\traidPtr->Disks[frow][fcol].numBlocks =\n\t\t    raidPtr->Disks[frow][fcol].numBlocks *\n\t\t    rf_sizePercentage / 100;\n\t}\n#if 0\n\t/* This is the way it was done before the CAM stuff was removed */\n\n\tif (rf_extract_ids(badDisk->devname, &bus, &targ, &lun)) {\n\t\tprintf(\"COPYBACK: unable to extract bus, target, lun from devname %s\\n\",\n\t\t    badDisk->devname);\n\t\treturn;\n\t}\n\t/* TUR the disk that's marked as bad to be sure that it's actually\n\t * alive */\n\trf_SCSI_AllocTUR(&tur_op);\n\tretcode = rf_SCSI_DoTUR(tur_op, bus, targ, lun, badDisk->dev);\n\trf_SCSI_FreeDiskOp(tur_op, 0);\n#endif\n\n\tif (retcode) {\n\t\tprintf(\"COPYBACK: target disk failed TUR\\n\");\n\t\treturn;\n\t}\n\t/* get a buffer to hold one SU  */\n\tRF_Malloc(databuf, rf_RaidAddressToByte(raidPtr, raidPtr->Layout.sectorsPerStripeUnit), (char *));\n\n\t/* create a descriptor */\n\tRF_Malloc(desc, sizeof(*desc), (RF_CopybackDesc_t *));\n\tdesc->raidPtr = raidPtr;\n\tdesc->status = 0;\n\tdesc->frow = frow;\n\tdesc->fcol = fcol;\n\tdesc->spRow = badDisk->spareRow;\n\tdesc->spCol = badDisk->spareCol;\n\tdesc->stripeAddr = 0;\n\tdesc->sectPerSU = raidPtr->Layout.sectorsPerStripeUnit;\n\tdesc->sectPerStripe = raidPtr->Layout.sectorsPerStripeUnit * raidPtr->Layout.numDataCol;\n\tdesc->databuf = databuf;\n\tdesc->mcpair = rf_AllocMCPair();\n\n\tprintf(\"COPYBACK: Quiescing the array\\n\");\n\t/* quiesce the array, since we don't want to code support for user\n\t * accs here */\n\trf_SuspendNewRequestsAndWait(raidPtr);\n\n\t/* adjust state of the array and of the disks */\n\tRF_LOCK_MUTEX(raidPtr->mutex);\n\traidPtr->Disks[desc->frow][desc->fcol].status = rf_ds_optimal;\n\traidPtr->status[desc->frow] = rf_rs_optimal;\n\trf_copyback_in_progress = 1;\t/* debug only */\n\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\n\tprintf(\"COPYBACK: Beginning\\n\");\n\tRF_GETTIME(desc->starttime);\n\trf_ContinueCopyback(desc);\n\n\t/* Data has been restored.  Fix up the component label. */\n\t/* Don't actually need the read here.. */\n\traidread_component_label( raidPtr->raid_cinfo[frow][fcol].ci_dev,\n\t\t\t\t  raidPtr->raid_cinfo[frow][fcol].ci_vp,\n\t\t\t\t  &c_label);\n\t\t\n\tc_label.version = RF_COMPONENT_LABEL_VERSION; \n\tc_label.mod_counter = raidPtr->mod_counter;\n\tc_label.serial_number = raidPtr->serial_number;\n\tc_label.row = frow;\n\tc_label.column = fcol;\n\tc_label.num_rows = raidPtr->numRow;\n\tc_label.num_columns = raidPtr->numCol;\n\tc_label.clean = RF_RAID_DIRTY;\n\tc_label.status = rf_ds_optimal;\n\t\n\traidwrite_component_label( raidPtr->raid_cinfo[frow][fcol].ci_dev,\n\t\t\t\t   raidPtr->raid_cinfo[frow][fcol].ci_vp,\n\t\t\t\t   &c_label);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 2311
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\nvoid rf_CopybackThread;\n\nvoid\nrf_CopybackThread(raidPtr)\n\tRF_Raid_t *raidPtr;\n{\n\tint s;\n\n\traidPtr->copyback_in_progress = 1;\n\ts = splbio();\n\trf_CopybackReconstructedData(raidPtr);\n\tsplx(s);\n\traidPtr->copyback_in_progress = 0;\n\n\t/* That's all... */\n\tkthread_exit(0);        /* does not return */\n}"
  },
  {
    "function_name": "rf_RewriteParityThread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_openbsdkintf.c",
    "lines": "2278-2301",
    "snippet": "void\nrf_RewriteParityThread(raidPtr)\n\tRF_Raid_t *raidPtr;\n{\n\tint retcode;\n\tint s;\n\n\traidPtr->parity_rewrite_in_progress = 1;\n\ts = splbio();\n\tretcode = rf_RewriteParity(raidPtr);\n\tsplx(s);\n\tif (retcode) {\n\t\tprintf(\"raid%d: Error re-writing parity!\\n\",raidPtr->raidid);\n\t} else {\n\t\t/* set the clean bit!  If we shutdown correctly,\n\t\t   the clean bit on each component label will get\n\t\t   set */\n\t\traidPtr->parity_good = RF_RAID_CLEAN;\n\t}\n\traidPtr->parity_rewrite_in_progress = 0;\n\n\t/* That's all... */\n\tkthread_exit(0);        /* does not return */\n}",
    "includes": [
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_kintf.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_dagflags.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_copyback.h\"",
      "#include \"rf_raidframe.h\"",
      "#include \"rf_raid.h\"",
      "#include \"raid.h\"",
      "#include <sys/user.h>",
      "#include <sys/buf.h>",
      "#include <sys/lock.h>",
      "#include <sys/conf.h>",
      "#include <sys/namei.h>",
      "#include <sys/systm.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/device.h>",
      "#include <sys/disk.h>",
      "#include <sys/queue.h>",
      "#include <sys/malloc.h>",
      "#include <sys/param.h>",
      "#include <sys/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void rf_RewriteParityThread"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kthread_exit",
          "args": [
            "0"
          ],
          "line": 2300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"raid%d: Error re-writing parity!\\n\"",
            "raidPtr->raidid"
          ],
          "line": 2290
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 2288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RewriteParity",
          "args": [
            "raidPtr"
          ],
          "line": 2287
        },
        "resolved": true,
        "details": {
          "function_name": "rf_RewriteParityThread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_openbsdkintf.c",
          "lines": "2278-2301",
          "snippet": "void\nrf_RewriteParityThread(raidPtr)\n\tRF_Raid_t *raidPtr;\n{\n\tint retcode;\n\tint s;\n\n\traidPtr->parity_rewrite_in_progress = 1;\n\ts = splbio();\n\tretcode = rf_RewriteParity(raidPtr);\n\tsplx(s);\n\tif (retcode) {\n\t\tprintf(\"raid%d: Error re-writing parity!\\n\",raidPtr->raidid);\n\t} else {\n\t\t/* set the clean bit!  If we shutdown correctly,\n\t\t   the clean bit on each component label will get\n\t\t   set */\n\t\traidPtr->parity_good = RF_RAID_CLEAN;\n\t}\n\traidPtr->parity_rewrite_in_progress = 0;\n\n\t/* That's all... */\n\tkthread_exit(0);        /* does not return */\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 2286
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\nvoid rf_RewriteParityThread;\n\nvoid\nrf_RewriteParityThread(raidPtr)\n\tRF_Raid_t *raidPtr;\n{\n\tint retcode;\n\tint s;\n\n\traidPtr->parity_rewrite_in_progress = 1;\n\ts = splbio();\n\tretcode = rf_RewriteParity(raidPtr);\n\tsplx(s);\n\tif (retcode) {\n\t\tprintf(\"raid%d: Error re-writing parity!\\n\",raidPtr->raidid);\n\t} else {\n\t\t/* set the clean bit!  If we shutdown correctly,\n\t\t   the clean bit on each component label will get\n\t\t   set */\n\t\traidPtr->parity_good = RF_RAID_CLEAN;\n\t}\n\traidPtr->parity_rewrite_in_progress = 0;\n\n\t/* That's all... */\n\tkthread_exit(0);        /* does not return */\n}"
  },
  {
    "function_name": "rf_ReconThread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_openbsdkintf.c",
    "lines": "2254-2276",
    "snippet": "void \nrf_ReconThread(req)\n\tstruct rf_recon_req *req;\n{\n\tint     s;\n\tRF_Raid_t *raidPtr;\n\n\ts = splbio();\n\traidPtr = (RF_Raid_t *) req->raidPtr;\n\traidPtr->recon_in_progress = 1;\n\n\trf_FailDisk((RF_Raid_t *) req->raidPtr, req->row, req->col,\n\t\t    ((req->flags & RF_FDFLAGS_RECON) ? 1 : 0));\n\n\t/* XXX get rid of this! we don't need it at all.. */\n\tRF_Free(req, sizeof(*req));\n\n\traidPtr->recon_in_progress = 0;\n\tsplx(s);\n\n\t/* That's all... */\n\tkthread_exit(0);        /* does not return */\n}",
    "includes": [
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_kintf.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_dagflags.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_copyback.h\"",
      "#include \"rf_raidframe.h\"",
      "#include \"rf_raid.h\"",
      "#include \"raid.h\"",
      "#include <sys/user.h>",
      "#include <sys/buf.h>",
      "#include <sys/lock.h>",
      "#include <sys/conf.h>",
      "#include <sys/namei.h>",
      "#include <sys/systm.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/device.h>",
      "#include <sys/disk.h>",
      "#include <sys/queue.h>",
      "#include <sys/malloc.h>",
      "#include <sys/param.h>",
      "#include <sys/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void rf_ReconThread"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kthread_exit",
          "args": [
            "0"
          ],
          "line": 2275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 2272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "req",
            "sizeof(*req)"
          ],
          "line": 2269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_FailDisk",
          "args": [
            "(RF_Raid_t *) req->raidPtr",
            "req->row",
            "req->col",
            "((req->flags & RF_FDFLAGS_RECON) ? 1 : 0)"
          ],
          "line": 2265
        },
        "resolved": true,
        "details": {
          "function_name": "rf_FailDisk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_driver.c",
          "lines": "749-765",
          "snippet": "int \nrf_FailDisk(\n    RF_Raid_t * raidPtr,\n    int frow,\n    int fcol,\n    int initRecon)\n{\n\tprintf(\"raid%d: Failing disk r%d c%d\\n\", raidPtr->raidid, frow, fcol);\n\tRF_LOCK_MUTEX(raidPtr->mutex);\n\traidPtr->numFailures++;\n\traidPtr->Disks[frow][fcol].status = rf_ds_failed;\n\traidPtr->status[frow] = rf_rs_degraded;\n\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\tif (initRecon)\n\t\trf_ReconstructFailedDisk(raidPtr, frow, fcol);\n\treturn (0);\n}",
          "includes": [
            "#include <sys/buf.h>",
            "#include \"rf_kintf.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_nwayxor.h\"",
            "#include \"rf_mcpair.h\"",
            "#include \"rf_memchunk.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_callback.h\"",
            "#include \"rf_revent.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_decluster.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_states.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_aselect.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include <sys/errno.h>",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_archs.h\"",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rf_UnconfigureVnodes( RF_Raid_t * );"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_options.h\"\n#include \"rf_driver.h\"\n#include \"rf_copyback.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_nwayxor.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_memchunk.h\"\n#include \"rf_engine.h\"\n#include \"rf_callback.h\"\n#include \"rf_revent.h\"\n#include \"rf_map.h\"\n#include \"rf_decluster.h\"\n#include \"rf_freelist.h\"\n#include \"rf_states.h\"\n#include \"rf_desc.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_utils.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_aselect.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n#include \"rf_archs.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid rf_UnconfigureVnodes( RF_Raid_t * );\n\nint \nrf_FailDisk(\n    RF_Raid_t * raidPtr,\n    int frow,\n    int fcol,\n    int initRecon)\n{\n\tprintf(\"raid%d: Failing disk r%d c%d\\n\", raidPtr->raidid, frow, fcol);\n\tRF_LOCK_MUTEX(raidPtr->mutex);\n\traidPtr->numFailures++;\n\traidPtr->Disks[frow][fcol].status = rf_ds_failed;\n\traidPtr->status[frow] = rf_rs_degraded;\n\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\tif (initRecon)\n\t\trf_ReconstructFailedDisk(raidPtr, frow, fcol);\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 2261
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\nvoid rf_ReconThread;\n\nvoid \nrf_ReconThread(req)\n\tstruct rf_recon_req *req;\n{\n\tint     s;\n\tRF_Raid_t *raidPtr;\n\n\ts = splbio();\n\traidPtr = (RF_Raid_t *) req->raidPtr;\n\traidPtr->recon_in_progress = 1;\n\n\trf_FailDisk((RF_Raid_t *) req->raidPtr, req->row, req->col,\n\t\t    ((req->flags & RF_FDFLAGS_RECON) ? 1 : 0));\n\n\t/* XXX get rid of this! we don't need it at all.. */\n\tRF_Free(req, sizeof(*req));\n\n\traidPtr->recon_in_progress = 0;\n\tsplx(s);\n\n\t/* That's all... */\n\tkthread_exit(0);        /* does not return */\n}"
  },
  {
    "function_name": "rf_update_component_labels",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_openbsdkintf.c",
    "lines": "2137-2252",
    "snippet": "void\nrf_update_component_labels( raidPtr )\n\tRF_Raid_t *raidPtr;\n{\n\tRF_ComponentLabel_t c_label;\n\tint sparecol;\n\tint r,c;\n\tint i,j;\n\tint srow, scol;\n\n\tsrow = -1;\n\tscol = -1;\n\n\t/* XXX should do extra checks to make sure things really are clean, \n\t   rather than blindly setting the clean bit... */\n\n\traidPtr->mod_counter++;\n\n\tfor (r = 0; r < raidPtr->numRow; r++) {\n\t\tfor (c = 0; c < raidPtr->numCol; c++) {\n\t\t\tif (raidPtr->Disks[r][c].status == rf_ds_optimal) {\n\t\t\t\traidread_component_label(\n\t\t\t\t\traidPtr->Disks[r][c].dev,\n\t\t\t\t\traidPtr->raid_cinfo[r][c].ci_vp,\n\t\t\t\t\t&c_label);\n\t\t\t\t/* make sure status is noted */\n\t\t\t\tc_label.status = rf_ds_optimal;\n\t\t\t\traidwrite_component_label( \n\t\t\t\t\traidPtr->Disks[r][c].dev,\n\t\t\t\t\traidPtr->raid_cinfo[r][c].ci_vp,\n\t\t\t\t\t&c_label);\n\t\t\t\tif (raidPtr->parity_good == RF_RAID_CLEAN) {\n\t\t\t\t\traidmarkclean( \n\t\t\t\t\t      raidPtr->Disks[r][c].dev, \n\t\t\t\t\t      raidPtr->raid_cinfo[r][c].ci_vp,\n\t\t\t\t\t      raidPtr->mod_counter);\n\t\t\t\t}\n\t\t\t} \n\t\t\t/* else we don't touch it.. */\n#if 0\n\t\t\telse if (raidPtr->Disks[r][c].status !=\n\t\t\t\t   rf_ds_failed) {\n\t\t\t\traidread_component_label(\n\t\t\t\t\traidPtr->Disks[r][c].dev,\n\t\t\t\t\traidPtr->raid_cinfo[r][c].ci_vp,\n\t\t\t\t\t&c_label);\n\t\t\t\t/* make sure status is noted */\n\t\t\t\tc_label.status = \n\t\t\t\t\traidPtr->Disks[r][c].status;\n\t\t\t\traidwrite_component_label( \n\t\t\t\t\traidPtr->Disks[r][c].dev,\n\t\t\t\t\traidPtr->raid_cinfo[r][c].ci_vp,\n\t\t\t\t\t&c_label);\n\t\t\t\tif (raidPtr->parity_good == RF_RAID_CLEAN) {\n\t\t\t\t\traidmarkclean( \n\t\t\t\t\t      raidPtr->Disks[r][c].dev, \n\t\t\t\t\t      raidPtr->raid_cinfo[r][c].ci_vp,\n\t\t\t\t\t      raidPtr->mod_counter);\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t} \n\t}\n\n\tfor( c = 0; c < raidPtr->numSpare ; c++) {\n\t\tsparecol = raidPtr->numCol + c;\n\t\tif (raidPtr->Disks[0][sparecol].status == rf_ds_used_spare) {\n\t\t\t/* \n\t\t\t   \n\t\t\t   we claim this disk is \"optimal\" if it's \n\t\t\t   rf_ds_used_spare, as that means it should be \n\t\t\t   directly substitutable for the disk it replaced. \n\t\t\t   We note that too...\n\n\t\t\t */\n\n\t\t\tfor(i=0;i<raidPtr->numRow;i++) {\n\t\t\t\tfor(j=0;j<raidPtr->numCol;j++) {\n\t\t\t\t\tif ((raidPtr->Disks[i][j].spareRow == \n\t\t\t\t\t     0) &&\n\t\t\t\t\t    (raidPtr->Disks[i][j].spareCol ==\n\t\t\t\t\t     sparecol)) {\n\t\t\t\t\t\tsrow = i;\n\t\t\t\t\t\tscol = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\traidread_component_label( \n\t\t\t\t      raidPtr->Disks[0][sparecol].dev,\n\t\t\t\t      raidPtr->raid_cinfo[0][sparecol].ci_vp,\n\t\t\t\t      &c_label);\n\t\t\t/* make sure status is noted */\n\t\t\tc_label.version = RF_COMPONENT_LABEL_VERSION; \n\t\t\tc_label.mod_counter = raidPtr->mod_counter;\n\t\t\tc_label.serial_number = raidPtr->serial_number;\n\t\t\tc_label.row = srow;\n\t\t\tc_label.column = scol;\n\t\t\tc_label.num_rows = raidPtr->numRow;\n\t\t\tc_label.num_columns = raidPtr->numCol;\n\t\t\tc_label.clean = RF_RAID_DIRTY; /* changed in a bit*/\n\t\t\tc_label.status = rf_ds_optimal;\n\t\t\traidwrite_component_label(\n\t\t\t\t      raidPtr->Disks[0][sparecol].dev,\n\t\t\t\t      raidPtr->raid_cinfo[0][sparecol].ci_vp,\n\t\t\t\t      &c_label);\n\t\t\tif (raidPtr->parity_good == RF_RAID_CLEAN) {\n\t\t\t\traidmarkclean( raidPtr->Disks[0][sparecol].dev,\n\t\t\t              raidPtr->raid_cinfo[0][sparecol].ci_vp,\n\t\t\t\t\t       raidPtr->mod_counter);\n\t\t\t}\n\t\t}\n\t}\n\t/* \tprintf(\"Component labels updated\\n\"); */\n}",
    "includes": [
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_kintf.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_dagflags.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_copyback.h\"",
      "#include \"rf_raidframe.h\"",
      "#include \"rf_raid.h\"",
      "#include \"raid.h\"",
      "#include <sys/user.h>",
      "#include <sys/buf.h>",
      "#include <sys/lock.h>",
      "#include <sys/conf.h>",
      "#include <sys/namei.h>",
      "#include <sys/systm.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/device.h>",
      "#include <sys/disk.h>",
      "#include <sys/queue.h>",
      "#include <sys/malloc.h>",
      "#include <sys/param.h>",
      "#include <sys/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raidmarkclean",
          "args": [
            "raidPtr->Disks[0][sparecol].dev",
            "raidPtr->raid_cinfo[0][sparecol].ci_vp",
            "raidPtr->mod_counter"
          ],
          "line": 2245
        },
        "resolved": true,
        "details": {
          "function_name": "raidmarkclean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_openbsdkintf.c",
          "lines": "1933-1942",
          "snippet": "int \nraidmarkclean(dev_t dev, struct vnode *b_vp, int mod_counter)\n{\n\tRF_ComponentLabel_t component_label;\n\traidread_component_label(dev, b_vp, &component_label);\n\tcomponent_label.mod_counter = mod_counter;\n\tcomponent_label.clean = RF_RAID_CLEAN;\n\traidwrite_component_label(dev, b_vp, &component_label);\n\treturn(0);\n}",
          "includes": [
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_dagflags.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_raidframe.h\"",
            "#include \"rf_raid.h\"",
            "#include \"raid.h\"",
            "#include <sys/user.h>",
            "#include <sys/buf.h>",
            "#include <sys/lock.h>",
            "#include <sys/conf.h>",
            "#include <sys/namei.h>",
            "#include <sys/systm.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/device.h>",
            "#include <sys/disk.h>",
            "#include <sys/queue.h>",
            "#include <sys/malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\nint \nraidmarkclean(dev_t dev, struct vnode *b_vp, int mod_counter)\n{\n\tRF_ComponentLabel_t component_label;\n\traidread_component_label(dev, b_vp, &component_label);\n\tcomponent_label.mod_counter = mod_counter;\n\tcomponent_label.clean = RF_RAID_CLEAN;\n\traidwrite_component_label(dev, b_vp, &component_label);\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raidwrite_component_label",
          "args": [
            "raidPtr->Disks[0][sparecol].dev",
            "raidPtr->raid_cinfo[0][sparecol].ci_vp",
            "&c_label"
          ],
          "line": 2240
        },
        "resolved": true,
        "details": {
          "function_name": "raidwrite_component_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_openbsdkintf.c",
          "lines": "2007-2039",
          "snippet": "int \nraidwrite_component_label(dev, b_vp, component_label)\n\tdev_t dev; \n\tstruct vnode *b_vp;\n\tRF_ComponentLabel_t *component_label;\n{\n\tstruct buf *bp;\n\tint error;\n\n\t/* get a block of the appropriate size... */\n\tbp = geteblk((int)RF_COMPONENT_INFO_SIZE);\n\tbp->b_dev = dev;\n\n\t/* get our ducks in a row for the write */\n\tbp->b_blkno = RF_COMPONENT_INFO_OFFSET / DEV_BSIZE;\n\tbp->b_bcount = RF_COMPONENT_INFO_SIZE;\n\tbp->b_flags = B_BUSY | B_WRITE;\n \tbp->b_resid = RF_COMPONENT_INFO_SIZE / DEV_BSIZE;\n\n\tmemset( bp->b_un.b_addr, 0, RF_COMPONENT_INFO_SIZE );\n\n\tmemcpy( bp->b_un.b_addr, component_label, sizeof(RF_ComponentLabel_t));\n\n\t(*bdevsw[major(bp->b_dev)].d_strategy)(bp);\n\terror = biowait(bp); \n        bp->b_flags = B_INVAL | B_AGE;\n\tbrelse(bp);\n\tif (error) {\n\t\tprintf(\"Failed to write RAID component info!\\n\");\n\t}\n\n\treturn(error);\n}",
          "includes": [
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_dagflags.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_raidframe.h\"",
            "#include \"rf_raid.h\"",
            "#include \"raid.h\"",
            "#include <sys/user.h>",
            "#include <sys/buf.h>",
            "#include <sys/lock.h>",
            "#include <sys/conf.h>",
            "#include <sys/namei.h>",
            "#include <sys/systm.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/device.h>",
            "#include <sys/disk.h>",
            "#include <sys/queue.h>",
            "#include <sys/malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/errno.h>"
          ],
          "macros_used": [
            "#define RF_COMPONENT_INFO_SIZE     1024 /* bytes */",
            "#define RF_COMPONENT_INFO_OFFSET  16384 /* bytes */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\n#define RF_COMPONENT_INFO_SIZE     1024 /* bytes */\n#define RF_COMPONENT_INFO_OFFSET  16384 /* bytes */\n\nint \nraidwrite_component_label(dev, b_vp, component_label)\n\tdev_t dev; \n\tstruct vnode *b_vp;\n\tRF_ComponentLabel_t *component_label;\n{\n\tstruct buf *bp;\n\tint error;\n\n\t/* get a block of the appropriate size... */\n\tbp = geteblk((int)RF_COMPONENT_INFO_SIZE);\n\tbp->b_dev = dev;\n\n\t/* get our ducks in a row for the write */\n\tbp->b_blkno = RF_COMPONENT_INFO_OFFSET / DEV_BSIZE;\n\tbp->b_bcount = RF_COMPONENT_INFO_SIZE;\n\tbp->b_flags = B_BUSY | B_WRITE;\n \tbp->b_resid = RF_COMPONENT_INFO_SIZE / DEV_BSIZE;\n\n\tmemset( bp->b_un.b_addr, 0, RF_COMPONENT_INFO_SIZE );\n\n\tmemcpy( bp->b_un.b_addr, component_label, sizeof(RF_ComponentLabel_t));\n\n\t(*bdevsw[major(bp->b_dev)].d_strategy)(bp);\n\terror = biowait(bp); \n        bp->b_flags = B_INVAL | B_AGE;\n\tbrelse(bp);\n\tif (error) {\n\t\tprintf(\"Failed to write RAID component info!\\n\");\n\t}\n\n\treturn(error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raidread_component_label",
          "args": [
            "raidPtr->Disks[0][sparecol].dev",
            "raidPtr->raid_cinfo[0][sparecol].ci_vp",
            "&c_label"
          ],
          "line": 2226
        },
        "resolved": true,
        "details": {
          "function_name": "raidread_component_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_openbsdkintf.c",
          "lines": "1957-2005",
          "snippet": "int\nraidread_component_label(dev, b_vp, component_label)\n\tdev_t dev;\n\tstruct vnode *b_vp;\n\tRF_ComponentLabel_t *component_label;\n{\n\tstruct buf *bp;\n\tint error;\n\t\n\t/* XXX should probably ensure that we don't try to do this if\n\t   someone has changed rf_protected_sectors. */ \n\n\t/* get a block of the appropriate size... */\n\tbp = geteblk((int)RF_COMPONENT_INFO_SIZE);\n\tbp->b_dev = dev;\n\n\t/* get our ducks in a row for the read */\n\tbp->b_blkno = RF_COMPONENT_INFO_OFFSET / DEV_BSIZE;\n\tbp->b_bcount = RF_COMPONENT_INFO_SIZE;\n\tbp->b_flags = B_BUSY | B_READ;\n \tbp->b_resid = RF_COMPONENT_INFO_SIZE / DEV_BSIZE;\n\n\t(*bdevsw[major(bp->b_dev)].d_strategy)(bp);\n\n\terror = biowait(bp); \n\n\tif (!error) {\n\t\tmemcpy(component_label, bp->b_un.b_addr,\n\t\t       sizeof(RF_ComponentLabel_t));\n#if 0\n\t\tprintf(\"raidread_component_label: got component label:\\n\");\n\t\tprintf(\"Version: %d\\n\",component_label->version);\n\t\tprintf(\"Serial Number: %d\\n\",component_label->serial_number);\n\t\tprintf(\"Mod counter: %d\\n\",component_label->mod_counter);\n\t\tprintf(\"Row: %d\\n\", component_label->row);\n\t\tprintf(\"Column: %d\\n\", component_label->column);\n\t\tprintf(\"Num Rows: %d\\n\", component_label->num_rows);\n\t\tprintf(\"Num Columns: %d\\n\", component_label->num_columns);\n\t\tprintf(\"Clean: %d\\n\", component_label->clean);\n\t\tprintf(\"Status: %d\\n\", component_label->status);\n#endif\n        } else {\n\t\tprintf(\"Failed to read RAID component label!\\n\");\n\t}\n\n        bp->b_flags = B_INVAL | B_AGE;\n\tbrelse(bp); \n\treturn(error);\n}",
          "includes": [
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_dagflags.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_raidframe.h\"",
            "#include \"rf_raid.h\"",
            "#include \"raid.h\"",
            "#include <sys/user.h>",
            "#include <sys/buf.h>",
            "#include <sys/lock.h>",
            "#include <sys/conf.h>",
            "#include <sys/namei.h>",
            "#include <sys/systm.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/device.h>",
            "#include <sys/disk.h>",
            "#include <sys/queue.h>",
            "#include <sys/malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/errno.h>"
          ],
          "macros_used": [
            "#define RF_COMPONENT_INFO_SIZE     1024 /* bytes */",
            "#define RF_COMPONENT_INFO_OFFSET  16384 /* bytes */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\n#define RF_COMPONENT_INFO_SIZE     1024 /* bytes */\n#define RF_COMPONENT_INFO_OFFSET  16384 /* bytes */\n\nint\nraidread_component_label(dev, b_vp, component_label)\n\tdev_t dev;\n\tstruct vnode *b_vp;\n\tRF_ComponentLabel_t *component_label;\n{\n\tstruct buf *bp;\n\tint error;\n\t\n\t/* XXX should probably ensure that we don't try to do this if\n\t   someone has changed rf_protected_sectors. */ \n\n\t/* get a block of the appropriate size... */\n\tbp = geteblk((int)RF_COMPONENT_INFO_SIZE);\n\tbp->b_dev = dev;\n\n\t/* get our ducks in a row for the read */\n\tbp->b_blkno = RF_COMPONENT_INFO_OFFSET / DEV_BSIZE;\n\tbp->b_bcount = RF_COMPONENT_INFO_SIZE;\n\tbp->b_flags = B_BUSY | B_READ;\n \tbp->b_resid = RF_COMPONENT_INFO_SIZE / DEV_BSIZE;\n\n\t(*bdevsw[major(bp->b_dev)].d_strategy)(bp);\n\n\terror = biowait(bp); \n\n\tif (!error) {\n\t\tmemcpy(component_label, bp->b_un.b_addr,\n\t\t       sizeof(RF_ComponentLabel_t));\n#if 0\n\t\tprintf(\"raidread_component_label: got component label:\\n\");\n\t\tprintf(\"Version: %d\\n\",component_label->version);\n\t\tprintf(\"Serial Number: %d\\n\",component_label->serial_number);\n\t\tprintf(\"Mod counter: %d\\n\",component_label->mod_counter);\n\t\tprintf(\"Row: %d\\n\", component_label->row);\n\t\tprintf(\"Column: %d\\n\", component_label->column);\n\t\tprintf(\"Num Rows: %d\\n\", component_label->num_rows);\n\t\tprintf(\"Num Columns: %d\\n\", component_label->num_columns);\n\t\tprintf(\"Clean: %d\\n\", component_label->clean);\n\t\tprintf(\"Status: %d\\n\", component_label->status);\n#endif\n        } else {\n\t\tprintf(\"Failed to read RAID component label!\\n\");\n\t}\n\n        bp->b_flags = B_INVAL | B_AGE;\n\tbrelse(bp); \n\treturn(error);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\nvoid\nrf_update_component_labels( raidPtr )\n\tRF_Raid_t *raidPtr;\n{\n\tRF_ComponentLabel_t c_label;\n\tint sparecol;\n\tint r,c;\n\tint i,j;\n\tint srow, scol;\n\n\tsrow = -1;\n\tscol = -1;\n\n\t/* XXX should do extra checks to make sure things really are clean, \n\t   rather than blindly setting the clean bit... */\n\n\traidPtr->mod_counter++;\n\n\tfor (r = 0; r < raidPtr->numRow; r++) {\n\t\tfor (c = 0; c < raidPtr->numCol; c++) {\n\t\t\tif (raidPtr->Disks[r][c].status == rf_ds_optimal) {\n\t\t\t\traidread_component_label(\n\t\t\t\t\traidPtr->Disks[r][c].dev,\n\t\t\t\t\traidPtr->raid_cinfo[r][c].ci_vp,\n\t\t\t\t\t&c_label);\n\t\t\t\t/* make sure status is noted */\n\t\t\t\tc_label.status = rf_ds_optimal;\n\t\t\t\traidwrite_component_label( \n\t\t\t\t\traidPtr->Disks[r][c].dev,\n\t\t\t\t\traidPtr->raid_cinfo[r][c].ci_vp,\n\t\t\t\t\t&c_label);\n\t\t\t\tif (raidPtr->parity_good == RF_RAID_CLEAN) {\n\t\t\t\t\traidmarkclean( \n\t\t\t\t\t      raidPtr->Disks[r][c].dev, \n\t\t\t\t\t      raidPtr->raid_cinfo[r][c].ci_vp,\n\t\t\t\t\t      raidPtr->mod_counter);\n\t\t\t\t}\n\t\t\t} \n\t\t\t/* else we don't touch it.. */\n#if 0\n\t\t\telse if (raidPtr->Disks[r][c].status !=\n\t\t\t\t   rf_ds_failed) {\n\t\t\t\traidread_component_label(\n\t\t\t\t\traidPtr->Disks[r][c].dev,\n\t\t\t\t\traidPtr->raid_cinfo[r][c].ci_vp,\n\t\t\t\t\t&c_label);\n\t\t\t\t/* make sure status is noted */\n\t\t\t\tc_label.status = \n\t\t\t\t\traidPtr->Disks[r][c].status;\n\t\t\t\traidwrite_component_label( \n\t\t\t\t\traidPtr->Disks[r][c].dev,\n\t\t\t\t\traidPtr->raid_cinfo[r][c].ci_vp,\n\t\t\t\t\t&c_label);\n\t\t\t\tif (raidPtr->parity_good == RF_RAID_CLEAN) {\n\t\t\t\t\traidmarkclean( \n\t\t\t\t\t      raidPtr->Disks[r][c].dev, \n\t\t\t\t\t      raidPtr->raid_cinfo[r][c].ci_vp,\n\t\t\t\t\t      raidPtr->mod_counter);\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t} \n\t}\n\n\tfor( c = 0; c < raidPtr->numSpare ; c++) {\n\t\tsparecol = raidPtr->numCol + c;\n\t\tif (raidPtr->Disks[0][sparecol].status == rf_ds_used_spare) {\n\t\t\t/* \n\t\t\t   \n\t\t\t   we claim this disk is \"optimal\" if it's \n\t\t\t   rf_ds_used_spare, as that means it should be \n\t\t\t   directly substitutable for the disk it replaced. \n\t\t\t   We note that too...\n\n\t\t\t */\n\n\t\t\tfor(i=0;i<raidPtr->numRow;i++) {\n\t\t\t\tfor(j=0;j<raidPtr->numCol;j++) {\n\t\t\t\t\tif ((raidPtr->Disks[i][j].spareRow == \n\t\t\t\t\t     0) &&\n\t\t\t\t\t    (raidPtr->Disks[i][j].spareCol ==\n\t\t\t\t\t     sparecol)) {\n\t\t\t\t\t\tsrow = i;\n\t\t\t\t\t\tscol = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\traidread_component_label( \n\t\t\t\t      raidPtr->Disks[0][sparecol].dev,\n\t\t\t\t      raidPtr->raid_cinfo[0][sparecol].ci_vp,\n\t\t\t\t      &c_label);\n\t\t\t/* make sure status is noted */\n\t\t\tc_label.version = RF_COMPONENT_LABEL_VERSION; \n\t\t\tc_label.mod_counter = raidPtr->mod_counter;\n\t\t\tc_label.serial_number = raidPtr->serial_number;\n\t\t\tc_label.row = srow;\n\t\t\tc_label.column = scol;\n\t\t\tc_label.num_rows = raidPtr->numRow;\n\t\t\tc_label.num_columns = raidPtr->numCol;\n\t\t\tc_label.clean = RF_RAID_DIRTY; /* changed in a bit*/\n\t\t\tc_label.status = rf_ds_optimal;\n\t\t\traidwrite_component_label(\n\t\t\t\t      raidPtr->Disks[0][sparecol].dev,\n\t\t\t\t      raidPtr->raid_cinfo[0][sparecol].ci_vp,\n\t\t\t\t      &c_label);\n\t\t\tif (raidPtr->parity_good == RF_RAID_CLEAN) {\n\t\t\t\traidmarkclean( raidPtr->Disks[0][sparecol].dev,\n\t\t\t              raidPtr->raid_cinfo[0][sparecol].ci_vp,\n\t\t\t\t\t       raidPtr->mod_counter);\n\t\t\t}\n\t\t}\n\t}\n\t/* \tprintf(\"Component labels updated\\n\"); */\n}"
  },
  {
    "function_name": "rf_markalldirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_openbsdkintf.c",
    "lines": "2041-2134",
    "snippet": "void \nrf_markalldirty( raidPtr )\n\tRF_Raid_t *raidPtr;\n{\n\tRF_ComponentLabel_t c_label;\n\tint r,c;\n\n\traidPtr->mod_counter++;\n\tfor (r = 0; r < raidPtr->numRow; r++) {\n\t\tfor (c = 0; c < raidPtr->numCol; c++) {\n\t\t\tif (raidPtr->Disks[r][c].status != rf_ds_failed) {\n\t\t\t\traidread_component_label(\n\t\t\t\t\traidPtr->Disks[r][c].dev,\n\t\t\t\t\traidPtr->raid_cinfo[r][c].ci_vp,\n\t\t\t\t\t&c_label);\n\t\t\t\tif (c_label.status == rf_ds_spared) {\n\t\t\t\t\t/* XXX do something special... \n\t\t\t\t\t but whatever you do, don't \n\t\t\t\t\t try to access it!! */\n\t\t\t\t} else {\n#if 0\n\t\t\t\tc_label.status = \n\t\t\t\t\traidPtr->Disks[r][c].status;\n\t\t\t\traidwrite_component_label( \n\t\t\t\t\traidPtr->Disks[r][c].dev,\n\t\t\t\t\traidPtr->raid_cinfo[r][c].ci_vp,\n\t\t\t\t\t&c_label);\n#endif\n\t\t\t\traidmarkdirty( \n\t\t\t\t       raidPtr->Disks[r][c].dev, \n\t\t\t\t       raidPtr->raid_cinfo[r][c].ci_vp,\n\t\t\t\t       raidPtr->mod_counter);\n\t\t\t\t}\n\t\t\t}\n\t\t} \n\t}\n\t/* printf(\"Component labels marked dirty.\\n\"); */\n#if 0\n\tfor( c = 0; c < raidPtr->numSpare ; c++) {\n\t\tsparecol = raidPtr->numCol + c;\n\t\tif (raidPtr->Disks[r][sparecol].status == rf_ds_used_spare) {\n\t\t\t/* \n\n\t\t\t   XXX this is where we get fancy and map this spare\n\t\t\t   into it's correct spot in the array.\n\n\t\t\t */\n\t\t\t/* \n\t\t\t   \n\t\t\t   we claim this disk is \"optimal\" if it's \n\t\t\t   rf_ds_used_spare, as that means it should be \n\t\t\t   directly substitutable for the disk it replaced. \n\t\t\t   We note that too...\n\n\t\t\t */\n\n\t\t\tfor(i=0;i<raidPtr->numRow;i++) {\n\t\t\t\tfor(j=0;j<raidPtr->numCol;j++) {\n\t\t\t\t\tif ((raidPtr->Disks[i][j].spareRow == \n\t\t\t\t\t     r) &&\n\t\t\t\t\t    (raidPtr->Disks[i][j].spareCol ==\n\t\t\t\t\t     sparecol)) {\n\t\t\t\t\t\tsrow = r;\n\t\t\t\t\t\tscol = sparecol;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\traidread_component_label( \n\t\t\t\t      raidPtr->Disks[r][sparecol].dev,\n\t\t\t\t      raidPtr->raid_cinfo[r][sparecol].ci_vp,\n\t\t\t\t      &c_label);\n\t\t\t/* make sure status is noted */\n\t\t\tc_label.version = RF_COMPONENT_LABEL_VERSION; \n\t\t\tc_label.mod_counter = raidPtr->mod_counter;\n\t\t\tc_label.serial_number = raidPtr->serial_number;\n\t\t\tc_label.row = srow;\n\t\t\tc_label.column = scol;\n\t\t\tc_label.num_rows = raidPtr->numRow;\n\t\t\tc_label.num_columns = raidPtr->numCol;\n\t\t\tc_label.clean = RF_RAID_DIRTY; /* changed in a bit*/\n\t\t\tc_label.status = rf_ds_optimal;\n\t\t\traidwrite_component_label(\n\t\t\t\t      raidPtr->Disks[r][sparecol].dev,\n\t\t\t\t      raidPtr->raid_cinfo[r][sparecol].ci_vp,\n\t\t\t\t      &c_label);\n\t\t\traidmarkclean( raidPtr->Disks[r][sparecol].dev, \n\t\t\t              raidPtr->raid_cinfo[r][sparecol].ci_vp);\n\t\t}\n\t}\n\n#endif\n}",
    "includes": [
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_kintf.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_dagflags.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_copyback.h\"",
      "#include \"rf_raidframe.h\"",
      "#include \"rf_raid.h\"",
      "#include \"raid.h\"",
      "#include <sys/user.h>",
      "#include <sys/buf.h>",
      "#include <sys/lock.h>",
      "#include <sys/conf.h>",
      "#include <sys/namei.h>",
      "#include <sys/systm.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/device.h>",
      "#include <sys/disk.h>",
      "#include <sys/queue.h>",
      "#include <sys/malloc.h>",
      "#include <sys/param.h>",
      "#include <sys/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\trf_markalldirty"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raidmarkclean",
          "args": [
            "raidPtr->Disks[r][sparecol].dev",
            "raidPtr->raid_cinfo[r][sparecol].ci_vp"
          ],
          "line": 2128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raidwrite_component_label",
          "args": [
            "raidPtr->Disks[r][sparecol].dev",
            "raidPtr->raid_cinfo[r][sparecol].ci_vp",
            "&c_label"
          ],
          "line": 2124
        },
        "resolved": true,
        "details": {
          "function_name": "raidwrite_component_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_openbsdkintf.c",
          "lines": "2007-2039",
          "snippet": "int \nraidwrite_component_label(dev, b_vp, component_label)\n\tdev_t dev; \n\tstruct vnode *b_vp;\n\tRF_ComponentLabel_t *component_label;\n{\n\tstruct buf *bp;\n\tint error;\n\n\t/* get a block of the appropriate size... */\n\tbp = geteblk((int)RF_COMPONENT_INFO_SIZE);\n\tbp->b_dev = dev;\n\n\t/* get our ducks in a row for the write */\n\tbp->b_blkno = RF_COMPONENT_INFO_OFFSET / DEV_BSIZE;\n\tbp->b_bcount = RF_COMPONENT_INFO_SIZE;\n\tbp->b_flags = B_BUSY | B_WRITE;\n \tbp->b_resid = RF_COMPONENT_INFO_SIZE / DEV_BSIZE;\n\n\tmemset( bp->b_un.b_addr, 0, RF_COMPONENT_INFO_SIZE );\n\n\tmemcpy( bp->b_un.b_addr, component_label, sizeof(RF_ComponentLabel_t));\n\n\t(*bdevsw[major(bp->b_dev)].d_strategy)(bp);\n\terror = biowait(bp); \n        bp->b_flags = B_INVAL | B_AGE;\n\tbrelse(bp);\n\tif (error) {\n\t\tprintf(\"Failed to write RAID component info!\\n\");\n\t}\n\n\treturn(error);\n}",
          "includes": [
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_dagflags.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_raidframe.h\"",
            "#include \"rf_raid.h\"",
            "#include \"raid.h\"",
            "#include <sys/user.h>",
            "#include <sys/buf.h>",
            "#include <sys/lock.h>",
            "#include <sys/conf.h>",
            "#include <sys/namei.h>",
            "#include <sys/systm.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/device.h>",
            "#include <sys/disk.h>",
            "#include <sys/queue.h>",
            "#include <sys/malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/errno.h>"
          ],
          "macros_used": [
            "#define RF_COMPONENT_INFO_SIZE     1024 /* bytes */",
            "#define RF_COMPONENT_INFO_OFFSET  16384 /* bytes */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\n#define RF_COMPONENT_INFO_SIZE     1024 /* bytes */\n#define RF_COMPONENT_INFO_OFFSET  16384 /* bytes */\n\nint \nraidwrite_component_label(dev, b_vp, component_label)\n\tdev_t dev; \n\tstruct vnode *b_vp;\n\tRF_ComponentLabel_t *component_label;\n{\n\tstruct buf *bp;\n\tint error;\n\n\t/* get a block of the appropriate size... */\n\tbp = geteblk((int)RF_COMPONENT_INFO_SIZE);\n\tbp->b_dev = dev;\n\n\t/* get our ducks in a row for the write */\n\tbp->b_blkno = RF_COMPONENT_INFO_OFFSET / DEV_BSIZE;\n\tbp->b_bcount = RF_COMPONENT_INFO_SIZE;\n\tbp->b_flags = B_BUSY | B_WRITE;\n \tbp->b_resid = RF_COMPONENT_INFO_SIZE / DEV_BSIZE;\n\n\tmemset( bp->b_un.b_addr, 0, RF_COMPONENT_INFO_SIZE );\n\n\tmemcpy( bp->b_un.b_addr, component_label, sizeof(RF_ComponentLabel_t));\n\n\t(*bdevsw[major(bp->b_dev)].d_strategy)(bp);\n\terror = biowait(bp); \n        bp->b_flags = B_INVAL | B_AGE;\n\tbrelse(bp);\n\tif (error) {\n\t\tprintf(\"Failed to write RAID component info!\\n\");\n\t}\n\n\treturn(error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raidread_component_label",
          "args": [
            "raidPtr->Disks[r][sparecol].dev",
            "raidPtr->raid_cinfo[r][sparecol].ci_vp",
            "&c_label"
          ],
          "line": 2110
        },
        "resolved": true,
        "details": {
          "function_name": "raidread_component_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_openbsdkintf.c",
          "lines": "1957-2005",
          "snippet": "int\nraidread_component_label(dev, b_vp, component_label)\n\tdev_t dev;\n\tstruct vnode *b_vp;\n\tRF_ComponentLabel_t *component_label;\n{\n\tstruct buf *bp;\n\tint error;\n\t\n\t/* XXX should probably ensure that we don't try to do this if\n\t   someone has changed rf_protected_sectors. */ \n\n\t/* get a block of the appropriate size... */\n\tbp = geteblk((int)RF_COMPONENT_INFO_SIZE);\n\tbp->b_dev = dev;\n\n\t/* get our ducks in a row for the read */\n\tbp->b_blkno = RF_COMPONENT_INFO_OFFSET / DEV_BSIZE;\n\tbp->b_bcount = RF_COMPONENT_INFO_SIZE;\n\tbp->b_flags = B_BUSY | B_READ;\n \tbp->b_resid = RF_COMPONENT_INFO_SIZE / DEV_BSIZE;\n\n\t(*bdevsw[major(bp->b_dev)].d_strategy)(bp);\n\n\terror = biowait(bp); \n\n\tif (!error) {\n\t\tmemcpy(component_label, bp->b_un.b_addr,\n\t\t       sizeof(RF_ComponentLabel_t));\n#if 0\n\t\tprintf(\"raidread_component_label: got component label:\\n\");\n\t\tprintf(\"Version: %d\\n\",component_label->version);\n\t\tprintf(\"Serial Number: %d\\n\",component_label->serial_number);\n\t\tprintf(\"Mod counter: %d\\n\",component_label->mod_counter);\n\t\tprintf(\"Row: %d\\n\", component_label->row);\n\t\tprintf(\"Column: %d\\n\", component_label->column);\n\t\tprintf(\"Num Rows: %d\\n\", component_label->num_rows);\n\t\tprintf(\"Num Columns: %d\\n\", component_label->num_columns);\n\t\tprintf(\"Clean: %d\\n\", component_label->clean);\n\t\tprintf(\"Status: %d\\n\", component_label->status);\n#endif\n        } else {\n\t\tprintf(\"Failed to read RAID component label!\\n\");\n\t}\n\n        bp->b_flags = B_INVAL | B_AGE;\n\tbrelse(bp); \n\treturn(error);\n}",
          "includes": [
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_dagflags.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_raidframe.h\"",
            "#include \"rf_raid.h\"",
            "#include \"raid.h\"",
            "#include <sys/user.h>",
            "#include <sys/buf.h>",
            "#include <sys/lock.h>",
            "#include <sys/conf.h>",
            "#include <sys/namei.h>",
            "#include <sys/systm.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/device.h>",
            "#include <sys/disk.h>",
            "#include <sys/queue.h>",
            "#include <sys/malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/errno.h>"
          ],
          "macros_used": [
            "#define RF_COMPONENT_INFO_SIZE     1024 /* bytes */",
            "#define RF_COMPONENT_INFO_OFFSET  16384 /* bytes */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\n#define RF_COMPONENT_INFO_SIZE     1024 /* bytes */\n#define RF_COMPONENT_INFO_OFFSET  16384 /* bytes */\n\nint\nraidread_component_label(dev, b_vp, component_label)\n\tdev_t dev;\n\tstruct vnode *b_vp;\n\tRF_ComponentLabel_t *component_label;\n{\n\tstruct buf *bp;\n\tint error;\n\t\n\t/* XXX should probably ensure that we don't try to do this if\n\t   someone has changed rf_protected_sectors. */ \n\n\t/* get a block of the appropriate size... */\n\tbp = geteblk((int)RF_COMPONENT_INFO_SIZE);\n\tbp->b_dev = dev;\n\n\t/* get our ducks in a row for the read */\n\tbp->b_blkno = RF_COMPONENT_INFO_OFFSET / DEV_BSIZE;\n\tbp->b_bcount = RF_COMPONENT_INFO_SIZE;\n\tbp->b_flags = B_BUSY | B_READ;\n \tbp->b_resid = RF_COMPONENT_INFO_SIZE / DEV_BSIZE;\n\n\t(*bdevsw[major(bp->b_dev)].d_strategy)(bp);\n\n\terror = biowait(bp); \n\n\tif (!error) {\n\t\tmemcpy(component_label, bp->b_un.b_addr,\n\t\t       sizeof(RF_ComponentLabel_t));\n#if 0\n\t\tprintf(\"raidread_component_label: got component label:\\n\");\n\t\tprintf(\"Version: %d\\n\",component_label->version);\n\t\tprintf(\"Serial Number: %d\\n\",component_label->serial_number);\n\t\tprintf(\"Mod counter: %d\\n\",component_label->mod_counter);\n\t\tprintf(\"Row: %d\\n\", component_label->row);\n\t\tprintf(\"Column: %d\\n\", component_label->column);\n\t\tprintf(\"Num Rows: %d\\n\", component_label->num_rows);\n\t\tprintf(\"Num Columns: %d\\n\", component_label->num_columns);\n\t\tprintf(\"Clean: %d\\n\", component_label->clean);\n\t\tprintf(\"Status: %d\\n\", component_label->status);\n#endif\n        } else {\n\t\tprintf(\"Failed to read RAID component label!\\n\");\n\t}\n\n        bp->b_flags = B_INVAL | B_AGE;\n\tbrelse(bp); \n\treturn(error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raidmarkdirty",
          "args": [
            "raidPtr->Disks[r][c].dev",
            "raidPtr->raid_cinfo[r][c].ci_vp",
            "raidPtr->mod_counter"
          ],
          "line": 2069
        },
        "resolved": true,
        "details": {
          "function_name": "raidmarkdirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_openbsdkintf.c",
          "lines": "1945-1954",
          "snippet": "int \nraidmarkdirty(dev_t dev, struct vnode *b_vp, int mod_counter)\n{\n\tRF_ComponentLabel_t component_label;\n\traidread_component_label(dev, b_vp, &component_label);\n\tcomponent_label.mod_counter = mod_counter;\n\tcomponent_label.clean = RF_RAID_DIRTY;\n\traidwrite_component_label(dev, b_vp, &component_label);\n\treturn(0);\n}",
          "includes": [
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_dagflags.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_raidframe.h\"",
            "#include \"rf_raid.h\"",
            "#include \"raid.h\"",
            "#include <sys/user.h>",
            "#include <sys/buf.h>",
            "#include <sys/lock.h>",
            "#include <sys/conf.h>",
            "#include <sys/namei.h>",
            "#include <sys/systm.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/device.h>",
            "#include <sys/disk.h>",
            "#include <sys/queue.h>",
            "#include <sys/malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\nint \nraidmarkdirty(dev_t dev, struct vnode *b_vp, int mod_counter)\n{\n\tRF_ComponentLabel_t component_label;\n\traidread_component_label(dev, b_vp, &component_label);\n\tcomponent_label.mod_counter = mod_counter;\n\tcomponent_label.clean = RF_RAID_DIRTY;\n\traidwrite_component_label(dev, b_vp, &component_label);\n\treturn(0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\nvoid\trf_markalldirty;\n\nvoid \nrf_markalldirty( raidPtr )\n\tRF_Raid_t *raidPtr;\n{\n\tRF_ComponentLabel_t c_label;\n\tint r,c;\n\n\traidPtr->mod_counter++;\n\tfor (r = 0; r < raidPtr->numRow; r++) {\n\t\tfor (c = 0; c < raidPtr->numCol; c++) {\n\t\t\tif (raidPtr->Disks[r][c].status != rf_ds_failed) {\n\t\t\t\traidread_component_label(\n\t\t\t\t\traidPtr->Disks[r][c].dev,\n\t\t\t\t\traidPtr->raid_cinfo[r][c].ci_vp,\n\t\t\t\t\t&c_label);\n\t\t\t\tif (c_label.status == rf_ds_spared) {\n\t\t\t\t\t/* XXX do something special... \n\t\t\t\t\t but whatever you do, don't \n\t\t\t\t\t try to access it!! */\n\t\t\t\t} else {\n#if 0\n\t\t\t\tc_label.status = \n\t\t\t\t\traidPtr->Disks[r][c].status;\n\t\t\t\traidwrite_component_label( \n\t\t\t\t\traidPtr->Disks[r][c].dev,\n\t\t\t\t\traidPtr->raid_cinfo[r][c].ci_vp,\n\t\t\t\t\t&c_label);\n#endif\n\t\t\t\traidmarkdirty( \n\t\t\t\t       raidPtr->Disks[r][c].dev, \n\t\t\t\t       raidPtr->raid_cinfo[r][c].ci_vp,\n\t\t\t\t       raidPtr->mod_counter);\n\t\t\t\t}\n\t\t\t}\n\t\t} \n\t}\n\t/* printf(\"Component labels marked dirty.\\n\"); */\n#if 0\n\tfor( c = 0; c < raidPtr->numSpare ; c++) {\n\t\tsparecol = raidPtr->numCol + c;\n\t\tif (raidPtr->Disks[r][sparecol].status == rf_ds_used_spare) {\n\t\t\t/* \n\n\t\t\t   XXX this is where we get fancy and map this spare\n\t\t\t   into it's correct spot in the array.\n\n\t\t\t */\n\t\t\t/* \n\t\t\t   \n\t\t\t   we claim this disk is \"optimal\" if it's \n\t\t\t   rf_ds_used_spare, as that means it should be \n\t\t\t   directly substitutable for the disk it replaced. \n\t\t\t   We note that too...\n\n\t\t\t */\n\n\t\t\tfor(i=0;i<raidPtr->numRow;i++) {\n\t\t\t\tfor(j=0;j<raidPtr->numCol;j++) {\n\t\t\t\t\tif ((raidPtr->Disks[i][j].spareRow == \n\t\t\t\t\t     r) &&\n\t\t\t\t\t    (raidPtr->Disks[i][j].spareCol ==\n\t\t\t\t\t     sparecol)) {\n\t\t\t\t\t\tsrow = r;\n\t\t\t\t\t\tscol = sparecol;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\traidread_component_label( \n\t\t\t\t      raidPtr->Disks[r][sparecol].dev,\n\t\t\t\t      raidPtr->raid_cinfo[r][sparecol].ci_vp,\n\t\t\t\t      &c_label);\n\t\t\t/* make sure status is noted */\n\t\t\tc_label.version = RF_COMPONENT_LABEL_VERSION; \n\t\t\tc_label.mod_counter = raidPtr->mod_counter;\n\t\t\tc_label.serial_number = raidPtr->serial_number;\n\t\t\tc_label.row = srow;\n\t\t\tc_label.column = scol;\n\t\t\tc_label.num_rows = raidPtr->numRow;\n\t\t\tc_label.num_columns = raidPtr->numCol;\n\t\t\tc_label.clean = RF_RAID_DIRTY; /* changed in a bit*/\n\t\t\tc_label.status = rf_ds_optimal;\n\t\t\traidwrite_component_label(\n\t\t\t\t      raidPtr->Disks[r][sparecol].dev,\n\t\t\t\t      raidPtr->raid_cinfo[r][sparecol].ci_vp,\n\t\t\t\t      &c_label);\n\t\t\traidmarkclean( raidPtr->Disks[r][sparecol].dev, \n\t\t\t              raidPtr->raid_cinfo[r][sparecol].ci_vp);\n\t\t}\n\t}\n\n#endif\n}"
  },
  {
    "function_name": "raidwrite_component_label",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_openbsdkintf.c",
    "lines": "2007-2039",
    "snippet": "int \nraidwrite_component_label(dev, b_vp, component_label)\n\tdev_t dev; \n\tstruct vnode *b_vp;\n\tRF_ComponentLabel_t *component_label;\n{\n\tstruct buf *bp;\n\tint error;\n\n\t/* get a block of the appropriate size... */\n\tbp = geteblk((int)RF_COMPONENT_INFO_SIZE);\n\tbp->b_dev = dev;\n\n\t/* get our ducks in a row for the write */\n\tbp->b_blkno = RF_COMPONENT_INFO_OFFSET / DEV_BSIZE;\n\tbp->b_bcount = RF_COMPONENT_INFO_SIZE;\n\tbp->b_flags = B_BUSY | B_WRITE;\n \tbp->b_resid = RF_COMPONENT_INFO_SIZE / DEV_BSIZE;\n\n\tmemset( bp->b_un.b_addr, 0, RF_COMPONENT_INFO_SIZE );\n\n\tmemcpy( bp->b_un.b_addr, component_label, sizeof(RF_ComponentLabel_t));\n\n\t(*bdevsw[major(bp->b_dev)].d_strategy)(bp);\n\terror = biowait(bp); \n        bp->b_flags = B_INVAL | B_AGE;\n\tbrelse(bp);\n\tif (error) {\n\t\tprintf(\"Failed to write RAID component info!\\n\");\n\t}\n\n\treturn(error);\n}",
    "includes": [
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_kintf.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_dagflags.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_copyback.h\"",
      "#include \"rf_raidframe.h\"",
      "#include \"rf_raid.h\"",
      "#include \"raid.h\"",
      "#include <sys/user.h>",
      "#include <sys/buf.h>",
      "#include <sys/lock.h>",
      "#include <sys/conf.h>",
      "#include <sys/namei.h>",
      "#include <sys/systm.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/device.h>",
      "#include <sys/disk.h>",
      "#include <sys/queue.h>",
      "#include <sys/malloc.h>",
      "#include <sys/param.h>",
      "#include <sys/errno.h>"
    ],
    "macros_used": [
      "#define RF_COMPONENT_INFO_SIZE     1024 /* bytes */",
      "#define RF_COMPONENT_INFO_OFFSET  16384 /* bytes */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Failed to write RAID component info!\\n\""
          ],
          "line": 2035
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bp"
          ],
          "line": 2033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "biowait",
          "args": [
            "bp"
          ],
          "line": 2031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "bp"
          ],
          "line": 2030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "major",
          "args": [
            "bp->b_dev"
          ],
          "line": 2030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "bp->b_un.b_addr",
            "component_label",
            "sizeof(RF_ComponentLabel_t)"
          ],
          "line": 2028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bp->b_un.b_addr",
            "0",
            "RF_COMPONENT_INFO_SIZE"
          ],
          "line": 2026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "geteblk",
          "args": [
            "(int)RF_COMPONENT_INFO_SIZE"
          ],
          "line": 2017
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\n#define RF_COMPONENT_INFO_SIZE     1024 /* bytes */\n#define RF_COMPONENT_INFO_OFFSET  16384 /* bytes */\n\nint \nraidwrite_component_label(dev, b_vp, component_label)\n\tdev_t dev; \n\tstruct vnode *b_vp;\n\tRF_ComponentLabel_t *component_label;\n{\n\tstruct buf *bp;\n\tint error;\n\n\t/* get a block of the appropriate size... */\n\tbp = geteblk((int)RF_COMPONENT_INFO_SIZE);\n\tbp->b_dev = dev;\n\n\t/* get our ducks in a row for the write */\n\tbp->b_blkno = RF_COMPONENT_INFO_OFFSET / DEV_BSIZE;\n\tbp->b_bcount = RF_COMPONENT_INFO_SIZE;\n\tbp->b_flags = B_BUSY | B_WRITE;\n \tbp->b_resid = RF_COMPONENT_INFO_SIZE / DEV_BSIZE;\n\n\tmemset( bp->b_un.b_addr, 0, RF_COMPONENT_INFO_SIZE );\n\n\tmemcpy( bp->b_un.b_addr, component_label, sizeof(RF_ComponentLabel_t));\n\n\t(*bdevsw[major(bp->b_dev)].d_strategy)(bp);\n\terror = biowait(bp); \n        bp->b_flags = B_INVAL | B_AGE;\n\tbrelse(bp);\n\tif (error) {\n\t\tprintf(\"Failed to write RAID component info!\\n\");\n\t}\n\n\treturn(error);\n}"
  },
  {
    "function_name": "raidread_component_label",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_openbsdkintf.c",
    "lines": "1957-2005",
    "snippet": "int\nraidread_component_label(dev, b_vp, component_label)\n\tdev_t dev;\n\tstruct vnode *b_vp;\n\tRF_ComponentLabel_t *component_label;\n{\n\tstruct buf *bp;\n\tint error;\n\t\n\t/* XXX should probably ensure that we don't try to do this if\n\t   someone has changed rf_protected_sectors. */ \n\n\t/* get a block of the appropriate size... */\n\tbp = geteblk((int)RF_COMPONENT_INFO_SIZE);\n\tbp->b_dev = dev;\n\n\t/* get our ducks in a row for the read */\n\tbp->b_blkno = RF_COMPONENT_INFO_OFFSET / DEV_BSIZE;\n\tbp->b_bcount = RF_COMPONENT_INFO_SIZE;\n\tbp->b_flags = B_BUSY | B_READ;\n \tbp->b_resid = RF_COMPONENT_INFO_SIZE / DEV_BSIZE;\n\n\t(*bdevsw[major(bp->b_dev)].d_strategy)(bp);\n\n\terror = biowait(bp); \n\n\tif (!error) {\n\t\tmemcpy(component_label, bp->b_un.b_addr,\n\t\t       sizeof(RF_ComponentLabel_t));\n#if 0\n\t\tprintf(\"raidread_component_label: got component label:\\n\");\n\t\tprintf(\"Version: %d\\n\",component_label->version);\n\t\tprintf(\"Serial Number: %d\\n\",component_label->serial_number);\n\t\tprintf(\"Mod counter: %d\\n\",component_label->mod_counter);\n\t\tprintf(\"Row: %d\\n\", component_label->row);\n\t\tprintf(\"Column: %d\\n\", component_label->column);\n\t\tprintf(\"Num Rows: %d\\n\", component_label->num_rows);\n\t\tprintf(\"Num Columns: %d\\n\", component_label->num_columns);\n\t\tprintf(\"Clean: %d\\n\", component_label->clean);\n\t\tprintf(\"Status: %d\\n\", component_label->status);\n#endif\n        } else {\n\t\tprintf(\"Failed to read RAID component label!\\n\");\n\t}\n\n        bp->b_flags = B_INVAL | B_AGE;\n\tbrelse(bp); \n\treturn(error);\n}",
    "includes": [
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_kintf.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_dagflags.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_copyback.h\"",
      "#include \"rf_raidframe.h\"",
      "#include \"rf_raid.h\"",
      "#include \"raid.h\"",
      "#include <sys/user.h>",
      "#include <sys/buf.h>",
      "#include <sys/lock.h>",
      "#include <sys/conf.h>",
      "#include <sys/namei.h>",
      "#include <sys/systm.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/device.h>",
      "#include <sys/disk.h>",
      "#include <sys/queue.h>",
      "#include <sys/malloc.h>",
      "#include <sys/param.h>",
      "#include <sys/errno.h>"
    ],
    "macros_used": [
      "#define RF_COMPONENT_INFO_SIZE     1024 /* bytes */",
      "#define RF_COMPONENT_INFO_OFFSET  16384 /* bytes */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bp"
          ],
          "line": 2003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Failed to read RAID component label!\\n\""
          ],
          "line": 1999
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "component_label",
            "bp->b_un.b_addr",
            "sizeof(RF_ComponentLabel_t)"
          ],
          "line": 1984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "biowait",
          "args": [
            "bp"
          ],
          "line": 1981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "bp"
          ],
          "line": 1979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "major",
          "args": [
            "bp->b_dev"
          ],
          "line": 1979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "geteblk",
          "args": [
            "(int)RF_COMPONENT_INFO_SIZE"
          ],
          "line": 1970
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\n#define RF_COMPONENT_INFO_SIZE     1024 /* bytes */\n#define RF_COMPONENT_INFO_OFFSET  16384 /* bytes */\n\nint\nraidread_component_label(dev, b_vp, component_label)\n\tdev_t dev;\n\tstruct vnode *b_vp;\n\tRF_ComponentLabel_t *component_label;\n{\n\tstruct buf *bp;\n\tint error;\n\t\n\t/* XXX should probably ensure that we don't try to do this if\n\t   someone has changed rf_protected_sectors. */ \n\n\t/* get a block of the appropriate size... */\n\tbp = geteblk((int)RF_COMPONENT_INFO_SIZE);\n\tbp->b_dev = dev;\n\n\t/* get our ducks in a row for the read */\n\tbp->b_blkno = RF_COMPONENT_INFO_OFFSET / DEV_BSIZE;\n\tbp->b_bcount = RF_COMPONENT_INFO_SIZE;\n\tbp->b_flags = B_BUSY | B_READ;\n \tbp->b_resid = RF_COMPONENT_INFO_SIZE / DEV_BSIZE;\n\n\t(*bdevsw[major(bp->b_dev)].d_strategy)(bp);\n\n\terror = biowait(bp); \n\n\tif (!error) {\n\t\tmemcpy(component_label, bp->b_un.b_addr,\n\t\t       sizeof(RF_ComponentLabel_t));\n#if 0\n\t\tprintf(\"raidread_component_label: got component label:\\n\");\n\t\tprintf(\"Version: %d\\n\",component_label->version);\n\t\tprintf(\"Serial Number: %d\\n\",component_label->serial_number);\n\t\tprintf(\"Mod counter: %d\\n\",component_label->mod_counter);\n\t\tprintf(\"Row: %d\\n\", component_label->row);\n\t\tprintf(\"Column: %d\\n\", component_label->column);\n\t\tprintf(\"Num Rows: %d\\n\", component_label->num_rows);\n\t\tprintf(\"Num Columns: %d\\n\", component_label->num_columns);\n\t\tprintf(\"Clean: %d\\n\", component_label->clean);\n\t\tprintf(\"Status: %d\\n\", component_label->status);\n#endif\n        } else {\n\t\tprintf(\"Failed to read RAID component label!\\n\");\n\t}\n\n        bp->b_flags = B_INVAL | B_AGE;\n\tbrelse(bp); \n\treturn(error);\n}"
  },
  {
    "function_name": "raidmarkdirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_openbsdkintf.c",
    "lines": "1945-1954",
    "snippet": "int \nraidmarkdirty(dev_t dev, struct vnode *b_vp, int mod_counter)\n{\n\tRF_ComponentLabel_t component_label;\n\traidread_component_label(dev, b_vp, &component_label);\n\tcomponent_label.mod_counter = mod_counter;\n\tcomponent_label.clean = RF_RAID_DIRTY;\n\traidwrite_component_label(dev, b_vp, &component_label);\n\treturn(0);\n}",
    "includes": [
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_kintf.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_dagflags.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_copyback.h\"",
      "#include \"rf_raidframe.h\"",
      "#include \"rf_raid.h\"",
      "#include \"raid.h\"",
      "#include <sys/user.h>",
      "#include <sys/buf.h>",
      "#include <sys/lock.h>",
      "#include <sys/conf.h>",
      "#include <sys/namei.h>",
      "#include <sys/systm.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/device.h>",
      "#include <sys/disk.h>",
      "#include <sys/queue.h>",
      "#include <sys/malloc.h>",
      "#include <sys/param.h>",
      "#include <sys/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raidwrite_component_label",
          "args": [
            "dev",
            "b_vp",
            "&component_label"
          ],
          "line": 1952
        },
        "resolved": true,
        "details": {
          "function_name": "raidwrite_component_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_openbsdkintf.c",
          "lines": "2007-2039",
          "snippet": "int \nraidwrite_component_label(dev, b_vp, component_label)\n\tdev_t dev; \n\tstruct vnode *b_vp;\n\tRF_ComponentLabel_t *component_label;\n{\n\tstruct buf *bp;\n\tint error;\n\n\t/* get a block of the appropriate size... */\n\tbp = geteblk((int)RF_COMPONENT_INFO_SIZE);\n\tbp->b_dev = dev;\n\n\t/* get our ducks in a row for the write */\n\tbp->b_blkno = RF_COMPONENT_INFO_OFFSET / DEV_BSIZE;\n\tbp->b_bcount = RF_COMPONENT_INFO_SIZE;\n\tbp->b_flags = B_BUSY | B_WRITE;\n \tbp->b_resid = RF_COMPONENT_INFO_SIZE / DEV_BSIZE;\n\n\tmemset( bp->b_un.b_addr, 0, RF_COMPONENT_INFO_SIZE );\n\n\tmemcpy( bp->b_un.b_addr, component_label, sizeof(RF_ComponentLabel_t));\n\n\t(*bdevsw[major(bp->b_dev)].d_strategy)(bp);\n\terror = biowait(bp); \n        bp->b_flags = B_INVAL | B_AGE;\n\tbrelse(bp);\n\tif (error) {\n\t\tprintf(\"Failed to write RAID component info!\\n\");\n\t}\n\n\treturn(error);\n}",
          "includes": [
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_dagflags.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_raidframe.h\"",
            "#include \"rf_raid.h\"",
            "#include \"raid.h\"",
            "#include <sys/user.h>",
            "#include <sys/buf.h>",
            "#include <sys/lock.h>",
            "#include <sys/conf.h>",
            "#include <sys/namei.h>",
            "#include <sys/systm.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/device.h>",
            "#include <sys/disk.h>",
            "#include <sys/queue.h>",
            "#include <sys/malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/errno.h>"
          ],
          "macros_used": [
            "#define RF_COMPONENT_INFO_SIZE     1024 /* bytes */",
            "#define RF_COMPONENT_INFO_OFFSET  16384 /* bytes */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\n#define RF_COMPONENT_INFO_SIZE     1024 /* bytes */\n#define RF_COMPONENT_INFO_OFFSET  16384 /* bytes */\n\nint \nraidwrite_component_label(dev, b_vp, component_label)\n\tdev_t dev; \n\tstruct vnode *b_vp;\n\tRF_ComponentLabel_t *component_label;\n{\n\tstruct buf *bp;\n\tint error;\n\n\t/* get a block of the appropriate size... */\n\tbp = geteblk((int)RF_COMPONENT_INFO_SIZE);\n\tbp->b_dev = dev;\n\n\t/* get our ducks in a row for the write */\n\tbp->b_blkno = RF_COMPONENT_INFO_OFFSET / DEV_BSIZE;\n\tbp->b_bcount = RF_COMPONENT_INFO_SIZE;\n\tbp->b_flags = B_BUSY | B_WRITE;\n \tbp->b_resid = RF_COMPONENT_INFO_SIZE / DEV_BSIZE;\n\n\tmemset( bp->b_un.b_addr, 0, RF_COMPONENT_INFO_SIZE );\n\n\tmemcpy( bp->b_un.b_addr, component_label, sizeof(RF_ComponentLabel_t));\n\n\t(*bdevsw[major(bp->b_dev)].d_strategy)(bp);\n\terror = biowait(bp); \n        bp->b_flags = B_INVAL | B_AGE;\n\tbrelse(bp);\n\tif (error) {\n\t\tprintf(\"Failed to write RAID component info!\\n\");\n\t}\n\n\treturn(error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raidread_component_label",
          "args": [
            "dev",
            "b_vp",
            "&component_label"
          ],
          "line": 1949
        },
        "resolved": true,
        "details": {
          "function_name": "raidread_component_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_openbsdkintf.c",
          "lines": "1957-2005",
          "snippet": "int\nraidread_component_label(dev, b_vp, component_label)\n\tdev_t dev;\n\tstruct vnode *b_vp;\n\tRF_ComponentLabel_t *component_label;\n{\n\tstruct buf *bp;\n\tint error;\n\t\n\t/* XXX should probably ensure that we don't try to do this if\n\t   someone has changed rf_protected_sectors. */ \n\n\t/* get a block of the appropriate size... */\n\tbp = geteblk((int)RF_COMPONENT_INFO_SIZE);\n\tbp->b_dev = dev;\n\n\t/* get our ducks in a row for the read */\n\tbp->b_blkno = RF_COMPONENT_INFO_OFFSET / DEV_BSIZE;\n\tbp->b_bcount = RF_COMPONENT_INFO_SIZE;\n\tbp->b_flags = B_BUSY | B_READ;\n \tbp->b_resid = RF_COMPONENT_INFO_SIZE / DEV_BSIZE;\n\n\t(*bdevsw[major(bp->b_dev)].d_strategy)(bp);\n\n\terror = biowait(bp); \n\n\tif (!error) {\n\t\tmemcpy(component_label, bp->b_un.b_addr,\n\t\t       sizeof(RF_ComponentLabel_t));\n#if 0\n\t\tprintf(\"raidread_component_label: got component label:\\n\");\n\t\tprintf(\"Version: %d\\n\",component_label->version);\n\t\tprintf(\"Serial Number: %d\\n\",component_label->serial_number);\n\t\tprintf(\"Mod counter: %d\\n\",component_label->mod_counter);\n\t\tprintf(\"Row: %d\\n\", component_label->row);\n\t\tprintf(\"Column: %d\\n\", component_label->column);\n\t\tprintf(\"Num Rows: %d\\n\", component_label->num_rows);\n\t\tprintf(\"Num Columns: %d\\n\", component_label->num_columns);\n\t\tprintf(\"Clean: %d\\n\", component_label->clean);\n\t\tprintf(\"Status: %d\\n\", component_label->status);\n#endif\n        } else {\n\t\tprintf(\"Failed to read RAID component label!\\n\");\n\t}\n\n        bp->b_flags = B_INVAL | B_AGE;\n\tbrelse(bp); \n\treturn(error);\n}",
          "includes": [
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_dagflags.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_raidframe.h\"",
            "#include \"rf_raid.h\"",
            "#include \"raid.h\"",
            "#include <sys/user.h>",
            "#include <sys/buf.h>",
            "#include <sys/lock.h>",
            "#include <sys/conf.h>",
            "#include <sys/namei.h>",
            "#include <sys/systm.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/device.h>",
            "#include <sys/disk.h>",
            "#include <sys/queue.h>",
            "#include <sys/malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/errno.h>"
          ],
          "macros_used": [
            "#define RF_COMPONENT_INFO_SIZE     1024 /* bytes */",
            "#define RF_COMPONENT_INFO_OFFSET  16384 /* bytes */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\n#define RF_COMPONENT_INFO_SIZE     1024 /* bytes */\n#define RF_COMPONENT_INFO_OFFSET  16384 /* bytes */\n\nint\nraidread_component_label(dev, b_vp, component_label)\n\tdev_t dev;\n\tstruct vnode *b_vp;\n\tRF_ComponentLabel_t *component_label;\n{\n\tstruct buf *bp;\n\tint error;\n\t\n\t/* XXX should probably ensure that we don't try to do this if\n\t   someone has changed rf_protected_sectors. */ \n\n\t/* get a block of the appropriate size... */\n\tbp = geteblk((int)RF_COMPONENT_INFO_SIZE);\n\tbp->b_dev = dev;\n\n\t/* get our ducks in a row for the read */\n\tbp->b_blkno = RF_COMPONENT_INFO_OFFSET / DEV_BSIZE;\n\tbp->b_bcount = RF_COMPONENT_INFO_SIZE;\n\tbp->b_flags = B_BUSY | B_READ;\n \tbp->b_resid = RF_COMPONENT_INFO_SIZE / DEV_BSIZE;\n\n\t(*bdevsw[major(bp->b_dev)].d_strategy)(bp);\n\n\terror = biowait(bp); \n\n\tif (!error) {\n\t\tmemcpy(component_label, bp->b_un.b_addr,\n\t\t       sizeof(RF_ComponentLabel_t));\n#if 0\n\t\tprintf(\"raidread_component_label: got component label:\\n\");\n\t\tprintf(\"Version: %d\\n\",component_label->version);\n\t\tprintf(\"Serial Number: %d\\n\",component_label->serial_number);\n\t\tprintf(\"Mod counter: %d\\n\",component_label->mod_counter);\n\t\tprintf(\"Row: %d\\n\", component_label->row);\n\t\tprintf(\"Column: %d\\n\", component_label->column);\n\t\tprintf(\"Num Rows: %d\\n\", component_label->num_rows);\n\t\tprintf(\"Num Columns: %d\\n\", component_label->num_columns);\n\t\tprintf(\"Clean: %d\\n\", component_label->clean);\n\t\tprintf(\"Status: %d\\n\", component_label->status);\n#endif\n        } else {\n\t\tprintf(\"Failed to read RAID component label!\\n\");\n\t}\n\n        bp->b_flags = B_INVAL | B_AGE;\n\tbrelse(bp); \n\treturn(error);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\nint \nraidmarkdirty(dev_t dev, struct vnode *b_vp, int mod_counter)\n{\n\tRF_ComponentLabel_t component_label;\n\traidread_component_label(dev, b_vp, &component_label);\n\tcomponent_label.mod_counter = mod_counter;\n\tcomponent_label.clean = RF_RAID_DIRTY;\n\traidwrite_component_label(dev, b_vp, &component_label);\n\treturn(0);\n}"
  },
  {
    "function_name": "raidmarkclean",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_openbsdkintf.c",
    "lines": "1933-1942",
    "snippet": "int \nraidmarkclean(dev_t dev, struct vnode *b_vp, int mod_counter)\n{\n\tRF_ComponentLabel_t component_label;\n\traidread_component_label(dev, b_vp, &component_label);\n\tcomponent_label.mod_counter = mod_counter;\n\tcomponent_label.clean = RF_RAID_CLEAN;\n\traidwrite_component_label(dev, b_vp, &component_label);\n\treturn(0);\n}",
    "includes": [
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_kintf.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_dagflags.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_copyback.h\"",
      "#include \"rf_raidframe.h\"",
      "#include \"rf_raid.h\"",
      "#include \"raid.h\"",
      "#include <sys/user.h>",
      "#include <sys/buf.h>",
      "#include <sys/lock.h>",
      "#include <sys/conf.h>",
      "#include <sys/namei.h>",
      "#include <sys/systm.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/device.h>",
      "#include <sys/disk.h>",
      "#include <sys/queue.h>",
      "#include <sys/malloc.h>",
      "#include <sys/param.h>",
      "#include <sys/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raidwrite_component_label",
          "args": [
            "dev",
            "b_vp",
            "&component_label"
          ],
          "line": 1940
        },
        "resolved": true,
        "details": {
          "function_name": "raidwrite_component_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_openbsdkintf.c",
          "lines": "2007-2039",
          "snippet": "int \nraidwrite_component_label(dev, b_vp, component_label)\n\tdev_t dev; \n\tstruct vnode *b_vp;\n\tRF_ComponentLabel_t *component_label;\n{\n\tstruct buf *bp;\n\tint error;\n\n\t/* get a block of the appropriate size... */\n\tbp = geteblk((int)RF_COMPONENT_INFO_SIZE);\n\tbp->b_dev = dev;\n\n\t/* get our ducks in a row for the write */\n\tbp->b_blkno = RF_COMPONENT_INFO_OFFSET / DEV_BSIZE;\n\tbp->b_bcount = RF_COMPONENT_INFO_SIZE;\n\tbp->b_flags = B_BUSY | B_WRITE;\n \tbp->b_resid = RF_COMPONENT_INFO_SIZE / DEV_BSIZE;\n\n\tmemset( bp->b_un.b_addr, 0, RF_COMPONENT_INFO_SIZE );\n\n\tmemcpy( bp->b_un.b_addr, component_label, sizeof(RF_ComponentLabel_t));\n\n\t(*bdevsw[major(bp->b_dev)].d_strategy)(bp);\n\terror = biowait(bp); \n        bp->b_flags = B_INVAL | B_AGE;\n\tbrelse(bp);\n\tif (error) {\n\t\tprintf(\"Failed to write RAID component info!\\n\");\n\t}\n\n\treturn(error);\n}",
          "includes": [
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_dagflags.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_raidframe.h\"",
            "#include \"rf_raid.h\"",
            "#include \"raid.h\"",
            "#include <sys/user.h>",
            "#include <sys/buf.h>",
            "#include <sys/lock.h>",
            "#include <sys/conf.h>",
            "#include <sys/namei.h>",
            "#include <sys/systm.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/device.h>",
            "#include <sys/disk.h>",
            "#include <sys/queue.h>",
            "#include <sys/malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/errno.h>"
          ],
          "macros_used": [
            "#define RF_COMPONENT_INFO_SIZE     1024 /* bytes */",
            "#define RF_COMPONENT_INFO_OFFSET  16384 /* bytes */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\n#define RF_COMPONENT_INFO_SIZE     1024 /* bytes */\n#define RF_COMPONENT_INFO_OFFSET  16384 /* bytes */\n\nint \nraidwrite_component_label(dev, b_vp, component_label)\n\tdev_t dev; \n\tstruct vnode *b_vp;\n\tRF_ComponentLabel_t *component_label;\n{\n\tstruct buf *bp;\n\tint error;\n\n\t/* get a block of the appropriate size... */\n\tbp = geteblk((int)RF_COMPONENT_INFO_SIZE);\n\tbp->b_dev = dev;\n\n\t/* get our ducks in a row for the write */\n\tbp->b_blkno = RF_COMPONENT_INFO_OFFSET / DEV_BSIZE;\n\tbp->b_bcount = RF_COMPONENT_INFO_SIZE;\n\tbp->b_flags = B_BUSY | B_WRITE;\n \tbp->b_resid = RF_COMPONENT_INFO_SIZE / DEV_BSIZE;\n\n\tmemset( bp->b_un.b_addr, 0, RF_COMPONENT_INFO_SIZE );\n\n\tmemcpy( bp->b_un.b_addr, component_label, sizeof(RF_ComponentLabel_t));\n\n\t(*bdevsw[major(bp->b_dev)].d_strategy)(bp);\n\terror = biowait(bp); \n        bp->b_flags = B_INVAL | B_AGE;\n\tbrelse(bp);\n\tif (error) {\n\t\tprintf(\"Failed to write RAID component info!\\n\");\n\t}\n\n\treturn(error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raidread_component_label",
          "args": [
            "dev",
            "b_vp",
            "&component_label"
          ],
          "line": 1937
        },
        "resolved": true,
        "details": {
          "function_name": "raidread_component_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_openbsdkintf.c",
          "lines": "1957-2005",
          "snippet": "int\nraidread_component_label(dev, b_vp, component_label)\n\tdev_t dev;\n\tstruct vnode *b_vp;\n\tRF_ComponentLabel_t *component_label;\n{\n\tstruct buf *bp;\n\tint error;\n\t\n\t/* XXX should probably ensure that we don't try to do this if\n\t   someone has changed rf_protected_sectors. */ \n\n\t/* get a block of the appropriate size... */\n\tbp = geteblk((int)RF_COMPONENT_INFO_SIZE);\n\tbp->b_dev = dev;\n\n\t/* get our ducks in a row for the read */\n\tbp->b_blkno = RF_COMPONENT_INFO_OFFSET / DEV_BSIZE;\n\tbp->b_bcount = RF_COMPONENT_INFO_SIZE;\n\tbp->b_flags = B_BUSY | B_READ;\n \tbp->b_resid = RF_COMPONENT_INFO_SIZE / DEV_BSIZE;\n\n\t(*bdevsw[major(bp->b_dev)].d_strategy)(bp);\n\n\terror = biowait(bp); \n\n\tif (!error) {\n\t\tmemcpy(component_label, bp->b_un.b_addr,\n\t\t       sizeof(RF_ComponentLabel_t));\n#if 0\n\t\tprintf(\"raidread_component_label: got component label:\\n\");\n\t\tprintf(\"Version: %d\\n\",component_label->version);\n\t\tprintf(\"Serial Number: %d\\n\",component_label->serial_number);\n\t\tprintf(\"Mod counter: %d\\n\",component_label->mod_counter);\n\t\tprintf(\"Row: %d\\n\", component_label->row);\n\t\tprintf(\"Column: %d\\n\", component_label->column);\n\t\tprintf(\"Num Rows: %d\\n\", component_label->num_rows);\n\t\tprintf(\"Num Columns: %d\\n\", component_label->num_columns);\n\t\tprintf(\"Clean: %d\\n\", component_label->clean);\n\t\tprintf(\"Status: %d\\n\", component_label->status);\n#endif\n        } else {\n\t\tprintf(\"Failed to read RAID component label!\\n\");\n\t}\n\n        bp->b_flags = B_INVAL | B_AGE;\n\tbrelse(bp); \n\treturn(error);\n}",
          "includes": [
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_dagflags.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_raidframe.h\"",
            "#include \"rf_raid.h\"",
            "#include \"raid.h\"",
            "#include <sys/user.h>",
            "#include <sys/buf.h>",
            "#include <sys/lock.h>",
            "#include <sys/conf.h>",
            "#include <sys/namei.h>",
            "#include <sys/systm.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/device.h>",
            "#include <sys/disk.h>",
            "#include <sys/queue.h>",
            "#include <sys/malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/errno.h>"
          ],
          "macros_used": [
            "#define RF_COMPONENT_INFO_SIZE     1024 /* bytes */",
            "#define RF_COMPONENT_INFO_OFFSET  16384 /* bytes */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\n#define RF_COMPONENT_INFO_SIZE     1024 /* bytes */\n#define RF_COMPONENT_INFO_OFFSET  16384 /* bytes */\n\nint\nraidread_component_label(dev, b_vp, component_label)\n\tdev_t dev;\n\tstruct vnode *b_vp;\n\tRF_ComponentLabel_t *component_label;\n{\n\tstruct buf *bp;\n\tint error;\n\t\n\t/* XXX should probably ensure that we don't try to do this if\n\t   someone has changed rf_protected_sectors. */ \n\n\t/* get a block of the appropriate size... */\n\tbp = geteblk((int)RF_COMPONENT_INFO_SIZE);\n\tbp->b_dev = dev;\n\n\t/* get our ducks in a row for the read */\n\tbp->b_blkno = RF_COMPONENT_INFO_OFFSET / DEV_BSIZE;\n\tbp->b_bcount = RF_COMPONENT_INFO_SIZE;\n\tbp->b_flags = B_BUSY | B_READ;\n \tbp->b_resid = RF_COMPONENT_INFO_SIZE / DEV_BSIZE;\n\n\t(*bdevsw[major(bp->b_dev)].d_strategy)(bp);\n\n\terror = biowait(bp); \n\n\tif (!error) {\n\t\tmemcpy(component_label, bp->b_un.b_addr,\n\t\t       sizeof(RF_ComponentLabel_t));\n#if 0\n\t\tprintf(\"raidread_component_label: got component label:\\n\");\n\t\tprintf(\"Version: %d\\n\",component_label->version);\n\t\tprintf(\"Serial Number: %d\\n\",component_label->serial_number);\n\t\tprintf(\"Mod counter: %d\\n\",component_label->mod_counter);\n\t\tprintf(\"Row: %d\\n\", component_label->row);\n\t\tprintf(\"Column: %d\\n\", component_label->column);\n\t\tprintf(\"Num Rows: %d\\n\", component_label->num_rows);\n\t\tprintf(\"Num Columns: %d\\n\", component_label->num_columns);\n\t\tprintf(\"Clean: %d\\n\", component_label->clean);\n\t\tprintf(\"Status: %d\\n\", component_label->status);\n#endif\n        } else {\n\t\tprintf(\"Failed to read RAID component label!\\n\");\n\t}\n\n        bp->b_flags = B_INVAL | B_AGE;\n\tbrelse(bp); \n\treturn(error);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\nint \nraidmarkclean(dev_t dev, struct vnode *b_vp, int mod_counter)\n{\n\tRF_ComponentLabel_t component_label;\n\traidread_component_label(dev, b_vp, &component_label);\n\tcomponent_label.mod_counter = mod_counter;\n\tcomponent_label.clean = RF_RAID_CLEAN;\n\traidwrite_component_label(dev, b_vp, &component_label);\n\treturn(0);\n}"
  },
  {
    "function_name": "raidunlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_openbsdkintf.c",
    "lines": "1918-1927",
    "snippet": "void\nraidunlock(rs)\n\tstruct raid_softc *rs;\n{\n\trs->sc_flags &= ~RAIDF_LOCKED;\n\tif ((rs->sc_flags & RAIDF_WANTED) != 0) {\n\t\trs->sc_flags &= ~RAIDF_WANTED;\n\t\twakeup(rs);\n\t}\n}",
    "includes": [
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_kintf.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_dagflags.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_copyback.h\"",
      "#include \"rf_raidframe.h\"",
      "#include \"rf_raid.h\"",
      "#include \"raid.h\"",
      "#include <sys/user.h>",
      "#include <sys/buf.h>",
      "#include <sys/lock.h>",
      "#include <sys/conf.h>",
      "#include <sys/namei.h>",
      "#include <sys/systm.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/device.h>",
      "#include <sys/disk.h>",
      "#include <sys/queue.h>",
      "#include <sys/malloc.h>",
      "#include <sys/param.h>",
      "#include <sys/errno.h>"
    ],
    "macros_used": [
      "#define RAIDF_LOCKED\t0x80\t/* unit is locked */",
      "#define RAIDF_WANTED\t0x40\t/* someone is waiting to obtain a lock */"
    ],
    "globals_used": [
      "struct raid_softc *raid_softc;",
      "void\traidunlock"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "rs"
          ],
          "line": 1925
        },
        "resolved": true,
        "details": {
          "function_name": "audio_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "765-774",
          "snippet": "static __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nstatic __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\n#define RAIDF_LOCKED\t0x80\t/* unit is locked */\n#define RAIDF_WANTED\t0x40\t/* someone is waiting to obtain a lock */\n\nstruct raid_softc *raid_softc;\nvoid\traidunlock;\n\nvoid\nraidunlock(rs)\n\tstruct raid_softc *rs;\n{\n\trs->sc_flags &= ~RAIDF_LOCKED;\n\tif ((rs->sc_flags & RAIDF_WANTED) != 0) {\n\t\trs->sc_flags &= ~RAIDF_WANTED;\n\t\twakeup(rs);\n\t}\n}"
  },
  {
    "function_name": "raidlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_openbsdkintf.c",
    "lines": "1900-1913",
    "snippet": "int\nraidlock(rs)\n\tstruct raid_softc *rs;\n{\n\tint error;\n\n\twhile ((rs->sc_flags & RAIDF_LOCKED) != 0) {\n\t\trs->sc_flags |= RAIDF_WANTED;\n\t\tif ((error = tsleep(rs, PRIBIO | PCATCH, \"raidlck\", 0)) != 0)\n\t\t\treturn (error);\n\t}\n\trs->sc_flags |= RAIDF_LOCKED;\n\treturn (0);\n}",
    "includes": [
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_kintf.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_dagflags.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_copyback.h\"",
      "#include \"rf_raidframe.h\"",
      "#include \"rf_raid.h\"",
      "#include \"raid.h\"",
      "#include <sys/user.h>",
      "#include <sys/buf.h>",
      "#include <sys/lock.h>",
      "#include <sys/conf.h>",
      "#include <sys/namei.h>",
      "#include <sys/systm.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/device.h>",
      "#include <sys/disk.h>",
      "#include <sys/queue.h>",
      "#include <sys/malloc.h>",
      "#include <sys/param.h>",
      "#include <sys/errno.h>"
    ],
    "macros_used": [
      "#define RAIDF_LOCKED\t0x80\t/* unit is locked */",
      "#define RAIDF_WANTED\t0x40\t/* someone is waiting to obtain a lock */"
    ],
    "globals_used": [
      "struct raid_softc *raid_softc;",
      "int\traidlock"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tsleep",
          "args": [
            "rs",
            "PRIBIO | PCATCH",
            "\"raidlck\"",
            "0"
          ],
          "line": 1908
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\n#define RAIDF_LOCKED\t0x80\t/* unit is locked */\n#define RAIDF_WANTED\t0x40\t/* someone is waiting to obtain a lock */\n\nstruct raid_softc *raid_softc;\nint\traidlock;\n\nint\nraidlock(rs)\n\tstruct raid_softc *rs;\n{\n\tint error;\n\n\twhile ((rs->sc_flags & RAIDF_LOCKED) != 0) {\n\t\trs->sc_flags |= RAIDF_WANTED;\n\t\tif ((error = tsleep(rs, PRIBIO | PCATCH, \"raidlck\", 0)) != 0)\n\t\t\treturn (error);\n\t}\n\trs->sc_flags |= RAIDF_LOCKED;\n\treturn (0);\n}"
  },
  {
    "function_name": "raidlookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_openbsdkintf.c",
    "lines": "1853-1891",
    "snippet": "int\nraidlookup(path, p, vpp)\n\tchar *path;\n\tstruct proc *p;\n\tstruct vnode **vpp;\t/* result */\n{\n\tstruct nameidata nd;\n\tstruct vnode *vp;\n\tstruct vattr va;\n\tint error;\n\n\tNDINIT(&nd, LOOKUP, FOLLOW, UIO_SYSSPACE, path, p);\n\tif ((error = vn_open(&nd, FREAD|FWRITE, 0)) != 0) {\n#ifdef DEBUG\n\t\tprintf(\"RAIDframe: vn_open returned %d\\n\", error);\n#endif\n\t\treturn (error);\n\t}\n\tvp = nd.ni_vp;\n\tif (vp->v_usecount > 1) {\n\t\tVOP_UNLOCK(vp, 0, p);\n\t\t(void)vn_close(vp, FREAD|FWRITE, p->p_ucred, p);\n\t\treturn (EBUSY);\n\t}\n\tif ((error = VOP_GETATTR(vp, &va, p->p_ucred, p)) != 0) {\n\t\tVOP_UNLOCK(vp, 0, p);\n\t\t(void)vn_close(vp, FREAD|FWRITE, p->p_ucred, p);\n\t\treturn (error);\n\t}\n\t/* XXX: eventually we should handle VREG, too. */\n\tif (va.va_type != VBLK) {\n\t\tVOP_UNLOCK(vp, 0, p);\n\t\t(void)vn_close(vp, FREAD|FWRITE, p->p_ucred, p);\n\t\treturn (ENOTBLK);\n\t}\n\tVOP_UNLOCK(vp, 0, p);\n\t*vpp = vp;\n\treturn (0);\n}",
    "includes": [
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_kintf.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_dagflags.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_copyback.h\"",
      "#include \"rf_raidframe.h\"",
      "#include \"rf_raid.h\"",
      "#include \"raid.h\"",
      "#include <sys/user.h>",
      "#include <sys/buf.h>",
      "#include <sys/lock.h>",
      "#include <sys/conf.h>",
      "#include <sys/namei.h>",
      "#include <sys/systm.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/device.h>",
      "#include <sys/disk.h>",
      "#include <sys/queue.h>",
      "#include <sys/malloc.h>",
      "#include <sys/param.h>",
      "#include <sys/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VOP_UNLOCK",
          "args": [
            "vp",
            "0",
            "p"
          ],
          "line": 1888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vn_close",
          "args": [
            "vp",
            "FREAD|FWRITE",
            "p->p_ucred",
            "p"
          ],
          "line": 1885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VOP_UNLOCK",
          "args": [
            "vp",
            "0",
            "p"
          ],
          "line": 1884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vn_close",
          "args": [
            "vp",
            "FREAD|FWRITE",
            "p->p_ucred",
            "p"
          ],
          "line": 1879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VOP_UNLOCK",
          "args": [
            "vp",
            "0",
            "p"
          ],
          "line": 1878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VOP_GETATTR",
          "args": [
            "vp",
            "&va",
            "p->p_ucred",
            "p"
          ],
          "line": 1877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vn_close",
          "args": [
            "vp",
            "FREAD|FWRITE",
            "p->p_ucred",
            "p"
          ],
          "line": 1874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VOP_UNLOCK",
          "args": [
            "vp",
            "0",
            "p"
          ],
          "line": 1873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"RAIDframe: vn_open returned %d\\n\"",
            "error"
          ],
          "line": 1867
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "vn_open",
          "args": [
            "&nd",
            "FREAD|FWRITE",
            "0"
          ],
          "line": 1865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NDINIT",
          "args": [
            "&nd",
            "LOOKUP",
            "FOLLOW",
            "UIO_SYSSPACE",
            "path",
            "p"
          ],
          "line": 1864
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\nint\nraidlookup(path, p, vpp)\n\tchar *path;\n\tstruct proc *p;\n\tstruct vnode **vpp;\t/* result */\n{\n\tstruct nameidata nd;\n\tstruct vnode *vp;\n\tstruct vattr va;\n\tint error;\n\n\tNDINIT(&nd, LOOKUP, FOLLOW, UIO_SYSSPACE, path, p);\n\tif ((error = vn_open(&nd, FREAD|FWRITE, 0)) != 0) {\n#ifdef DEBUG\n\t\tprintf(\"RAIDframe: vn_open returned %d\\n\", error);\n#endif\n\t\treturn (error);\n\t}\n\tvp = nd.ni_vp;\n\tif (vp->v_usecount > 1) {\n\t\tVOP_UNLOCK(vp, 0, p);\n\t\t(void)vn_close(vp, FREAD|FWRITE, p->p_ucred, p);\n\t\treturn (EBUSY);\n\t}\n\tif ((error = VOP_GETATTR(vp, &va, p->p_ucred, p)) != 0) {\n\t\tVOP_UNLOCK(vp, 0, p);\n\t\t(void)vn_close(vp, FREAD|FWRITE, p->p_ucred, p);\n\t\treturn (error);\n\t}\n\t/* XXX: eventually we should handle VREG, too. */\n\tif (va.va_type != VBLK) {\n\t\tVOP_UNLOCK(vp, 0, p);\n\t\t(void)vn_close(vp, FREAD|FWRITE, p->p_ucred, p);\n\t\treturn (ENOTBLK);\n\t}\n\tVOP_UNLOCK(vp, 0, p);\n\t*vpp = vp;\n\treturn (0);\n}"
  },
  {
    "function_name": "raidmakedisklabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_openbsdkintf.c",
    "lines": "1828-1845",
    "snippet": "void\nraidmakedisklabel(rs)\n\tstruct raid_softc *rs;\n{\n\tstruct disklabel *lp = rs->sc_dkdev.dk_label;\n\tdb1_printf((\"Making a label..\\n\"));\n\n\t/*\n\t * For historical reasons, if there's no disklabel present\n\t * the raw partition must be marked FS_BSDFFS.\n\t */\n\n\tlp->d_partitions[RAW_PART].p_fstype = FS_BSDFFS;\n\n\tstrncpy(lp->d_packname, \"default label\", sizeof(lp->d_packname));\n\n\tlp->d_checksum = dkcksum(lp);\n}",
    "includes": [
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_kintf.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_dagflags.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_copyback.h\"",
      "#include \"rf_raidframe.h\"",
      "#include \"rf_raid.h\"",
      "#include \"raid.h\"",
      "#include <sys/user.h>",
      "#include <sys/buf.h>",
      "#include <sys/lock.h>",
      "#include <sys/conf.h>",
      "#include <sys/namei.h>",
      "#include <sys/systm.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/device.h>",
      "#include <sys/disk.h>",
      "#include <sys/queue.h>",
      "#include <sys/malloc.h>",
      "#include <sys/param.h>",
      "#include <sys/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct raid_softc *raid_softc;",
      "void\traidmakedisklabel"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dkcksum",
          "args": [
            "lp"
          ],
          "line": 1844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "lp->d_packname",
            "\"default label\"",
            "sizeof(lp->d_packname)"
          ],
          "line": 1842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db1_printf",
          "args": [
            "(\"Making a label..\\n\")"
          ],
          "line": 1833
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\nstruct raid_softc *raid_softc;\nvoid\traidmakedisklabel;\n\nvoid\nraidmakedisklabel(rs)\n\tstruct raid_softc *rs;\n{\n\tstruct disklabel *lp = rs->sc_dkdev.dk_label;\n\tdb1_printf((\"Making a label..\\n\"));\n\n\t/*\n\t * For historical reasons, if there's no disklabel present\n\t * the raw partition must be marked FS_BSDFFS.\n\t */\n\n\tlp->d_partitions[RAW_PART].p_fstype = FS_BSDFFS;\n\n\tstrncpy(lp->d_packname, \"default label\", sizeof(lp->d_packname));\n\n\tlp->d_checksum = dkcksum(lp);\n}"
  },
  {
    "function_name": "raidgetdisklabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_openbsdkintf.c",
    "lines": "1771-1822",
    "snippet": "void\nraidgetdisklabel(dev)\n\tdev_t dev;\n{\n\tint unit = raidunit(dev);\n\tstruct raid_softc *rs = &raid_softc[unit];\n\tchar *errstring;\n\tstruct disklabel *lp = rs->sc_dkdev.dk_label;\n\tstruct cpu_disklabel *clp = rs->sc_dkdev.dk_cpulabel;\n\tRF_Raid_t *raidPtr;\n\n\tdb1_printf((\"Getting the disklabel...\\n\"));\n\n\tbzero(clp, sizeof(*clp));\n\n\traidPtr = raidPtrs[unit];\n\n\traidgetdefaultlabel(raidPtr, rs, lp);\n\n\t/*\n\t * Call the generic disklabel extraction routine.\n\t */\n\terrstring = readdisklabel(RAIDLABELDEV(dev), raidstrategy,\n\t    rs->sc_dkdev.dk_label, rs->sc_dkdev.dk_cpulabel, 0);\n\tif (errstring)\n\t\traidmakedisklabel(rs);\n\telse {\n\t\tint i;\n\t\tstruct partition *pp;\n\n\t\t/*\n\t\t * Sanity check whether the found disklabel is valid.\n\t\t *\n\t\t * This is necessary since total size of the raid device\n\t\t * may vary when an interleave is changed even though exactly\n\t\t * same componets are used, and old disklabel may used\n\t\t * if that is found.\n\t\t */\n\t\tif (lp->d_secperunit != rs->sc_size)\n\t\t\tprintf(\"WARNING: %s: \"\n\t\t\t    \"total sector size in disklabel (%d) != \"\n\t\t\t    \"the size of raid (%ld)\\n\", rs->sc_xname,\n\t\t\t    lp->d_secperunit, (long) rs->sc_size);\n\t\tfor (i = 0; i < lp->d_npartitions; i++) {\n\t\t\tpp = &lp->d_partitions[i];\n\t\t\tif (pp->p_offset + pp->p_size > rs->sc_size)\n\t\t\t\tprintf(\"WARNING: %s: end of partition `%c' \"\n\t\t\t\t    \"exceeds the size of raid (%ld)\\n\",\n\t\t\t\t    rs->sc_xname, 'a' + i, (long) rs->sc_size);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_kintf.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_dagflags.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_copyback.h\"",
      "#include \"rf_raidframe.h\"",
      "#include \"rf_raid.h\"",
      "#include \"raid.h\"",
      "#include <sys/user.h>",
      "#include <sys/buf.h>",
      "#include <sys/lock.h>",
      "#include <sys/conf.h>",
      "#include <sys/namei.h>",
      "#include <sys/systm.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/device.h>",
      "#include <sys/disk.h>",
      "#include <sys/queue.h>",
      "#include <sys/malloc.h>",
      "#include <sys/param.h>",
      "#include <sys/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static RF_Raid_t **raidPtrs;",
      "void\traidstrategy",
      "struct raid_softc *raid_softc;",
      "void\traidgetdefaultlabel",
      "void\traidgetdisklabel",
      "void\traidmakedisklabel"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"WARNING: %s: end of partition `%c' \"\n\t\t\t\t    \"exceeds the size of raid (%ld)\\n\"",
            "rs->sc_xname",
            "'a' + i",
            "(long) rs->sc_size"
          ],
          "line": 1817
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "raidmakedisklabel",
          "args": [
            "rs"
          ],
          "line": 1796
        },
        "resolved": true,
        "details": {
          "function_name": "raidmakedisklabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_openbsdkintf.c",
          "lines": "1828-1845",
          "snippet": "void\nraidmakedisklabel(rs)\n\tstruct raid_softc *rs;\n{\n\tstruct disklabel *lp = rs->sc_dkdev.dk_label;\n\tdb1_printf((\"Making a label..\\n\"));\n\n\t/*\n\t * For historical reasons, if there's no disklabel present\n\t * the raw partition must be marked FS_BSDFFS.\n\t */\n\n\tlp->d_partitions[RAW_PART].p_fstype = FS_BSDFFS;\n\n\tstrncpy(lp->d_packname, \"default label\", sizeof(lp->d_packname));\n\n\tlp->d_checksum = dkcksum(lp);\n}",
          "includes": [
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_dagflags.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_raidframe.h\"",
            "#include \"rf_raid.h\"",
            "#include \"raid.h\"",
            "#include <sys/user.h>",
            "#include <sys/buf.h>",
            "#include <sys/lock.h>",
            "#include <sys/conf.h>",
            "#include <sys/namei.h>",
            "#include <sys/systm.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/device.h>",
            "#include <sys/disk.h>",
            "#include <sys/queue.h>",
            "#include <sys/malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct raid_softc *raid_softc;",
            "void\traidmakedisklabel"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\nstruct raid_softc *raid_softc;\nvoid\traidmakedisklabel;\n\nvoid\nraidmakedisklabel(rs)\n\tstruct raid_softc *rs;\n{\n\tstruct disklabel *lp = rs->sc_dkdev.dk_label;\n\tdb1_printf((\"Making a label..\\n\"));\n\n\t/*\n\t * For historical reasons, if there's no disklabel present\n\t * the raw partition must be marked FS_BSDFFS.\n\t */\n\n\tlp->d_partitions[RAW_PART].p_fstype = FS_BSDFFS;\n\n\tstrncpy(lp->d_packname, \"default label\", sizeof(lp->d_packname));\n\n\tlp->d_checksum = dkcksum(lp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "readdisklabel",
          "args": [
            "RAIDLABELDEV(dev)",
            "raidstrategy",
            "rs->sc_dkdev.dk_label",
            "rs->sc_dkdev.dk_cpulabel",
            "0"
          ],
          "line": 1793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAIDLABELDEV",
          "args": [
            "dev"
          ],
          "line": 1793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raidgetdefaultlabel",
          "args": [
            "raidPtr",
            "rs",
            "lp"
          ],
          "line": 1788
        },
        "resolved": true,
        "details": {
          "function_name": "raidgetdefaultlabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_openbsdkintf.c",
          "lines": "1731-1765",
          "snippet": "void\nraidgetdefaultlabel(raidPtr, rs, lp)\n\tRF_Raid_t *raidPtr;\n\tstruct raid_softc *rs;\n\tstruct disklabel *lp;\n{\n\tdb1_printf((\"Building a default label...\\n\"));\n\tbzero(lp, sizeof(*lp));\n\n\t/* fabricate a label... */\n\tlp->d_secperunit = raidPtr->totalSectors;\n\tlp->d_secsize = raidPtr->bytesPerSector;\n\tlp->d_nsectors = raidPtr->Layout.dataSectorsPerStripe;\n\tlp->d_ntracks = 1;\n\tlp->d_ncylinders = raidPtr->totalSectors / \n\t\t(lp->d_nsectors * lp->d_ntracks);\n\tlp->d_secpercyl = lp->d_ntracks * lp->d_nsectors;\n\n\tstrncpy(lp->d_typename, \"raid\", sizeof(lp->d_typename));\n\tlp->d_type = DTYPE_RAID;\n\tstrncpy(lp->d_packname, \"fictitious\", sizeof(lp->d_packname));\n\tlp->d_rpm = 3600;\n\tlp->d_interleave = 1;\n\tlp->d_flags = 0;\n\n\tlp->d_partitions[RAW_PART].p_offset = 0;\n\tlp->d_partitions[RAW_PART].p_size = raidPtr->totalSectors;\n\tlp->d_partitions[RAW_PART].p_fstype = FS_UNUSED;\n\tlp->d_npartitions = RAW_PART + 1;\n\n\tlp->d_magic = DISKMAGIC;\n\tlp->d_magic2 = DISKMAGIC;\n\tlp->d_checksum = dkcksum(rs->sc_dkdev.dk_label);\n\n}",
          "includes": [
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_dagflags.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_raidframe.h\"",
            "#include \"rf_raid.h\"",
            "#include \"raid.h\"",
            "#include <sys/user.h>",
            "#include <sys/buf.h>",
            "#include <sys/lock.h>",
            "#include <sys/conf.h>",
            "#include <sys/namei.h>",
            "#include <sys/systm.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/device.h>",
            "#include <sys/disk.h>",
            "#include <sys/queue.h>",
            "#include <sys/malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct raid_softc *raid_softc;",
            "void\traidgetdefaultlabel"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\nstruct raid_softc *raid_softc;\nvoid\traidgetdefaultlabel;\n\nvoid\nraidgetdefaultlabel(raidPtr, rs, lp)\n\tRF_Raid_t *raidPtr;\n\tstruct raid_softc *rs;\n\tstruct disklabel *lp;\n{\n\tdb1_printf((\"Building a default label...\\n\"));\n\tbzero(lp, sizeof(*lp));\n\n\t/* fabricate a label... */\n\tlp->d_secperunit = raidPtr->totalSectors;\n\tlp->d_secsize = raidPtr->bytesPerSector;\n\tlp->d_nsectors = raidPtr->Layout.dataSectorsPerStripe;\n\tlp->d_ntracks = 1;\n\tlp->d_ncylinders = raidPtr->totalSectors / \n\t\t(lp->d_nsectors * lp->d_ntracks);\n\tlp->d_secpercyl = lp->d_ntracks * lp->d_nsectors;\n\n\tstrncpy(lp->d_typename, \"raid\", sizeof(lp->d_typename));\n\tlp->d_type = DTYPE_RAID;\n\tstrncpy(lp->d_packname, \"fictitious\", sizeof(lp->d_packname));\n\tlp->d_rpm = 3600;\n\tlp->d_interleave = 1;\n\tlp->d_flags = 0;\n\n\tlp->d_partitions[RAW_PART].p_offset = 0;\n\tlp->d_partitions[RAW_PART].p_size = raidPtr->totalSectors;\n\tlp->d_partitions[RAW_PART].p_fstype = FS_UNUSED;\n\tlp->d_npartitions = RAW_PART + 1;\n\n\tlp->d_magic = DISKMAGIC;\n\tlp->d_magic2 = DISKMAGIC;\n\tlp->d_checksum = dkcksum(rs->sc_dkdev.dk_label);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "clp",
            "sizeof(*clp)"
          ],
          "line": 1784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db1_printf",
          "args": [
            "(\"Getting the disklabel...\\n\")"
          ],
          "line": 1782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raidunit",
          "args": [
            "dev"
          ],
          "line": 1775
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\nstatic RF_Raid_t **raidPtrs;\nvoid\traidstrategy;\nstruct raid_softc *raid_softc;\nvoid\traidgetdefaultlabel;\nvoid\traidgetdisklabel;\nvoid\traidmakedisklabel;\n\nvoid\nraidgetdisklabel(dev)\n\tdev_t dev;\n{\n\tint unit = raidunit(dev);\n\tstruct raid_softc *rs = &raid_softc[unit];\n\tchar *errstring;\n\tstruct disklabel *lp = rs->sc_dkdev.dk_label;\n\tstruct cpu_disklabel *clp = rs->sc_dkdev.dk_cpulabel;\n\tRF_Raid_t *raidPtr;\n\n\tdb1_printf((\"Getting the disklabel...\\n\"));\n\n\tbzero(clp, sizeof(*clp));\n\n\traidPtr = raidPtrs[unit];\n\n\traidgetdefaultlabel(raidPtr, rs, lp);\n\n\t/*\n\t * Call the generic disklabel extraction routine.\n\t */\n\terrstring = readdisklabel(RAIDLABELDEV(dev), raidstrategy,\n\t    rs->sc_dkdev.dk_label, rs->sc_dkdev.dk_cpulabel, 0);\n\tif (errstring)\n\t\traidmakedisklabel(rs);\n\telse {\n\t\tint i;\n\t\tstruct partition *pp;\n\n\t\t/*\n\t\t * Sanity check whether the found disklabel is valid.\n\t\t *\n\t\t * This is necessary since total size of the raid device\n\t\t * may vary when an interleave is changed even though exactly\n\t\t * same componets are used, and old disklabel may used\n\t\t * if that is found.\n\t\t */\n\t\tif (lp->d_secperunit != rs->sc_size)\n\t\t\tprintf(\"WARNING: %s: \"\n\t\t\t    \"total sector size in disklabel (%d) != \"\n\t\t\t    \"the size of raid (%ld)\\n\", rs->sc_xname,\n\t\t\t    lp->d_secperunit, (long) rs->sc_size);\n\t\tfor (i = 0; i < lp->d_npartitions; i++) {\n\t\t\tpp = &lp->d_partitions[i];\n\t\t\tif (pp->p_offset + pp->p_size > rs->sc_size)\n\t\t\t\tprintf(\"WARNING: %s: end of partition `%c' \"\n\t\t\t\t    \"exceeds the size of raid (%ld)\\n\",\n\t\t\t\t    rs->sc_xname, 'a' + i, (long) rs->sc_size);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "raidgetdefaultlabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_openbsdkintf.c",
    "lines": "1731-1765",
    "snippet": "void\nraidgetdefaultlabel(raidPtr, rs, lp)\n\tRF_Raid_t *raidPtr;\n\tstruct raid_softc *rs;\n\tstruct disklabel *lp;\n{\n\tdb1_printf((\"Building a default label...\\n\"));\n\tbzero(lp, sizeof(*lp));\n\n\t/* fabricate a label... */\n\tlp->d_secperunit = raidPtr->totalSectors;\n\tlp->d_secsize = raidPtr->bytesPerSector;\n\tlp->d_nsectors = raidPtr->Layout.dataSectorsPerStripe;\n\tlp->d_ntracks = 1;\n\tlp->d_ncylinders = raidPtr->totalSectors / \n\t\t(lp->d_nsectors * lp->d_ntracks);\n\tlp->d_secpercyl = lp->d_ntracks * lp->d_nsectors;\n\n\tstrncpy(lp->d_typename, \"raid\", sizeof(lp->d_typename));\n\tlp->d_type = DTYPE_RAID;\n\tstrncpy(lp->d_packname, \"fictitious\", sizeof(lp->d_packname));\n\tlp->d_rpm = 3600;\n\tlp->d_interleave = 1;\n\tlp->d_flags = 0;\n\n\tlp->d_partitions[RAW_PART].p_offset = 0;\n\tlp->d_partitions[RAW_PART].p_size = raidPtr->totalSectors;\n\tlp->d_partitions[RAW_PART].p_fstype = FS_UNUSED;\n\tlp->d_npartitions = RAW_PART + 1;\n\n\tlp->d_magic = DISKMAGIC;\n\tlp->d_magic2 = DISKMAGIC;\n\tlp->d_checksum = dkcksum(rs->sc_dkdev.dk_label);\n\n}",
    "includes": [
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_kintf.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_dagflags.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_copyback.h\"",
      "#include \"rf_raidframe.h\"",
      "#include \"rf_raid.h\"",
      "#include \"raid.h\"",
      "#include <sys/user.h>",
      "#include <sys/buf.h>",
      "#include <sys/lock.h>",
      "#include <sys/conf.h>",
      "#include <sys/namei.h>",
      "#include <sys/systm.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/device.h>",
      "#include <sys/disk.h>",
      "#include <sys/queue.h>",
      "#include <sys/malloc.h>",
      "#include <sys/param.h>",
      "#include <sys/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct raid_softc *raid_softc;",
      "void\traidgetdefaultlabel"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dkcksum",
          "args": [
            "rs->sc_dkdev.dk_label"
          ],
          "line": 1763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "lp->d_packname",
            "\"fictitious\"",
            "sizeof(lp->d_packname)"
          ],
          "line": 1751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "lp->d_typename",
            "\"raid\"",
            "sizeof(lp->d_typename)"
          ],
          "line": 1749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "lp",
            "sizeof(*lp)"
          ],
          "line": 1738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db1_printf",
          "args": [
            "(\"Building a default label...\\n\")"
          ],
          "line": 1737
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\nstruct raid_softc *raid_softc;\nvoid\traidgetdefaultlabel;\n\nvoid\nraidgetdefaultlabel(raidPtr, rs, lp)\n\tRF_Raid_t *raidPtr;\n\tstruct raid_softc *rs;\n\tstruct disklabel *lp;\n{\n\tdb1_printf((\"Building a default label...\\n\"));\n\tbzero(lp, sizeof(*lp));\n\n\t/* fabricate a label... */\n\tlp->d_secperunit = raidPtr->totalSectors;\n\tlp->d_secsize = raidPtr->bytesPerSector;\n\tlp->d_nsectors = raidPtr->Layout.dataSectorsPerStripe;\n\tlp->d_ntracks = 1;\n\tlp->d_ncylinders = raidPtr->totalSectors / \n\t\t(lp->d_nsectors * lp->d_ntracks);\n\tlp->d_secpercyl = lp->d_ntracks * lp->d_nsectors;\n\n\tstrncpy(lp->d_typename, \"raid\", sizeof(lp->d_typename));\n\tlp->d_type = DTYPE_RAID;\n\tstrncpy(lp->d_packname, \"fictitious\", sizeof(lp->d_packname));\n\tlp->d_rpm = 3600;\n\tlp->d_interleave = 1;\n\tlp->d_flags = 0;\n\n\tlp->d_partitions[RAW_PART].p_offset = 0;\n\tlp->d_partitions[RAW_PART].p_size = raidPtr->totalSectors;\n\tlp->d_partitions[RAW_PART].p_fstype = FS_UNUSED;\n\tlp->d_npartitions = RAW_PART + 1;\n\n\tlp->d_magic = DISKMAGIC;\n\tlp->d_magic2 = DISKMAGIC;\n\tlp->d_checksum = dkcksum(rs->sc_dkdev.dk_label);\n\n}"
  },
  {
    "function_name": "rf_InitBP",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_openbsdkintf.c",
    "lines": "1698-1729",
    "snippet": "void\nrf_InitBP(bp, b_vp, rw_flag, dev, startSect, numSect, buf, cbFunc, cbArg,\n    logBytesPerSector, b_proc)\n\tstruct buf *bp;\n\tstruct vnode *b_vp;\n\tunsigned rw_flag;\n\tdev_t dev;\n\tRF_SectorNum_t startSect;\n\tRF_SectorCount_t numSect;\n\tcaddr_t buf;\n\tvoid (*cbFunc)(struct buf *);\n\tvoid *cbArg;\n\tint logBytesPerSector;\n\tstruct proc *b_proc;\n{\n\t/* bp->b_flags = B_PHYS | rw_flag; */\n\tbp->b_flags = B_CALL | rw_flag; /* XXX need B_PHYS here too??? */\n\tbp->b_bcount = numSect << logBytesPerSector;\n\tbp->b_bufsize = bp->b_bcount;\n\tbp->b_error = 0;\n\tbp->b_dev = dev;\n\tbp->b_un.b_addr = buf;\n\tbp->b_blkno = startSect;\n\tbp->b_resid = bp->b_bcount; /* XXX is this right!??!?!! */\n\tif (bp->b_bcount == 0) {\n\t\tpanic(\"bp->b_bcount is zero in rf_InitBP!!\\n\");\n\t}\n\tbp->b_proc = b_proc;\n\tbp->b_iodone = cbFunc;\n\tbp->b_vp = b_vp;\n\tLIST_INIT(&bp->b_dep);\n}",
    "includes": [
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_kintf.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_dagflags.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_copyback.h\"",
      "#include \"rf_raidframe.h\"",
      "#include \"rf_raid.h\"",
      "#include \"raid.h\"",
      "#include <sys/user.h>",
      "#include <sys/buf.h>",
      "#include <sys/lock.h>",
      "#include <sys/conf.h>",
      "#include <sys/namei.h>",
      "#include <sys/systm.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/device.h>",
      "#include <sys/disk.h>",
      "#include <sys/queue.h>",
      "#include <sys/malloc.h>",
      "#include <sys/param.h>",
      "#include <sys/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\trf_InitBP"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LIST_INIT",
          "args": [
            "&bp->b_dep"
          ],
          "line": 1728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"bp->b_bcount is zero in rf_InitBP!!\\n\""
          ],
          "line": 1723
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\nvoid\trf_InitBP;\n\nvoid\nrf_InitBP(bp, b_vp, rw_flag, dev, startSect, numSect, buf, cbFunc, cbArg,\n    logBytesPerSector, b_proc)\n\tstruct buf *bp;\n\tstruct vnode *b_vp;\n\tunsigned rw_flag;\n\tdev_t dev;\n\tRF_SectorNum_t startSect;\n\tRF_SectorCount_t numSect;\n\tcaddr_t buf;\n\tvoid (*cbFunc)(struct buf *);\n\tvoid *cbArg;\n\tint logBytesPerSector;\n\tstruct proc *b_proc;\n{\n\t/* bp->b_flags = B_PHYS | rw_flag; */\n\tbp->b_flags = B_CALL | rw_flag; /* XXX need B_PHYS here too??? */\n\tbp->b_bcount = numSect << logBytesPerSector;\n\tbp->b_bufsize = bp->b_bcount;\n\tbp->b_error = 0;\n\tbp->b_dev = dev;\n\tbp->b_un.b_addr = buf;\n\tbp->b_blkno = startSect;\n\tbp->b_resid = bp->b_bcount; /* XXX is this right!??!?!! */\n\tif (bp->b_bcount == 0) {\n\t\tpanic(\"bp->b_bcount is zero in rf_InitBP!!\\n\");\n\t}\n\tbp->b_proc = b_proc;\n\tbp->b_iodone = cbFunc;\n\tbp->b_vp = b_vp;\n\tLIST_INIT(&bp->b_dep);\n}"
  },
  {
    "function_name": "rf_KernelWakeupFunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_openbsdkintf.c",
    "lines": "1611-1693",
    "snippet": "void\nrf_KernelWakeupFunc(vbp)\n\tstruct buf *vbp;\n{\n\tRF_DiskQueueData_t *req = NULL;\n\tRF_DiskQueue_t *queue;\n\tstruct raidbuf *raidbp = (struct raidbuf *)vbp;\n\tstruct buf *bp;\n\tstruct raid_softc *rs;\n\tint unit;\n\tint s;\n\n\ts = splbio();\n\tdb1_printf((\"recovering the request queue:\\n\"));\n\treq = raidbp->req;\n\n\tbp = raidbp->rf_obp;\n\n\tqueue = (RF_DiskQueue_t *)req->queue;\n\n\tif (raidbp->rf_buf.b_flags & B_ERROR) {\n\t\tbp->b_flags |= B_ERROR;\n\t\tbp->b_error =\n\t\t    raidbp->rf_buf.b_error ? raidbp->rf_buf.b_error : EIO;\n\t}\n\n#if 1\n\t/* XXX Methinks this could be wrong... */\n\tbp->b_resid = raidbp->rf_buf.b_resid;\n#endif\n\n\tif (req->tracerec) {\n\t\tRF_ETIMER_STOP(req->tracerec->timer);\n\t\tRF_ETIMER_EVAL(req->tracerec->timer);\n\t\tRF_LOCK_MUTEX(rf_tracing_mutex);\n\t\treq->tracerec->diskwait_us +=\n\t\t    RF_ETIMER_VAL_US(req->tracerec->timer);\n\t\treq->tracerec->phys_io_us +=\n\t\t    RF_ETIMER_VAL_US(req->tracerec->timer);\n\t\treq->tracerec->num_phys_ios++;\n\t\tRF_UNLOCK_MUTEX(rf_tracing_mutex);\n\t}\n\n\tbp->b_bcount = raidbp->rf_buf.b_bcount;/* XXXX ?? */\n\n\tunit = queue->raidPtr->raidid; /* *Much* simpler :-> */\n\n\t/*\n\t * XXX Ok, let's get aggressive... If B_ERROR is set, let's go\n\t * ballistic, and mark the component as hosed...\n\t */\n\tif (bp->b_flags & B_ERROR) {\n\t\t/* Mark the disk as dead but only mark it once... */\n\t\tif (queue->raidPtr->Disks[queue->row][queue->col].status ==\n\t\t    rf_ds_optimal) {\n\t\t\tprintf(\"raid%d: IO Error.  Marking %s as failed.\\n\",\n\t\t\t    unit,\n\t\t\t    queue->raidPtr->\n\t\t\t    Disks[queue->row][queue->col].devname);\n\t\t\tqueue->raidPtr->Disks[queue->row][queue->col].status =\n\t\t\t    rf_ds_failed;\n\t\t\tqueue->raidPtr->status[queue->row] = rf_rs_degraded;\n\t\t\tqueue->raidPtr->numFailures++;\n\t\t\t/* XXX here we should bump the version number for each component, and write that data out */\n\t\t} else {\n\t\t\t/* Disk is already dead... */\n\t\t\t/* printf(\"Disk already marked as dead!\\n\"); */\n\t\t}\n\t}\n\n\trs = &raid_softc[unit];\n\tRAIDPUTBUF(raidbp);\n\n\tif (bp->b_resid==0) {\n\t\t/* XXX is this the right place for a disk_unbusy()??!??!?!? */\n\t\tdisk_unbusy(&rs->sc_dkdev, (bp->b_bcount - bp->b_resid));\n\t}\n\n\trf_DiskIOComplete(queue, req, (bp->b_flags & B_ERROR) ? 1 : 0);\n\t(req->CompleteFunc)(req->argument, (bp->b_flags & B_ERROR) ? 1 : 0);\n\n\tsplx(s);\n}",
    "includes": [
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_kintf.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_dagflags.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_copyback.h\"",
      "#include \"rf_raidframe.h\"",
      "#include \"rf_raid.h\"",
      "#include \"raid.h\"",
      "#include <sys/user.h>",
      "#include <sys/buf.h>",
      "#include <sys/lock.h>",
      "#include <sys/conf.h>",
      "#include <sys/namei.h>",
      "#include <sys/systm.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/device.h>",
      "#include <sys/disk.h>",
      "#include <sys/queue.h>",
      "#include <sys/malloc.h>",
      "#include <sys/param.h>",
      "#include <sys/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\trf_KernelWakeupFunc",
      "struct raid_softc *raid_softc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "req->argument",
            "(bp->b_flags & B_ERROR) ? 1 : 0"
          ],
          "line": 1690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_DiskIOComplete",
          "args": [
            "queue",
            "req",
            "(bp->b_flags & B_ERROR) ? 1 : 0"
          ],
          "line": 1689
        },
        "resolved": true,
        "details": {
          "function_name": "rf_DiskIOComplete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_diskqueue.c",
          "lines": "408-493",
          "snippet": "void \nrf_DiskIOComplete(queue, req, status)\n\tRF_DiskQueue_t *queue;\n\tRF_DiskQueueData_t *req;\n\tint     status;\n{\n\tint     done = 0;\n\n\tRF_LOCK_QUEUE_MUTEX(queue, \"DiskIOComplete\");\n\n\t/* unlock the queue: (1) after an unlocking req completes (2) after a\n\t * locking req fails */\n\tif (RF_UNLOCKING_REQ(req) || (RF_LOCKING_REQ(req) && status)) {\n\t\tDprintf2(\"DiskIOComplete: unlocking queue at r %d c %d\\n\", queue->row, queue->col);\n\t\tRF_ASSERT(RF_QUEUE_LOCKED(queue) && (queue->unlockingOp == NULL));\n\t\tRF_UNLOCK_QUEUE(queue);\n\t}\n\tqueue->numOutstanding--;\n\tRF_ASSERT(queue->numOutstanding >= 0);\n\n\t/* dispatch requests to the disk until we find one that we can't. */\n\t/* no reason to continue once we've filled up the queue */\n\t/* no reason to even start if the queue is locked */\n\n\twhile (!done && !RF_QUEUE_FULL(queue) && !RF_QUEUE_LOCKED(queue)) {\n\t\tif (queue->nextLockingOp) {\n\t\t\treq = queue->nextLockingOp;\n\t\t\tqueue->nextLockingOp = NULL;\n\t\t\tDprintf3(\"DiskIOComplete: a pri %d locking req was pending at r %d c %d\\n\", req->priority, queue->row, queue->col);\n\t\t} else {\n\t\t\treq = (queue->qPtr->Dequeue) (queue->qHdr);\n\t\t\tif (req != NULL) {\n\t\t\t\tDprintf3(\"DiskIOComplete: extracting pri %d req from queue at r %d c %d\\n\", req->priority, queue->row, queue->col);\n\t\t\t} else {\n\t\t\t\tDprintf1(\"DiskIOComplete: no more requests to extract.\\n\", \"\");\n\t\t\t}\n\t\t}\n\t\tif (req) {\n\t\t\tqueue->queueLength--;\t/* decrement count of number\n\t\t\t\t\t\t * of requests waiting in this\n\t\t\t\t\t\t * queue */\n\t\t\tRF_ASSERT(queue->queueLength >= 0);\n\t\t}\n\t\tif (!req)\n\t\t\tdone = 1;\n\t\telse\n\t\t\tif (RF_LOCKING_REQ(req)) {\n\t\t\t\tif (RF_QUEUE_EMPTY(queue)) {\t/* dispatch it */\n\t\t\t\t\tDprintf3(\"DiskIOComplete: dispatching pri %d locking req to r %d c %d (queue empty)\\n\", req->priority, queue->row, queue->col);\n\t\t\t\t\tRF_LOCK_QUEUE(queue);\n\t\t\t\t\trf_DispatchKernelIO(queue, req);\n\t\t\t\t\tdone = 1;\n\t\t\t\t} else {\t/* put it aside to wait for\n\t\t\t\t\t\t * the queue to drain */\n\t\t\t\t\tDprintf3(\"DiskIOComplete: postponing pri %d locking req to r %d c %d\\n\", req->priority, queue->row, queue->col);\n\t\t\t\t\tRF_ASSERT(queue->nextLockingOp == NULL);\n\t\t\t\t\tqueue->nextLockingOp = req;\n\t\t\t\t\tdone = 1;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tif (RF_UNLOCKING_REQ(req)) {\t/* should not happen:\n\t\t\t\t\t\t\t\t * unlocking ops should\n\t\t\t\t\t\t\t\t * not get queued */\n\t\t\t\t\tRF_ASSERT(RF_QUEUE_LOCKED(queue));\t/* support it anyway for\n\t\t\t\t\t\t\t\t\t\t * the future */\n\t\t\t\t\tDprintf3(\"DiskIOComplete: dispatching pri %d unl req to r %d c %d (SHOULD NOT SEE THIS)\\n\", req->priority, queue->row, queue->col);\n\t\t\t\t\trf_DispatchKernelIO(queue, req);\n\t\t\t\t\tdone = 1;\n\t\t\t\t} else\n\t\t\t\t\tif (RF_OK_TO_DISPATCH(queue, req)) {\n\t\t\t\t\t\tDprintf3(\"DiskIOComplete: dispatching pri %d regular req to r %d c %d (ok to dispatch)\\n\", req->priority, queue->row, queue->col);\n\t\t\t\t\t\trf_DispatchKernelIO(queue, req);\n\t\t\t\t\t} else {\t/* we can't dispatch it,\n\t\t\t\t\t\t\t * so just re-enqueue\n\t\t\t\t\t\t\t * it.  */\n\t\t\t\t\t\t/* potential trouble here if\n\t\t\t\t\t\t * disk queues batch reqs */\n\t\t\t\t\t\tDprintf3(\"DiskIOComplete: re-enqueueing pri %d regular req to r %d c %d\\n\", req->priority, queue->row, queue->col);\n\t\t\t\t\t\tqueue->queueLength++;\n\t\t\t\t\t\t(queue->qPtr->Enqueue) (queue->qHdr, req, req->priority);\n\t\t\t\t\t\tdone = 1;\n\t\t\t\t\t}\n\t}\n\n\tRF_UNLOCK_QUEUE_MUTEX(queue, \"DiskIOComplete\");\n}",
          "includes": [
            "#include <sys/buf.h>",
            "#include \"rf_fifo.h\"",
            "#include \"rf_sstf.h\"",
            "#include \"rf_cvscan.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_dqd(RF_DiskQueueData_t *);",
            "static void clean_dqd(RF_DiskQueueData_t *);",
            "int     rf_DispatchKernelIO(RF_DiskQueue_t *, RF_DiskQueueData_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_fifo.h\"\n#include \"rf_sstf.h\"\n#include \"rf_cvscan.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic int init_dqd(RF_DiskQueueData_t *);\nstatic void clean_dqd(RF_DiskQueueData_t *);\nint     rf_DispatchKernelIO(RF_DiskQueue_t *, RF_DiskQueueData_t *);\n\nvoid \nrf_DiskIOComplete(queue, req, status)\n\tRF_DiskQueue_t *queue;\n\tRF_DiskQueueData_t *req;\n\tint     status;\n{\n\tint     done = 0;\n\n\tRF_LOCK_QUEUE_MUTEX(queue, \"DiskIOComplete\");\n\n\t/* unlock the queue: (1) after an unlocking req completes (2) after a\n\t * locking req fails */\n\tif (RF_UNLOCKING_REQ(req) || (RF_LOCKING_REQ(req) && status)) {\n\t\tDprintf2(\"DiskIOComplete: unlocking queue at r %d c %d\\n\", queue->row, queue->col);\n\t\tRF_ASSERT(RF_QUEUE_LOCKED(queue) && (queue->unlockingOp == NULL));\n\t\tRF_UNLOCK_QUEUE(queue);\n\t}\n\tqueue->numOutstanding--;\n\tRF_ASSERT(queue->numOutstanding >= 0);\n\n\t/* dispatch requests to the disk until we find one that we can't. */\n\t/* no reason to continue once we've filled up the queue */\n\t/* no reason to even start if the queue is locked */\n\n\twhile (!done && !RF_QUEUE_FULL(queue) && !RF_QUEUE_LOCKED(queue)) {\n\t\tif (queue->nextLockingOp) {\n\t\t\treq = queue->nextLockingOp;\n\t\t\tqueue->nextLockingOp = NULL;\n\t\t\tDprintf3(\"DiskIOComplete: a pri %d locking req was pending at r %d c %d\\n\", req->priority, queue->row, queue->col);\n\t\t} else {\n\t\t\treq = (queue->qPtr->Dequeue) (queue->qHdr);\n\t\t\tif (req != NULL) {\n\t\t\t\tDprintf3(\"DiskIOComplete: extracting pri %d req from queue at r %d c %d\\n\", req->priority, queue->row, queue->col);\n\t\t\t} else {\n\t\t\t\tDprintf1(\"DiskIOComplete: no more requests to extract.\\n\", \"\");\n\t\t\t}\n\t\t}\n\t\tif (req) {\n\t\t\tqueue->queueLength--;\t/* decrement count of number\n\t\t\t\t\t\t * of requests waiting in this\n\t\t\t\t\t\t * queue */\n\t\t\tRF_ASSERT(queue->queueLength >= 0);\n\t\t}\n\t\tif (!req)\n\t\t\tdone = 1;\n\t\telse\n\t\t\tif (RF_LOCKING_REQ(req)) {\n\t\t\t\tif (RF_QUEUE_EMPTY(queue)) {\t/* dispatch it */\n\t\t\t\t\tDprintf3(\"DiskIOComplete: dispatching pri %d locking req to r %d c %d (queue empty)\\n\", req->priority, queue->row, queue->col);\n\t\t\t\t\tRF_LOCK_QUEUE(queue);\n\t\t\t\t\trf_DispatchKernelIO(queue, req);\n\t\t\t\t\tdone = 1;\n\t\t\t\t} else {\t/* put it aside to wait for\n\t\t\t\t\t\t * the queue to drain */\n\t\t\t\t\tDprintf3(\"DiskIOComplete: postponing pri %d locking req to r %d c %d\\n\", req->priority, queue->row, queue->col);\n\t\t\t\t\tRF_ASSERT(queue->nextLockingOp == NULL);\n\t\t\t\t\tqueue->nextLockingOp = req;\n\t\t\t\t\tdone = 1;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tif (RF_UNLOCKING_REQ(req)) {\t/* should not happen:\n\t\t\t\t\t\t\t\t * unlocking ops should\n\t\t\t\t\t\t\t\t * not get queued */\n\t\t\t\t\tRF_ASSERT(RF_QUEUE_LOCKED(queue));\t/* support it anyway for\n\t\t\t\t\t\t\t\t\t\t * the future */\n\t\t\t\t\tDprintf3(\"DiskIOComplete: dispatching pri %d unl req to r %d c %d (SHOULD NOT SEE THIS)\\n\", req->priority, queue->row, queue->col);\n\t\t\t\t\trf_DispatchKernelIO(queue, req);\n\t\t\t\t\tdone = 1;\n\t\t\t\t} else\n\t\t\t\t\tif (RF_OK_TO_DISPATCH(queue, req)) {\n\t\t\t\t\t\tDprintf3(\"DiskIOComplete: dispatching pri %d regular req to r %d c %d (ok to dispatch)\\n\", req->priority, queue->row, queue->col);\n\t\t\t\t\t\trf_DispatchKernelIO(queue, req);\n\t\t\t\t\t} else {\t/* we can't dispatch it,\n\t\t\t\t\t\t\t * so just re-enqueue\n\t\t\t\t\t\t\t * it.  */\n\t\t\t\t\t\t/* potential trouble here if\n\t\t\t\t\t\t * disk queues batch reqs */\n\t\t\t\t\t\tDprintf3(\"DiskIOComplete: re-enqueueing pri %d regular req to r %d c %d\\n\", req->priority, queue->row, queue->col);\n\t\t\t\t\t\tqueue->queueLength++;\n\t\t\t\t\t\t(queue->qPtr->Enqueue) (queue->qHdr, req, req->priority);\n\t\t\t\t\t\tdone = 1;\n\t\t\t\t\t}\n\t}\n\n\tRF_UNLOCK_QUEUE_MUTEX(queue, \"DiskIOComplete\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "disk_unbusy",
          "args": [
            "&rs->sc_dkdev",
            "(bp->b_bcount - bp->b_resid)"
          ],
          "line": 1686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAIDPUTBUF",
          "args": [
            "raidbp"
          ],
          "line": 1682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"raid%d: IO Error.  Marking %s as failed.\\n\"",
            "unit",
            "queue->raidPtr->\n\t\t\t    Disks[queue->row][queue->col].devname"
          ],
          "line": 1666
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_UNLOCK_MUTEX",
          "args": [
            "rf_tracing_mutex"
          ],
          "line": 1651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_VAL_US",
          "args": [
            "req->tracerec->timer"
          ],
          "line": 1649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_VAL_US",
          "args": [
            "req->tracerec->timer"
          ],
          "line": 1647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_LOCK_MUTEX",
          "args": [
            "rf_tracing_mutex"
          ],
          "line": 1645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_EVAL",
          "args": [
            "req->tracerec->timer"
          ],
          "line": 1644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_STOP",
          "args": [
            "req->tracerec->timer"
          ],
          "line": 1643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db1_printf",
          "args": [
            "(\"recovering the request queue:\\n\")"
          ],
          "line": 1624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 1623
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\nvoid\trf_KernelWakeupFunc;\nstruct raid_softc *raid_softc;\n\nvoid\nrf_KernelWakeupFunc(vbp)\n\tstruct buf *vbp;\n{\n\tRF_DiskQueueData_t *req = NULL;\n\tRF_DiskQueue_t *queue;\n\tstruct raidbuf *raidbp = (struct raidbuf *)vbp;\n\tstruct buf *bp;\n\tstruct raid_softc *rs;\n\tint unit;\n\tint s;\n\n\ts = splbio();\n\tdb1_printf((\"recovering the request queue:\\n\"));\n\treq = raidbp->req;\n\n\tbp = raidbp->rf_obp;\n\n\tqueue = (RF_DiskQueue_t *)req->queue;\n\n\tif (raidbp->rf_buf.b_flags & B_ERROR) {\n\t\tbp->b_flags |= B_ERROR;\n\t\tbp->b_error =\n\t\t    raidbp->rf_buf.b_error ? raidbp->rf_buf.b_error : EIO;\n\t}\n\n#if 1\n\t/* XXX Methinks this could be wrong... */\n\tbp->b_resid = raidbp->rf_buf.b_resid;\n#endif\n\n\tif (req->tracerec) {\n\t\tRF_ETIMER_STOP(req->tracerec->timer);\n\t\tRF_ETIMER_EVAL(req->tracerec->timer);\n\t\tRF_LOCK_MUTEX(rf_tracing_mutex);\n\t\treq->tracerec->diskwait_us +=\n\t\t    RF_ETIMER_VAL_US(req->tracerec->timer);\n\t\treq->tracerec->phys_io_us +=\n\t\t    RF_ETIMER_VAL_US(req->tracerec->timer);\n\t\treq->tracerec->num_phys_ios++;\n\t\tRF_UNLOCK_MUTEX(rf_tracing_mutex);\n\t}\n\n\tbp->b_bcount = raidbp->rf_buf.b_bcount;/* XXXX ?? */\n\n\tunit = queue->raidPtr->raidid; /* *Much* simpler :-> */\n\n\t/*\n\t * XXX Ok, let's get aggressive... If B_ERROR is set, let's go\n\t * ballistic, and mark the component as hosed...\n\t */\n\tif (bp->b_flags & B_ERROR) {\n\t\t/* Mark the disk as dead but only mark it once... */\n\t\tif (queue->raidPtr->Disks[queue->row][queue->col].status ==\n\t\t    rf_ds_optimal) {\n\t\t\tprintf(\"raid%d: IO Error.  Marking %s as failed.\\n\",\n\t\t\t    unit,\n\t\t\t    queue->raidPtr->\n\t\t\t    Disks[queue->row][queue->col].devname);\n\t\t\tqueue->raidPtr->Disks[queue->row][queue->col].status =\n\t\t\t    rf_ds_failed;\n\t\t\tqueue->raidPtr->status[queue->row] = rf_rs_degraded;\n\t\t\tqueue->raidPtr->numFailures++;\n\t\t\t/* XXX here we should bump the version number for each component, and write that data out */\n\t\t} else {\n\t\t\t/* Disk is already dead... */\n\t\t\t/* printf(\"Disk already marked as dead!\\n\"); */\n\t\t}\n\t}\n\n\trs = &raid_softc[unit];\n\tRAIDPUTBUF(raidbp);\n\n\tif (bp->b_resid==0) {\n\t\t/* XXX is this the right place for a disk_unbusy()??!??!?!? */\n\t\tdisk_unbusy(&rs->sc_dkdev, (bp->b_bcount - bp->b_resid));\n\t}\n\n\trf_DiskIOComplete(queue, req, (bp->b_flags & B_ERROR) ? 1 : 0);\n\t(req->CompleteFunc)(req->argument, (bp->b_flags & B_ERROR) ? 1 : 0);\n\n\tsplx(s);\n}"
  },
  {
    "function_name": "rf_DispatchKernelIO",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_openbsdkintf.c",
    "lines": "1475-1605",
    "snippet": "int\nrf_DispatchKernelIO(queue, req)\n\tRF_DiskQueue_t *queue;\n\tRF_DiskQueueData_t *req;\n{\n\tint op = (req->type == RF_IO_TYPE_READ) ? B_READ : B_WRITE;\n\tstruct buf *bp;\n\tstruct raidbuf *raidbp = NULL;\n\tstruct raid_softc *rs;\n\tint unit;\n\tint s;\n  \n\ts=0;\n\t/* s = splbio();*/ /* want to test this */\n\t\n\t/*\n\t * XXX along with the vnode, we also need the softc associated with\n\t * this device..\n\t */\n\treq->queue = queue;\n\t\n\tunit = queue->raidPtr->raidid;\n\n\tdb1_printf((\"DispatchKernelIO unit: %d\\n\", unit));\n\n\tif (unit >= numraid) {\n\t\tprintf(\"Invalid unit number: %d %d\\n\", unit, numraid);\n\t\tpanic(\"Invalid Unit number in rf_DispatchKernelIO\\n\");\n\t}\n\n\trs = &raid_softc[unit];\n\n\t/* XXX is this the right place? */\n\tdisk_busy(&rs->sc_dkdev);\n\n\tbp = req->bp;\n\n#if 1\n\t/*\n\t * XXX When there is a physical disk failure, someone is passing\n\t * us a buffer that contains old stuff!!  Attempt to deal with\n\t * this problem without taking a performance hit...\n\t * (not sure where the real bug is.  It's buried in RAIDframe\n\t * somewhere) :-(  GO )\n\t */\n\tif (bp->b_flags & B_ERROR) {\n\t\tbp->b_flags &= ~B_ERROR;\n\t}\n\tif (bp->b_error!=0) {\n\t\tbp->b_error = 0;\n\t}\n#endif\n\n\traidbp = RAIDGETBUF();\n\n\traidbp->rf_flags = 0; /* XXX not really used anywhere... */\n\n\t/*\n\t * context for raidiodone\n\t */\n\traidbp->rf_obp = bp;\n\traidbp->req = req;\n\n\tLIST_INIT(&raidbp->rf_buf.b_dep);\n\n\tswitch (req->type) {\n\tcase RF_IO_TYPE_NOP:\n\t\t/* Used primarily to unlock a locked queue. */\n\n\t\tdb1_printf((\"rf_DispatchKernelIO: NOP to r %d c %d\\n\",\n\t\t    queue->row, queue->col));\n\n\t\t/* XXX need to do something extra here.. */\n\n\t\t/*\n\t\t * I'm leaving this in, as I've never actually seen it\n\t\t * used, and I'd like folks to report it... GO\n\t\t */\n\t\tprintf((\"WAKEUP CALLED\\n\"));\n\t\tqueue->numOutstanding++;\n\n\t\t/* XXX need to glue the original buffer into this??  */\n\n\t\trf_KernelWakeupFunc(&raidbp->rf_buf);\n\t\tbreak;\n\t\t\n\tcase RF_IO_TYPE_READ:\n\tcase RF_IO_TYPE_WRITE:\n\t\tif (req->tracerec) {\n\t\t\tRF_ETIMER_START(req->tracerec->timer);\n\t\t}\n\n\t\trf_InitBP(&raidbp->rf_buf, queue->rf_cinfo->ci_vp,\n\t\t    op | bp->b_flags, queue->rf_cinfo->ci_dev,\n\t\t    req->sectorOffset, req->numSector,\n\t\t    req->buf, rf_KernelWakeupFunc, (void *)req,\t\n\t\t    queue->raidPtr->logBytesPerSector, req->b_proc);\n\n\t\tif (rf_debugKernelAccess) {\n\t\t\tdb1_printf((\"dispatch: bp->b_blkno = %ld\\n\",\n\t\t\t    (long)bp->b_blkno));\n\t\t}\n\t\tqueue->numOutstanding++;\n\t\tqueue->last_deq_sector = req->sectorOffset;\n\n\t\t/*\n\t\t * Acc wouldn't have been let in if there were any\n\t\t * pending reqs at any other priority.\n\t\t */\n\t\tqueue->curPriority = req->priority;\n\n\t\tdb1_printf((\"Going for %c to unit %d row %d col %d\\n\",\n\t\t    req->type, unit, queue->row, queue->col));\n\t\tdb1_printf((\"sector %d count %d (%d bytes) %d\\n\",\n\t\t    (int)req->sectorOffset, (int)req->numSector,\n\t\t    (int)(req->numSector << queue->raidPtr->logBytesPerSector),\n\t\t    (int)queue->raidPtr->logBytesPerSector));\n\t\tif ((raidbp->rf_buf.b_flags & B_READ) == 0) {\n\t\t\traidbp->rf_buf.b_vp->v_numoutput++;\n\t\t}\n\n\t\tVOP_STRATEGY(&raidbp->rf_buf);\n\t\tbreak;\n\t\t\n\tdefault:\n\t\tpanic(\"bad req->type in rf_DispatchKernelIO\");\n\t}\n\tdb1_printf((\"Exiting from DispatchKernelIO\\n\"));\n\t/* splx(s); */ /* want to test this */\n\treturn (0);\n}",
    "includes": [
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_kintf.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_dagflags.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_copyback.h\"",
      "#include \"rf_raidframe.h\"",
      "#include \"rf_raid.h\"",
      "#include \"raid.h\"",
      "#include <sys/user.h>",
      "#include <sys/buf.h>",
      "#include <sys/lock.h>",
      "#include <sys/conf.h>",
      "#include <sys/namei.h>",
      "#include <sys/systm.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/device.h>",
      "#include <sys/disk.h>",
      "#include <sys/queue.h>",
      "#include <sys/malloc.h>",
      "#include <sys/param.h>",
      "#include <sys/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\trf_KernelWakeupFunc",
      "void\trf_InitBP",
      "static int numraid = 0;",
      "struct raid_softc *raid_softc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "db1_printf",
          "args": [
            "(\"Exiting from DispatchKernelIO\\n\")"
          ],
          "line": 1602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"bad req->type in rf_DispatchKernelIO\""
          ],
          "line": 1600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VOP_STRATEGY",
          "args": [
            "&raidbp->rf_buf"
          ],
          "line": 1596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db1_printf",
          "args": [
            "(\"sector %d count %d (%d bytes) %d\\n\",\n\t\t    (int)req->sectorOffset, (int)req->numSector,\n\t\t    (int)(req->numSector << queue->raidPtr->logBytesPerSector),\n\t\t    (int)queue->raidPtr->logBytesPerSector)"
          ],
          "line": 1588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db1_printf",
          "args": [
            "(\"Going for %c to unit %d row %d col %d\\n\",\n\t\t    req->type, unit, queue->row, queue->col)"
          ],
          "line": 1586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db1_printf",
          "args": [
            "(\"dispatch: bp->b_blkno = %ld\\n\",\n\t\t\t    (long)bp->b_blkno)"
          ],
          "line": 1574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_InitBP",
          "args": [
            "&raidbp->rf_buf",
            "queue->rf_cinfo->ci_vp",
            "op | bp->b_flags",
            "queue->rf_cinfo->ci_dev",
            "req->sectorOffset",
            "req->numSector",
            "req->buf",
            "rf_KernelWakeupFunc",
            "(void *)req",
            "queue->raidPtr->logBytesPerSector",
            "req->b_proc"
          ],
          "line": 1567
        },
        "resolved": true,
        "details": {
          "function_name": "rf_InitBP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_openbsdkintf.c",
          "lines": "1698-1729",
          "snippet": "void\nrf_InitBP(bp, b_vp, rw_flag, dev, startSect, numSect, buf, cbFunc, cbArg,\n    logBytesPerSector, b_proc)\n\tstruct buf *bp;\n\tstruct vnode *b_vp;\n\tunsigned rw_flag;\n\tdev_t dev;\n\tRF_SectorNum_t startSect;\n\tRF_SectorCount_t numSect;\n\tcaddr_t buf;\n\tvoid (*cbFunc)(struct buf *);\n\tvoid *cbArg;\n\tint logBytesPerSector;\n\tstruct proc *b_proc;\n{\n\t/* bp->b_flags = B_PHYS | rw_flag; */\n\tbp->b_flags = B_CALL | rw_flag; /* XXX need B_PHYS here too??? */\n\tbp->b_bcount = numSect << logBytesPerSector;\n\tbp->b_bufsize = bp->b_bcount;\n\tbp->b_error = 0;\n\tbp->b_dev = dev;\n\tbp->b_un.b_addr = buf;\n\tbp->b_blkno = startSect;\n\tbp->b_resid = bp->b_bcount; /* XXX is this right!??!?!! */\n\tif (bp->b_bcount == 0) {\n\t\tpanic(\"bp->b_bcount is zero in rf_InitBP!!\\n\");\n\t}\n\tbp->b_proc = b_proc;\n\tbp->b_iodone = cbFunc;\n\tbp->b_vp = b_vp;\n\tLIST_INIT(&bp->b_dep);\n}",
          "includes": [
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_dagflags.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_raidframe.h\"",
            "#include \"rf_raid.h\"",
            "#include \"raid.h\"",
            "#include <sys/user.h>",
            "#include <sys/buf.h>",
            "#include <sys/lock.h>",
            "#include <sys/conf.h>",
            "#include <sys/namei.h>",
            "#include <sys/systm.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/device.h>",
            "#include <sys/disk.h>",
            "#include <sys/queue.h>",
            "#include <sys/malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\trf_InitBP"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\nvoid\trf_InitBP;\n\nvoid\nrf_InitBP(bp, b_vp, rw_flag, dev, startSect, numSect, buf, cbFunc, cbArg,\n    logBytesPerSector, b_proc)\n\tstruct buf *bp;\n\tstruct vnode *b_vp;\n\tunsigned rw_flag;\n\tdev_t dev;\n\tRF_SectorNum_t startSect;\n\tRF_SectorCount_t numSect;\n\tcaddr_t buf;\n\tvoid (*cbFunc)(struct buf *);\n\tvoid *cbArg;\n\tint logBytesPerSector;\n\tstruct proc *b_proc;\n{\n\t/* bp->b_flags = B_PHYS | rw_flag; */\n\tbp->b_flags = B_CALL | rw_flag; /* XXX need B_PHYS here too??? */\n\tbp->b_bcount = numSect << logBytesPerSector;\n\tbp->b_bufsize = bp->b_bcount;\n\tbp->b_error = 0;\n\tbp->b_dev = dev;\n\tbp->b_un.b_addr = buf;\n\tbp->b_blkno = startSect;\n\tbp->b_resid = bp->b_bcount; /* XXX is this right!??!?!! */\n\tif (bp->b_bcount == 0) {\n\t\tpanic(\"bp->b_bcount is zero in rf_InitBP!!\\n\");\n\t}\n\tbp->b_proc = b_proc;\n\tbp->b_iodone = cbFunc;\n\tbp->b_vp = b_vp;\n\tLIST_INIT(&bp->b_dep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_START",
          "args": [
            "req->tracerec->timer"
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_KernelWakeupFunc",
          "args": [
            "&raidbp->rf_buf"
          ],
          "line": 1558
        },
        "resolved": true,
        "details": {
          "function_name": "rf_KernelWakeupFunc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_openbsdkintf.c",
          "lines": "1611-1693",
          "snippet": "void\nrf_KernelWakeupFunc(vbp)\n\tstruct buf *vbp;\n{\n\tRF_DiskQueueData_t *req = NULL;\n\tRF_DiskQueue_t *queue;\n\tstruct raidbuf *raidbp = (struct raidbuf *)vbp;\n\tstruct buf *bp;\n\tstruct raid_softc *rs;\n\tint unit;\n\tint s;\n\n\ts = splbio();\n\tdb1_printf((\"recovering the request queue:\\n\"));\n\treq = raidbp->req;\n\n\tbp = raidbp->rf_obp;\n\n\tqueue = (RF_DiskQueue_t *)req->queue;\n\n\tif (raidbp->rf_buf.b_flags & B_ERROR) {\n\t\tbp->b_flags |= B_ERROR;\n\t\tbp->b_error =\n\t\t    raidbp->rf_buf.b_error ? raidbp->rf_buf.b_error : EIO;\n\t}\n\n#if 1\n\t/* XXX Methinks this could be wrong... */\n\tbp->b_resid = raidbp->rf_buf.b_resid;\n#endif\n\n\tif (req->tracerec) {\n\t\tRF_ETIMER_STOP(req->tracerec->timer);\n\t\tRF_ETIMER_EVAL(req->tracerec->timer);\n\t\tRF_LOCK_MUTEX(rf_tracing_mutex);\n\t\treq->tracerec->diskwait_us +=\n\t\t    RF_ETIMER_VAL_US(req->tracerec->timer);\n\t\treq->tracerec->phys_io_us +=\n\t\t    RF_ETIMER_VAL_US(req->tracerec->timer);\n\t\treq->tracerec->num_phys_ios++;\n\t\tRF_UNLOCK_MUTEX(rf_tracing_mutex);\n\t}\n\n\tbp->b_bcount = raidbp->rf_buf.b_bcount;/* XXXX ?? */\n\n\tunit = queue->raidPtr->raidid; /* *Much* simpler :-> */\n\n\t/*\n\t * XXX Ok, let's get aggressive... If B_ERROR is set, let's go\n\t * ballistic, and mark the component as hosed...\n\t */\n\tif (bp->b_flags & B_ERROR) {\n\t\t/* Mark the disk as dead but only mark it once... */\n\t\tif (queue->raidPtr->Disks[queue->row][queue->col].status ==\n\t\t    rf_ds_optimal) {\n\t\t\tprintf(\"raid%d: IO Error.  Marking %s as failed.\\n\",\n\t\t\t    unit,\n\t\t\t    queue->raidPtr->\n\t\t\t    Disks[queue->row][queue->col].devname);\n\t\t\tqueue->raidPtr->Disks[queue->row][queue->col].status =\n\t\t\t    rf_ds_failed;\n\t\t\tqueue->raidPtr->status[queue->row] = rf_rs_degraded;\n\t\t\tqueue->raidPtr->numFailures++;\n\t\t\t/* XXX here we should bump the version number for each component, and write that data out */\n\t\t} else {\n\t\t\t/* Disk is already dead... */\n\t\t\t/* printf(\"Disk already marked as dead!\\n\"); */\n\t\t}\n\t}\n\n\trs = &raid_softc[unit];\n\tRAIDPUTBUF(raidbp);\n\n\tif (bp->b_resid==0) {\n\t\t/* XXX is this the right place for a disk_unbusy()??!??!?!? */\n\t\tdisk_unbusy(&rs->sc_dkdev, (bp->b_bcount - bp->b_resid));\n\t}\n\n\trf_DiskIOComplete(queue, req, (bp->b_flags & B_ERROR) ? 1 : 0);\n\t(req->CompleteFunc)(req->argument, (bp->b_flags & B_ERROR) ? 1 : 0);\n\n\tsplx(s);\n}",
          "includes": [
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_dagflags.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_raidframe.h\"",
            "#include \"rf_raid.h\"",
            "#include \"raid.h\"",
            "#include <sys/user.h>",
            "#include <sys/buf.h>",
            "#include <sys/lock.h>",
            "#include <sys/conf.h>",
            "#include <sys/namei.h>",
            "#include <sys/systm.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/device.h>",
            "#include <sys/disk.h>",
            "#include <sys/queue.h>",
            "#include <sys/malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\trf_KernelWakeupFunc",
            "struct raid_softc *raid_softc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\nvoid\trf_KernelWakeupFunc;\nstruct raid_softc *raid_softc;\n\nvoid\nrf_KernelWakeupFunc(vbp)\n\tstruct buf *vbp;\n{\n\tRF_DiskQueueData_t *req = NULL;\n\tRF_DiskQueue_t *queue;\n\tstruct raidbuf *raidbp = (struct raidbuf *)vbp;\n\tstruct buf *bp;\n\tstruct raid_softc *rs;\n\tint unit;\n\tint s;\n\n\ts = splbio();\n\tdb1_printf((\"recovering the request queue:\\n\"));\n\treq = raidbp->req;\n\n\tbp = raidbp->rf_obp;\n\n\tqueue = (RF_DiskQueue_t *)req->queue;\n\n\tif (raidbp->rf_buf.b_flags & B_ERROR) {\n\t\tbp->b_flags |= B_ERROR;\n\t\tbp->b_error =\n\t\t    raidbp->rf_buf.b_error ? raidbp->rf_buf.b_error : EIO;\n\t}\n\n#if 1\n\t/* XXX Methinks this could be wrong... */\n\tbp->b_resid = raidbp->rf_buf.b_resid;\n#endif\n\n\tif (req->tracerec) {\n\t\tRF_ETIMER_STOP(req->tracerec->timer);\n\t\tRF_ETIMER_EVAL(req->tracerec->timer);\n\t\tRF_LOCK_MUTEX(rf_tracing_mutex);\n\t\treq->tracerec->diskwait_us +=\n\t\t    RF_ETIMER_VAL_US(req->tracerec->timer);\n\t\treq->tracerec->phys_io_us +=\n\t\t    RF_ETIMER_VAL_US(req->tracerec->timer);\n\t\treq->tracerec->num_phys_ios++;\n\t\tRF_UNLOCK_MUTEX(rf_tracing_mutex);\n\t}\n\n\tbp->b_bcount = raidbp->rf_buf.b_bcount;/* XXXX ?? */\n\n\tunit = queue->raidPtr->raidid; /* *Much* simpler :-> */\n\n\t/*\n\t * XXX Ok, let's get aggressive... If B_ERROR is set, let's go\n\t * ballistic, and mark the component as hosed...\n\t */\n\tif (bp->b_flags & B_ERROR) {\n\t\t/* Mark the disk as dead but only mark it once... */\n\t\tif (queue->raidPtr->Disks[queue->row][queue->col].status ==\n\t\t    rf_ds_optimal) {\n\t\t\tprintf(\"raid%d: IO Error.  Marking %s as failed.\\n\",\n\t\t\t    unit,\n\t\t\t    queue->raidPtr->\n\t\t\t    Disks[queue->row][queue->col].devname);\n\t\t\tqueue->raidPtr->Disks[queue->row][queue->col].status =\n\t\t\t    rf_ds_failed;\n\t\t\tqueue->raidPtr->status[queue->row] = rf_rs_degraded;\n\t\t\tqueue->raidPtr->numFailures++;\n\t\t\t/* XXX here we should bump the version number for each component, and write that data out */\n\t\t} else {\n\t\t\t/* Disk is already dead... */\n\t\t\t/* printf(\"Disk already marked as dead!\\n\"); */\n\t\t}\n\t}\n\n\trs = &raid_softc[unit];\n\tRAIDPUTBUF(raidbp);\n\n\tif (bp->b_resid==0) {\n\t\t/* XXX is this the right place for a disk_unbusy()??!??!?!? */\n\t\tdisk_unbusy(&rs->sc_dkdev, (bp->b_bcount - bp->b_resid));\n\t}\n\n\trf_DiskIOComplete(queue, req, (bp->b_flags & B_ERROR) ? 1 : 0);\n\t(req->CompleteFunc)(req->argument, (bp->b_flags & B_ERROR) ? 1 : 0);\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "(\"WAKEUP CALLED\\n\")"
          ],
          "line": 1553
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "db1_printf",
          "args": [
            "(\"rf_DispatchKernelIO: NOP to r %d c %d\\n\",\n\t\t    queue->row, queue->col)"
          ],
          "line": 1544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_INIT",
          "args": [
            "&raidbp->rf_buf.b_dep"
          ],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAIDGETBUF",
          "args": [],
          "line": 1528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disk_busy",
          "args": [
            "&rs->sc_dkdev"
          ],
          "line": 1508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"Invalid Unit number in rf_DispatchKernelIO\\n\""
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db1_printf",
          "args": [
            "(\"DispatchKernelIO unit: %d\\n\", unit)"
          ],
          "line": 1498
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\nvoid\trf_KernelWakeupFunc;\nvoid\trf_InitBP;\nstatic int numraid = 0;\nstruct raid_softc *raid_softc;\n\nint\nrf_DispatchKernelIO(queue, req)\n\tRF_DiskQueue_t *queue;\n\tRF_DiskQueueData_t *req;\n{\n\tint op = (req->type == RF_IO_TYPE_READ) ? B_READ : B_WRITE;\n\tstruct buf *bp;\n\tstruct raidbuf *raidbp = NULL;\n\tstruct raid_softc *rs;\n\tint unit;\n\tint s;\n  \n\ts=0;\n\t/* s = splbio();*/ /* want to test this */\n\t\n\t/*\n\t * XXX along with the vnode, we also need the softc associated with\n\t * this device..\n\t */\n\treq->queue = queue;\n\t\n\tunit = queue->raidPtr->raidid;\n\n\tdb1_printf((\"DispatchKernelIO unit: %d\\n\", unit));\n\n\tif (unit >= numraid) {\n\t\tprintf(\"Invalid unit number: %d %d\\n\", unit, numraid);\n\t\tpanic(\"Invalid Unit number in rf_DispatchKernelIO\\n\");\n\t}\n\n\trs = &raid_softc[unit];\n\n\t/* XXX is this the right place? */\n\tdisk_busy(&rs->sc_dkdev);\n\n\tbp = req->bp;\n\n#if 1\n\t/*\n\t * XXX When there is a physical disk failure, someone is passing\n\t * us a buffer that contains old stuff!!  Attempt to deal with\n\t * this problem without taking a performance hit...\n\t * (not sure where the real bug is.  It's buried in RAIDframe\n\t * somewhere) :-(  GO )\n\t */\n\tif (bp->b_flags & B_ERROR) {\n\t\tbp->b_flags &= ~B_ERROR;\n\t}\n\tif (bp->b_error!=0) {\n\t\tbp->b_error = 0;\n\t}\n#endif\n\n\traidbp = RAIDGETBUF();\n\n\traidbp->rf_flags = 0; /* XXX not really used anywhere... */\n\n\t/*\n\t * context for raidiodone\n\t */\n\traidbp->rf_obp = bp;\n\traidbp->req = req;\n\n\tLIST_INIT(&raidbp->rf_buf.b_dep);\n\n\tswitch (req->type) {\n\tcase RF_IO_TYPE_NOP:\n\t\t/* Used primarily to unlock a locked queue. */\n\n\t\tdb1_printf((\"rf_DispatchKernelIO: NOP to r %d c %d\\n\",\n\t\t    queue->row, queue->col));\n\n\t\t/* XXX need to do something extra here.. */\n\n\t\t/*\n\t\t * I'm leaving this in, as I've never actually seen it\n\t\t * used, and I'd like folks to report it... GO\n\t\t */\n\t\tprintf((\"WAKEUP CALLED\\n\"));\n\t\tqueue->numOutstanding++;\n\n\t\t/* XXX need to glue the original buffer into this??  */\n\n\t\trf_KernelWakeupFunc(&raidbp->rf_buf);\n\t\tbreak;\n\t\t\n\tcase RF_IO_TYPE_READ:\n\tcase RF_IO_TYPE_WRITE:\n\t\tif (req->tracerec) {\n\t\t\tRF_ETIMER_START(req->tracerec->timer);\n\t\t}\n\n\t\trf_InitBP(&raidbp->rf_buf, queue->rf_cinfo->ci_vp,\n\t\t    op | bp->b_flags, queue->rf_cinfo->ci_dev,\n\t\t    req->sectorOffset, req->numSector,\n\t\t    req->buf, rf_KernelWakeupFunc, (void *)req,\t\n\t\t    queue->raidPtr->logBytesPerSector, req->b_proc);\n\n\t\tif (rf_debugKernelAccess) {\n\t\t\tdb1_printf((\"dispatch: bp->b_blkno = %ld\\n\",\n\t\t\t    (long)bp->b_blkno));\n\t\t}\n\t\tqueue->numOutstanding++;\n\t\tqueue->last_deq_sector = req->sectorOffset;\n\n\t\t/*\n\t\t * Acc wouldn't have been let in if there were any\n\t\t * pending reqs at any other priority.\n\t\t */\n\t\tqueue->curPriority = req->priority;\n\n\t\tdb1_printf((\"Going for %c to unit %d row %d col %d\\n\",\n\t\t    req->type, unit, queue->row, queue->col));\n\t\tdb1_printf((\"sector %d count %d (%d bytes) %d\\n\",\n\t\t    (int)req->sectorOffset, (int)req->numSector,\n\t\t    (int)(req->numSector << queue->raidPtr->logBytesPerSector),\n\t\t    (int)queue->raidPtr->logBytesPerSector));\n\t\tif ((raidbp->rf_buf.b_flags & B_READ) == 0) {\n\t\t\traidbp->rf_buf.b_vp->v_numoutput++;\n\t\t}\n\n\t\tVOP_STRATEGY(&raidbp->rf_buf);\n\t\tbreak;\n\t\t\n\tdefault:\n\t\tpanic(\"bad req->type in rf_DispatchKernelIO\");\n\t}\n\tdb1_printf((\"Exiting from DispatchKernelIO\\n\"));\n\t/* splx(s); */ /* want to test this */\n\treturn (0);\n}"
  },
  {
    "function_name": "raidstart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_openbsdkintf.c",
    "lines": "1351-1471",
    "snippet": "void\nraidstart(raidPtr)\n\tRF_Raid_t *raidPtr;\n{\n\tRF_SectorCount_t num_blocks, pb, sum;\n\tRF_RaidAddr_t raid_addr;\n\tint retcode;\n\tstruct partition *pp;\n\tdaddr_t blocknum;\t\n\tint unit;\n\tstruct raid_softc *rs;\n\tint\tdo_async;\n\tstruct buf *bp;\n\tstruct buf *dp;\n\n\tunit = raidPtr->raidid;\n\trs = &raid_softc[unit];\n\n\t\n\t/* Check to see if we're at the limit... */\n\tRF_LOCK_MUTEX(raidPtr->mutex);\n\twhile (raidPtr->openings > 0) {\n\t\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n  \n\t\t/* get the next item, if any, from the queue */\n\t\tdp = &rs->buf_queue;\n\t\tbp = dp->b_actf;\n\t\tif (bp == NULL) {\n\t\t\t/* nothing more to do */\n\t\t\treturn;\n\t\t}\n  \n\t\t/* update structures */\n\t\tdp = bp->b_actf;\n\t\tif (dp != NULL) {\n\t\t\tdp->b_actb = bp->b_actb;\n\t\t} else {\n\t\t\trs->buf_queue.b_actb = bp->b_actb;\n\t\t}\n\t\t*bp->b_actb = dp;\n  \n\t\t/* Ok, for the bp we have here, bp->b_blkno is relative to the\n\t\t * partition.. Need to make it absolute to the underlying \n\t\t * device.. */\n  \n\t\tblocknum = bp->b_blkno;\n\t\tif (DISKPART(bp->b_dev) != RAW_PART) {\n\t\t\tpp = &rs->sc_dkdev.dk_label->d_partitions[DISKPART(bp->b_dev)];\n\t\t\tblocknum += pp->p_offset;\n\t\t}\n  \n\t\tdb1_printf((\"Blocks: %d, %d\\n\", (int) bp->b_blkno, \n\t\t\t    (int) blocknum));\n\t\t\n\t\tdb1_printf((\"bp->b_bcount = %d\\n\", (int) bp->b_bcount));\n\t\tdb1_printf((\"bp->b_resid = %d\\n\", (int) bp->b_resid));\n\t\t\n\t\t/* *THIS* is where we adjust what block we're going to... \n\t\t * but DO NOT TOUCH bp->b_blkno!!! */\n\t\traid_addr = blocknum;\n\t\t\n\t\tnum_blocks = bp->b_bcount >> raidPtr->logBytesPerSector;\n\t\tpb = (bp->b_bcount & raidPtr->sectorMask) ? 1 : 0;\n\t\tsum = raid_addr + num_blocks + pb;\n\t\tif (1 || rf_debugKernelAccess) {\n\t\t\tdb1_printf((\"raid_addr=%d sum=%d num_blocks=%d(+%d) (%d)\\n\",\n\t\t\t\t    (int) raid_addr, (int) sum, (int) num_blocks,\n\t\t\t\t    (int) pb, (int) bp->b_resid));\n\t\t}\n\t\tif ((sum > raidPtr->totalSectors) || (sum < raid_addr)\n\t\t    || (sum < num_blocks) || (sum < pb)) {\n\t\t\tbp->b_error = ENOSPC;\n\t\t\tbp->b_flags |= B_ERROR;\n\t\t\tbp->b_resid = bp->b_bcount;\n\t\t\tbiodone(bp);\n\t\t\tRF_LOCK_MUTEX(raidPtr->mutex);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * XXX rf_DoAccess() should do this, not just DoAccessKernel()\n\t\t */\n\t\t\n\t\tif (bp->b_bcount & raidPtr->sectorMask) {\n\t\t\tbp->b_error = EINVAL;\n\t\t\tbp->b_flags |= B_ERROR;\n\t\t\tbp->b_resid = bp->b_bcount;\n\t\t\tbiodone(bp);\n\t\t\tRF_LOCK_MUTEX(raidPtr->mutex);\n\t\t\tcontinue;\n\t\t\t\n\t\t}\n\t\tdb1_printf((\"Calling DoAccess..\\n\"));\n\t\t\n  \n\t\tRF_LOCK_MUTEX(raidPtr->mutex);\n\t\traidPtr->openings--;\n\t\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\n\t\t/*\n\t\t * Everything is async.\n\t\t */\n\t\tdo_async = 1;\n\t\t\n\t\t/* don't ever condition on bp->b_flags & B_WRITE.  \n\t\t * always condition on B_READ instead */\n\t\t\n\t\t/* XXX we're still at splbio() here... do we *really* \n\t\t   need to be? */\n\n\t\t\n\t\tretcode = rf_DoAccess(raidPtr, (bp->b_flags & B_READ) ?\n\t\t\t\t      RF_IO_TYPE_READ : RF_IO_TYPE_WRITE,\n\t\t\t\t      do_async, raid_addr, num_blocks,\n\t\t\t\t      bp->b_un.b_addr, bp, NULL, NULL, \n\t\t\t\t      RF_DAG_NONBLOCKING_IO, NULL, NULL, NULL);\n\n\n\t\tRF_LOCK_MUTEX(raidPtr->mutex);\n\t}\n\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n}",
    "includes": [
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_kintf.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_dagflags.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_copyback.h\"",
      "#include \"rf_raidframe.h\"",
      "#include \"rf_raid.h\"",
      "#include \"raid.h\"",
      "#include <sys/user.h>",
      "#include <sys/buf.h>",
      "#include <sys/lock.h>",
      "#include <sys/conf.h>",
      "#include <sys/namei.h>",
      "#include <sys/systm.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/device.h>",
      "#include <sys/disk.h>",
      "#include <sys/queue.h>",
      "#include <sys/malloc.h>",
      "#include <sys/param.h>",
      "#include <sys/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct raid_softc *raid_softc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_UNLOCK_MUTEX",
          "args": [
            "raidPtr->mutex"
          ],
          "line": 1470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_LOCK_MUTEX",
          "args": [
            "raidPtr->mutex"
          ],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_DoAccess",
          "args": [
            "raidPtr",
            "(bp->b_flags & B_READ) ?\n\t\t\t\t      RF_IO_TYPE_READ : RF_IO_TYPE_WRITE",
            "do_async",
            "raid_addr",
            "num_blocks",
            "bp->b_un.b_addr",
            "bp",
            "NULL",
            "NULL",
            "RF_DAG_NONBLOCKING_IO",
            "NULL",
            "NULL",
            "NULL"
          ],
          "line": 1461
        },
        "resolved": true,
        "details": {
          "function_name": "rf_DoAccess",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_driver.c",
          "lines": "654-722",
          "snippet": "int \nrf_DoAccess(\n    RF_Raid_t * raidPtr,\n    RF_IoType_t type,\n    int async_flag,\n    RF_RaidAddr_t raidAddress,\n    RF_SectorCount_t numBlocks,\n    caddr_t bufPtr,\n    void *bp_in,\n    RF_DagHeader_t ** paramDAG,\n    RF_AccessStripeMapHeader_t ** paramASM,\n    RF_RaidAccessFlags_t flags,\n    RF_RaidAccessDesc_t ** paramDesc,\n    void (*cbF) (struct buf *),\n    void *cbA)\n/*\ntype should be read or write\nasync_flag should be RF_TRUE or RF_FALSE\nbp_in is a buf pointer.  void * to facilitate ignoring it outside the kernel\n*/\n{\n\tRF_RaidAccessDesc_t *desc;\n\tcaddr_t lbufPtr = bufPtr;\n\tstruct buf *bp = (struct buf *) bp_in;\n\n\traidAddress += rf_raidSectorOffset;\n\n\tif (!raidPtr->valid) {\n\t\tRF_ERRORMSG(\"RAIDframe driver not successfully configured.  Rejecting access.\\n\");\n\t\tIO_BUF_ERR(bp, EINVAL);\n\t\treturn (EINVAL);\n\t}\n\n\tif (rf_accessDebug) {\n\n\t\tprintf(\"logBytes is: %d %d %d\\n\", raidPtr->raidid,\n\t\t    raidPtr->logBytesPerSector,\n\t\t    (int) rf_RaidAddressToByte(raidPtr, numBlocks));\n\t\tprintf(\"raid%d: %s raidAddr %d (stripeid %d-%d) numBlocks %d (%d bytes) buf 0x%lx\\n\", raidPtr->raidid,\n\t\t    (type == RF_IO_TYPE_READ) ? \"READ\" : \"WRITE\", (int) raidAddress,\n\t\t    (int) rf_RaidAddressToStripeID(&raidPtr->Layout, raidAddress),\n\t\t    (int) rf_RaidAddressToStripeID(&raidPtr->Layout, raidAddress + numBlocks - 1),\n\t\t    (int) numBlocks,\n\t\t    (int) rf_RaidAddressToByte(raidPtr, numBlocks),\n\t\t    (long) bufPtr);\n\t}\n\tif (raidAddress + numBlocks > raidPtr->totalSectors) {\n\n\t\tprintf(\"DoAccess: raid addr %lu too large to access %lu sectors.  Max legal addr is %lu\\n\",\n\t\t    (u_long) raidAddress, (u_long) numBlocks, (u_long) raidPtr->totalSectors);\n\n\t\t\tIO_BUF_ERR(bp, ENOSPC);\n\t\t\treturn (ENOSPC);\n\t}\n\tdesc = rf_AllocRaidAccDesc(raidPtr, type, raidAddress,\n\t    numBlocks, lbufPtr, bp, paramDAG, paramASM,\n\t    flags, cbF, cbA, raidPtr->Layout.map->states);\n\n\tif (desc == NULL) {\n\t\treturn (ENOMEM);\n\t}\n\tRF_ETIMER_START(desc->tracerec.tot_timer);\n\n\tdesc->async_flag = async_flag;\n\n\trf_ContinueRaidAccess(desc);\n\n\treturn (0);\n}",
          "includes": [
            "#include <sys/buf.h>",
            "#include \"rf_kintf.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_nwayxor.h\"",
            "#include \"rf_mcpair.h\"",
            "#include \"rf_memchunk.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_callback.h\"",
            "#include \"rf_revent.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_decluster.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_states.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_aselect.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include <sys/errno.h>",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_archs.h\"",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_rad(RF_RaidAccessDesc_t *);",
            "static void clean_rad(RF_RaidAccessDesc_t *);",
            "void rf_UnconfigureVnodes( RF_Raid_t * );"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_options.h\"\n#include \"rf_driver.h\"\n#include \"rf_copyback.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_nwayxor.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_memchunk.h\"\n#include \"rf_engine.h\"\n#include \"rf_callback.h\"\n#include \"rf_revent.h\"\n#include \"rf_map.h\"\n#include \"rf_decluster.h\"\n#include \"rf_freelist.h\"\n#include \"rf_states.h\"\n#include \"rf_desc.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_utils.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_aselect.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n#include \"rf_archs.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic int init_rad(RF_RaidAccessDesc_t *);\nstatic void clean_rad(RF_RaidAccessDesc_t *);\nvoid rf_UnconfigureVnodes( RF_Raid_t * );\n\nint \nrf_DoAccess(\n    RF_Raid_t * raidPtr,\n    RF_IoType_t type,\n    int async_flag,\n    RF_RaidAddr_t raidAddress,\n    RF_SectorCount_t numBlocks,\n    caddr_t bufPtr,\n    void *bp_in,\n    RF_DagHeader_t ** paramDAG,\n    RF_AccessStripeMapHeader_t ** paramASM,\n    RF_RaidAccessFlags_t flags,\n    RF_RaidAccessDesc_t ** paramDesc,\n    void (*cbF) (struct buf *),\n    void *cbA)\n/*\ntype should be read or write\nasync_flag should be RF_TRUE or RF_FALSE\nbp_in is a buf pointer.  void * to facilitate ignoring it outside the kernel\n*/\n{\n\tRF_RaidAccessDesc_t *desc;\n\tcaddr_t lbufPtr = bufPtr;\n\tstruct buf *bp = (struct buf *) bp_in;\n\n\traidAddress += rf_raidSectorOffset;\n\n\tif (!raidPtr->valid) {\n\t\tRF_ERRORMSG(\"RAIDframe driver not successfully configured.  Rejecting access.\\n\");\n\t\tIO_BUF_ERR(bp, EINVAL);\n\t\treturn (EINVAL);\n\t}\n\n\tif (rf_accessDebug) {\n\n\t\tprintf(\"logBytes is: %d %d %d\\n\", raidPtr->raidid,\n\t\t    raidPtr->logBytesPerSector,\n\t\t    (int) rf_RaidAddressToByte(raidPtr, numBlocks));\n\t\tprintf(\"raid%d: %s raidAddr %d (stripeid %d-%d) numBlocks %d (%d bytes) buf 0x%lx\\n\", raidPtr->raidid,\n\t\t    (type == RF_IO_TYPE_READ) ? \"READ\" : \"WRITE\", (int) raidAddress,\n\t\t    (int) rf_RaidAddressToStripeID(&raidPtr->Layout, raidAddress),\n\t\t    (int) rf_RaidAddressToStripeID(&raidPtr->Layout, raidAddress + numBlocks - 1),\n\t\t    (int) numBlocks,\n\t\t    (int) rf_RaidAddressToByte(raidPtr, numBlocks),\n\t\t    (long) bufPtr);\n\t}\n\tif (raidAddress + numBlocks > raidPtr->totalSectors) {\n\n\t\tprintf(\"DoAccess: raid addr %lu too large to access %lu sectors.  Max legal addr is %lu\\n\",\n\t\t    (u_long) raidAddress, (u_long) numBlocks, (u_long) raidPtr->totalSectors);\n\n\t\t\tIO_BUF_ERR(bp, ENOSPC);\n\t\t\treturn (ENOSPC);\n\t}\n\tdesc = rf_AllocRaidAccDesc(raidPtr, type, raidAddress,\n\t    numBlocks, lbufPtr, bp, paramDAG, paramASM,\n\t    flags, cbF, cbA, raidPtr->Layout.map->states);\n\n\tif (desc == NULL) {\n\t\treturn (ENOMEM);\n\t}\n\tRF_ETIMER_START(desc->tracerec.tot_timer);\n\n\tdesc->async_flag = async_flag;\n\n\trf_ContinueRaidAccess(desc);\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_UNLOCK_MUTEX",
          "args": [
            "raidPtr->mutex"
          ],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_LOCK_MUTEX",
          "args": [
            "raidPtr->mutex"
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db1_printf",
          "args": [
            "(\"Calling DoAccess..\\n\")"
          ],
          "line": 1442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_LOCK_MUTEX",
          "args": [
            "raidPtr->mutex"
          ],
          "line": 1438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "biodone",
          "args": [
            "bp"
          ],
          "line": 1437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_LOCK_MUTEX",
          "args": [
            "raidPtr->mutex"
          ],
          "line": 1426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "biodone",
          "args": [
            "bp"
          ],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db1_printf",
          "args": [
            "(\"raid_addr=%d sum=%d num_blocks=%d(+%d) (%d)\\n\",\n\t\t\t\t    (int) raid_addr, (int) sum, (int) num_blocks,\n\t\t\t\t    (int) pb, (int) bp->b_resid)"
          ],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db1_printf",
          "args": [
            "(\"bp->b_resid = %d\\n\", (int) bp->b_resid)"
          ],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db1_printf",
          "args": [
            "(\"bp->b_bcount = %d\\n\", (int) bp->b_bcount)"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db1_printf",
          "args": [
            "(\"Blocks: %d, %d\\n\", (int) bp->b_blkno, \n\t\t\t    (int) blocknum)"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DISKPART",
          "args": [
            "bp->b_dev"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DISKPART",
          "args": [
            "bp->b_dev"
          ],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_UNLOCK_MUTEX",
          "args": [
            "raidPtr->mutex"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_LOCK_MUTEX",
          "args": [
            "raidPtr->mutex"
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\nstruct raid_softc *raid_softc;\n\nvoid\nraidstart(raidPtr)\n\tRF_Raid_t *raidPtr;\n{\n\tRF_SectorCount_t num_blocks, pb, sum;\n\tRF_RaidAddr_t raid_addr;\n\tint retcode;\n\tstruct partition *pp;\n\tdaddr_t blocknum;\t\n\tint unit;\n\tstruct raid_softc *rs;\n\tint\tdo_async;\n\tstruct buf *bp;\n\tstruct buf *dp;\n\n\tunit = raidPtr->raidid;\n\trs = &raid_softc[unit];\n\n\t\n\t/* Check to see if we're at the limit... */\n\tRF_LOCK_MUTEX(raidPtr->mutex);\n\twhile (raidPtr->openings > 0) {\n\t\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n  \n\t\t/* get the next item, if any, from the queue */\n\t\tdp = &rs->buf_queue;\n\t\tbp = dp->b_actf;\n\t\tif (bp == NULL) {\n\t\t\t/* nothing more to do */\n\t\t\treturn;\n\t\t}\n  \n\t\t/* update structures */\n\t\tdp = bp->b_actf;\n\t\tif (dp != NULL) {\n\t\t\tdp->b_actb = bp->b_actb;\n\t\t} else {\n\t\t\trs->buf_queue.b_actb = bp->b_actb;\n\t\t}\n\t\t*bp->b_actb = dp;\n  \n\t\t/* Ok, for the bp we have here, bp->b_blkno is relative to the\n\t\t * partition.. Need to make it absolute to the underlying \n\t\t * device.. */\n  \n\t\tblocknum = bp->b_blkno;\n\t\tif (DISKPART(bp->b_dev) != RAW_PART) {\n\t\t\tpp = &rs->sc_dkdev.dk_label->d_partitions[DISKPART(bp->b_dev)];\n\t\t\tblocknum += pp->p_offset;\n\t\t}\n  \n\t\tdb1_printf((\"Blocks: %d, %d\\n\", (int) bp->b_blkno, \n\t\t\t    (int) blocknum));\n\t\t\n\t\tdb1_printf((\"bp->b_bcount = %d\\n\", (int) bp->b_bcount));\n\t\tdb1_printf((\"bp->b_resid = %d\\n\", (int) bp->b_resid));\n\t\t\n\t\t/* *THIS* is where we adjust what block we're going to... \n\t\t * but DO NOT TOUCH bp->b_blkno!!! */\n\t\traid_addr = blocknum;\n\t\t\n\t\tnum_blocks = bp->b_bcount >> raidPtr->logBytesPerSector;\n\t\tpb = (bp->b_bcount & raidPtr->sectorMask) ? 1 : 0;\n\t\tsum = raid_addr + num_blocks + pb;\n\t\tif (1 || rf_debugKernelAccess) {\n\t\t\tdb1_printf((\"raid_addr=%d sum=%d num_blocks=%d(+%d) (%d)\\n\",\n\t\t\t\t    (int) raid_addr, (int) sum, (int) num_blocks,\n\t\t\t\t    (int) pb, (int) bp->b_resid));\n\t\t}\n\t\tif ((sum > raidPtr->totalSectors) || (sum < raid_addr)\n\t\t    || (sum < num_blocks) || (sum < pb)) {\n\t\t\tbp->b_error = ENOSPC;\n\t\t\tbp->b_flags |= B_ERROR;\n\t\t\tbp->b_resid = bp->b_bcount;\n\t\t\tbiodone(bp);\n\t\t\tRF_LOCK_MUTEX(raidPtr->mutex);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * XXX rf_DoAccess() should do this, not just DoAccessKernel()\n\t\t */\n\t\t\n\t\tif (bp->b_bcount & raidPtr->sectorMask) {\n\t\t\tbp->b_error = EINVAL;\n\t\t\tbp->b_flags |= B_ERROR;\n\t\t\tbp->b_resid = bp->b_bcount;\n\t\t\tbiodone(bp);\n\t\t\tRF_LOCK_MUTEX(raidPtr->mutex);\n\t\t\tcontinue;\n\t\t\t\n\t\t}\n\t\tdb1_printf((\"Calling DoAccess..\\n\"));\n\t\t\n  \n\t\tRF_LOCK_MUTEX(raidPtr->mutex);\n\t\traidPtr->openings--;\n\t\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\n\t\t/*\n\t\t * Everything is async.\n\t\t */\n\t\tdo_async = 1;\n\t\t\n\t\t/* don't ever condition on bp->b_flags & B_WRITE.  \n\t\t * always condition on B_READ instead */\n\t\t\n\t\t/* XXX we're still at splbio() here... do we *really* \n\t\t   need to be? */\n\n\t\t\n\t\tretcode = rf_DoAccess(raidPtr, (bp->b_flags & B_READ) ?\n\t\t\t\t      RF_IO_TYPE_READ : RF_IO_TYPE_WRITE,\n\t\t\t\t      do_async, raid_addr, num_blocks,\n\t\t\t\t      bp->b_un.b_addr, bp, NULL, NULL, \n\t\t\t\t      RF_DAG_NONBLOCKING_IO, NULL, NULL, NULL);\n\n\n\t\tRF_LOCK_MUTEX(raidPtr->mutex);\n\t}\n\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n}"
  },
  {
    "function_name": "rf_GetSpareTableFromDaemon",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_openbsdkintf.c",
    "lines": "1316-1340",
    "snippet": "int\nrf_GetSpareTableFromDaemon(req)\n\tRF_SparetWait_t\t *req;\n{\n\tint retcode;\n\n\tRF_LOCK_MUTEX(rf_sparet_wait_mutex);\n\treq->next = rf_sparet_wait_queue;\n\trf_sparet_wait_queue = req;\n\twakeup(&rf_sparet_wait_queue);\n\n\t/* mpsleep unlocks the mutex */\n\twhile (!rf_sparet_resp_queue) {\n\t\ttsleep(&rf_sparet_resp_queue, PRIBIO,\n\t\t       \"raidframe getsparetable\", 0);\n\t}\n\treq = rf_sparet_resp_queue;\n\trf_sparet_resp_queue = req->next;\n\tRF_UNLOCK_MUTEX(rf_sparet_wait_mutex);\n\n\tretcode = req->fcol;\n\t/* this is not the same req as we alloc'd */\n\tRF_Free(req, sizeof *req);\n\treturn (retcode);\n}",
    "includes": [
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_kintf.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_dagflags.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_copyback.h\"",
      "#include \"rf_raidframe.h\"",
      "#include \"rf_raid.h\"",
      "#include \"raid.h\"",
      "#include <sys/user.h>",
      "#include <sys/buf.h>",
      "#include <sys/lock.h>",
      "#include <sys/conf.h>",
      "#include <sys/namei.h>",
      "#include <sys/systm.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/device.h>",
      "#include <sys/disk.h>",
      "#include <sys/queue.h>",
      "#include <sys/malloc.h>",
      "#include <sys/param.h>",
      "#include <sys/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "RF_DECLARE_STATIC_MUTEX(rf_sparet_wait_mutex)\n\n/* requests to install a spare table */\nstatic RF_SparetWait_t",
      "static RF_SparetWait_t *rf_sparet_resp_queue;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "req",
            "sizeof *req"
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_UNLOCK_MUTEX",
          "args": [
            "rf_sparet_wait_mutex"
          ],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tsleep",
          "args": [
            "&rf_sparet_resp_queue",
            "PRIBIO",
            "\"raidframe getsparetable\"",
            "0"
          ],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "&rf_sparet_wait_queue"
          ],
          "line": 1325
        },
        "resolved": true,
        "details": {
          "function_name": "audio_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "765-774",
          "snippet": "static __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nstatic __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_LOCK_MUTEX",
          "args": [
            "rf_sparet_wait_mutex"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\nRF_DECLARE_STATIC_MUTEX(rf_sparet_wait_mutex)\n\n/* requests to install a spare table */\nstatic RF_SparetWait_t;\nstatic RF_SparetWait_t *rf_sparet_resp_queue;\n\nint\nrf_GetSpareTableFromDaemon(req)\n\tRF_SparetWait_t\t *req;\n{\n\tint retcode;\n\n\tRF_LOCK_MUTEX(rf_sparet_wait_mutex);\n\treq->next = rf_sparet_wait_queue;\n\trf_sparet_wait_queue = req;\n\twakeup(&rf_sparet_wait_queue);\n\n\t/* mpsleep unlocks the mutex */\n\twhile (!rf_sparet_resp_queue) {\n\t\ttsleep(&rf_sparet_resp_queue, PRIBIO,\n\t\t       \"raidframe getsparetable\", 0);\n\t}\n\treq = rf_sparet_resp_queue;\n\trf_sparet_resp_queue = req->next;\n\tRF_UNLOCK_MUTEX(rf_sparet_wait_mutex);\n\n\tretcode = req->fcol;\n\t/* this is not the same req as we alloc'd */\n\tRF_Free(req, sizeof *req);\n\treturn (retcode);\n}"
  },
  {
    "function_name": "raidinit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_openbsdkintf.c",
    "lines": "1269-1304",
    "snippet": "int\nraidinit(dev, raidPtr, unit)\n\tdev_t dev;\n\tRF_Raid_t *raidPtr;\n\tint unit;\n{\n\tint retcode;\n\tstruct raid_softc *rs;\n\n\tretcode = 0;\n\n\trs = &raid_softc[unit];\n\t\n\t/* XXX should check return code first... */\n\trs->sc_flags |= RAIDF_INITED;\n\n\t/* XXX doesn't check bounds.*/\n\tsprintf(rs->sc_xname, \"raid%d\", unit);\n\n\trs->sc_dkdev.dk_name = rs->sc_xname;\t\n\n\t/*\n\t * disk_attach actually creates space for the CPU disklabel, among\n\t * other things, so it's critical to call this *BEFORE* we\n\t * try putzing with disklabels.\n\t */\n\tdisk_attach(&rs->sc_dkdev);\n\n\t/*\n\t * XXX There may be a weird interaction here between this, and\n\t * protectedSectors, as used in RAIDframe.\n\t */\n\trs->sc_size = raidPtr->totalSectors;\n\trs->sc_dev = dev;\n\treturn (retcode);\n}",
    "includes": [
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_kintf.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_dagflags.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_copyback.h\"",
      "#include \"rf_raidframe.h\"",
      "#include \"rf_raid.h\"",
      "#include \"raid.h\"",
      "#include <sys/user.h>",
      "#include <sys/buf.h>",
      "#include <sys/lock.h>",
      "#include <sys/conf.h>",
      "#include <sys/namei.h>",
      "#include <sys/systm.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/device.h>",
      "#include <sys/disk.h>",
      "#include <sys/queue.h>",
      "#include <sys/malloc.h>",
      "#include <sys/param.h>",
      "#include <sys/errno.h>"
    ],
    "macros_used": [
      "#define RAIDF_INITED\t0x01\t/* unit has been initialized */"
    ],
    "globals_used": [
      "static int raidinit",
      "struct raid_softc *raid_softc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "disk_attach",
          "args": [
            "&rs->sc_dkdev"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "rs->sc_xname",
            "\"raid%d\"",
            "unit"
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\n#define RAIDF_INITED\t0x01\t/* unit has been initialized */\n\nstatic int raidinit;\nstruct raid_softc *raid_softc;\n\nint\nraidinit(dev, raidPtr, unit)\n\tdev_t dev;\n\tRF_Raid_t *raidPtr;\n\tint unit;\n{\n\tint retcode;\n\tstruct raid_softc *rs;\n\n\tretcode = 0;\n\n\trs = &raid_softc[unit];\n\t\n\t/* XXX should check return code first... */\n\trs->sc_flags |= RAIDF_INITED;\n\n\t/* XXX doesn't check bounds.*/\n\tsprintf(rs->sc_xname, \"raid%d\", unit);\n\n\trs->sc_dkdev.dk_name = rs->sc_xname;\t\n\n\t/*\n\t * disk_attach actually creates space for the CPU disklabel, among\n\t * other things, so it's critical to call this *BEFORE* we\n\t * try putzing with disklabels.\n\t */\n\tdisk_attach(&rs->sc_dkdev);\n\n\t/*\n\t * XXX There may be a weird interaction here between this, and\n\t * protectedSectors, as used in RAIDframe.\n\t */\n\trs->sc_size = raidPtr->totalSectors;\n\trs->sc_dev = dev;\n\treturn (retcode);\n}"
  },
  {
    "function_name": "raidioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_openbsdkintf.c",
    "lines": "623-1263",
    "snippet": "int\nraidioctl(dev, cmd, data, flag, p)\n\tdev_t dev;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tint unit = raidunit(dev);\n\tint error = 0;\n\tint part, pmask;\n\tstruct raid_softc *rs;\n\tRF_Config_t *k_cfg, *u_cfg;\n\tRF_Raid_t *raidPtr;\n\tRF_AccTotals_t *totals;\n\tRF_DeviceConfig_t *d_cfg, **ucfgp;\n\tu_char *specific_buf;\n\tint retcode = 0;\n\tint row;\n\tint column;\n\tstruct rf_recon_req *rrcopy, *rr;\n\tRF_ComponentLabel_t *component_label;\n\tRF_ComponentLabel_t ci_label;\n\tRF_ComponentLabel_t **c_label_ptr;\n\tRF_SingleComponent_t *sparePtr,*componentPtr;\n\tRF_SingleComponent_t hot_spare;\n\tRF_SingleComponent_t component;\n\tint i, j, d;\n\n\tif (unit >= numraid)\n\t\treturn (ENXIO);\n\trs = &raid_softc[unit];\n\traidPtr = raidPtrs[unit];\n\n\tdb1_printf((\"raidioctl: %d %d %d %d\\n\", (int)dev, (int)DISKPART(dev),\n\t    (int)unit, (int)cmd));\n\n\t/* Must be open for writes for these commands... */\n\tswitch (cmd) {\n\tcase DIOCSDINFO:\n\tcase DIOCWDINFO:\n\tcase DIOCWLABEL:\n\t\tif ((flag & FWRITE) == 0)\n\t\t\treturn (EBADF);\n\t}\n\n\t/* Must be initialized for these... */\n\tswitch (cmd) {\n\tcase DIOCGDINFO:\n\tcase DIOCSDINFO:\n\tcase DIOCWDINFO:\n\tcase DIOCGPART:\n\tcase DIOCWLABEL:\n\tcase RAIDFRAME_SHUTDOWN:\n\tcase RAIDFRAME_REWRITEPARITY:\n\tcase RAIDFRAME_GET_INFO:\n\tcase RAIDFRAME_RESET_ACCTOTALS:\n\tcase RAIDFRAME_GET_ACCTOTALS:\n\tcase RAIDFRAME_KEEP_ACCTOTALS:\n\tcase RAIDFRAME_GET_SIZE:\n\tcase RAIDFRAME_FAIL_DISK:\n\tcase RAIDFRAME_COPYBACK:\n\tcase RAIDFRAME_CHECK_RECON_STATUS:\n\tcase RAIDFRAME_GET_COMPONENT_LABEL:\n\tcase RAIDFRAME_SET_COMPONENT_LABEL:\n\tcase RAIDFRAME_ADD_HOT_SPARE:\n\tcase RAIDFRAME_REMOVE_HOT_SPARE:\n\tcase RAIDFRAME_INIT_LABELS:\n\tcase RAIDFRAME_REBUILD_IN_PLACE:\n\tcase RAIDFRAME_CHECK_PARITY:\n\tcase RAIDFRAME_CHECK_PARITYREWRITE_STATUS:\n\tcase RAIDFRAME_CHECK_COPYBACK_STATUS:\n\t\tif ((rs->sc_flags & RAIDF_INITED) == 0)\n\t\t\treturn (ENXIO);\n\t}\n\t\n\tswitch (cmd) {\n\t\t/* Configure the system */\n\tcase RAIDFRAME_CONFIGURE:\n\t\t/*\n\t\t * Copy-in the configuration information\n\t\t * data points to a pointer to the configuration structure.\n\t\t */\n\t\tu_cfg = *((RF_Config_t **)data);\n\t\tRF_Malloc(k_cfg, sizeof (RF_Config_t), (RF_Config_t *));\n\t\tif (k_cfg == NULL) {\n\t\t\treturn (ENOMEM);\n\t\t}\n\t\tretcode = copyin((caddr_t)u_cfg, (caddr_t)k_cfg,\n\t\t    sizeof (RF_Config_t));\n\t\tif (retcode) {\n\t\t\tRF_Free(k_cfg, sizeof(RF_Config_t));\n\t\t\treturn (retcode);\n\t\t}\n\n\t\t/*\n\t\t * Allocate a buffer for the layout-specific data,\n\t\t * and copy it in.\n\t\t */\n\t\tif (k_cfg->layoutSpecificSize) {\n\t\t\tif (k_cfg->layoutSpecificSize > 10000) {\n\t\t\t\t/* sanity check */\n\t\t\t\tRF_Free(k_cfg, sizeof(RF_Config_t));\n\t\t\t\treturn (EINVAL);\n\t\t\t}\n\t\t\tRF_Malloc(specific_buf, k_cfg->layoutSpecificSize,\n\t\t\t    (u_char *));\n\t\t\tif (specific_buf == NULL) {\n\t\t\t\tRF_Free(k_cfg, sizeof (RF_Config_t));\n\t\t\t\treturn (ENOMEM);\n\t\t\t}\n\t\t\tretcode = copyin(k_cfg->layoutSpecific,\n\t\t\t    (caddr_t)specific_buf, k_cfg->layoutSpecificSize);\n\t\t\tif (retcode) {\n\t\t\t\tRF_Free(k_cfg, sizeof(RF_Config_t));\n\t\t\t\tRF_Free(specific_buf, \n\t\t\t\t\tk_cfg->layoutSpecificSize);\n\t\t\t\treturn (retcode);\n\t\t\t}\n\t\t} else\n\t\t\tspecific_buf = NULL;\n\t\tk_cfg->layoutSpecific = specific_buf;\n\t\t\n\t\t/*\n\t\t * We should do some kind of sanity check on the\n\t\t * configuration.\n\t\t * Store the sum of all the bytes in the last byte?\n\t\t */\n\n\t\t/* configure the system */\n\t\traidPtr->raidid = unit;\n\n\t\tretcode = rf_Configure(raidPtr, k_cfg);\n\n\t\tif (retcode == 0) {\n\n\t\t\t/* allow this many simultaneous IO's to\n\t\t\t   this RAID device */\n\t\t\traidPtr->openings = RAIDOUTSTANDING;\n\n\t\t\t/* XXX should be moved to rf_Configure() */\n\n\t\t\traidPtr->copyback_in_progress = 0;\n\t\t\traidPtr->parity_rewrite_in_progress = 0;\n\t\t\traidPtr->recon_in_progress = 0;\n\t\t\n\t\t\tretcode = raidinit(dev, raidPtr, unit);\n\t\t\trf_markalldirty( raidPtr );\n\t\t}\n\n\t\t/* Free the buffers.  No return code here. */\n\t\tif (k_cfg->layoutSpecificSize) {\n\t\t\tRF_Free(specific_buf, k_cfg->layoutSpecificSize);\n\t\t}\n\t\tRF_Free(k_cfg, sizeof (RF_Config_t));\n\t\t\n\t\treturn (retcode);\n\t\t\n\tcase RAIDFRAME_SHUTDOWN:\n\t\t/* Shutdown the system */\n\t\t\n\t\tif ((error = raidlock(rs)) != 0)\n\t\t\treturn (error);\n\n\t\t/*\n\t\t * If somebody has a partition mounted, we shouldn't\n\t\t * shutdown.\n\t\t */\n\n\t\tpart = DISKPART(dev);\n\t\tpmask = (1 << part);\n\t\tif ((rs->sc_dkdev.dk_openmask & ~pmask) ||\n\t\t    ((rs->sc_dkdev.dk_bopenmask & pmask) &&\n\t\t    (rs->sc_dkdev.dk_copenmask & pmask))) {\n\t\t\traidunlock(rs);\n\t\t\treturn (EBUSY);\n\t\t}\n\n\t\tretcode = rf_Shutdown(raidPtr);\n\n\t\t/* It's no longer initialized... */\n\t\trs->sc_flags &= ~RAIDF_INITED;\n\n\t\t/* Detach the disk. */\n\t\tdisk_detach(&rs->sc_dkdev);\n\n\t\traidunlock(rs);\n\n\t\treturn (retcode);\n\t\t\n\tcase RAIDFRAME_GET_COMPONENT_LABEL:\n\t\tc_label_ptr = (RF_ComponentLabel_t **) data;\n\t\t/* need to read the component label for the disk indicated\n\t\t   by row,column in component_label */\n\n\t\t/* For practice, let's get it directly fromdisk, rather \n\t\t   than from the in-core copy */\n\t\tRF_Malloc( component_label, sizeof( RF_ComponentLabel_t ),\n\t\t\t   (RF_ComponentLabel_t *));\n\t\tif (component_label == NULL)\n\t\t\treturn (ENOMEM);\n\n\t\tbzero((char *) component_label, sizeof(RF_ComponentLabel_t));\n\n\t\tretcode = copyin( *c_label_ptr, component_label, \n\t\t\t\t  sizeof(RF_ComponentLabel_t));\n\n\t\tif (retcode) {\n\t\t\tRF_Free( component_label, sizeof(RF_ComponentLabel_t));\n\t\t\treturn(retcode);\n\t\t}\n \n \t\trow = component_label->row;\n\t\tcolumn = component_label->column;\n\n\t\tif ((row < 0) || (row >= raidPtr->numRow) ||\n\t\t    (column < 0) || (column >= raidPtr->numCol)) {\n\t\t\treturn(EINVAL);\n  \t\t}\n\n\t\traidread_component_label( \n                              raidPtr->Disks[row][column].dev, \n\t\t\t      raidPtr->raid_cinfo[row][column].ci_vp, \n\t\t\t      component_label );\n\n\t\tretcode = copyout((caddr_t) component_label, \n\t\t\t\t  (caddr_t) *c_label_ptr,\n\t\t\t\t  sizeof(RF_ComponentLabel_t));\n\t\tRF_Free( component_label, sizeof(RF_ComponentLabel_t));\n\t\treturn (retcode);\n\n\tcase RAIDFRAME_SET_COMPONENT_LABEL:\n\t\tcomponent_label = (RF_ComponentLabel_t *) data;\n\n\t\t/* XXX check the label for valid stuff... */\n\t\t/* Note that some things *should not* get modified --\n\t\t   the user should be re-initing the labels instead of \n\t\t   trying to patch things.\n\t\t   */\n\n\t\tprintf(\"Got component label:\\n\");\n\t\tprintf(\"Version: %d\\n\",component_label->version);\n\t\tprintf(\"Serial Number: %d\\n\",component_label->serial_number);\n\t\tprintf(\"Mod counter: %d\\n\",component_label->mod_counter);\n\t\tprintf(\"Row: %d\\n\", component_label->row);\n\t\tprintf(\"Column: %d\\n\", component_label->column);\n\t\tprintf(\"Num Rows: %d\\n\", component_label->num_rows);\n\t\tprintf(\"Num Columns: %d\\n\", component_label->num_columns);\n\t\tprintf(\"Clean: %d\\n\", component_label->clean);\n\t\tprintf(\"Status: %d\\n\", component_label->status);\n\n\t\trow = component_label->row;\n\t\tcolumn = component_label->column;\n\n\t\tif ((row < 0) || (row >= raidPtr->numRow) ||\n\t\t    (column < 0) || (column >= raidPtr->numCol)) {\n\t\t\tRF_Free( component_label, sizeof(RF_ComponentLabel_t));\n\t\t\treturn(EINVAL);\n\t\t}\n\n \t\t/* XXX this isn't allowed to do anything for now :-) */\n#if 0\n\t\traidwrite_component_label( \n                            raidPtr->Disks[row][column].dev, \n\t\t\t    raidPtr->raid_cinfo[row][column].ci_vp, \n\t\t\t    component_label );\n#endif\n\t\treturn (0);\n\n\tcase RAIDFRAME_INIT_LABELS:\t\n\t\tcomponent_label = (RF_ComponentLabel_t *) data;\n\t\t/* \n\t\t   we only want the serial number from\n\t\t   the above.  We get all the rest of the information\n\t\t   from the config that was used to create this RAID\n\t\t   set. \n\t\t   */\n\n\t\traidPtr->serial_number = component_label->serial_number;\n\t\t/* current version number */\n\t\tci_label.version = RF_COMPONENT_LABEL_VERSION; \n\t\tci_label.serial_number = component_label->serial_number;\n\t\tci_label.mod_counter = raidPtr->mod_counter;\n\t\tci_label.num_rows = raidPtr->numRow;\n\t\tci_label.num_columns = raidPtr->numCol;\n\t\tci_label.clean = RF_RAID_DIRTY; /* not clean */\n\t\tci_label.status = rf_ds_optimal; /* \"It's good!\" */\n\n\t\tfor(row=0;row<raidPtr->numRow;row++) {\n\t\t\tci_label.row = row;\n\t\t\tfor(column=0;column<raidPtr->numCol;column++) {\n\t\t\t\tci_label.column = column;\n\t\t\t\traidwrite_component_label( \n\t\t\t\t  raidPtr->Disks[row][column].dev, \n\t\t\t\t  raidPtr->raid_cinfo[row][column].ci_vp, \n\t\t\t\t  &ci_label );\n\t\t\t}\n\t\t}\n\n\t\treturn (retcode);\n  \n\tcase RAIDFRAME_REWRITEPARITY:\n\n\t\tif (raidPtr->Layout.map->faultsTolerated == 0) {\n\t\t\t/* Parity for RAID 0 is trivially correct */\n\t\t\traidPtr->parity_good = RF_RAID_CLEAN;\n\t\t\treturn(0);\n\t\t}\n\n\t\t\n\t\tif (raidPtr->parity_rewrite_in_progress == 1) {\n\t\t\t/* Re-write is already in progress! */\n\t\t\treturn(EINVAL);\n\t\t}\n\n\t\tretcode = RF_CREATE_THREAD(raidPtr->parity_rewrite_thread,\n\t\t\t\t\t   rf_RewriteParityThread,\n\t\t\t\t\t   raidPtr,\"raid_parity\");\n\n\t\treturn (retcode);\n\n\n\tcase RAIDFRAME_ADD_HOT_SPARE:\n\t\tsparePtr = (RF_SingleComponent_t *) data;\n\t\tmemcpy( &hot_spare, sparePtr, sizeof(RF_SingleComponent_t));\n\t\tprintf(\"Adding spare\\n\");\n\t\tretcode = rf_add_hot_spare(raidPtr, &hot_spare);\n\t\treturn(retcode);\n\n\tcase RAIDFRAME_REMOVE_HOT_SPARE:\n\t\treturn(retcode);\n\n\tcase RAIDFRAME_REBUILD_IN_PLACE:\n\n\t\tif (raidPtr->Layout.map->faultsTolerated == 0) {\n\t\t\t/* Can't do this on a RAID 0!! */\n\t\t\treturn(EINVAL);\n\t\t}\n\n\t\tif (raidPtr->recon_in_progress == 1) {\n\t\t\t/* a reconstruct is already in progress! */\n\t\t\treturn(EINVAL);\n\t\t}\n\n\t\tcomponentPtr = (RF_SingleComponent_t *) data;\n\t\tmemcpy( &component, componentPtr, \n\t\t\tsizeof(RF_SingleComponent_t));\n\t\trow = component.row;\n\t\tcolumn = component.column;\n\t\tprintf(\"Rebuild: %d %d\\n\",row, column);\n\t\tif ((row < 0) || (row >= raidPtr->numRow) ||\n\t\t    (column < 0) || (column >= raidPtr->numCol)) {\n\t\t\treturn(EINVAL);\n\t\t}\n\n\t\tRF_Malloc(rrcopy, sizeof(*rrcopy), (struct rf_recon_req *));\n\t\tif (rrcopy == NULL)\n\t\t\treturn(ENOMEM);\n\n\t\trrcopy->raidPtr = (void *) raidPtr;\n\t\trrcopy->row = row;\n\t\trrcopy->col = column;\n\n\t\tretcode = RF_CREATE_THREAD(raidPtr->recon_thread,\n\t\t\t\t\t   rf_ReconstructInPlaceThread,\n\t\t\t\t\t   rrcopy,\"raid_reconip\");\n\n\t\treturn (retcode);\n\n\tcase RAIDFRAME_GET_INFO:\n\t\tif (!raidPtr->valid)\n\t\t\treturn (ENODEV);\n\t\tucfgp = (RF_DeviceConfig_t **) data;\n\t\tRF_Malloc(d_cfg, sizeof(RF_DeviceConfig_t),\n\t\t\t  (RF_DeviceConfig_t *));\n\t\tif (d_cfg == NULL)\n\t\t\treturn (ENOMEM);\n\t\tbzero((char *) d_cfg, sizeof(RF_DeviceConfig_t));\n\t\td_cfg->rows = raidPtr->numRow;\n\t\td_cfg->cols = raidPtr->numCol;\n\t\td_cfg->ndevs = raidPtr->numRow * raidPtr->numCol;\n\t\tif (d_cfg->ndevs >= RF_MAX_DISKS) {\n\t\t\tRF_Free(d_cfg, sizeof(RF_DeviceConfig_t));\n\t\t\treturn (ENOMEM);\n\t\t}\n\t\td_cfg->nspares = raidPtr->numSpare;\n\t\tif (d_cfg->nspares >= RF_MAX_DISKS) {\n\t\t\tRF_Free(d_cfg, sizeof(RF_DeviceConfig_t));\n\t\t\treturn (ENOMEM);\n\t\t}\n\t\td_cfg->maxqdepth = raidPtr->maxQueueDepth;\n\t\td = 0;\n\t\tfor (i = 0; i < d_cfg->rows; i++) {\n\t\t\tfor (j = 0; j < d_cfg->cols; j++) {\n\t\t\t\td_cfg->devs[d] = raidPtr->Disks[i][j];\n\t\t\t\td++;\n\t\t\t}\n\t\t}\n\t\tfor (j = d_cfg->cols, i = 0; i < d_cfg->nspares; i++, j++) {\n\t\t\td_cfg->spares[i] = raidPtr->Disks[0][j];\n\t\t}\n\t\tretcode = copyout((caddr_t) d_cfg, (caddr_t) * ucfgp,\n\t\t\t\t  sizeof(RF_DeviceConfig_t));\n\t\tRF_Free(d_cfg, sizeof(RF_DeviceConfig_t));\n\n\t\treturn (retcode);\n\n\tcase RAIDFRAME_CHECK_PARITY:\n\t\t*(int *) data = raidPtr->parity_good;\n\t\treturn (0);\n\tcase RAIDFRAME_RESET_ACCTOTALS:\n\t\tbzero(&raidPtr->acc_totals, sizeof(raidPtr->acc_totals));\n\t\treturn (0);\n  \n  \tcase RAIDFRAME_GET_ACCTOTALS:\n\t\ttotals = (RF_AccTotals_t *) data;\n\t\t*totals = raidPtr->acc_totals;\n\t\treturn (0);\n\n\tcase RAIDFRAME_KEEP_ACCTOTALS:\n\t\traidPtr->keep_acc_totals = *(int *)data;\n\t\treturn (0);\n  \n\tcase RAIDFRAME_GET_SIZE:\n\t\t*(int *) data = raidPtr->totalSectors;\n\t\treturn (0);\n\n\t\t/* fail a disk & optionally start reconstruction */\n\tcase RAIDFRAME_FAIL_DISK:\n\t\trr = (struct rf_recon_req *)data;\n\t\t\n\t\tif (rr->row < 0 || rr->row >= raidPtr->numRow ||\n\t\t    rr->col < 0 || rr->col >= raidPtr->numCol)\n\t\t\treturn (EINVAL);\n\n\t\tprintf(\"raid%d: Failing the disk: row: %d col: %d\\n\",\n\t\t       unit, rr->row, rr->col);\n\t\t\n\t\t/*\n\t\t * Make a copy of the recon request so that we don't\n\t\t * rely on the user's buffer\n\t\t */\n\t\tRF_Malloc(rrcopy, sizeof(*rrcopy), (struct rf_recon_req *));\n\t\tif (rrcopy == NULL)\n\t\t\treturn(ENOMEM);\n\t\tbcopy(rr, rrcopy, sizeof(*rr));\n\t\trrcopy->raidPtr = (void *)raidPtr;\n\n\t\tretcode = RF_CREATE_THREAD(raidPtr->recon_thread,\n\t\t\t\t\t   rf_ReconThread,\n\t\t\t\t\t   rrcopy,\"raid_recon\");\n\t\treturn (0);\n\t\t\n\t\t/*\n\t\t * Invoke a copyback operation after recon on whatever\n\t\t * disk needs it, if any.\n\t\t */\n\tcase RAIDFRAME_COPYBACK:\t\t\n\t\tif (raidPtr->Layout.map->faultsTolerated == 0) {\n\t\t\t/* This makes no sense on a RAID 0!! */\n\t\t\treturn(EINVAL);\n\t\t}\n  \n\t\tif (raidPtr->copyback_in_progress == 1) {\n\t\t\t/* Copyback is already in progress! */\n\t\t\treturn(EINVAL);\n\t\t}\n  \n\t\tretcode = RF_CREATE_THREAD(raidPtr->copyback_thread,\n\t\t\t\t\t   rf_CopybackThread,\n\t\t\t\t\t   raidPtr,\"raid_copyback\");\n\t\treturn (retcode);\n\t\t\n\t\t/* Return the percentage completion of reconstruction */\n\tcase RAIDFRAME_CHECK_RECON_STATUS:\n\t\tif (raidPtr->Layout.map->faultsTolerated == 0) {\n\t\t\t/* This makes no sense on a RAID 0 */\n\t\t\treturn(EINVAL);\n\t\t}\n\t\trow = 0; /* XXX we only consider a single row... */\n\t\tif (raidPtr->status[row] != rf_rs_reconstructing)\n\t\t\t*(int *)data = 100;\n\t\telse\n\t\t\t*(int *)data =\n\t\t\t    raidPtr->reconControl[row]->percentComplete;\n\t\treturn (0);\n\tcase RAIDFRAME_CHECK_PARITYREWRITE_STATUS:\n\t\tif (raidPtr->Layout.map->faultsTolerated == 0) {\n\t\t\t/* This makes no sense on a RAID 0 */\n\t\t\treturn(EINVAL);\n\t\t}\n\t\tif (raidPtr->parity_rewrite_in_progress == 1) {\n\t\t\t*(int *) data = 100 * raidPtr->parity_rewrite_stripes_done / raidPtr->Layout.numStripe;\n\t\t} else {\n\t\t\t*(int *) data = 100;\n\t\t}\n\t\treturn (0);\n\n\tcase RAIDFRAME_CHECK_COPYBACK_STATUS:\n\t\tif (raidPtr->Layout.map->faultsTolerated == 0) {\n\t\t\t/* This makes no sense on a RAID 0 */\n\t\t\treturn(EINVAL);\n\t\t}\n\t\tif (raidPtr->copyback_in_progress == 1) {\n\t\t\t*(int *) data = 100 * raidPtr->copyback_stripes_done / raidPtr->Layout.numStripe;\n\t\t} else {\n\t\t\t*(int *) data = 100;\n\t\t}\n\t\treturn (0);\n\n#if 0\n\tcase RAIDFRAME_SPARET_WAIT:\n\t\t/*\n\t\t * The sparetable daemon calls this to wait for the\n\t\t * kernel to need a spare table.\n\t\t * This ioctl does not return until a spare table is needed.\n\t\t * XXX -- Calling mpsleep here in the ioctl code is almost\n\t\t * certainly wrong and evil. -- XXX\n\t\t * XXX -- I should either compute the spare table in the\n\t\t * kernel, or have a different. -- XXX\n\t\t * XXX -- Interface (a different character device) for\n\t\t * delivering the table. -- XXX\n\t\t */\n\t\tRF_LOCK_MUTEX(rf_sparet_wait_mutex);\n\t\twhile (!rf_sparet_wait_queue)\n\t\t\tmpsleep(&rf_sparet_wait_queue, (PZERO + 1) | PCATCH,\n\t\t\t    \"sparet wait\", 0,\n\t\t\t    (void *)simple_lock_addr(rf_sparet_wait_mutex),\n\t\t\t    MS_LOCK_SIMPLE);\n\t\twaitreq = rf_sparet_wait_queue;\n\t\trf_sparet_wait_queue = rf_sparet_wait_queue->next;\n\t\tRF_UNLOCK_MUTEX(rf_sparet_wait_mutex);\n\t\t\n\t\t*((RF_SparetWait_t *)data) = *waitreq;\n\t\t\n\t\tRF_Free(waitreq, sizeof *waitreq);\n\t\treturn (0);\n\t\t\n\tcase RAIDFRAME_ABORT_SPARET_WAIT:\n\t\t/*\n\t\t * Wakes up a process waiting on SPARET_WAIT and puts an\n\t\t * error code in it that will cause the dameon to exit.\n\t\t */\n\t\tRF_Malloc(waitreq, sizeof (*waitreq), (RF_SparetWait_t *));\n\t\twaitreq->fcol = -1;\n\t\tRF_LOCK_MUTEX(rf_sparet_wait_mutex);\n\t\twaitreq->next = rf_sparet_wait_queue;\n\t\trf_sparet_wait_queue = waitreq;\n\t\tRF_UNLOCK_MUTEX(rf_sparet_wait_mutex);\n\t\twakeup(&rf_sparet_wait_queue);\n\t\treturn (0);\n\n\tcase RAIDFRAME_SEND_SPARET:\n\t\t/*\n\t\t * Used by the spare table daemon to deliver a spare table\n\t\t * into the kernel\n\t\t */\n\t\t\n\t\t/* Install the spare table */\n\t\tretcode = rf_SetSpareTable(raidPtr,*(void **)data);\n\t\t\n\t\t/*\n\t\t * Respond to the requestor.  the return status of the\n\t\t * spare table installation is passed in the \"fcol\" field\n\t\t */\n\t\tRF_Malloc(waitreq, sizeof *waitreq, (RF_SparetWait_t *));\n\t\twaitreq->fcol = retcode;\n\t\tRF_LOCK_MUTEX(rf_sparet_wait_mutex);\n\t\twaitreq->next = rf_sparet_resp_queue;\n\t\trf_sparet_resp_queue = waitreq;\n\t\twakeup(&rf_sparet_resp_queue);\n\t\tRF_UNLOCK_MUTEX(rf_sparet_wait_mutex);\n\t\t\n\t\treturn (retcode);\n#endif\n\tdefault:\n\t\t/* fall through to the os-specific code below */\n\t\tbreak;\n\t}\n\t\n\tif (!raidPtr->valid)\n\t\treturn (EINVAL);\n\t\n\t/*\n\t * Add support for \"regular\" device ioctls here.\n\t */\n\tswitch (cmd) {\n\tcase DIOCGDINFO:\n\t\t*(struct disklabel *)data = *(rs->sc_dkdev.dk_label);\n\t\tbreak;\n\n\tcase DIOCGPART:\n\t\t((struct partinfo *)data)->disklab = rs->sc_dkdev.dk_label;\n\t\t((struct partinfo *)data)->part =\n\t\t    &rs->sc_dkdev.dk_label->d_partitions[DISKPART(dev)];\n\t\tbreak;\n\n\tcase DIOCWDINFO:\n\tcase DIOCSDINFO:\n\t\tif ((error = raidlock(rs)) != 0)\n\t\t\treturn (error);\n\n\t\trs->sc_flags |= RAIDF_LABELLING;\n\n\t\terror = setdisklabel(rs->sc_dkdev.dk_label,\n\t\t    (struct disklabel *)data, 0, rs->sc_dkdev.dk_cpulabel);\n\t\tif (error == 0) {\n\t\t\tif (cmd == DIOCWDINFO)\n\t\t\t\terror = writedisklabel(RAIDLABELDEV(dev),\n\t\t\t\t    raidstrategy, rs->sc_dkdev.dk_label,\n\t\t\t\t    rs->sc_dkdev.dk_cpulabel);\n\t\t}\n\n\t\trs->sc_flags &= ~RAIDF_LABELLING;\n\n\t\traidunlock(rs);\n\n\t\tif (error)\n\t\t\treturn (error);\n\t\tbreak;\n\n\tcase DIOCWLABEL:\n\t\tif (*(int *)data != 0)\n\t\t\trs->sc_flags |= RAIDF_WLABEL;\n\t\telse\n\t\t\trs->sc_flags &= ~RAIDF_WLABEL;\n\t\tbreak;\n\n#if 0\n  \tcase DIOCGDEFLABEL:\n  \t\traidgetdefaultlabel(raidPtr, rs,\n  \t\t    (struct disklabel *) data);\n  \t\tbreak;\n#endif\n  \n\n\tdefault:\n\t\tretcode = ENOTTY;\n\t}\n\treturn (retcode);\n}",
    "includes": [
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_kintf.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_dagflags.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_copyback.h\"",
      "#include \"rf_raidframe.h\"",
      "#include \"rf_raid.h\"",
      "#include \"raid.h\"",
      "#include <sys/user.h>",
      "#include <sys/buf.h>",
      "#include <sys/lock.h>",
      "#include <sys/conf.h>",
      "#include <sys/namei.h>",
      "#include <sys/systm.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/device.h>",
      "#include <sys/disk.h>",
      "#include <sys/queue.h>",
      "#include <sys/malloc.h>",
      "#include <sys/param.h>",
      "#include <sys/errno.h>"
    ],
    "macros_used": [
      "#define RAIDOUTSTANDING   6",
      "#define RAIDF_LABELLING\t0x04\t/* unit is currently being labelled */",
      "#define RAIDF_WLABEL\t0x02\t/* label area is writable */",
      "#define RAIDF_INITED\t0x01\t/* unit has been initialized */"
    ],
    "globals_used": [
      "static RF_Raid_t **raidPtrs;",
      "RF_DECLARE_STATIC_MUTEX(rf_sparet_wait_mutex)\n\n/* requests to install a spare table */\nstatic RF_SparetWait_t",
      "static RF_SparetWait_t *rf_sparet_resp_queue;",
      "static int raidinit",
      "int\traidioctl",
      "void\traidstrategy",
      "static int numraid = 0;",
      "struct raid_softc *raid_softc;",
      "void\traidgetdefaultlabel",
      "int\traidlock",
      "void\traidunlock",
      "void\trf_markalldirty",
      "void rf_ReconThread",
      "void rf_RewriteParityThread",
      "void rf_CopybackThread",
      "void rf_ReconstructInPlaceThread"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raidgetdefaultlabel",
          "args": [
            "raidPtr",
            "rs",
            "(struct disklabel *) data"
          ],
          "line": 1253
        },
        "resolved": true,
        "details": {
          "function_name": "raidgetdefaultlabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_openbsdkintf.c",
          "lines": "1731-1765",
          "snippet": "void\nraidgetdefaultlabel(raidPtr, rs, lp)\n\tRF_Raid_t *raidPtr;\n\tstruct raid_softc *rs;\n\tstruct disklabel *lp;\n{\n\tdb1_printf((\"Building a default label...\\n\"));\n\tbzero(lp, sizeof(*lp));\n\n\t/* fabricate a label... */\n\tlp->d_secperunit = raidPtr->totalSectors;\n\tlp->d_secsize = raidPtr->bytesPerSector;\n\tlp->d_nsectors = raidPtr->Layout.dataSectorsPerStripe;\n\tlp->d_ntracks = 1;\n\tlp->d_ncylinders = raidPtr->totalSectors / \n\t\t(lp->d_nsectors * lp->d_ntracks);\n\tlp->d_secpercyl = lp->d_ntracks * lp->d_nsectors;\n\n\tstrncpy(lp->d_typename, \"raid\", sizeof(lp->d_typename));\n\tlp->d_type = DTYPE_RAID;\n\tstrncpy(lp->d_packname, \"fictitious\", sizeof(lp->d_packname));\n\tlp->d_rpm = 3600;\n\tlp->d_interleave = 1;\n\tlp->d_flags = 0;\n\n\tlp->d_partitions[RAW_PART].p_offset = 0;\n\tlp->d_partitions[RAW_PART].p_size = raidPtr->totalSectors;\n\tlp->d_partitions[RAW_PART].p_fstype = FS_UNUSED;\n\tlp->d_npartitions = RAW_PART + 1;\n\n\tlp->d_magic = DISKMAGIC;\n\tlp->d_magic2 = DISKMAGIC;\n\tlp->d_checksum = dkcksum(rs->sc_dkdev.dk_label);\n\n}",
          "includes": [
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_dagflags.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_raidframe.h\"",
            "#include \"rf_raid.h\"",
            "#include \"raid.h\"",
            "#include <sys/user.h>",
            "#include <sys/buf.h>",
            "#include <sys/lock.h>",
            "#include <sys/conf.h>",
            "#include <sys/namei.h>",
            "#include <sys/systm.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/device.h>",
            "#include <sys/disk.h>",
            "#include <sys/queue.h>",
            "#include <sys/malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct raid_softc *raid_softc;",
            "void\traidgetdefaultlabel"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\nstruct raid_softc *raid_softc;\nvoid\traidgetdefaultlabel;\n\nvoid\nraidgetdefaultlabel(raidPtr, rs, lp)\n\tRF_Raid_t *raidPtr;\n\tstruct raid_softc *rs;\n\tstruct disklabel *lp;\n{\n\tdb1_printf((\"Building a default label...\\n\"));\n\tbzero(lp, sizeof(*lp));\n\n\t/* fabricate a label... */\n\tlp->d_secperunit = raidPtr->totalSectors;\n\tlp->d_secsize = raidPtr->bytesPerSector;\n\tlp->d_nsectors = raidPtr->Layout.dataSectorsPerStripe;\n\tlp->d_ntracks = 1;\n\tlp->d_ncylinders = raidPtr->totalSectors / \n\t\t(lp->d_nsectors * lp->d_ntracks);\n\tlp->d_secpercyl = lp->d_ntracks * lp->d_nsectors;\n\n\tstrncpy(lp->d_typename, \"raid\", sizeof(lp->d_typename));\n\tlp->d_type = DTYPE_RAID;\n\tstrncpy(lp->d_packname, \"fictitious\", sizeof(lp->d_packname));\n\tlp->d_rpm = 3600;\n\tlp->d_interleave = 1;\n\tlp->d_flags = 0;\n\n\tlp->d_partitions[RAW_PART].p_offset = 0;\n\tlp->d_partitions[RAW_PART].p_size = raidPtr->totalSectors;\n\tlp->d_partitions[RAW_PART].p_fstype = FS_UNUSED;\n\tlp->d_npartitions = RAW_PART + 1;\n\n\tlp->d_magic = DISKMAGIC;\n\tlp->d_magic2 = DISKMAGIC;\n\tlp->d_checksum = dkcksum(rs->sc_dkdev.dk_label);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "raidunlock",
          "args": [
            "rs"
          ],
          "line": 1238
        },
        "resolved": true,
        "details": {
          "function_name": "raidunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_openbsdkintf.c",
          "lines": "1918-1927",
          "snippet": "void\nraidunlock(rs)\n\tstruct raid_softc *rs;\n{\n\trs->sc_flags &= ~RAIDF_LOCKED;\n\tif ((rs->sc_flags & RAIDF_WANTED) != 0) {\n\t\trs->sc_flags &= ~RAIDF_WANTED;\n\t\twakeup(rs);\n\t}\n}",
          "includes": [
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_dagflags.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_raidframe.h\"",
            "#include \"rf_raid.h\"",
            "#include \"raid.h\"",
            "#include <sys/user.h>",
            "#include <sys/buf.h>",
            "#include <sys/lock.h>",
            "#include <sys/conf.h>",
            "#include <sys/namei.h>",
            "#include <sys/systm.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/device.h>",
            "#include <sys/disk.h>",
            "#include <sys/queue.h>",
            "#include <sys/malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/errno.h>"
          ],
          "macros_used": [
            "#define RAIDF_LOCKED\t0x80\t/* unit is locked */",
            "#define RAIDF_WANTED\t0x40\t/* someone is waiting to obtain a lock */"
          ],
          "globals_used": [
            "struct raid_softc *raid_softc;",
            "void\traidunlock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\n#define RAIDF_LOCKED\t0x80\t/* unit is locked */\n#define RAIDF_WANTED\t0x40\t/* someone is waiting to obtain a lock */\n\nstruct raid_softc *raid_softc;\nvoid\traidunlock;\n\nvoid\nraidunlock(rs)\n\tstruct raid_softc *rs;\n{\n\trs->sc_flags &= ~RAIDF_LOCKED;\n\tif ((rs->sc_flags & RAIDF_WANTED) != 0) {\n\t\trs->sc_flags &= ~RAIDF_WANTED;\n\t\twakeup(rs);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "writedisklabel",
          "args": [
            "RAIDLABELDEV(dev)",
            "raidstrategy",
            "rs->sc_dkdev.dk_label",
            "rs->sc_dkdev.dk_cpulabel"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAIDLABELDEV",
          "args": [
            "dev"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setdisklabel",
          "args": [
            "rs->sc_dkdev.dk_label",
            "(struct disklabel *)data",
            "0",
            "rs->sc_dkdev.dk_cpulabel"
          ],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raidlock",
          "args": [
            "rs"
          ],
          "line": 1222
        },
        "resolved": true,
        "details": {
          "function_name": "raidlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_openbsdkintf.c",
          "lines": "1900-1913",
          "snippet": "int\nraidlock(rs)\n\tstruct raid_softc *rs;\n{\n\tint error;\n\n\twhile ((rs->sc_flags & RAIDF_LOCKED) != 0) {\n\t\trs->sc_flags |= RAIDF_WANTED;\n\t\tif ((error = tsleep(rs, PRIBIO | PCATCH, \"raidlck\", 0)) != 0)\n\t\t\treturn (error);\n\t}\n\trs->sc_flags |= RAIDF_LOCKED;\n\treturn (0);\n}",
          "includes": [
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_dagflags.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_raidframe.h\"",
            "#include \"rf_raid.h\"",
            "#include \"raid.h\"",
            "#include <sys/user.h>",
            "#include <sys/buf.h>",
            "#include <sys/lock.h>",
            "#include <sys/conf.h>",
            "#include <sys/namei.h>",
            "#include <sys/systm.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/device.h>",
            "#include <sys/disk.h>",
            "#include <sys/queue.h>",
            "#include <sys/malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/errno.h>"
          ],
          "macros_used": [
            "#define RAIDF_LOCKED\t0x80\t/* unit is locked */",
            "#define RAIDF_WANTED\t0x40\t/* someone is waiting to obtain a lock */"
          ],
          "globals_used": [
            "struct raid_softc *raid_softc;",
            "int\traidlock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\n#define RAIDF_LOCKED\t0x80\t/* unit is locked */\n#define RAIDF_WANTED\t0x40\t/* someone is waiting to obtain a lock */\n\nstruct raid_softc *raid_softc;\nint\traidlock;\n\nint\nraidlock(rs)\n\tstruct raid_softc *rs;\n{\n\tint error;\n\n\twhile ((rs->sc_flags & RAIDF_LOCKED) != 0) {\n\t\trs->sc_flags |= RAIDF_WANTED;\n\t\tif ((error = tsleep(rs, PRIBIO | PCATCH, \"raidlck\", 0)) != 0)\n\t\t\treturn (error);\n\t}\n\trs->sc_flags |= RAIDF_LOCKED;\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DISKPART",
          "args": [
            "dev"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_UNLOCK_MUTEX",
          "args": [
            "rf_sparet_wait_mutex"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "&rf_sparet_resp_queue"
          ],
          "line": 1193
        },
        "resolved": true,
        "details": {
          "function_name": "audio_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "765-774",
          "snippet": "static __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nstatic __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_LOCK_MUTEX",
          "args": [
            "rf_sparet_wait_mutex"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Malloc",
          "args": [
            "waitreq",
            "sizeof *waitreq",
            "(RF_SparetWait_t *)"
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_SetSpareTable",
          "args": [
            "raidPtr",
            "*(void **)data"
          ],
          "line": 1182
        },
        "resolved": true,
        "details": {
          "function_name": "rf_SetSpareTable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_decluster.c",
          "lines": "682-718",
          "snippet": "int \nrf_SetSpareTable(raidPtr, data)\n\tRF_Raid_t *raidPtr;\n\tvoid   *data;\n{\n\tRF_DeclusteredConfigInfo_t *info = (RF_DeclusteredConfigInfo_t *) raidPtr->Layout.layoutSpecificInfo;\n\tRF_SpareTableEntry_t **ptrs;\n\tint     i, retcode;\n\n\t/* what we need to copyin is a 2-d array, so first copyin the user\n\t * pointers to the rows in the table */\n\tRF_Malloc(ptrs, info->TablesPerSpareRegion * sizeof(RF_SpareTableEntry_t *), (RF_SpareTableEntry_t **));\n\tretcode = copyin((caddr_t) data, (caddr_t) ptrs, info->TablesPerSpareRegion * sizeof(RF_SpareTableEntry_t *));\n\n\tif (retcode)\n\t\treturn (retcode);\n\n\t/* now allocate kernel space for the row pointers */\n\tRF_Malloc(info->SpareTable, info->TablesPerSpareRegion * sizeof(RF_SpareTableEntry_t *), (RF_SpareTableEntry_t **));\n\n\t/* now allocate kernel space for each row in the table, and copy it in\n\t * from user space */\n\tfor (i = 0; i < info->TablesPerSpareRegion; i++) {\n\t\tRF_Malloc(info->SpareTable[i], info->BlocksPerTable * sizeof(RF_SpareTableEntry_t), (RF_SpareTableEntry_t *));\n\t\tretcode = copyin(ptrs[i], info->SpareTable[i], info->BlocksPerTable * sizeof(RF_SpareTableEntry_t));\n\t\tif (retcode) {\n\t\t\tinfo->SpareTable = NULL;\t/* blow off the memory\n\t\t\t\t\t\t\t * we've allocated */\n\t\t\treturn (retcode);\n\t\t}\n\t}\n\n\t/* free up the temporary array we used */\n\tRF_Free(ptrs, info->TablesPerSpareRegion * sizeof(RF_SpareTableEntry_t *));\n\n\treturn (0);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_decluster.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_raidframe.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_general.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_utils.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_decluster.h\"\n#include \"rf_configure.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nint \nrf_SetSpareTable(raidPtr, data)\n\tRF_Raid_t *raidPtr;\n\tvoid   *data;\n{\n\tRF_DeclusteredConfigInfo_t *info = (RF_DeclusteredConfigInfo_t *) raidPtr->Layout.layoutSpecificInfo;\n\tRF_SpareTableEntry_t **ptrs;\n\tint     i, retcode;\n\n\t/* what we need to copyin is a 2-d array, so first copyin the user\n\t * pointers to the rows in the table */\n\tRF_Malloc(ptrs, info->TablesPerSpareRegion * sizeof(RF_SpareTableEntry_t *), (RF_SpareTableEntry_t **));\n\tretcode = copyin((caddr_t) data, (caddr_t) ptrs, info->TablesPerSpareRegion * sizeof(RF_SpareTableEntry_t *));\n\n\tif (retcode)\n\t\treturn (retcode);\n\n\t/* now allocate kernel space for the row pointers */\n\tRF_Malloc(info->SpareTable, info->TablesPerSpareRegion * sizeof(RF_SpareTableEntry_t *), (RF_SpareTableEntry_t **));\n\n\t/* now allocate kernel space for each row in the table, and copy it in\n\t * from user space */\n\tfor (i = 0; i < info->TablesPerSpareRegion; i++) {\n\t\tRF_Malloc(info->SpareTable[i], info->BlocksPerTable * sizeof(RF_SpareTableEntry_t), (RF_SpareTableEntry_t *));\n\t\tretcode = copyin(ptrs[i], info->SpareTable[i], info->BlocksPerTable * sizeof(RF_SpareTableEntry_t));\n\t\tif (retcode) {\n\t\t\tinfo->SpareTable = NULL;\t/* blow off the memory\n\t\t\t\t\t\t\t * we've allocated */\n\t\t\treturn (retcode);\n\t\t}\n\t}\n\n\t/* free up the temporary array we used */\n\tRF_Free(ptrs, info->TablesPerSpareRegion * sizeof(RF_SpareTableEntry_t *));\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_UNLOCK_MUTEX",
          "args": [
            "rf_sparet_wait_mutex"
          ],
          "line": 1171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_LOCK_MUTEX",
          "args": [
            "rf_sparet_wait_mutex"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Malloc",
          "args": [
            "waitreq",
            "sizeof (*waitreq)",
            "(RF_SparetWait_t *)"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "waitreq",
            "sizeof *waitreq"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_UNLOCK_MUTEX",
          "args": [
            "rf_sparet_wait_mutex"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mpsleep",
          "args": [
            "&rf_sparet_wait_queue",
            "(PZERO + 1) | PCATCH",
            "\"sparet wait\"",
            "0",
            "(void *)simple_lock_addr(rf_sparet_wait_mutex)",
            "MS_LOCK_SIMPLE"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_lock_addr",
          "args": [
            "rf_sparet_wait_mutex"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_LOCK_MUTEX",
          "args": [
            "rf_sparet_wait_mutex"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_CREATE_THREAD",
          "args": [
            "raidPtr->copyback_thread",
            "rf_CopybackThread",
            "raidPtr",
            "\"raid_copyback\""
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_CREATE_THREAD",
          "args": [
            "raidPtr->recon_thread",
            "rf_ReconThread",
            "rrcopy",
            "\"raid_recon\""
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "rr",
            "rrcopy",
            "sizeof(*rr)"
          ],
          "line": 1068
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_Malloc",
          "args": [
            "rrcopy",
            "sizeof(*rrcopy)",
            "(struct rf_recon_req *)"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"raid%d: Failing the disk: row: %d col: %d\\n\"",
            "unit",
            "rr->row",
            "rr->col"
          ],
          "line": 1058
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "&raidPtr->acc_totals",
            "sizeof(raidPtr->acc_totals)"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "d_cfg",
            "sizeof(RF_DeviceConfig_t)"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copyout",
          "args": [
            "(caddr_t) d_cfg",
            "(caddr_t) * ucfgp",
            "sizeof(RF_DeviceConfig_t)"
          ],
          "line": 1024
        },
        "resolved": true,
        "details": {
          "function_name": "audio_silence_copyout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "1249-1268",
          "snippet": "int\naudio_silence_copyout(sc, n, uio)\n\tstruct audio_softc *sc;\n\tint n;\n\tstruct uio *uio;\n{\n\tint error;\n\tint k;\n\tu_char zerobuf[128];\n\n\taudio_fill_silence(&sc->sc_rparams, zerobuf, sizeof zerobuf);\n\n\terror = 0;\n        while (n > 0 && uio->uio_resid > 0 && !error) {\n\t\tk = min(n, min(uio->uio_resid, sizeof zerobuf));\n\t\terror = uiomove(zerobuf, k, uio);\n\t\tn -= k;\n\t}\n        return (error);\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\naudio_silence_copyout(sc, n, uio)\n\tstruct audio_softc *sc;\n\tint n;\n\tstruct uio *uio;\n{\n\tint error;\n\tint k;\n\tu_char zerobuf[128];\n\n\taudio_fill_silence(&sc->sc_rparams, zerobuf, sizeof zerobuf);\n\n\terror = 0;\n        while (n > 0 && uio->uio_resid > 0 && !error) {\n\t\tk = min(n, min(uio->uio_resid, sizeof zerobuf));\n\t\terror = uiomove(zerobuf, k, uio);\n\t\tn -= k;\n\t}\n        return (error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "d_cfg",
            "sizeof(RF_DeviceConfig_t)"
          ],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "d_cfg",
            "sizeof(RF_DeviceConfig_t)"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char *) d_cfg",
            "sizeof(RF_DeviceConfig_t)"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Malloc",
          "args": [
            "d_cfg",
            "sizeof(RF_DeviceConfig_t)",
            "(RF_DeviceConfig_t *)"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_CREATE_THREAD",
          "args": [
            "raidPtr->recon_thread",
            "rf_ReconstructInPlaceThread",
            "rrcopy",
            "\"raid_reconip\""
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Malloc",
          "args": [
            "rrcopy",
            "sizeof(*rrcopy)",
            "(struct rf_recon_req *)"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&component",
            "componentPtr",
            "sizeof(RF_SingleComponent_t)"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_add_hot_spare",
          "args": [
            "raidPtr",
            "&hot_spare"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "rf_add_hot_spare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_disks.c",
          "lines": "774-863",
          "snippet": "int\nrf_add_hot_spare(raidPtr, sparePtr)\n\tRF_Raid_t *raidPtr;\n\tRF_SingleComponent_t *sparePtr;\n{\n\tRF_RaidDisk_t *disks;\n\tRF_DiskQueue_t *spareQueues;\n\tint ret;\n\tunsigned int bs;\n\tint spare_number;\n\n\tprintf(\"Just in rf_add_hot_spare: %d\\n\",raidPtr->numSpare);\n\tprintf(\"Num col: %d\\n\",raidPtr->numCol);\n\tif (raidPtr->numSpare >= RF_MAXSPARE) {\n\t\tRF_ERRORMSG1(\"Too many spares: %d\\n\", raidPtr->numSpare);\n\t\treturn(EINVAL);\n \t}\n\n\tRF_LOCK_MUTEX(raidPtr->mutex);\n\n\t/* the beginning of the spares... */\n\tdisks = &raidPtr->Disks[0][raidPtr->numCol];\n\n\tspare_number = raidPtr->numSpare;\n\n\tret = rf_ConfigureDisk(raidPtr, sparePtr->component_name,\n\t\t\t       &disks[spare_number], 0,\n\t\t\t       raidPtr->numCol + spare_number);\n\n\tif (ret)\n\t\tgoto fail;\n\tif (disks[spare_number].status != rf_ds_optimal) {\n\t\tRF_ERRORMSG1(\"Warning: spare disk %s failed TUR\\n\", \n\t\t\t     sparePtr->component_name);\n\t\tret=EINVAL;\n\t\tgoto fail;\n\t} else {\n\t\tdisks[spare_number].status = rf_ds_spare;\n\t\tDPRINTF6(\"Spare Disk %d: dev %s numBlocks %ld blockSize %d (%ld MB)\\n\", spare_number,\n\t\t\t disks[spare_number].devname,\n\t\t\t (long int) disks[spare_number].numBlocks, \n\t\t\t disks[spare_number].blockSize,\n\t\t\t (long int) disks[spare_number].numBlocks * \n\t\t\t disks[spare_number].blockSize / 1024 / 1024);\n\t}\n\t\n\n\t/* check sizes and block sizes on the spare disk */\n\tbs = 1 << raidPtr->logBytesPerSector;\n\tif (disks[spare_number].blockSize != bs) {\n\t\tRF_ERRORMSG3(\"Block size of %d on spare disk %s is not the same as on other disks (%d)\\n\", disks[spare_number].blockSize, disks[spare_number].devname, bs);\n\t\tret = EINVAL;\n\t\tgoto fail;\n\t}\n\tif (disks[spare_number].numBlocks < raidPtr->sectorsPerDisk) {\n\t\tRF_ERRORMSG3(\"Spare disk %s (%d blocks) is too small to serve as a spare (need %ld blocks)\\n\",\n\t\t\t     disks[spare_number].devname, \n\t\t\t     disks[spare_number].blockSize, \n\t\t\t     (long int) raidPtr->sectorsPerDisk);\n\t\tret = EINVAL;\n\t\tgoto fail;\n\t} else {\n\t\tif (disks[spare_number].numBlocks > \n\t\t    raidPtr->sectorsPerDisk) {\n\t\t\tRF_ERRORMSG2(\"Warning: truncating spare disk %s to %ld blocks\\n\", disks[spare_number].devname, \n\t\t\t\t     (long int) raidPtr->sectorsPerDisk);\n\t\t\t\n\t\t\tdisks[spare_number].numBlocks = raidPtr->sectorsPerDisk;\n\t\t}\n\t}\n\n\tspareQueues = &raidPtr->Queues[0][raidPtr->numCol];\n\tret = config_disk_queue( raidPtr, &spareQueues[spare_number],\n\t\t\t\t 0, raidPtr->numCol + spare_number, \n\t\t\t\t raidPtr->Queues[0][0].qPtr, /* XXX */\n\t\t\t\t raidPtr->sectorsPerDisk,\n\t\t\t\t raidPtr->Disks[0][raidPtr->numCol + spare_number].dev,\n\t\t\t\t raidPtr->Queues[0][0].maxOutstanding, /* XXX */\n\t\t\t\t &raidPtr->shutdownList,\n\t\t\t\t raidPtr->cleanupList);\n\t\t\t\t \n\n\traidPtr->numSpare++;\n\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\treturn (0);\n\nfail:\n\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\treturn(ret);\n}",
          "includes": [
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"rf_kintf.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void rf_UnconfigureVnodes( RF_Raid_t * );",
            "int rf_add_hot_spare(RF_Raid_t *, RF_SingleComponent_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"rf_kintf.h\"\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_utils.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid rf_UnconfigureVnodes( RF_Raid_t * );\nint rf_add_hot_spare(RF_Raid_t *, RF_SingleComponent_t *);\n\nint\nrf_add_hot_spare(raidPtr, sparePtr)\n\tRF_Raid_t *raidPtr;\n\tRF_SingleComponent_t *sparePtr;\n{\n\tRF_RaidDisk_t *disks;\n\tRF_DiskQueue_t *spareQueues;\n\tint ret;\n\tunsigned int bs;\n\tint spare_number;\n\n\tprintf(\"Just in rf_add_hot_spare: %d\\n\",raidPtr->numSpare);\n\tprintf(\"Num col: %d\\n\",raidPtr->numCol);\n\tif (raidPtr->numSpare >= RF_MAXSPARE) {\n\t\tRF_ERRORMSG1(\"Too many spares: %d\\n\", raidPtr->numSpare);\n\t\treturn(EINVAL);\n \t}\n\n\tRF_LOCK_MUTEX(raidPtr->mutex);\n\n\t/* the beginning of the spares... */\n\tdisks = &raidPtr->Disks[0][raidPtr->numCol];\n\n\tspare_number = raidPtr->numSpare;\n\n\tret = rf_ConfigureDisk(raidPtr, sparePtr->component_name,\n\t\t\t       &disks[spare_number], 0,\n\t\t\t       raidPtr->numCol + spare_number);\n\n\tif (ret)\n\t\tgoto fail;\n\tif (disks[spare_number].status != rf_ds_optimal) {\n\t\tRF_ERRORMSG1(\"Warning: spare disk %s failed TUR\\n\", \n\t\t\t     sparePtr->component_name);\n\t\tret=EINVAL;\n\t\tgoto fail;\n\t} else {\n\t\tdisks[spare_number].status = rf_ds_spare;\n\t\tDPRINTF6(\"Spare Disk %d: dev %s numBlocks %ld blockSize %d (%ld MB)\\n\", spare_number,\n\t\t\t disks[spare_number].devname,\n\t\t\t (long int) disks[spare_number].numBlocks, \n\t\t\t disks[spare_number].blockSize,\n\t\t\t (long int) disks[spare_number].numBlocks * \n\t\t\t disks[spare_number].blockSize / 1024 / 1024);\n\t}\n\t\n\n\t/* check sizes and block sizes on the spare disk */\n\tbs = 1 << raidPtr->logBytesPerSector;\n\tif (disks[spare_number].blockSize != bs) {\n\t\tRF_ERRORMSG3(\"Block size of %d on spare disk %s is not the same as on other disks (%d)\\n\", disks[spare_number].blockSize, disks[spare_number].devname, bs);\n\t\tret = EINVAL;\n\t\tgoto fail;\n\t}\n\tif (disks[spare_number].numBlocks < raidPtr->sectorsPerDisk) {\n\t\tRF_ERRORMSG3(\"Spare disk %s (%d blocks) is too small to serve as a spare (need %ld blocks)\\n\",\n\t\t\t     disks[spare_number].devname, \n\t\t\t     disks[spare_number].blockSize, \n\t\t\t     (long int) raidPtr->sectorsPerDisk);\n\t\tret = EINVAL;\n\t\tgoto fail;\n\t} else {\n\t\tif (disks[spare_number].numBlocks > \n\t\t    raidPtr->sectorsPerDisk) {\n\t\t\tRF_ERRORMSG2(\"Warning: truncating spare disk %s to %ld blocks\\n\", disks[spare_number].devname, \n\t\t\t\t     (long int) raidPtr->sectorsPerDisk);\n\t\t\t\n\t\t\tdisks[spare_number].numBlocks = raidPtr->sectorsPerDisk;\n\t\t}\n\t}\n\n\tspareQueues = &raidPtr->Queues[0][raidPtr->numCol];\n\tret = config_disk_queue( raidPtr, &spareQueues[spare_number],\n\t\t\t\t 0, raidPtr->numCol + spare_number, \n\t\t\t\t raidPtr->Queues[0][0].qPtr, /* XXX */\n\t\t\t\t raidPtr->sectorsPerDisk,\n\t\t\t\t raidPtr->Disks[0][raidPtr->numCol + spare_number].dev,\n\t\t\t\t raidPtr->Queues[0][0].maxOutstanding, /* XXX */\n\t\t\t\t &raidPtr->shutdownList,\n\t\t\t\t raidPtr->cleanupList);\n\t\t\t\t \n\n\traidPtr->numSpare++;\n\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\treturn (0);\n\nfail:\n\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\treturn(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&hot_spare",
            "sparePtr",
            "sizeof(RF_SingleComponent_t)"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_CREATE_THREAD",
          "args": [
            "raidPtr->parity_rewrite_thread",
            "rf_RewriteParityThread",
            "raidPtr",
            "\"raid_parity\""
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raidwrite_component_label",
          "args": [
            "raidPtr->Disks[row][column].dev",
            "raidPtr->raid_cinfo[row][column].ci_vp",
            "&ci_label"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "raidwrite_component_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_openbsdkintf.c",
          "lines": "2007-2039",
          "snippet": "int \nraidwrite_component_label(dev, b_vp, component_label)\n\tdev_t dev; \n\tstruct vnode *b_vp;\n\tRF_ComponentLabel_t *component_label;\n{\n\tstruct buf *bp;\n\tint error;\n\n\t/* get a block of the appropriate size... */\n\tbp = geteblk((int)RF_COMPONENT_INFO_SIZE);\n\tbp->b_dev = dev;\n\n\t/* get our ducks in a row for the write */\n\tbp->b_blkno = RF_COMPONENT_INFO_OFFSET / DEV_BSIZE;\n\tbp->b_bcount = RF_COMPONENT_INFO_SIZE;\n\tbp->b_flags = B_BUSY | B_WRITE;\n \tbp->b_resid = RF_COMPONENT_INFO_SIZE / DEV_BSIZE;\n\n\tmemset( bp->b_un.b_addr, 0, RF_COMPONENT_INFO_SIZE );\n\n\tmemcpy( bp->b_un.b_addr, component_label, sizeof(RF_ComponentLabel_t));\n\n\t(*bdevsw[major(bp->b_dev)].d_strategy)(bp);\n\terror = biowait(bp); \n        bp->b_flags = B_INVAL | B_AGE;\n\tbrelse(bp);\n\tif (error) {\n\t\tprintf(\"Failed to write RAID component info!\\n\");\n\t}\n\n\treturn(error);\n}",
          "includes": [
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_dagflags.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_raidframe.h\"",
            "#include \"rf_raid.h\"",
            "#include \"raid.h\"",
            "#include <sys/user.h>",
            "#include <sys/buf.h>",
            "#include <sys/lock.h>",
            "#include <sys/conf.h>",
            "#include <sys/namei.h>",
            "#include <sys/systm.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/device.h>",
            "#include <sys/disk.h>",
            "#include <sys/queue.h>",
            "#include <sys/malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/errno.h>"
          ],
          "macros_used": [
            "#define RF_COMPONENT_INFO_SIZE     1024 /* bytes */",
            "#define RF_COMPONENT_INFO_OFFSET  16384 /* bytes */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\n#define RF_COMPONENT_INFO_SIZE     1024 /* bytes */\n#define RF_COMPONENT_INFO_OFFSET  16384 /* bytes */\n\nint \nraidwrite_component_label(dev, b_vp, component_label)\n\tdev_t dev; \n\tstruct vnode *b_vp;\n\tRF_ComponentLabel_t *component_label;\n{\n\tstruct buf *bp;\n\tint error;\n\n\t/* get a block of the appropriate size... */\n\tbp = geteblk((int)RF_COMPONENT_INFO_SIZE);\n\tbp->b_dev = dev;\n\n\t/* get our ducks in a row for the write */\n\tbp->b_blkno = RF_COMPONENT_INFO_OFFSET / DEV_BSIZE;\n\tbp->b_bcount = RF_COMPONENT_INFO_SIZE;\n\tbp->b_flags = B_BUSY | B_WRITE;\n \tbp->b_resid = RF_COMPONENT_INFO_SIZE / DEV_BSIZE;\n\n\tmemset( bp->b_un.b_addr, 0, RF_COMPONENT_INFO_SIZE );\n\n\tmemcpy( bp->b_un.b_addr, component_label, sizeof(RF_ComponentLabel_t));\n\n\t(*bdevsw[major(bp->b_dev)].d_strategy)(bp);\n\terror = biowait(bp); \n        bp->b_flags = B_INVAL | B_AGE;\n\tbrelse(bp);\n\tif (error) {\n\t\tprintf(\"Failed to write RAID component info!\\n\");\n\t}\n\n\treturn(error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "component_label",
            "sizeof(RF_ComponentLabel_t)"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "component_label",
            "sizeof(RF_ComponentLabel_t)"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raidread_component_label",
          "args": [
            "raidPtr->Disks[row][column].dev",
            "raidPtr->raid_cinfo[row][column].ci_vp",
            "component_label"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "raidread_component_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_openbsdkintf.c",
          "lines": "1957-2005",
          "snippet": "int\nraidread_component_label(dev, b_vp, component_label)\n\tdev_t dev;\n\tstruct vnode *b_vp;\n\tRF_ComponentLabel_t *component_label;\n{\n\tstruct buf *bp;\n\tint error;\n\t\n\t/* XXX should probably ensure that we don't try to do this if\n\t   someone has changed rf_protected_sectors. */ \n\n\t/* get a block of the appropriate size... */\n\tbp = geteblk((int)RF_COMPONENT_INFO_SIZE);\n\tbp->b_dev = dev;\n\n\t/* get our ducks in a row for the read */\n\tbp->b_blkno = RF_COMPONENT_INFO_OFFSET / DEV_BSIZE;\n\tbp->b_bcount = RF_COMPONENT_INFO_SIZE;\n\tbp->b_flags = B_BUSY | B_READ;\n \tbp->b_resid = RF_COMPONENT_INFO_SIZE / DEV_BSIZE;\n\n\t(*bdevsw[major(bp->b_dev)].d_strategy)(bp);\n\n\terror = biowait(bp); \n\n\tif (!error) {\n\t\tmemcpy(component_label, bp->b_un.b_addr,\n\t\t       sizeof(RF_ComponentLabel_t));\n#if 0\n\t\tprintf(\"raidread_component_label: got component label:\\n\");\n\t\tprintf(\"Version: %d\\n\",component_label->version);\n\t\tprintf(\"Serial Number: %d\\n\",component_label->serial_number);\n\t\tprintf(\"Mod counter: %d\\n\",component_label->mod_counter);\n\t\tprintf(\"Row: %d\\n\", component_label->row);\n\t\tprintf(\"Column: %d\\n\", component_label->column);\n\t\tprintf(\"Num Rows: %d\\n\", component_label->num_rows);\n\t\tprintf(\"Num Columns: %d\\n\", component_label->num_columns);\n\t\tprintf(\"Clean: %d\\n\", component_label->clean);\n\t\tprintf(\"Status: %d\\n\", component_label->status);\n#endif\n        } else {\n\t\tprintf(\"Failed to read RAID component label!\\n\");\n\t}\n\n        bp->b_flags = B_INVAL | B_AGE;\n\tbrelse(bp); \n\treturn(error);\n}",
          "includes": [
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_dagflags.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_raidframe.h\"",
            "#include \"rf_raid.h\"",
            "#include \"raid.h\"",
            "#include <sys/user.h>",
            "#include <sys/buf.h>",
            "#include <sys/lock.h>",
            "#include <sys/conf.h>",
            "#include <sys/namei.h>",
            "#include <sys/systm.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/device.h>",
            "#include <sys/disk.h>",
            "#include <sys/queue.h>",
            "#include <sys/malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/errno.h>"
          ],
          "macros_used": [
            "#define RF_COMPONENT_INFO_SIZE     1024 /* bytes */",
            "#define RF_COMPONENT_INFO_OFFSET  16384 /* bytes */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\n#define RF_COMPONENT_INFO_SIZE     1024 /* bytes */\n#define RF_COMPONENT_INFO_OFFSET  16384 /* bytes */\n\nint\nraidread_component_label(dev, b_vp, component_label)\n\tdev_t dev;\n\tstruct vnode *b_vp;\n\tRF_ComponentLabel_t *component_label;\n{\n\tstruct buf *bp;\n\tint error;\n\t\n\t/* XXX should probably ensure that we don't try to do this if\n\t   someone has changed rf_protected_sectors. */ \n\n\t/* get a block of the appropriate size... */\n\tbp = geteblk((int)RF_COMPONENT_INFO_SIZE);\n\tbp->b_dev = dev;\n\n\t/* get our ducks in a row for the read */\n\tbp->b_blkno = RF_COMPONENT_INFO_OFFSET / DEV_BSIZE;\n\tbp->b_bcount = RF_COMPONENT_INFO_SIZE;\n\tbp->b_flags = B_BUSY | B_READ;\n \tbp->b_resid = RF_COMPONENT_INFO_SIZE / DEV_BSIZE;\n\n\t(*bdevsw[major(bp->b_dev)].d_strategy)(bp);\n\n\terror = biowait(bp); \n\n\tif (!error) {\n\t\tmemcpy(component_label, bp->b_un.b_addr,\n\t\t       sizeof(RF_ComponentLabel_t));\n#if 0\n\t\tprintf(\"raidread_component_label: got component label:\\n\");\n\t\tprintf(\"Version: %d\\n\",component_label->version);\n\t\tprintf(\"Serial Number: %d\\n\",component_label->serial_number);\n\t\tprintf(\"Mod counter: %d\\n\",component_label->mod_counter);\n\t\tprintf(\"Row: %d\\n\", component_label->row);\n\t\tprintf(\"Column: %d\\n\", component_label->column);\n\t\tprintf(\"Num Rows: %d\\n\", component_label->num_rows);\n\t\tprintf(\"Num Columns: %d\\n\", component_label->num_columns);\n\t\tprintf(\"Clean: %d\\n\", component_label->clean);\n\t\tprintf(\"Status: %d\\n\", component_label->status);\n#endif\n        } else {\n\t\tprintf(\"Failed to read RAID component label!\\n\");\n\t}\n\n        bp->b_flags = B_INVAL | B_AGE;\n\tbrelse(bp); \n\treturn(error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "component_label",
            "sizeof(RF_ComponentLabel_t)"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copyin",
          "args": [
            "*c_label_ptr",
            "component_label",
            "sizeof(RF_ComponentLabel_t)"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char *) component_label",
            "sizeof(RF_ComponentLabel_t)"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Malloc",
          "args": [
            "component_label",
            "sizeof( RF_ComponentLabel_t )",
            "(RF_ComponentLabel_t *)"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disk_detach",
          "args": [
            "&rs->sc_dkdev"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_Shutdown",
          "args": [
            "raidPtr"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "rf_ShutdownRAID5",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_raid5.c",
          "lines": "112-116",
          "snippet": "int \nrf_ShutdownRAID5(RF_Raid_t * raidPtr)\n{\n\treturn (0);\n}",
          "includes": [
            "#include \"rf_utils.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dagdegwr.h\"",
            "#include \"rf_dagdegrd.h\"",
            "#include \"rf_dagffwr.h\"",
            "#include \"rf_dagffrd.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid5.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_utils.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid5.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nint \nrf_ShutdownRAID5(RF_Raid_t * raidPtr)\n{\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DISKPART",
          "args": [
            "dev"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "k_cfg",
            "sizeof (RF_Config_t)"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "specific_buf",
            "k_cfg->layoutSpecificSize"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_markalldirty",
          "args": [
            "raidPtr"
          ],
          "line": 770
        },
        "resolved": true,
        "details": {
          "function_name": "rf_markalldirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_openbsdkintf.c",
          "lines": "2041-2134",
          "snippet": "void \nrf_markalldirty( raidPtr )\n\tRF_Raid_t *raidPtr;\n{\n\tRF_ComponentLabel_t c_label;\n\tint r,c;\n\n\traidPtr->mod_counter++;\n\tfor (r = 0; r < raidPtr->numRow; r++) {\n\t\tfor (c = 0; c < raidPtr->numCol; c++) {\n\t\t\tif (raidPtr->Disks[r][c].status != rf_ds_failed) {\n\t\t\t\traidread_component_label(\n\t\t\t\t\traidPtr->Disks[r][c].dev,\n\t\t\t\t\traidPtr->raid_cinfo[r][c].ci_vp,\n\t\t\t\t\t&c_label);\n\t\t\t\tif (c_label.status == rf_ds_spared) {\n\t\t\t\t\t/* XXX do something special... \n\t\t\t\t\t but whatever you do, don't \n\t\t\t\t\t try to access it!! */\n\t\t\t\t} else {\n#if 0\n\t\t\t\tc_label.status = \n\t\t\t\t\traidPtr->Disks[r][c].status;\n\t\t\t\traidwrite_component_label( \n\t\t\t\t\traidPtr->Disks[r][c].dev,\n\t\t\t\t\traidPtr->raid_cinfo[r][c].ci_vp,\n\t\t\t\t\t&c_label);\n#endif\n\t\t\t\traidmarkdirty( \n\t\t\t\t       raidPtr->Disks[r][c].dev, \n\t\t\t\t       raidPtr->raid_cinfo[r][c].ci_vp,\n\t\t\t\t       raidPtr->mod_counter);\n\t\t\t\t}\n\t\t\t}\n\t\t} \n\t}\n\t/* printf(\"Component labels marked dirty.\\n\"); */\n#if 0\n\tfor( c = 0; c < raidPtr->numSpare ; c++) {\n\t\tsparecol = raidPtr->numCol + c;\n\t\tif (raidPtr->Disks[r][sparecol].status == rf_ds_used_spare) {\n\t\t\t/* \n\n\t\t\t   XXX this is where we get fancy and map this spare\n\t\t\t   into it's correct spot in the array.\n\n\t\t\t */\n\t\t\t/* \n\t\t\t   \n\t\t\t   we claim this disk is \"optimal\" if it's \n\t\t\t   rf_ds_used_spare, as that means it should be \n\t\t\t   directly substitutable for the disk it replaced. \n\t\t\t   We note that too...\n\n\t\t\t */\n\n\t\t\tfor(i=0;i<raidPtr->numRow;i++) {\n\t\t\t\tfor(j=0;j<raidPtr->numCol;j++) {\n\t\t\t\t\tif ((raidPtr->Disks[i][j].spareRow == \n\t\t\t\t\t     r) &&\n\t\t\t\t\t    (raidPtr->Disks[i][j].spareCol ==\n\t\t\t\t\t     sparecol)) {\n\t\t\t\t\t\tsrow = r;\n\t\t\t\t\t\tscol = sparecol;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\traidread_component_label( \n\t\t\t\t      raidPtr->Disks[r][sparecol].dev,\n\t\t\t\t      raidPtr->raid_cinfo[r][sparecol].ci_vp,\n\t\t\t\t      &c_label);\n\t\t\t/* make sure status is noted */\n\t\t\tc_label.version = RF_COMPONENT_LABEL_VERSION; \n\t\t\tc_label.mod_counter = raidPtr->mod_counter;\n\t\t\tc_label.serial_number = raidPtr->serial_number;\n\t\t\tc_label.row = srow;\n\t\t\tc_label.column = scol;\n\t\t\tc_label.num_rows = raidPtr->numRow;\n\t\t\tc_label.num_columns = raidPtr->numCol;\n\t\t\tc_label.clean = RF_RAID_DIRTY; /* changed in a bit*/\n\t\t\tc_label.status = rf_ds_optimal;\n\t\t\traidwrite_component_label(\n\t\t\t\t      raidPtr->Disks[r][sparecol].dev,\n\t\t\t\t      raidPtr->raid_cinfo[r][sparecol].ci_vp,\n\t\t\t\t      &c_label);\n\t\t\traidmarkclean( raidPtr->Disks[r][sparecol].dev, \n\t\t\t              raidPtr->raid_cinfo[r][sparecol].ci_vp);\n\t\t}\n\t}\n\n#endif\n}",
          "includes": [
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_dagflags.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_raidframe.h\"",
            "#include \"rf_raid.h\"",
            "#include \"raid.h\"",
            "#include <sys/user.h>",
            "#include <sys/buf.h>",
            "#include <sys/lock.h>",
            "#include <sys/conf.h>",
            "#include <sys/namei.h>",
            "#include <sys/systm.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/device.h>",
            "#include <sys/disk.h>",
            "#include <sys/queue.h>",
            "#include <sys/malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\trf_markalldirty"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\nvoid\trf_markalldirty;\n\nvoid \nrf_markalldirty( raidPtr )\n\tRF_Raid_t *raidPtr;\n{\n\tRF_ComponentLabel_t c_label;\n\tint r,c;\n\n\traidPtr->mod_counter++;\n\tfor (r = 0; r < raidPtr->numRow; r++) {\n\t\tfor (c = 0; c < raidPtr->numCol; c++) {\n\t\t\tif (raidPtr->Disks[r][c].status != rf_ds_failed) {\n\t\t\t\traidread_component_label(\n\t\t\t\t\traidPtr->Disks[r][c].dev,\n\t\t\t\t\traidPtr->raid_cinfo[r][c].ci_vp,\n\t\t\t\t\t&c_label);\n\t\t\t\tif (c_label.status == rf_ds_spared) {\n\t\t\t\t\t/* XXX do something special... \n\t\t\t\t\t but whatever you do, don't \n\t\t\t\t\t try to access it!! */\n\t\t\t\t} else {\n#if 0\n\t\t\t\tc_label.status = \n\t\t\t\t\traidPtr->Disks[r][c].status;\n\t\t\t\traidwrite_component_label( \n\t\t\t\t\traidPtr->Disks[r][c].dev,\n\t\t\t\t\traidPtr->raid_cinfo[r][c].ci_vp,\n\t\t\t\t\t&c_label);\n#endif\n\t\t\t\traidmarkdirty( \n\t\t\t\t       raidPtr->Disks[r][c].dev, \n\t\t\t\t       raidPtr->raid_cinfo[r][c].ci_vp,\n\t\t\t\t       raidPtr->mod_counter);\n\t\t\t\t}\n\t\t\t}\n\t\t} \n\t}\n\t/* printf(\"Component labels marked dirty.\\n\"); */\n#if 0\n\tfor( c = 0; c < raidPtr->numSpare ; c++) {\n\t\tsparecol = raidPtr->numCol + c;\n\t\tif (raidPtr->Disks[r][sparecol].status == rf_ds_used_spare) {\n\t\t\t/* \n\n\t\t\t   XXX this is where we get fancy and map this spare\n\t\t\t   into it's correct spot in the array.\n\n\t\t\t */\n\t\t\t/* \n\t\t\t   \n\t\t\t   we claim this disk is \"optimal\" if it's \n\t\t\t   rf_ds_used_spare, as that means it should be \n\t\t\t   directly substitutable for the disk it replaced. \n\t\t\t   We note that too...\n\n\t\t\t */\n\n\t\t\tfor(i=0;i<raidPtr->numRow;i++) {\n\t\t\t\tfor(j=0;j<raidPtr->numCol;j++) {\n\t\t\t\t\tif ((raidPtr->Disks[i][j].spareRow == \n\t\t\t\t\t     r) &&\n\t\t\t\t\t    (raidPtr->Disks[i][j].spareCol ==\n\t\t\t\t\t     sparecol)) {\n\t\t\t\t\t\tsrow = r;\n\t\t\t\t\t\tscol = sparecol;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\traidread_component_label( \n\t\t\t\t      raidPtr->Disks[r][sparecol].dev,\n\t\t\t\t      raidPtr->raid_cinfo[r][sparecol].ci_vp,\n\t\t\t\t      &c_label);\n\t\t\t/* make sure status is noted */\n\t\t\tc_label.version = RF_COMPONENT_LABEL_VERSION; \n\t\t\tc_label.mod_counter = raidPtr->mod_counter;\n\t\t\tc_label.serial_number = raidPtr->serial_number;\n\t\t\tc_label.row = srow;\n\t\t\tc_label.column = scol;\n\t\t\tc_label.num_rows = raidPtr->numRow;\n\t\t\tc_label.num_columns = raidPtr->numCol;\n\t\t\tc_label.clean = RF_RAID_DIRTY; /* changed in a bit*/\n\t\t\tc_label.status = rf_ds_optimal;\n\t\t\traidwrite_component_label(\n\t\t\t\t      raidPtr->Disks[r][sparecol].dev,\n\t\t\t\t      raidPtr->raid_cinfo[r][sparecol].ci_vp,\n\t\t\t\t      &c_label);\n\t\t\traidmarkclean( raidPtr->Disks[r][sparecol].dev, \n\t\t\t              raidPtr->raid_cinfo[r][sparecol].ci_vp);\n\t\t}\n\t}\n\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "raidinit",
          "args": [
            "dev",
            "raidPtr",
            "unit"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "raidinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_openbsdkintf.c",
          "lines": "1269-1304",
          "snippet": "int\nraidinit(dev, raidPtr, unit)\n\tdev_t dev;\n\tRF_Raid_t *raidPtr;\n\tint unit;\n{\n\tint retcode;\n\tstruct raid_softc *rs;\n\n\tretcode = 0;\n\n\trs = &raid_softc[unit];\n\t\n\t/* XXX should check return code first... */\n\trs->sc_flags |= RAIDF_INITED;\n\n\t/* XXX doesn't check bounds.*/\n\tsprintf(rs->sc_xname, \"raid%d\", unit);\n\n\trs->sc_dkdev.dk_name = rs->sc_xname;\t\n\n\t/*\n\t * disk_attach actually creates space for the CPU disklabel, among\n\t * other things, so it's critical to call this *BEFORE* we\n\t * try putzing with disklabels.\n\t */\n\tdisk_attach(&rs->sc_dkdev);\n\n\t/*\n\t * XXX There may be a weird interaction here between this, and\n\t * protectedSectors, as used in RAIDframe.\n\t */\n\trs->sc_size = raidPtr->totalSectors;\n\trs->sc_dev = dev;\n\treturn (retcode);\n}",
          "includes": [
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_dagflags.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_raidframe.h\"",
            "#include \"rf_raid.h\"",
            "#include \"raid.h\"",
            "#include <sys/user.h>",
            "#include <sys/buf.h>",
            "#include <sys/lock.h>",
            "#include <sys/conf.h>",
            "#include <sys/namei.h>",
            "#include <sys/systm.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/device.h>",
            "#include <sys/disk.h>",
            "#include <sys/queue.h>",
            "#include <sys/malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/errno.h>"
          ],
          "macros_used": [
            "#define RAIDF_INITED\t0x01\t/* unit has been initialized */"
          ],
          "globals_used": [
            "static int raidinit",
            "struct raid_softc *raid_softc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\n#define RAIDF_INITED\t0x01\t/* unit has been initialized */\n\nstatic int raidinit;\nstruct raid_softc *raid_softc;\n\nint\nraidinit(dev, raidPtr, unit)\n\tdev_t dev;\n\tRF_Raid_t *raidPtr;\n\tint unit;\n{\n\tint retcode;\n\tstruct raid_softc *rs;\n\n\tretcode = 0;\n\n\trs = &raid_softc[unit];\n\t\n\t/* XXX should check return code first... */\n\trs->sc_flags |= RAIDF_INITED;\n\n\t/* XXX doesn't check bounds.*/\n\tsprintf(rs->sc_xname, \"raid%d\", unit);\n\n\trs->sc_dkdev.dk_name = rs->sc_xname;\t\n\n\t/*\n\t * disk_attach actually creates space for the CPU disklabel, among\n\t * other things, so it's critical to call this *BEFORE* we\n\t * try putzing with disklabels.\n\t */\n\tdisk_attach(&rs->sc_dkdev);\n\n\t/*\n\t * XXX There may be a weird interaction here between this, and\n\t * protectedSectors, as used in RAIDframe.\n\t */\n\trs->sc_size = raidPtr->totalSectors;\n\trs->sc_dev = dev;\n\treturn (retcode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_Configure",
          "args": [
            "raidPtr",
            "k_cfg"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "rf_ConfigureMemChunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_memchunk.c",
          "lines": "109-130",
          "snippet": "int \nrf_ConfigureMemChunk(listp)\n\tRF_ShutdownList_t **listp;\n{\n\tint     rc;\n\n\tchunklist = NULL;\n\tchunk_hdr_free_list = NULL;\n\tchunk_desc_free_list = NULL;\n\trc = rf_mutex_init(&chunkmutex);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to init mutex file %s line %d rc=%d\\n\", __FILE__,\n\t\t    __LINE__, rc);\n\t}\n\trc = rf_ShutdownCreate(listp, rf_ShutdownMemChunk, NULL);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to add to shutdown list file %s line %d rc=%d\\n\", __FILE__,\n\t\t    __LINE__, rc);\n\t\trf_mutex_destroy(&chunkmutex);\n\t}\n\treturn (rc);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_memchunk.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static RF_ChunkHdr_t *chunklist, *chunk_hdr_free_list;",
            "static RF_ChunkDesc_t *chunk_desc_free_list;",
            "RF_DECLARE_STATIC_MUTEX(chunkmutex)\n\tstatic void rf_ShutdownMemChunk(void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_memchunk.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic RF_ChunkHdr_t *chunklist, *chunk_hdr_free_list;\nstatic RF_ChunkDesc_t *chunk_desc_free_list;\nRF_DECLARE_STATIC_MUTEX(chunkmutex)\n\tstatic void rf_ShutdownMemChunk(void *);\n\nint \nrf_ConfigureMemChunk(listp)\n\tRF_ShutdownList_t **listp;\n{\n\tint     rc;\n\n\tchunklist = NULL;\n\tchunk_hdr_free_list = NULL;\n\tchunk_desc_free_list = NULL;\n\trc = rf_mutex_init(&chunkmutex);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to init mutex file %s line %d rc=%d\\n\", __FILE__,\n\t\t    __LINE__, rc);\n\t}\n\trc = rf_ShutdownCreate(listp, rf_ShutdownMemChunk, NULL);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to add to shutdown list file %s line %d rc=%d\\n\", __FILE__,\n\t\t    __LINE__, rc);\n\t\trf_mutex_destroy(&chunkmutex);\n\t}\n\treturn (rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "specific_buf",
            "k_cfg->layoutSpecificSize"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "k_cfg",
            "sizeof(RF_Config_t)"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copyin",
          "args": [
            "k_cfg->layoutSpecific",
            "(caddr_t)specific_buf",
            "k_cfg->layoutSpecificSize"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "k_cfg",
            "sizeof (RF_Config_t)"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Malloc",
          "args": [
            "specific_buf",
            "k_cfg->layoutSpecificSize",
            "(u_char *)"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "k_cfg",
            "sizeof(RF_Config_t)"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "k_cfg",
            "sizeof(RF_Config_t)"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copyin",
          "args": [
            "(caddr_t)u_cfg",
            "(caddr_t)k_cfg",
            "sizeof (RF_Config_t)"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Malloc",
          "args": [
            "k_cfg",
            "sizeof (RF_Config_t)",
            "(RF_Config_t *)"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db1_printf",
          "args": [
            "(\"raidioctl: %d %d %d %d\\n\", (int)dev, (int)DISKPART(dev),\n\t    (int)unit, (int)cmd)"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DISKPART",
          "args": [
            "dev"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raidunit",
          "args": [
            "dev"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\n#define RAIDOUTSTANDING   6\n#define RAIDF_LABELLING\t0x04\t/* unit is currently being labelled */\n#define RAIDF_WLABEL\t0x02\t/* label area is writable */\n#define RAIDF_INITED\t0x01\t/* unit has been initialized */\n\nstatic RF_Raid_t **raidPtrs;\nRF_DECLARE_STATIC_MUTEX(rf_sparet_wait_mutex)\n\n/* requests to install a spare table */\nstatic RF_SparetWait_t;\nstatic RF_SparetWait_t *rf_sparet_resp_queue;\nstatic int raidinit;\nint\traidioctl;\nvoid\traidstrategy;\nstatic int numraid = 0;\nstruct raid_softc *raid_softc;\nvoid\traidgetdefaultlabel;\nint\traidlock;\nvoid\traidunlock;\nvoid\trf_markalldirty;\nvoid rf_ReconThread;\nvoid rf_RewriteParityThread;\nvoid rf_CopybackThread;\nvoid rf_ReconstructInPlaceThread;\n\nint\nraidioctl(dev, cmd, data, flag, p)\n\tdev_t dev;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tint unit = raidunit(dev);\n\tint error = 0;\n\tint part, pmask;\n\tstruct raid_softc *rs;\n\tRF_Config_t *k_cfg, *u_cfg;\n\tRF_Raid_t *raidPtr;\n\tRF_AccTotals_t *totals;\n\tRF_DeviceConfig_t *d_cfg, **ucfgp;\n\tu_char *specific_buf;\n\tint retcode = 0;\n\tint row;\n\tint column;\n\tstruct rf_recon_req *rrcopy, *rr;\n\tRF_ComponentLabel_t *component_label;\n\tRF_ComponentLabel_t ci_label;\n\tRF_ComponentLabel_t **c_label_ptr;\n\tRF_SingleComponent_t *sparePtr,*componentPtr;\n\tRF_SingleComponent_t hot_spare;\n\tRF_SingleComponent_t component;\n\tint i, j, d;\n\n\tif (unit >= numraid)\n\t\treturn (ENXIO);\n\trs = &raid_softc[unit];\n\traidPtr = raidPtrs[unit];\n\n\tdb1_printf((\"raidioctl: %d %d %d %d\\n\", (int)dev, (int)DISKPART(dev),\n\t    (int)unit, (int)cmd));\n\n\t/* Must be open for writes for these commands... */\n\tswitch (cmd) {\n\tcase DIOCSDINFO:\n\tcase DIOCWDINFO:\n\tcase DIOCWLABEL:\n\t\tif ((flag & FWRITE) == 0)\n\t\t\treturn (EBADF);\n\t}\n\n\t/* Must be initialized for these... */\n\tswitch (cmd) {\n\tcase DIOCGDINFO:\n\tcase DIOCSDINFO:\n\tcase DIOCWDINFO:\n\tcase DIOCGPART:\n\tcase DIOCWLABEL:\n\tcase RAIDFRAME_SHUTDOWN:\n\tcase RAIDFRAME_REWRITEPARITY:\n\tcase RAIDFRAME_GET_INFO:\n\tcase RAIDFRAME_RESET_ACCTOTALS:\n\tcase RAIDFRAME_GET_ACCTOTALS:\n\tcase RAIDFRAME_KEEP_ACCTOTALS:\n\tcase RAIDFRAME_GET_SIZE:\n\tcase RAIDFRAME_FAIL_DISK:\n\tcase RAIDFRAME_COPYBACK:\n\tcase RAIDFRAME_CHECK_RECON_STATUS:\n\tcase RAIDFRAME_GET_COMPONENT_LABEL:\n\tcase RAIDFRAME_SET_COMPONENT_LABEL:\n\tcase RAIDFRAME_ADD_HOT_SPARE:\n\tcase RAIDFRAME_REMOVE_HOT_SPARE:\n\tcase RAIDFRAME_INIT_LABELS:\n\tcase RAIDFRAME_REBUILD_IN_PLACE:\n\tcase RAIDFRAME_CHECK_PARITY:\n\tcase RAIDFRAME_CHECK_PARITYREWRITE_STATUS:\n\tcase RAIDFRAME_CHECK_COPYBACK_STATUS:\n\t\tif ((rs->sc_flags & RAIDF_INITED) == 0)\n\t\t\treturn (ENXIO);\n\t}\n\t\n\tswitch (cmd) {\n\t\t/* Configure the system */\n\tcase RAIDFRAME_CONFIGURE:\n\t\t/*\n\t\t * Copy-in the configuration information\n\t\t * data points to a pointer to the configuration structure.\n\t\t */\n\t\tu_cfg = *((RF_Config_t **)data);\n\t\tRF_Malloc(k_cfg, sizeof (RF_Config_t), (RF_Config_t *));\n\t\tif (k_cfg == NULL) {\n\t\t\treturn (ENOMEM);\n\t\t}\n\t\tretcode = copyin((caddr_t)u_cfg, (caddr_t)k_cfg,\n\t\t    sizeof (RF_Config_t));\n\t\tif (retcode) {\n\t\t\tRF_Free(k_cfg, sizeof(RF_Config_t));\n\t\t\treturn (retcode);\n\t\t}\n\n\t\t/*\n\t\t * Allocate a buffer for the layout-specific data,\n\t\t * and copy it in.\n\t\t */\n\t\tif (k_cfg->layoutSpecificSize) {\n\t\t\tif (k_cfg->layoutSpecificSize > 10000) {\n\t\t\t\t/* sanity check */\n\t\t\t\tRF_Free(k_cfg, sizeof(RF_Config_t));\n\t\t\t\treturn (EINVAL);\n\t\t\t}\n\t\t\tRF_Malloc(specific_buf, k_cfg->layoutSpecificSize,\n\t\t\t    (u_char *));\n\t\t\tif (specific_buf == NULL) {\n\t\t\t\tRF_Free(k_cfg, sizeof (RF_Config_t));\n\t\t\t\treturn (ENOMEM);\n\t\t\t}\n\t\t\tretcode = copyin(k_cfg->layoutSpecific,\n\t\t\t    (caddr_t)specific_buf, k_cfg->layoutSpecificSize);\n\t\t\tif (retcode) {\n\t\t\t\tRF_Free(k_cfg, sizeof(RF_Config_t));\n\t\t\t\tRF_Free(specific_buf, \n\t\t\t\t\tk_cfg->layoutSpecificSize);\n\t\t\t\treturn (retcode);\n\t\t\t}\n\t\t} else\n\t\t\tspecific_buf = NULL;\n\t\tk_cfg->layoutSpecific = specific_buf;\n\t\t\n\t\t/*\n\t\t * We should do some kind of sanity check on the\n\t\t * configuration.\n\t\t * Store the sum of all the bytes in the last byte?\n\t\t */\n\n\t\t/* configure the system */\n\t\traidPtr->raidid = unit;\n\n\t\tretcode = rf_Configure(raidPtr, k_cfg);\n\n\t\tif (retcode == 0) {\n\n\t\t\t/* allow this many simultaneous IO's to\n\t\t\t   this RAID device */\n\t\t\traidPtr->openings = RAIDOUTSTANDING;\n\n\t\t\t/* XXX should be moved to rf_Configure() */\n\n\t\t\traidPtr->copyback_in_progress = 0;\n\t\t\traidPtr->parity_rewrite_in_progress = 0;\n\t\t\traidPtr->recon_in_progress = 0;\n\t\t\n\t\t\tretcode = raidinit(dev, raidPtr, unit);\n\t\t\trf_markalldirty( raidPtr );\n\t\t}\n\n\t\t/* Free the buffers.  No return code here. */\n\t\tif (k_cfg->layoutSpecificSize) {\n\t\t\tRF_Free(specific_buf, k_cfg->layoutSpecificSize);\n\t\t}\n\t\tRF_Free(k_cfg, sizeof (RF_Config_t));\n\t\t\n\t\treturn (retcode);\n\t\t\n\tcase RAIDFRAME_SHUTDOWN:\n\t\t/* Shutdown the system */\n\t\t\n\t\tif ((error = raidlock(rs)) != 0)\n\t\t\treturn (error);\n\n\t\t/*\n\t\t * If somebody has a partition mounted, we shouldn't\n\t\t * shutdown.\n\t\t */\n\n\t\tpart = DISKPART(dev);\n\t\tpmask = (1 << part);\n\t\tif ((rs->sc_dkdev.dk_openmask & ~pmask) ||\n\t\t    ((rs->sc_dkdev.dk_bopenmask & pmask) &&\n\t\t    (rs->sc_dkdev.dk_copenmask & pmask))) {\n\t\t\traidunlock(rs);\n\t\t\treturn (EBUSY);\n\t\t}\n\n\t\tretcode = rf_Shutdown(raidPtr);\n\n\t\t/* It's no longer initialized... */\n\t\trs->sc_flags &= ~RAIDF_INITED;\n\n\t\t/* Detach the disk. */\n\t\tdisk_detach(&rs->sc_dkdev);\n\n\t\traidunlock(rs);\n\n\t\treturn (retcode);\n\t\t\n\tcase RAIDFRAME_GET_COMPONENT_LABEL:\n\t\tc_label_ptr = (RF_ComponentLabel_t **) data;\n\t\t/* need to read the component label for the disk indicated\n\t\t   by row,column in component_label */\n\n\t\t/* For practice, let's get it directly fromdisk, rather \n\t\t   than from the in-core copy */\n\t\tRF_Malloc( component_label, sizeof( RF_ComponentLabel_t ),\n\t\t\t   (RF_ComponentLabel_t *));\n\t\tif (component_label == NULL)\n\t\t\treturn (ENOMEM);\n\n\t\tbzero((char *) component_label, sizeof(RF_ComponentLabel_t));\n\n\t\tretcode = copyin( *c_label_ptr, component_label, \n\t\t\t\t  sizeof(RF_ComponentLabel_t));\n\n\t\tif (retcode) {\n\t\t\tRF_Free( component_label, sizeof(RF_ComponentLabel_t));\n\t\t\treturn(retcode);\n\t\t}\n \n \t\trow = component_label->row;\n\t\tcolumn = component_label->column;\n\n\t\tif ((row < 0) || (row >= raidPtr->numRow) ||\n\t\t    (column < 0) || (column >= raidPtr->numCol)) {\n\t\t\treturn(EINVAL);\n  \t\t}\n\n\t\traidread_component_label( \n                              raidPtr->Disks[row][column].dev, \n\t\t\t      raidPtr->raid_cinfo[row][column].ci_vp, \n\t\t\t      component_label );\n\n\t\tretcode = copyout((caddr_t) component_label, \n\t\t\t\t  (caddr_t) *c_label_ptr,\n\t\t\t\t  sizeof(RF_ComponentLabel_t));\n\t\tRF_Free( component_label, sizeof(RF_ComponentLabel_t));\n\t\treturn (retcode);\n\n\tcase RAIDFRAME_SET_COMPONENT_LABEL:\n\t\tcomponent_label = (RF_ComponentLabel_t *) data;\n\n\t\t/* XXX check the label for valid stuff... */\n\t\t/* Note that some things *should not* get modified --\n\t\t   the user should be re-initing the labels instead of \n\t\t   trying to patch things.\n\t\t   */\n\n\t\tprintf(\"Got component label:\\n\");\n\t\tprintf(\"Version: %d\\n\",component_label->version);\n\t\tprintf(\"Serial Number: %d\\n\",component_label->serial_number);\n\t\tprintf(\"Mod counter: %d\\n\",component_label->mod_counter);\n\t\tprintf(\"Row: %d\\n\", component_label->row);\n\t\tprintf(\"Column: %d\\n\", component_label->column);\n\t\tprintf(\"Num Rows: %d\\n\", component_label->num_rows);\n\t\tprintf(\"Num Columns: %d\\n\", component_label->num_columns);\n\t\tprintf(\"Clean: %d\\n\", component_label->clean);\n\t\tprintf(\"Status: %d\\n\", component_label->status);\n\n\t\trow = component_label->row;\n\t\tcolumn = component_label->column;\n\n\t\tif ((row < 0) || (row >= raidPtr->numRow) ||\n\t\t    (column < 0) || (column >= raidPtr->numCol)) {\n\t\t\tRF_Free( component_label, sizeof(RF_ComponentLabel_t));\n\t\t\treturn(EINVAL);\n\t\t}\n\n \t\t/* XXX this isn't allowed to do anything for now :-) */\n#if 0\n\t\traidwrite_component_label( \n                            raidPtr->Disks[row][column].dev, \n\t\t\t    raidPtr->raid_cinfo[row][column].ci_vp, \n\t\t\t    component_label );\n#endif\n\t\treturn (0);\n\n\tcase RAIDFRAME_INIT_LABELS:\t\n\t\tcomponent_label = (RF_ComponentLabel_t *) data;\n\t\t/* \n\t\t   we only want the serial number from\n\t\t   the above.  We get all the rest of the information\n\t\t   from the config that was used to create this RAID\n\t\t   set. \n\t\t   */\n\n\t\traidPtr->serial_number = component_label->serial_number;\n\t\t/* current version number */\n\t\tci_label.version = RF_COMPONENT_LABEL_VERSION; \n\t\tci_label.serial_number = component_label->serial_number;\n\t\tci_label.mod_counter = raidPtr->mod_counter;\n\t\tci_label.num_rows = raidPtr->numRow;\n\t\tci_label.num_columns = raidPtr->numCol;\n\t\tci_label.clean = RF_RAID_DIRTY; /* not clean */\n\t\tci_label.status = rf_ds_optimal; /* \"It's good!\" */\n\n\t\tfor(row=0;row<raidPtr->numRow;row++) {\n\t\t\tci_label.row = row;\n\t\t\tfor(column=0;column<raidPtr->numCol;column++) {\n\t\t\t\tci_label.column = column;\n\t\t\t\traidwrite_component_label( \n\t\t\t\t  raidPtr->Disks[row][column].dev, \n\t\t\t\t  raidPtr->raid_cinfo[row][column].ci_vp, \n\t\t\t\t  &ci_label );\n\t\t\t}\n\t\t}\n\n\t\treturn (retcode);\n  \n\tcase RAIDFRAME_REWRITEPARITY:\n\n\t\tif (raidPtr->Layout.map->faultsTolerated == 0) {\n\t\t\t/* Parity for RAID 0 is trivially correct */\n\t\t\traidPtr->parity_good = RF_RAID_CLEAN;\n\t\t\treturn(0);\n\t\t}\n\n\t\t\n\t\tif (raidPtr->parity_rewrite_in_progress == 1) {\n\t\t\t/* Re-write is already in progress! */\n\t\t\treturn(EINVAL);\n\t\t}\n\n\t\tretcode = RF_CREATE_THREAD(raidPtr->parity_rewrite_thread,\n\t\t\t\t\t   rf_RewriteParityThread,\n\t\t\t\t\t   raidPtr,\"raid_parity\");\n\n\t\treturn (retcode);\n\n\n\tcase RAIDFRAME_ADD_HOT_SPARE:\n\t\tsparePtr = (RF_SingleComponent_t *) data;\n\t\tmemcpy( &hot_spare, sparePtr, sizeof(RF_SingleComponent_t));\n\t\tprintf(\"Adding spare\\n\");\n\t\tretcode = rf_add_hot_spare(raidPtr, &hot_spare);\n\t\treturn(retcode);\n\n\tcase RAIDFRAME_REMOVE_HOT_SPARE:\n\t\treturn(retcode);\n\n\tcase RAIDFRAME_REBUILD_IN_PLACE:\n\n\t\tif (raidPtr->Layout.map->faultsTolerated == 0) {\n\t\t\t/* Can't do this on a RAID 0!! */\n\t\t\treturn(EINVAL);\n\t\t}\n\n\t\tif (raidPtr->recon_in_progress == 1) {\n\t\t\t/* a reconstruct is already in progress! */\n\t\t\treturn(EINVAL);\n\t\t}\n\n\t\tcomponentPtr = (RF_SingleComponent_t *) data;\n\t\tmemcpy( &component, componentPtr, \n\t\t\tsizeof(RF_SingleComponent_t));\n\t\trow = component.row;\n\t\tcolumn = component.column;\n\t\tprintf(\"Rebuild: %d %d\\n\",row, column);\n\t\tif ((row < 0) || (row >= raidPtr->numRow) ||\n\t\t    (column < 0) || (column >= raidPtr->numCol)) {\n\t\t\treturn(EINVAL);\n\t\t}\n\n\t\tRF_Malloc(rrcopy, sizeof(*rrcopy), (struct rf_recon_req *));\n\t\tif (rrcopy == NULL)\n\t\t\treturn(ENOMEM);\n\n\t\trrcopy->raidPtr = (void *) raidPtr;\n\t\trrcopy->row = row;\n\t\trrcopy->col = column;\n\n\t\tretcode = RF_CREATE_THREAD(raidPtr->recon_thread,\n\t\t\t\t\t   rf_ReconstructInPlaceThread,\n\t\t\t\t\t   rrcopy,\"raid_reconip\");\n\n\t\treturn (retcode);\n\n\tcase RAIDFRAME_GET_INFO:\n\t\tif (!raidPtr->valid)\n\t\t\treturn (ENODEV);\n\t\tucfgp = (RF_DeviceConfig_t **) data;\n\t\tRF_Malloc(d_cfg, sizeof(RF_DeviceConfig_t),\n\t\t\t  (RF_DeviceConfig_t *));\n\t\tif (d_cfg == NULL)\n\t\t\treturn (ENOMEM);\n\t\tbzero((char *) d_cfg, sizeof(RF_DeviceConfig_t));\n\t\td_cfg->rows = raidPtr->numRow;\n\t\td_cfg->cols = raidPtr->numCol;\n\t\td_cfg->ndevs = raidPtr->numRow * raidPtr->numCol;\n\t\tif (d_cfg->ndevs >= RF_MAX_DISKS) {\n\t\t\tRF_Free(d_cfg, sizeof(RF_DeviceConfig_t));\n\t\t\treturn (ENOMEM);\n\t\t}\n\t\td_cfg->nspares = raidPtr->numSpare;\n\t\tif (d_cfg->nspares >= RF_MAX_DISKS) {\n\t\t\tRF_Free(d_cfg, sizeof(RF_DeviceConfig_t));\n\t\t\treturn (ENOMEM);\n\t\t}\n\t\td_cfg->maxqdepth = raidPtr->maxQueueDepth;\n\t\td = 0;\n\t\tfor (i = 0; i < d_cfg->rows; i++) {\n\t\t\tfor (j = 0; j < d_cfg->cols; j++) {\n\t\t\t\td_cfg->devs[d] = raidPtr->Disks[i][j];\n\t\t\t\td++;\n\t\t\t}\n\t\t}\n\t\tfor (j = d_cfg->cols, i = 0; i < d_cfg->nspares; i++, j++) {\n\t\t\td_cfg->spares[i] = raidPtr->Disks[0][j];\n\t\t}\n\t\tretcode = copyout((caddr_t) d_cfg, (caddr_t) * ucfgp,\n\t\t\t\t  sizeof(RF_DeviceConfig_t));\n\t\tRF_Free(d_cfg, sizeof(RF_DeviceConfig_t));\n\n\t\treturn (retcode);\n\n\tcase RAIDFRAME_CHECK_PARITY:\n\t\t*(int *) data = raidPtr->parity_good;\n\t\treturn (0);\n\tcase RAIDFRAME_RESET_ACCTOTALS:\n\t\tbzero(&raidPtr->acc_totals, sizeof(raidPtr->acc_totals));\n\t\treturn (0);\n  \n  \tcase RAIDFRAME_GET_ACCTOTALS:\n\t\ttotals = (RF_AccTotals_t *) data;\n\t\t*totals = raidPtr->acc_totals;\n\t\treturn (0);\n\n\tcase RAIDFRAME_KEEP_ACCTOTALS:\n\t\traidPtr->keep_acc_totals = *(int *)data;\n\t\treturn (0);\n  \n\tcase RAIDFRAME_GET_SIZE:\n\t\t*(int *) data = raidPtr->totalSectors;\n\t\treturn (0);\n\n\t\t/* fail a disk & optionally start reconstruction */\n\tcase RAIDFRAME_FAIL_DISK:\n\t\trr = (struct rf_recon_req *)data;\n\t\t\n\t\tif (rr->row < 0 || rr->row >= raidPtr->numRow ||\n\t\t    rr->col < 0 || rr->col >= raidPtr->numCol)\n\t\t\treturn (EINVAL);\n\n\t\tprintf(\"raid%d: Failing the disk: row: %d col: %d\\n\",\n\t\t       unit, rr->row, rr->col);\n\t\t\n\t\t/*\n\t\t * Make a copy of the recon request so that we don't\n\t\t * rely on the user's buffer\n\t\t */\n\t\tRF_Malloc(rrcopy, sizeof(*rrcopy), (struct rf_recon_req *));\n\t\tif (rrcopy == NULL)\n\t\t\treturn(ENOMEM);\n\t\tbcopy(rr, rrcopy, sizeof(*rr));\n\t\trrcopy->raidPtr = (void *)raidPtr;\n\n\t\tretcode = RF_CREATE_THREAD(raidPtr->recon_thread,\n\t\t\t\t\t   rf_ReconThread,\n\t\t\t\t\t   rrcopy,\"raid_recon\");\n\t\treturn (0);\n\t\t\n\t\t/*\n\t\t * Invoke a copyback operation after recon on whatever\n\t\t * disk needs it, if any.\n\t\t */\n\tcase RAIDFRAME_COPYBACK:\t\t\n\t\tif (raidPtr->Layout.map->faultsTolerated == 0) {\n\t\t\t/* This makes no sense on a RAID 0!! */\n\t\t\treturn(EINVAL);\n\t\t}\n  \n\t\tif (raidPtr->copyback_in_progress == 1) {\n\t\t\t/* Copyback is already in progress! */\n\t\t\treturn(EINVAL);\n\t\t}\n  \n\t\tretcode = RF_CREATE_THREAD(raidPtr->copyback_thread,\n\t\t\t\t\t   rf_CopybackThread,\n\t\t\t\t\t   raidPtr,\"raid_copyback\");\n\t\treturn (retcode);\n\t\t\n\t\t/* Return the percentage completion of reconstruction */\n\tcase RAIDFRAME_CHECK_RECON_STATUS:\n\t\tif (raidPtr->Layout.map->faultsTolerated == 0) {\n\t\t\t/* This makes no sense on a RAID 0 */\n\t\t\treturn(EINVAL);\n\t\t}\n\t\trow = 0; /* XXX we only consider a single row... */\n\t\tif (raidPtr->status[row] != rf_rs_reconstructing)\n\t\t\t*(int *)data = 100;\n\t\telse\n\t\t\t*(int *)data =\n\t\t\t    raidPtr->reconControl[row]->percentComplete;\n\t\treturn (0);\n\tcase RAIDFRAME_CHECK_PARITYREWRITE_STATUS:\n\t\tif (raidPtr->Layout.map->faultsTolerated == 0) {\n\t\t\t/* This makes no sense on a RAID 0 */\n\t\t\treturn(EINVAL);\n\t\t}\n\t\tif (raidPtr->parity_rewrite_in_progress == 1) {\n\t\t\t*(int *) data = 100 * raidPtr->parity_rewrite_stripes_done / raidPtr->Layout.numStripe;\n\t\t} else {\n\t\t\t*(int *) data = 100;\n\t\t}\n\t\treturn (0);\n\n\tcase RAIDFRAME_CHECK_COPYBACK_STATUS:\n\t\tif (raidPtr->Layout.map->faultsTolerated == 0) {\n\t\t\t/* This makes no sense on a RAID 0 */\n\t\t\treturn(EINVAL);\n\t\t}\n\t\tif (raidPtr->copyback_in_progress == 1) {\n\t\t\t*(int *) data = 100 * raidPtr->copyback_stripes_done / raidPtr->Layout.numStripe;\n\t\t} else {\n\t\t\t*(int *) data = 100;\n\t\t}\n\t\treturn (0);\n\n#if 0\n\tcase RAIDFRAME_SPARET_WAIT:\n\t\t/*\n\t\t * The sparetable daemon calls this to wait for the\n\t\t * kernel to need a spare table.\n\t\t * This ioctl does not return until a spare table is needed.\n\t\t * XXX -- Calling mpsleep here in the ioctl code is almost\n\t\t * certainly wrong and evil. -- XXX\n\t\t * XXX -- I should either compute the spare table in the\n\t\t * kernel, or have a different. -- XXX\n\t\t * XXX -- Interface (a different character device) for\n\t\t * delivering the table. -- XXX\n\t\t */\n\t\tRF_LOCK_MUTEX(rf_sparet_wait_mutex);\n\t\twhile (!rf_sparet_wait_queue)\n\t\t\tmpsleep(&rf_sparet_wait_queue, (PZERO + 1) | PCATCH,\n\t\t\t    \"sparet wait\", 0,\n\t\t\t    (void *)simple_lock_addr(rf_sparet_wait_mutex),\n\t\t\t    MS_LOCK_SIMPLE);\n\t\twaitreq = rf_sparet_wait_queue;\n\t\trf_sparet_wait_queue = rf_sparet_wait_queue->next;\n\t\tRF_UNLOCK_MUTEX(rf_sparet_wait_mutex);\n\t\t\n\t\t*((RF_SparetWait_t *)data) = *waitreq;\n\t\t\n\t\tRF_Free(waitreq, sizeof *waitreq);\n\t\treturn (0);\n\t\t\n\tcase RAIDFRAME_ABORT_SPARET_WAIT:\n\t\t/*\n\t\t * Wakes up a process waiting on SPARET_WAIT and puts an\n\t\t * error code in it that will cause the dameon to exit.\n\t\t */\n\t\tRF_Malloc(waitreq, sizeof (*waitreq), (RF_SparetWait_t *));\n\t\twaitreq->fcol = -1;\n\t\tRF_LOCK_MUTEX(rf_sparet_wait_mutex);\n\t\twaitreq->next = rf_sparet_wait_queue;\n\t\trf_sparet_wait_queue = waitreq;\n\t\tRF_UNLOCK_MUTEX(rf_sparet_wait_mutex);\n\t\twakeup(&rf_sparet_wait_queue);\n\t\treturn (0);\n\n\tcase RAIDFRAME_SEND_SPARET:\n\t\t/*\n\t\t * Used by the spare table daemon to deliver a spare table\n\t\t * into the kernel\n\t\t */\n\t\t\n\t\t/* Install the spare table */\n\t\tretcode = rf_SetSpareTable(raidPtr,*(void **)data);\n\t\t\n\t\t/*\n\t\t * Respond to the requestor.  the return status of the\n\t\t * spare table installation is passed in the \"fcol\" field\n\t\t */\n\t\tRF_Malloc(waitreq, sizeof *waitreq, (RF_SparetWait_t *));\n\t\twaitreq->fcol = retcode;\n\t\tRF_LOCK_MUTEX(rf_sparet_wait_mutex);\n\t\twaitreq->next = rf_sparet_resp_queue;\n\t\trf_sparet_resp_queue = waitreq;\n\t\twakeup(&rf_sparet_resp_queue);\n\t\tRF_UNLOCK_MUTEX(rf_sparet_wait_mutex);\n\t\t\n\t\treturn (retcode);\n#endif\n\tdefault:\n\t\t/* fall through to the os-specific code below */\n\t\tbreak;\n\t}\n\t\n\tif (!raidPtr->valid)\n\t\treturn (EINVAL);\n\t\n\t/*\n\t * Add support for \"regular\" device ioctls here.\n\t */\n\tswitch (cmd) {\n\tcase DIOCGDINFO:\n\t\t*(struct disklabel *)data = *(rs->sc_dkdev.dk_label);\n\t\tbreak;\n\n\tcase DIOCGPART:\n\t\t((struct partinfo *)data)->disklab = rs->sc_dkdev.dk_label;\n\t\t((struct partinfo *)data)->part =\n\t\t    &rs->sc_dkdev.dk_label->d_partitions[DISKPART(dev)];\n\t\tbreak;\n\n\tcase DIOCWDINFO:\n\tcase DIOCSDINFO:\n\t\tif ((error = raidlock(rs)) != 0)\n\t\t\treturn (error);\n\n\t\trs->sc_flags |= RAIDF_LABELLING;\n\n\t\terror = setdisklabel(rs->sc_dkdev.dk_label,\n\t\t    (struct disklabel *)data, 0, rs->sc_dkdev.dk_cpulabel);\n\t\tif (error == 0) {\n\t\t\tif (cmd == DIOCWDINFO)\n\t\t\t\terror = writedisklabel(RAIDLABELDEV(dev),\n\t\t\t\t    raidstrategy, rs->sc_dkdev.dk_label,\n\t\t\t\t    rs->sc_dkdev.dk_cpulabel);\n\t\t}\n\n\t\trs->sc_flags &= ~RAIDF_LABELLING;\n\n\t\traidunlock(rs);\n\n\t\tif (error)\n\t\t\treturn (error);\n\t\tbreak;\n\n\tcase DIOCWLABEL:\n\t\tif (*(int *)data != 0)\n\t\t\trs->sc_flags |= RAIDF_WLABEL;\n\t\telse\n\t\t\trs->sc_flags &= ~RAIDF_WLABEL;\n\t\tbreak;\n\n#if 0\n  \tcase DIOCGDEFLABEL:\n  \t\traidgetdefaultlabel(raidPtr, rs,\n  \t\t    (struct disklabel *) data);\n  \t\tbreak;\n#endif\n  \n\n\tdefault:\n\t\tretcode = ENOTTY;\n\t}\n\treturn (retcode);\n}"
  },
  {
    "function_name": "raidwrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_openbsdkintf.c",
    "lines": "604-621",
    "snippet": "int\nraidwrite(dev, uio, flags)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flags;\n{\n\tint unit = raidunit(dev);\n\tstruct raid_softc *rs;\n\n\tif (unit >= numraid)\n\t\treturn (ENXIO);\n\trs = &raid_softc[unit];\n\n\tif ((rs->sc_flags & RAIDF_INITED) == 0)\n\t\treturn (ENXIO);\n\tdb1_printf((\"raidwrite\\n\"));\n\treturn (physio(raidstrategy, NULL, dev, B_WRITE, minphys, uio));\n}",
    "includes": [
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_kintf.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_dagflags.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_copyback.h\"",
      "#include \"rf_raidframe.h\"",
      "#include \"rf_raid.h\"",
      "#include \"raid.h\"",
      "#include <sys/user.h>",
      "#include <sys/buf.h>",
      "#include <sys/lock.h>",
      "#include <sys/conf.h>",
      "#include <sys/namei.h>",
      "#include <sys/systm.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/device.h>",
      "#include <sys/disk.h>",
      "#include <sys/queue.h>",
      "#include <sys/malloc.h>",
      "#include <sys/param.h>",
      "#include <sys/errno.h>"
    ],
    "macros_used": [
      "#define RAIDF_INITED\t0x01\t/* unit has been initialized */"
    ],
    "globals_used": [
      "int\traidwrite",
      "void\traidstrategy",
      "static int numraid = 0;",
      "struct raid_softc *raid_softc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "physio",
          "args": [
            "raidstrategy",
            "NULL",
            "dev",
            "B_WRITE",
            "minphys",
            "uio"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db1_printf",
          "args": [
            "(\"raidwrite\\n\")"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raidunit",
          "args": [
            "dev"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\n#define RAIDF_INITED\t0x01\t/* unit has been initialized */\n\nint\traidwrite;\nvoid\traidstrategy;\nstatic int numraid = 0;\nstruct raid_softc *raid_softc;\n\nint\nraidwrite(dev, uio, flags)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flags;\n{\n\tint unit = raidunit(dev);\n\tstruct raid_softc *rs;\n\n\tif (unit >= numraid)\n\t\treturn (ENXIO);\n\trs = &raid_softc[unit];\n\n\tif ((rs->sc_flags & RAIDF_INITED) == 0)\n\t\treturn (ENXIO);\n\tdb1_printf((\"raidwrite\\n\"));\n\treturn (physio(raidstrategy, NULL, dev, B_WRITE, minphys, uio));\n}"
  },
  {
    "function_name": "raidread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_openbsdkintf.c",
    "lines": "580-601",
    "snippet": "int\nraidread(dev, uio, flags)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flags;\n{\n\tint unit = raidunit(dev);\n\tstruct raid_softc *rs;\n\tint part;\n\n\tif (unit >= numraid)\n\t\treturn (ENXIO);\n\trs = &raid_softc[unit];\n\n\tif ((rs->sc_flags & RAIDF_INITED) == 0)\n\t\treturn (ENXIO);\n\tpart = DISKPART(dev);\n\n\tdb1_printf((\"raidread: unit: %d partition: %d\\n\", unit, part));\n\n\treturn (physio(raidstrategy, NULL, dev, B_READ, minphys, uio));\n}",
    "includes": [
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_kintf.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_dagflags.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_copyback.h\"",
      "#include \"rf_raidframe.h\"",
      "#include \"rf_raid.h\"",
      "#include \"raid.h\"",
      "#include <sys/user.h>",
      "#include <sys/buf.h>",
      "#include <sys/lock.h>",
      "#include <sys/conf.h>",
      "#include <sys/namei.h>",
      "#include <sys/systm.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/device.h>",
      "#include <sys/disk.h>",
      "#include <sys/queue.h>",
      "#include <sys/malloc.h>",
      "#include <sys/param.h>",
      "#include <sys/errno.h>"
    ],
    "macros_used": [
      "#define RAIDF_INITED\t0x01\t/* unit has been initialized */"
    ],
    "globals_used": [
      "int\traidread",
      "void\traidstrategy",
      "static int numraid = 0;",
      "struct raid_softc *raid_softc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "physio",
          "args": [
            "raidstrategy",
            "NULL",
            "dev",
            "B_READ",
            "minphys",
            "uio"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db1_printf",
          "args": [
            "(\"raidread: unit: %d partition: %d\\n\", unit, part)"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DISKPART",
          "args": [
            "dev"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raidunit",
          "args": [
            "dev"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\n#define RAIDF_INITED\t0x01\t/* unit has been initialized */\n\nint\traidread;\nvoid\traidstrategy;\nstatic int numraid = 0;\nstruct raid_softc *raid_softc;\n\nint\nraidread(dev, uio, flags)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flags;\n{\n\tint unit = raidunit(dev);\n\tstruct raid_softc *rs;\n\tint part;\n\n\tif (unit >= numraid)\n\t\treturn (ENXIO);\n\trs = &raid_softc[unit];\n\n\tif ((rs->sc_flags & RAIDF_INITED) == 0)\n\t\treturn (ENXIO);\n\tpart = DISKPART(dev);\n\n\tdb1_printf((\"raidread: unit: %d partition: %d\\n\", unit, part));\n\n\treturn (physio(raidstrategy, NULL, dev, B_READ, minphys, uio));\n}"
  },
  {
    "function_name": "raidstrategy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_openbsdkintf.c",
    "lines": "506-577",
    "snippet": "void\nraidstrategy(bp)\n\tstruct buf *bp;\n{\n\tint s;\n\n\tunsigned int raidID = raidunit(bp->b_dev);\n\tRF_Raid_t *raidPtr;\n\tstruct raid_softc *rs = &raid_softc[raidID];\n\tstruct disklabel *lp;\n\tstruct buf *dp;\n\tint wlabel;\n\n\tif ((rs->sc_flags & RAIDF_INITED) ==0) {\n\t\tbp->b_error = ENXIO;\n\t\tbp->b_flags = B_ERROR;\n\t\tbp->b_resid = bp->b_bcount;\n\t\tbiodone(bp);\n  \t\treturn;\n\t}\n\tif (raidID >= numraid || !raidPtrs[raidID]) {\n\t\tbp->b_error = ENODEV;\n\t\tbp->b_flags |= B_ERROR;\n\t\tbp->b_resid = bp->b_bcount;\n\t\tbiodone(bp);\n\t\treturn;\n\t}\n\traidPtr = raidPtrs[raidID];\n\tif (!raidPtr->valid) {\n\t\tbp->b_error = ENODEV;\n\t\tbp->b_flags |= B_ERROR;\n\t\tbp->b_resid = bp->b_bcount;\n\t\tbiodone(bp);\n\t\treturn;\n\t}\n\tif (bp->b_bcount == 0) {\n\t\tdb1_printf((\"b_bcount is zero..\\n\"));\n\t\tbiodone(bp);\n\t\treturn;\n\t}\n\tlp = rs->sc_dkdev.dk_label;\n\n\t/*\n\t * Do bounds checking and adjust transfer.  If there's an\n\t * error, the bounds check will flag that for us.\n\t */\n\twlabel = rs->sc_flags & (RAIDF_WLABEL | RAIDF_LABELLING);\n\tif (DISKPART(bp->b_dev) != RAW_PART)\n\t\tif (bounds_check_with_label(bp, lp, rs->sc_dkdev.dk_cpulabel,\n\t\t    wlabel) <= 0) {\n\t\t\tdb1_printf((\"Bounds check failed!!:%d %d\\n\",\n\t\t\t    (int)bp->b_blkno, (int)wlabel));\n\t\t\tbiodone(bp);\n\t\t\treturn;\n\t\t}\n\n\ts = splbio();\n\n\tbp->b_resid = 0;\n\n\t/* stuff it onto our queue */\n\n\tdp = &rs->buf_queue;\n\tbp->b_actf = NULL;\n\tbp->b_actb = dp->b_actb;\n\t*dp->b_actb = bp;\n\tdp->b_actb = &bp->b_actf;\n\t\n\traidstart(raidPtrs[raidID]);\n\n\tsplx(s);\n}",
    "includes": [
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_kintf.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_dagflags.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_copyback.h\"",
      "#include \"rf_raidframe.h\"",
      "#include \"rf_raid.h\"",
      "#include \"raid.h\"",
      "#include <sys/user.h>",
      "#include <sys/buf.h>",
      "#include <sys/lock.h>",
      "#include <sys/conf.h>",
      "#include <sys/namei.h>",
      "#include <sys/systm.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/device.h>",
      "#include <sys/disk.h>",
      "#include <sys/queue.h>",
      "#include <sys/malloc.h>",
      "#include <sys/param.h>",
      "#include <sys/errno.h>"
    ],
    "macros_used": [
      "#define RAIDF_LABELLING\t0x04\t/* unit is currently being labelled */",
      "#define RAIDF_WLABEL\t0x02\t/* label area is writable */",
      "#define RAIDF_INITED\t0x01\t/* unit has been initialized */"
    ],
    "globals_used": [
      "static RF_Raid_t **raidPtrs;",
      "void\traidstrategy",
      "static int numraid = 0;",
      "struct raid_softc *raid_softc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raidstart",
          "args": [
            "raidPtrs[raidID]"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "raidstart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_openbsdkintf.c",
          "lines": "1351-1471",
          "snippet": "void\nraidstart(raidPtr)\n\tRF_Raid_t *raidPtr;\n{\n\tRF_SectorCount_t num_blocks, pb, sum;\n\tRF_RaidAddr_t raid_addr;\n\tint retcode;\n\tstruct partition *pp;\n\tdaddr_t blocknum;\t\n\tint unit;\n\tstruct raid_softc *rs;\n\tint\tdo_async;\n\tstruct buf *bp;\n\tstruct buf *dp;\n\n\tunit = raidPtr->raidid;\n\trs = &raid_softc[unit];\n\n\t\n\t/* Check to see if we're at the limit... */\n\tRF_LOCK_MUTEX(raidPtr->mutex);\n\twhile (raidPtr->openings > 0) {\n\t\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n  \n\t\t/* get the next item, if any, from the queue */\n\t\tdp = &rs->buf_queue;\n\t\tbp = dp->b_actf;\n\t\tif (bp == NULL) {\n\t\t\t/* nothing more to do */\n\t\t\treturn;\n\t\t}\n  \n\t\t/* update structures */\n\t\tdp = bp->b_actf;\n\t\tif (dp != NULL) {\n\t\t\tdp->b_actb = bp->b_actb;\n\t\t} else {\n\t\t\trs->buf_queue.b_actb = bp->b_actb;\n\t\t}\n\t\t*bp->b_actb = dp;\n  \n\t\t/* Ok, for the bp we have here, bp->b_blkno is relative to the\n\t\t * partition.. Need to make it absolute to the underlying \n\t\t * device.. */\n  \n\t\tblocknum = bp->b_blkno;\n\t\tif (DISKPART(bp->b_dev) != RAW_PART) {\n\t\t\tpp = &rs->sc_dkdev.dk_label->d_partitions[DISKPART(bp->b_dev)];\n\t\t\tblocknum += pp->p_offset;\n\t\t}\n  \n\t\tdb1_printf((\"Blocks: %d, %d\\n\", (int) bp->b_blkno, \n\t\t\t    (int) blocknum));\n\t\t\n\t\tdb1_printf((\"bp->b_bcount = %d\\n\", (int) bp->b_bcount));\n\t\tdb1_printf((\"bp->b_resid = %d\\n\", (int) bp->b_resid));\n\t\t\n\t\t/* *THIS* is where we adjust what block we're going to... \n\t\t * but DO NOT TOUCH bp->b_blkno!!! */\n\t\traid_addr = blocknum;\n\t\t\n\t\tnum_blocks = bp->b_bcount >> raidPtr->logBytesPerSector;\n\t\tpb = (bp->b_bcount & raidPtr->sectorMask) ? 1 : 0;\n\t\tsum = raid_addr + num_blocks + pb;\n\t\tif (1 || rf_debugKernelAccess) {\n\t\t\tdb1_printf((\"raid_addr=%d sum=%d num_blocks=%d(+%d) (%d)\\n\",\n\t\t\t\t    (int) raid_addr, (int) sum, (int) num_blocks,\n\t\t\t\t    (int) pb, (int) bp->b_resid));\n\t\t}\n\t\tif ((sum > raidPtr->totalSectors) || (sum < raid_addr)\n\t\t    || (sum < num_blocks) || (sum < pb)) {\n\t\t\tbp->b_error = ENOSPC;\n\t\t\tbp->b_flags |= B_ERROR;\n\t\t\tbp->b_resid = bp->b_bcount;\n\t\t\tbiodone(bp);\n\t\t\tRF_LOCK_MUTEX(raidPtr->mutex);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * XXX rf_DoAccess() should do this, not just DoAccessKernel()\n\t\t */\n\t\t\n\t\tif (bp->b_bcount & raidPtr->sectorMask) {\n\t\t\tbp->b_error = EINVAL;\n\t\t\tbp->b_flags |= B_ERROR;\n\t\t\tbp->b_resid = bp->b_bcount;\n\t\t\tbiodone(bp);\n\t\t\tRF_LOCK_MUTEX(raidPtr->mutex);\n\t\t\tcontinue;\n\t\t\t\n\t\t}\n\t\tdb1_printf((\"Calling DoAccess..\\n\"));\n\t\t\n  \n\t\tRF_LOCK_MUTEX(raidPtr->mutex);\n\t\traidPtr->openings--;\n\t\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\n\t\t/*\n\t\t * Everything is async.\n\t\t */\n\t\tdo_async = 1;\n\t\t\n\t\t/* don't ever condition on bp->b_flags & B_WRITE.  \n\t\t * always condition on B_READ instead */\n\t\t\n\t\t/* XXX we're still at splbio() here... do we *really* \n\t\t   need to be? */\n\n\t\t\n\t\tretcode = rf_DoAccess(raidPtr, (bp->b_flags & B_READ) ?\n\t\t\t\t      RF_IO_TYPE_READ : RF_IO_TYPE_WRITE,\n\t\t\t\t      do_async, raid_addr, num_blocks,\n\t\t\t\t      bp->b_un.b_addr, bp, NULL, NULL, \n\t\t\t\t      RF_DAG_NONBLOCKING_IO, NULL, NULL, NULL);\n\n\n\t\tRF_LOCK_MUTEX(raidPtr->mutex);\n\t}\n\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n}",
          "includes": [
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_dagflags.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_raidframe.h\"",
            "#include \"rf_raid.h\"",
            "#include \"raid.h\"",
            "#include <sys/user.h>",
            "#include <sys/buf.h>",
            "#include <sys/lock.h>",
            "#include <sys/conf.h>",
            "#include <sys/namei.h>",
            "#include <sys/systm.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/device.h>",
            "#include <sys/disk.h>",
            "#include <sys/queue.h>",
            "#include <sys/malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct raid_softc *raid_softc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\nstruct raid_softc *raid_softc;\n\nvoid\nraidstart(raidPtr)\n\tRF_Raid_t *raidPtr;\n{\n\tRF_SectorCount_t num_blocks, pb, sum;\n\tRF_RaidAddr_t raid_addr;\n\tint retcode;\n\tstruct partition *pp;\n\tdaddr_t blocknum;\t\n\tint unit;\n\tstruct raid_softc *rs;\n\tint\tdo_async;\n\tstruct buf *bp;\n\tstruct buf *dp;\n\n\tunit = raidPtr->raidid;\n\trs = &raid_softc[unit];\n\n\t\n\t/* Check to see if we're at the limit... */\n\tRF_LOCK_MUTEX(raidPtr->mutex);\n\twhile (raidPtr->openings > 0) {\n\t\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n  \n\t\t/* get the next item, if any, from the queue */\n\t\tdp = &rs->buf_queue;\n\t\tbp = dp->b_actf;\n\t\tif (bp == NULL) {\n\t\t\t/* nothing more to do */\n\t\t\treturn;\n\t\t}\n  \n\t\t/* update structures */\n\t\tdp = bp->b_actf;\n\t\tif (dp != NULL) {\n\t\t\tdp->b_actb = bp->b_actb;\n\t\t} else {\n\t\t\trs->buf_queue.b_actb = bp->b_actb;\n\t\t}\n\t\t*bp->b_actb = dp;\n  \n\t\t/* Ok, for the bp we have here, bp->b_blkno is relative to the\n\t\t * partition.. Need to make it absolute to the underlying \n\t\t * device.. */\n  \n\t\tblocknum = bp->b_blkno;\n\t\tif (DISKPART(bp->b_dev) != RAW_PART) {\n\t\t\tpp = &rs->sc_dkdev.dk_label->d_partitions[DISKPART(bp->b_dev)];\n\t\t\tblocknum += pp->p_offset;\n\t\t}\n  \n\t\tdb1_printf((\"Blocks: %d, %d\\n\", (int) bp->b_blkno, \n\t\t\t    (int) blocknum));\n\t\t\n\t\tdb1_printf((\"bp->b_bcount = %d\\n\", (int) bp->b_bcount));\n\t\tdb1_printf((\"bp->b_resid = %d\\n\", (int) bp->b_resid));\n\t\t\n\t\t/* *THIS* is where we adjust what block we're going to... \n\t\t * but DO NOT TOUCH bp->b_blkno!!! */\n\t\traid_addr = blocknum;\n\t\t\n\t\tnum_blocks = bp->b_bcount >> raidPtr->logBytesPerSector;\n\t\tpb = (bp->b_bcount & raidPtr->sectorMask) ? 1 : 0;\n\t\tsum = raid_addr + num_blocks + pb;\n\t\tif (1 || rf_debugKernelAccess) {\n\t\t\tdb1_printf((\"raid_addr=%d sum=%d num_blocks=%d(+%d) (%d)\\n\",\n\t\t\t\t    (int) raid_addr, (int) sum, (int) num_blocks,\n\t\t\t\t    (int) pb, (int) bp->b_resid));\n\t\t}\n\t\tif ((sum > raidPtr->totalSectors) || (sum < raid_addr)\n\t\t    || (sum < num_blocks) || (sum < pb)) {\n\t\t\tbp->b_error = ENOSPC;\n\t\t\tbp->b_flags |= B_ERROR;\n\t\t\tbp->b_resid = bp->b_bcount;\n\t\t\tbiodone(bp);\n\t\t\tRF_LOCK_MUTEX(raidPtr->mutex);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * XXX rf_DoAccess() should do this, not just DoAccessKernel()\n\t\t */\n\t\t\n\t\tif (bp->b_bcount & raidPtr->sectorMask) {\n\t\t\tbp->b_error = EINVAL;\n\t\t\tbp->b_flags |= B_ERROR;\n\t\t\tbp->b_resid = bp->b_bcount;\n\t\t\tbiodone(bp);\n\t\t\tRF_LOCK_MUTEX(raidPtr->mutex);\n\t\t\tcontinue;\n\t\t\t\n\t\t}\n\t\tdb1_printf((\"Calling DoAccess..\\n\"));\n\t\t\n  \n\t\tRF_LOCK_MUTEX(raidPtr->mutex);\n\t\traidPtr->openings--;\n\t\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\n\t\t/*\n\t\t * Everything is async.\n\t\t */\n\t\tdo_async = 1;\n\t\t\n\t\t/* don't ever condition on bp->b_flags & B_WRITE.  \n\t\t * always condition on B_READ instead */\n\t\t\n\t\t/* XXX we're still at splbio() here... do we *really* \n\t\t   need to be? */\n\n\t\t\n\t\tretcode = rf_DoAccess(raidPtr, (bp->b_flags & B_READ) ?\n\t\t\t\t      RF_IO_TYPE_READ : RF_IO_TYPE_WRITE,\n\t\t\t\t      do_async, raid_addr, num_blocks,\n\t\t\t\t      bp->b_un.b_addr, bp, NULL, NULL, \n\t\t\t\t      RF_DAG_NONBLOCKING_IO, NULL, NULL, NULL);\n\n\n\t\tRF_LOCK_MUTEX(raidPtr->mutex);\n\t}\n\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "biodone",
          "args": [
            "bp"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db1_printf",
          "args": [
            "(\"Bounds check failed!!:%d %d\\n\",\n\t\t\t    (int)bp->b_blkno, (int)wlabel)"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bounds_check_with_label",
          "args": [
            "bp",
            "lp",
            "rs->sc_dkdev.dk_cpulabel",
            "wlabel"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DISKPART",
          "args": [
            "bp->b_dev"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "biodone",
          "args": [
            "bp"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db1_printf",
          "args": [
            "(\"b_bcount is zero..\\n\")"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "biodone",
          "args": [
            "bp"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "biodone",
          "args": [
            "bp"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "biodone",
          "args": [
            "bp"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raidunit",
          "args": [
            "bp->b_dev"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\n#define RAIDF_LABELLING\t0x04\t/* unit is currently being labelled */\n#define RAIDF_WLABEL\t0x02\t/* label area is writable */\n#define RAIDF_INITED\t0x01\t/* unit has been initialized */\n\nstatic RF_Raid_t **raidPtrs;\nvoid\traidstrategy;\nstatic int numraid = 0;\nstruct raid_softc *raid_softc;\n\nvoid\nraidstrategy(bp)\n\tstruct buf *bp;\n{\n\tint s;\n\n\tunsigned int raidID = raidunit(bp->b_dev);\n\tRF_Raid_t *raidPtr;\n\tstruct raid_softc *rs = &raid_softc[raidID];\n\tstruct disklabel *lp;\n\tstruct buf *dp;\n\tint wlabel;\n\n\tif ((rs->sc_flags & RAIDF_INITED) ==0) {\n\t\tbp->b_error = ENXIO;\n\t\tbp->b_flags = B_ERROR;\n\t\tbp->b_resid = bp->b_bcount;\n\t\tbiodone(bp);\n  \t\treturn;\n\t}\n\tif (raidID >= numraid || !raidPtrs[raidID]) {\n\t\tbp->b_error = ENODEV;\n\t\tbp->b_flags |= B_ERROR;\n\t\tbp->b_resid = bp->b_bcount;\n\t\tbiodone(bp);\n\t\treturn;\n\t}\n\traidPtr = raidPtrs[raidID];\n\tif (!raidPtr->valid) {\n\t\tbp->b_error = ENODEV;\n\t\tbp->b_flags |= B_ERROR;\n\t\tbp->b_resid = bp->b_bcount;\n\t\tbiodone(bp);\n\t\treturn;\n\t}\n\tif (bp->b_bcount == 0) {\n\t\tdb1_printf((\"b_bcount is zero..\\n\"));\n\t\tbiodone(bp);\n\t\treturn;\n\t}\n\tlp = rs->sc_dkdev.dk_label;\n\n\t/*\n\t * Do bounds checking and adjust transfer.  If there's an\n\t * error, the bounds check will flag that for us.\n\t */\n\twlabel = rs->sc_flags & (RAIDF_WLABEL | RAIDF_LABELLING);\n\tif (DISKPART(bp->b_dev) != RAW_PART)\n\t\tif (bounds_check_with_label(bp, lp, rs->sc_dkdev.dk_cpulabel,\n\t\t    wlabel) <= 0) {\n\t\t\tdb1_printf((\"Bounds check failed!!:%d %d\\n\",\n\t\t\t    (int)bp->b_blkno, (int)wlabel));\n\t\t\tbiodone(bp);\n\t\t\treturn;\n\t\t}\n\n\ts = splbio();\n\n\tbp->b_resid = 0;\n\n\t/* stuff it onto our queue */\n\n\tdp = &rs->buf_queue;\n\tbp->b_actf = NULL;\n\tbp->b_actb = dp->b_actb;\n\t*dp->b_actb = bp;\n\tdp->b_actb = &bp->b_actf;\n\t\n\traidstart(raidPtrs[raidID]);\n\n\tsplx(s);\n}"
  },
  {
    "function_name": "raidclose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_openbsdkintf.c",
    "lines": "460-504",
    "snippet": "int\nraidclose(dev, flags, fmt, p)\n\tdev_t dev;\n\tint flags, fmt;\n\tstruct proc *p;\n{\n\tint unit = raidunit(dev);\n\tstruct raid_softc *rs;\n\tint error = 0;\n\tint part;\n\n\tif (unit >= numraid)\n\t\treturn (ENXIO);\n\trs = &raid_softc[unit];\n\n\tif ((error = raidlock(rs)) != 0)\n\t\treturn (error);\n\n\tpart = DISKPART(dev);\n\n\t/* ...that much closer to allowing unconfiguration... */\n\tswitch (fmt) {\n\tcase S_IFCHR:\n\t\trs->sc_dkdev.dk_copenmask &= ~(1 << part);\n\t\tbreak;\n\n\tcase S_IFBLK:\n\t\trs->sc_dkdev.dk_bopenmask &= ~(1 << part);\n\t\tbreak;\n\t}\n\trs->sc_dkdev.dk_openmask =\n\t    rs->sc_dkdev.dk_copenmask | rs->sc_dkdev.dk_bopenmask;\n\n\tif ((rs->sc_dkdev.dk_openmask == 0) &&\n\t    ((rs->sc_flags & RAIDF_INITED) != 0)) {\n\t        /* Last one... device is not unconfigured yet.\n\t           Device shutdown has taken care of setting the\n\t           clean bits if RAIDF_INITED is not set\n\t           mark things as clean... */\n\t        rf_update_component_labels( raidPtrs[unit] );\n\t}\n\n\traidunlock(rs);\n\treturn (0);\n}",
    "includes": [
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_kintf.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_dagflags.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_copyback.h\"",
      "#include \"rf_raidframe.h\"",
      "#include \"rf_raid.h\"",
      "#include \"raid.h\"",
      "#include <sys/user.h>",
      "#include <sys/buf.h>",
      "#include <sys/lock.h>",
      "#include <sys/conf.h>",
      "#include <sys/namei.h>",
      "#include <sys/systm.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/device.h>",
      "#include <sys/disk.h>",
      "#include <sys/queue.h>",
      "#include <sys/malloc.h>",
      "#include <sys/param.h>",
      "#include <sys/errno.h>"
    ],
    "macros_used": [
      "#define RAIDF_INITED\t0x01\t/* unit has been initialized */"
    ],
    "globals_used": [
      "static RF_Raid_t **raidPtrs;",
      "int\traidclose",
      "static int numraid = 0;",
      "struct raid_softc *raid_softc;",
      "int\traidlock",
      "void\traidunlock"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raidunlock",
          "args": [
            "rs"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "raidunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_openbsdkintf.c",
          "lines": "1918-1927",
          "snippet": "void\nraidunlock(rs)\n\tstruct raid_softc *rs;\n{\n\trs->sc_flags &= ~RAIDF_LOCKED;\n\tif ((rs->sc_flags & RAIDF_WANTED) != 0) {\n\t\trs->sc_flags &= ~RAIDF_WANTED;\n\t\twakeup(rs);\n\t}\n}",
          "includes": [
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_dagflags.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_raidframe.h\"",
            "#include \"rf_raid.h\"",
            "#include \"raid.h\"",
            "#include <sys/user.h>",
            "#include <sys/buf.h>",
            "#include <sys/lock.h>",
            "#include <sys/conf.h>",
            "#include <sys/namei.h>",
            "#include <sys/systm.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/device.h>",
            "#include <sys/disk.h>",
            "#include <sys/queue.h>",
            "#include <sys/malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/errno.h>"
          ],
          "macros_used": [
            "#define RAIDF_LOCKED\t0x80\t/* unit is locked */",
            "#define RAIDF_WANTED\t0x40\t/* someone is waiting to obtain a lock */"
          ],
          "globals_used": [
            "struct raid_softc *raid_softc;",
            "void\traidunlock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\n#define RAIDF_LOCKED\t0x80\t/* unit is locked */\n#define RAIDF_WANTED\t0x40\t/* someone is waiting to obtain a lock */\n\nstruct raid_softc *raid_softc;\nvoid\traidunlock;\n\nvoid\nraidunlock(rs)\n\tstruct raid_softc *rs;\n{\n\trs->sc_flags &= ~RAIDF_LOCKED;\n\tif ((rs->sc_flags & RAIDF_WANTED) != 0) {\n\t\trs->sc_flags &= ~RAIDF_WANTED;\n\t\twakeup(rs);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_update_component_labels",
          "args": [
            "raidPtrs[unit]"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "rf_update_component_labels",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_openbsdkintf.c",
          "lines": "2137-2252",
          "snippet": "void\nrf_update_component_labels( raidPtr )\n\tRF_Raid_t *raidPtr;\n{\n\tRF_ComponentLabel_t c_label;\n\tint sparecol;\n\tint r,c;\n\tint i,j;\n\tint srow, scol;\n\n\tsrow = -1;\n\tscol = -1;\n\n\t/* XXX should do extra checks to make sure things really are clean, \n\t   rather than blindly setting the clean bit... */\n\n\traidPtr->mod_counter++;\n\n\tfor (r = 0; r < raidPtr->numRow; r++) {\n\t\tfor (c = 0; c < raidPtr->numCol; c++) {\n\t\t\tif (raidPtr->Disks[r][c].status == rf_ds_optimal) {\n\t\t\t\traidread_component_label(\n\t\t\t\t\traidPtr->Disks[r][c].dev,\n\t\t\t\t\traidPtr->raid_cinfo[r][c].ci_vp,\n\t\t\t\t\t&c_label);\n\t\t\t\t/* make sure status is noted */\n\t\t\t\tc_label.status = rf_ds_optimal;\n\t\t\t\traidwrite_component_label( \n\t\t\t\t\traidPtr->Disks[r][c].dev,\n\t\t\t\t\traidPtr->raid_cinfo[r][c].ci_vp,\n\t\t\t\t\t&c_label);\n\t\t\t\tif (raidPtr->parity_good == RF_RAID_CLEAN) {\n\t\t\t\t\traidmarkclean( \n\t\t\t\t\t      raidPtr->Disks[r][c].dev, \n\t\t\t\t\t      raidPtr->raid_cinfo[r][c].ci_vp,\n\t\t\t\t\t      raidPtr->mod_counter);\n\t\t\t\t}\n\t\t\t} \n\t\t\t/* else we don't touch it.. */\n#if 0\n\t\t\telse if (raidPtr->Disks[r][c].status !=\n\t\t\t\t   rf_ds_failed) {\n\t\t\t\traidread_component_label(\n\t\t\t\t\traidPtr->Disks[r][c].dev,\n\t\t\t\t\traidPtr->raid_cinfo[r][c].ci_vp,\n\t\t\t\t\t&c_label);\n\t\t\t\t/* make sure status is noted */\n\t\t\t\tc_label.status = \n\t\t\t\t\traidPtr->Disks[r][c].status;\n\t\t\t\traidwrite_component_label( \n\t\t\t\t\traidPtr->Disks[r][c].dev,\n\t\t\t\t\traidPtr->raid_cinfo[r][c].ci_vp,\n\t\t\t\t\t&c_label);\n\t\t\t\tif (raidPtr->parity_good == RF_RAID_CLEAN) {\n\t\t\t\t\traidmarkclean( \n\t\t\t\t\t      raidPtr->Disks[r][c].dev, \n\t\t\t\t\t      raidPtr->raid_cinfo[r][c].ci_vp,\n\t\t\t\t\t      raidPtr->mod_counter);\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t} \n\t}\n\n\tfor( c = 0; c < raidPtr->numSpare ; c++) {\n\t\tsparecol = raidPtr->numCol + c;\n\t\tif (raidPtr->Disks[0][sparecol].status == rf_ds_used_spare) {\n\t\t\t/* \n\t\t\t   \n\t\t\t   we claim this disk is \"optimal\" if it's \n\t\t\t   rf_ds_used_spare, as that means it should be \n\t\t\t   directly substitutable for the disk it replaced. \n\t\t\t   We note that too...\n\n\t\t\t */\n\n\t\t\tfor(i=0;i<raidPtr->numRow;i++) {\n\t\t\t\tfor(j=0;j<raidPtr->numCol;j++) {\n\t\t\t\t\tif ((raidPtr->Disks[i][j].spareRow == \n\t\t\t\t\t     0) &&\n\t\t\t\t\t    (raidPtr->Disks[i][j].spareCol ==\n\t\t\t\t\t     sparecol)) {\n\t\t\t\t\t\tsrow = i;\n\t\t\t\t\t\tscol = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\traidread_component_label( \n\t\t\t\t      raidPtr->Disks[0][sparecol].dev,\n\t\t\t\t      raidPtr->raid_cinfo[0][sparecol].ci_vp,\n\t\t\t\t      &c_label);\n\t\t\t/* make sure status is noted */\n\t\t\tc_label.version = RF_COMPONENT_LABEL_VERSION; \n\t\t\tc_label.mod_counter = raidPtr->mod_counter;\n\t\t\tc_label.serial_number = raidPtr->serial_number;\n\t\t\tc_label.row = srow;\n\t\t\tc_label.column = scol;\n\t\t\tc_label.num_rows = raidPtr->numRow;\n\t\t\tc_label.num_columns = raidPtr->numCol;\n\t\t\tc_label.clean = RF_RAID_DIRTY; /* changed in a bit*/\n\t\t\tc_label.status = rf_ds_optimal;\n\t\t\traidwrite_component_label(\n\t\t\t\t      raidPtr->Disks[0][sparecol].dev,\n\t\t\t\t      raidPtr->raid_cinfo[0][sparecol].ci_vp,\n\t\t\t\t      &c_label);\n\t\t\tif (raidPtr->parity_good == RF_RAID_CLEAN) {\n\t\t\t\traidmarkclean( raidPtr->Disks[0][sparecol].dev,\n\t\t\t              raidPtr->raid_cinfo[0][sparecol].ci_vp,\n\t\t\t\t\t       raidPtr->mod_counter);\n\t\t\t}\n\t\t}\n\t}\n\t/* \tprintf(\"Component labels updated\\n\"); */\n}",
          "includes": [
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_dagflags.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_raidframe.h\"",
            "#include \"rf_raid.h\"",
            "#include \"raid.h\"",
            "#include <sys/user.h>",
            "#include <sys/buf.h>",
            "#include <sys/lock.h>",
            "#include <sys/conf.h>",
            "#include <sys/namei.h>",
            "#include <sys/systm.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/device.h>",
            "#include <sys/disk.h>",
            "#include <sys/queue.h>",
            "#include <sys/malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\nvoid\nrf_update_component_labels( raidPtr )\n\tRF_Raid_t *raidPtr;\n{\n\tRF_ComponentLabel_t c_label;\n\tint sparecol;\n\tint r,c;\n\tint i,j;\n\tint srow, scol;\n\n\tsrow = -1;\n\tscol = -1;\n\n\t/* XXX should do extra checks to make sure things really are clean, \n\t   rather than blindly setting the clean bit... */\n\n\traidPtr->mod_counter++;\n\n\tfor (r = 0; r < raidPtr->numRow; r++) {\n\t\tfor (c = 0; c < raidPtr->numCol; c++) {\n\t\t\tif (raidPtr->Disks[r][c].status == rf_ds_optimal) {\n\t\t\t\traidread_component_label(\n\t\t\t\t\traidPtr->Disks[r][c].dev,\n\t\t\t\t\traidPtr->raid_cinfo[r][c].ci_vp,\n\t\t\t\t\t&c_label);\n\t\t\t\t/* make sure status is noted */\n\t\t\t\tc_label.status = rf_ds_optimal;\n\t\t\t\traidwrite_component_label( \n\t\t\t\t\traidPtr->Disks[r][c].dev,\n\t\t\t\t\traidPtr->raid_cinfo[r][c].ci_vp,\n\t\t\t\t\t&c_label);\n\t\t\t\tif (raidPtr->parity_good == RF_RAID_CLEAN) {\n\t\t\t\t\traidmarkclean( \n\t\t\t\t\t      raidPtr->Disks[r][c].dev, \n\t\t\t\t\t      raidPtr->raid_cinfo[r][c].ci_vp,\n\t\t\t\t\t      raidPtr->mod_counter);\n\t\t\t\t}\n\t\t\t} \n\t\t\t/* else we don't touch it.. */\n#if 0\n\t\t\telse if (raidPtr->Disks[r][c].status !=\n\t\t\t\t   rf_ds_failed) {\n\t\t\t\traidread_component_label(\n\t\t\t\t\traidPtr->Disks[r][c].dev,\n\t\t\t\t\traidPtr->raid_cinfo[r][c].ci_vp,\n\t\t\t\t\t&c_label);\n\t\t\t\t/* make sure status is noted */\n\t\t\t\tc_label.status = \n\t\t\t\t\traidPtr->Disks[r][c].status;\n\t\t\t\traidwrite_component_label( \n\t\t\t\t\traidPtr->Disks[r][c].dev,\n\t\t\t\t\traidPtr->raid_cinfo[r][c].ci_vp,\n\t\t\t\t\t&c_label);\n\t\t\t\tif (raidPtr->parity_good == RF_RAID_CLEAN) {\n\t\t\t\t\traidmarkclean( \n\t\t\t\t\t      raidPtr->Disks[r][c].dev, \n\t\t\t\t\t      raidPtr->raid_cinfo[r][c].ci_vp,\n\t\t\t\t\t      raidPtr->mod_counter);\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t} \n\t}\n\n\tfor( c = 0; c < raidPtr->numSpare ; c++) {\n\t\tsparecol = raidPtr->numCol + c;\n\t\tif (raidPtr->Disks[0][sparecol].status == rf_ds_used_spare) {\n\t\t\t/* \n\t\t\t   \n\t\t\t   we claim this disk is \"optimal\" if it's \n\t\t\t   rf_ds_used_spare, as that means it should be \n\t\t\t   directly substitutable for the disk it replaced. \n\t\t\t   We note that too...\n\n\t\t\t */\n\n\t\t\tfor(i=0;i<raidPtr->numRow;i++) {\n\t\t\t\tfor(j=0;j<raidPtr->numCol;j++) {\n\t\t\t\t\tif ((raidPtr->Disks[i][j].spareRow == \n\t\t\t\t\t     0) &&\n\t\t\t\t\t    (raidPtr->Disks[i][j].spareCol ==\n\t\t\t\t\t     sparecol)) {\n\t\t\t\t\t\tsrow = i;\n\t\t\t\t\t\tscol = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\traidread_component_label( \n\t\t\t\t      raidPtr->Disks[0][sparecol].dev,\n\t\t\t\t      raidPtr->raid_cinfo[0][sparecol].ci_vp,\n\t\t\t\t      &c_label);\n\t\t\t/* make sure status is noted */\n\t\t\tc_label.version = RF_COMPONENT_LABEL_VERSION; \n\t\t\tc_label.mod_counter = raidPtr->mod_counter;\n\t\t\tc_label.serial_number = raidPtr->serial_number;\n\t\t\tc_label.row = srow;\n\t\t\tc_label.column = scol;\n\t\t\tc_label.num_rows = raidPtr->numRow;\n\t\t\tc_label.num_columns = raidPtr->numCol;\n\t\t\tc_label.clean = RF_RAID_DIRTY; /* changed in a bit*/\n\t\t\tc_label.status = rf_ds_optimal;\n\t\t\traidwrite_component_label(\n\t\t\t\t      raidPtr->Disks[0][sparecol].dev,\n\t\t\t\t      raidPtr->raid_cinfo[0][sparecol].ci_vp,\n\t\t\t\t      &c_label);\n\t\t\tif (raidPtr->parity_good == RF_RAID_CLEAN) {\n\t\t\t\traidmarkclean( raidPtr->Disks[0][sparecol].dev,\n\t\t\t              raidPtr->raid_cinfo[0][sparecol].ci_vp,\n\t\t\t\t\t       raidPtr->mod_counter);\n\t\t\t}\n\t\t}\n\t}\n\t/* \tprintf(\"Component labels updated\\n\"); */\n}"
        }
      },
      {
        "call_info": {
          "callee": "DISKPART",
          "args": [
            "dev"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raidlock",
          "args": [
            "rs"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "raidlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_openbsdkintf.c",
          "lines": "1900-1913",
          "snippet": "int\nraidlock(rs)\n\tstruct raid_softc *rs;\n{\n\tint error;\n\n\twhile ((rs->sc_flags & RAIDF_LOCKED) != 0) {\n\t\trs->sc_flags |= RAIDF_WANTED;\n\t\tif ((error = tsleep(rs, PRIBIO | PCATCH, \"raidlck\", 0)) != 0)\n\t\t\treturn (error);\n\t}\n\trs->sc_flags |= RAIDF_LOCKED;\n\treturn (0);\n}",
          "includes": [
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_dagflags.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_raidframe.h\"",
            "#include \"rf_raid.h\"",
            "#include \"raid.h\"",
            "#include <sys/user.h>",
            "#include <sys/buf.h>",
            "#include <sys/lock.h>",
            "#include <sys/conf.h>",
            "#include <sys/namei.h>",
            "#include <sys/systm.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/device.h>",
            "#include <sys/disk.h>",
            "#include <sys/queue.h>",
            "#include <sys/malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/errno.h>"
          ],
          "macros_used": [
            "#define RAIDF_LOCKED\t0x80\t/* unit is locked */",
            "#define RAIDF_WANTED\t0x40\t/* someone is waiting to obtain a lock */"
          ],
          "globals_used": [
            "struct raid_softc *raid_softc;",
            "int\traidlock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\n#define RAIDF_LOCKED\t0x80\t/* unit is locked */\n#define RAIDF_WANTED\t0x40\t/* someone is waiting to obtain a lock */\n\nstruct raid_softc *raid_softc;\nint\traidlock;\n\nint\nraidlock(rs)\n\tstruct raid_softc *rs;\n{\n\tint error;\n\n\twhile ((rs->sc_flags & RAIDF_LOCKED) != 0) {\n\t\trs->sc_flags |= RAIDF_WANTED;\n\t\tif ((error = tsleep(rs, PRIBIO | PCATCH, \"raidlck\", 0)) != 0)\n\t\t\treturn (error);\n\t}\n\trs->sc_flags |= RAIDF_LOCKED;\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raidunit",
          "args": [
            "dev"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\n#define RAIDF_INITED\t0x01\t/* unit has been initialized */\n\nstatic RF_Raid_t **raidPtrs;\nint\traidclose;\nstatic int numraid = 0;\nstruct raid_softc *raid_softc;\nint\traidlock;\nvoid\traidunlock;\n\nint\nraidclose(dev, flags, fmt, p)\n\tdev_t dev;\n\tint flags, fmt;\n\tstruct proc *p;\n{\n\tint unit = raidunit(dev);\n\tstruct raid_softc *rs;\n\tint error = 0;\n\tint part;\n\n\tif (unit >= numraid)\n\t\treturn (ENXIO);\n\trs = &raid_softc[unit];\n\n\tif ((error = raidlock(rs)) != 0)\n\t\treturn (error);\n\n\tpart = DISKPART(dev);\n\n\t/* ...that much closer to allowing unconfiguration... */\n\tswitch (fmt) {\n\tcase S_IFCHR:\n\t\trs->sc_dkdev.dk_copenmask &= ~(1 << part);\n\t\tbreak;\n\n\tcase S_IFBLK:\n\t\trs->sc_dkdev.dk_bopenmask &= ~(1 << part);\n\t\tbreak;\n\t}\n\trs->sc_dkdev.dk_openmask =\n\t    rs->sc_dkdev.dk_copenmask | rs->sc_dkdev.dk_bopenmask;\n\n\tif ((rs->sc_dkdev.dk_openmask == 0) &&\n\t    ((rs->sc_flags & RAIDF_INITED) != 0)) {\n\t        /* Last one... device is not unconfigured yet.\n\t           Device shutdown has taken care of setting the\n\t           clean bits if RAIDF_INITED is not set\n\t           mark things as clean... */\n\t        rf_update_component_labels( raidPtrs[unit] );\n\t}\n\n\traidunlock(rs);\n\treturn (0);\n}"
  },
  {
    "function_name": "raidopen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_openbsdkintf.c",
    "lines": "383-457",
    "snippet": "int\nraidopen(dev, flags, fmt, p)\n\tdev_t dev;\n\tint flags, fmt;\n\tstruct proc *p;\n{\n\tint unit = raidunit(dev);\n\tstruct raid_softc *rs;\n\tstruct disklabel *lp;\n\tint part,pmask;\n\tint error = 0;\n\t\n\tif (unit >= numraid)\n\t\treturn (ENXIO);\n\trs = &raid_softc[unit];\n\n\tif ((error = raidlock(rs)) != 0)\n\t\treturn (error);\n\tlp = rs->sc_dkdev.dk_label;\n\n\tpart = DISKPART(dev);\n\tpmask = (1 << part);\n\n\tdb1_printf(\n\t    (\"Opening raid device number: %d partition: %d\\n\", unit, part));\n\n\n\tif ((rs->sc_flags & RAIDF_INITED) && (rs->sc_dkdev.dk_openmask == 0))\n\t\traidgetdisklabel(dev);\n\n\t/* make sure that this partition exists */\n\n\tif (part != RAW_PART) {\n\t\tdb1_printf((\"Not a raw partition..\\n\"));\n\t\tif (((rs->sc_flags & RAIDF_INITED) == 0) ||\n\t\t    ((part >= lp->d_npartitions) ||\n\t\t    (lp->d_partitions[part].p_fstype == FS_UNUSED))) {\n\t\t\terror = ENXIO;\n\t\t\traidunlock(rs);\n\t\t\tdb1_printf((\"Bailing out...\\n\"));\n\t\t\treturn (error);\n\t\t}\n\t}\n\n\t/* Prevent this unit from being unconfigured while open. */\n\tswitch (fmt) {\n\tcase S_IFCHR:\n\t\trs->sc_dkdev.dk_copenmask |= pmask;\n\t\tbreak;\n\n\tcase S_IFBLK:\n\t\trs->sc_dkdev.dk_bopenmask |= pmask;\n\t\tbreak;\n\t}\n\n\tif ((rs->sc_dkdev.dk_openmask == 0) &&\n\t    ((rs->sc_flags & RAIDF_INITED) != 0)) {\n\t        /* First one... mark things as dirty... Note that we *MUST*\n\t         have done a configure before this.  I DO NOT WANT TO BE\n\t         SCRIBBLING TO RANDOM COMPONENTS UNTIL IT'S BEEN DETERMINED\n\t         THAT THEY BELONG TOGETHER!!!!! */\n\t        /* XXX should check to see if we're only open for reading\n\t           here... If so, we needn't do this, but then need some\n\t           other way of keeping track of what's happened.. */\n\n\t        rf_markalldirty( raidPtrs[unit] );\n\t}\n\n\trs->sc_dkdev.dk_openmask =\n\t    rs->sc_dkdev.dk_copenmask | rs->sc_dkdev.dk_bopenmask;\n\n\traidunlock(rs);\n\n\treturn (error);\n}",
    "includes": [
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_kintf.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_dagflags.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_copyback.h\"",
      "#include \"rf_raidframe.h\"",
      "#include \"rf_raid.h\"",
      "#include \"raid.h\"",
      "#include <sys/user.h>",
      "#include <sys/buf.h>",
      "#include <sys/lock.h>",
      "#include <sys/conf.h>",
      "#include <sys/namei.h>",
      "#include <sys/systm.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/device.h>",
      "#include <sys/disk.h>",
      "#include <sys/queue.h>",
      "#include <sys/malloc.h>",
      "#include <sys/param.h>",
      "#include <sys/errno.h>"
    ],
    "macros_used": [
      "#define RAIDF_INITED\t0x01\t/* unit has been initialized */"
    ],
    "globals_used": [
      "static RF_Raid_t **raidPtrs;",
      "int\traidopen",
      "static int numraid = 0;",
      "struct raid_softc *raid_softc;",
      "void\traidgetdisklabel",
      "int\traidlock",
      "void\traidunlock",
      "void\trf_markalldirty"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raidunlock",
          "args": [
            "rs"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "raidunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_openbsdkintf.c",
          "lines": "1918-1927",
          "snippet": "void\nraidunlock(rs)\n\tstruct raid_softc *rs;\n{\n\trs->sc_flags &= ~RAIDF_LOCKED;\n\tif ((rs->sc_flags & RAIDF_WANTED) != 0) {\n\t\trs->sc_flags &= ~RAIDF_WANTED;\n\t\twakeup(rs);\n\t}\n}",
          "includes": [
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_dagflags.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_raidframe.h\"",
            "#include \"rf_raid.h\"",
            "#include \"raid.h\"",
            "#include <sys/user.h>",
            "#include <sys/buf.h>",
            "#include <sys/lock.h>",
            "#include <sys/conf.h>",
            "#include <sys/namei.h>",
            "#include <sys/systm.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/device.h>",
            "#include <sys/disk.h>",
            "#include <sys/queue.h>",
            "#include <sys/malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/errno.h>"
          ],
          "macros_used": [
            "#define RAIDF_LOCKED\t0x80\t/* unit is locked */",
            "#define RAIDF_WANTED\t0x40\t/* someone is waiting to obtain a lock */"
          ],
          "globals_used": [
            "struct raid_softc *raid_softc;",
            "void\traidunlock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\n#define RAIDF_LOCKED\t0x80\t/* unit is locked */\n#define RAIDF_WANTED\t0x40\t/* someone is waiting to obtain a lock */\n\nstruct raid_softc *raid_softc;\nvoid\traidunlock;\n\nvoid\nraidunlock(rs)\n\tstruct raid_softc *rs;\n{\n\trs->sc_flags &= ~RAIDF_LOCKED;\n\tif ((rs->sc_flags & RAIDF_WANTED) != 0) {\n\t\trs->sc_flags &= ~RAIDF_WANTED;\n\t\twakeup(rs);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_markalldirty",
          "args": [
            "raidPtrs[unit]"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "rf_markalldirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_openbsdkintf.c",
          "lines": "2041-2134",
          "snippet": "void \nrf_markalldirty( raidPtr )\n\tRF_Raid_t *raidPtr;\n{\n\tRF_ComponentLabel_t c_label;\n\tint r,c;\n\n\traidPtr->mod_counter++;\n\tfor (r = 0; r < raidPtr->numRow; r++) {\n\t\tfor (c = 0; c < raidPtr->numCol; c++) {\n\t\t\tif (raidPtr->Disks[r][c].status != rf_ds_failed) {\n\t\t\t\traidread_component_label(\n\t\t\t\t\traidPtr->Disks[r][c].dev,\n\t\t\t\t\traidPtr->raid_cinfo[r][c].ci_vp,\n\t\t\t\t\t&c_label);\n\t\t\t\tif (c_label.status == rf_ds_spared) {\n\t\t\t\t\t/* XXX do something special... \n\t\t\t\t\t but whatever you do, don't \n\t\t\t\t\t try to access it!! */\n\t\t\t\t} else {\n#if 0\n\t\t\t\tc_label.status = \n\t\t\t\t\traidPtr->Disks[r][c].status;\n\t\t\t\traidwrite_component_label( \n\t\t\t\t\traidPtr->Disks[r][c].dev,\n\t\t\t\t\traidPtr->raid_cinfo[r][c].ci_vp,\n\t\t\t\t\t&c_label);\n#endif\n\t\t\t\traidmarkdirty( \n\t\t\t\t       raidPtr->Disks[r][c].dev, \n\t\t\t\t       raidPtr->raid_cinfo[r][c].ci_vp,\n\t\t\t\t       raidPtr->mod_counter);\n\t\t\t\t}\n\t\t\t}\n\t\t} \n\t}\n\t/* printf(\"Component labels marked dirty.\\n\"); */\n#if 0\n\tfor( c = 0; c < raidPtr->numSpare ; c++) {\n\t\tsparecol = raidPtr->numCol + c;\n\t\tif (raidPtr->Disks[r][sparecol].status == rf_ds_used_spare) {\n\t\t\t/* \n\n\t\t\t   XXX this is where we get fancy and map this spare\n\t\t\t   into it's correct spot in the array.\n\n\t\t\t */\n\t\t\t/* \n\t\t\t   \n\t\t\t   we claim this disk is \"optimal\" if it's \n\t\t\t   rf_ds_used_spare, as that means it should be \n\t\t\t   directly substitutable for the disk it replaced. \n\t\t\t   We note that too...\n\n\t\t\t */\n\n\t\t\tfor(i=0;i<raidPtr->numRow;i++) {\n\t\t\t\tfor(j=0;j<raidPtr->numCol;j++) {\n\t\t\t\t\tif ((raidPtr->Disks[i][j].spareRow == \n\t\t\t\t\t     r) &&\n\t\t\t\t\t    (raidPtr->Disks[i][j].spareCol ==\n\t\t\t\t\t     sparecol)) {\n\t\t\t\t\t\tsrow = r;\n\t\t\t\t\t\tscol = sparecol;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\traidread_component_label( \n\t\t\t\t      raidPtr->Disks[r][sparecol].dev,\n\t\t\t\t      raidPtr->raid_cinfo[r][sparecol].ci_vp,\n\t\t\t\t      &c_label);\n\t\t\t/* make sure status is noted */\n\t\t\tc_label.version = RF_COMPONENT_LABEL_VERSION; \n\t\t\tc_label.mod_counter = raidPtr->mod_counter;\n\t\t\tc_label.serial_number = raidPtr->serial_number;\n\t\t\tc_label.row = srow;\n\t\t\tc_label.column = scol;\n\t\t\tc_label.num_rows = raidPtr->numRow;\n\t\t\tc_label.num_columns = raidPtr->numCol;\n\t\t\tc_label.clean = RF_RAID_DIRTY; /* changed in a bit*/\n\t\t\tc_label.status = rf_ds_optimal;\n\t\t\traidwrite_component_label(\n\t\t\t\t      raidPtr->Disks[r][sparecol].dev,\n\t\t\t\t      raidPtr->raid_cinfo[r][sparecol].ci_vp,\n\t\t\t\t      &c_label);\n\t\t\traidmarkclean( raidPtr->Disks[r][sparecol].dev, \n\t\t\t              raidPtr->raid_cinfo[r][sparecol].ci_vp);\n\t\t}\n\t}\n\n#endif\n}",
          "includes": [
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_dagflags.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_raidframe.h\"",
            "#include \"rf_raid.h\"",
            "#include \"raid.h\"",
            "#include <sys/user.h>",
            "#include <sys/buf.h>",
            "#include <sys/lock.h>",
            "#include <sys/conf.h>",
            "#include <sys/namei.h>",
            "#include <sys/systm.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/device.h>",
            "#include <sys/disk.h>",
            "#include <sys/queue.h>",
            "#include <sys/malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\trf_markalldirty"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\nvoid\trf_markalldirty;\n\nvoid \nrf_markalldirty( raidPtr )\n\tRF_Raid_t *raidPtr;\n{\n\tRF_ComponentLabel_t c_label;\n\tint r,c;\n\n\traidPtr->mod_counter++;\n\tfor (r = 0; r < raidPtr->numRow; r++) {\n\t\tfor (c = 0; c < raidPtr->numCol; c++) {\n\t\t\tif (raidPtr->Disks[r][c].status != rf_ds_failed) {\n\t\t\t\traidread_component_label(\n\t\t\t\t\traidPtr->Disks[r][c].dev,\n\t\t\t\t\traidPtr->raid_cinfo[r][c].ci_vp,\n\t\t\t\t\t&c_label);\n\t\t\t\tif (c_label.status == rf_ds_spared) {\n\t\t\t\t\t/* XXX do something special... \n\t\t\t\t\t but whatever you do, don't \n\t\t\t\t\t try to access it!! */\n\t\t\t\t} else {\n#if 0\n\t\t\t\tc_label.status = \n\t\t\t\t\traidPtr->Disks[r][c].status;\n\t\t\t\traidwrite_component_label( \n\t\t\t\t\traidPtr->Disks[r][c].dev,\n\t\t\t\t\traidPtr->raid_cinfo[r][c].ci_vp,\n\t\t\t\t\t&c_label);\n#endif\n\t\t\t\traidmarkdirty( \n\t\t\t\t       raidPtr->Disks[r][c].dev, \n\t\t\t\t       raidPtr->raid_cinfo[r][c].ci_vp,\n\t\t\t\t       raidPtr->mod_counter);\n\t\t\t\t}\n\t\t\t}\n\t\t} \n\t}\n\t/* printf(\"Component labels marked dirty.\\n\"); */\n#if 0\n\tfor( c = 0; c < raidPtr->numSpare ; c++) {\n\t\tsparecol = raidPtr->numCol + c;\n\t\tif (raidPtr->Disks[r][sparecol].status == rf_ds_used_spare) {\n\t\t\t/* \n\n\t\t\t   XXX this is where we get fancy and map this spare\n\t\t\t   into it's correct spot in the array.\n\n\t\t\t */\n\t\t\t/* \n\t\t\t   \n\t\t\t   we claim this disk is \"optimal\" if it's \n\t\t\t   rf_ds_used_spare, as that means it should be \n\t\t\t   directly substitutable for the disk it replaced. \n\t\t\t   We note that too...\n\n\t\t\t */\n\n\t\t\tfor(i=0;i<raidPtr->numRow;i++) {\n\t\t\t\tfor(j=0;j<raidPtr->numCol;j++) {\n\t\t\t\t\tif ((raidPtr->Disks[i][j].spareRow == \n\t\t\t\t\t     r) &&\n\t\t\t\t\t    (raidPtr->Disks[i][j].spareCol ==\n\t\t\t\t\t     sparecol)) {\n\t\t\t\t\t\tsrow = r;\n\t\t\t\t\t\tscol = sparecol;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\traidread_component_label( \n\t\t\t\t      raidPtr->Disks[r][sparecol].dev,\n\t\t\t\t      raidPtr->raid_cinfo[r][sparecol].ci_vp,\n\t\t\t\t      &c_label);\n\t\t\t/* make sure status is noted */\n\t\t\tc_label.version = RF_COMPONENT_LABEL_VERSION; \n\t\t\tc_label.mod_counter = raidPtr->mod_counter;\n\t\t\tc_label.serial_number = raidPtr->serial_number;\n\t\t\tc_label.row = srow;\n\t\t\tc_label.column = scol;\n\t\t\tc_label.num_rows = raidPtr->numRow;\n\t\t\tc_label.num_columns = raidPtr->numCol;\n\t\t\tc_label.clean = RF_RAID_DIRTY; /* changed in a bit*/\n\t\t\tc_label.status = rf_ds_optimal;\n\t\t\traidwrite_component_label(\n\t\t\t\t      raidPtr->Disks[r][sparecol].dev,\n\t\t\t\t      raidPtr->raid_cinfo[r][sparecol].ci_vp,\n\t\t\t\t      &c_label);\n\t\t\traidmarkclean( raidPtr->Disks[r][sparecol].dev, \n\t\t\t              raidPtr->raid_cinfo[r][sparecol].ci_vp);\n\t\t}\n\t}\n\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "db1_printf",
          "args": [
            "(\"Bailing out...\\n\")"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db1_printf",
          "args": [
            "(\"Not a raw partition..\\n\")"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raidgetdisklabel",
          "args": [
            "dev"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "raidgetdisklabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_openbsdkintf.c",
          "lines": "1771-1822",
          "snippet": "void\nraidgetdisklabel(dev)\n\tdev_t dev;\n{\n\tint unit = raidunit(dev);\n\tstruct raid_softc *rs = &raid_softc[unit];\n\tchar *errstring;\n\tstruct disklabel *lp = rs->sc_dkdev.dk_label;\n\tstruct cpu_disklabel *clp = rs->sc_dkdev.dk_cpulabel;\n\tRF_Raid_t *raidPtr;\n\n\tdb1_printf((\"Getting the disklabel...\\n\"));\n\n\tbzero(clp, sizeof(*clp));\n\n\traidPtr = raidPtrs[unit];\n\n\traidgetdefaultlabel(raidPtr, rs, lp);\n\n\t/*\n\t * Call the generic disklabel extraction routine.\n\t */\n\terrstring = readdisklabel(RAIDLABELDEV(dev), raidstrategy,\n\t    rs->sc_dkdev.dk_label, rs->sc_dkdev.dk_cpulabel, 0);\n\tif (errstring)\n\t\traidmakedisklabel(rs);\n\telse {\n\t\tint i;\n\t\tstruct partition *pp;\n\n\t\t/*\n\t\t * Sanity check whether the found disklabel is valid.\n\t\t *\n\t\t * This is necessary since total size of the raid device\n\t\t * may vary when an interleave is changed even though exactly\n\t\t * same componets are used, and old disklabel may used\n\t\t * if that is found.\n\t\t */\n\t\tif (lp->d_secperunit != rs->sc_size)\n\t\t\tprintf(\"WARNING: %s: \"\n\t\t\t    \"total sector size in disklabel (%d) != \"\n\t\t\t    \"the size of raid (%ld)\\n\", rs->sc_xname,\n\t\t\t    lp->d_secperunit, (long) rs->sc_size);\n\t\tfor (i = 0; i < lp->d_npartitions; i++) {\n\t\t\tpp = &lp->d_partitions[i];\n\t\t\tif (pp->p_offset + pp->p_size > rs->sc_size)\n\t\t\t\tprintf(\"WARNING: %s: end of partition `%c' \"\n\t\t\t\t    \"exceeds the size of raid (%ld)\\n\",\n\t\t\t\t    rs->sc_xname, 'a' + i, (long) rs->sc_size);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_dagflags.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_raidframe.h\"",
            "#include \"rf_raid.h\"",
            "#include \"raid.h\"",
            "#include <sys/user.h>",
            "#include <sys/buf.h>",
            "#include <sys/lock.h>",
            "#include <sys/conf.h>",
            "#include <sys/namei.h>",
            "#include <sys/systm.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/device.h>",
            "#include <sys/disk.h>",
            "#include <sys/queue.h>",
            "#include <sys/malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static RF_Raid_t **raidPtrs;",
            "void\traidstrategy",
            "struct raid_softc *raid_softc;",
            "void\traidgetdefaultlabel",
            "void\traidgetdisklabel",
            "void\traidmakedisklabel"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\nstatic RF_Raid_t **raidPtrs;\nvoid\traidstrategy;\nstruct raid_softc *raid_softc;\nvoid\traidgetdefaultlabel;\nvoid\traidgetdisklabel;\nvoid\traidmakedisklabel;\n\nvoid\nraidgetdisklabel(dev)\n\tdev_t dev;\n{\n\tint unit = raidunit(dev);\n\tstruct raid_softc *rs = &raid_softc[unit];\n\tchar *errstring;\n\tstruct disklabel *lp = rs->sc_dkdev.dk_label;\n\tstruct cpu_disklabel *clp = rs->sc_dkdev.dk_cpulabel;\n\tRF_Raid_t *raidPtr;\n\n\tdb1_printf((\"Getting the disklabel...\\n\"));\n\n\tbzero(clp, sizeof(*clp));\n\n\traidPtr = raidPtrs[unit];\n\n\traidgetdefaultlabel(raidPtr, rs, lp);\n\n\t/*\n\t * Call the generic disklabel extraction routine.\n\t */\n\terrstring = readdisklabel(RAIDLABELDEV(dev), raidstrategy,\n\t    rs->sc_dkdev.dk_label, rs->sc_dkdev.dk_cpulabel, 0);\n\tif (errstring)\n\t\traidmakedisklabel(rs);\n\telse {\n\t\tint i;\n\t\tstruct partition *pp;\n\n\t\t/*\n\t\t * Sanity check whether the found disklabel is valid.\n\t\t *\n\t\t * This is necessary since total size of the raid device\n\t\t * may vary when an interleave is changed even though exactly\n\t\t * same componets are used, and old disklabel may used\n\t\t * if that is found.\n\t\t */\n\t\tif (lp->d_secperunit != rs->sc_size)\n\t\t\tprintf(\"WARNING: %s: \"\n\t\t\t    \"total sector size in disklabel (%d) != \"\n\t\t\t    \"the size of raid (%ld)\\n\", rs->sc_xname,\n\t\t\t    lp->d_secperunit, (long) rs->sc_size);\n\t\tfor (i = 0; i < lp->d_npartitions; i++) {\n\t\t\tpp = &lp->d_partitions[i];\n\t\t\tif (pp->p_offset + pp->p_size > rs->sc_size)\n\t\t\t\tprintf(\"WARNING: %s: end of partition `%c' \"\n\t\t\t\t    \"exceeds the size of raid (%ld)\\n\",\n\t\t\t\t    rs->sc_xname, 'a' + i, (long) rs->sc_size);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "db1_printf",
          "args": [
            "(\"Opening raid device number: %d partition: %d\\n\", unit, part)"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DISKPART",
          "args": [
            "dev"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raidlock",
          "args": [
            "rs"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "raidlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_openbsdkintf.c",
          "lines": "1900-1913",
          "snippet": "int\nraidlock(rs)\n\tstruct raid_softc *rs;\n{\n\tint error;\n\n\twhile ((rs->sc_flags & RAIDF_LOCKED) != 0) {\n\t\trs->sc_flags |= RAIDF_WANTED;\n\t\tif ((error = tsleep(rs, PRIBIO | PCATCH, \"raidlck\", 0)) != 0)\n\t\t\treturn (error);\n\t}\n\trs->sc_flags |= RAIDF_LOCKED;\n\treturn (0);\n}",
          "includes": [
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_dagflags.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_raidframe.h\"",
            "#include \"rf_raid.h\"",
            "#include \"raid.h\"",
            "#include <sys/user.h>",
            "#include <sys/buf.h>",
            "#include <sys/lock.h>",
            "#include <sys/conf.h>",
            "#include <sys/namei.h>",
            "#include <sys/systm.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/device.h>",
            "#include <sys/disk.h>",
            "#include <sys/queue.h>",
            "#include <sys/malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/errno.h>"
          ],
          "macros_used": [
            "#define RAIDF_LOCKED\t0x80\t/* unit is locked */",
            "#define RAIDF_WANTED\t0x40\t/* someone is waiting to obtain a lock */"
          ],
          "globals_used": [
            "struct raid_softc *raid_softc;",
            "int\traidlock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\n#define RAIDF_LOCKED\t0x80\t/* unit is locked */\n#define RAIDF_WANTED\t0x40\t/* someone is waiting to obtain a lock */\n\nstruct raid_softc *raid_softc;\nint\traidlock;\n\nint\nraidlock(rs)\n\tstruct raid_softc *rs;\n{\n\tint error;\n\n\twhile ((rs->sc_flags & RAIDF_LOCKED) != 0) {\n\t\trs->sc_flags |= RAIDF_WANTED;\n\t\tif ((error = tsleep(rs, PRIBIO | PCATCH, \"raidlck\", 0)) != 0)\n\t\t\treturn (error);\n\t}\n\trs->sc_flags |= RAIDF_LOCKED;\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raidunit",
          "args": [
            "dev"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\n#define RAIDF_INITED\t0x01\t/* unit has been initialized */\n\nstatic RF_Raid_t **raidPtrs;\nint\traidopen;\nstatic int numraid = 0;\nstruct raid_softc *raid_softc;\nvoid\traidgetdisklabel;\nint\traidlock;\nvoid\traidunlock;\nvoid\trf_markalldirty;\n\nint\nraidopen(dev, flags, fmt, p)\n\tdev_t dev;\n\tint flags, fmt;\n\tstruct proc *p;\n{\n\tint unit = raidunit(dev);\n\tstruct raid_softc *rs;\n\tstruct disklabel *lp;\n\tint part,pmask;\n\tint error = 0;\n\t\n\tif (unit >= numraid)\n\t\treturn (ENXIO);\n\trs = &raid_softc[unit];\n\n\tif ((error = raidlock(rs)) != 0)\n\t\treturn (error);\n\tlp = rs->sc_dkdev.dk_label;\n\n\tpart = DISKPART(dev);\n\tpmask = (1 << part);\n\n\tdb1_printf(\n\t    (\"Opening raid device number: %d partition: %d\\n\", unit, part));\n\n\n\tif ((rs->sc_flags & RAIDF_INITED) && (rs->sc_dkdev.dk_openmask == 0))\n\t\traidgetdisklabel(dev);\n\n\t/* make sure that this partition exists */\n\n\tif (part != RAW_PART) {\n\t\tdb1_printf((\"Not a raw partition..\\n\"));\n\t\tif (((rs->sc_flags & RAIDF_INITED) == 0) ||\n\t\t    ((part >= lp->d_npartitions) ||\n\t\t    (lp->d_partitions[part].p_fstype == FS_UNUSED))) {\n\t\t\terror = ENXIO;\n\t\t\traidunlock(rs);\n\t\t\tdb1_printf((\"Bailing out...\\n\"));\n\t\t\treturn (error);\n\t\t}\n\t}\n\n\t/* Prevent this unit from being unconfigured while open. */\n\tswitch (fmt) {\n\tcase S_IFCHR:\n\t\trs->sc_dkdev.dk_copenmask |= pmask;\n\t\tbreak;\n\n\tcase S_IFBLK:\n\t\trs->sc_dkdev.dk_bopenmask |= pmask;\n\t\tbreak;\n\t}\n\n\tif ((rs->sc_dkdev.dk_openmask == 0) &&\n\t    ((rs->sc_flags & RAIDF_INITED) != 0)) {\n\t        /* First one... mark things as dirty... Note that we *MUST*\n\t         have done a configure before this.  I DO NOT WANT TO BE\n\t         SCRIBBLING TO RANDOM COMPONENTS UNTIL IT'S BEEN DETERMINED\n\t         THAT THEY BELONG TOGETHER!!!!! */\n\t        /* XXX should check to see if we're only open for reading\n\t           here... If so, we needn't do this, but then need some\n\t           other way of keeping track of what's happened.. */\n\n\t        rf_markalldirty( raidPtrs[unit] );\n\t}\n\n\trs->sc_dkdev.dk_openmask =\n\t    rs->sc_dkdev.dk_copenmask | rs->sc_dkdev.dk_bopenmask;\n\n\traidunlock(rs);\n\n\treturn (error);\n}"
  },
  {
    "function_name": "raiddump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_openbsdkintf.c",
    "lines": "371-380",
    "snippet": "int\nraiddump(dev, blkno, va, size)\n\tdev_t dev;\n\tdaddr_t blkno;\n\tcaddr_t va;\n\tsize_t size;\n{\n\t/* Not implemented. */\n\treturn (ENXIO);\n}",
    "includes": [
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_kintf.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_dagflags.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_copyback.h\"",
      "#include \"rf_raidframe.h\"",
      "#include \"rf_raid.h\"",
      "#include \"raid.h\"",
      "#include <sys/user.h>",
      "#include <sys/buf.h>",
      "#include <sys/lock.h>",
      "#include <sys/conf.h>",
      "#include <sys/namei.h>",
      "#include <sys/systm.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/device.h>",
      "#include <sys/disk.h>",
      "#include <sys/queue.h>",
      "#include <sys/malloc.h>",
      "#include <sys/param.h>",
      "#include <sys/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\traiddump"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\nint\traiddump;\n\nint\nraiddump(dev, blkno, va, size)\n\tdev_t dev;\n\tdaddr_t blkno;\n\tcaddr_t va;\n\tsize_t size;\n{\n\t/* Not implemented. */\n\treturn (ENXIO);\n}"
  },
  {
    "function_name": "raidsize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_openbsdkintf.c",
    "lines": "335-369",
    "snippet": "int\nraidsize(dev)\n\tdev_t dev;\n{\n\tstruct raid_softc *rs;\n\tstruct disklabel *lp;\n\tint part, unit, omask, size;\n\n\tunit = raidunit(dev);\n\tif (unit >= numraid)\n\t\treturn (-1);\n\trs = &raid_softc[unit];\n\n\tif ((rs->sc_flags & RAIDF_INITED) == 0)\n\t\treturn (-1);\n\n\tpart = DISKPART(dev);\n\tomask = rs->sc_dkdev.dk_openmask & (1 << part);\n\tlp = rs->sc_dkdev.dk_label;\n\n\tif (omask == 0 && raidopen(dev, 0, S_IFBLK, curproc))\n\t\treturn (-1);\n\n\tif (lp->d_partitions[part].p_fstype != FS_SWAP)\n\t\tsize = -1;\n\telse\n\t\tsize = lp->d_partitions[part].p_size *\n\t\t    (lp->d_secsize / DEV_BSIZE);\n\n\tif (omask == 0 && raidclose(dev, 0, S_IFBLK, curproc))\n\t\treturn (-1);\n\n\treturn (size);\n\n}",
    "includes": [
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_kintf.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_dagflags.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_copyback.h\"",
      "#include \"rf_raidframe.h\"",
      "#include \"rf_raid.h\"",
      "#include \"raid.h\"",
      "#include <sys/user.h>",
      "#include <sys/buf.h>",
      "#include <sys/lock.h>",
      "#include <sys/conf.h>",
      "#include <sys/namei.h>",
      "#include <sys/systm.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/device.h>",
      "#include <sys/disk.h>",
      "#include <sys/queue.h>",
      "#include <sys/malloc.h>",
      "#include <sys/param.h>",
      "#include <sys/errno.h>"
    ],
    "macros_used": [
      "#define RAIDF_INITED\t0x01\t/* unit has been initialized */"
    ],
    "globals_used": [
      "int\traidsize",
      "int\traidopen",
      "int\traidclose",
      "static int numraid = 0;",
      "struct raid_softc *raid_softc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raidclose",
          "args": [
            "dev",
            "0",
            "S_IFBLK",
            "curproc"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "raidclose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_openbsdkintf.c",
          "lines": "460-504",
          "snippet": "int\nraidclose(dev, flags, fmt, p)\n\tdev_t dev;\n\tint flags, fmt;\n\tstruct proc *p;\n{\n\tint unit = raidunit(dev);\n\tstruct raid_softc *rs;\n\tint error = 0;\n\tint part;\n\n\tif (unit >= numraid)\n\t\treturn (ENXIO);\n\trs = &raid_softc[unit];\n\n\tif ((error = raidlock(rs)) != 0)\n\t\treturn (error);\n\n\tpart = DISKPART(dev);\n\n\t/* ...that much closer to allowing unconfiguration... */\n\tswitch (fmt) {\n\tcase S_IFCHR:\n\t\trs->sc_dkdev.dk_copenmask &= ~(1 << part);\n\t\tbreak;\n\n\tcase S_IFBLK:\n\t\trs->sc_dkdev.dk_bopenmask &= ~(1 << part);\n\t\tbreak;\n\t}\n\trs->sc_dkdev.dk_openmask =\n\t    rs->sc_dkdev.dk_copenmask | rs->sc_dkdev.dk_bopenmask;\n\n\tif ((rs->sc_dkdev.dk_openmask == 0) &&\n\t    ((rs->sc_flags & RAIDF_INITED) != 0)) {\n\t        /* Last one... device is not unconfigured yet.\n\t           Device shutdown has taken care of setting the\n\t           clean bits if RAIDF_INITED is not set\n\t           mark things as clean... */\n\t        rf_update_component_labels( raidPtrs[unit] );\n\t}\n\n\traidunlock(rs);\n\treturn (0);\n}",
          "includes": [
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_dagflags.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_raidframe.h\"",
            "#include \"rf_raid.h\"",
            "#include \"raid.h\"",
            "#include <sys/user.h>",
            "#include <sys/buf.h>",
            "#include <sys/lock.h>",
            "#include <sys/conf.h>",
            "#include <sys/namei.h>",
            "#include <sys/systm.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/device.h>",
            "#include <sys/disk.h>",
            "#include <sys/queue.h>",
            "#include <sys/malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/errno.h>"
          ],
          "macros_used": [
            "#define RAIDF_INITED\t0x01\t/* unit has been initialized */"
          ],
          "globals_used": [
            "static RF_Raid_t **raidPtrs;",
            "int\traidclose",
            "static int numraid = 0;",
            "struct raid_softc *raid_softc;",
            "int\traidlock",
            "void\traidunlock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\n#define RAIDF_INITED\t0x01\t/* unit has been initialized */\n\nstatic RF_Raid_t **raidPtrs;\nint\traidclose;\nstatic int numraid = 0;\nstruct raid_softc *raid_softc;\nint\traidlock;\nvoid\traidunlock;\n\nint\nraidclose(dev, flags, fmt, p)\n\tdev_t dev;\n\tint flags, fmt;\n\tstruct proc *p;\n{\n\tint unit = raidunit(dev);\n\tstruct raid_softc *rs;\n\tint error = 0;\n\tint part;\n\n\tif (unit >= numraid)\n\t\treturn (ENXIO);\n\trs = &raid_softc[unit];\n\n\tif ((error = raidlock(rs)) != 0)\n\t\treturn (error);\n\n\tpart = DISKPART(dev);\n\n\t/* ...that much closer to allowing unconfiguration... */\n\tswitch (fmt) {\n\tcase S_IFCHR:\n\t\trs->sc_dkdev.dk_copenmask &= ~(1 << part);\n\t\tbreak;\n\n\tcase S_IFBLK:\n\t\trs->sc_dkdev.dk_bopenmask &= ~(1 << part);\n\t\tbreak;\n\t}\n\trs->sc_dkdev.dk_openmask =\n\t    rs->sc_dkdev.dk_copenmask | rs->sc_dkdev.dk_bopenmask;\n\n\tif ((rs->sc_dkdev.dk_openmask == 0) &&\n\t    ((rs->sc_flags & RAIDF_INITED) != 0)) {\n\t        /* Last one... device is not unconfigured yet.\n\t           Device shutdown has taken care of setting the\n\t           clean bits if RAIDF_INITED is not set\n\t           mark things as clean... */\n\t        rf_update_component_labels( raidPtrs[unit] );\n\t}\n\n\traidunlock(rs);\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raidopen",
          "args": [
            "dev",
            "0",
            "S_IFBLK",
            "curproc"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "raidopen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_openbsdkintf.c",
          "lines": "383-457",
          "snippet": "int\nraidopen(dev, flags, fmt, p)\n\tdev_t dev;\n\tint flags, fmt;\n\tstruct proc *p;\n{\n\tint unit = raidunit(dev);\n\tstruct raid_softc *rs;\n\tstruct disklabel *lp;\n\tint part,pmask;\n\tint error = 0;\n\t\n\tif (unit >= numraid)\n\t\treturn (ENXIO);\n\trs = &raid_softc[unit];\n\n\tif ((error = raidlock(rs)) != 0)\n\t\treturn (error);\n\tlp = rs->sc_dkdev.dk_label;\n\n\tpart = DISKPART(dev);\n\tpmask = (1 << part);\n\n\tdb1_printf(\n\t    (\"Opening raid device number: %d partition: %d\\n\", unit, part));\n\n\n\tif ((rs->sc_flags & RAIDF_INITED) && (rs->sc_dkdev.dk_openmask == 0))\n\t\traidgetdisklabel(dev);\n\n\t/* make sure that this partition exists */\n\n\tif (part != RAW_PART) {\n\t\tdb1_printf((\"Not a raw partition..\\n\"));\n\t\tif (((rs->sc_flags & RAIDF_INITED) == 0) ||\n\t\t    ((part >= lp->d_npartitions) ||\n\t\t    (lp->d_partitions[part].p_fstype == FS_UNUSED))) {\n\t\t\terror = ENXIO;\n\t\t\traidunlock(rs);\n\t\t\tdb1_printf((\"Bailing out...\\n\"));\n\t\t\treturn (error);\n\t\t}\n\t}\n\n\t/* Prevent this unit from being unconfigured while open. */\n\tswitch (fmt) {\n\tcase S_IFCHR:\n\t\trs->sc_dkdev.dk_copenmask |= pmask;\n\t\tbreak;\n\n\tcase S_IFBLK:\n\t\trs->sc_dkdev.dk_bopenmask |= pmask;\n\t\tbreak;\n\t}\n\n\tif ((rs->sc_dkdev.dk_openmask == 0) &&\n\t    ((rs->sc_flags & RAIDF_INITED) != 0)) {\n\t        /* First one... mark things as dirty... Note that we *MUST*\n\t         have done a configure before this.  I DO NOT WANT TO BE\n\t         SCRIBBLING TO RANDOM COMPONENTS UNTIL IT'S BEEN DETERMINED\n\t         THAT THEY BELONG TOGETHER!!!!! */\n\t        /* XXX should check to see if we're only open for reading\n\t           here... If so, we needn't do this, but then need some\n\t           other way of keeping track of what's happened.. */\n\n\t        rf_markalldirty( raidPtrs[unit] );\n\t}\n\n\trs->sc_dkdev.dk_openmask =\n\t    rs->sc_dkdev.dk_copenmask | rs->sc_dkdev.dk_bopenmask;\n\n\traidunlock(rs);\n\n\treturn (error);\n}",
          "includes": [
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_dagflags.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_raidframe.h\"",
            "#include \"rf_raid.h\"",
            "#include \"raid.h\"",
            "#include <sys/user.h>",
            "#include <sys/buf.h>",
            "#include <sys/lock.h>",
            "#include <sys/conf.h>",
            "#include <sys/namei.h>",
            "#include <sys/systm.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/device.h>",
            "#include <sys/disk.h>",
            "#include <sys/queue.h>",
            "#include <sys/malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/errno.h>"
          ],
          "macros_used": [
            "#define RAIDF_INITED\t0x01\t/* unit has been initialized */"
          ],
          "globals_used": [
            "static RF_Raid_t **raidPtrs;",
            "int\traidopen",
            "static int numraid = 0;",
            "struct raid_softc *raid_softc;",
            "void\traidgetdisklabel",
            "int\traidlock",
            "void\traidunlock",
            "void\trf_markalldirty"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\n#define RAIDF_INITED\t0x01\t/* unit has been initialized */\n\nstatic RF_Raid_t **raidPtrs;\nint\traidopen;\nstatic int numraid = 0;\nstruct raid_softc *raid_softc;\nvoid\traidgetdisklabel;\nint\traidlock;\nvoid\traidunlock;\nvoid\trf_markalldirty;\n\nint\nraidopen(dev, flags, fmt, p)\n\tdev_t dev;\n\tint flags, fmt;\n\tstruct proc *p;\n{\n\tint unit = raidunit(dev);\n\tstruct raid_softc *rs;\n\tstruct disklabel *lp;\n\tint part,pmask;\n\tint error = 0;\n\t\n\tif (unit >= numraid)\n\t\treturn (ENXIO);\n\trs = &raid_softc[unit];\n\n\tif ((error = raidlock(rs)) != 0)\n\t\treturn (error);\n\tlp = rs->sc_dkdev.dk_label;\n\n\tpart = DISKPART(dev);\n\tpmask = (1 << part);\n\n\tdb1_printf(\n\t    (\"Opening raid device number: %d partition: %d\\n\", unit, part));\n\n\n\tif ((rs->sc_flags & RAIDF_INITED) && (rs->sc_dkdev.dk_openmask == 0))\n\t\traidgetdisklabel(dev);\n\n\t/* make sure that this partition exists */\n\n\tif (part != RAW_PART) {\n\t\tdb1_printf((\"Not a raw partition..\\n\"));\n\t\tif (((rs->sc_flags & RAIDF_INITED) == 0) ||\n\t\t    ((part >= lp->d_npartitions) ||\n\t\t    (lp->d_partitions[part].p_fstype == FS_UNUSED))) {\n\t\t\terror = ENXIO;\n\t\t\traidunlock(rs);\n\t\t\tdb1_printf((\"Bailing out...\\n\"));\n\t\t\treturn (error);\n\t\t}\n\t}\n\n\t/* Prevent this unit from being unconfigured while open. */\n\tswitch (fmt) {\n\tcase S_IFCHR:\n\t\trs->sc_dkdev.dk_copenmask |= pmask;\n\t\tbreak;\n\n\tcase S_IFBLK:\n\t\trs->sc_dkdev.dk_bopenmask |= pmask;\n\t\tbreak;\n\t}\n\n\tif ((rs->sc_dkdev.dk_openmask == 0) &&\n\t    ((rs->sc_flags & RAIDF_INITED) != 0)) {\n\t        /* First one... mark things as dirty... Note that we *MUST*\n\t         have done a configure before this.  I DO NOT WANT TO BE\n\t         SCRIBBLING TO RANDOM COMPONENTS UNTIL IT'S BEEN DETERMINED\n\t         THAT THEY BELONG TOGETHER!!!!! */\n\t        /* XXX should check to see if we're only open for reading\n\t           here... If so, we needn't do this, but then need some\n\t           other way of keeping track of what's happened.. */\n\n\t        rf_markalldirty( raidPtrs[unit] );\n\t}\n\n\trs->sc_dkdev.dk_openmask =\n\t    rs->sc_dkdev.dk_copenmask | rs->sc_dkdev.dk_bopenmask;\n\n\traidunlock(rs);\n\n\treturn (error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DISKPART",
          "args": [
            "dev"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raidunit",
          "args": [
            "dev"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\n#define RAIDF_INITED\t0x01\t/* unit has been initialized */\n\nint\traidsize;\nint\traidopen;\nint\traidclose;\nstatic int numraid = 0;\nstruct raid_softc *raid_softc;\n\nint\nraidsize(dev)\n\tdev_t dev;\n{\n\tstruct raid_softc *rs;\n\tstruct disklabel *lp;\n\tint part, unit, omask, size;\n\n\tunit = raidunit(dev);\n\tif (unit >= numraid)\n\t\treturn (-1);\n\trs = &raid_softc[unit];\n\n\tif ((rs->sc_flags & RAIDF_INITED) == 0)\n\t\treturn (-1);\n\n\tpart = DISKPART(dev);\n\tomask = rs->sc_dkdev.dk_openmask & (1 << part);\n\tlp = rs->sc_dkdev.dk_label;\n\n\tif (omask == 0 && raidopen(dev, 0, S_IFBLK, curproc))\n\t\treturn (-1);\n\n\tif (lp->d_partitions[part].p_fstype != FS_SWAP)\n\t\tsize = -1;\n\telse\n\t\tsize = lp->d_partitions[part].p_size *\n\t\t    (lp->d_secsize / DEV_BSIZE);\n\n\tif (omask == 0 && raidclose(dev, 0, S_IFBLK, curproc))\n\t\treturn (-1);\n\n\treturn (size);\n\n}"
  },
  {
    "function_name": "raidattach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_openbsdkintf.c",
    "lines": "268-333",
    "snippet": "void\nraidattach(num)\n\tint num;\n{\n\tint raidID;\n\tint i, rc;\n\n\tdb1_printf((\"raidattach: Asked for %d units\\n\", num));\n\n\tif (num <= 0) {\n#ifdef DIAGNOSTIC\n\t\tpanic(\"raidattach: count <= 0\");\n#endif\n\t\treturn;\n\t}\n\n\t/* This is where all the initialization stuff gets done. */\n\n\t/* Make some space for requested number of units... */\n\tRF_Calloc(raidPtrs, num, sizeof(RF_Raid_t *), (RF_Raid_t **));\n\tif (raidPtrs == NULL) {\n\t\tpanic(\"raidPtrs is NULL!!\\n\");\n\t}\n\n\trc = rf_mutex_init(&rf_sparet_wait_mutex);\n\tif (rc) {\n\t        RF_PANIC();\n        }\n\n\trf_sparet_wait_queue = rf_sparet_resp_queue = NULL;\n\n\tfor (i = 0; i < numraid; i++)\n\t        raidPtrs[i] = NULL;\n\trc = rf_BootRaidframe();\n\tif (rc == 0)\n\t        printf(\"Kernelized RAIDframe activated\\n\");\n\telse\n\t        panic(\"Serious error booting RAID!!\\n\");\n\t\n\t/*\n\t * Put together some datastructures like the CCD device does..\n\t * This lets us lock the device and what-not when it gets opened.\n\t */\n\t\n\traid_softc = (struct raid_softc *)\n\t    malloc(num * sizeof (struct raid_softc), M_RAIDFRAME, M_NOWAIT);\n\tif (raid_softc == NULL) {\n\t\tprintf(\"WARNING: no memory for RAIDframe driver\\n\");\n\t\treturn;\n\t}\n\tnumraid = num;\n\tbzero(raid_softc, num * sizeof (struct raid_softc));\n\n\tfor (raidID = 0; raidID < num; raidID++) {\n\t\traid_softc[raidID].buf_queue.b_actf = NULL;\n\t\traid_softc[raidID].buf_queue.b_actb = \n\t\t\t&raid_softc[raidID].buf_queue.b_actf;\n\t\tRF_Calloc(raidPtrs[raidID], 1, sizeof (RF_Raid_t),\n\t\t    (RF_Raid_t *));\n\t\tif (raidPtrs[raidID] == NULL) {\n\t\t\tprintf(\"WARNING: raidPtrs[%d] is NULL\\n\", raidID);\n\t\t\tnumraid = raidID;\n\t\t\treturn;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_kintf.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_dagflags.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_copyback.h\"",
      "#include \"rf_raidframe.h\"",
      "#include \"rf_raid.h\"",
      "#include \"raid.h\"",
      "#include <sys/user.h>",
      "#include <sys/buf.h>",
      "#include <sys/lock.h>",
      "#include <sys/conf.h>",
      "#include <sys/namei.h>",
      "#include <sys/systm.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/device.h>",
      "#include <sys/disk.h>",
      "#include <sys/queue.h>",
      "#include <sys/malloc.h>",
      "#include <sys/param.h>",
      "#include <sys/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static RF_Raid_t **raidPtrs;",
      "static RF_SparetWait_t *rf_sparet_resp_queue;",
      "void\traidattach",
      "static int numraid = 0;",
      "struct raid_softc *raid_softc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"WARNING: raidPtrs[%d] is NULL\\n\"",
            "raidID"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_Calloc",
          "args": [
            "raidPtrs[raidID]",
            "1",
            "sizeof (RF_Raid_t)",
            "(RF_Raid_t *)"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "raid_softc",
            "num * sizeof (struct raid_softc)"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "num * sizeof (struct raid_softc)",
            "M_RAIDFRAME",
            "M_NOWAIT"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"Serious error booting RAID!!\\n\""
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_BootRaidframe",
          "args": [],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "rf_BootRaidframe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_driver.c",
          "lines": "168-187",
          "snippet": "int\nrf_BootRaidframe()\n{\n\tint     rc;\n\n\tif (raidframe_booted)\n\t\treturn (EBUSY);\n\traidframe_booted = 1;\n\n\trc = rf_mutex_init(&configureMutex);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to init mutex file %s line %d rc=%d\\n\", __FILE__,\n\t\t    __LINE__, rc);\n\t\tRF_PANIC();\n\t}\n\tconfigureCount = 0;\n\tisconfigged = 0;\n\tglobalShutdown = NULL;\n\treturn (0);\n}",
          "includes": [
            "#include <sys/buf.h>",
            "#include \"rf_kintf.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_nwayxor.h\"",
            "#include \"rf_mcpair.h\"",
            "#include \"rf_memchunk.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_callback.h\"",
            "#include \"rf_revent.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_decluster.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_states.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_aselect.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include <sys/errno.h>",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_archs.h\"",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int raidframe_booted = 0;",
            "static int configureCount = 0;",
            "static int isconfigged = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_options.h\"\n#include \"rf_driver.h\"\n#include \"rf_copyback.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_nwayxor.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_memchunk.h\"\n#include \"rf_engine.h\"\n#include \"rf_callback.h\"\n#include \"rf_revent.h\"\n#include \"rf_map.h\"\n#include \"rf_decluster.h\"\n#include \"rf_freelist.h\"\n#include \"rf_states.h\"\n#include \"rf_desc.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_utils.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_aselect.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n#include \"rf_archs.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic int raidframe_booted = 0;\nstatic int configureCount = 0;\nstatic int isconfigged = 0;\n\nint\nrf_BootRaidframe()\n{\n\tint     rc;\n\n\tif (raidframe_booted)\n\t\treturn (EBUSY);\n\traidframe_booted = 1;\n\n\trc = rf_mutex_init(&configureMutex);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to init mutex file %s line %d rc=%d\\n\", __FILE__,\n\t\t    __LINE__, rc);\n\t\tRF_PANIC();\n\t}\n\tconfigureCount = 0;\n\tisconfigged = 0;\n\tglobalShutdown = NULL;\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_PANIC",
          "args": [],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_mutex_init",
          "args": [
            "&rf_sparet_wait_mutex"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "rf_mutex_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_threadstuff.c",
          "lines": "173-186",
          "snippet": "int \nrf_mutex_init(m)\ndecl_simple_lock_data(, *m)\n{\n\tsimple_lock_init(m);\n\treturn (0);\n}\n\nint \nrf_mutex_destroy(m)\ndecl_simple_lock_data(, *m)\n{\n\treturn (0);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_general.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nint \nrf_mutex_init(m)\ndecl_simple_lock_data(, *m)\n{\n\tsimple_lock_init(m);\n\treturn (0);\n}\n\nint \nrf_mutex_destroy(m)\ndecl_simple_lock_data(, *m)\n{\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"raidPtrs is NULL!!\\n\""
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Calloc",
          "args": [
            "raidPtrs",
            "num",
            "sizeof(RF_Raid_t *)",
            "(RF_Raid_t **)"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"raidattach: count <= 0\""
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db1_printf",
          "args": [
            "(\"raidattach: Asked for %d units\\n\", num)"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\nstatic RF_Raid_t **raidPtrs;\nstatic RF_SparetWait_t *rf_sparet_resp_queue;\nvoid\traidattach;\nstatic int numraid = 0;\nstruct raid_softc *raid_softc;\n\nvoid\nraidattach(num)\n\tint num;\n{\n\tint raidID;\n\tint i, rc;\n\n\tdb1_printf((\"raidattach: Asked for %d units\\n\", num));\n\n\tif (num <= 0) {\n#ifdef DIAGNOSTIC\n\t\tpanic(\"raidattach: count <= 0\");\n#endif\n\t\treturn;\n\t}\n\n\t/* This is where all the initialization stuff gets done. */\n\n\t/* Make some space for requested number of units... */\n\tRF_Calloc(raidPtrs, num, sizeof(RF_Raid_t *), (RF_Raid_t **));\n\tif (raidPtrs == NULL) {\n\t\tpanic(\"raidPtrs is NULL!!\\n\");\n\t}\n\n\trc = rf_mutex_init(&rf_sparet_wait_mutex);\n\tif (rc) {\n\t        RF_PANIC();\n        }\n\n\trf_sparet_wait_queue = rf_sparet_resp_queue = NULL;\n\n\tfor (i = 0; i < numraid; i++)\n\t        raidPtrs[i] = NULL;\n\trc = rf_BootRaidframe();\n\tif (rc == 0)\n\t        printf(\"Kernelized RAIDframe activated\\n\");\n\telse\n\t        panic(\"Serious error booting RAID!!\\n\");\n\t\n\t/*\n\t * Put together some datastructures like the CCD device does..\n\t * This lets us lock the device and what-not when it gets opened.\n\t */\n\t\n\traid_softc = (struct raid_softc *)\n\t    malloc(num * sizeof (struct raid_softc), M_RAIDFRAME, M_NOWAIT);\n\tif (raid_softc == NULL) {\n\t\tprintf(\"WARNING: no memory for RAIDframe driver\\n\");\n\t\treturn;\n\t}\n\tnumraid = num;\n\tbzero(raid_softc, num * sizeof (struct raid_softc));\n\n\tfor (raidID = 0; raidID < num; raidID++) {\n\t\traid_softc[raidID].buf_queue.b_actf = NULL;\n\t\traid_softc[raidID].buf_queue.b_actb = \n\t\t\t&raid_softc[raidID].buf_queue.b_actf;\n\t\tRF_Calloc(raidPtrs[raidID], 1, sizeof (RF_Raid_t),\n\t\t    (RF_Raid_t *));\n\t\tif (raidPtrs[raidID] == NULL) {\n\t\t\tprintf(\"WARNING: raidPtrs[%d] is NULL\\n\", raidID);\n\t\t\tnumraid = raidID;\n\t\t\treturn;\n\t\t}\n\t}\n}"
  }
]