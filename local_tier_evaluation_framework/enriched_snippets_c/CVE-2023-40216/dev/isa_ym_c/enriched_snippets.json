[
  {
    "function_name": "ym_mpu401_getinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ym.c",
    "lines": "627-634",
    "snippet": "void\nym_mpu401_getinfo(addr, mi)\n\tvoid   *addr;\n\tstruct midi_info *mi;\n{\n\tmi->name = \"YM MPU-401 UART\";\n\tmi->props = 0;\n}",
    "includes": [
      "#include <dev/isa/ymvar.h>",
      "#include <dev/ic/mpuvar.h>",
      "#include <dev/ic/opl3sa3reg.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/midi_if.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"midi.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <dev/isa/ymvar.h>\n#include <dev/ic/mpuvar.h>\n#include <dev/ic/opl3sa3reg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"midi.h\"\n\nvoid\nym_mpu401_getinfo(addr, mi)\n\tvoid   *addr;\n\tstruct midi_info *mi;\n{\n\tmi->name = \"YM MPU-401 UART\";\n\tmi->props = 0;\n}"
  },
  {
    "function_name": "ym_mpu401_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ym.c",
    "lines": "620-625",
    "snippet": "void\nym_mpu401_close(addr)\n\tvoid   *addr;\n{\n\tmpu_close(YMMPU(addr));\n}",
    "includes": [
      "#include <dev/isa/ymvar.h>",
      "#include <dev/ic/mpuvar.h>",
      "#include <dev/ic/opl3sa3reg.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/midi_if.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"midi.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mpu_close",
          "args": [
            "YMMPU(addr)"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "mpu_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mpu401.c",
          "lines": "183-194",
          "snippet": "void\nmpu_close(v)\n\tvoid *v;\n{\n\tstruct mpu_softc *sc = v;\n\n        DPRINTF((\"mpu_close: sc=%p\\n\", sc));\n\n\tsc->open = 0;\n\tsc->intr = 0;\n\tmpu_reset(sc); /* exit UART mode */\n}",
          "includes": [
            "#include <dev/ic/mpuvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/midi_if.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tmpu_reset(struct mpu_softc *);",
            "static\t__inline int mpu_waitready(struct mpu_softc *);",
            "void\tmpu_readinput(struct mpu_softc *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/mpuvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/midi_if.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tmpu_reset(struct mpu_softc *);\nstatic\t__inline int mpu_waitready(struct mpu_softc *);\nvoid\tmpu_readinput(struct mpu_softc *);\n\nvoid\nmpu_close(v)\n\tvoid *v;\n{\n\tstruct mpu_softc *sc = v;\n\n        DPRINTF((\"mpu_close: sc=%p\\n\", sc));\n\n\tsc->open = 0;\n\tsc->intr = 0;\n\tmpu_reset(sc); /* exit UART mode */\n}"
        }
      },
      {
        "call_info": {
          "callee": "YMMPU",
          "args": [
            "addr"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/ymvar.h>\n#include <dev/ic/mpuvar.h>\n#include <dev/ic/opl3sa3reg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"midi.h\"\n\nvoid\nym_mpu401_close(addr)\n\tvoid   *addr;\n{\n\tmpu_close(YMMPU(addr));\n}"
  },
  {
    "function_name": "ym_mpu401_output",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ym.c",
    "lines": "612-618",
    "snippet": "int\nym_mpu401_output(addr, d)\n\tvoid   *addr;\n\tint     d;\n{\n\treturn mpu_output(YMMPU(addr), d);\n}",
    "includes": [
      "#include <dev/isa/ymvar.h>",
      "#include <dev/ic/mpuvar.h>",
      "#include <dev/ic/opl3sa3reg.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/midi_if.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"midi.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mpu_output",
          "args": [
            "YMMPU(addr)",
            "d"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "mpu_output",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mpu401.c",
          "lines": "212-232",
          "snippet": "int\nmpu_output(v, d)\n\tvoid *v;\n\tint d;\n{\n\tstruct mpu_softc *sc = v;\n\tint s;\n\n\tDPRINTFN(3, (\"mpu_output: sc=%p 0x%02x\\n\", sc, d));\n\tif (!(MPU_GETSTATUS(sc->iot, sc->ioh) & MPU_INPUT_EMPTY)) {\n\t\ts = splaudio();\n\t\tmpu_readinput(sc);\n\t\tsplx(s);\n\t}\n\tif (mpu_waitready(sc)) {\n\t\tDPRINTF((\"mpu_output: not ready\\n\"));\n\t\treturn EIO;\n\t}\n\tbus_space_write_1(sc->iot, sc->ioh, MPU_DATA, d);\n\treturn 0;\n}",
          "includes": [
            "#include <dev/ic/mpuvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/midi_if.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define  MPU_INPUT_EMPTY\t0x80",
            "#define MPU_DATA\t\t0"
          ],
          "globals_used": [
            "int\tmpu_reset(struct mpu_softc *);",
            "static\t__inline int mpu_waitready(struct mpu_softc *);",
            "void\tmpu_readinput(struct mpu_softc *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/mpuvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/midi_if.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define  MPU_INPUT_EMPTY\t0x80\n#define MPU_DATA\t\t0\n\nint\tmpu_reset(struct mpu_softc *);\nstatic\t__inline int mpu_waitready(struct mpu_softc *);\nvoid\tmpu_readinput(struct mpu_softc *);\n\nint\nmpu_output(v, d)\n\tvoid *v;\n\tint d;\n{\n\tstruct mpu_softc *sc = v;\n\tint s;\n\n\tDPRINTFN(3, (\"mpu_output: sc=%p 0x%02x\\n\", sc, d));\n\tif (!(MPU_GETSTATUS(sc->iot, sc->ioh) & MPU_INPUT_EMPTY)) {\n\t\ts = splaudio();\n\t\tmpu_readinput(sc);\n\t\tsplx(s);\n\t}\n\tif (mpu_waitready(sc)) {\n\t\tDPRINTF((\"mpu_output: not ready\\n\"));\n\t\treturn EIO;\n\t}\n\tbus_space_write_1(sc->iot, sc->ioh, MPU_DATA, d);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "YMMPU",
          "args": [
            "addr"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/ymvar.h>\n#include <dev/ic/mpuvar.h>\n#include <dev/ic/opl3sa3reg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"midi.h\"\n\nint\nym_mpu401_output(addr, d)\n\tvoid   *addr;\n\tint     d;\n{\n\treturn mpu_output(YMMPU(addr), d);\n}"
  },
  {
    "function_name": "ym_mpu401_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ym.c",
    "lines": "601-610",
    "snippet": "int\nym_mpu401_open(addr, flags, iintr, ointr, arg)\n\tvoid   *addr;\n\tint     flags;\n\tvoid    (*iintr) __P((void *, int));\n\tvoid    (*ointr) __P((void *));\n\tvoid   *arg;\n{\n\treturn mpu_open(YMMPU(addr), flags, iintr, ointr, arg);\n}",
    "includes": [
      "#include <dev/isa/ymvar.h>",
      "#include <dev/ic/mpuvar.h>",
      "#include <dev/ic/opl3sa3reg.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/midi_if.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"midi.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mpu_open",
          "args": [
            "YMMPU(addr)",
            "flags",
            "iintr",
            "ointr",
            "arg"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "mpu_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mpu401.c",
          "lines": "159-181",
          "snippet": "int\nmpu_open(v, flags, iintr, ointr, arg)\n\tvoid *v;\n\tint flags;\n\tvoid (*iintr)__P((void *, int));\n\tvoid (*ointr)__P((void *));\n\tvoid *arg;\n{\n\tstruct mpu_softc *sc = v;\n\n        DPRINTF((\"mpu_open: sc=%p\\n\", sc));\n\n\tif (sc->open)\n\t\treturn EBUSY;\n\tif (mpu_reset(sc) != 0)\n\t\treturn EIO;\n\n\tbus_space_write_1(sc->iot, sc->ioh, MPU_COMMAND, MPU_UART_MODE);\n\tsc->open = 1;\n\tsc->intr = iintr;\n\tsc->arg = arg;\n\treturn 0;\n}",
          "includes": [
            "#include <dev/ic/mpuvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/midi_if.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define  MPU_UART_MODE\t0x3f",
            "#define MPU_COMMAND\t1"
          ],
          "globals_used": [
            "int\tmpu_reset(struct mpu_softc *);",
            "static\t__inline int mpu_waitready(struct mpu_softc *);",
            "void\tmpu_readinput(struct mpu_softc *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/mpuvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/midi_if.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define  MPU_UART_MODE\t0x3f\n#define MPU_COMMAND\t1\n\nint\tmpu_reset(struct mpu_softc *);\nstatic\t__inline int mpu_waitready(struct mpu_softc *);\nvoid\tmpu_readinput(struct mpu_softc *);\n\nint\nmpu_open(v, flags, iintr, ointr, arg)\n\tvoid *v;\n\tint flags;\n\tvoid (*iintr)__P((void *, int));\n\tvoid (*ointr)__P((void *));\n\tvoid *arg;\n{\n\tstruct mpu_softc *sc = v;\n\n        DPRINTF((\"mpu_open: sc=%p\\n\", sc));\n\n\tif (sc->open)\n\t\treturn EBUSY;\n\tif (mpu_reset(sc) != 0)\n\t\treturn EIO;\n\n\tbus_space_write_1(sc->iot, sc->ioh, MPU_COMMAND, MPU_UART_MODE);\n\tsc->open = 1;\n\tsc->intr = iintr;\n\tsc->arg = arg;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "YMMPU",
          "args": [
            "addr"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/ymvar.h>\n#include <dev/ic/mpuvar.h>\n#include <dev/ic/opl3sa3reg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"midi.h\"\n\nint\nym_mpu401_open(addr, flags, iintr, ointr, arg)\n\tvoid   *addr;\n\tint     flags;\n\tvoid    (*iintr) __P((void *, int));\n\tvoid    (*ointr) __P((void *));\n\tvoid   *arg;\n{\n\treturn mpu_open(YMMPU(addr), flags, iintr, ointr, arg);\n}"
  },
  {
    "function_name": "ym_query_devinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ym.c",
    "lines": "437-596",
    "snippet": "int\nym_query_devinfo(addr, dip)\n\tvoid   *addr;\n\tmixer_devinfo_t *dip;\n{\n\tstatic char *mixer_port_names[] = { AudioNmidi, AudioNcd, AudioNdac,\n\t\tAudioNline, AudioNspeaker, AudioNmicrophone, AudioNmonitor\n\t};\n\n\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\n\tswitch (dip->index) {\n\tcase YM_INPUT_CLASS:\t/* input class descriptor */\n\tcase YM_OUTPUT_CLASS:\n\tcase YM_MONITOR_CLASS:\n\tcase YM_RECORD_CLASS:\n\tcase YM_EQ_CLASS:\n\t\tdip->type = AUDIO_MIXER_CLASS;\n\t\tdip->mixer_class = dip->index;\n\t\tstrcpy(dip->label.name,\n\t\t    mixer_classes[dip->index - YM_INPUT_CLASS]);\n\t\tbreak;\n\n\tcase YM_MIDI_LVL:\n\tcase YM_CD_LVL:\n\tcase YM_DAC_LVL:\n\tcase YM_LINE_LVL:\n\tcase YM_SPEAKER_LVL:\n\tcase YM_MIC_LVL:\n\tcase YM_MONITOR_LVL:\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tif (dip->index == YM_MONITOR_LVL)\n\t\t\tdip->mixer_class = YM_MONITOR_CLASS;\n\t\telse\n\t\t\tdip->mixer_class = YM_INPUT_CLASS;\n\n\t\tdip->next = dip->index + 7;\n\n\t\tstrcpy(dip->label.name, mixer_port_names[dip->index - YM_MIDI_LVL]);\n\n\t\tif (dip->index == YM_SPEAKER_LVL ||\n\t\t    dip->index == YM_MIC_LVL)\n\t\t\tdip->un.v.num_channels = 1;\n\t\telse\n\t\t\tdip->un.v.num_channels = 2;\n\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\tbreak;\n\n\tcase YM_MIDI_MUTE:\n\tcase YM_CD_MUTE:\n\tcase YM_DAC_MUTE:\n\tcase YM_LINE_MUTE:\n\tcase YM_SPEAKER_MUTE:\n\tcase YM_MIC_MUTE:\n\tcase YM_MONITOR_MUTE:\n\t\tif (dip->index == YM_MONITOR_MUTE)\n\t\t\tdip->mixer_class = YM_MONITOR_CLASS;\n\t\telse\n\t\t\tdip->mixer_class = YM_INPUT_CLASS;\n\t\tdip->type = AUDIO_MIXER_ENUM;\n\t\tdip->prev = dip->index - 7;\nmute:\n\t\tstrcpy(dip->label.name, AudioNmute);\n\t\tdip->un.e.num_mem = 2;\n\t\tstrcpy(dip->un.e.member[0].label.name, AudioNoff);\n\t\tdip->un.e.member[0].ord = 0;\n\t\tstrcpy(dip->un.e.member[1].label.name, AudioNon);\n\t\tdip->un.e.member[1].ord = 1;\n\t\tbreak;\n\n\n\tcase YM_OUTPUT_LVL:\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->mixer_class = YM_OUTPUT_CLASS;\n\t\tdip->next = YM_OUTPUT_MUTE;\n\t\tstrcpy(dip->label.name, AudioNmaster);\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\tbreak;\n\n\tcase YM_OUTPUT_MUTE:\n\t\tdip->mixer_class = YM_OUTPUT_CLASS;\n\t\tdip->type = AUDIO_MIXER_ENUM;\n\t\tdip->prev = YM_OUTPUT_LVL;\n\t\tgoto mute;\n\n\tcase YM_REC_LVL:\t/* record level */\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->mixer_class = YM_RECORD_CLASS;\n\t\tdip->next = YM_RECORD_SOURCE;\n\t\tstrcpy(dip->label.name, AudioNrecord);\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\tbreak;\n\n\n\tcase YM_RECORD_SOURCE:\n\t\tdip->mixer_class = YM_RECORD_CLASS;\n\t\tdip->type = AUDIO_MIXER_ENUM;\n\t\tdip->prev = YM_REC_LVL;\n\t\tstrcpy(dip->label.name, AudioNsource);\n\t\tdip->un.e.num_mem = 4;\n\t\tstrcpy(dip->un.e.member[0].label.name, AudioNmicrophone);\n\t\tdip->un.e.member[0].ord = MIC_IN_PORT;\n\t\tstrcpy(dip->un.e.member[1].label.name, AudioNline);\n\t\tdip->un.e.member[1].ord = LINE_IN_PORT;\n\t\tstrcpy(dip->un.e.member[2].label.name, AudioNdac);\n\t\tdip->un.e.member[2].ord = DAC_IN_PORT;\n\t\tstrcpy(dip->un.e.member[3].label.name, AudioNcd);\n\t\tdip->un.e.member[3].ord = AUX1_IN_PORT;\n\t\tbreak;\n\n\tcase YM_MASTER_EQMODE:\n\t\tdip->type = AUDIO_MIXER_ENUM;\n\t\tdip->mixer_class = YM_EQ_CLASS;\n\t\tstrcpy(dip->label.name, AudioNmode);\n\t\tstrcpy(dip->un.v.units.name, AudioNmode);\n\t\tdip->un.e.num_mem = 4;\n\t\tstrcpy(dip->un.e.member[0].label.name, AudioNdesktop);\n\t\tdip->un.e.member[0].ord = SA3_SYS_CTL_YMODE0;\n\t\tstrcpy(dip->un.e.member[1].label.name, AudioNlaptop);\n\t\tdip->un.e.member[1].ord = SA3_SYS_CTL_YMODE1;\n\t\tstrcpy(dip->un.e.member[2].label.name, AudioNsubnote);\n\t\tdip->un.e.member[2].ord = SA3_SYS_CTL_YMODE2;\n\t\tstrcpy(dip->un.e.member[3].label.name, AudioNhifi);\n\t\tdip->un.e.member[3].ord = SA3_SYS_CTL_YMODE3;\n\t\tbreak;\n\n\tcase YM_MASTER_TREBLE:\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->mixer_class = YM_EQ_CLASS;\n\t\tstrcpy(dip->label.name, AudioNtreble);\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNtreble);\n\t\tbreak;\n\n\tcase YM_MASTER_BASS:\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->mixer_class = YM_EQ_CLASS;\n\t\tstrcpy(dip->label.name, AudioNbass);\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNbass);\n\t\tbreak;\n\n\tcase YM_MASTER_WIDE:\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->mixer_class = YM_EQ_CLASS;\n\t\tstrcpy(dip->label.name, AudioNsurround);\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNsurround);\n\t\tbreak;\n\n\tdefault:\n\t\treturn ENXIO;\n\t\t/* NOTREACHED */\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <dev/isa/ymvar.h>",
      "#include <dev/ic/mpuvar.h>",
      "#include <dev/ic/opl3sa3reg.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/midi_if.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"midi.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int ym_query_devinfo",
      "static char *mixer_classes[] = {\n\tAudioCinputs, AudioCrecord, AudioCoutputs, AudioCmonitor,\n\tAudioCequalization\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.v.units.name",
            "AudioNsurround"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNsurround"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.v.units.name",
            "AudioNbass"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNbass"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.v.units.name",
            "AudioNtreble"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNtreble"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.e.member[3].label.name",
            "AudioNhifi"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.e.member[2].label.name",
            "AudioNsubnote"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.e.member[1].label.name",
            "AudioNlaptop"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.e.member[0].label.name",
            "AudioNdesktop"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.v.units.name",
            "AudioNmode"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNmode"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.e.member[3].label.name",
            "AudioNcd"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.e.member[2].label.name",
            "AudioNdac"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.e.member[1].label.name",
            "AudioNline"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.e.member[0].label.name",
            "AudioNmicrophone"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNsource"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.v.units.name",
            "AudioNvolume"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNrecord"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.v.units.name",
            "AudioNvolume"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNmaster"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.e.member[1].label.name",
            "AudioNon"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.e.member[0].label.name",
            "AudioNoff"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNmute"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.v.units.name",
            "AudioNvolume"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "mixer_port_names[dip->index - YM_MIDI_LVL]"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "mixer_classes[dip->index - YM_INPUT_CLASS]"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/ymvar.h>\n#include <dev/ic/mpuvar.h>\n#include <dev/ic/opl3sa3reg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"midi.h\"\n\nint ym_query_devinfo;\nstatic char *mixer_classes[] = {\n\tAudioCinputs, AudioCrecord, AudioCoutputs, AudioCmonitor,\n\tAudioCequalization\n};\n\nint\nym_query_devinfo(addr, dip)\n\tvoid   *addr;\n\tmixer_devinfo_t *dip;\n{\n\tstatic char *mixer_port_names[] = { AudioNmidi, AudioNcd, AudioNdac,\n\t\tAudioNline, AudioNspeaker, AudioNmicrophone, AudioNmonitor\n\t};\n\n\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\n\tswitch (dip->index) {\n\tcase YM_INPUT_CLASS:\t/* input class descriptor */\n\tcase YM_OUTPUT_CLASS:\n\tcase YM_MONITOR_CLASS:\n\tcase YM_RECORD_CLASS:\n\tcase YM_EQ_CLASS:\n\t\tdip->type = AUDIO_MIXER_CLASS;\n\t\tdip->mixer_class = dip->index;\n\t\tstrcpy(dip->label.name,\n\t\t    mixer_classes[dip->index - YM_INPUT_CLASS]);\n\t\tbreak;\n\n\tcase YM_MIDI_LVL:\n\tcase YM_CD_LVL:\n\tcase YM_DAC_LVL:\n\tcase YM_LINE_LVL:\n\tcase YM_SPEAKER_LVL:\n\tcase YM_MIC_LVL:\n\tcase YM_MONITOR_LVL:\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tif (dip->index == YM_MONITOR_LVL)\n\t\t\tdip->mixer_class = YM_MONITOR_CLASS;\n\t\telse\n\t\t\tdip->mixer_class = YM_INPUT_CLASS;\n\n\t\tdip->next = dip->index + 7;\n\n\t\tstrcpy(dip->label.name, mixer_port_names[dip->index - YM_MIDI_LVL]);\n\n\t\tif (dip->index == YM_SPEAKER_LVL ||\n\t\t    dip->index == YM_MIC_LVL)\n\t\t\tdip->un.v.num_channels = 1;\n\t\telse\n\t\t\tdip->un.v.num_channels = 2;\n\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\tbreak;\n\n\tcase YM_MIDI_MUTE:\n\tcase YM_CD_MUTE:\n\tcase YM_DAC_MUTE:\n\tcase YM_LINE_MUTE:\n\tcase YM_SPEAKER_MUTE:\n\tcase YM_MIC_MUTE:\n\tcase YM_MONITOR_MUTE:\n\t\tif (dip->index == YM_MONITOR_MUTE)\n\t\t\tdip->mixer_class = YM_MONITOR_CLASS;\n\t\telse\n\t\t\tdip->mixer_class = YM_INPUT_CLASS;\n\t\tdip->type = AUDIO_MIXER_ENUM;\n\t\tdip->prev = dip->index - 7;\nmute:\n\t\tstrcpy(dip->label.name, AudioNmute);\n\t\tdip->un.e.num_mem = 2;\n\t\tstrcpy(dip->un.e.member[0].label.name, AudioNoff);\n\t\tdip->un.e.member[0].ord = 0;\n\t\tstrcpy(dip->un.e.member[1].label.name, AudioNon);\n\t\tdip->un.e.member[1].ord = 1;\n\t\tbreak;\n\n\n\tcase YM_OUTPUT_LVL:\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->mixer_class = YM_OUTPUT_CLASS;\n\t\tdip->next = YM_OUTPUT_MUTE;\n\t\tstrcpy(dip->label.name, AudioNmaster);\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\tbreak;\n\n\tcase YM_OUTPUT_MUTE:\n\t\tdip->mixer_class = YM_OUTPUT_CLASS;\n\t\tdip->type = AUDIO_MIXER_ENUM;\n\t\tdip->prev = YM_OUTPUT_LVL;\n\t\tgoto mute;\n\n\tcase YM_REC_LVL:\t/* record level */\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->mixer_class = YM_RECORD_CLASS;\n\t\tdip->next = YM_RECORD_SOURCE;\n\t\tstrcpy(dip->label.name, AudioNrecord);\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\tbreak;\n\n\n\tcase YM_RECORD_SOURCE:\n\t\tdip->mixer_class = YM_RECORD_CLASS;\n\t\tdip->type = AUDIO_MIXER_ENUM;\n\t\tdip->prev = YM_REC_LVL;\n\t\tstrcpy(dip->label.name, AudioNsource);\n\t\tdip->un.e.num_mem = 4;\n\t\tstrcpy(dip->un.e.member[0].label.name, AudioNmicrophone);\n\t\tdip->un.e.member[0].ord = MIC_IN_PORT;\n\t\tstrcpy(dip->un.e.member[1].label.name, AudioNline);\n\t\tdip->un.e.member[1].ord = LINE_IN_PORT;\n\t\tstrcpy(dip->un.e.member[2].label.name, AudioNdac);\n\t\tdip->un.e.member[2].ord = DAC_IN_PORT;\n\t\tstrcpy(dip->un.e.member[3].label.name, AudioNcd);\n\t\tdip->un.e.member[3].ord = AUX1_IN_PORT;\n\t\tbreak;\n\n\tcase YM_MASTER_EQMODE:\n\t\tdip->type = AUDIO_MIXER_ENUM;\n\t\tdip->mixer_class = YM_EQ_CLASS;\n\t\tstrcpy(dip->label.name, AudioNmode);\n\t\tstrcpy(dip->un.v.units.name, AudioNmode);\n\t\tdip->un.e.num_mem = 4;\n\t\tstrcpy(dip->un.e.member[0].label.name, AudioNdesktop);\n\t\tdip->un.e.member[0].ord = SA3_SYS_CTL_YMODE0;\n\t\tstrcpy(dip->un.e.member[1].label.name, AudioNlaptop);\n\t\tdip->un.e.member[1].ord = SA3_SYS_CTL_YMODE1;\n\t\tstrcpy(dip->un.e.member[2].label.name, AudioNsubnote);\n\t\tdip->un.e.member[2].ord = SA3_SYS_CTL_YMODE2;\n\t\tstrcpy(dip->un.e.member[3].label.name, AudioNhifi);\n\t\tdip->un.e.member[3].ord = SA3_SYS_CTL_YMODE3;\n\t\tbreak;\n\n\tcase YM_MASTER_TREBLE:\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->mixer_class = YM_EQ_CLASS;\n\t\tstrcpy(dip->label.name, AudioNtreble);\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNtreble);\n\t\tbreak;\n\n\tcase YM_MASTER_BASS:\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->mixer_class = YM_EQ_CLASS;\n\t\tstrcpy(dip->label.name, AudioNbass);\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNbass);\n\t\tbreak;\n\n\tcase YM_MASTER_WIDE:\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->mixer_class = YM_EQ_CLASS;\n\t\tstrcpy(dip->label.name, AudioNsurround);\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNsurround);\n\t\tbreak;\n\n\tdefault:\n\t\treturn ENXIO;\n\t\t/* NOTREACHED */\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ym_mixer_get_port",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ym.c",
    "lines": "374-430",
    "snippet": "int\nym_mixer_get_port(addr, cp)\n\tvoid   *addr;\n\tmixer_ctrl_t *cp;\n{\n\tstruct ad1848_softc *ac = addr;\n\tstruct ym_softc *sc = ac->parent;\n\n\tint     error = ad1848_mixer_get_port(ac, mappings, NUMMAP, cp);\n\n\tif (error != ENXIO)\n\t\treturn (error);\n\n\terror = 0;\n\n\tswitch (cp->dev) {\n\tcase YM_OUTPUT_LVL:\n\t\tad1848_from_vol(cp, &sc->master_gain);\n\t\tbreak;\n\n\tcase YM_OUTPUT_MUTE:\n\t\tcp->un.ord = sc->master_mute;\n\t\tbreak;\n\n\tcase YM_MIC_LVL:\n\t\tif (cp->un.value.num_channels != 1)\n\t\t\terror = EINVAL;\n\t\tcp->un.value.level[AUDIO_MIXER_LEVEL_MONO] = sc->mic_gain;\t\n\t\tbreak;\n\n\tcase YM_MASTER_EQMODE:\n\t\tcp->un.ord = sc->sc_eqmode;\n\t\tbreak;\n\n\tcase YM_MASTER_TREBLE:\n\t\tad1848_from_vol(cp, &sc->sc_treble);\n\t\tbreak;\n\n\tcase YM_MASTER_BASS:\n\t\tad1848_from_vol(cp, &sc->sc_bass);\n\t\tbreak;\n\n\tcase YM_MASTER_WIDE:\n\t\tad1848_from_vol(cp, &sc->sc_wide);\n\t\tbreak;\n\n\tcase YM_MIC_MUTE:\n\t\tcp->un.ord = sc->mic_mute;\n\t\tbreak;\n\n\tdefault:\n\t\terror = ENXIO;\n\t\tbreak;\n\t}\n\n\treturn (error);\n}",
    "includes": [
      "#include <dev/isa/ymvar.h>",
      "#include <dev/ic/mpuvar.h>",
      "#include <dev/ic/opl3sa3reg.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/midi_if.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"midi.h\""
    ],
    "macros_used": [
      "#define NUMMAP\t(sizeof(mappings) / sizeof(mappings[0]))"
    ],
    "globals_used": [
      "int ym_mixer_get_port",
      "static ad1848_devmap_t mappings[] = {\n\t{ YM_MIDI_LVL, AD1848_KIND_LVL, AD1848_AUX2_CHANNEL },\n\t{ YM_CD_LVL, AD1848_KIND_LVL, AD1848_AUX1_CHANNEL },\n\t{ YM_DAC_LVL, AD1848_KIND_LVL, AD1848_DAC_CHANNEL },\n\t{ YM_LINE_LVL, AD1848_KIND_LVL, AD1848_LINE_CHANNEL },\n\t{ YM_SPEAKER_LVL, AD1848_KIND_LVL, AD1848_MONO_CHANNEL },\n\t{ YM_MONITOR_LVL, AD1848_KIND_LVL, AD1848_MONITOR_CHANNEL },\n\t{ YM_MIDI_MUTE, AD1848_KIND_MUTE, AD1848_AUX2_CHANNEL },\n\t{ YM_CD_MUTE, AD1848_KIND_MUTE, AD1848_AUX1_CHANNEL },\n\t{ YM_DAC_MUTE, AD1848_KIND_MUTE, AD1848_DAC_CHANNEL },\n\t{ YM_LINE_MUTE, AD1848_KIND_MUTE, AD1848_LINE_CHANNEL },\n\t{ YM_SPEAKER_MUTE, AD1848_KIND_MUTE, AD1848_MONO_CHANNEL },\n\t{ YM_MONITOR_MUTE, AD1848_KIND_MUTE, AD1848_MONITOR_CHANNEL },\n\t{ YM_REC_LVL, AD1848_KIND_RECORDGAIN, -1 },\n\t{ YM_RECORD_SOURCE, AD1848_KIND_RECORDSOURCE, -1 }\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ad1848_from_vol",
          "args": [
            "cp",
            "&sc->sc_wide"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "ad1848_from_vol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848var.h",
          "lines": "162-177",
          "snippet": "static __inline int\nad1848_from_vol(cp, vol)\n\tmixer_ctrl_t *cp;\n\tstruct ad1848_volume *vol;\n{\n\tif (cp->un.value.num_channels == 1) {\n\t\tcp->un.value.level[AUDIO_MIXER_LEVEL_MONO] = vol->left;\n\t\treturn(1);\n\t}\n\telse if (cp->un.value.num_channels == 2) {\n\t\tcp->un.value.level[AUDIO_MIXER_LEVEL_LEFT] = vol->left;\n\t\tcp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] = vol->right;\n\t\treturn(1);\n\t}\n\treturn(0);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static __inline int\nad1848_from_vol(cp, vol)\n\tmixer_ctrl_t *cp;\n\tstruct ad1848_volume *vol;\n{\n\tif (cp->un.value.num_channels == 1) {\n\t\tcp->un.value.level[AUDIO_MIXER_LEVEL_MONO] = vol->left;\n\t\treturn(1);\n\t}\n\telse if (cp->un.value.num_channels == 2) {\n\t\tcp->un.value.level[AUDIO_MIXER_LEVEL_LEFT] = vol->left;\n\t\tcp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] = vol->right;\n\t\treturn(1);\n\t}\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ad1848_mixer_get_port",
          "args": [
            "ac",
            "mappings",
            "NUMMAP",
            "cp"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "ad1848_mixer_get_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "793-865",
          "snippet": "int     \nad1848_mixer_get_port(ac, map, cnt, cp)\n  struct ad1848_softc *ac;\n  struct ad1848_devmap *map;\n  int cnt;\n  mixer_ctrl_t *cp;\n{\n  ad1848_devmap_t *entry;\n  struct ad1848_volume vol;\n  int error = EINVAL;\n  int dev;\n\n  if (!(entry = ad1848_mixer_find_dev(map, cnt, cp)))\n    return (ENXIO);\n\n  dev = entry->dev;\n\n  switch (entry->kind) {\n  case AD1848_KIND_LVL:\n    if (cp->type != AUDIO_MIXER_VALUE)\n      break;\n\n    if (dev < AD1848_AUX2_CHANNEL ||\n\tdev > AD1848_MONITOR_CHANNEL)\n      break;\n\n    if (cp->un.value.num_channels != 1 &&\n        mixer_channel_info[dev].right_reg == 0) \n      break;\n\n    error = ad1848_get_device_gain(ac, dev, &vol);\n    if (!error)\n      ad1848_from_vol(cp, &vol);\n\n    break;\n\n  case AD1848_KIND_MUTE:\n    if (cp->type != AUDIO_MIXER_ENUM) break;\n\n    cp->un.ord = ac->mute[dev] ? 1 : 0;\n    error = 0;\n    break;\n\n  case AD1848_KIND_RECORDGAIN:\n    if (cp->type != AUDIO_MIXER_VALUE) break;\n\n    error = ad1848_get_rec_gain(ac, &vol);\n    if (!error)\n      ad1848_from_vol(cp, &vol);\n\n    break;\n\n  case AD1848_KIND_MICGAIN:\n    if (cp->type != AUDIO_MIXER_VALUE) break;\n\n    error = ad1848_get_mic_gain(ac, &vol);\n    if (!error)\n      ad1848_from_vol(cp, &vol);\n\n    break;\n\n  case AD1848_KIND_RECORDSOURCE:\n    if (cp->type != AUDIO_MIXER_ENUM) break;\n    cp->un.ord = ad1848_get_rec_port(ac);\n    error = 0;\n    break;\n  default:\n    printf (\"Invalid kind\\n\");\n    break;\n  }\n\n  return (error);\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct ad1848_mixerinfo {\n  int  left_reg;\n  int  right_reg;\n  int  atten_bits;\n  int  atten_mask;\n} mixer_channel_info[] = \n{ { SP_LEFT_AUX2_CONTROL, SP_RIGHT_AUX2_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_AUX1_CONTROL, SP_RIGHT_AUX1_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_OUTPUT_CONTROL, SP_RIGHT_OUTPUT_CONTROL, \n    OUTPUT_ATTEN_BITS, OUTPUT_ATTEN_MASK }, \n  { CS_LEFT_LINE_CONTROL, CS_RIGHT_LINE_CONTROL, LINE_INPUT_ATTEN_BITS,\n    LINE_INPUT_ATTEN_MASK },\n  { CS_MONO_IO_CONTROL, 0, MONO_INPUT_ATTEN_BITS, MONO_INPUT_ATTEN_MASK },\n  { SP_DIGITAL_MIX, 0, OUTPUT_ATTEN_BITS, MIX_ATTEN_MASK }\n};",
            "static ad1848_devmap_t *ad1848_mixer_find_dev",
            "static ad1848_devmap_t *\nad1848_mixer_find_dev(map, cnt, cp)\n  ad1848_devmap_t *map;",
            "int cnt;",
            "mixer_ctrl_t *cp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct ad1848_mixerinfo {\n  int  left_reg;\n  int  right_reg;\n  int  atten_bits;\n  int  atten_mask;\n} mixer_channel_info[] = \n{ { SP_LEFT_AUX2_CONTROL, SP_RIGHT_AUX2_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_AUX1_CONTROL, SP_RIGHT_AUX1_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_OUTPUT_CONTROL, SP_RIGHT_OUTPUT_CONTROL, \n    OUTPUT_ATTEN_BITS, OUTPUT_ATTEN_MASK }, \n  { CS_LEFT_LINE_CONTROL, CS_RIGHT_LINE_CONTROL, LINE_INPUT_ATTEN_BITS,\n    LINE_INPUT_ATTEN_MASK },\n  { CS_MONO_IO_CONTROL, 0, MONO_INPUT_ATTEN_BITS, MONO_INPUT_ATTEN_MASK },\n  { SP_DIGITAL_MIX, 0, OUTPUT_ATTEN_BITS, MIX_ATTEN_MASK }\n};\nstatic ad1848_devmap_t *ad1848_mixer_find_dev;\nstatic ad1848_devmap_t *\nad1848_mixer_find_dev(map, cnt, cp)\n  ad1848_devmap_t *map;\nint cnt;\nmixer_ctrl_t *cp;\n\nint     \nad1848_mixer_get_port(ac, map, cnt, cp)\n  struct ad1848_softc *ac;\n  struct ad1848_devmap *map;\n  int cnt;\n  mixer_ctrl_t *cp;\n{\n  ad1848_devmap_t *entry;\n  struct ad1848_volume vol;\n  int error = EINVAL;\n  int dev;\n\n  if (!(entry = ad1848_mixer_find_dev(map, cnt, cp)))\n    return (ENXIO);\n\n  dev = entry->dev;\n\n  switch (entry->kind) {\n  case AD1848_KIND_LVL:\n    if (cp->type != AUDIO_MIXER_VALUE)\n      break;\n\n    if (dev < AD1848_AUX2_CHANNEL ||\n\tdev > AD1848_MONITOR_CHANNEL)\n      break;\n\n    if (cp->un.value.num_channels != 1 &&\n        mixer_channel_info[dev].right_reg == 0) \n      break;\n\n    error = ad1848_get_device_gain(ac, dev, &vol);\n    if (!error)\n      ad1848_from_vol(cp, &vol);\n\n    break;\n\n  case AD1848_KIND_MUTE:\n    if (cp->type != AUDIO_MIXER_ENUM) break;\n\n    cp->un.ord = ac->mute[dev] ? 1 : 0;\n    error = 0;\n    break;\n\n  case AD1848_KIND_RECORDGAIN:\n    if (cp->type != AUDIO_MIXER_VALUE) break;\n\n    error = ad1848_get_rec_gain(ac, &vol);\n    if (!error)\n      ad1848_from_vol(cp, &vol);\n\n    break;\n\n  case AD1848_KIND_MICGAIN:\n    if (cp->type != AUDIO_MIXER_VALUE) break;\n\n    error = ad1848_get_mic_gain(ac, &vol);\n    if (!error)\n      ad1848_from_vol(cp, &vol);\n\n    break;\n\n  case AD1848_KIND_RECORDSOURCE:\n    if (cp->type != AUDIO_MIXER_ENUM) break;\n    cp->un.ord = ad1848_get_rec_port(ac);\n    error = 0;\n    break;\n  default:\n    printf (\"Invalid kind\\n\");\n    break;\n  }\n\n  return (error);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/ymvar.h>\n#include <dev/ic/mpuvar.h>\n#include <dev/ic/opl3sa3reg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"midi.h\"\n\n#define NUMMAP\t(sizeof(mappings) / sizeof(mappings[0]))\n\nint ym_mixer_get_port;\nstatic ad1848_devmap_t mappings[] = {\n\t{ YM_MIDI_LVL, AD1848_KIND_LVL, AD1848_AUX2_CHANNEL },\n\t{ YM_CD_LVL, AD1848_KIND_LVL, AD1848_AUX1_CHANNEL },\n\t{ YM_DAC_LVL, AD1848_KIND_LVL, AD1848_DAC_CHANNEL },\n\t{ YM_LINE_LVL, AD1848_KIND_LVL, AD1848_LINE_CHANNEL },\n\t{ YM_SPEAKER_LVL, AD1848_KIND_LVL, AD1848_MONO_CHANNEL },\n\t{ YM_MONITOR_LVL, AD1848_KIND_LVL, AD1848_MONITOR_CHANNEL },\n\t{ YM_MIDI_MUTE, AD1848_KIND_MUTE, AD1848_AUX2_CHANNEL },\n\t{ YM_CD_MUTE, AD1848_KIND_MUTE, AD1848_AUX1_CHANNEL },\n\t{ YM_DAC_MUTE, AD1848_KIND_MUTE, AD1848_DAC_CHANNEL },\n\t{ YM_LINE_MUTE, AD1848_KIND_MUTE, AD1848_LINE_CHANNEL },\n\t{ YM_SPEAKER_MUTE, AD1848_KIND_MUTE, AD1848_MONO_CHANNEL },\n\t{ YM_MONITOR_MUTE, AD1848_KIND_MUTE, AD1848_MONITOR_CHANNEL },\n\t{ YM_REC_LVL, AD1848_KIND_RECORDGAIN, -1 },\n\t{ YM_RECORD_SOURCE, AD1848_KIND_RECORDSOURCE, -1 }\n};\n\nint\nym_mixer_get_port(addr, cp)\n\tvoid   *addr;\n\tmixer_ctrl_t *cp;\n{\n\tstruct ad1848_softc *ac = addr;\n\tstruct ym_softc *sc = ac->parent;\n\n\tint     error = ad1848_mixer_get_port(ac, mappings, NUMMAP, cp);\n\n\tif (error != ENXIO)\n\t\treturn (error);\n\n\terror = 0;\n\n\tswitch (cp->dev) {\n\tcase YM_OUTPUT_LVL:\n\t\tad1848_from_vol(cp, &sc->master_gain);\n\t\tbreak;\n\n\tcase YM_OUTPUT_MUTE:\n\t\tcp->un.ord = sc->master_mute;\n\t\tbreak;\n\n\tcase YM_MIC_LVL:\n\t\tif (cp->un.value.num_channels != 1)\n\t\t\terror = EINVAL;\n\t\tcp->un.value.level[AUDIO_MIXER_LEVEL_MONO] = sc->mic_gain;\t\n\t\tbreak;\n\n\tcase YM_MASTER_EQMODE:\n\t\tcp->un.ord = sc->sc_eqmode;\n\t\tbreak;\n\n\tcase YM_MASTER_TREBLE:\n\t\tad1848_from_vol(cp, &sc->sc_treble);\n\t\tbreak;\n\n\tcase YM_MASTER_BASS:\n\t\tad1848_from_vol(cp, &sc->sc_bass);\n\t\tbreak;\n\n\tcase YM_MASTER_WIDE:\n\t\tad1848_from_vol(cp, &sc->sc_wide);\n\t\tbreak;\n\n\tcase YM_MIC_MUTE:\n\t\tcp->un.ord = sc->mic_mute;\n\t\tbreak;\n\n\tdefault:\n\t\terror = ENXIO;\n\t\tbreak;\n\t}\n\n\treturn (error);\n}"
  },
  {
    "function_name": "ym_mixer_set_port",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ym.c",
    "lines": "308-372",
    "snippet": "int\nym_mixer_set_port(addr, cp)\n\tvoid   *addr;\n\tmixer_ctrl_t *cp;\n{\n\tstruct ad1848_softc *ac = addr;\n\tstruct ym_softc *sc = ac->parent;\n\tstruct ad1848_volume vol;\n\tint     error = ad1848_mixer_set_port(ac, mappings, NUMMAP, cp);\n\n\tif (error != ENXIO)\n\t\treturn (error);\n\n\terror = 0;\n\n\tswitch (cp->dev) {\n\tcase YM_OUTPUT_LVL:\n\t\tad1848_to_vol(cp, &vol);\n\t\tym_set_master_gain(sc, &vol);\n\t\tbreak;\n\n\tcase YM_OUTPUT_MUTE:\n\t\tsc->master_mute = (cp->un.ord != 0);\n\t\tym_mute(sc, SA3_VOL_L, sc->master_mute);\n\t\tym_mute(sc, SA3_VOL_R, sc->master_mute);\n\t\tbreak;\n\n\tcase YM_MIC_LVL:\n\t\tif (cp->un.value.num_channels != 1)\n\t\t\terror = EINVAL;\n\t\telse\n\t\t\tym_set_mic_gain(sc,\n\t\t\t    cp->un.value.level[AUDIO_MIXER_LEVEL_MONO]);\n\t\tbreak;\n\n\tcase YM_MASTER_EQMODE:\n\t\tsc->sc_eqmode = cp->un.ord & SA3_SYS_CTL_YMODE;\n\t\tym_write(sc, SA3_SYS_CTL, (ym_read(sc, SA3_SYS_CTL) &\n\t\t    ~SA3_SYS_CTL_YMODE) | sc->sc_eqmode);\n\t\tbreak;\n\n\tcase YM_MASTER_TREBLE:\n\t\tym_set_3d(sc, cp, &sc->sc_treble, SA3_3D_TREBLE);\n\t\tbreak;\n\n\tcase YM_MASTER_BASS:\n\t\tym_set_3d(sc, cp, &sc->sc_bass, SA3_3D_BASS);\n\t\tbreak;\n\n\tcase YM_MASTER_WIDE:\n\t\tym_set_3d(sc, cp, &sc->sc_wide, SA3_3D_WIDE);\n\t\tbreak;\n\n\tcase YM_MIC_MUTE:\n\t\tsc->mic_mute = (cp->un.ord != 0);\n\t\tym_mute(sc, SA3_MIC_VOL, sc->mic_mute);\n\t\tbreak;\n\n\tdefault:\n\t\treturn ENXIO;\n\t\t/* NOTREACHED */\n\t}\n\n\treturn (error);\n}",
    "includes": [
      "#include <dev/isa/ymvar.h>",
      "#include <dev/ic/mpuvar.h>",
      "#include <dev/ic/opl3sa3reg.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/midi_if.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"midi.h\""
    ],
    "macros_used": [
      "#define NUMMAP\t(sizeof(mappings) / sizeof(mappings[0]))"
    ],
    "globals_used": [
      "int ym_mixer_set_port",
      "static void ym_mute",
      "static void ym_set_master_gain",
      "static void ym_set_mic_gain",
      "static void ym_set_3d",
      "static __inline int ym_read",
      "static __inline void ym_write",
      "static ad1848_devmap_t mappings[] = {\n\t{ YM_MIDI_LVL, AD1848_KIND_LVL, AD1848_AUX2_CHANNEL },\n\t{ YM_CD_LVL, AD1848_KIND_LVL, AD1848_AUX1_CHANNEL },\n\t{ YM_DAC_LVL, AD1848_KIND_LVL, AD1848_DAC_CHANNEL },\n\t{ YM_LINE_LVL, AD1848_KIND_LVL, AD1848_LINE_CHANNEL },\n\t{ YM_SPEAKER_LVL, AD1848_KIND_LVL, AD1848_MONO_CHANNEL },\n\t{ YM_MONITOR_LVL, AD1848_KIND_LVL, AD1848_MONITOR_CHANNEL },\n\t{ YM_MIDI_MUTE, AD1848_KIND_MUTE, AD1848_AUX2_CHANNEL },\n\t{ YM_CD_MUTE, AD1848_KIND_MUTE, AD1848_AUX1_CHANNEL },\n\t{ YM_DAC_MUTE, AD1848_KIND_MUTE, AD1848_DAC_CHANNEL },\n\t{ YM_LINE_MUTE, AD1848_KIND_MUTE, AD1848_LINE_CHANNEL },\n\t{ YM_SPEAKER_MUTE, AD1848_KIND_MUTE, AD1848_MONO_CHANNEL },\n\t{ YM_MONITOR_MUTE, AD1848_KIND_MUTE, AD1848_MONITOR_CHANNEL },\n\t{ YM_REC_LVL, AD1848_KIND_RECORDGAIN, -1 },\n\t{ YM_RECORD_SOURCE, AD1848_KIND_RECORDSOURCE, -1 }\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ym_mute",
          "args": [
            "sc",
            "SA3_MIC_VOL",
            "sc->mic_mute"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "ym_mute",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ym.c",
          "lines": "238-251",
          "snippet": "static void\nym_mute(sc, left_reg, mute)\n\tstruct ym_softc *sc;\n\tint     left_reg;\n\tint     mute;\n{\n\tu_int8_t reg;\n\n\treg = ym_read(sc, left_reg);\n\tif (mute)\n\t\tym_write(sc, left_reg, reg | 0x80);\n\telse\n\t\tym_write(sc, left_reg, reg & ~0x80);\n}",
          "includes": [
            "#include <dev/isa/ymvar.h>",
            "#include <dev/ic/mpuvar.h>",
            "#include <dev/ic/opl3sa3reg.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/midi_if.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"midi.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ym_mute",
            "static __inline int ym_read",
            "static __inline void ym_write"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/ymvar.h>\n#include <dev/ic/mpuvar.h>\n#include <dev/ic/opl3sa3reg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"midi.h\"\n\nstatic void ym_mute;\nstatic __inline int ym_read;\nstatic __inline void ym_write;\n\nstatic void\nym_mute(sc, left_reg, mute)\n\tstruct ym_softc *sc;\n\tint     left_reg;\n\tint     mute;\n{\n\tu_int8_t reg;\n\n\treg = ym_read(sc, left_reg);\n\tif (mute)\n\t\tym_write(sc, left_reg, reg | 0x80);\n\telse\n\t\tym_write(sc, left_reg, reg & ~0x80);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ym_set_3d",
          "args": [
            "sc",
            "cp",
            "&sc->sc_wide",
            "SA3_3D_WIDE"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "ym_set_3d",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ym.c",
          "lines": "289-306",
          "snippet": "static void\nym_set_3d(sc, cp, val, reg)\n\tstruct ym_softc *sc;\n\tmixer_ctrl_t *cp;\n\tstruct ad1848_volume *val;\n\tint reg;\n{\n\tu_int8_t e;\n\n\tad1848_to_vol(cp, val);\n\n\te = (val->left * (SA3_3D_BITS + 1) + (SA3_3D_BITS + 1) / 2) /\n\t\t(AUDIO_MAX_GAIN + 1) << SA3_3D_LSHIFT |\n\t    (val->right * (SA3_3D_BITS + 1) + (SA3_3D_BITS + 1) / 2) /\n\t\t(AUDIO_MAX_GAIN + 1) << SA3_3D_RSHIFT;\n\n\tym_write(sc, reg, e);\n}",
          "includes": [
            "#include <dev/isa/ymvar.h>",
            "#include <dev/ic/mpuvar.h>",
            "#include <dev/ic/opl3sa3reg.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/midi_if.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"midi.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ym_set_3d",
            "static __inline void ym_write"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/ymvar.h>\n#include <dev/ic/mpuvar.h>\n#include <dev/ic/opl3sa3reg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"midi.h\"\n\nstatic void ym_set_3d;\nstatic __inline void ym_write;\n\nstatic void\nym_set_3d(sc, cp, val, reg)\n\tstruct ym_softc *sc;\n\tmixer_ctrl_t *cp;\n\tstruct ad1848_volume *val;\n\tint reg;\n{\n\tu_int8_t e;\n\n\tad1848_to_vol(cp, val);\n\n\te = (val->left * (SA3_3D_BITS + 1) + (SA3_3D_BITS + 1) / 2) /\n\t\t(AUDIO_MAX_GAIN + 1) << SA3_3D_LSHIFT |\n\t    (val->right * (SA3_3D_BITS + 1) + (SA3_3D_BITS + 1) / 2) /\n\t\t(AUDIO_MAX_GAIN + 1) << SA3_3D_RSHIFT;\n\n\tym_write(sc, reg, e);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ym_write",
          "args": [
            "sc",
            "SA3_SYS_CTL",
            "(ym_read(sc, SA3_SYS_CTL) &\n\t\t    ~SA3_SYS_CTL_YMODE) | sc->sc_eqmode"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "ym_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ym.c",
          "lines": "194-204",
          "snippet": "static __inline void\nym_write(sc, reg, data)\n\tstruct ym_softc *sc;\n\tint     reg;\n\tint     data;\n{\n\tbus_space_write_1(sc->sc_iot, sc->sc_controlioh, SA3_CTL_INDEX,\n\t    (reg & 0xff));\n\tbus_space_write_1(sc->sc_iot, sc->sc_controlioh, SA3_CTL_DATA,\n\t    (data & 0xff));\n}",
          "includes": [
            "#include <dev/isa/ymvar.h>",
            "#include <dev/ic/mpuvar.h>",
            "#include <dev/ic/opl3sa3reg.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/midi_if.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"midi.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline void ym_write"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/ymvar.h>\n#include <dev/ic/mpuvar.h>\n#include <dev/ic/opl3sa3reg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"midi.h\"\n\nstatic __inline void ym_write;\n\nstatic __inline void\nym_write(sc, reg, data)\n\tstruct ym_softc *sc;\n\tint     reg;\n\tint     data;\n{\n\tbus_space_write_1(sc->sc_iot, sc->sc_controlioh, SA3_CTL_INDEX,\n\t    (reg & 0xff));\n\tbus_space_write_1(sc->sc_iot, sc->sc_controlioh, SA3_CTL_DATA,\n\t    (data & 0xff));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ym_read",
          "args": [
            "sc",
            "SA3_SYS_CTL"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "ym_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ym.c",
          "lines": "184-192",
          "snippet": "static __inline int\nym_read(sc, reg)\n\tstruct ym_softc *sc;\n\tint     reg;\n{\n\tbus_space_write_1(sc->sc_iot, sc->sc_controlioh, SA3_CTL_INDEX,\n\t    (reg & 0xff));\n\treturn (bus_space_read_1(sc->sc_iot, sc->sc_controlioh, SA3_CTL_DATA));\n}",
          "includes": [
            "#include <dev/isa/ymvar.h>",
            "#include <dev/ic/mpuvar.h>",
            "#include <dev/ic/opl3sa3reg.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/midi_if.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"midi.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline int ym_read"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/ymvar.h>\n#include <dev/ic/mpuvar.h>\n#include <dev/ic/opl3sa3reg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"midi.h\"\n\nstatic __inline int ym_read;\n\nstatic __inline int\nym_read(sc, reg)\n\tstruct ym_softc *sc;\n\tint     reg;\n{\n\tbus_space_write_1(sc->sc_iot, sc->sc_controlioh, SA3_CTL_INDEX,\n\t    (reg & 0xff));\n\treturn (bus_space_read_1(sc->sc_iot, sc->sc_controlioh, SA3_CTL_DATA));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ym_set_mic_gain",
          "args": [
            "sc",
            "cp->un.value.level[AUDIO_MIXER_LEVEL_MONO]"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "ym_set_mic_gain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ym.c",
          "lines": "273-287",
          "snippet": "static void\nym_set_mic_gain(sc, vol)\n\tstruct ym_softc *sc;\n\tint vol;\n{\n\tu_int   atten;\n\n\tsc->mic_gain = vol;\n\n\tatten = ((AUDIO_MAX_GAIN - vol) * (SA3_MIC_MCV + 1)) /\n\t    (AUDIO_MAX_GAIN + 1);\n\n\tym_write(sc, SA3_MIC_VOL,\n\t    (ym_read(sc, SA3_MIC_VOL) & ~SA3_MIC_MCV) | atten);\n}",
          "includes": [
            "#include <dev/isa/ymvar.h>",
            "#include <dev/ic/mpuvar.h>",
            "#include <dev/ic/opl3sa3reg.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/midi_if.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"midi.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ym_set_mic_gain",
            "static __inline int ym_read",
            "static __inline void ym_write"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/ymvar.h>\n#include <dev/ic/mpuvar.h>\n#include <dev/ic/opl3sa3reg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"midi.h\"\n\nstatic void ym_set_mic_gain;\nstatic __inline int ym_read;\nstatic __inline void ym_write;\n\nstatic void\nym_set_mic_gain(sc, vol)\n\tstruct ym_softc *sc;\n\tint vol;\n{\n\tu_int   atten;\n\n\tsc->mic_gain = vol;\n\n\tatten = ((AUDIO_MAX_GAIN - vol) * (SA3_MIC_MCV + 1)) /\n\t    (AUDIO_MAX_GAIN + 1);\n\n\tym_write(sc, SA3_MIC_VOL,\n\t    (ym_read(sc, SA3_MIC_VOL) & ~SA3_MIC_MCV) | atten);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ym_set_master_gain",
          "args": [
            "sc",
            "&vol"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "ym_set_master_gain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ym.c",
          "lines": "253-271",
          "snippet": "static void\nym_set_master_gain(sc, vol)\n\tstruct ym_softc *sc;\n\tstruct ad1848_volume *vol;\n{\n\tu_int   atten;\n\n\tsc->master_gain = *vol;\n\n\tatten = ((AUDIO_MAX_GAIN - vol->left) * (SA3_VOL_MV + 1)) /\n\t   (AUDIO_MAX_GAIN + 1);\n\n\tym_write(sc, SA3_VOL_L, (ym_read(sc, SA3_VOL_L) & ~SA3_VOL_MV) | atten);\n\n\tatten = ((AUDIO_MAX_GAIN - vol->right) * (SA3_VOL_MV + 1)) /\n\t   (AUDIO_MAX_GAIN + 1);\n\n\tym_write(sc, SA3_VOL_R, (ym_read(sc, SA3_VOL_R) & ~SA3_VOL_MV) | atten);\n}",
          "includes": [
            "#include <dev/isa/ymvar.h>",
            "#include <dev/ic/mpuvar.h>",
            "#include <dev/ic/opl3sa3reg.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/midi_if.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"midi.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ym_set_master_gain",
            "static __inline int ym_read",
            "static __inline void ym_write"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/ymvar.h>\n#include <dev/ic/mpuvar.h>\n#include <dev/ic/opl3sa3reg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"midi.h\"\n\nstatic void ym_set_master_gain;\nstatic __inline int ym_read;\nstatic __inline void ym_write;\n\nstatic void\nym_set_master_gain(sc, vol)\n\tstruct ym_softc *sc;\n\tstruct ad1848_volume *vol;\n{\n\tu_int   atten;\n\n\tsc->master_gain = *vol;\n\n\tatten = ((AUDIO_MAX_GAIN - vol->left) * (SA3_VOL_MV + 1)) /\n\t   (AUDIO_MAX_GAIN + 1);\n\n\tym_write(sc, SA3_VOL_L, (ym_read(sc, SA3_VOL_L) & ~SA3_VOL_MV) | atten);\n\n\tatten = ((AUDIO_MAX_GAIN - vol->right) * (SA3_VOL_MV + 1)) /\n\t   (AUDIO_MAX_GAIN + 1);\n\n\tym_write(sc, SA3_VOL_R, (ym_read(sc, SA3_VOL_R) & ~SA3_VOL_MV) | atten);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ad1848_to_vol",
          "args": [
            "cp",
            "&vol"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "ad1848_to_vol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848var.h",
          "lines": "145-160",
          "snippet": "static __inline int\nad1848_to_vol(cp, vol)\n\tmixer_ctrl_t *cp;\n\tstruct ad1848_volume *vol;\n{\n\tif (cp->un.value.num_channels == 1) {\n\t\tvol->left = vol->right = cp->un.value.level[AUDIO_MIXER_LEVEL_MONO];\n\t\treturn(1);\n\t}\n\telse if (cp->un.value.num_channels == 2) {\n\t\tvol->left  = cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT];\n\t\tvol->right = cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT];\n\t\treturn(1);\n\t}\n\treturn(0);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static __inline int\nad1848_to_vol(cp, vol)\n\tmixer_ctrl_t *cp;\n\tstruct ad1848_volume *vol;\n{\n\tif (cp->un.value.num_channels == 1) {\n\t\tvol->left = vol->right = cp->un.value.level[AUDIO_MIXER_LEVEL_MONO];\n\t\treturn(1);\n\t}\n\telse if (cp->un.value.num_channels == 2) {\n\t\tvol->left  = cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT];\n\t\tvol->right = cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT];\n\t\treturn(1);\n\t}\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ad1848_mixer_set_port",
          "args": [
            "ac",
            "mappings",
            "NUMMAP",
            "cp"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "ad1848_mixer_set_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "867-934",
          "snippet": "int     \nad1848_mixer_set_port(ac, map, cnt, cp)\n  struct ad1848_softc *ac;\n  struct ad1848_devmap *map;\n  int cnt;\n  mixer_ctrl_t *cp;\n{\n  ad1848_devmap_t *entry;\n  struct ad1848_volume vol;\n  int error = EINVAL;\n  int dev;\n\n  if (!(entry = ad1848_mixer_find_dev(map, cnt, cp)))\n    return (ENXIO);\n\n  dev = entry->dev;\n\n  switch (entry->kind) {\n  case AD1848_KIND_LVL:\n    if (cp->type != AUDIO_MIXER_VALUE)\n      break;\n\n    if (dev < AD1848_AUX2_CHANNEL ||\n\tdev > AD1848_MONITOR_CHANNEL)\n      break;\n\n    if (cp->un.value.num_channels != 1 &&\n        mixer_channel_info[dev].right_reg == 0) \n      break;\n    \n    ad1848_to_vol(cp, &vol);\n    error = ad1848_set_channel_gain(ac, dev, &vol);\n    break;\n\n  case AD1848_KIND_MUTE:\n    if (cp->type != AUDIO_MIXER_ENUM) break;\n    \n    ac->mute[dev] = (cp->un.ord ? MUTE_ALL : 0);\n    ad1848_mute_channel(ac, dev, ac->mute[dev]);\n    error = 0;\n    break;\n\n  case AD1848_KIND_RECORDGAIN:\n    if (cp->type != AUDIO_MIXER_VALUE) break;\n\n    ad1848_to_vol(cp, &vol);\n    error = ad1848_set_rec_gain(ac, &vol);\n    break;\n\n  case AD1848_KIND_MICGAIN:\n    if (cp->type != AUDIO_MIXER_VALUE) break;\n\n    ad1848_to_vol(cp, &vol);\n    error = ad1848_set_mic_gain(ac, &vol);\n    break;\n\n  case AD1848_KIND_RECORDSOURCE:\n    if (cp->type != AUDIO_MIXER_ENUM) break;\n\n    error = ad1848_set_rec_port(ac,  cp->un.ord);\n    break;\n  default:\n    printf (\"Invalid kind\\n\");\n    break;\n  }\n\n  return (error);\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct ad1848_mixerinfo {\n  int  left_reg;\n  int  right_reg;\n  int  atten_bits;\n  int  atten_mask;\n} mixer_channel_info[] = \n{ { SP_LEFT_AUX2_CONTROL, SP_RIGHT_AUX2_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_AUX1_CONTROL, SP_RIGHT_AUX1_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_OUTPUT_CONTROL, SP_RIGHT_OUTPUT_CONTROL, \n    OUTPUT_ATTEN_BITS, OUTPUT_ATTEN_MASK }, \n  { CS_LEFT_LINE_CONTROL, CS_RIGHT_LINE_CONTROL, LINE_INPUT_ATTEN_BITS,\n    LINE_INPUT_ATTEN_MASK },\n  { CS_MONO_IO_CONTROL, 0, MONO_INPUT_ATTEN_BITS, MONO_INPUT_ATTEN_MASK },\n  { SP_DIGITAL_MIX, 0, OUTPUT_ATTEN_BITS, MIX_ATTEN_MASK }\n};",
            "static ad1848_devmap_t *ad1848_mixer_find_dev",
            "static ad1848_devmap_t *\nad1848_mixer_find_dev(map, cnt, cp)\n  ad1848_devmap_t *map;",
            "int cnt;",
            "mixer_ctrl_t *cp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct ad1848_mixerinfo {\n  int  left_reg;\n  int  right_reg;\n  int  atten_bits;\n  int  atten_mask;\n} mixer_channel_info[] = \n{ { SP_LEFT_AUX2_CONTROL, SP_RIGHT_AUX2_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_AUX1_CONTROL, SP_RIGHT_AUX1_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_OUTPUT_CONTROL, SP_RIGHT_OUTPUT_CONTROL, \n    OUTPUT_ATTEN_BITS, OUTPUT_ATTEN_MASK }, \n  { CS_LEFT_LINE_CONTROL, CS_RIGHT_LINE_CONTROL, LINE_INPUT_ATTEN_BITS,\n    LINE_INPUT_ATTEN_MASK },\n  { CS_MONO_IO_CONTROL, 0, MONO_INPUT_ATTEN_BITS, MONO_INPUT_ATTEN_MASK },\n  { SP_DIGITAL_MIX, 0, OUTPUT_ATTEN_BITS, MIX_ATTEN_MASK }\n};\nstatic ad1848_devmap_t *ad1848_mixer_find_dev;\nstatic ad1848_devmap_t *\nad1848_mixer_find_dev(map, cnt, cp)\n  ad1848_devmap_t *map;\nint cnt;\nmixer_ctrl_t *cp;\n\nint     \nad1848_mixer_set_port(ac, map, cnt, cp)\n  struct ad1848_softc *ac;\n  struct ad1848_devmap *map;\n  int cnt;\n  mixer_ctrl_t *cp;\n{\n  ad1848_devmap_t *entry;\n  struct ad1848_volume vol;\n  int error = EINVAL;\n  int dev;\n\n  if (!(entry = ad1848_mixer_find_dev(map, cnt, cp)))\n    return (ENXIO);\n\n  dev = entry->dev;\n\n  switch (entry->kind) {\n  case AD1848_KIND_LVL:\n    if (cp->type != AUDIO_MIXER_VALUE)\n      break;\n\n    if (dev < AD1848_AUX2_CHANNEL ||\n\tdev > AD1848_MONITOR_CHANNEL)\n      break;\n\n    if (cp->un.value.num_channels != 1 &&\n        mixer_channel_info[dev].right_reg == 0) \n      break;\n    \n    ad1848_to_vol(cp, &vol);\n    error = ad1848_set_channel_gain(ac, dev, &vol);\n    break;\n\n  case AD1848_KIND_MUTE:\n    if (cp->type != AUDIO_MIXER_ENUM) break;\n    \n    ac->mute[dev] = (cp->un.ord ? MUTE_ALL : 0);\n    ad1848_mute_channel(ac, dev, ac->mute[dev]);\n    error = 0;\n    break;\n\n  case AD1848_KIND_RECORDGAIN:\n    if (cp->type != AUDIO_MIXER_VALUE) break;\n\n    ad1848_to_vol(cp, &vol);\n    error = ad1848_set_rec_gain(ac, &vol);\n    break;\n\n  case AD1848_KIND_MICGAIN:\n    if (cp->type != AUDIO_MIXER_VALUE) break;\n\n    ad1848_to_vol(cp, &vol);\n    error = ad1848_set_mic_gain(ac, &vol);\n    break;\n\n  case AD1848_KIND_RECORDSOURCE:\n    if (cp->type != AUDIO_MIXER_ENUM) break;\n\n    error = ad1848_set_rec_port(ac,  cp->un.ord);\n    break;\n  default:\n    printf (\"Invalid kind\\n\");\n    break;\n  }\n\n  return (error);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/ymvar.h>\n#include <dev/ic/mpuvar.h>\n#include <dev/ic/opl3sa3reg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"midi.h\"\n\n#define NUMMAP\t(sizeof(mappings) / sizeof(mappings[0]))\n\nint ym_mixer_set_port;\nstatic void ym_mute;\nstatic void ym_set_master_gain;\nstatic void ym_set_mic_gain;\nstatic void ym_set_3d;\nstatic __inline int ym_read;\nstatic __inline void ym_write;\nstatic ad1848_devmap_t mappings[] = {\n\t{ YM_MIDI_LVL, AD1848_KIND_LVL, AD1848_AUX2_CHANNEL },\n\t{ YM_CD_LVL, AD1848_KIND_LVL, AD1848_AUX1_CHANNEL },\n\t{ YM_DAC_LVL, AD1848_KIND_LVL, AD1848_DAC_CHANNEL },\n\t{ YM_LINE_LVL, AD1848_KIND_LVL, AD1848_LINE_CHANNEL },\n\t{ YM_SPEAKER_LVL, AD1848_KIND_LVL, AD1848_MONO_CHANNEL },\n\t{ YM_MONITOR_LVL, AD1848_KIND_LVL, AD1848_MONITOR_CHANNEL },\n\t{ YM_MIDI_MUTE, AD1848_KIND_MUTE, AD1848_AUX2_CHANNEL },\n\t{ YM_CD_MUTE, AD1848_KIND_MUTE, AD1848_AUX1_CHANNEL },\n\t{ YM_DAC_MUTE, AD1848_KIND_MUTE, AD1848_DAC_CHANNEL },\n\t{ YM_LINE_MUTE, AD1848_KIND_MUTE, AD1848_LINE_CHANNEL },\n\t{ YM_SPEAKER_MUTE, AD1848_KIND_MUTE, AD1848_MONO_CHANNEL },\n\t{ YM_MONITOR_MUTE, AD1848_KIND_MUTE, AD1848_MONITOR_CHANNEL },\n\t{ YM_REC_LVL, AD1848_KIND_RECORDGAIN, -1 },\n\t{ YM_RECORD_SOURCE, AD1848_KIND_RECORDSOURCE, -1 }\n};\n\nint\nym_mixer_set_port(addr, cp)\n\tvoid   *addr;\n\tmixer_ctrl_t *cp;\n{\n\tstruct ad1848_softc *ac = addr;\n\tstruct ym_softc *sc = ac->parent;\n\tstruct ad1848_volume vol;\n\tint     error = ad1848_mixer_set_port(ac, mappings, NUMMAP, cp);\n\n\tif (error != ENXIO)\n\t\treturn (error);\n\n\terror = 0;\n\n\tswitch (cp->dev) {\n\tcase YM_OUTPUT_LVL:\n\t\tad1848_to_vol(cp, &vol);\n\t\tym_set_master_gain(sc, &vol);\n\t\tbreak;\n\n\tcase YM_OUTPUT_MUTE:\n\t\tsc->master_mute = (cp->un.ord != 0);\n\t\tym_mute(sc, SA3_VOL_L, sc->master_mute);\n\t\tym_mute(sc, SA3_VOL_R, sc->master_mute);\n\t\tbreak;\n\n\tcase YM_MIC_LVL:\n\t\tif (cp->un.value.num_channels != 1)\n\t\t\terror = EINVAL;\n\t\telse\n\t\t\tym_set_mic_gain(sc,\n\t\t\t    cp->un.value.level[AUDIO_MIXER_LEVEL_MONO]);\n\t\tbreak;\n\n\tcase YM_MASTER_EQMODE:\n\t\tsc->sc_eqmode = cp->un.ord & SA3_SYS_CTL_YMODE;\n\t\tym_write(sc, SA3_SYS_CTL, (ym_read(sc, SA3_SYS_CTL) &\n\t\t    ~SA3_SYS_CTL_YMODE) | sc->sc_eqmode);\n\t\tbreak;\n\n\tcase YM_MASTER_TREBLE:\n\t\tym_set_3d(sc, cp, &sc->sc_treble, SA3_3D_TREBLE);\n\t\tbreak;\n\n\tcase YM_MASTER_BASS:\n\t\tym_set_3d(sc, cp, &sc->sc_bass, SA3_3D_BASS);\n\t\tbreak;\n\n\tcase YM_MASTER_WIDE:\n\t\tym_set_3d(sc, cp, &sc->sc_wide, SA3_3D_WIDE);\n\t\tbreak;\n\n\tcase YM_MIC_MUTE:\n\t\tsc->mic_mute = (cp->un.ord != 0);\n\t\tym_mute(sc, SA3_MIC_VOL, sc->mic_mute);\n\t\tbreak;\n\n\tdefault:\n\t\treturn ENXIO;\n\t\t/* NOTREACHED */\n\t}\n\n\treturn (error);\n}"
  },
  {
    "function_name": "ym_set_3d",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ym.c",
    "lines": "289-306",
    "snippet": "static void\nym_set_3d(sc, cp, val, reg)\n\tstruct ym_softc *sc;\n\tmixer_ctrl_t *cp;\n\tstruct ad1848_volume *val;\n\tint reg;\n{\n\tu_int8_t e;\n\n\tad1848_to_vol(cp, val);\n\n\te = (val->left * (SA3_3D_BITS + 1) + (SA3_3D_BITS + 1) / 2) /\n\t\t(AUDIO_MAX_GAIN + 1) << SA3_3D_LSHIFT |\n\t    (val->right * (SA3_3D_BITS + 1) + (SA3_3D_BITS + 1) / 2) /\n\t\t(AUDIO_MAX_GAIN + 1) << SA3_3D_RSHIFT;\n\n\tym_write(sc, reg, e);\n}",
    "includes": [
      "#include <dev/isa/ymvar.h>",
      "#include <dev/ic/mpuvar.h>",
      "#include <dev/ic/opl3sa3reg.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/midi_if.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"midi.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ym_set_3d",
      "static __inline void ym_write"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ym_write",
          "args": [
            "sc",
            "reg",
            "e"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "ym_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ym.c",
          "lines": "194-204",
          "snippet": "static __inline void\nym_write(sc, reg, data)\n\tstruct ym_softc *sc;\n\tint     reg;\n\tint     data;\n{\n\tbus_space_write_1(sc->sc_iot, sc->sc_controlioh, SA3_CTL_INDEX,\n\t    (reg & 0xff));\n\tbus_space_write_1(sc->sc_iot, sc->sc_controlioh, SA3_CTL_DATA,\n\t    (data & 0xff));\n}",
          "includes": [
            "#include <dev/isa/ymvar.h>",
            "#include <dev/ic/mpuvar.h>",
            "#include <dev/ic/opl3sa3reg.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/midi_if.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"midi.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline void ym_write"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/ymvar.h>\n#include <dev/ic/mpuvar.h>\n#include <dev/ic/opl3sa3reg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"midi.h\"\n\nstatic __inline void ym_write;\n\nstatic __inline void\nym_write(sc, reg, data)\n\tstruct ym_softc *sc;\n\tint     reg;\n\tint     data;\n{\n\tbus_space_write_1(sc->sc_iot, sc->sc_controlioh, SA3_CTL_INDEX,\n\t    (reg & 0xff));\n\tbus_space_write_1(sc->sc_iot, sc->sc_controlioh, SA3_CTL_DATA,\n\t    (data & 0xff));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ad1848_to_vol",
          "args": [
            "cp",
            "val"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "ad1848_to_vol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848var.h",
          "lines": "145-160",
          "snippet": "static __inline int\nad1848_to_vol(cp, vol)\n\tmixer_ctrl_t *cp;\n\tstruct ad1848_volume *vol;\n{\n\tif (cp->un.value.num_channels == 1) {\n\t\tvol->left = vol->right = cp->un.value.level[AUDIO_MIXER_LEVEL_MONO];\n\t\treturn(1);\n\t}\n\telse if (cp->un.value.num_channels == 2) {\n\t\tvol->left  = cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT];\n\t\tvol->right = cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT];\n\t\treturn(1);\n\t}\n\treturn(0);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static __inline int\nad1848_to_vol(cp, vol)\n\tmixer_ctrl_t *cp;\n\tstruct ad1848_volume *vol;\n{\n\tif (cp->un.value.num_channels == 1) {\n\t\tvol->left = vol->right = cp->un.value.level[AUDIO_MIXER_LEVEL_MONO];\n\t\treturn(1);\n\t}\n\telse if (cp->un.value.num_channels == 2) {\n\t\tvol->left  = cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT];\n\t\tvol->right = cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT];\n\t\treturn(1);\n\t}\n\treturn(0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/ymvar.h>\n#include <dev/ic/mpuvar.h>\n#include <dev/ic/opl3sa3reg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"midi.h\"\n\nstatic void ym_set_3d;\nstatic __inline void ym_write;\n\nstatic void\nym_set_3d(sc, cp, val, reg)\n\tstruct ym_softc *sc;\n\tmixer_ctrl_t *cp;\n\tstruct ad1848_volume *val;\n\tint reg;\n{\n\tu_int8_t e;\n\n\tad1848_to_vol(cp, val);\n\n\te = (val->left * (SA3_3D_BITS + 1) + (SA3_3D_BITS + 1) / 2) /\n\t\t(AUDIO_MAX_GAIN + 1) << SA3_3D_LSHIFT |\n\t    (val->right * (SA3_3D_BITS + 1) + (SA3_3D_BITS + 1) / 2) /\n\t\t(AUDIO_MAX_GAIN + 1) << SA3_3D_RSHIFT;\n\n\tym_write(sc, reg, e);\n}"
  },
  {
    "function_name": "ym_set_mic_gain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ym.c",
    "lines": "273-287",
    "snippet": "static void\nym_set_mic_gain(sc, vol)\n\tstruct ym_softc *sc;\n\tint vol;\n{\n\tu_int   atten;\n\n\tsc->mic_gain = vol;\n\n\tatten = ((AUDIO_MAX_GAIN - vol) * (SA3_MIC_MCV + 1)) /\n\t    (AUDIO_MAX_GAIN + 1);\n\n\tym_write(sc, SA3_MIC_VOL,\n\t    (ym_read(sc, SA3_MIC_VOL) & ~SA3_MIC_MCV) | atten);\n}",
    "includes": [
      "#include <dev/isa/ymvar.h>",
      "#include <dev/ic/mpuvar.h>",
      "#include <dev/ic/opl3sa3reg.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/midi_if.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"midi.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ym_set_mic_gain",
      "static __inline int ym_read",
      "static __inline void ym_write"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ym_write",
          "args": [
            "sc",
            "SA3_MIC_VOL",
            "(ym_read(sc, SA3_MIC_VOL) & ~SA3_MIC_MCV) | atten"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "ym_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ym.c",
          "lines": "194-204",
          "snippet": "static __inline void\nym_write(sc, reg, data)\n\tstruct ym_softc *sc;\n\tint     reg;\n\tint     data;\n{\n\tbus_space_write_1(sc->sc_iot, sc->sc_controlioh, SA3_CTL_INDEX,\n\t    (reg & 0xff));\n\tbus_space_write_1(sc->sc_iot, sc->sc_controlioh, SA3_CTL_DATA,\n\t    (data & 0xff));\n}",
          "includes": [
            "#include <dev/isa/ymvar.h>",
            "#include <dev/ic/mpuvar.h>",
            "#include <dev/ic/opl3sa3reg.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/midi_if.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"midi.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline void ym_write"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/ymvar.h>\n#include <dev/ic/mpuvar.h>\n#include <dev/ic/opl3sa3reg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"midi.h\"\n\nstatic __inline void ym_write;\n\nstatic __inline void\nym_write(sc, reg, data)\n\tstruct ym_softc *sc;\n\tint     reg;\n\tint     data;\n{\n\tbus_space_write_1(sc->sc_iot, sc->sc_controlioh, SA3_CTL_INDEX,\n\t    (reg & 0xff));\n\tbus_space_write_1(sc->sc_iot, sc->sc_controlioh, SA3_CTL_DATA,\n\t    (data & 0xff));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ym_read",
          "args": [
            "sc",
            "SA3_MIC_VOL"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "ym_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ym.c",
          "lines": "184-192",
          "snippet": "static __inline int\nym_read(sc, reg)\n\tstruct ym_softc *sc;\n\tint     reg;\n{\n\tbus_space_write_1(sc->sc_iot, sc->sc_controlioh, SA3_CTL_INDEX,\n\t    (reg & 0xff));\n\treturn (bus_space_read_1(sc->sc_iot, sc->sc_controlioh, SA3_CTL_DATA));\n}",
          "includes": [
            "#include <dev/isa/ymvar.h>",
            "#include <dev/ic/mpuvar.h>",
            "#include <dev/ic/opl3sa3reg.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/midi_if.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"midi.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline int ym_read"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/ymvar.h>\n#include <dev/ic/mpuvar.h>\n#include <dev/ic/opl3sa3reg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"midi.h\"\n\nstatic __inline int ym_read;\n\nstatic __inline int\nym_read(sc, reg)\n\tstruct ym_softc *sc;\n\tint     reg;\n{\n\tbus_space_write_1(sc->sc_iot, sc->sc_controlioh, SA3_CTL_INDEX,\n\t    (reg & 0xff));\n\treturn (bus_space_read_1(sc->sc_iot, sc->sc_controlioh, SA3_CTL_DATA));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/ymvar.h>\n#include <dev/ic/mpuvar.h>\n#include <dev/ic/opl3sa3reg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"midi.h\"\n\nstatic void ym_set_mic_gain;\nstatic __inline int ym_read;\nstatic __inline void ym_write;\n\nstatic void\nym_set_mic_gain(sc, vol)\n\tstruct ym_softc *sc;\n\tint vol;\n{\n\tu_int   atten;\n\n\tsc->mic_gain = vol;\n\n\tatten = ((AUDIO_MAX_GAIN - vol) * (SA3_MIC_MCV + 1)) /\n\t    (AUDIO_MAX_GAIN + 1);\n\n\tym_write(sc, SA3_MIC_VOL,\n\t    (ym_read(sc, SA3_MIC_VOL) & ~SA3_MIC_MCV) | atten);\n}"
  },
  {
    "function_name": "ym_set_master_gain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ym.c",
    "lines": "253-271",
    "snippet": "static void\nym_set_master_gain(sc, vol)\n\tstruct ym_softc *sc;\n\tstruct ad1848_volume *vol;\n{\n\tu_int   atten;\n\n\tsc->master_gain = *vol;\n\n\tatten = ((AUDIO_MAX_GAIN - vol->left) * (SA3_VOL_MV + 1)) /\n\t   (AUDIO_MAX_GAIN + 1);\n\n\tym_write(sc, SA3_VOL_L, (ym_read(sc, SA3_VOL_L) & ~SA3_VOL_MV) | atten);\n\n\tatten = ((AUDIO_MAX_GAIN - vol->right) * (SA3_VOL_MV + 1)) /\n\t   (AUDIO_MAX_GAIN + 1);\n\n\tym_write(sc, SA3_VOL_R, (ym_read(sc, SA3_VOL_R) & ~SA3_VOL_MV) | atten);\n}",
    "includes": [
      "#include <dev/isa/ymvar.h>",
      "#include <dev/ic/mpuvar.h>",
      "#include <dev/ic/opl3sa3reg.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/midi_if.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"midi.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ym_set_master_gain",
      "static __inline int ym_read",
      "static __inline void ym_write"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ym_write",
          "args": [
            "sc",
            "SA3_VOL_R",
            "(ym_read(sc, SA3_VOL_R) & ~SA3_VOL_MV) | atten"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "ym_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ym.c",
          "lines": "194-204",
          "snippet": "static __inline void\nym_write(sc, reg, data)\n\tstruct ym_softc *sc;\n\tint     reg;\n\tint     data;\n{\n\tbus_space_write_1(sc->sc_iot, sc->sc_controlioh, SA3_CTL_INDEX,\n\t    (reg & 0xff));\n\tbus_space_write_1(sc->sc_iot, sc->sc_controlioh, SA3_CTL_DATA,\n\t    (data & 0xff));\n}",
          "includes": [
            "#include <dev/isa/ymvar.h>",
            "#include <dev/ic/mpuvar.h>",
            "#include <dev/ic/opl3sa3reg.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/midi_if.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"midi.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline void ym_write"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/ymvar.h>\n#include <dev/ic/mpuvar.h>\n#include <dev/ic/opl3sa3reg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"midi.h\"\n\nstatic __inline void ym_write;\n\nstatic __inline void\nym_write(sc, reg, data)\n\tstruct ym_softc *sc;\n\tint     reg;\n\tint     data;\n{\n\tbus_space_write_1(sc->sc_iot, sc->sc_controlioh, SA3_CTL_INDEX,\n\t    (reg & 0xff));\n\tbus_space_write_1(sc->sc_iot, sc->sc_controlioh, SA3_CTL_DATA,\n\t    (data & 0xff));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ym_read",
          "args": [
            "sc",
            "SA3_VOL_R"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "ym_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ym.c",
          "lines": "184-192",
          "snippet": "static __inline int\nym_read(sc, reg)\n\tstruct ym_softc *sc;\n\tint     reg;\n{\n\tbus_space_write_1(sc->sc_iot, sc->sc_controlioh, SA3_CTL_INDEX,\n\t    (reg & 0xff));\n\treturn (bus_space_read_1(sc->sc_iot, sc->sc_controlioh, SA3_CTL_DATA));\n}",
          "includes": [
            "#include <dev/isa/ymvar.h>",
            "#include <dev/ic/mpuvar.h>",
            "#include <dev/ic/opl3sa3reg.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/midi_if.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"midi.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline int ym_read"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/ymvar.h>\n#include <dev/ic/mpuvar.h>\n#include <dev/ic/opl3sa3reg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"midi.h\"\n\nstatic __inline int ym_read;\n\nstatic __inline int\nym_read(sc, reg)\n\tstruct ym_softc *sc;\n\tint     reg;\n{\n\tbus_space_write_1(sc->sc_iot, sc->sc_controlioh, SA3_CTL_INDEX,\n\t    (reg & 0xff));\n\treturn (bus_space_read_1(sc->sc_iot, sc->sc_controlioh, SA3_CTL_DATA));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/ymvar.h>\n#include <dev/ic/mpuvar.h>\n#include <dev/ic/opl3sa3reg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"midi.h\"\n\nstatic void ym_set_master_gain;\nstatic __inline int ym_read;\nstatic __inline void ym_write;\n\nstatic void\nym_set_master_gain(sc, vol)\n\tstruct ym_softc *sc;\n\tstruct ad1848_volume *vol;\n{\n\tu_int   atten;\n\n\tsc->master_gain = *vol;\n\n\tatten = ((AUDIO_MAX_GAIN - vol->left) * (SA3_VOL_MV + 1)) /\n\t   (AUDIO_MAX_GAIN + 1);\n\n\tym_write(sc, SA3_VOL_L, (ym_read(sc, SA3_VOL_L) & ~SA3_VOL_MV) | atten);\n\n\tatten = ((AUDIO_MAX_GAIN - vol->right) * (SA3_VOL_MV + 1)) /\n\t   (AUDIO_MAX_GAIN + 1);\n\n\tym_write(sc, SA3_VOL_R, (ym_read(sc, SA3_VOL_R) & ~SA3_VOL_MV) | atten);\n}"
  },
  {
    "function_name": "ym_mute",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ym.c",
    "lines": "238-251",
    "snippet": "static void\nym_mute(sc, left_reg, mute)\n\tstruct ym_softc *sc;\n\tint     left_reg;\n\tint     mute;\n{\n\tu_int8_t reg;\n\n\treg = ym_read(sc, left_reg);\n\tif (mute)\n\t\tym_write(sc, left_reg, reg | 0x80);\n\telse\n\t\tym_write(sc, left_reg, reg & ~0x80);\n}",
    "includes": [
      "#include <dev/isa/ymvar.h>",
      "#include <dev/ic/mpuvar.h>",
      "#include <dev/ic/opl3sa3reg.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/midi_if.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"midi.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ym_mute",
      "static __inline int ym_read",
      "static __inline void ym_write"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ym_write",
          "args": [
            "sc",
            "left_reg",
            "reg & ~0x80"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "ym_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ym.c",
          "lines": "194-204",
          "snippet": "static __inline void\nym_write(sc, reg, data)\n\tstruct ym_softc *sc;\n\tint     reg;\n\tint     data;\n{\n\tbus_space_write_1(sc->sc_iot, sc->sc_controlioh, SA3_CTL_INDEX,\n\t    (reg & 0xff));\n\tbus_space_write_1(sc->sc_iot, sc->sc_controlioh, SA3_CTL_DATA,\n\t    (data & 0xff));\n}",
          "includes": [
            "#include <dev/isa/ymvar.h>",
            "#include <dev/ic/mpuvar.h>",
            "#include <dev/ic/opl3sa3reg.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/midi_if.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"midi.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline void ym_write"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/ymvar.h>\n#include <dev/ic/mpuvar.h>\n#include <dev/ic/opl3sa3reg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"midi.h\"\n\nstatic __inline void ym_write;\n\nstatic __inline void\nym_write(sc, reg, data)\n\tstruct ym_softc *sc;\n\tint     reg;\n\tint     data;\n{\n\tbus_space_write_1(sc->sc_iot, sc->sc_controlioh, SA3_CTL_INDEX,\n\t    (reg & 0xff));\n\tbus_space_write_1(sc->sc_iot, sc->sc_controlioh, SA3_CTL_DATA,\n\t    (data & 0xff));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ym_read",
          "args": [
            "sc",
            "left_reg"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "ym_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ym.c",
          "lines": "184-192",
          "snippet": "static __inline int\nym_read(sc, reg)\n\tstruct ym_softc *sc;\n\tint     reg;\n{\n\tbus_space_write_1(sc->sc_iot, sc->sc_controlioh, SA3_CTL_INDEX,\n\t    (reg & 0xff));\n\treturn (bus_space_read_1(sc->sc_iot, sc->sc_controlioh, SA3_CTL_DATA));\n}",
          "includes": [
            "#include <dev/isa/ymvar.h>",
            "#include <dev/ic/mpuvar.h>",
            "#include <dev/ic/opl3sa3reg.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/midi_if.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"midi.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline int ym_read"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/ymvar.h>\n#include <dev/ic/mpuvar.h>\n#include <dev/ic/opl3sa3reg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"midi.h\"\n\nstatic __inline int ym_read;\n\nstatic __inline int\nym_read(sc, reg)\n\tstruct ym_softc *sc;\n\tint     reg;\n{\n\tbus_space_write_1(sc->sc_iot, sc->sc_controlioh, SA3_CTL_INDEX,\n\t    (reg & 0xff));\n\treturn (bus_space_read_1(sc->sc_iot, sc->sc_controlioh, SA3_CTL_DATA));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/ymvar.h>\n#include <dev/ic/mpuvar.h>\n#include <dev/ic/opl3sa3reg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"midi.h\"\n\nstatic void ym_mute;\nstatic __inline int ym_read;\nstatic __inline void ym_write;\n\nstatic void\nym_mute(sc, left_reg, mute)\n\tstruct ym_softc *sc;\n\tint     left_reg;\n\tint     mute;\n{\n\tu_int8_t reg;\n\n\treg = ym_read(sc, left_reg);\n\tif (mute)\n\t\tym_write(sc, left_reg, reg | 0x80);\n\telse\n\t\tym_write(sc, left_reg, reg & ~0x80);\n}"
  },
  {
    "function_name": "ym_getdev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ym.c",
    "lines": "208-215",
    "snippet": "int\nym_getdev(addr, retp)\n\tvoid   *addr;\n\tstruct audio_device *retp;\n{\n\t*retp = ym_device;\n\treturn 0;\n}",
    "includes": [
      "#include <dev/isa/ymvar.h>",
      "#include <dev/ic/mpuvar.h>",
      "#include <dev/ic/opl3sa3reg.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/midi_if.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"midi.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int ym_getdev",
      "struct audio_device ym_device = {\n\t\"ym,ad1848\",\n\t\"\",\n\t\"ym\"\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/isa/ymvar.h>\n#include <dev/ic/mpuvar.h>\n#include <dev/ic/opl3sa3reg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"midi.h\"\n\nint ym_getdev;\nstruct audio_device ym_device = {\n\t\"ym,ad1848\",\n\t\"\",\n\t\"ym\"\n};\n\nint\nym_getdev(addr, retp)\n\tvoid   *addr;\n\tstruct audio_device *retp;\n{\n\t*retp = ym_device;\n\treturn 0;\n}"
  },
  {
    "function_name": "ym_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ym.c",
    "lines": "194-204",
    "snippet": "static __inline void\nym_write(sc, reg, data)\n\tstruct ym_softc *sc;\n\tint     reg;\n\tint     data;\n{\n\tbus_space_write_1(sc->sc_iot, sc->sc_controlioh, SA3_CTL_INDEX,\n\t    (reg & 0xff));\n\tbus_space_write_1(sc->sc_iot, sc->sc_controlioh, SA3_CTL_DATA,\n\t    (data & 0xff));\n}",
    "includes": [
      "#include <dev/isa/ymvar.h>",
      "#include <dev/ic/mpuvar.h>",
      "#include <dev/ic/opl3sa3reg.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/midi_if.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"midi.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __inline void ym_write"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->sc_iot",
            "sc->sc_controlioh",
            "SA3_CTL_DATA",
            "(data & 0xff)"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->sc_iot",
            "sc->sc_controlioh",
            "SA3_CTL_INDEX",
            "(reg & 0xff)"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/ymvar.h>\n#include <dev/ic/mpuvar.h>\n#include <dev/ic/opl3sa3reg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"midi.h\"\n\nstatic __inline void ym_write;\n\nstatic __inline void\nym_write(sc, reg, data)\n\tstruct ym_softc *sc;\n\tint     reg;\n\tint     data;\n{\n\tbus_space_write_1(sc->sc_iot, sc->sc_controlioh, SA3_CTL_INDEX,\n\t    (reg & 0xff));\n\tbus_space_write_1(sc->sc_iot, sc->sc_controlioh, SA3_CTL_DATA,\n\t    (data & 0xff));\n}"
  },
  {
    "function_name": "ym_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ym.c",
    "lines": "184-192",
    "snippet": "static __inline int\nym_read(sc, reg)\n\tstruct ym_softc *sc;\n\tint     reg;\n{\n\tbus_space_write_1(sc->sc_iot, sc->sc_controlioh, SA3_CTL_INDEX,\n\t    (reg & 0xff));\n\treturn (bus_space_read_1(sc->sc_iot, sc->sc_controlioh, SA3_CTL_DATA));\n}",
    "includes": [
      "#include <dev/isa/ymvar.h>",
      "#include <dev/ic/mpuvar.h>",
      "#include <dev/ic/opl3sa3reg.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/midi_if.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"midi.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __inline int ym_read"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "sc->sc_iot",
            "sc->sc_controlioh",
            "SA3_CTL_DATA"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->sc_iot",
            "sc->sc_controlioh",
            "SA3_CTL_INDEX",
            "(reg & 0xff)"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/ymvar.h>\n#include <dev/ic/mpuvar.h>\n#include <dev/ic/opl3sa3reg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"midi.h\"\n\nstatic __inline int ym_read;\n\nstatic __inline int\nym_read(sc, reg)\n\tstruct ym_softc *sc;\n\tint     reg;\n{\n\tbus_space_write_1(sc->sc_iot, sc->sc_controlioh, SA3_CTL_INDEX,\n\t    (reg & 0xff));\n\treturn (bus_space_read_1(sc->sc_iot, sc->sc_controlioh, SA3_CTL_DATA));\n}"
  },
  {
    "function_name": "ym_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ym.c",
    "lines": "142-182",
    "snippet": "void\nym_attach(sc)\n\tstruct ym_softc *sc;\n\n{\n\tstruct ad1848_volume vol_mid = {220, 220};\n#if NMIDI > 0\n\tstruct midi_hw_if *mhw = &ym_mpu401_hw_if;\n#endif\n\n\tsc->sc_ih = isa_intr_establish(sc->sc_ic, sc->ym_irq, IST_EDGE,\n\t    IPL_AUDIO, ym_intr, &sc->sc_ad1848, sc->sc_dev.dv_xname);\n\n\tad1848_attach(&sc->sc_ad1848);\n\tprintf(\"\\n\");\n\tsc->sc_ad1848.parent = sc;\n\n\t/* Establish chip in well known mode */\n\tym_set_master_gain(sc, &vol_mid);\n\tym_set_mic_gain(sc, 0);\n\tsc->master_mute = 0;\n\tym_mute(sc, SA3_VOL_L, sc->master_mute);\n\tym_mute(sc, SA3_VOL_R, sc->master_mute);\n\n\tsc->mic_mute = 1;\n\tym_mute(sc, SA3_MIC_VOL, sc->mic_mute);\n\n#if NMIDI > 0\n\tsc->sc_hasmpu = 0;\n\tif (sc->sc_mpu_sc.iobase) {\n\t\tsc->sc_mpu_sc.iot = sc->sc_iot;\n\t\tif (mpu_find(&sc->sc_mpu_sc)) {\n\t\t\tsc->sc_hasmpu = 1;\n\t\t\tmhw = &ym_mpu401_hw_if;\n\t\t}\n\t}\n\tmidi_attach_mi(mhw, sc, &sc->sc_dev);\n#endif\n\n\taudio_attach_mi(&ym_hw_if, &sc->sc_ad1848, &sc->sc_dev);\n}",
    "includes": [
      "#include <dev/isa/ymvar.h>",
      "#include <dev/ic/mpuvar.h>",
      "#include <dev/ic/opl3sa3reg.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/midi_if.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"midi.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int ym_intr",
      "static void ym_mute",
      "static void ym_set_master_gain",
      "static void ym_set_mic_gain",
      "struct audio_hw_if ym_hw_if = {\n\tad1848_open,\n\tad1848_close,\n\tNULL,\n\tad1848_query_encoding,\n\tad1848_set_params,\n\tad1848_round_blocksize,\n\tad1848_commit_settings,\n\tad1848_dma_init_output,\n\tad1848_dma_init_input,\n\tad1848_dma_output,\n\tad1848_dma_input,\n\tad1848_halt_out_dma,\n\tad1848_halt_in_dma,\n\tNULL,\n\tym_getdev,\n\tNULL,\n\tym_mixer_set_port,\n\tym_mixer_get_port,\n\tym_query_devinfo,\n\tad1848_malloc,\n\tad1848_free,\n\tad1848_round,\n\tad1848_mappage,\n\tad1848_get_props,\n\tNULL,\n\tNULL\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audio_attach_mi",
          "args": [
            "&ym_hw_if",
            "&sc->sc_ad1848",
            "&sc->sc_dev"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "audio_attach_mi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "394-408",
          "snippet": "void\naudio_attach_mi(ahwp, hdlp, dev)\n\tstruct audio_hw_if *ahwp;\n\tvoid *hdlp;\n\tstruct device *dev;\n{\n\tstruct audio_attach_args arg;\n\n\tif (ahwp != NULL) {\n\t\targ.type = AUDIODEV_TYPE_AUDIO;\n\t\targ.hwif = ahwp;\n\t\targ.hdl = hdlp;\n\t\t(void)config_found(dev, &arg, audioprint);\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nvoid\naudio_attach_mi(ahwp, hdlp, dev)\n\tstruct audio_hw_if *ahwp;\n\tvoid *hdlp;\n\tstruct device *dev;\n{\n\tstruct audio_attach_args arg;\n\n\tif (ahwp != NULL) {\n\t\targ.type = AUDIODEV_TYPE_AUDIO;\n\t\targ.hwif = ahwp;\n\t\targ.hdl = hdlp;\n\t\t(void)config_found(dev, &arg, audioprint);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "midi_attach_mi",
          "args": [
            "mhw",
            "sc",
            "&sc->sc_dev"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "midi_attach_mi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/midi.c",
          "lines": "749-767",
          "snippet": "void\nmidi_attach_mi(mhwp, hdlp, dev)\n\tstruct midi_hw_if *mhwp;\n\tvoid *hdlp;\n\tstruct device *dev;\n{\n\tstruct audio_attach_args arg;\n\n#ifdef DIAGNOSTIC\n\tif (mhwp == NULL) {\n\t\tprintf(\"midi_attach_mi: NULL\\n\");\n\t\treturn;\n\t}\n#endif\n\targ.type = AUDIODEV_TYPE_MIDI;\n\targ.hwif = mhwp;\n\targ.hdl = hdlp;\n\t(void)config_found(dev, &arg, midiprint);\n}",
          "includes": [
            "#include <dev/midivar.h>",
            "#include <dev/midi_if.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/midiio.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"sequencer.h\"",
            "#include \"midi.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n#include \"midi.h\"\n\nvoid\nmidi_attach_mi(mhwp, hdlp, dev)\n\tstruct midi_hw_if *mhwp;\n\tvoid *hdlp;\n\tstruct device *dev;\n{\n\tstruct audio_attach_args arg;\n\n#ifdef DIAGNOSTIC\n\tif (mhwp == NULL) {\n\t\tprintf(\"midi_attach_mi: NULL\\n\");\n\t\treturn;\n\t}\n#endif\n\targ.type = AUDIODEV_TYPE_MIDI;\n\targ.hwif = mhwp;\n\targ.hdl = hdlp;\n\t(void)config_found(dev, &arg, midiprint);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mpu_find",
          "args": [
            "&sc->sc_mpu_sc"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "mpu_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mpu401.c",
          "lines": "100-116",
          "snippet": "int\nmpu_find(v)\n\tvoid *v;\n{\n\tstruct mpu_softc *sc = v;\n\n\tif (MPU_GETSTATUS(sc->iot, sc->ioh) == 0xff) {\n\t\tDPRINTF((\"mpu_find: No status\\n\"));\n\t\tgoto bad;\n\t}\n\tsc->open = 0;\n\tsc->intr = 0;\n\tif (mpu_reset(sc) == 0)\n\t\treturn 1;\nbad:\n\treturn 0;\n}",
          "includes": [
            "#include <dev/ic/mpuvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/midi_if.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tmpu_reset(struct mpu_softc *);",
            "static\t__inline int mpu_waitready(struct mpu_softc *);",
            "void\tmpu_readinput(struct mpu_softc *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/mpuvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/midi_if.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tmpu_reset(struct mpu_softc *);\nstatic\t__inline int mpu_waitready(struct mpu_softc *);\nvoid\tmpu_readinput(struct mpu_softc *);\n\nint\nmpu_find(v)\n\tvoid *v;\n{\n\tstruct mpu_softc *sc = v;\n\n\tif (MPU_GETSTATUS(sc->iot, sc->ioh) == 0xff) {\n\t\tDPRINTF((\"mpu_find: No status\\n\"));\n\t\tgoto bad;\n\t}\n\tsc->open = 0;\n\tsc->intr = 0;\n\tif (mpu_reset(sc) == 0)\n\t\treturn 1;\nbad:\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ym_mute",
          "args": [
            "sc",
            "SA3_MIC_VOL",
            "sc->mic_mute"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "ym_mute",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ym.c",
          "lines": "238-251",
          "snippet": "static void\nym_mute(sc, left_reg, mute)\n\tstruct ym_softc *sc;\n\tint     left_reg;\n\tint     mute;\n{\n\tu_int8_t reg;\n\n\treg = ym_read(sc, left_reg);\n\tif (mute)\n\t\tym_write(sc, left_reg, reg | 0x80);\n\telse\n\t\tym_write(sc, left_reg, reg & ~0x80);\n}",
          "includes": [
            "#include <dev/isa/ymvar.h>",
            "#include <dev/ic/mpuvar.h>",
            "#include <dev/ic/opl3sa3reg.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/midi_if.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"midi.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ym_mute",
            "static __inline int ym_read",
            "static __inline void ym_write"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/ymvar.h>\n#include <dev/ic/mpuvar.h>\n#include <dev/ic/opl3sa3reg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"midi.h\"\n\nstatic void ym_mute;\nstatic __inline int ym_read;\nstatic __inline void ym_write;\n\nstatic void\nym_mute(sc, left_reg, mute)\n\tstruct ym_softc *sc;\n\tint     left_reg;\n\tint     mute;\n{\n\tu_int8_t reg;\n\n\treg = ym_read(sc, left_reg);\n\tif (mute)\n\t\tym_write(sc, left_reg, reg | 0x80);\n\telse\n\t\tym_write(sc, left_reg, reg & ~0x80);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ym_set_mic_gain",
          "args": [
            "sc",
            "0"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "ym_set_mic_gain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ym.c",
          "lines": "273-287",
          "snippet": "static void\nym_set_mic_gain(sc, vol)\n\tstruct ym_softc *sc;\n\tint vol;\n{\n\tu_int   atten;\n\n\tsc->mic_gain = vol;\n\n\tatten = ((AUDIO_MAX_GAIN - vol) * (SA3_MIC_MCV + 1)) /\n\t    (AUDIO_MAX_GAIN + 1);\n\n\tym_write(sc, SA3_MIC_VOL,\n\t    (ym_read(sc, SA3_MIC_VOL) & ~SA3_MIC_MCV) | atten);\n}",
          "includes": [
            "#include <dev/isa/ymvar.h>",
            "#include <dev/ic/mpuvar.h>",
            "#include <dev/ic/opl3sa3reg.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/midi_if.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"midi.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ym_set_mic_gain",
            "static __inline int ym_read",
            "static __inline void ym_write"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/ymvar.h>\n#include <dev/ic/mpuvar.h>\n#include <dev/ic/opl3sa3reg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"midi.h\"\n\nstatic void ym_set_mic_gain;\nstatic __inline int ym_read;\nstatic __inline void ym_write;\n\nstatic void\nym_set_mic_gain(sc, vol)\n\tstruct ym_softc *sc;\n\tint vol;\n{\n\tu_int   atten;\n\n\tsc->mic_gain = vol;\n\n\tatten = ((AUDIO_MAX_GAIN - vol) * (SA3_MIC_MCV + 1)) /\n\t    (AUDIO_MAX_GAIN + 1);\n\n\tym_write(sc, SA3_MIC_VOL,\n\t    (ym_read(sc, SA3_MIC_VOL) & ~SA3_MIC_MCV) | atten);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ym_set_master_gain",
          "args": [
            "sc",
            "&vol_mid"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "ym_set_master_gain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ym.c",
          "lines": "253-271",
          "snippet": "static void\nym_set_master_gain(sc, vol)\n\tstruct ym_softc *sc;\n\tstruct ad1848_volume *vol;\n{\n\tu_int   atten;\n\n\tsc->master_gain = *vol;\n\n\tatten = ((AUDIO_MAX_GAIN - vol->left) * (SA3_VOL_MV + 1)) /\n\t   (AUDIO_MAX_GAIN + 1);\n\n\tym_write(sc, SA3_VOL_L, (ym_read(sc, SA3_VOL_L) & ~SA3_VOL_MV) | atten);\n\n\tatten = ((AUDIO_MAX_GAIN - vol->right) * (SA3_VOL_MV + 1)) /\n\t   (AUDIO_MAX_GAIN + 1);\n\n\tym_write(sc, SA3_VOL_R, (ym_read(sc, SA3_VOL_R) & ~SA3_VOL_MV) | atten);\n}",
          "includes": [
            "#include <dev/isa/ymvar.h>",
            "#include <dev/ic/mpuvar.h>",
            "#include <dev/ic/opl3sa3reg.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/midi_if.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"midi.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ym_set_master_gain",
            "static __inline int ym_read",
            "static __inline void ym_write"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/ymvar.h>\n#include <dev/ic/mpuvar.h>\n#include <dev/ic/opl3sa3reg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"midi.h\"\n\nstatic void ym_set_master_gain;\nstatic __inline int ym_read;\nstatic __inline void ym_write;\n\nstatic void\nym_set_master_gain(sc, vol)\n\tstruct ym_softc *sc;\n\tstruct ad1848_volume *vol;\n{\n\tu_int   atten;\n\n\tsc->master_gain = *vol;\n\n\tatten = ((AUDIO_MAX_GAIN - vol->left) * (SA3_VOL_MV + 1)) /\n\t   (AUDIO_MAX_GAIN + 1);\n\n\tym_write(sc, SA3_VOL_L, (ym_read(sc, SA3_VOL_L) & ~SA3_VOL_MV) | atten);\n\n\tatten = ((AUDIO_MAX_GAIN - vol->right) * (SA3_VOL_MV + 1)) /\n\t   (AUDIO_MAX_GAIN + 1);\n\n\tym_write(sc, SA3_VOL_R, (ym_read(sc, SA3_VOL_R) & ~SA3_VOL_MV) | atten);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ad1848_attach",
          "args": [
            "&sc->sc_ad1848"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "ad1848_attach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "502-577",
          "snippet": "void\nad1848_attach(sc)\n    struct ad1848_softc *sc;\n{\n    int i;\n    struct ad1848_volume vol_mid = {220, 220};\n    struct ad1848_volume vol_0   = {0, 0};\n    struct audio_params pparams, rparams;\n    int timeout;\n    \n    sc->sc_locked = 0;\n    sc->sc_playrun = NOTRUNNING;\n    sc->sc_recrun = NOTRUNNING;\n\n    if (sc->sc_drq != -1) {\n\tif (isa_dmamap_create(sc->sc_isa, sc->sc_drq, MAX_ISADMA,\n\t    BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW)) {\n\t\tprintf(\"ad1848_attach: can't create map for drq %d\\n\",\n\t\t    sc->sc_drq);\n\t\treturn;\n\t}\n    }\n    if (sc->sc_recdrq != -1 && sc->sc_recdrq != sc->sc_drq) {\n\tif (isa_dmamap_create(sc->sc_isa, sc->sc_recdrq, MAX_ISADMA,\n\t    BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW)) {\n\t\tprintf(\"ad1848_attach: can't creape map for drq %d\\n\",\n\t\t    sc->sc_recdrq);\n\t\treturn;\n\t}\n    }\n\n    /* Initialize the ad1848... */\n    for (i = 0; i < 0x10; i++) {\n\tad_write(sc, i, ad1848_init_values[i]);\n        timeout = 100000;\n        while (timeout > 0 && ad_read(sc, AD1848_IADDR) & SP_IN_INIT)\n\t    timeout--;\n    }\n    /* ...and additional CS4231 stuff too */\n    if (sc->mode == 2) {\n\t    ad_write(sc, SP_INTERFACE_CONFIG, 0); /* disable SINGLE_DMA */\n\t    for (i = 0x10; i < 0x20; i++)\n\t\t    if (ad1848_init_values[i] != 0) {\n\t\t\t    ad_write(sc, i, ad1848_init_values[i]);\n\t\t\t    timeout = 100000;\n    \t\t\t    while (timeout > 0 && \n\t\t\t\t   ad_read(sc, AD1848_IADDR) & SP_IN_INIT)\n\t\t\t\ttimeout--;\n\t\t    }\n    }\n    ad1848_reset(sc);\n\n    pparams = audio_default;\n    rparams = audio_default;\n    (void) ad1848_set_params(sc, AUMODE_RECORD|AUMODE_PLAY, 0, &pparams, &rparams);\n\n    /* Set default gains */\n    (void) ad1848_set_rec_gain(sc, &vol_mid);\n    (void) ad1848_set_channel_gain(sc, AD1848_DAC_CHANNEL, &vol_mid);\n    (void) ad1848_set_channel_gain(sc, AD1848_MONITOR_CHANNEL, &vol_0);\n    (void) ad1848_set_channel_gain(sc, AD1848_AUX1_CHANNEL, &vol_mid);\t/* CD volume */\n    if (sc->mode == 2) {\n\t(void) ad1848_set_channel_gain(sc, AD1848_AUX2_CHANNEL, &vol_mid); /* CD volume */\n\t(void) ad1848_set_channel_gain(sc, AD1848_LINE_CHANNEL, &vol_mid);\n\t(void) ad1848_set_channel_gain(sc, AD1848_MONO_CHANNEL, &vol_0);\n\tsc->mute[AD1848_MONO_CHANNEL] = MUTE_ALL;\n    } else\n\t(void) ad1848_set_channel_gain(sc, AD1848_AUX2_CHANNEL, &vol_0);\n\n    /* Set default port */\n    (void) ad1848_set_rec_port(sc, MIC_IN_PORT);\n\n    if (sc->chip_name)\n\tprintf(\": %s\", sc->chip_name);\n#undef WAITREADY\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ad1848_init_values[] = {\n\t\t\t/* Left Input Control */\n    GAIN_12|INPUT_MIC_GAIN_ENABLE,\n\t\t\t/* Right Input Control */\n    GAIN_12|INPUT_MIC_GAIN_ENABLE,\n    ATTEN_12,\t\t/* Left Aux #1 Input Control */\n    ATTEN_12,\t\t/* Right Aux #1 Input Control */\n    ATTEN_12,\t\t/* Left Aux #2 Input Control */\n    ATTEN_12,\t\t/* Right Aux #2 Input Control */\n    /* bits 5-0 are attenuation select */\n    ATTEN_12,\t\t/* Left DAC output Control */\n    ATTEN_12,\t\t/* Right DAC output Control */\n\t\t\t/* Clock and Data Format */\n    CLOCK_XTAL1|FMT_PCM8,\n\t\t\t/* Interface Config */\n    SINGLE_DMA|AUTO_CAL_ENABLE,\n    INTERRUPT_ENABLE,\t/* Pin control */\n    0x00,\t\t/* Test and Init */\n    MODE2,\t\t/* Misc control */\n    ATTEN_0<<2,\t\t/* Digital Mix Control */\n    0,\t\t\t/* Upper base Count */\n    0,\t\t\t/* Lower base Count */\n\n    /* These are for CS4231 &c. only (additional registers): */\n    0,\t\t\t/* Alt feature 1 */\n    0,\t\t\t/* Alt feature 2 */\n    ATTEN_12,\t\t/* Left line in */\n    ATTEN_12,\t\t/* Right line in */\n    0,\t\t\t/* Timer low */\n    0,\t\t\t/* Timer high */\n    0,\t\t\t/* unused */\n    0,\t\t\t/* unused */\n    0,\t\t\t/* IRQ status */\n    0,\t\t\t/* unused */\n\t\t\t/* Mono input (a.k.a speaker) (mic) Control */\n    MONO_INPUT_MUTE|ATTEN_6,\t\t/* mute speaker by default */\n    0,\t\t\t/* unused */\n    0,\t\t\t/* record format */\n    0,\t\t\t/* Crystal Clock Select */\n    0,\t\t\t/* upper record count */\n    0\t\t\t/* lower record count */\n};",
            "void\tad1848_reset",
            "static int ad_read",
            "static void ad_write",
            "static ad1848_devmap_t *\nad1848_mixer_find_dev(map, cnt, cp)\n  ad1848_devmap_t *map;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int ad1848_init_values[] = {\n\t\t\t/* Left Input Control */\n    GAIN_12|INPUT_MIC_GAIN_ENABLE,\n\t\t\t/* Right Input Control */\n    GAIN_12|INPUT_MIC_GAIN_ENABLE,\n    ATTEN_12,\t\t/* Left Aux #1 Input Control */\n    ATTEN_12,\t\t/* Right Aux #1 Input Control */\n    ATTEN_12,\t\t/* Left Aux #2 Input Control */\n    ATTEN_12,\t\t/* Right Aux #2 Input Control */\n    /* bits 5-0 are attenuation select */\n    ATTEN_12,\t\t/* Left DAC output Control */\n    ATTEN_12,\t\t/* Right DAC output Control */\n\t\t\t/* Clock and Data Format */\n    CLOCK_XTAL1|FMT_PCM8,\n\t\t\t/* Interface Config */\n    SINGLE_DMA|AUTO_CAL_ENABLE,\n    INTERRUPT_ENABLE,\t/* Pin control */\n    0x00,\t\t/* Test and Init */\n    MODE2,\t\t/* Misc control */\n    ATTEN_0<<2,\t\t/* Digital Mix Control */\n    0,\t\t\t/* Upper base Count */\n    0,\t\t\t/* Lower base Count */\n\n    /* These are for CS4231 &c. only (additional registers): */\n    0,\t\t\t/* Alt feature 1 */\n    0,\t\t\t/* Alt feature 2 */\n    ATTEN_12,\t\t/* Left line in */\n    ATTEN_12,\t\t/* Right line in */\n    0,\t\t\t/* Timer low */\n    0,\t\t\t/* Timer high */\n    0,\t\t\t/* unused */\n    0,\t\t\t/* unused */\n    0,\t\t\t/* IRQ status */\n    0,\t\t\t/* unused */\n\t\t\t/* Mono input (a.k.a speaker) (mic) Control */\n    MONO_INPUT_MUTE|ATTEN_6,\t\t/* mute speaker by default */\n    0,\t\t\t/* unused */\n    0,\t\t\t/* record format */\n    0,\t\t\t/* Crystal Clock Select */\n    0,\t\t\t/* upper record count */\n    0\t\t\t/* lower record count */\n};\nvoid\tad1848_reset;\nstatic int ad_read;\nstatic void ad_write;\nstatic ad1848_devmap_t *\nad1848_mixer_find_dev(map, cnt, cp)\n  ad1848_devmap_t *map;\n\nvoid\nad1848_attach(sc)\n    struct ad1848_softc *sc;\n{\n    int i;\n    struct ad1848_volume vol_mid = {220, 220};\n    struct ad1848_volume vol_0   = {0, 0};\n    struct audio_params pparams, rparams;\n    int timeout;\n    \n    sc->sc_locked = 0;\n    sc->sc_playrun = NOTRUNNING;\n    sc->sc_recrun = NOTRUNNING;\n\n    if (sc->sc_drq != -1) {\n\tif (isa_dmamap_create(sc->sc_isa, sc->sc_drq, MAX_ISADMA,\n\t    BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW)) {\n\t\tprintf(\"ad1848_attach: can't create map for drq %d\\n\",\n\t\t    sc->sc_drq);\n\t\treturn;\n\t}\n    }\n    if (sc->sc_recdrq != -1 && sc->sc_recdrq != sc->sc_drq) {\n\tif (isa_dmamap_create(sc->sc_isa, sc->sc_recdrq, MAX_ISADMA,\n\t    BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW)) {\n\t\tprintf(\"ad1848_attach: can't creape map for drq %d\\n\",\n\t\t    sc->sc_recdrq);\n\t\treturn;\n\t}\n    }\n\n    /* Initialize the ad1848... */\n    for (i = 0; i < 0x10; i++) {\n\tad_write(sc, i, ad1848_init_values[i]);\n        timeout = 100000;\n        while (timeout > 0 && ad_read(sc, AD1848_IADDR) & SP_IN_INIT)\n\t    timeout--;\n    }\n    /* ...and additional CS4231 stuff too */\n    if (sc->mode == 2) {\n\t    ad_write(sc, SP_INTERFACE_CONFIG, 0); /* disable SINGLE_DMA */\n\t    for (i = 0x10; i < 0x20; i++)\n\t\t    if (ad1848_init_values[i] != 0) {\n\t\t\t    ad_write(sc, i, ad1848_init_values[i]);\n\t\t\t    timeout = 100000;\n    \t\t\t    while (timeout > 0 && \n\t\t\t\t   ad_read(sc, AD1848_IADDR) & SP_IN_INIT)\n\t\t\t\ttimeout--;\n\t\t    }\n    }\n    ad1848_reset(sc);\n\n    pparams = audio_default;\n    rparams = audio_default;\n    (void) ad1848_set_params(sc, AUMODE_RECORD|AUMODE_PLAY, 0, &pparams, &rparams);\n\n    /* Set default gains */\n    (void) ad1848_set_rec_gain(sc, &vol_mid);\n    (void) ad1848_set_channel_gain(sc, AD1848_DAC_CHANNEL, &vol_mid);\n    (void) ad1848_set_channel_gain(sc, AD1848_MONITOR_CHANNEL, &vol_0);\n    (void) ad1848_set_channel_gain(sc, AD1848_AUX1_CHANNEL, &vol_mid);\t/* CD volume */\n    if (sc->mode == 2) {\n\t(void) ad1848_set_channel_gain(sc, AD1848_AUX2_CHANNEL, &vol_mid); /* CD volume */\n\t(void) ad1848_set_channel_gain(sc, AD1848_LINE_CHANNEL, &vol_mid);\n\t(void) ad1848_set_channel_gain(sc, AD1848_MONO_CHANNEL, &vol_0);\n\tsc->mute[AD1848_MONO_CHANNEL] = MUTE_ALL;\n    } else\n\t(void) ad1848_set_channel_gain(sc, AD1848_AUX2_CHANNEL, &vol_0);\n\n    /* Set default port */\n    (void) ad1848_set_rec_port(sc, MIC_IN_PORT);\n\n    if (sc->chip_name)\n\tprintf(\": %s\", sc->chip_name);\n#undef WAITREADY\n}"
        }
      },
      {
        "call_info": {
          "callee": "isa_intr_establish",
          "args": [
            "sc->sc_ic",
            "sc->ym_irq",
            "IST_EDGE",
            "IPL_AUDIO",
            "ym_intr",
            "&sc->sc_ad1848",
            "sc->sc_dev.dv_xname"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/ymvar.h>\n#include <dev/ic/mpuvar.h>\n#include <dev/ic/opl3sa3reg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"midi.h\"\n\nint ym_intr;\nstatic void ym_mute;\nstatic void ym_set_master_gain;\nstatic void ym_set_mic_gain;\nstruct audio_hw_if ym_hw_if = {\n\tad1848_open,\n\tad1848_close,\n\tNULL,\n\tad1848_query_encoding,\n\tad1848_set_params,\n\tad1848_round_blocksize,\n\tad1848_commit_settings,\n\tad1848_dma_init_output,\n\tad1848_dma_init_input,\n\tad1848_dma_output,\n\tad1848_dma_input,\n\tad1848_halt_out_dma,\n\tad1848_halt_in_dma,\n\tNULL,\n\tym_getdev,\n\tNULL,\n\tym_mixer_set_port,\n\tym_mixer_get_port,\n\tym_query_devinfo,\n\tad1848_malloc,\n\tad1848_free,\n\tad1848_round,\n\tad1848_mappage,\n\tad1848_get_props,\n\tNULL,\n\tNULL\n};\n\nvoid\nym_attach(sc)\n\tstruct ym_softc *sc;\n\n{\n\tstruct ad1848_volume vol_mid = {220, 220};\n#if NMIDI > 0\n\tstruct midi_hw_if *mhw = &ym_mpu401_hw_if;\n#endif\n\n\tsc->sc_ih = isa_intr_establish(sc->sc_ic, sc->ym_irq, IST_EDGE,\n\t    IPL_AUDIO, ym_intr, &sc->sc_ad1848, sc->sc_dev.dv_xname);\n\n\tad1848_attach(&sc->sc_ad1848);\n\tprintf(\"\\n\");\n\tsc->sc_ad1848.parent = sc;\n\n\t/* Establish chip in well known mode */\n\tym_set_master_gain(sc, &vol_mid);\n\tym_set_mic_gain(sc, 0);\n\tsc->master_mute = 0;\n\tym_mute(sc, SA3_VOL_L, sc->master_mute);\n\tym_mute(sc, SA3_VOL_R, sc->master_mute);\n\n\tsc->mic_mute = 1;\n\tym_mute(sc, SA3_MIC_VOL, sc->mic_mute);\n\n#if NMIDI > 0\n\tsc->sc_hasmpu = 0;\n\tif (sc->sc_mpu_sc.iobase) {\n\t\tsc->sc_mpu_sc.iot = sc->sc_iot;\n\t\tif (mpu_find(&sc->sc_mpu_sc)) {\n\t\t\tsc->sc_hasmpu = 1;\n\t\t\tmhw = &ym_mpu401_hw_if;\n\t\t}\n\t}\n\tmidi_attach_mi(mhw, sc, &sc->sc_dev);\n#endif\n\n\taudio_attach_mi(&ym_hw_if, &sc->sc_ad1848, &sc->sc_dev);\n}"
  },
  {
    "function_name": "ym_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ym.c",
    "lines": "129-140",
    "snippet": "int\nym_intr(v)\n\tvoid   *v;\n{\n#if NMIDI > 0\n\tstruct ym_softc *sc = v;\n\n\tif ( /* XXX && */ sc->sc_hasmpu)\n\t\tmpu_intr(&sc->sc_mpu_sc);\n#endif\n\treturn ad1848_intr(v);\n}",
    "includes": [
      "#include <dev/isa/ymvar.h>",
      "#include <dev/ic/mpuvar.h>",
      "#include <dev/ic/opl3sa3reg.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/midi_if.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"midi.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int ym_intr"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ad1848_intr",
          "args": [
            "v"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "ad1848_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "1607-1640",
          "snippet": "int\nad1848_intr(arg)\n\tvoid *arg;\n{\n    struct ad1848_softc *sc = arg;\n    int retval = 0;\n    u_char status;\n    \n    /* Get intr status */\n    status = ADREAD(sc, AD1848_STATUS);\n    \n#ifdef AUDIO_DEBUG\n    if (ad1848debug > 1)\n\tprintf(\"ad1848_intr: intr=%p status=%x\\n\", sc->sc_intr, status);\n#endif\n    sc->sc_locked = 0;\n    sc->sc_interrupts++;\n    \n    /* Handle interrupt */\n    if (sc->sc_intr && (status & INTERRUPT_STATUS)) {\n\t/* ACK DMA read because it may be in a bounce buffer */\n\t/* XXX Do write to mask DMA ? */\n\tif ((sc->sc_dma_flags & DMAMODE_READ) && sc->sc_recrun == NOTRUNNING)\n\t    isa_dmadone(sc->sc_isa, sc->sc_recdrq);\n\t(*sc->sc_intr)(sc->sc_arg);\n\tretval = 1;\n    }\n\n    /* clear interrupt */\n    if (status & INTERRUPT_STATUS)\n\tADWRITE(sc, AD1848_STATUS, 0);\n\n    return(retval);\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nad1848_intr(arg)\n\tvoid *arg;\n{\n    struct ad1848_softc *sc = arg;\n    int retval = 0;\n    u_char status;\n    \n    /* Get intr status */\n    status = ADREAD(sc, AD1848_STATUS);\n    \n#ifdef AUDIO_DEBUG\n    if (ad1848debug > 1)\n\tprintf(\"ad1848_intr: intr=%p status=%x\\n\", sc->sc_intr, status);\n#endif\n    sc->sc_locked = 0;\n    sc->sc_interrupts++;\n    \n    /* Handle interrupt */\n    if (sc->sc_intr && (status & INTERRUPT_STATUS)) {\n\t/* ACK DMA read because it may be in a bounce buffer */\n\t/* XXX Do write to mask DMA ? */\n\tif ((sc->sc_dma_flags & DMAMODE_READ) && sc->sc_recrun == NOTRUNNING)\n\t    isa_dmadone(sc->sc_isa, sc->sc_recdrq);\n\t(*sc->sc_intr)(sc->sc_arg);\n\tretval = 1;\n    }\n\n    /* clear interrupt */\n    if (status & INTERRUPT_STATUS)\n\tADWRITE(sc, AD1848_STATUS, 0);\n\n    return(retval);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mpu_intr",
          "args": [
            "&sc->sc_mpu_sc"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "mpu_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mpu401.c",
          "lines": "243-255",
          "snippet": "int\nmpu_intr(v)\n\tvoid *v;\n{\n\tstruct mpu_softc *sc = v;\n\n\tif (MPU_GETSTATUS(sc->iot, sc->ioh) & MPU_INPUT_EMPTY) {\n\t\tDPRINTF((\"mpu_intr: no data\\n\"));\n\t\treturn 0;\n\t}\n\tmpu_readinput(sc);\n\treturn 1;\n}",
          "includes": [
            "#include <dev/ic/mpuvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/midi_if.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define  MPU_INPUT_EMPTY\t0x80"
          ],
          "globals_used": [
            "int\tmpu_reset(struct mpu_softc *);",
            "static\t__inline int mpu_waitready(struct mpu_softc *);",
            "void\tmpu_readinput(struct mpu_softc *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/mpuvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/midi_if.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define  MPU_INPUT_EMPTY\t0x80\n\nint\tmpu_reset(struct mpu_softc *);\nstatic\t__inline int mpu_waitready(struct mpu_softc *);\nvoid\tmpu_readinput(struct mpu_softc *);\n\nint\nmpu_intr(v)\n\tvoid *v;\n{\n\tstruct mpu_softc *sc = v;\n\n\tif (MPU_GETSTATUS(sc->iot, sc->ioh) & MPU_INPUT_EMPTY) {\n\t\tDPRINTF((\"mpu_intr: no data\\n\"));\n\t\treturn 0;\n\t}\n\tmpu_readinput(sc);\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/ymvar.h>\n#include <dev/ic/mpuvar.h>\n#include <dev/ic/opl3sa3reg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"midi.h\"\n\nint ym_intr;\n\nint\nym_intr(v)\n\tvoid   *v;\n{\n#if NMIDI > 0\n\tstruct ym_softc *sc = v;\n\n\tif ( /* XXX && */ sc->sc_hasmpu)\n\t\tmpu_intr(&sc->sc_mpu_sc);\n#endif\n\treturn ad1848_intr(v);\n}"
  }
]