[
  {
    "function_name": "rf_SelectMirrorDiskPartition",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagutils.c",
    "lines": "1251-1297",
    "snippet": "void \nrf_SelectMirrorDiskPartition(RF_DagNode_t * node)\n{\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->dagHdr->raidPtr;\n\tRF_RowCol_t rowData, colData, rowMirror, colMirror;\n\tRF_PhysDiskAddr_t *data_pda = (RF_PhysDiskAddr_t *) node->params[0].p;\n\tRF_PhysDiskAddr_t *mirror_pda = (RF_PhysDiskAddr_t *) node->params[4].p;\n\tRF_PhysDiskAddr_t *tmp_pda;\n\tRF_RaidDisk_t **disks = raidPtr->Disks;\n\tRF_DiskQueue_t **dqs = raidPtr->Queues, *dataQueue, *mirrorQueue;\n\tint     usemirror;\n\n\t/* return the [row col] of the disk with the shortest queue */\n\trowData = data_pda->row;\n\tcolData = data_pda->col;\n\trowMirror = mirror_pda->row;\n\tcolMirror = mirror_pda->col;\n\tdataQueue = &(dqs[rowData][colData]);\n\tmirrorQueue = &(dqs[rowMirror][colMirror]);\n\n\tusemirror = 0;\n\tif (RF_DEAD_DISK(disks[rowMirror][colMirror].status)) {\n\t\tusemirror = 0;\n\t} else\n\t\tif (RF_DEAD_DISK(disks[rowData][colData].status)) {\n\t\t\tusemirror = 1;\n\t\t} else \n\t\t\tif (raidPtr->parity_good == RF_RAID_DIRTY) {\n\t\t\t\t/* Trust only the main disk */\n\t\t\t\tusemirror = 0;\n\t\t} else\n\t\t\t\tif (data_pda->startSector < \n\t\t\t\t    (disks[rowData][colData].numBlocks / 2)) {\n\t\t\t\tusemirror = 0;\n\t\t\t} else {\n\t\t\t\tusemirror = 1;\n\t\t\t}\n\n\tif (usemirror) {\n\t\t/* use mirror (parity) disk, swap params 0 & 4 */\n\t\ttmp_pda = data_pda;\n\t\tnode->params[0].p = mirror_pda;\n\t\tnode->params[4].p = tmp_pda;\n\t} else {\n\t\t/* use data disk, leave param 0 unchanged */\n\t}\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void rf_RecurPrintDAG(RF_DagNode_t *, int, int);",
      "static int \nrf_ValidateBranch(RF_DagNode_t *, int *, int *,\n    RF_DagNode_t **, int);",
      "static void rf_ValidateBranchVisitedBits(RF_DagNode_t *, int, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_DEAD_DISK",
          "args": [
            "disks[rowData][colData].status"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_DEAD_DISK",
          "args": [
            "disks[rowMirror][colMirror].status"
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_map.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void rf_RecurPrintDAG(RF_DagNode_t *, int, int);\nstatic int \nrf_ValidateBranch(RF_DagNode_t *, int *, int *,\n    RF_DagNode_t **, int);\nstatic void rf_ValidateBranchVisitedBits(RF_DagNode_t *, int, int);\n\nvoid \nrf_SelectMirrorDiskPartition(RF_DagNode_t * node)\n{\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->dagHdr->raidPtr;\n\tRF_RowCol_t rowData, colData, rowMirror, colMirror;\n\tRF_PhysDiskAddr_t *data_pda = (RF_PhysDiskAddr_t *) node->params[0].p;\n\tRF_PhysDiskAddr_t *mirror_pda = (RF_PhysDiskAddr_t *) node->params[4].p;\n\tRF_PhysDiskAddr_t *tmp_pda;\n\tRF_RaidDisk_t **disks = raidPtr->Disks;\n\tRF_DiskQueue_t **dqs = raidPtr->Queues, *dataQueue, *mirrorQueue;\n\tint     usemirror;\n\n\t/* return the [row col] of the disk with the shortest queue */\n\trowData = data_pda->row;\n\tcolData = data_pda->col;\n\trowMirror = mirror_pda->row;\n\tcolMirror = mirror_pda->col;\n\tdataQueue = &(dqs[rowData][colData]);\n\tmirrorQueue = &(dqs[rowMirror][colMirror]);\n\n\tusemirror = 0;\n\tif (RF_DEAD_DISK(disks[rowMirror][colMirror].status)) {\n\t\tusemirror = 0;\n\t} else\n\t\tif (RF_DEAD_DISK(disks[rowData][colData].status)) {\n\t\t\tusemirror = 1;\n\t\t} else \n\t\t\tif (raidPtr->parity_good == RF_RAID_DIRTY) {\n\t\t\t\t/* Trust only the main disk */\n\t\t\t\tusemirror = 0;\n\t\t} else\n\t\t\t\tif (data_pda->startSector < \n\t\t\t\t    (disks[rowData][colData].numBlocks / 2)) {\n\t\t\t\tusemirror = 0;\n\t\t\t} else {\n\t\t\t\tusemirror = 1;\n\t\t\t}\n\n\tif (usemirror) {\n\t\t/* use mirror (parity) disk, swap params 0 & 4 */\n\t\ttmp_pda = data_pda;\n\t\tnode->params[0].p = mirror_pda;\n\t\tnode->params[4].p = tmp_pda;\n\t} else {\n\t\t/* use data disk, leave param 0 unchanged */\n\t}\n}"
  },
  {
    "function_name": "rf_SelectMirrorDiskIdle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagutils.c",
    "lines": "1176-1246",
    "snippet": "void \nrf_SelectMirrorDiskIdle(RF_DagNode_t * node)\n{\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->dagHdr->raidPtr;\n\tRF_RowCol_t rowData, colData, rowMirror, colMirror;\n\tint     dataQueueLength, mirrorQueueLength, usemirror;\n\tRF_PhysDiskAddr_t *data_pda = (RF_PhysDiskAddr_t *) node->params[0].p;\n\tRF_PhysDiskAddr_t *mirror_pda = (RF_PhysDiskAddr_t *) node->params[4].p;\n\tRF_PhysDiskAddr_t *tmp_pda;\n\tRF_RaidDisk_t **disks = raidPtr->Disks;\n\tRF_DiskQueue_t **dqs = raidPtr->Queues, *dataQueue, *mirrorQueue;\n\n\t/* return the [row col] of the disk with the shortest queue */\n\trowData = data_pda->row;\n\tcolData = data_pda->col;\n\trowMirror = mirror_pda->row;\n\tcolMirror = mirror_pda->col;\n\tdataQueue = &(dqs[rowData][colData]);\n\tmirrorQueue = &(dqs[rowMirror][colMirror]);\n\n#ifdef RF_LOCK_QUEUES_TO_READ_LEN\n\tRF_LOCK_QUEUE_MUTEX(dataQueue, \"SelectMirrorDiskIdle\");\n#endif\t\t\t\t/* RF_LOCK_QUEUES_TO_READ_LEN */\n\tdataQueueLength = dataQueue->queueLength + dataQueue->numOutstanding;\n#ifdef RF_LOCK_QUEUES_TO_READ_LEN\n\tRF_UNLOCK_QUEUE_MUTEX(dataQueue, \"SelectMirrorDiskIdle\");\n\tRF_LOCK_QUEUE_MUTEX(mirrorQueue, \"SelectMirrorDiskIdle\");\n#endif\t\t\t\t/* RF_LOCK_QUEUES_TO_READ_LEN */\n\tmirrorQueueLength = mirrorQueue->queueLength + mirrorQueue->numOutstanding;\n#ifdef RF_LOCK_QUEUES_TO_READ_LEN\n\tRF_UNLOCK_QUEUE_MUTEX(mirrorQueue, \"SelectMirrorDiskIdle\");\n#endif\t\t\t\t/* RF_LOCK_QUEUES_TO_READ_LEN */\n\n\tusemirror = 0;\n\tif (RF_DEAD_DISK(disks[rowMirror][colMirror].status)) {\n\t\tusemirror = 0;\n\t} else\n\t\tif (RF_DEAD_DISK(disks[rowData][colData].status)) {\n\t\t\tusemirror = 1;\n\t\t} else\n\t\t\tif (raidPtr->parity_good == RF_RAID_DIRTY) {\n\t\t\t\t/* Trust only the main disk */\n\t\t\t\tusemirror = 0;\n\t\t\t} else\n\t\t\tif (dataQueueLength < mirrorQueueLength) {\n\t\t\t\tusemirror = 0;\n\t\t\t} else\n\t\t\t\tif (mirrorQueueLength < dataQueueLength) {\n\t\t\t\t\tusemirror = 1;\n\t\t\t\t} else {\n\t\t\t\t\t/* queues are equal length. attempt\n\t\t\t\t\t * cleverness. */\n\t\t\t\t\tif (SNUM_DIFF(dataQueue->last_deq_sector, data_pda->startSector)\n\t\t\t\t\t    <= SNUM_DIFF(mirrorQueue->last_deq_sector, mirror_pda->startSector)) {\n\t\t\t\t\t\tusemirror = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tusemirror = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\tif (usemirror) {\n\t\t/* use mirror (parity) disk, swap params 0 & 4 */\n\t\ttmp_pda = data_pda;\n\t\tnode->params[0].p = mirror_pda;\n\t\tnode->params[4].p = tmp_pda;\n\t} else {\n\t\t/* use data disk, leave param 0 unchanged */\n\t}\n\t/* printf(\"dataQueueLength %d, mirrorQueueLength\n\t * %d\\n\",dataQueueLength, mirrorQueueLength); */\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void rf_RecurPrintDAG(RF_DagNode_t *, int, int);",
      "static int \nrf_ValidateBranch(RF_DagNode_t *, int *, int *,\n    RF_DagNode_t **, int);",
      "static void rf_ValidateBranchVisitedBits(RF_DagNode_t *, int, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SNUM_DIFF",
          "args": [
            "mirrorQueue->last_deq_sector",
            "mirror_pda->startSector"
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SNUM_DIFF",
          "args": [
            "dataQueue->last_deq_sector",
            "data_pda->startSector"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_DEAD_DISK",
          "args": [
            "disks[rowData][colData].status"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_DEAD_DISK",
          "args": [
            "disks[rowMirror][colMirror].status"
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_UNLOCK_QUEUE_MUTEX",
          "args": [
            "mirrorQueue",
            "\"SelectMirrorDiskIdle\""
          ],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_LOCK_QUEUE_MUTEX",
          "args": [
            "mirrorQueue",
            "\"SelectMirrorDiskIdle\""
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_UNLOCK_QUEUE_MUTEX",
          "args": [
            "dataQueue",
            "\"SelectMirrorDiskIdle\""
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_LOCK_QUEUE_MUTEX",
          "args": [
            "dataQueue",
            "\"SelectMirrorDiskIdle\""
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_map.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void rf_RecurPrintDAG(RF_DagNode_t *, int, int);\nstatic int \nrf_ValidateBranch(RF_DagNode_t *, int *, int *,\n    RF_DagNode_t **, int);\nstatic void rf_ValidateBranchVisitedBits(RF_DagNode_t *, int, int);\n\nvoid \nrf_SelectMirrorDiskIdle(RF_DagNode_t * node)\n{\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->dagHdr->raidPtr;\n\tRF_RowCol_t rowData, colData, rowMirror, colMirror;\n\tint     dataQueueLength, mirrorQueueLength, usemirror;\n\tRF_PhysDiskAddr_t *data_pda = (RF_PhysDiskAddr_t *) node->params[0].p;\n\tRF_PhysDiskAddr_t *mirror_pda = (RF_PhysDiskAddr_t *) node->params[4].p;\n\tRF_PhysDiskAddr_t *tmp_pda;\n\tRF_RaidDisk_t **disks = raidPtr->Disks;\n\tRF_DiskQueue_t **dqs = raidPtr->Queues, *dataQueue, *mirrorQueue;\n\n\t/* return the [row col] of the disk with the shortest queue */\n\trowData = data_pda->row;\n\tcolData = data_pda->col;\n\trowMirror = mirror_pda->row;\n\tcolMirror = mirror_pda->col;\n\tdataQueue = &(dqs[rowData][colData]);\n\tmirrorQueue = &(dqs[rowMirror][colMirror]);\n\n#ifdef RF_LOCK_QUEUES_TO_READ_LEN\n\tRF_LOCK_QUEUE_MUTEX(dataQueue, \"SelectMirrorDiskIdle\");\n#endif\t\t\t\t/* RF_LOCK_QUEUES_TO_READ_LEN */\n\tdataQueueLength = dataQueue->queueLength + dataQueue->numOutstanding;\n#ifdef RF_LOCK_QUEUES_TO_READ_LEN\n\tRF_UNLOCK_QUEUE_MUTEX(dataQueue, \"SelectMirrorDiskIdle\");\n\tRF_LOCK_QUEUE_MUTEX(mirrorQueue, \"SelectMirrorDiskIdle\");\n#endif\t\t\t\t/* RF_LOCK_QUEUES_TO_READ_LEN */\n\tmirrorQueueLength = mirrorQueue->queueLength + mirrorQueue->numOutstanding;\n#ifdef RF_LOCK_QUEUES_TO_READ_LEN\n\tRF_UNLOCK_QUEUE_MUTEX(mirrorQueue, \"SelectMirrorDiskIdle\");\n#endif\t\t\t\t/* RF_LOCK_QUEUES_TO_READ_LEN */\n\n\tusemirror = 0;\n\tif (RF_DEAD_DISK(disks[rowMirror][colMirror].status)) {\n\t\tusemirror = 0;\n\t} else\n\t\tif (RF_DEAD_DISK(disks[rowData][colData].status)) {\n\t\t\tusemirror = 1;\n\t\t} else\n\t\t\tif (raidPtr->parity_good == RF_RAID_DIRTY) {\n\t\t\t\t/* Trust only the main disk */\n\t\t\t\tusemirror = 0;\n\t\t\t} else\n\t\t\tif (dataQueueLength < mirrorQueueLength) {\n\t\t\t\tusemirror = 0;\n\t\t\t} else\n\t\t\t\tif (mirrorQueueLength < dataQueueLength) {\n\t\t\t\t\tusemirror = 1;\n\t\t\t\t} else {\n\t\t\t\t\t/* queues are equal length. attempt\n\t\t\t\t\t * cleverness. */\n\t\t\t\t\tif (SNUM_DIFF(dataQueue->last_deq_sector, data_pda->startSector)\n\t\t\t\t\t    <= SNUM_DIFF(mirrorQueue->last_deq_sector, mirror_pda->startSector)) {\n\t\t\t\t\t\tusemirror = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tusemirror = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\tif (usemirror) {\n\t\t/* use mirror (parity) disk, swap params 0 & 4 */\n\t\ttmp_pda = data_pda;\n\t\tnode->params[0].p = mirror_pda;\n\t\tnode->params[4].p = tmp_pda;\n\t} else {\n\t\t/* use data disk, leave param 0 unchanged */\n\t}\n\t/* printf(\"dataQueueLength %d, mirrorQueueLength\n\t * %d\\n\",dataQueueLength, mirrorQueueLength); */\n}"
  },
  {
    "function_name": "rf_compute_workload_shift",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagutils.c",
    "lines": "1090-1166",
    "snippet": "int \nrf_compute_workload_shift(\n    RF_Raid_t * raidPtr,\n    RF_PhysDiskAddr_t * pda)\n{\n\t/*\n         * variables:\n         *  d   = column of disk containing primary\n         *  f   = column of failed disk\n         *  n   = number of disks in array\n         *  sd  = \"shift distance\" (number of columns that d is to the right of f)\n         *  row = row of array the access is in\n         *  v   = numerator of redirection ratio\n         *  k   = denominator of redirection ratio\n         */\n\tRF_RowCol_t d, f, sd, row, n;\n\tint     k, v, ret, i;\n\n\trow = pda->row;\n\tn = raidPtr->numCol;\n\n\t/* assign column of primary copy to d */\n\td = pda->col;\n\n\t/* assign column of dead disk to f */\n\tfor (f = 0; ((!RF_DEAD_DISK(raidPtr->Disks[row][f].status)) && (f < n)); f++);\n\n\tRF_ASSERT(f < n);\n\tRF_ASSERT(f != d);\n\n\tsd = (f > d) ? (n + d - f) : (d - f);\n\tRF_ASSERT(sd < n);\n\n\t/*\n         * v of every k accesses should be redirected\n         *\n         * v/k := (n-1-sd)/(n-1)\n         */\n\tv = (n - 1 - sd);\n\tk = (n - 1);\n\n#if 1\n\t/*\n         * XXX\n         * Is this worth it?\n         *\n         * Now reduce the fraction, by repeatedly factoring\n         * out primes (just like they teach in elementary school!)\n         */\n\tfor (i = 0; i < NLOWPRIMES; i++) {\n\t\tif (lowprimes[i] > v)\n\t\t\tbreak;\n\t\twhile (((v % lowprimes[i]) == 0) && ((k % lowprimes[i]) == 0)) {\n\t\t\tv /= lowprimes[i];\n\t\t\tk /= lowprimes[i];\n\t\t}\n\t}\n#endif\n\n\traidPtr->hist_diskreq[row][d]++;\n\tif (raidPtr->hist_diskreq[row][d] > v) {\n\t\tret = 0;\t/* do not redirect */\n\t} else {\n\t\tret = 1;\t/* redirect */\n\t}\n\n#if 0\n\tprintf(\"d=%d f=%d sd=%d v=%d k=%d ret=%d h=%d\\n\", d, f, sd, v, k, ret,\n\t    raidPtr->hist_diskreq[row][d]);\n#endif\n\n\tif (raidPtr->hist_diskreq[row][d] >= k) {\n\t\t/* reset counter */\n\t\traidPtr->hist_diskreq[row][d] = 0;\n\t}\n\treturn (ret);\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [
      "#define NLOWPRIMES 8"
    ],
    "globals_used": [
      "static int lowprimes[NLOWPRIMES] = {2, 3, 5, 7, 11, 13, 17, 19};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"d=%d f=%d sd=%d v=%d k=%d ret=%d h=%d\\n\"",
            "d",
            "f",
            "sd",
            "v",
            "k",
            "ret",
            "raidPtr->hist_diskreq[row][d]"
          ],
          "line": 1157
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "sd < n"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "f != d"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "f < n"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_DEAD_DISK",
          "args": [
            "raidPtr->Disks[row][f].status"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_map.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\n#define NLOWPRIMES 8\n\nstatic int lowprimes[NLOWPRIMES] = {2, 3, 5, 7, 11, 13, 17, 19};\n\nint \nrf_compute_workload_shift(\n    RF_Raid_t * raidPtr,\n    RF_PhysDiskAddr_t * pda)\n{\n\t/*\n         * variables:\n         *  d   = column of disk containing primary\n         *  f   = column of failed disk\n         *  n   = number of disks in array\n         *  sd  = \"shift distance\" (number of columns that d is to the right of f)\n         *  row = row of array the access is in\n         *  v   = numerator of redirection ratio\n         *  k   = denominator of redirection ratio\n         */\n\tRF_RowCol_t d, f, sd, row, n;\n\tint     k, v, ret, i;\n\n\trow = pda->row;\n\tn = raidPtr->numCol;\n\n\t/* assign column of primary copy to d */\n\td = pda->col;\n\n\t/* assign column of dead disk to f */\n\tfor (f = 0; ((!RF_DEAD_DISK(raidPtr->Disks[row][f].status)) && (f < n)); f++);\n\n\tRF_ASSERT(f < n);\n\tRF_ASSERT(f != d);\n\n\tsd = (f > d) ? (n + d - f) : (d - f);\n\tRF_ASSERT(sd < n);\n\n\t/*\n         * v of every k accesses should be redirected\n         *\n         * v/k := (n-1-sd)/(n-1)\n         */\n\tv = (n - 1 - sd);\n\tk = (n - 1);\n\n#if 1\n\t/*\n         * XXX\n         * Is this worth it?\n         *\n         * Now reduce the fraction, by repeatedly factoring\n         * out primes (just like they teach in elementary school!)\n         */\n\tfor (i = 0; i < NLOWPRIMES; i++) {\n\t\tif (lowprimes[i] > v)\n\t\t\tbreak;\n\t\twhile (((v % lowprimes[i]) == 0) && ((k % lowprimes[i]) == 0)) {\n\t\t\tv /= lowprimes[i];\n\t\t\tk /= lowprimes[i];\n\t\t}\n\t}\n#endif\n\n\traidPtr->hist_diskreq[row][d]++;\n\tif (raidPtr->hist_diskreq[row][d] > v) {\n\t\tret = 0;\t/* do not redirect */\n\t} else {\n\t\tret = 1;\t/* redirect */\n\t}\n\n#if 0\n\tprintf(\"d=%d f=%d sd=%d v=%d k=%d ret=%d h=%d\\n\", d, f, sd, v, k, ret,\n\t    raidPtr->hist_diskreq[row][d]);\n#endif\n\n\tif (raidPtr->hist_diskreq[row][d] >= k) {\n\t\t/* reset counter */\n\t\traidPtr->hist_diskreq[row][d] = 0;\n\t}\n\treturn (ret);\n}"
  },
  {
    "function_name": "rf_RangeRestrictPDA",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagutils.c",
    "lines": "1050-1075",
    "snippet": "void \nrf_RangeRestrictPDA(\n    RF_Raid_t * raidPtr,\n    RF_PhysDiskAddr_t * src,\n    RF_PhysDiskAddr_t * dest,\n    int dobuffer,\n    int doraidaddr)\n{\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\tRF_SectorNum_t soffs = rf_StripeUnitOffset(layoutPtr, src->startSector);\n\tRF_SectorNum_t doffs = rf_StripeUnitOffset(layoutPtr, dest->startSector);\n\tRF_SectorNum_t send = rf_StripeUnitOffset(layoutPtr, src->startSector + src->numSector - 1);\t/* use -1 to be sure we\n\t\t\t\t\t\t\t\t\t\t\t\t\t * stay within SU */\n\tRF_SectorNum_t dend = rf_StripeUnitOffset(layoutPtr, dest->startSector + dest->numSector - 1);\n\tRF_SectorNum_t subAddr = rf_RaidAddressOfPrevStripeUnitBoundary(layoutPtr, dest->startSector);\t/* stripe unit boundary */\n\n\tdest->startSector = subAddr + RF_MAX(soffs, doffs);\n\tdest->numSector = subAddr + RF_MIN(send, dend) + 1 - dest->startSector;\n\n\tif (dobuffer)\n\t\tdest->bufPtr += (soffs > doffs) ? rf_RaidAddressToByte(raidPtr, soffs - doffs) : 0;\n\tif (doraidaddr) {\n\t\tdest->raidAddress = rf_RaidAddressOfPrevStripeUnitBoundary(layoutPtr, dest->raidAddress) +\n\t\t    rf_StripeUnitOffset(layoutPtr, dest->startSector);\n\t}\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_StripeUnitOffset",
          "args": [
            "layoutPtr",
            "dest->startSector"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressOfPrevStripeUnitBoundary",
          "args": [
            "layoutPtr",
            "dest->raidAddress"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToByte",
          "args": [
            "raidPtr",
            "soffs - doffs"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_MIN",
          "args": [
            "send",
            "dend"
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_MAX",
          "args": [
            "soffs",
            "doffs"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressOfPrevStripeUnitBoundary",
          "args": [
            "layoutPtr",
            "dest->startSector"
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_StripeUnitOffset",
          "args": [
            "layoutPtr",
            "dest->startSector + dest->numSector - 1"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_StripeUnitOffset",
          "args": [
            "layoutPtr",
            "src->startSector + src->numSector - 1"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_StripeUnitOffset",
          "args": [
            "layoutPtr",
            "dest->startSector"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_StripeUnitOffset",
          "args": [
            "layoutPtr",
            "src->startSector"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_map.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nvoid \nrf_RangeRestrictPDA(\n    RF_Raid_t * raidPtr,\n    RF_PhysDiskAddr_t * src,\n    RF_PhysDiskAddr_t * dest,\n    int dobuffer,\n    int doraidaddr)\n{\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\tRF_SectorNum_t soffs = rf_StripeUnitOffset(layoutPtr, src->startSector);\n\tRF_SectorNum_t doffs = rf_StripeUnitOffset(layoutPtr, dest->startSector);\n\tRF_SectorNum_t send = rf_StripeUnitOffset(layoutPtr, src->startSector + src->numSector - 1);\t/* use -1 to be sure we\n\t\t\t\t\t\t\t\t\t\t\t\t\t * stay within SU */\n\tRF_SectorNum_t dend = rf_StripeUnitOffset(layoutPtr, dest->startSector + dest->numSector - 1);\n\tRF_SectorNum_t subAddr = rf_RaidAddressOfPrevStripeUnitBoundary(layoutPtr, dest->startSector);\t/* stripe unit boundary */\n\n\tdest->startSector = subAddr + RF_MAX(soffs, doffs);\n\tdest->numSector = subAddr + RF_MIN(send, dend) + 1 - dest->startSector;\n\n\tif (dobuffer)\n\t\tdest->bufPtr += (soffs > doffs) ? rf_RaidAddressToByte(raidPtr, soffs - doffs) : 0;\n\tif (doraidaddr) {\n\t\tdest->raidAddress = rf_RaidAddressOfPrevStripeUnitBoundary(layoutPtr, dest->raidAddress) +\n\t\t    rf_StripeUnitOffset(layoutPtr, dest->startSector);\n\t}\n}"
  },
  {
    "function_name": "rf_GenerateFailedAccessASMs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagutils.c",
    "lines": "899-1025",
    "snippet": "void \nrf_GenerateFailedAccessASMs(\n    RF_Raid_t * raidPtr,\n    RF_AccessStripeMap_t * asmap,\n    RF_PhysDiskAddr_t * failedPDA,\n    RF_DagHeader_t * dag_h,\n    RF_AccessStripeMapHeader_t ** new_asm_h,\n    int *nXorBufs,\n    char **rpBufPtr,\n    char *overlappingPDAs,\n    RF_AllocListElem_t * allocList)\n{\n\tRF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);\n\n\t/* s=start, e=end, s=stripe, a=access, f=failed, su=stripe unit */\n\tRF_RaidAddr_t sosAddr, sosEndAddr, eosStartAddr, eosAddr;\n\n\tRF_SectorCount_t numSect[2], numParitySect;\n\tRF_PhysDiskAddr_t *pda;\n\tchar   *rdBuf, *bufP;\n\tint     foundit, i;\n\n\tbufP = NULL;\n\tfoundit = 0;\n\t/* first compute the following raid addresses: start of stripe,\n\t * (sosAddr) MIN(start of access, start of failed SU),   (sosEndAddr)\n\t * MAX(end of access, end of failed SU),       (eosStartAddr) end of\n\t * stripe (i.e. start of next stripe)   (eosAddr) */\n\tsosAddr = rf_RaidAddressOfPrevStripeBoundary(layoutPtr, asmap->raidAddress);\n\tsosEndAddr = RF_MIN(asmap->raidAddress, rf_RaidAddressOfPrevStripeUnitBoundary(layoutPtr, failedPDA->raidAddress));\n\teosStartAddr = RF_MAX(asmap->endRaidAddress, rf_RaidAddressOfNextStripeUnitBoundary(layoutPtr, failedPDA->raidAddress));\n\teosAddr = rf_RaidAddressOfNextStripeBoundary(layoutPtr, asmap->raidAddress);\n\n\t/* now generate access stripe maps for each of the above regions of\n\t * the stripe.  Use a dummy (NULL) buf ptr for now */\n\n\tnew_asm_h[0] = (sosAddr != sosEndAddr) ? rf_MapAccess(raidPtr, sosAddr, sosEndAddr - sosAddr, NULL, RF_DONT_REMAP) : NULL;\n\tnew_asm_h[1] = (eosStartAddr != eosAddr) ? rf_MapAccess(raidPtr, eosStartAddr, eosAddr - eosStartAddr, NULL, RF_DONT_REMAP) : NULL;\n\n\t/* walk through the PDAs and range-restrict each SU to the region of\n\t * the SU touched on the failed PDA.  also compute total data buffer\n\t * space requirements in this step.  Ignore the parity for now. */\n\n\tnumSect[0] = numSect[1] = 0;\n\tif (new_asm_h[0]) {\n\t\tnew_asm_h[0]->next = dag_h->asmList;\n\t\tdag_h->asmList = new_asm_h[0];\n\t\tfor (pda = new_asm_h[0]->stripeMap->physInfo; pda; pda = pda->next) {\n\t\t\trf_RangeRestrictPDA(raidPtr, failedPDA, pda, RF_RESTRICT_NOBUFFER, 0);\n\t\t\tnumSect[0] += pda->numSector;\n\t\t}\n\t}\n\tif (new_asm_h[1]) {\n\t\tnew_asm_h[1]->next = dag_h->asmList;\n\t\tdag_h->asmList = new_asm_h[1];\n\t\tfor (pda = new_asm_h[1]->stripeMap->physInfo; pda; pda = pda->next) {\n\t\t\trf_RangeRestrictPDA(raidPtr, failedPDA, pda, RF_RESTRICT_NOBUFFER, 0);\n\t\t\tnumSect[1] += pda->numSector;\n\t\t}\n\t}\n\tnumParitySect = failedPDA->numSector;\n\n\t/* allocate buffer space for the data & parity we have to read to\n\t * recover from the failure */\n\n\tif (numSect[0] + numSect[1] + ((rpBufPtr) ? numParitySect : 0)) {\t/* don't allocate parity\n\t\t\t\t\t\t\t\t\t\t * buf if not needed */\n\t\tRF_MallocAndAdd(rdBuf, rf_RaidAddressToByte(raidPtr, numSect[0] + numSect[1] + numParitySect), (char *), allocList);\n\t\tbufP = rdBuf;\n\t\tif (rf_degDagDebug)\n\t\t\tprintf(\"Newly allocated buffer (%d bytes) is 0x%lx\\n\",\n\t\t\t    (int) rf_RaidAddressToByte(raidPtr, numSect[0] + numSect[1] + numParitySect), (unsigned long) bufP);\n\t}\n\t/* now walk through the pdas one last time and assign buffer pointers\n\t * (ugh!).  Again, ignore the parity.  also, count nodes to find out\n\t * how many bufs need to be xored together */\n\t(*nXorBufs) = 1;\t/* in read case, 1 is for parity.  In write\n\t\t\t\t * case, 1 is for failed data */\n\tif (new_asm_h[0]) {\n\t\tfor (pda = new_asm_h[0]->stripeMap->physInfo; pda; pda = pda->next) {\n\t\t\tpda->bufPtr = bufP;\n\t\t\tbufP += rf_RaidAddressToByte(raidPtr, pda->numSector);\n\t\t}\n\t\t*nXorBufs += new_asm_h[0]->stripeMap->numStripeUnitsAccessed;\n\t}\n\tif (new_asm_h[1]) {\n\t\tfor (pda = new_asm_h[1]->stripeMap->physInfo; pda; pda = pda->next) {\n\t\t\tpda->bufPtr = bufP;\n\t\t\tbufP += rf_RaidAddressToByte(raidPtr, pda->numSector);\n\t\t}\n\t\t(*nXorBufs) += new_asm_h[1]->stripeMap->numStripeUnitsAccessed;\n\t}\n\tif (rpBufPtr)\n\t\t*rpBufPtr = bufP;\t/* the rest of the buffer is for\n\t\t\t\t\t * parity */\n\n\t/* the last step is to figure out how many more distinct buffers need\n\t * to get xor'd to produce the missing unit.  there's one for each\n\t * user-data read node that overlaps the portion of the failed unit\n\t * being accessed */\n\n\tfor (foundit = i = 0, pda = asmap->physInfo; pda; i++, pda = pda->next) {\n\t\tif (pda == failedPDA) {\n\t\t\ti--;\n\t\t\tfoundit = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (rf_PDAOverlap(layoutPtr, pda, failedPDA)) {\n\t\t\toverlappingPDAs[i] = 1;\n\t\t\t(*nXorBufs)++;\n\t\t}\n\t}\n\tif (!foundit) {\n\t\tRF_ERRORMSG(\"GenerateFailedAccessASMs: did not find failedPDA in asm list\\n\");\n\t\tRF_ASSERT(0);\n\t}\n\tif (rf_degDagDebug) {\n\t\tif (new_asm_h[0]) {\n\t\t\tprintf(\"First asm:\\n\");\n\t\t\trf_PrintFullAccessStripeMap(new_asm_h[0], 1);\n\t\t}\n\t\tif (new_asm_h[1]) {\n\t\t\tprintf(\"Second asm:\\n\");\n\t\t\trf_PrintFullAccessStripeMap(new_asm_h[1], 1);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void rf_PrintDAG(RF_DagHeader_t *);",
      "static void rf_ValidateVisitedBits(RF_DagHeader_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_PrintFullAccessStripeMap",
          "args": [
            "new_asm_h[1]",
            "1"
          ],
          "line": 1022
        },
        "resolved": true,
        "details": {
          "function_name": "rf_PrintFullAccessStripeMap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_map.c",
          "lines": "705-759",
          "snippet": "void \nrf_PrintFullAccessStripeMap(asm_h, prbuf)\n\tRF_AccessStripeMapHeader_t *asm_h;\n\tint     prbuf;\t\t/* flag to print buffer pointers */\n{\n\tint     i;\n\tRF_AccessStripeMap_t *asmap = asm_h->stripeMap;\n\tRF_PhysDiskAddr_t *p;\n\tprintf(\"%d stripes total\\n\", (int) asm_h->numStripes);\n\tfor (; asmap; asmap = asmap->next) {\n\t\t/* printf(\"Num failures: %d\\n\",asmap->numDataFailed); */\n\t\t/* printf(\"Num sectors:\n\t\t * %d\\n\",(int)asmap->totalSectorsAccessed); */\n\t\tprintf(\"Stripe %d (%d sectors), failures: %d data, %d parity: \",\n\t\t    (int) asmap->stripeID,\n\t\t    (int) asmap->totalSectorsAccessed,\n\t\t    (int) asmap->numDataFailed,\n\t\t    (int) asmap->numParityFailed);\n\t\tif (asmap->parityInfo) {\n\t\t\tprintf(\"Parity [r%d c%d s%d-%d\", asmap->parityInfo->row, asmap->parityInfo->col,\n\t\t\t    (int) asmap->parityInfo->startSector,\n\t\t\t    (int) (asmap->parityInfo->startSector +\n\t\t\t\tasmap->parityInfo->numSector - 1));\n\t\t\tif (prbuf)\n\t\t\t\tprintf(\" b0x%lx\", (unsigned long) asmap->parityInfo->bufPtr);\n\t\t\tif (asmap->parityInfo->next) {\n\t\t\t\tprintf(\", r%d c%d s%d-%d\", asmap->parityInfo->next->row,\n\t\t\t\t    asmap->parityInfo->next->col,\n\t\t\t\t    (int) asmap->parityInfo->next->startSector,\n\t\t\t\t    (int) (asmap->parityInfo->next->startSector +\n\t\t\t\t\tasmap->parityInfo->next->numSector - 1));\n\t\t\t\tif (prbuf)\n\t\t\t\t\tprintf(\" b0x%lx\", (unsigned long) asmap->parityInfo->next->bufPtr);\n\t\t\t\tRF_ASSERT(asmap->parityInfo->next->next == NULL);\n\t\t\t}\n\t\t\tprintf(\"]\\n\\t\");\n\t\t}\n\t\tfor (i = 0, p = asmap->physInfo; p; p = p->next, i++) {\n\t\t\tprintf(\"SU r%d c%d s%d-%d \", p->row, p->col, (int) p->startSector,\n\t\t\t    (int) (p->startSector + p->numSector - 1));\n\t\t\tif (prbuf)\n\t\t\t\tprintf(\"b0x%lx \", (unsigned long) p->bufPtr);\n\t\t\tif (i && !(i & 1))\n\t\t\t\tprintf(\"\\n\\t\");\n\t\t}\n\t\tprintf(\"\\n\");\n\t\tp = asm_h->stripeMap->failedPDAs[0];\n\t\tif (asm_h->stripeMap->numDataFailed + asm_h->stripeMap->numParityFailed > 1)\n\t\t\tprintf(\"[multiple failures]\\n\");\n\t\telse\n\t\t\tif (asm_h->stripeMap->numDataFailed + asm_h->stripeMap->numParityFailed > 0)\n\t\t\t\tprintf(\"\\t[Failed PDA: r%d c%d s%d-%d]\\n\", p->row, p->col,\n\t\t\t\t    (int) p->startSector, (int) (p->startSector + p->numSector - 1));\n\t}\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "caddr_t buffer;",
            "RF_AccessStripeMap_t *\nrf_DuplicateASM(asmap)\n\tRF_AccessStripeMap_t *asmap;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_freelist.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\ncaddr_t buffer;\nRF_AccessStripeMap_t *\nrf_DuplicateASM(asmap)\n\tRF_AccessStripeMap_t *asmap;\n\nvoid \nrf_PrintFullAccessStripeMap(asm_h, prbuf)\n\tRF_AccessStripeMapHeader_t *asm_h;\n\tint     prbuf;\t\t/* flag to print buffer pointers */\n{\n\tint     i;\n\tRF_AccessStripeMap_t *asmap = asm_h->stripeMap;\n\tRF_PhysDiskAddr_t *p;\n\tprintf(\"%d stripes total\\n\", (int) asm_h->numStripes);\n\tfor (; asmap; asmap = asmap->next) {\n\t\t/* printf(\"Num failures: %d\\n\",asmap->numDataFailed); */\n\t\t/* printf(\"Num sectors:\n\t\t * %d\\n\",(int)asmap->totalSectorsAccessed); */\n\t\tprintf(\"Stripe %d (%d sectors), failures: %d data, %d parity: \",\n\t\t    (int) asmap->stripeID,\n\t\t    (int) asmap->totalSectorsAccessed,\n\t\t    (int) asmap->numDataFailed,\n\t\t    (int) asmap->numParityFailed);\n\t\tif (asmap->parityInfo) {\n\t\t\tprintf(\"Parity [r%d c%d s%d-%d\", asmap->parityInfo->row, asmap->parityInfo->col,\n\t\t\t    (int) asmap->parityInfo->startSector,\n\t\t\t    (int) (asmap->parityInfo->startSector +\n\t\t\t\tasmap->parityInfo->numSector - 1));\n\t\t\tif (prbuf)\n\t\t\t\tprintf(\" b0x%lx\", (unsigned long) asmap->parityInfo->bufPtr);\n\t\t\tif (asmap->parityInfo->next) {\n\t\t\t\tprintf(\", r%d c%d s%d-%d\", asmap->parityInfo->next->row,\n\t\t\t\t    asmap->parityInfo->next->col,\n\t\t\t\t    (int) asmap->parityInfo->next->startSector,\n\t\t\t\t    (int) (asmap->parityInfo->next->startSector +\n\t\t\t\t\tasmap->parityInfo->next->numSector - 1));\n\t\t\t\tif (prbuf)\n\t\t\t\t\tprintf(\" b0x%lx\", (unsigned long) asmap->parityInfo->next->bufPtr);\n\t\t\t\tRF_ASSERT(asmap->parityInfo->next->next == NULL);\n\t\t\t}\n\t\t\tprintf(\"]\\n\\t\");\n\t\t}\n\t\tfor (i = 0, p = asmap->physInfo; p; p = p->next, i++) {\n\t\t\tprintf(\"SU r%d c%d s%d-%d \", p->row, p->col, (int) p->startSector,\n\t\t\t    (int) (p->startSector + p->numSector - 1));\n\t\t\tif (prbuf)\n\t\t\t\tprintf(\"b0x%lx \", (unsigned long) p->bufPtr);\n\t\t\tif (i && !(i & 1))\n\t\t\t\tprintf(\"\\n\\t\");\n\t\t}\n\t\tprintf(\"\\n\");\n\t\tp = asm_h->stripeMap->failedPDAs[0];\n\t\tif (asm_h->stripeMap->numDataFailed + asm_h->stripeMap->numParityFailed > 1)\n\t\t\tprintf(\"[multiple failures]\\n\");\n\t\telse\n\t\t\tif (asm_h->stripeMap->numDataFailed + asm_h->stripeMap->numParityFailed > 0)\n\t\t\t\tprintf(\"\\t[Failed PDA: r%d c%d s%d-%d]\\n\", p->row, p->col,\n\t\t\t\t    (int) p->startSector, (int) (p->startSector + p->numSector - 1));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Second asm:\\n\""
          ],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "0"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG",
          "args": [
            "\"GenerateFailedAccessASMs: did not find failedPDA in asm list\\n\""
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_PDAOverlap",
          "args": [
            "layoutPtr",
            "pda",
            "failedPDA"
          ],
          "line": 1006
        },
        "resolved": true,
        "details": {
          "function_name": "rf_PDAOverlap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagutils.c",
          "lines": "856-868",
          "snippet": "int \nrf_PDAOverlap(\n    RF_RaidLayout_t * layoutPtr,\n    RF_PhysDiskAddr_t * src,\n    RF_PhysDiskAddr_t * dest)\n{\n\tRF_SectorNum_t soffs = rf_StripeUnitOffset(layoutPtr, src->startSector);\n\tRF_SectorNum_t doffs = rf_StripeUnitOffset(layoutPtr, dest->startSector);\n\t/* use -1 to be sure we stay within SU */\n\tRF_SectorNum_t send = rf_StripeUnitOffset(layoutPtr, src->startSector + src->numSector - 1);\n\tRF_SectorNum_t dend = rf_StripeUnitOffset(layoutPtr, dest->startSector + dest->numSector - 1);\n\treturn ((RF_MAX(soffs, doffs) <= RF_MIN(send, dend)) ? 1 : 0);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_archs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_map.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nint \nrf_PDAOverlap(\n    RF_RaidLayout_t * layoutPtr,\n    RF_PhysDiskAddr_t * src,\n    RF_PhysDiskAddr_t * dest)\n{\n\tRF_SectorNum_t soffs = rf_StripeUnitOffset(layoutPtr, src->startSector);\n\tRF_SectorNum_t doffs = rf_StripeUnitOffset(layoutPtr, dest->startSector);\n\t/* use -1 to be sure we stay within SU */\n\tRF_SectorNum_t send = rf_StripeUnitOffset(layoutPtr, src->startSector + src->numSector - 1);\n\tRF_SectorNum_t dend = rf_StripeUnitOffset(layoutPtr, dest->startSector + dest->numSector - 1);\n\treturn ((RF_MAX(soffs, doffs) <= RF_MIN(send, dend)) ? 1 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToByte",
          "args": [
            "raidPtr",
            "pda->numSector"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToByte",
          "args": [
            "raidPtr",
            "pda->numSector"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToByte",
          "args": [
            "raidPtr",
            "numSect[0] + numSect[1] + numParitySect"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_MallocAndAdd",
          "args": [
            "rdBuf",
            "rf_RaidAddressToByte(raidPtr, numSect[0] + numSect[1] + numParitySect)",
            "(char *), allocList"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToByte",
          "args": [
            "raidPtr",
            "numSect[0] + numSect[1] + numParitySect"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RangeRestrictPDA",
          "args": [
            "raidPtr",
            "failedPDA",
            "pda",
            "RF_RESTRICT_NOBUFFER",
            "0"
          ],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "rf_RangeRestrictPDA",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagutils.c",
          "lines": "1050-1075",
          "snippet": "void \nrf_RangeRestrictPDA(\n    RF_Raid_t * raidPtr,\n    RF_PhysDiskAddr_t * src,\n    RF_PhysDiskAddr_t * dest,\n    int dobuffer,\n    int doraidaddr)\n{\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\tRF_SectorNum_t soffs = rf_StripeUnitOffset(layoutPtr, src->startSector);\n\tRF_SectorNum_t doffs = rf_StripeUnitOffset(layoutPtr, dest->startSector);\n\tRF_SectorNum_t send = rf_StripeUnitOffset(layoutPtr, src->startSector + src->numSector - 1);\t/* use -1 to be sure we\n\t\t\t\t\t\t\t\t\t\t\t\t\t * stay within SU */\n\tRF_SectorNum_t dend = rf_StripeUnitOffset(layoutPtr, dest->startSector + dest->numSector - 1);\n\tRF_SectorNum_t subAddr = rf_RaidAddressOfPrevStripeUnitBoundary(layoutPtr, dest->startSector);\t/* stripe unit boundary */\n\n\tdest->startSector = subAddr + RF_MAX(soffs, doffs);\n\tdest->numSector = subAddr + RF_MIN(send, dend) + 1 - dest->startSector;\n\n\tif (dobuffer)\n\t\tdest->bufPtr += (soffs > doffs) ? rf_RaidAddressToByte(raidPtr, soffs - doffs) : 0;\n\tif (doraidaddr) {\n\t\tdest->raidAddress = rf_RaidAddressOfPrevStripeUnitBoundary(layoutPtr, dest->raidAddress) +\n\t\t    rf_StripeUnitOffset(layoutPtr, dest->startSector);\n\t}\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_archs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_map.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nvoid \nrf_RangeRestrictPDA(\n    RF_Raid_t * raidPtr,\n    RF_PhysDiskAddr_t * src,\n    RF_PhysDiskAddr_t * dest,\n    int dobuffer,\n    int doraidaddr)\n{\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\tRF_SectorNum_t soffs = rf_StripeUnitOffset(layoutPtr, src->startSector);\n\tRF_SectorNum_t doffs = rf_StripeUnitOffset(layoutPtr, dest->startSector);\n\tRF_SectorNum_t send = rf_StripeUnitOffset(layoutPtr, src->startSector + src->numSector - 1);\t/* use -1 to be sure we\n\t\t\t\t\t\t\t\t\t\t\t\t\t * stay within SU */\n\tRF_SectorNum_t dend = rf_StripeUnitOffset(layoutPtr, dest->startSector + dest->numSector - 1);\n\tRF_SectorNum_t subAddr = rf_RaidAddressOfPrevStripeUnitBoundary(layoutPtr, dest->startSector);\t/* stripe unit boundary */\n\n\tdest->startSector = subAddr + RF_MAX(soffs, doffs);\n\tdest->numSector = subAddr + RF_MIN(send, dend) + 1 - dest->startSector;\n\n\tif (dobuffer)\n\t\tdest->bufPtr += (soffs > doffs) ? rf_RaidAddressToByte(raidPtr, soffs - doffs) : 0;\n\tif (doraidaddr) {\n\t\tdest->raidAddress = rf_RaidAddressOfPrevStripeUnitBoundary(layoutPtr, dest->raidAddress) +\n\t\t    rf_StripeUnitOffset(layoutPtr, dest->startSector);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_MapAccess",
          "args": [
            "raidPtr",
            "eosStartAddr",
            "eosAddr - eosStartAddr",
            "NULL",
            "RF_DONT_REMAP"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_MapAccess",
          "args": [
            "raidPtr",
            "sosAddr",
            "sosEndAddr - sosAddr",
            "NULL",
            "RF_DONT_REMAP"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressOfNextStripeBoundary",
          "args": [
            "layoutPtr",
            "asmap->raidAddress"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_MAX",
          "args": [
            "asmap->endRaidAddress",
            "rf_RaidAddressOfNextStripeUnitBoundary(layoutPtr, failedPDA->raidAddress)"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressOfNextStripeUnitBoundary",
          "args": [
            "layoutPtr",
            "failedPDA->raidAddress"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_MIN",
          "args": [
            "asmap->raidAddress",
            "rf_RaidAddressOfPrevStripeUnitBoundary(layoutPtr, failedPDA->raidAddress)"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressOfPrevStripeUnitBoundary",
          "args": [
            "layoutPtr",
            "failedPDA->raidAddress"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressOfPrevStripeBoundary",
          "args": [
            "layoutPtr",
            "asmap->raidAddress"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_map.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void rf_PrintDAG(RF_DagHeader_t *);\nstatic void rf_ValidateVisitedBits(RF_DagHeader_t *);\n\nvoid \nrf_GenerateFailedAccessASMs(\n    RF_Raid_t * raidPtr,\n    RF_AccessStripeMap_t * asmap,\n    RF_PhysDiskAddr_t * failedPDA,\n    RF_DagHeader_t * dag_h,\n    RF_AccessStripeMapHeader_t ** new_asm_h,\n    int *nXorBufs,\n    char **rpBufPtr,\n    char *overlappingPDAs,\n    RF_AllocListElem_t * allocList)\n{\n\tRF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);\n\n\t/* s=start, e=end, s=stripe, a=access, f=failed, su=stripe unit */\n\tRF_RaidAddr_t sosAddr, sosEndAddr, eosStartAddr, eosAddr;\n\n\tRF_SectorCount_t numSect[2], numParitySect;\n\tRF_PhysDiskAddr_t *pda;\n\tchar   *rdBuf, *bufP;\n\tint     foundit, i;\n\n\tbufP = NULL;\n\tfoundit = 0;\n\t/* first compute the following raid addresses: start of stripe,\n\t * (sosAddr) MIN(start of access, start of failed SU),   (sosEndAddr)\n\t * MAX(end of access, end of failed SU),       (eosStartAddr) end of\n\t * stripe (i.e. start of next stripe)   (eosAddr) */\n\tsosAddr = rf_RaidAddressOfPrevStripeBoundary(layoutPtr, asmap->raidAddress);\n\tsosEndAddr = RF_MIN(asmap->raidAddress, rf_RaidAddressOfPrevStripeUnitBoundary(layoutPtr, failedPDA->raidAddress));\n\teosStartAddr = RF_MAX(asmap->endRaidAddress, rf_RaidAddressOfNextStripeUnitBoundary(layoutPtr, failedPDA->raidAddress));\n\teosAddr = rf_RaidAddressOfNextStripeBoundary(layoutPtr, asmap->raidAddress);\n\n\t/* now generate access stripe maps for each of the above regions of\n\t * the stripe.  Use a dummy (NULL) buf ptr for now */\n\n\tnew_asm_h[0] = (sosAddr != sosEndAddr) ? rf_MapAccess(raidPtr, sosAddr, sosEndAddr - sosAddr, NULL, RF_DONT_REMAP) : NULL;\n\tnew_asm_h[1] = (eosStartAddr != eosAddr) ? rf_MapAccess(raidPtr, eosStartAddr, eosAddr - eosStartAddr, NULL, RF_DONT_REMAP) : NULL;\n\n\t/* walk through the PDAs and range-restrict each SU to the region of\n\t * the SU touched on the failed PDA.  also compute total data buffer\n\t * space requirements in this step.  Ignore the parity for now. */\n\n\tnumSect[0] = numSect[1] = 0;\n\tif (new_asm_h[0]) {\n\t\tnew_asm_h[0]->next = dag_h->asmList;\n\t\tdag_h->asmList = new_asm_h[0];\n\t\tfor (pda = new_asm_h[0]->stripeMap->physInfo; pda; pda = pda->next) {\n\t\t\trf_RangeRestrictPDA(raidPtr, failedPDA, pda, RF_RESTRICT_NOBUFFER, 0);\n\t\t\tnumSect[0] += pda->numSector;\n\t\t}\n\t}\n\tif (new_asm_h[1]) {\n\t\tnew_asm_h[1]->next = dag_h->asmList;\n\t\tdag_h->asmList = new_asm_h[1];\n\t\tfor (pda = new_asm_h[1]->stripeMap->physInfo; pda; pda = pda->next) {\n\t\t\trf_RangeRestrictPDA(raidPtr, failedPDA, pda, RF_RESTRICT_NOBUFFER, 0);\n\t\t\tnumSect[1] += pda->numSector;\n\t\t}\n\t}\n\tnumParitySect = failedPDA->numSector;\n\n\t/* allocate buffer space for the data & parity we have to read to\n\t * recover from the failure */\n\n\tif (numSect[0] + numSect[1] + ((rpBufPtr) ? numParitySect : 0)) {\t/* don't allocate parity\n\t\t\t\t\t\t\t\t\t\t * buf if not needed */\n\t\tRF_MallocAndAdd(rdBuf, rf_RaidAddressToByte(raidPtr, numSect[0] + numSect[1] + numParitySect), (char *), allocList);\n\t\tbufP = rdBuf;\n\t\tif (rf_degDagDebug)\n\t\t\tprintf(\"Newly allocated buffer (%d bytes) is 0x%lx\\n\",\n\t\t\t    (int) rf_RaidAddressToByte(raidPtr, numSect[0] + numSect[1] + numParitySect), (unsigned long) bufP);\n\t}\n\t/* now walk through the pdas one last time and assign buffer pointers\n\t * (ugh!).  Again, ignore the parity.  also, count nodes to find out\n\t * how many bufs need to be xored together */\n\t(*nXorBufs) = 1;\t/* in read case, 1 is for parity.  In write\n\t\t\t\t * case, 1 is for failed data */\n\tif (new_asm_h[0]) {\n\t\tfor (pda = new_asm_h[0]->stripeMap->physInfo; pda; pda = pda->next) {\n\t\t\tpda->bufPtr = bufP;\n\t\t\tbufP += rf_RaidAddressToByte(raidPtr, pda->numSector);\n\t\t}\n\t\t*nXorBufs += new_asm_h[0]->stripeMap->numStripeUnitsAccessed;\n\t}\n\tif (new_asm_h[1]) {\n\t\tfor (pda = new_asm_h[1]->stripeMap->physInfo; pda; pda = pda->next) {\n\t\t\tpda->bufPtr = bufP;\n\t\t\tbufP += rf_RaidAddressToByte(raidPtr, pda->numSector);\n\t\t}\n\t\t(*nXorBufs) += new_asm_h[1]->stripeMap->numStripeUnitsAccessed;\n\t}\n\tif (rpBufPtr)\n\t\t*rpBufPtr = bufP;\t/* the rest of the buffer is for\n\t\t\t\t\t * parity */\n\n\t/* the last step is to figure out how many more distinct buffers need\n\t * to get xor'd to produce the missing unit.  there's one for each\n\t * user-data read node that overlaps the portion of the failed unit\n\t * being accessed */\n\n\tfor (foundit = i = 0, pda = asmap->physInfo; pda; i++, pda = pda->next) {\n\t\tif (pda == failedPDA) {\n\t\t\ti--;\n\t\t\tfoundit = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (rf_PDAOverlap(layoutPtr, pda, failedPDA)) {\n\t\t\toverlappingPDAs[i] = 1;\n\t\t\t(*nXorBufs)++;\n\t\t}\n\t}\n\tif (!foundit) {\n\t\tRF_ERRORMSG(\"GenerateFailedAccessASMs: did not find failedPDA in asm list\\n\");\n\t\tRF_ASSERT(0);\n\t}\n\tif (rf_degDagDebug) {\n\t\tif (new_asm_h[0]) {\n\t\t\tprintf(\"First asm:\\n\");\n\t\t\trf_PrintFullAccessStripeMap(new_asm_h[0], 1);\n\t\t}\n\t\tif (new_asm_h[1]) {\n\t\t\tprintf(\"Second asm:\\n\");\n\t\t\trf_PrintFullAccessStripeMap(new_asm_h[1], 1);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "rf_PDAOverlap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagutils.c",
    "lines": "856-868",
    "snippet": "int \nrf_PDAOverlap(\n    RF_RaidLayout_t * layoutPtr,\n    RF_PhysDiskAddr_t * src,\n    RF_PhysDiskAddr_t * dest)\n{\n\tRF_SectorNum_t soffs = rf_StripeUnitOffset(layoutPtr, src->startSector);\n\tRF_SectorNum_t doffs = rf_StripeUnitOffset(layoutPtr, dest->startSector);\n\t/* use -1 to be sure we stay within SU */\n\tRF_SectorNum_t send = rf_StripeUnitOffset(layoutPtr, src->startSector + src->numSector - 1);\n\tRF_SectorNum_t dend = rf_StripeUnitOffset(layoutPtr, dest->startSector + dest->numSector - 1);\n\treturn ((RF_MAX(soffs, doffs) <= RF_MIN(send, dend)) ? 1 : 0);\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_MIN",
          "args": [
            "send",
            "dend"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_MAX",
          "args": [
            "soffs",
            "doffs"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_StripeUnitOffset",
          "args": [
            "layoutPtr",
            "dest->startSector + dest->numSector - 1"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_StripeUnitOffset",
          "args": [
            "layoutPtr",
            "src->startSector + src->numSector - 1"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_StripeUnitOffset",
          "args": [
            "layoutPtr",
            "dest->startSector"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_StripeUnitOffset",
          "args": [
            "layoutPtr",
            "src->startSector"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_map.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nint \nrf_PDAOverlap(\n    RF_RaidLayout_t * layoutPtr,\n    RF_PhysDiskAddr_t * src,\n    RF_PhysDiskAddr_t * dest)\n{\n\tRF_SectorNum_t soffs = rf_StripeUnitOffset(layoutPtr, src->startSector);\n\tRF_SectorNum_t doffs = rf_StripeUnitOffset(layoutPtr, dest->startSector);\n\t/* use -1 to be sure we stay within SU */\n\tRF_SectorNum_t send = rf_StripeUnitOffset(layoutPtr, src->startSector + src->numSector - 1);\n\tRF_SectorNum_t dend = rf_StripeUnitOffset(layoutPtr, dest->startSector + dest->numSector - 1);\n\treturn ((RF_MAX(soffs, doffs) <= RF_MIN(send, dend)) ? 1 : 0);\n}"
  },
  {
    "function_name": "rf_MapUnaccessedPortionOfStripe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagutils.c",
    "lines": "799-851",
    "snippet": "void \nrf_MapUnaccessedPortionOfStripe(\n    RF_Raid_t * raidPtr,\n    RF_RaidLayout_t * layoutPtr,/* in: layout information */\n    RF_AccessStripeMap_t * asmap,\t/* in: access stripe map */\n    RF_DagHeader_t * dag_h,\t/* in: header of the dag to create */\n    RF_AccessStripeMapHeader_t ** new_asm_h,\t/* in: ptr to array of 2\n\t\t\t\t\t\t * headers, to be filled in */\n    int *nRodNodes,\t\t/* out: num nodes to be generated to read\n\t\t\t\t * unaccessed data */\n    char **sosBuffer,\t\t/* out: pointers to newly allocated buffer */\n    char **eosBuffer,\n    RF_AllocListElem_t * allocList)\n{\n\tRF_RaidAddr_t sosRaidAddress, eosRaidAddress;\n\tRF_SectorNum_t sosNumSector, eosNumSector;\n\n\tRF_ASSERT(asmap->numStripeUnitsAccessed > (layoutPtr->numDataCol / 2));\n\t/* generate an access map for the region of the array from start of\n\t * stripe to start of access */\n\tnew_asm_h[0] = new_asm_h[1] = NULL;\n\t*nRodNodes = 0;\n\tif (!rf_RaidAddressStripeAligned(layoutPtr, asmap->raidAddress)) {\n\t\tsosRaidAddress = rf_RaidAddressOfPrevStripeBoundary(layoutPtr, asmap->raidAddress);\n\t\tsosNumSector = asmap->raidAddress - sosRaidAddress;\n\t\tRF_MallocAndAdd(*sosBuffer, rf_RaidAddressToByte(raidPtr, sosNumSector), (char *), allocList);\n\t\tnew_asm_h[0] = rf_MapAccess(raidPtr, sosRaidAddress, sosNumSector, *sosBuffer, RF_DONT_REMAP);\n\t\tnew_asm_h[0]->next = dag_h->asmList;\n\t\tdag_h->asmList = new_asm_h[0];\n\t\t*nRodNodes += new_asm_h[0]->stripeMap->numStripeUnitsAccessed;\n\n\t\tRF_ASSERT(new_asm_h[0]->stripeMap->next == NULL);\n\t\t/* we're totally within one stripe here */\n\t\tif (asmap->flags & RF_ASM_REDIR_LARGE_WRITE)\n\t\t\trf_redirect_asm(raidPtr, new_asm_h[0]->stripeMap);\n\t}\n\t/* generate an access map for the region of the array from end of\n\t * access to end of stripe */\n\tif (!rf_RaidAddressStripeAligned(layoutPtr, asmap->endRaidAddress)) {\n\t\teosRaidAddress = asmap->endRaidAddress;\n\t\teosNumSector = rf_RaidAddressOfNextStripeBoundary(layoutPtr, eosRaidAddress) - eosRaidAddress;\n\t\tRF_MallocAndAdd(*eosBuffer, rf_RaidAddressToByte(raidPtr, eosNumSector), (char *), allocList);\n\t\tnew_asm_h[1] = rf_MapAccess(raidPtr, eosRaidAddress, eosNumSector, *eosBuffer, RF_DONT_REMAP);\n\t\tnew_asm_h[1]->next = dag_h->asmList;\n\t\tdag_h->asmList = new_asm_h[1];\n\t\t*nRodNodes += new_asm_h[1]->stripeMap->numStripeUnitsAccessed;\n\n\t\tRF_ASSERT(new_asm_h[1]->stripeMap->next == NULL);\n\t\t/* we're totally within one stripe here */\n\t\tif (asmap->flags & RF_ASM_REDIR_LARGE_WRITE)\n\t\t\trf_redirect_asm(raidPtr, new_asm_h[1]->stripeMap);\n\t}\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void rf_PrintDAG(RF_DagHeader_t *);",
      "static void rf_ValidateVisitedBits(RF_DagHeader_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_redirect_asm",
          "args": [
            "raidPtr",
            "new_asm_h[1]->stripeMap"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "rf_redirect_asm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagutils.c",
          "lines": "742-788",
          "snippet": "void \nrf_redirect_asm(\n    RF_Raid_t * raidPtr,\n    RF_AccessStripeMap_t * asmap)\n{\n\tint     ds = (raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE) ? 1 : 0;\n\tint     row = asmap->physInfo->row;\n\tint     fcol = raidPtr->reconControl[row]->fcol;\n\tint     srow = raidPtr->reconControl[row]->spareRow;\n\tint     scol = raidPtr->reconControl[row]->spareCol;\n\tRF_PhysDiskAddr_t *pda;\n\n\tRF_ASSERT(raidPtr->status[row] == rf_rs_reconstructing);\n\tfor (pda = asmap->physInfo; pda; pda = pda->next) {\n\t\tif (pda->col == fcol) {\n\t\t\tif (rf_dagDebug) {\n\t\t\t\tif (!rf_CheckRUReconstructed(raidPtr->reconControl[row]->reconMap,\n\t\t\t\t\tpda->startSector)) {\n\t\t\t\t\tRF_PANIC();\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* printf(\"Remapped data for large write\\n\"); */\n\t\t\tif (ds) {\n\t\t\t\traidPtr->Layout.map->MapSector(raidPtr, pda->raidAddress,\n\t\t\t\t    &pda->row, &pda->col, &pda->startSector, RF_REMAP);\n\t\t\t} else {\n\t\t\t\tpda->row = srow;\n\t\t\t\tpda->col = scol;\n\t\t\t}\n\t\t}\n\t}\n\tfor (pda = asmap->parityInfo; pda; pda = pda->next) {\n\t\tif (pda->col == fcol) {\n\t\t\tif (rf_dagDebug) {\n\t\t\t\tif (!rf_CheckRUReconstructed(raidPtr->reconControl[row]->reconMap, pda->startSector)) {\n\t\t\t\t\tRF_PANIC();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ds) {\n\t\t\t(raidPtr->Layout.map->MapParity) (raidPtr, pda->raidAddress, &pda->row, &pda->col, &pda->startSector, RF_REMAP);\n\t\t} else {\n\t\t\tpda->row = srow;\n\t\t\tpda->col = scol;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_archs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_map.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nvoid \nrf_redirect_asm(\n    RF_Raid_t * raidPtr,\n    RF_AccessStripeMap_t * asmap)\n{\n\tint     ds = (raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE) ? 1 : 0;\n\tint     row = asmap->physInfo->row;\n\tint     fcol = raidPtr->reconControl[row]->fcol;\n\tint     srow = raidPtr->reconControl[row]->spareRow;\n\tint     scol = raidPtr->reconControl[row]->spareCol;\n\tRF_PhysDiskAddr_t *pda;\n\n\tRF_ASSERT(raidPtr->status[row] == rf_rs_reconstructing);\n\tfor (pda = asmap->physInfo; pda; pda = pda->next) {\n\t\tif (pda->col == fcol) {\n\t\t\tif (rf_dagDebug) {\n\t\t\t\tif (!rf_CheckRUReconstructed(raidPtr->reconControl[row]->reconMap,\n\t\t\t\t\tpda->startSector)) {\n\t\t\t\t\tRF_PANIC();\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* printf(\"Remapped data for large write\\n\"); */\n\t\t\tif (ds) {\n\t\t\t\traidPtr->Layout.map->MapSector(raidPtr, pda->raidAddress,\n\t\t\t\t    &pda->row, &pda->col, &pda->startSector, RF_REMAP);\n\t\t\t} else {\n\t\t\t\tpda->row = srow;\n\t\t\t\tpda->col = scol;\n\t\t\t}\n\t\t}\n\t}\n\tfor (pda = asmap->parityInfo; pda; pda = pda->next) {\n\t\tif (pda->col == fcol) {\n\t\t\tif (rf_dagDebug) {\n\t\t\t\tif (!rf_CheckRUReconstructed(raidPtr->reconControl[row]->reconMap, pda->startSector)) {\n\t\t\t\t\tRF_PANIC();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ds) {\n\t\t\t(raidPtr->Layout.map->MapParity) (raidPtr, pda->raidAddress, &pda->row, &pda->col, &pda->startSector, RF_REMAP);\n\t\t} else {\n\t\t\tpda->row = srow;\n\t\t\tpda->col = scol;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "new_asm_h[1]->stripeMap->next == NULL"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_MapAccess",
          "args": [
            "raidPtr",
            "eosRaidAddress",
            "eosNumSector",
            "*eosBuffer",
            "RF_DONT_REMAP"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_MallocAndAdd",
          "args": [
            "*eosBuffer",
            "rf_RaidAddressToByte(raidPtr, eosNumSector)",
            "(char *), allocList"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToByte",
          "args": [
            "raidPtr",
            "eosNumSector"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressOfNextStripeBoundary",
          "args": [
            "layoutPtr",
            "eosRaidAddress"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressStripeAligned",
          "args": [
            "layoutPtr",
            "asmap->endRaidAddress"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "new_asm_h[0]->stripeMap->next == NULL"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_MapAccess",
          "args": [
            "raidPtr",
            "sosRaidAddress",
            "sosNumSector",
            "*sosBuffer",
            "RF_DONT_REMAP"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_MallocAndAdd",
          "args": [
            "*sosBuffer",
            "rf_RaidAddressToByte(raidPtr, sosNumSector)",
            "(char *), allocList"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToByte",
          "args": [
            "raidPtr",
            "sosNumSector"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressOfPrevStripeBoundary",
          "args": [
            "layoutPtr",
            "asmap->raidAddress"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressStripeAligned",
          "args": [
            "layoutPtr",
            "asmap->raidAddress"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "asmap->numStripeUnitsAccessed > (layoutPtr->numDataCol / 2)"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_map.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void rf_PrintDAG(RF_DagHeader_t *);\nstatic void rf_ValidateVisitedBits(RF_DagHeader_t *);\n\nvoid \nrf_MapUnaccessedPortionOfStripe(\n    RF_Raid_t * raidPtr,\n    RF_RaidLayout_t * layoutPtr,/* in: layout information */\n    RF_AccessStripeMap_t * asmap,\t/* in: access stripe map */\n    RF_DagHeader_t * dag_h,\t/* in: header of the dag to create */\n    RF_AccessStripeMapHeader_t ** new_asm_h,\t/* in: ptr to array of 2\n\t\t\t\t\t\t * headers, to be filled in */\n    int *nRodNodes,\t\t/* out: num nodes to be generated to read\n\t\t\t\t * unaccessed data */\n    char **sosBuffer,\t\t/* out: pointers to newly allocated buffer */\n    char **eosBuffer,\n    RF_AllocListElem_t * allocList)\n{\n\tRF_RaidAddr_t sosRaidAddress, eosRaidAddress;\n\tRF_SectorNum_t sosNumSector, eosNumSector;\n\n\tRF_ASSERT(asmap->numStripeUnitsAccessed > (layoutPtr->numDataCol / 2));\n\t/* generate an access map for the region of the array from start of\n\t * stripe to start of access */\n\tnew_asm_h[0] = new_asm_h[1] = NULL;\n\t*nRodNodes = 0;\n\tif (!rf_RaidAddressStripeAligned(layoutPtr, asmap->raidAddress)) {\n\t\tsosRaidAddress = rf_RaidAddressOfPrevStripeBoundary(layoutPtr, asmap->raidAddress);\n\t\tsosNumSector = asmap->raidAddress - sosRaidAddress;\n\t\tRF_MallocAndAdd(*sosBuffer, rf_RaidAddressToByte(raidPtr, sosNumSector), (char *), allocList);\n\t\tnew_asm_h[0] = rf_MapAccess(raidPtr, sosRaidAddress, sosNumSector, *sosBuffer, RF_DONT_REMAP);\n\t\tnew_asm_h[0]->next = dag_h->asmList;\n\t\tdag_h->asmList = new_asm_h[0];\n\t\t*nRodNodes += new_asm_h[0]->stripeMap->numStripeUnitsAccessed;\n\n\t\tRF_ASSERT(new_asm_h[0]->stripeMap->next == NULL);\n\t\t/* we're totally within one stripe here */\n\t\tif (asmap->flags & RF_ASM_REDIR_LARGE_WRITE)\n\t\t\trf_redirect_asm(raidPtr, new_asm_h[0]->stripeMap);\n\t}\n\t/* generate an access map for the region of the array from end of\n\t * access to end of stripe */\n\tif (!rf_RaidAddressStripeAligned(layoutPtr, asmap->endRaidAddress)) {\n\t\teosRaidAddress = asmap->endRaidAddress;\n\t\teosNumSector = rf_RaidAddressOfNextStripeBoundary(layoutPtr, eosRaidAddress) - eosRaidAddress;\n\t\tRF_MallocAndAdd(*eosBuffer, rf_RaidAddressToByte(raidPtr, eosNumSector), (char *), allocList);\n\t\tnew_asm_h[1] = rf_MapAccess(raidPtr, eosRaidAddress, eosNumSector, *eosBuffer, RF_DONT_REMAP);\n\t\tnew_asm_h[1]->next = dag_h->asmList;\n\t\tdag_h->asmList = new_asm_h[1];\n\t\t*nRodNodes += new_asm_h[1]->stripeMap->numStripeUnitsAccessed;\n\n\t\tRF_ASSERT(new_asm_h[1]->stripeMap->next == NULL);\n\t\t/* we're totally within one stripe here */\n\t\tif (asmap->flags & RF_ASM_REDIR_LARGE_WRITE)\n\t\t\trf_redirect_asm(raidPtr, new_asm_h[1]->stripeMap);\n\t}\n}"
  },
  {
    "function_name": "rf_redirect_asm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagutils.c",
    "lines": "742-788",
    "snippet": "void \nrf_redirect_asm(\n    RF_Raid_t * raidPtr,\n    RF_AccessStripeMap_t * asmap)\n{\n\tint     ds = (raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE) ? 1 : 0;\n\tint     row = asmap->physInfo->row;\n\tint     fcol = raidPtr->reconControl[row]->fcol;\n\tint     srow = raidPtr->reconControl[row]->spareRow;\n\tint     scol = raidPtr->reconControl[row]->spareCol;\n\tRF_PhysDiskAddr_t *pda;\n\n\tRF_ASSERT(raidPtr->status[row] == rf_rs_reconstructing);\n\tfor (pda = asmap->physInfo; pda; pda = pda->next) {\n\t\tif (pda->col == fcol) {\n\t\t\tif (rf_dagDebug) {\n\t\t\t\tif (!rf_CheckRUReconstructed(raidPtr->reconControl[row]->reconMap,\n\t\t\t\t\tpda->startSector)) {\n\t\t\t\t\tRF_PANIC();\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* printf(\"Remapped data for large write\\n\"); */\n\t\t\tif (ds) {\n\t\t\t\traidPtr->Layout.map->MapSector(raidPtr, pda->raidAddress,\n\t\t\t\t    &pda->row, &pda->col, &pda->startSector, RF_REMAP);\n\t\t\t} else {\n\t\t\t\tpda->row = srow;\n\t\t\t\tpda->col = scol;\n\t\t\t}\n\t\t}\n\t}\n\tfor (pda = asmap->parityInfo; pda; pda = pda->next) {\n\t\tif (pda->col == fcol) {\n\t\t\tif (rf_dagDebug) {\n\t\t\t\tif (!rf_CheckRUReconstructed(raidPtr->reconControl[row]->reconMap, pda->startSector)) {\n\t\t\t\t\tRF_PANIC();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ds) {\n\t\t\t(raidPtr->Layout.map->MapParity) (raidPtr, pda->raidAddress, &pda->row, &pda->col, &pda->startSector, RF_REMAP);\n\t\t} else {\n\t\t\tpda->row = srow;\n\t\t\tpda->col = scol;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "raidPtr",
            "pda->raidAddress",
            "&pda->row",
            "&pda->col",
            "&pda->startSector",
            "RF_REMAP"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_PANIC",
          "args": [],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_CheckRUReconstructed",
          "args": [
            "raidPtr->reconControl[row]->reconMap",
            "pda->startSector"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "rf_CheckRUReconstructed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconmap.c",
          "lines": "308-319",
          "snippet": "int \nrf_CheckRUReconstructed(mapPtr, startSector)\n\tRF_ReconMap_t *mapPtr;\n\tRF_SectorNum_t startSector;\n{\n\tRF_ReconMapListElem_t *l;\t/* used for searching */\n\tRF_ReconUnitNum_t i;\n\n\ti = startSector / mapPtr->sectorsPerReconUnit;\n\tl = mapPtr->status[i];\n\treturn ((l == RU_ALL) ? 1 : 0);\n}",
          "includes": [
            "#include \"rf_utils.h\"",
            "#include \"rf_general.h\"",
            "#include <sys/time.h>",
            "#include \"rf_raid.h\""
          ],
          "macros_used": [
            "#define RU_ALL      ((RF_ReconMapListElem_t *) -1)"
          ],
          "globals_used": [
            "static void \ncompact_stat_entry(RF_Raid_t * raidPtr, RF_ReconMap_t * mapPtr,\n    int i);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_utils.h\"\n#include \"rf_general.h\"\n#include <sys/time.h>\n#include \"rf_raid.h\"\n\n#define RU_ALL      ((RF_ReconMapListElem_t *) -1)\n\nstatic void \ncompact_stat_entry(RF_Raid_t * raidPtr, RF_ReconMap_t * mapPtr,\n    int i);\n\nint \nrf_CheckRUReconstructed(mapPtr, startSector)\n\tRF_ReconMap_t *mapPtr;\n\tRF_SectorNum_t startSector;\n{\n\tRF_ReconMapListElem_t *l;\t/* used for searching */\n\tRF_ReconUnitNum_t i;\n\n\ti = startSector / mapPtr->sectorsPerReconUnit;\n\tl = mapPtr->status[i];\n\treturn ((l == RU_ALL) ? 1 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raidPtr->Layout.map->MapSector",
          "args": [
            "raidPtr",
            "pda->raidAddress",
            "&pda->row",
            "&pda->col",
            "&pda->startSector",
            "RF_REMAP"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_PANIC",
          "args": [],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "raidPtr->status[row] == rf_rs_reconstructing"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_map.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nvoid \nrf_redirect_asm(\n    RF_Raid_t * raidPtr,\n    RF_AccessStripeMap_t * asmap)\n{\n\tint     ds = (raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE) ? 1 : 0;\n\tint     row = asmap->physInfo->row;\n\tint     fcol = raidPtr->reconControl[row]->fcol;\n\tint     srow = raidPtr->reconControl[row]->spareRow;\n\tint     scol = raidPtr->reconControl[row]->spareCol;\n\tRF_PhysDiskAddr_t *pda;\n\n\tRF_ASSERT(raidPtr->status[row] == rf_rs_reconstructing);\n\tfor (pda = asmap->physInfo; pda; pda = pda->next) {\n\t\tif (pda->col == fcol) {\n\t\t\tif (rf_dagDebug) {\n\t\t\t\tif (!rf_CheckRUReconstructed(raidPtr->reconControl[row]->reconMap,\n\t\t\t\t\tpda->startSector)) {\n\t\t\t\t\tRF_PANIC();\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* printf(\"Remapped data for large write\\n\"); */\n\t\t\tif (ds) {\n\t\t\t\traidPtr->Layout.map->MapSector(raidPtr, pda->raidAddress,\n\t\t\t\t    &pda->row, &pda->col, &pda->startSector, RF_REMAP);\n\t\t\t} else {\n\t\t\t\tpda->row = srow;\n\t\t\t\tpda->col = scol;\n\t\t\t}\n\t\t}\n\t}\n\tfor (pda = asmap->parityInfo; pda; pda = pda->next) {\n\t\tif (pda->col == fcol) {\n\t\t\tif (rf_dagDebug) {\n\t\t\t\tif (!rf_CheckRUReconstructed(raidPtr->reconControl[row]->reconMap, pda->startSector)) {\n\t\t\t\t\tRF_PANIC();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ds) {\n\t\t\t(raidPtr->Layout.map->MapParity) (raidPtr, pda->raidAddress, &pda->row, &pda->col, &pda->startSector, RF_REMAP);\n\t\t} else {\n\t\t\tpda->row = srow;\n\t\t\tpda->col = scol;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "rf_ValidateDAG",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagutils.c",
    "lines": "635-733",
    "snippet": "int \nrf_ValidateDAG(dag_h)\n\tRF_DagHeader_t *dag_h;\n{\n\tint     i, nodecount;\n\tint    *scount, *acount;/* per-node successor and antecedent counts */\n\tRF_DagNode_t **nodes;\t/* array of ptrs to nodes in dag */\n\tint     retcode = 0;\n\tint     unvisited;\n\tint     commitNodeCount = 0;\n\n\tif (rf_validateVisitedDebug)\n\t\trf_ValidateVisitedBits(dag_h);\n\n\tif (dag_h->numNodesCompleted != 0) {\n\t\tprintf(\"INVALID DAG: num nodes completed is %d, should be 0\\n\", dag_h->numNodesCompleted);\n\t\tretcode = 1;\n\t\tgoto validate_dag_bad;\n\t}\n\tif (dag_h->status != rf_enable) {\n\t\tprintf(\"INVALID DAG: not enabled\\n\");\n\t\tretcode = 1;\n\t\tgoto validate_dag_bad;\n\t}\n\tif (dag_h->numCommits != 0) {\n\t\tprintf(\"INVALID DAG: numCommits != 0 (%d)\\n\", dag_h->numCommits);\n\t\tretcode = 1;\n\t\tgoto validate_dag_bad;\n\t}\n\tif (dag_h->numSuccedents != 1) {\n\t\t/* currently, all dags must have only one succedent */\n\t\tprintf(\"INVALID DAG: numSuccedents !1 (%d)\\n\", dag_h->numSuccedents);\n\t\tretcode = 1;\n\t\tgoto validate_dag_bad;\n\t}\n\tnodecount = rf_AssignNodeNums(dag_h);\n\n\tunvisited = dag_h->succedents[0]->visited;\n\n\tRF_Calloc(scount, nodecount, sizeof(int), (int *));\n\tRF_Calloc(acount, nodecount, sizeof(int), (int *));\n\tRF_Calloc(nodes, nodecount, sizeof(RF_DagNode_t *), (RF_DagNode_t **));\n\tfor (i = 0; i < dag_h->numSuccedents; i++) {\n\t\tif ((dag_h->succedents[i]->visited == unvisited)\n\t\t    && rf_ValidateBranch(dag_h->succedents[i], scount,\n\t\t\tacount, nodes, unvisited)) {\n\t\t\tretcode = 1;\n\t\t}\n\t}\n\t/* start at 1 to skip the header node */\n\tfor (i = 1; i < nodecount; i++) {\n\t\tif (nodes[i]->commitNode)\n\t\t\tcommitNodeCount++;\n\t\tif (nodes[i]->doFunc == NULL) {\n\t\t\tprintf(\"INVALID DAG: node %s has an undefined doFunc\\n\", nodes[i]->name);\n\t\t\tretcode = 1;\n\t\t\tgoto validate_dag_out;\n\t\t}\n\t\tif (nodes[i]->undoFunc == NULL) {\n\t\t\tprintf(\"INVALID DAG: node %s has an undefined doFunc\\n\", nodes[i]->name);\n\t\t\tretcode = 1;\n\t\t\tgoto validate_dag_out;\n\t\t}\n\t\tif (nodes[i]->numAntecedents != scount[nodes[i]->nodeNum]) {\n\t\t\tprintf(\"INVALID DAG: node %s has %d antecedents but appears as a succedent %d times\\n\",\n\t\t\t    nodes[i]->name, nodes[i]->numAntecedents, scount[nodes[i]->nodeNum]);\n\t\t\tretcode = 1;\n\t\t\tgoto validate_dag_out;\n\t\t}\n\t\tif (nodes[i]->numSuccedents != acount[nodes[i]->nodeNum]) {\n\t\t\tprintf(\"INVALID DAG: node %s has %d succedents but appears as an antecedent %d times\\n\",\n\t\t\t    nodes[i]->name, nodes[i]->numSuccedents, acount[nodes[i]->nodeNum]);\n\t\t\tretcode = 1;\n\t\t\tgoto validate_dag_out;\n\t\t}\n\t}\n\n\tif (dag_h->numCommitNodes != commitNodeCount) {\n\t\tprintf(\"INVALID DAG: incorrect commit node count.  hdr->numCommitNodes (%d) found (%d) commit nodes in graph\\n\",\n\t\t    dag_h->numCommitNodes, commitNodeCount);\n\t\tretcode = 1;\n\t\tgoto validate_dag_out;\n\t}\nvalidate_dag_out:\n\tRF_Free(scount, nodecount * sizeof(int));\n\tRF_Free(acount, nodecount * sizeof(int));\n\tRF_Free(nodes, nodecount * sizeof(RF_DagNode_t *));\n\tif (retcode)\n\t\trf_PrintDAGList(dag_h);\n\n\tif (rf_validateVisitedDebug)\n\t\trf_ValidateVisitedBits(dag_h);\n\n\treturn (retcode);\n\nvalidate_dag_bad:\n\trf_PrintDAGList(dag_h);\n\treturn (retcode);\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void rf_RecurPrintDAG(RF_DagNode_t *, int, int);",
      "static void rf_PrintDAG(RF_DagHeader_t *);",
      "static int \nrf_ValidateBranch(RF_DagNode_t *, int *, int *,\n    RF_DagNode_t **, int);",
      "static void rf_ValidateBranchVisitedBits(RF_DagNode_t *, int, int);",
      "static void rf_ValidateVisitedBits(RF_DagHeader_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_PrintDAGList",
          "args": [
            "dag_h"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "rf_PrintDAGList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagutils.c",
          "lines": "509-519",
          "snippet": "void \nrf_PrintDAGList(RF_DagHeader_t * dag_h)\n{\n\tint     i = 0;\n\n\tfor (; dag_h; dag_h = dag_h->next) {\n\t\trf_AssignNodeNums(dag_h);\n\t\tprintf(\"\\n\\nDAG %d IN LIST:\\n\", i++);\n\t\trf_PrintDAG(dag_h);\n\t}\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_archs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void rf_PrintDAG(RF_DagHeader_t *);",
            "static void rf_ValidateVisitedBits(RF_DagHeader_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_map.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void rf_PrintDAG(RF_DagHeader_t *);\nstatic void rf_ValidateVisitedBits(RF_DagHeader_t *);\n\nvoid \nrf_PrintDAGList(RF_DagHeader_t * dag_h)\n{\n\tint     i = 0;\n\n\tfor (; dag_h; dag_h = dag_h->next) {\n\t\trf_AssignNodeNums(dag_h);\n\t\tprintf(\"\\n\\nDAG %d IN LIST:\\n\", i++);\n\t\trf_PrintDAG(dag_h);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_ValidateVisitedBits",
          "args": [
            "dag_h"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "rf_ValidateVisitedBits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagutils.c",
          "lines": "603-618",
          "snippet": "static void \nrf_ValidateVisitedBits(dag)\n\tRF_DagHeader_t *dag;\n{\n\tint     i, unvisited;\n\n\tunvisited = dag->succedents[0]->visited;\n\n\tfor (i = 0; i < dag->numSuccedents; i++) {\n\t\tif (dag->succedents[i] == NULL) {\n\t\t\tprintf(\"dag=%lx dag->succedents[%d] is NULL\\n\", (long) dag, i);\n\t\t\tRF_ASSERT(0);\n\t\t}\n\t\trf_ValidateBranchVisitedBits(dag->succedents[i], unvisited, 0);\n\t}\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_archs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void rf_PrintDAG(RF_DagHeader_t *);",
            "static void rf_ValidateVisitedBits(RF_DagHeader_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_map.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void rf_PrintDAG(RF_DagHeader_t *);\nstatic void rf_ValidateVisitedBits(RF_DagHeader_t *);\n\nstatic void \nrf_ValidateVisitedBits(dag)\n\tRF_DagHeader_t *dag;\n{\n\tint     i, unvisited;\n\n\tunvisited = dag->succedents[0]->visited;\n\n\tfor (i = 0; i < dag->numSuccedents; i++) {\n\t\tif (dag->succedents[i] == NULL) {\n\t\t\tprintf(\"dag=%lx dag->succedents[%d] is NULL\\n\", (long) dag, i);\n\t\t\tRF_ASSERT(0);\n\t\t}\n\t\trf_ValidateBranchVisitedBits(dag->succedents[i], unvisited, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "nodes",
            "nodecount * sizeof(RF_DagNode_t *)"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "acount",
            "nodecount * sizeof(int)"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "scount",
            "nodecount * sizeof(int)"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"INVALID DAG: incorrect commit node count.  hdr->numCommitNodes (%d) found (%d) commit nodes in graph\\n\"",
            "dag_h->numCommitNodes",
            "commitNodeCount"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_ValidateBranch",
          "args": [
            "dag_h->succedents[i]",
            "scount",
            "acount",
            "nodes",
            "unvisited"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "rf_ValidateBranchVisitedBits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagutils.c",
          "lines": "583-599",
          "snippet": "static void \nrf_ValidateBranchVisitedBits(node, unvisited, rl)\n\tRF_DagNode_t *node;\n\tint     unvisited;\n\tint     rl;\n{\n\tint     i;\n\n\tRF_ASSERT(node->visited == unvisited);\n\tfor (i = 0; i < node->numSuccedents; i++) {\n\t\tif (node->succedents[i] == NULL) {\n\t\t\tprintf(\"node=%lx node->succedents[%d] is NULL\\n\", (long) node, i);\n\t\t\tRF_ASSERT(0);\n\t\t}\n\t\trf_ValidateBranchVisitedBits(node->succedents[i], unvisited, rl + 1);\n\t}\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_archs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void rf_RecurPrintDAG(RF_DagNode_t *, int, int);",
            "static int \nrf_ValidateBranch(RF_DagNode_t *, int *, int *,\n    RF_DagNode_t **, int);",
            "static void rf_ValidateBranchVisitedBits(RF_DagNode_t *, int, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_map.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void rf_RecurPrintDAG(RF_DagNode_t *, int, int);\nstatic int \nrf_ValidateBranch(RF_DagNode_t *, int *, int *,\n    RF_DagNode_t **, int);\nstatic void rf_ValidateBranchVisitedBits(RF_DagNode_t *, int, int);\n\nstatic void \nrf_ValidateBranchVisitedBits(node, unvisited, rl)\n\tRF_DagNode_t *node;\n\tint     unvisited;\n\tint     rl;\n{\n\tint     i;\n\n\tRF_ASSERT(node->visited == unvisited);\n\tfor (i = 0; i < node->numSuccedents; i++) {\n\t\tif (node->succedents[i] == NULL) {\n\t\t\tprintf(\"node=%lx node->succedents[%d] is NULL\\n\", (long) node, i);\n\t\t\tRF_ASSERT(0);\n\t\t}\n\t\trf_ValidateBranchVisitedBits(node->succedents[i], unvisited, rl + 1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_Calloc",
          "args": [
            "nodes",
            "nodecount",
            "sizeof(RF_DagNode_t *)",
            "(RF_DagNode_t **)"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Calloc",
          "args": [
            "acount",
            "nodecount",
            "sizeof(int)",
            "(int *)"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Calloc",
          "args": [
            "scount",
            "nodecount",
            "sizeof(int)",
            "(int *)"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_AssignNodeNums",
          "args": [
            "dag_h"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "rf_AssignNodeNums",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagutils.c",
          "lines": "447-464",
          "snippet": "int \nrf_AssignNodeNums(RF_DagHeader_t * dag_h)\n{\n\tint     unvisited, i, nnum;\n\tRF_DagNode_t *node;\n\n\tnnum = 0;\n\tunvisited = dag_h->succedents[0]->visited;\n\n\tdag_h->nodeNum = nnum++;\n\tfor (i = 0; i < dag_h->numSuccedents; i++) {\n\t\tnode = dag_h->succedents[i];\n\t\tif (node->visited == unvisited) {\n\t\t\tnnum = rf_RecurAssignNodeNums(dag_h->succedents[i], nnum, unvisited);\n\t\t}\n\t}\n\treturn (nnum);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_archs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void rf_RecurPrintDAG(RF_DagNode_t *, int, int);",
            "static void rf_PrintDAG(RF_DagHeader_t *);",
            "static int \nrf_ValidateBranch(RF_DagNode_t *, int *, int *,\n    RF_DagNode_t **, int);",
            "static void rf_ValidateBranchVisitedBits(RF_DagNode_t *, int, int);",
            "static void rf_ValidateVisitedBits(RF_DagHeader_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_map.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void rf_RecurPrintDAG(RF_DagNode_t *, int, int);\nstatic void rf_PrintDAG(RF_DagHeader_t *);\nstatic int \nrf_ValidateBranch(RF_DagNode_t *, int *, int *,\n    RF_DagNode_t **, int);\nstatic void rf_ValidateBranchVisitedBits(RF_DagNode_t *, int, int);\nstatic void rf_ValidateVisitedBits(RF_DagHeader_t *);\n\nint \nrf_AssignNodeNums(RF_DagHeader_t * dag_h)\n{\n\tint     unvisited, i, nnum;\n\tRF_DagNode_t *node;\n\n\tnnum = 0;\n\tunvisited = dag_h->succedents[0]->visited;\n\n\tdag_h->nodeNum = nnum++;\n\tfor (i = 0; i < dag_h->numSuccedents; i++) {\n\t\tnode = dag_h->succedents[i];\n\t\tif (node->visited == unvisited) {\n\t\t\tnnum = rf_RecurAssignNodeNums(dag_h->succedents[i], nnum, unvisited);\n\t\t}\n\t}\n\treturn (nnum);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_map.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void rf_RecurPrintDAG(RF_DagNode_t *, int, int);\nstatic void rf_PrintDAG(RF_DagHeader_t *);\nstatic int \nrf_ValidateBranch(RF_DagNode_t *, int *, int *,\n    RF_DagNode_t **, int);\nstatic void rf_ValidateBranchVisitedBits(RF_DagNode_t *, int, int);\nstatic void rf_ValidateVisitedBits(RF_DagHeader_t *);\n\nint \nrf_ValidateDAG(dag_h)\n\tRF_DagHeader_t *dag_h;\n{\n\tint     i, nodecount;\n\tint    *scount, *acount;/* per-node successor and antecedent counts */\n\tRF_DagNode_t **nodes;\t/* array of ptrs to nodes in dag */\n\tint     retcode = 0;\n\tint     unvisited;\n\tint     commitNodeCount = 0;\n\n\tif (rf_validateVisitedDebug)\n\t\trf_ValidateVisitedBits(dag_h);\n\n\tif (dag_h->numNodesCompleted != 0) {\n\t\tprintf(\"INVALID DAG: num nodes completed is %d, should be 0\\n\", dag_h->numNodesCompleted);\n\t\tretcode = 1;\n\t\tgoto validate_dag_bad;\n\t}\n\tif (dag_h->status != rf_enable) {\n\t\tprintf(\"INVALID DAG: not enabled\\n\");\n\t\tretcode = 1;\n\t\tgoto validate_dag_bad;\n\t}\n\tif (dag_h->numCommits != 0) {\n\t\tprintf(\"INVALID DAG: numCommits != 0 (%d)\\n\", dag_h->numCommits);\n\t\tretcode = 1;\n\t\tgoto validate_dag_bad;\n\t}\n\tif (dag_h->numSuccedents != 1) {\n\t\t/* currently, all dags must have only one succedent */\n\t\tprintf(\"INVALID DAG: numSuccedents !1 (%d)\\n\", dag_h->numSuccedents);\n\t\tretcode = 1;\n\t\tgoto validate_dag_bad;\n\t}\n\tnodecount = rf_AssignNodeNums(dag_h);\n\n\tunvisited = dag_h->succedents[0]->visited;\n\n\tRF_Calloc(scount, nodecount, sizeof(int), (int *));\n\tRF_Calloc(acount, nodecount, sizeof(int), (int *));\n\tRF_Calloc(nodes, nodecount, sizeof(RF_DagNode_t *), (RF_DagNode_t **));\n\tfor (i = 0; i < dag_h->numSuccedents; i++) {\n\t\tif ((dag_h->succedents[i]->visited == unvisited)\n\t\t    && rf_ValidateBranch(dag_h->succedents[i], scount,\n\t\t\tacount, nodes, unvisited)) {\n\t\t\tretcode = 1;\n\t\t}\n\t}\n\t/* start at 1 to skip the header node */\n\tfor (i = 1; i < nodecount; i++) {\n\t\tif (nodes[i]->commitNode)\n\t\t\tcommitNodeCount++;\n\t\tif (nodes[i]->doFunc == NULL) {\n\t\t\tprintf(\"INVALID DAG: node %s has an undefined doFunc\\n\", nodes[i]->name);\n\t\t\tretcode = 1;\n\t\t\tgoto validate_dag_out;\n\t\t}\n\t\tif (nodes[i]->undoFunc == NULL) {\n\t\t\tprintf(\"INVALID DAG: node %s has an undefined doFunc\\n\", nodes[i]->name);\n\t\t\tretcode = 1;\n\t\t\tgoto validate_dag_out;\n\t\t}\n\t\tif (nodes[i]->numAntecedents != scount[nodes[i]->nodeNum]) {\n\t\t\tprintf(\"INVALID DAG: node %s has %d antecedents but appears as a succedent %d times\\n\",\n\t\t\t    nodes[i]->name, nodes[i]->numAntecedents, scount[nodes[i]->nodeNum]);\n\t\t\tretcode = 1;\n\t\t\tgoto validate_dag_out;\n\t\t}\n\t\tif (nodes[i]->numSuccedents != acount[nodes[i]->nodeNum]) {\n\t\t\tprintf(\"INVALID DAG: node %s has %d succedents but appears as an antecedent %d times\\n\",\n\t\t\t    nodes[i]->name, nodes[i]->numSuccedents, acount[nodes[i]->nodeNum]);\n\t\t\tretcode = 1;\n\t\t\tgoto validate_dag_out;\n\t\t}\n\t}\n\n\tif (dag_h->numCommitNodes != commitNodeCount) {\n\t\tprintf(\"INVALID DAG: incorrect commit node count.  hdr->numCommitNodes (%d) found (%d) commit nodes in graph\\n\",\n\t\t    dag_h->numCommitNodes, commitNodeCount);\n\t\tretcode = 1;\n\t\tgoto validate_dag_out;\n\t}\nvalidate_dag_out:\n\tRF_Free(scount, nodecount * sizeof(int));\n\tRF_Free(acount, nodecount * sizeof(int));\n\tRF_Free(nodes, nodecount * sizeof(RF_DagNode_t *));\n\tif (retcode)\n\t\trf_PrintDAGList(dag_h);\n\n\tif (rf_validateVisitedDebug)\n\t\trf_ValidateVisitedBits(dag_h);\n\n\treturn (retcode);\n\nvalidate_dag_bad:\n\trf_PrintDAGList(dag_h);\n\treturn (retcode);\n}"
  },
  {
    "function_name": "rf_ValidateVisitedBits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagutils.c",
    "lines": "603-618",
    "snippet": "static void \nrf_ValidateVisitedBits(dag)\n\tRF_DagHeader_t *dag;\n{\n\tint     i, unvisited;\n\n\tunvisited = dag->succedents[0]->visited;\n\n\tfor (i = 0; i < dag->numSuccedents; i++) {\n\t\tif (dag->succedents[i] == NULL) {\n\t\t\tprintf(\"dag=%lx dag->succedents[%d] is NULL\\n\", (long) dag, i);\n\t\t\tRF_ASSERT(0);\n\t\t}\n\t\trf_ValidateBranchVisitedBits(dag->succedents[i], unvisited, 0);\n\t}\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void rf_PrintDAG(RF_DagHeader_t *);",
      "static void rf_ValidateVisitedBits(RF_DagHeader_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_ValidateBranchVisitedBits",
          "args": [
            "dag->succedents[i]",
            "unvisited",
            "0"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "rf_ValidateBranchVisitedBits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagutils.c",
          "lines": "583-599",
          "snippet": "static void \nrf_ValidateBranchVisitedBits(node, unvisited, rl)\n\tRF_DagNode_t *node;\n\tint     unvisited;\n\tint     rl;\n{\n\tint     i;\n\n\tRF_ASSERT(node->visited == unvisited);\n\tfor (i = 0; i < node->numSuccedents; i++) {\n\t\tif (node->succedents[i] == NULL) {\n\t\t\tprintf(\"node=%lx node->succedents[%d] is NULL\\n\", (long) node, i);\n\t\t\tRF_ASSERT(0);\n\t\t}\n\t\trf_ValidateBranchVisitedBits(node->succedents[i], unvisited, rl + 1);\n\t}\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_archs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void rf_RecurPrintDAG(RF_DagNode_t *, int, int);",
            "static int \nrf_ValidateBranch(RF_DagNode_t *, int *, int *,\n    RF_DagNode_t **, int);",
            "static void rf_ValidateBranchVisitedBits(RF_DagNode_t *, int, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_map.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void rf_RecurPrintDAG(RF_DagNode_t *, int, int);\nstatic int \nrf_ValidateBranch(RF_DagNode_t *, int *, int *,\n    RF_DagNode_t **, int);\nstatic void rf_ValidateBranchVisitedBits(RF_DagNode_t *, int, int);\n\nstatic void \nrf_ValidateBranchVisitedBits(node, unvisited, rl)\n\tRF_DagNode_t *node;\n\tint     unvisited;\n\tint     rl;\n{\n\tint     i;\n\n\tRF_ASSERT(node->visited == unvisited);\n\tfor (i = 0; i < node->numSuccedents; i++) {\n\t\tif (node->succedents[i] == NULL) {\n\t\t\tprintf(\"node=%lx node->succedents[%d] is NULL\\n\", (long) node, i);\n\t\t\tRF_ASSERT(0);\n\t\t}\n\t\trf_ValidateBranchVisitedBits(node->succedents[i], unvisited, rl + 1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "0"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"dag=%lx dag->succedents[%d] is NULL\\n\"",
            "(long) dag",
            "i"
          ],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_map.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void rf_PrintDAG(RF_DagHeader_t *);\nstatic void rf_ValidateVisitedBits(RF_DagHeader_t *);\n\nstatic void \nrf_ValidateVisitedBits(dag)\n\tRF_DagHeader_t *dag;\n{\n\tint     i, unvisited;\n\n\tunvisited = dag->succedents[0]->visited;\n\n\tfor (i = 0; i < dag->numSuccedents; i++) {\n\t\tif (dag->succedents[i] == NULL) {\n\t\t\tprintf(\"dag=%lx dag->succedents[%d] is NULL\\n\", (long) dag, i);\n\t\t\tRF_ASSERT(0);\n\t\t}\n\t\trf_ValidateBranchVisitedBits(dag->succedents[i], unvisited, 0);\n\t}\n}"
  },
  {
    "function_name": "rf_ValidateBranchVisitedBits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagutils.c",
    "lines": "583-599",
    "snippet": "static void \nrf_ValidateBranchVisitedBits(node, unvisited, rl)\n\tRF_DagNode_t *node;\n\tint     unvisited;\n\tint     rl;\n{\n\tint     i;\n\n\tRF_ASSERT(node->visited == unvisited);\n\tfor (i = 0; i < node->numSuccedents; i++) {\n\t\tif (node->succedents[i] == NULL) {\n\t\t\tprintf(\"node=%lx node->succedents[%d] is NULL\\n\", (long) node, i);\n\t\t\tRF_ASSERT(0);\n\t\t}\n\t\trf_ValidateBranchVisitedBits(node->succedents[i], unvisited, rl + 1);\n\t}\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void rf_RecurPrintDAG(RF_DagNode_t *, int, int);",
      "static int \nrf_ValidateBranch(RF_DagNode_t *, int *, int *,\n    RF_DagNode_t **, int);",
      "static void rf_ValidateBranchVisitedBits(RF_DagNode_t *, int, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_ValidateBranchVisitedBits",
          "args": [
            "node->succedents[i]",
            "unvisited",
            "rl + 1"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "rf_ValidateBranchVisitedBits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagutils.c",
          "lines": "583-599",
          "snippet": "static void \nrf_ValidateBranchVisitedBits(node, unvisited, rl)\n\tRF_DagNode_t *node;\n\tint     unvisited;\n\tint     rl;\n{\n\tint     i;\n\n\tRF_ASSERT(node->visited == unvisited);\n\tfor (i = 0; i < node->numSuccedents; i++) {\n\t\tif (node->succedents[i] == NULL) {\n\t\t\tprintf(\"node=%lx node->succedents[%d] is NULL\\n\", (long) node, i);\n\t\t\tRF_ASSERT(0);\n\t\t}\n\t\trf_ValidateBranchVisitedBits(node->succedents[i], unvisited, rl + 1);\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "0"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"node=%lx node->succedents[%d] is NULL\\n\"",
            "(long) node",
            "i"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "node->visited == unvisited"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_map.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void rf_RecurPrintDAG(RF_DagNode_t *, int, int);\nstatic int \nrf_ValidateBranch(RF_DagNode_t *, int *, int *,\n    RF_DagNode_t **, int);\nstatic void rf_ValidateBranchVisitedBits(RF_DagNode_t *, int, int);\n\nstatic void \nrf_ValidateBranchVisitedBits(node, unvisited, rl)\n\tRF_DagNode_t *node;\n\tint     unvisited;\n\tint     rl;\n{\n\tint     i;\n\n\tRF_ASSERT(node->visited == unvisited);\n\tfor (i = 0; i < node->numSuccedents; i++) {\n\t\tif (node->succedents[i] == NULL) {\n\t\t\tprintf(\"node=%lx node->succedents[%d] is NULL\\n\", (long) node, i);\n\t\t\tRF_ASSERT(0);\n\t\t}\n\t\trf_ValidateBranchVisitedBits(node->succedents[i], unvisited, rl + 1);\n\t}\n}"
  },
  {
    "function_name": "rf_ValidateBranch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagutils.c",
    "lines": "521-581",
    "snippet": "static int \nrf_ValidateBranch(node, scount, acount, nodes, unvisited)\n\tRF_DagNode_t *node;\n\tint    *scount;\n\tint    *acount;\n\tRF_DagNode_t **nodes;\n\tint     unvisited;\n{\n\tint     i, retcode = 0;\n\n\t/* construct an array of node pointers indexed by node num */\n\tnode->visited = (unvisited) ? 0 : 1;\n\tnodes[node->nodeNum] = node;\n\n\tif (node->next != NULL) {\n\t\tprintf(\"INVALID DAG: next pointer in node is not NULL\\n\");\n\t\tretcode = 1;\n\t}\n\tif (node->status != rf_wait) {\n\t\tprintf(\"INVALID DAG: Node status is not wait\\n\");\n\t\tretcode = 1;\n\t}\n\tif (node->numAntDone != 0) {\n\t\tprintf(\"INVALID DAG: numAntDone is not zero\\n\");\n\t\tretcode = 1;\n\t}\n\tif (node->doFunc == rf_TerminateFunc) {\n\t\tif (node->numSuccedents != 0) {\n\t\t\tprintf(\"INVALID DAG: Terminator node has succedents\\n\");\n\t\t\tretcode = 1;\n\t\t}\n\t} else {\n\t\tif (node->numSuccedents == 0) {\n\t\t\tprintf(\"INVALID DAG: Non-terminator node has no succedents\\n\");\n\t\t\tretcode = 1;\n\t\t}\n\t}\n\tfor (i = 0; i < node->numSuccedents; i++) {\n\t\tif (!node->succedents[i]) {\n\t\t\tprintf(\"INVALID DAG: succedent %d of node %s is NULL\\n\", i, node->name);\n\t\t\tretcode = 1;\n\t\t}\n\t\tscount[node->succedents[i]->nodeNum]++;\n\t}\n\tfor (i = 0; i < node->numAntecedents; i++) {\n\t\tif (!node->antecedents[i]) {\n\t\t\tprintf(\"INVALID DAG: antecedent %d of node %s is NULL\\n\", i, node->name);\n\t\t\tretcode = 1;\n\t\t}\n\t\tacount[node->antecedents[i]->nodeNum]++;\n\t}\n\tfor (i = 0; i < node->numSuccedents; i++) {\n\t\tif (node->succedents[i]->visited == unvisited) {\n\t\t\tif (rf_ValidateBranch(node->succedents[i], scount,\n\t\t\t\tacount, nodes, unvisited)) {\n\t\t\t\tretcode = 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn (retcode);\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void rf_RecurPrintDAG(RF_DagNode_t *, int, int);",
      "static int \nrf_ValidateBranch(RF_DagNode_t *, int *, int *,\n    RF_DagNode_t **, int);",
      "static void rf_ValidateBranchVisitedBits(RF_DagNode_t *, int, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_ValidateBranch",
          "args": [
            "node->succedents[i]",
            "scount",
            "acount",
            "nodes",
            "unvisited"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "rf_ValidateBranchVisitedBits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagutils.c",
          "lines": "583-599",
          "snippet": "static void \nrf_ValidateBranchVisitedBits(node, unvisited, rl)\n\tRF_DagNode_t *node;\n\tint     unvisited;\n\tint     rl;\n{\n\tint     i;\n\n\tRF_ASSERT(node->visited == unvisited);\n\tfor (i = 0; i < node->numSuccedents; i++) {\n\t\tif (node->succedents[i] == NULL) {\n\t\t\tprintf(\"node=%lx node->succedents[%d] is NULL\\n\", (long) node, i);\n\t\t\tRF_ASSERT(0);\n\t\t}\n\t\trf_ValidateBranchVisitedBits(node->succedents[i], unvisited, rl + 1);\n\t}\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_archs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void rf_RecurPrintDAG(RF_DagNode_t *, int, int);",
            "static int \nrf_ValidateBranch(RF_DagNode_t *, int *, int *,\n    RF_DagNode_t **, int);",
            "static void rf_ValidateBranchVisitedBits(RF_DagNode_t *, int, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_map.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void rf_RecurPrintDAG(RF_DagNode_t *, int, int);\nstatic int \nrf_ValidateBranch(RF_DagNode_t *, int *, int *,\n    RF_DagNode_t **, int);\nstatic void rf_ValidateBranchVisitedBits(RF_DagNode_t *, int, int);\n\nstatic void \nrf_ValidateBranchVisitedBits(node, unvisited, rl)\n\tRF_DagNode_t *node;\n\tint     unvisited;\n\tint     rl;\n{\n\tint     i;\n\n\tRF_ASSERT(node->visited == unvisited);\n\tfor (i = 0; i < node->numSuccedents; i++) {\n\t\tif (node->succedents[i] == NULL) {\n\t\t\tprintf(\"node=%lx node->succedents[%d] is NULL\\n\", (long) node, i);\n\t\t\tRF_ASSERT(0);\n\t\t}\n\t\trf_ValidateBranchVisitedBits(node->succedents[i], unvisited, rl + 1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"INVALID DAG: antecedent %d of node %s is NULL\\n\"",
            "i",
            "node->name"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_map.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void rf_RecurPrintDAG(RF_DagNode_t *, int, int);\nstatic int \nrf_ValidateBranch(RF_DagNode_t *, int *, int *,\n    RF_DagNode_t **, int);\nstatic void rf_ValidateBranchVisitedBits(RF_DagNode_t *, int, int);\n\nstatic int \nrf_ValidateBranch(node, scount, acount, nodes, unvisited)\n\tRF_DagNode_t *node;\n\tint    *scount;\n\tint    *acount;\n\tRF_DagNode_t **nodes;\n\tint     unvisited;\n{\n\tint     i, retcode = 0;\n\n\t/* construct an array of node pointers indexed by node num */\n\tnode->visited = (unvisited) ? 0 : 1;\n\tnodes[node->nodeNum] = node;\n\n\tif (node->next != NULL) {\n\t\tprintf(\"INVALID DAG: next pointer in node is not NULL\\n\");\n\t\tretcode = 1;\n\t}\n\tif (node->status != rf_wait) {\n\t\tprintf(\"INVALID DAG: Node status is not wait\\n\");\n\t\tretcode = 1;\n\t}\n\tif (node->numAntDone != 0) {\n\t\tprintf(\"INVALID DAG: numAntDone is not zero\\n\");\n\t\tretcode = 1;\n\t}\n\tif (node->doFunc == rf_TerminateFunc) {\n\t\tif (node->numSuccedents != 0) {\n\t\t\tprintf(\"INVALID DAG: Terminator node has succedents\\n\");\n\t\t\tretcode = 1;\n\t\t}\n\t} else {\n\t\tif (node->numSuccedents == 0) {\n\t\t\tprintf(\"INVALID DAG: Non-terminator node has no succedents\\n\");\n\t\t\tretcode = 1;\n\t\t}\n\t}\n\tfor (i = 0; i < node->numSuccedents; i++) {\n\t\tif (!node->succedents[i]) {\n\t\t\tprintf(\"INVALID DAG: succedent %d of node %s is NULL\\n\", i, node->name);\n\t\t\tretcode = 1;\n\t\t}\n\t\tscount[node->succedents[i]->nodeNum]++;\n\t}\n\tfor (i = 0; i < node->numAntecedents; i++) {\n\t\tif (!node->antecedents[i]) {\n\t\t\tprintf(\"INVALID DAG: antecedent %d of node %s is NULL\\n\", i, node->name);\n\t\t\tretcode = 1;\n\t\t}\n\t\tacount[node->antecedents[i]->nodeNum]++;\n\t}\n\tfor (i = 0; i < node->numSuccedents; i++) {\n\t\tif (node->succedents[i]->visited == unvisited) {\n\t\t\tif (rf_ValidateBranch(node->succedents[i], scount,\n\t\t\t\tacount, nodes, unvisited)) {\n\t\t\t\tretcode = 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn (retcode);\n}"
  },
  {
    "function_name": "rf_PrintDAGList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagutils.c",
    "lines": "509-519",
    "snippet": "void \nrf_PrintDAGList(RF_DagHeader_t * dag_h)\n{\n\tint     i = 0;\n\n\tfor (; dag_h; dag_h = dag_h->next) {\n\t\trf_AssignNodeNums(dag_h);\n\t\tprintf(\"\\n\\nDAG %d IN LIST:\\n\", i++);\n\t\trf_PrintDAG(dag_h);\n\t}\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void rf_PrintDAG(RF_DagHeader_t *);",
      "static void rf_ValidateVisitedBits(RF_DagHeader_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_PrintDAG",
          "args": [
            "dag_h"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "rf_PrintDAGList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagutils.c",
          "lines": "509-519",
          "snippet": "void \nrf_PrintDAGList(RF_DagHeader_t * dag_h)\n{\n\tint     i = 0;\n\n\tfor (; dag_h; dag_h = dag_h->next) {\n\t\trf_AssignNodeNums(dag_h);\n\t\tprintf(\"\\n\\nDAG %d IN LIST:\\n\", i++);\n\t\trf_PrintDAG(dag_h);\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\\nDAG %d IN LIST:\\n\"",
            "i++"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_AssignNodeNums",
          "args": [
            "dag_h"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "rf_AssignNodeNums",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagutils.c",
          "lines": "447-464",
          "snippet": "int \nrf_AssignNodeNums(RF_DagHeader_t * dag_h)\n{\n\tint     unvisited, i, nnum;\n\tRF_DagNode_t *node;\n\n\tnnum = 0;\n\tunvisited = dag_h->succedents[0]->visited;\n\n\tdag_h->nodeNum = nnum++;\n\tfor (i = 0; i < dag_h->numSuccedents; i++) {\n\t\tnode = dag_h->succedents[i];\n\t\tif (node->visited == unvisited) {\n\t\t\tnnum = rf_RecurAssignNodeNums(dag_h->succedents[i], nnum, unvisited);\n\t\t}\n\t}\n\treturn (nnum);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_archs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void rf_RecurPrintDAG(RF_DagNode_t *, int, int);",
            "static void rf_PrintDAG(RF_DagHeader_t *);",
            "static int \nrf_ValidateBranch(RF_DagNode_t *, int *, int *,\n    RF_DagNode_t **, int);",
            "static void rf_ValidateBranchVisitedBits(RF_DagNode_t *, int, int);",
            "static void rf_ValidateVisitedBits(RF_DagHeader_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_map.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void rf_RecurPrintDAG(RF_DagNode_t *, int, int);\nstatic void rf_PrintDAG(RF_DagHeader_t *);\nstatic int \nrf_ValidateBranch(RF_DagNode_t *, int *, int *,\n    RF_DagNode_t **, int);\nstatic void rf_ValidateBranchVisitedBits(RF_DagNode_t *, int, int);\nstatic void rf_ValidateVisitedBits(RF_DagHeader_t *);\n\nint \nrf_AssignNodeNums(RF_DagHeader_t * dag_h)\n{\n\tint     unvisited, i, nnum;\n\tRF_DagNode_t *node;\n\n\tnnum = 0;\n\tunvisited = dag_h->succedents[0]->visited;\n\n\tdag_h->nodeNum = nnum++;\n\tfor (i = 0; i < dag_h->numSuccedents; i++) {\n\t\tnode = dag_h->succedents[i];\n\t\tif (node->visited == unvisited) {\n\t\t\tnnum = rf_RecurAssignNodeNums(dag_h->succedents[i], nnum, unvisited);\n\t\t}\n\t}\n\treturn (nnum);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_map.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void rf_PrintDAG(RF_DagHeader_t *);\nstatic void rf_ValidateVisitedBits(RF_DagHeader_t *);\n\nvoid \nrf_PrintDAGList(RF_DagHeader_t * dag_h)\n{\n\tint     i = 0;\n\n\tfor (; dag_h; dag_h = dag_h->next) {\n\t\trf_AssignNodeNums(dag_h);\n\t\tprintf(\"\\n\\nDAG %d IN LIST:\\n\", i++);\n\t\trf_PrintDAG(dag_h);\n\t}\n}"
  },
  {
    "function_name": "rf_RecurResetDAGHeaderPointers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagutils.c",
    "lines": "496-506",
    "snippet": "void \nrf_RecurResetDAGHeaderPointers(node, newptr)\n\tRF_DagNode_t *node;\n\tRF_DagHeader_t *newptr;\n{\n\tint     i;\n\tnode->dagHdr = newptr;\n\tfor (i = 0; i < node->numSuccedents; i++)\n\t\tif (node->succedents[i]->dagHdr != newptr)\n\t\t\trf_RecurResetDAGHeaderPointers(node->succedents[i], newptr);\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void rf_RecurPrintDAG(RF_DagNode_t *, int, int);",
      "static void rf_PrintDAG(RF_DagHeader_t *);",
      "static int \nrf_ValidateBranch(RF_DagNode_t *, int *, int *,\n    RF_DagNode_t **, int);",
      "static void rf_ValidateBranchVisitedBits(RF_DagNode_t *, int, int);",
      "static void rf_ValidateVisitedBits(RF_DagHeader_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_RecurResetDAGHeaderPointers",
          "args": [
            "node->succedents[i]",
            "newptr"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "rf_RecurResetDAGHeaderPointers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagutils.c",
          "lines": "496-506",
          "snippet": "void \nrf_RecurResetDAGHeaderPointers(node, newptr)\n\tRF_DagNode_t *node;\n\tRF_DagHeader_t *newptr;\n{\n\tint     i;\n\tnode->dagHdr = newptr;\n\tfor (i = 0; i < node->numSuccedents; i++)\n\t\tif (node->succedents[i]->dagHdr != newptr)\n\t\t\trf_RecurResetDAGHeaderPointers(node->succedents[i], newptr);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_map.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void rf_RecurPrintDAG(RF_DagNode_t *, int, int);\nstatic void rf_PrintDAG(RF_DagHeader_t *);\nstatic int \nrf_ValidateBranch(RF_DagNode_t *, int *, int *,\n    RF_DagNode_t **, int);\nstatic void rf_ValidateBranchVisitedBits(RF_DagNode_t *, int, int);\nstatic void rf_ValidateVisitedBits(RF_DagHeader_t *);\n\nvoid \nrf_RecurResetDAGHeaderPointers(node, newptr)\n\tRF_DagNode_t *node;\n\tRF_DagHeader_t *newptr;\n{\n\tint     i;\n\tnode->dagHdr = newptr;\n\tfor (i = 0; i < node->numSuccedents; i++)\n\t\tif (node->succedents[i]->dagHdr != newptr)\n\t\t\trf_RecurResetDAGHeaderPointers(node->succedents[i], newptr);\n}"
  },
  {
    "function_name": "rf_ResetDAGHeaderPointers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagutils.c",
    "lines": "485-494",
    "snippet": "void \nrf_ResetDAGHeaderPointers(dag_h, newptr)\n\tRF_DagHeader_t *dag_h;\n\tRF_DagHeader_t *newptr;\n{\n\tint     i;\n\tfor (i = 0; i < dag_h->numSuccedents; i++)\n\t\tif (dag_h->succedents[i]->dagHdr != newptr)\n\t\t\trf_RecurResetDAGHeaderPointers(dag_h->succedents[i], newptr);\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void rf_PrintDAG(RF_DagHeader_t *);",
      "static void rf_ValidateVisitedBits(RF_DagHeader_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_RecurResetDAGHeaderPointers",
          "args": [
            "dag_h->succedents[i]",
            "newptr"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "rf_RecurResetDAGHeaderPointers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagutils.c",
          "lines": "496-506",
          "snippet": "void \nrf_RecurResetDAGHeaderPointers(node, newptr)\n\tRF_DagNode_t *node;\n\tRF_DagHeader_t *newptr;\n{\n\tint     i;\n\tnode->dagHdr = newptr;\n\tfor (i = 0; i < node->numSuccedents; i++)\n\t\tif (node->succedents[i]->dagHdr != newptr)\n\t\t\trf_RecurResetDAGHeaderPointers(node->succedents[i], newptr);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_archs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void rf_RecurPrintDAG(RF_DagNode_t *, int, int);",
            "static void rf_PrintDAG(RF_DagHeader_t *);",
            "static int \nrf_ValidateBranch(RF_DagNode_t *, int *, int *,\n    RF_DagNode_t **, int);",
            "static void rf_ValidateBranchVisitedBits(RF_DagNode_t *, int, int);",
            "static void rf_ValidateVisitedBits(RF_DagHeader_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_map.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void rf_RecurPrintDAG(RF_DagNode_t *, int, int);\nstatic void rf_PrintDAG(RF_DagHeader_t *);\nstatic int \nrf_ValidateBranch(RF_DagNode_t *, int *, int *,\n    RF_DagNode_t **, int);\nstatic void rf_ValidateBranchVisitedBits(RF_DagNode_t *, int, int);\nstatic void rf_ValidateVisitedBits(RF_DagHeader_t *);\n\nvoid \nrf_RecurResetDAGHeaderPointers(node, newptr)\n\tRF_DagNode_t *node;\n\tRF_DagHeader_t *newptr;\n{\n\tint     i;\n\tnode->dagHdr = newptr;\n\tfor (i = 0; i < node->numSuccedents; i++)\n\t\tif (node->succedents[i]->dagHdr != newptr)\n\t\t\trf_RecurResetDAGHeaderPointers(node->succedents[i], newptr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_map.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void rf_PrintDAG(RF_DagHeader_t *);\nstatic void rf_ValidateVisitedBits(RF_DagHeader_t *);\n\nvoid \nrf_ResetDAGHeaderPointers(dag_h, newptr)\n\tRF_DagHeader_t *dag_h;\n\tRF_DagHeader_t *newptr;\n{\n\tint     i;\n\tfor (i = 0; i < dag_h->numSuccedents; i++)\n\t\tif (dag_h->succedents[i]->dagHdr != newptr)\n\t\t\trf_RecurResetDAGHeaderPointers(dag_h->succedents[i], newptr);\n}"
  },
  {
    "function_name": "rf_RecurAssignNodeNums",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagutils.c",
    "lines": "466-483",
    "snippet": "int \nrf_RecurAssignNodeNums(node, num, unvisited)\n\tRF_DagNode_t *node;\n\tint     num;\n\tint     unvisited;\n{\n\tint     i;\n\n\tnode->visited = (unvisited) ? 0 : 1;\n\n\tnode->nodeNum = num++;\n\tfor (i = 0; i < node->numSuccedents; i++) {\n\t\tif (node->succedents[i]->visited == unvisited) {\n\t\t\tnum = rf_RecurAssignNodeNums(node->succedents[i], num, unvisited);\n\t\t}\n\t}\n\treturn (num);\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void rf_RecurPrintDAG(RF_DagNode_t *, int, int);",
      "static int \nrf_ValidateBranch(RF_DagNode_t *, int *, int *,\n    RF_DagNode_t **, int);",
      "static void rf_ValidateBranchVisitedBits(RF_DagNode_t *, int, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_RecurAssignNodeNums",
          "args": [
            "node->succedents[i]",
            "num",
            "unvisited"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "rf_RecurAssignNodeNums",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagutils.c",
          "lines": "466-483",
          "snippet": "int \nrf_RecurAssignNodeNums(node, num, unvisited)\n\tRF_DagNode_t *node;\n\tint     num;\n\tint     unvisited;\n{\n\tint     i;\n\n\tnode->visited = (unvisited) ? 0 : 1;\n\n\tnode->nodeNum = num++;\n\tfor (i = 0; i < node->numSuccedents; i++) {\n\t\tif (node->succedents[i]->visited == unvisited) {\n\t\t\tnum = rf_RecurAssignNodeNums(node->succedents[i], num, unvisited);\n\t\t}\n\t}\n\treturn (num);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_map.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void rf_RecurPrintDAG(RF_DagNode_t *, int, int);\nstatic int \nrf_ValidateBranch(RF_DagNode_t *, int *, int *,\n    RF_DagNode_t **, int);\nstatic void rf_ValidateBranchVisitedBits(RF_DagNode_t *, int, int);\n\nint \nrf_RecurAssignNodeNums(node, num, unvisited)\n\tRF_DagNode_t *node;\n\tint     num;\n\tint     unvisited;\n{\n\tint     i;\n\n\tnode->visited = (unvisited) ? 0 : 1;\n\n\tnode->nodeNum = num++;\n\tfor (i = 0; i < node->numSuccedents; i++) {\n\t\tif (node->succedents[i]->visited == unvisited) {\n\t\t\tnum = rf_RecurAssignNodeNums(node->succedents[i], num, unvisited);\n\t\t}\n\t}\n\treturn (num);\n}"
  },
  {
    "function_name": "rf_AssignNodeNums",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagutils.c",
    "lines": "447-464",
    "snippet": "int \nrf_AssignNodeNums(RF_DagHeader_t * dag_h)\n{\n\tint     unvisited, i, nnum;\n\tRF_DagNode_t *node;\n\n\tnnum = 0;\n\tunvisited = dag_h->succedents[0]->visited;\n\n\tdag_h->nodeNum = nnum++;\n\tfor (i = 0; i < dag_h->numSuccedents; i++) {\n\t\tnode = dag_h->succedents[i];\n\t\tif (node->visited == unvisited) {\n\t\t\tnnum = rf_RecurAssignNodeNums(dag_h->succedents[i], nnum, unvisited);\n\t\t}\n\t}\n\treturn (nnum);\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void rf_RecurPrintDAG(RF_DagNode_t *, int, int);",
      "static void rf_PrintDAG(RF_DagHeader_t *);",
      "static int \nrf_ValidateBranch(RF_DagNode_t *, int *, int *,\n    RF_DagNode_t **, int);",
      "static void rf_ValidateBranchVisitedBits(RF_DagNode_t *, int, int);",
      "static void rf_ValidateVisitedBits(RF_DagHeader_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_RecurAssignNodeNums",
          "args": [
            "dag_h->succedents[i]",
            "nnum",
            "unvisited"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "rf_RecurAssignNodeNums",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagutils.c",
          "lines": "466-483",
          "snippet": "int \nrf_RecurAssignNodeNums(node, num, unvisited)\n\tRF_DagNode_t *node;\n\tint     num;\n\tint     unvisited;\n{\n\tint     i;\n\n\tnode->visited = (unvisited) ? 0 : 1;\n\n\tnode->nodeNum = num++;\n\tfor (i = 0; i < node->numSuccedents; i++) {\n\t\tif (node->succedents[i]->visited == unvisited) {\n\t\t\tnum = rf_RecurAssignNodeNums(node->succedents[i], num, unvisited);\n\t\t}\n\t}\n\treturn (num);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_archs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void rf_RecurPrintDAG(RF_DagNode_t *, int, int);",
            "static int \nrf_ValidateBranch(RF_DagNode_t *, int *, int *,\n    RF_DagNode_t **, int);",
            "static void rf_ValidateBranchVisitedBits(RF_DagNode_t *, int, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_map.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void rf_RecurPrintDAG(RF_DagNode_t *, int, int);\nstatic int \nrf_ValidateBranch(RF_DagNode_t *, int *, int *,\n    RF_DagNode_t **, int);\nstatic void rf_ValidateBranchVisitedBits(RF_DagNode_t *, int, int);\n\nint \nrf_RecurAssignNodeNums(node, num, unvisited)\n\tRF_DagNode_t *node;\n\tint     num;\n\tint     unvisited;\n{\n\tint     i;\n\n\tnode->visited = (unvisited) ? 0 : 1;\n\n\tnode->nodeNum = num++;\n\tfor (i = 0; i < node->numSuccedents; i++) {\n\t\tif (node->succedents[i]->visited == unvisited) {\n\t\t\tnum = rf_RecurAssignNodeNums(node->succedents[i], num, unvisited);\n\t\t}\n\t}\n\treturn (num);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_map.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void rf_RecurPrintDAG(RF_DagNode_t *, int, int);\nstatic void rf_PrintDAG(RF_DagHeader_t *);\nstatic int \nrf_ValidateBranch(RF_DagNode_t *, int *, int *,\n    RF_DagNode_t **, int);\nstatic void rf_ValidateBranchVisitedBits(RF_DagNode_t *, int, int);\nstatic void rf_ValidateVisitedBits(RF_DagHeader_t *);\n\nint \nrf_AssignNodeNums(RF_DagHeader_t * dag_h)\n{\n\tint     unvisited, i, nnum;\n\tRF_DagNode_t *node;\n\n\tnnum = 0;\n\tunvisited = dag_h->succedents[0]->visited;\n\n\tdag_h->nodeNum = nnum++;\n\tfor (i = 0; i < dag_h->numSuccedents; i++) {\n\t\tnode = dag_h->succedents[i];\n\t\tif (node->visited == unvisited) {\n\t\t\tnnum = rf_RecurAssignNodeNums(dag_h->succedents[i], nnum, unvisited);\n\t\t}\n\t}\n\treturn (nnum);\n}"
  },
  {
    "function_name": "rf_PrintDAG",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagutils.c",
    "lines": "407-445",
    "snippet": "static void \nrf_PrintDAG(dag_h)\n\tRF_DagHeader_t *dag_h;\n{\n\tint     unvisited, i;\n\tchar   *status;\n\n\t/* set dag status */\n\tswitch (dag_h->status) {\n\tcase rf_enable:\n\t\tstatus = \"enable\";\n\t\tbreak;\n\tcase rf_rollForward:\n\t\tstatus = \"rollForward\";\n\t\tbreak;\n\tcase rf_rollBackward:\n\t\tstatus = \"rollBackward\";\n\t\tbreak;\n\tdefault:\n\t\tstatus = \"illegal!\";\n\t\tbreak;\n\t}\n\t/* find out if visited bits are currently set or clear */\n\tunvisited = dag_h->succedents[0]->visited;\n\n\tprintf(\"DAG type:  %s\\n\", dag_h->creator);\n\tprintf(\"format is (depth) num commit type: status,nSucc nSuccFired/nSuccDone,nAnte/nAnteDone,nParam,nResult S{x} A{x(type)};  info\\n\");\n\tprintf(\"(0) %d Hdr: %s, s%d, (commit %d/%d) S{\", dag_h->nodeNum,\n\t    status, dag_h->numSuccedents, dag_h->numCommitNodes, dag_h->numCommits);\n\tfor (i = 0; i < dag_h->numSuccedents; i++) {\n\t\tprintf(\"%d%s\", dag_h->succedents[i]->nodeNum,\n\t\t    ((i == dag_h->numSuccedents - 1) ? \"\\0\" : \" \"));\n\t}\n\tprintf(\"};\\n\");\n\tfor (i = 0; i < dag_h->numSuccedents; i++) {\n\t\tif (dag_h->succedents[i]->visited == unvisited)\n\t\t\trf_RecurPrintDAG(dag_h->succedents[i], 1, unvisited);\n\t}\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void rf_PrintDAG(RF_DagHeader_t *);",
      "static void rf_ValidateVisitedBits(RF_DagHeader_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_RecurPrintDAG",
          "args": [
            "dag_h->succedents[i]",
            "1",
            "unvisited"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "rf_RecurPrintDAG",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagutils.c",
          "lines": "360-405",
          "snippet": "static void \nrf_RecurPrintDAG(node, depth, unvisited)\n\tRF_DagNode_t *node;\n\tint     depth;\n\tint     unvisited;\n{\n\tchar   *anttype;\n\tint     i;\n\n\tnode->visited = (unvisited) ? 0 : 1;\n\tprintf(\"(%d) %d C%d %s: %s,s%d %d/%d,a%d/%d,p%d,r%d S{\", depth,\n\t    node->nodeNum, node->commitNode, node->name, rf_NodeStatusString(node),\n\t    node->numSuccedents, node->numSuccFired, node->numSuccDone,\n\t    node->numAntecedents, node->numAntDone, node->numParams, node->numResults);\n\tfor (i = 0; i < node->numSuccedents; i++) {\n\t\tprintf(\"%d%s\", node->succedents[i]->nodeNum,\n\t\t    ((i == node->numSuccedents - 1) ? \"\\0\" : \" \"));\n\t}\n\tprintf(\"} A{\");\n\tfor (i = 0; i < node->numAntecedents; i++) {\n\t\tswitch (node->antType[i]) {\n\t\tcase rf_trueData:\n\t\t\tanttype = \"T\";\n\t\t\tbreak;\n\t\tcase rf_antiData:\n\t\t\tanttype = \"A\";\n\t\t\tbreak;\n\t\tcase rf_outputData:\n\t\t\tanttype = \"O\";\n\t\t\tbreak;\n\t\tcase rf_control:\n\t\t\tanttype = \"C\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tanttype = \"?\";\n\t\t\tbreak;\n\t\t}\n\t\tprintf(\"%d(%s)%s\", node->antecedents[i]->nodeNum, anttype, (i == node->numAntecedents - 1) ? \"\\0\" : \" \");\n\t}\n\tprintf(\"}; \");\n\trf_PrintNodeInfoString(node);\n\tfor (i = 0; i < node->numSuccedents; i++) {\n\t\tif (node->succedents[i]->visited == unvisited)\n\t\t\trf_RecurPrintDAG(node->succedents[i], depth + 1, unvisited);\n\t}\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_archs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void rf_RecurPrintDAG(RF_DagNode_t *, int, int);",
            "static int \nrf_ValidateBranch(RF_DagNode_t *, int *, int *,\n    RF_DagNode_t **, int);",
            "static void rf_ValidateBranchVisitedBits(RF_DagNode_t *, int, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_map.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void rf_RecurPrintDAG(RF_DagNode_t *, int, int);\nstatic int \nrf_ValidateBranch(RF_DagNode_t *, int *, int *,\n    RF_DagNode_t **, int);\nstatic void rf_ValidateBranchVisitedBits(RF_DagNode_t *, int, int);\n\nstatic void \nrf_RecurPrintDAG(node, depth, unvisited)\n\tRF_DagNode_t *node;\n\tint     depth;\n\tint     unvisited;\n{\n\tchar   *anttype;\n\tint     i;\n\n\tnode->visited = (unvisited) ? 0 : 1;\n\tprintf(\"(%d) %d C%d %s: %s,s%d %d/%d,a%d/%d,p%d,r%d S{\", depth,\n\t    node->nodeNum, node->commitNode, node->name, rf_NodeStatusString(node),\n\t    node->numSuccedents, node->numSuccFired, node->numSuccDone,\n\t    node->numAntecedents, node->numAntDone, node->numParams, node->numResults);\n\tfor (i = 0; i < node->numSuccedents; i++) {\n\t\tprintf(\"%d%s\", node->succedents[i]->nodeNum,\n\t\t    ((i == node->numSuccedents - 1) ? \"\\0\" : \" \"));\n\t}\n\tprintf(\"} A{\");\n\tfor (i = 0; i < node->numAntecedents; i++) {\n\t\tswitch (node->antType[i]) {\n\t\tcase rf_trueData:\n\t\t\tanttype = \"T\";\n\t\t\tbreak;\n\t\tcase rf_antiData:\n\t\t\tanttype = \"A\";\n\t\t\tbreak;\n\t\tcase rf_outputData:\n\t\t\tanttype = \"O\";\n\t\t\tbreak;\n\t\tcase rf_control:\n\t\t\tanttype = \"C\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tanttype = \"?\";\n\t\t\tbreak;\n\t\t}\n\t\tprintf(\"%d(%s)%s\", node->antecedents[i]->nodeNum, anttype, (i == node->numAntecedents - 1) ? \"\\0\" : \" \");\n\t}\n\tprintf(\"}; \");\n\trf_PrintNodeInfoString(node);\n\tfor (i = 0; i < node->numSuccedents; i++) {\n\t\tif (node->succedents[i]->visited == unvisited)\n\t\t\trf_RecurPrintDAG(node->succedents[i], depth + 1, unvisited);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"};\\n\""
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_map.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void rf_PrintDAG(RF_DagHeader_t *);\nstatic void rf_ValidateVisitedBits(RF_DagHeader_t *);\n\nstatic void \nrf_PrintDAG(dag_h)\n\tRF_DagHeader_t *dag_h;\n{\n\tint     unvisited, i;\n\tchar   *status;\n\n\t/* set dag status */\n\tswitch (dag_h->status) {\n\tcase rf_enable:\n\t\tstatus = \"enable\";\n\t\tbreak;\n\tcase rf_rollForward:\n\t\tstatus = \"rollForward\";\n\t\tbreak;\n\tcase rf_rollBackward:\n\t\tstatus = \"rollBackward\";\n\t\tbreak;\n\tdefault:\n\t\tstatus = \"illegal!\";\n\t\tbreak;\n\t}\n\t/* find out if visited bits are currently set or clear */\n\tunvisited = dag_h->succedents[0]->visited;\n\n\tprintf(\"DAG type:  %s\\n\", dag_h->creator);\n\tprintf(\"format is (depth) num commit type: status,nSucc nSuccFired/nSuccDone,nAnte/nAnteDone,nParam,nResult S{x} A{x(type)};  info\\n\");\n\tprintf(\"(0) %d Hdr: %s, s%d, (commit %d/%d) S{\", dag_h->nodeNum,\n\t    status, dag_h->numSuccedents, dag_h->numCommitNodes, dag_h->numCommits);\n\tfor (i = 0; i < dag_h->numSuccedents; i++) {\n\t\tprintf(\"%d%s\", dag_h->succedents[i]->nodeNum,\n\t\t    ((i == dag_h->numSuccedents - 1) ? \"\\0\" : \" \"));\n\t}\n\tprintf(\"};\\n\");\n\tfor (i = 0; i < dag_h->numSuccedents; i++) {\n\t\tif (dag_h->succedents[i]->visited == unvisited)\n\t\t\trf_RecurPrintDAG(dag_h->succedents[i], 1, unvisited);\n\t}\n}"
  },
  {
    "function_name": "rf_RecurPrintDAG",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagutils.c",
    "lines": "360-405",
    "snippet": "static void \nrf_RecurPrintDAG(node, depth, unvisited)\n\tRF_DagNode_t *node;\n\tint     depth;\n\tint     unvisited;\n{\n\tchar   *anttype;\n\tint     i;\n\n\tnode->visited = (unvisited) ? 0 : 1;\n\tprintf(\"(%d) %d C%d %s: %s,s%d %d/%d,a%d/%d,p%d,r%d S{\", depth,\n\t    node->nodeNum, node->commitNode, node->name, rf_NodeStatusString(node),\n\t    node->numSuccedents, node->numSuccFired, node->numSuccDone,\n\t    node->numAntecedents, node->numAntDone, node->numParams, node->numResults);\n\tfor (i = 0; i < node->numSuccedents; i++) {\n\t\tprintf(\"%d%s\", node->succedents[i]->nodeNum,\n\t\t    ((i == node->numSuccedents - 1) ? \"\\0\" : \" \"));\n\t}\n\tprintf(\"} A{\");\n\tfor (i = 0; i < node->numAntecedents; i++) {\n\t\tswitch (node->antType[i]) {\n\t\tcase rf_trueData:\n\t\t\tanttype = \"T\";\n\t\t\tbreak;\n\t\tcase rf_antiData:\n\t\t\tanttype = \"A\";\n\t\t\tbreak;\n\t\tcase rf_outputData:\n\t\t\tanttype = \"O\";\n\t\t\tbreak;\n\t\tcase rf_control:\n\t\t\tanttype = \"C\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tanttype = \"?\";\n\t\t\tbreak;\n\t\t}\n\t\tprintf(\"%d(%s)%s\", node->antecedents[i]->nodeNum, anttype, (i == node->numAntecedents - 1) ? \"\\0\" : \" \");\n\t}\n\tprintf(\"}; \");\n\trf_PrintNodeInfoString(node);\n\tfor (i = 0; i < node->numSuccedents; i++) {\n\t\tif (node->succedents[i]->visited == unvisited)\n\t\t\trf_RecurPrintDAG(node->succedents[i], depth + 1, unvisited);\n\t}\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void rf_RecurPrintDAG(RF_DagNode_t *, int, int);",
      "static int \nrf_ValidateBranch(RF_DagNode_t *, int *, int *,\n    RF_DagNode_t **, int);",
      "static void rf_ValidateBranchVisitedBits(RF_DagNode_t *, int, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_RecurPrintDAG",
          "args": [
            "node->succedents[i]",
            "depth + 1",
            "unvisited"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "rf_RecurPrintDAG",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagutils.c",
          "lines": "360-405",
          "snippet": "static void \nrf_RecurPrintDAG(node, depth, unvisited)\n\tRF_DagNode_t *node;\n\tint     depth;\n\tint     unvisited;\n{\n\tchar   *anttype;\n\tint     i;\n\n\tnode->visited = (unvisited) ? 0 : 1;\n\tprintf(\"(%d) %d C%d %s: %s,s%d %d/%d,a%d/%d,p%d,r%d S{\", depth,\n\t    node->nodeNum, node->commitNode, node->name, rf_NodeStatusString(node),\n\t    node->numSuccedents, node->numSuccFired, node->numSuccDone,\n\t    node->numAntecedents, node->numAntDone, node->numParams, node->numResults);\n\tfor (i = 0; i < node->numSuccedents; i++) {\n\t\tprintf(\"%d%s\", node->succedents[i]->nodeNum,\n\t\t    ((i == node->numSuccedents - 1) ? \"\\0\" : \" \"));\n\t}\n\tprintf(\"} A{\");\n\tfor (i = 0; i < node->numAntecedents; i++) {\n\t\tswitch (node->antType[i]) {\n\t\tcase rf_trueData:\n\t\t\tanttype = \"T\";\n\t\t\tbreak;\n\t\tcase rf_antiData:\n\t\t\tanttype = \"A\";\n\t\t\tbreak;\n\t\tcase rf_outputData:\n\t\t\tanttype = \"O\";\n\t\t\tbreak;\n\t\tcase rf_control:\n\t\t\tanttype = \"C\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tanttype = \"?\";\n\t\t\tbreak;\n\t\t}\n\t\tprintf(\"%d(%s)%s\", node->antecedents[i]->nodeNum, anttype, (i == node->numAntecedents - 1) ? \"\\0\" : \" \");\n\t}\n\tprintf(\"}; \");\n\trf_PrintNodeInfoString(node);\n\tfor (i = 0; i < node->numSuccedents; i++) {\n\t\tif (node->succedents[i]->visited == unvisited)\n\t\t\trf_RecurPrintDAG(node->succedents[i], depth + 1, unvisited);\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "rf_PrintNodeInfoString",
          "args": [
            "node"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "rf_PrintNodeInfoString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagutils.c",
          "lines": "298-358",
          "snippet": "void \nrf_PrintNodeInfoString(RF_DagNode_t * node)\n{\n\tRF_PhysDiskAddr_t *pda;\n\tint     (*df) (RF_DagNode_t *) = node->doFunc;\n\tint     i, lk, unlk;\n\tvoid   *bufPtr;\n\n\tif ((df == rf_DiskReadFunc) || (df == rf_DiskWriteFunc)\n\t    || (df == rf_DiskReadMirrorIdleFunc)\n\t    || (df == rf_DiskReadMirrorPartitionFunc)) {\n\t\tpda = (RF_PhysDiskAddr_t *) node->params[0].p;\n\t\tbufPtr = (void *) node->params[1].p;\n\t\tlk = RF_EXTRACT_LOCK_FLAG(node->params[3].v);\n\t\tunlk = RF_EXTRACT_UNLOCK_FLAG(node->params[3].v);\n\t\tRF_ASSERT(!(lk && unlk));\n\t\tprintf(\"r %d c %d offs %ld nsect %d buf 0x%lx %s\\n\", pda->row, pda->col,\n\t\t    (long) pda->startSector, (int) pda->numSector, (long) bufPtr,\n\t\t    (lk) ? \"LOCK\" : ((unlk) ? \"UNLK\" : \" \"));\n\t\treturn;\n\t}\n\tif (df == rf_DiskUnlockFunc) {\n\t\tpda = (RF_PhysDiskAddr_t *) node->params[0].p;\n\t\tlk = RF_EXTRACT_LOCK_FLAG(node->params[3].v);\n\t\tunlk = RF_EXTRACT_UNLOCK_FLAG(node->params[3].v);\n\t\tRF_ASSERT(!(lk && unlk));\n\t\tprintf(\"r %d c %d %s\\n\", pda->row, pda->col,\n\t\t    (lk) ? \"LOCK\" : ((unlk) ? \"UNLK\" : \"nop\"));\n\t\treturn;\n\t}\n\tif ((df == rf_SimpleXorFunc) || (df == rf_RegularXorFunc)\n\t    || (df == rf_RecoveryXorFunc)) {\n\t\tprintf(\"result buf 0x%lx\\n\", (long) node->results[0]);\n\t\tfor (i = 0; i < node->numParams - 1; i += 2) {\n\t\t\tpda = (RF_PhysDiskAddr_t *) node->params[i].p;\n\t\t\tbufPtr = (RF_PhysDiskAddr_t *) node->params[i + 1].p;\n\t\t\tprintf(\"    buf 0x%lx r%d c%d offs %ld nsect %d\\n\",\n\t\t\t    (long) bufPtr, pda->row, pda->col,\n\t\t\t    (long) pda->startSector, (int) pda->numSector);\n\t\t}\n\t\treturn;\n\t}\n#if RF_INCLUDE_PARITYLOGGING > 0\n\tif (df == rf_ParityLogOverwriteFunc || df == rf_ParityLogUpdateFunc) {\n\t\tfor (i = 0; i < node->numParams - 1; i += 2) {\n\t\t\tpda = (RF_PhysDiskAddr_t *) node->params[i].p;\n\t\t\tbufPtr = (RF_PhysDiskAddr_t *) node->params[i + 1].p;\n\t\t\tprintf(\" r%d c%d offs %ld nsect %d buf 0x%lx\\n\",\n\t\t\t    pda->row, pda->col, (long) pda->startSector,\n\t\t\t    (int) pda->numSector, (long) bufPtr);\n\t\t}\n\t\treturn;\n\t}\n#endif\t\t\t\t/* RF_INCLUDE_PARITYLOGGING > 0 */\n\n\tif ((df == rf_TerminateFunc) || (df == rf_NullNodeFunc)) {\n\t\tprintf(\"\\n\");\n\t\treturn;\n\t}\n\tprintf(\"?\\n\");\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_archs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void rf_RecurPrintDAG(RF_DagNode_t *, int, int);",
            "static int \nrf_ValidateBranch(RF_DagNode_t *, int *, int *,\n    RF_DagNode_t **, int);",
            "static void rf_ValidateBranchVisitedBits(RF_DagNode_t *, int, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_map.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void rf_RecurPrintDAG(RF_DagNode_t *, int, int);\nstatic int \nrf_ValidateBranch(RF_DagNode_t *, int *, int *,\n    RF_DagNode_t **, int);\nstatic void rf_ValidateBranchVisitedBits(RF_DagNode_t *, int, int);\n\nvoid \nrf_PrintNodeInfoString(RF_DagNode_t * node)\n{\n\tRF_PhysDiskAddr_t *pda;\n\tint     (*df) (RF_DagNode_t *) = node->doFunc;\n\tint     i, lk, unlk;\n\tvoid   *bufPtr;\n\n\tif ((df == rf_DiskReadFunc) || (df == rf_DiskWriteFunc)\n\t    || (df == rf_DiskReadMirrorIdleFunc)\n\t    || (df == rf_DiskReadMirrorPartitionFunc)) {\n\t\tpda = (RF_PhysDiskAddr_t *) node->params[0].p;\n\t\tbufPtr = (void *) node->params[1].p;\n\t\tlk = RF_EXTRACT_LOCK_FLAG(node->params[3].v);\n\t\tunlk = RF_EXTRACT_UNLOCK_FLAG(node->params[3].v);\n\t\tRF_ASSERT(!(lk && unlk));\n\t\tprintf(\"r %d c %d offs %ld nsect %d buf 0x%lx %s\\n\", pda->row, pda->col,\n\t\t    (long) pda->startSector, (int) pda->numSector, (long) bufPtr,\n\t\t    (lk) ? \"LOCK\" : ((unlk) ? \"UNLK\" : \" \"));\n\t\treturn;\n\t}\n\tif (df == rf_DiskUnlockFunc) {\n\t\tpda = (RF_PhysDiskAddr_t *) node->params[0].p;\n\t\tlk = RF_EXTRACT_LOCK_FLAG(node->params[3].v);\n\t\tunlk = RF_EXTRACT_UNLOCK_FLAG(node->params[3].v);\n\t\tRF_ASSERT(!(lk && unlk));\n\t\tprintf(\"r %d c %d %s\\n\", pda->row, pda->col,\n\t\t    (lk) ? \"LOCK\" : ((unlk) ? \"UNLK\" : \"nop\"));\n\t\treturn;\n\t}\n\tif ((df == rf_SimpleXorFunc) || (df == rf_RegularXorFunc)\n\t    || (df == rf_RecoveryXorFunc)) {\n\t\tprintf(\"result buf 0x%lx\\n\", (long) node->results[0]);\n\t\tfor (i = 0; i < node->numParams - 1; i += 2) {\n\t\t\tpda = (RF_PhysDiskAddr_t *) node->params[i].p;\n\t\t\tbufPtr = (RF_PhysDiskAddr_t *) node->params[i + 1].p;\n\t\t\tprintf(\"    buf 0x%lx r%d c%d offs %ld nsect %d\\n\",\n\t\t\t    (long) bufPtr, pda->row, pda->col,\n\t\t\t    (long) pda->startSector, (int) pda->numSector);\n\t\t}\n\t\treturn;\n\t}\n#if RF_INCLUDE_PARITYLOGGING > 0\n\tif (df == rf_ParityLogOverwriteFunc || df == rf_ParityLogUpdateFunc) {\n\t\tfor (i = 0; i < node->numParams - 1; i += 2) {\n\t\t\tpda = (RF_PhysDiskAddr_t *) node->params[i].p;\n\t\t\tbufPtr = (RF_PhysDiskAddr_t *) node->params[i + 1].p;\n\t\t\tprintf(\" r%d c%d offs %ld nsect %d buf 0x%lx\\n\",\n\t\t\t    pda->row, pda->col, (long) pda->startSector,\n\t\t\t    (int) pda->numSector, (long) bufPtr);\n\t\t}\n\t\treturn;\n\t}\n#endif\t\t\t\t/* RF_INCLUDE_PARITYLOGGING > 0 */\n\n\tif ((df == rf_TerminateFunc) || (df == rf_NullNodeFunc)) {\n\t\tprintf(\"\\n\");\n\t\treturn;\n\t}\n\tprintf(\"?\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"}; \""
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_NodeStatusString",
          "args": [
            "node"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "rf_NodeStatusString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagutils.c",
          "lines": "282-296",
          "snippet": "char   *\nrf_NodeStatusString(RF_DagNode_t * node)\n{\n\tswitch (node->status) {\n\t\tcase rf_wait:return (\"wait\");\n\tcase rf_fired:\n\t\treturn (\"fired\");\n\tcase rf_good:\n\t\treturn (\"good\");\n\tcase rf_bad:\n\t\treturn (\"bad\");\n\tdefault:\n\t\treturn (\"?\");\n\t}\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_archs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void rf_RecurPrintDAG(RF_DagNode_t *, int, int);",
            "static int \nrf_ValidateBranch(RF_DagNode_t *, int *, int *,\n    RF_DagNode_t **, int);",
            "static void rf_ValidateBranchVisitedBits(RF_DagNode_t *, int, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_map.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void rf_RecurPrintDAG(RF_DagNode_t *, int, int);\nstatic int \nrf_ValidateBranch(RF_DagNode_t *, int *, int *,\n    RF_DagNode_t **, int);\nstatic void rf_ValidateBranchVisitedBits(RF_DagNode_t *, int, int);\n\nchar   *\nrf_NodeStatusString(RF_DagNode_t * node)\n{\n\tswitch (node->status) {\n\t\tcase rf_wait:return (\"wait\");\n\tcase rf_fired:\n\t\treturn (\"fired\");\n\tcase rf_good:\n\t\treturn (\"good\");\n\tcase rf_bad:\n\t\treturn (\"bad\");\n\tdefault:\n\t\treturn (\"?\");\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_map.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void rf_RecurPrintDAG(RF_DagNode_t *, int, int);\nstatic int \nrf_ValidateBranch(RF_DagNode_t *, int *, int *,\n    RF_DagNode_t **, int);\nstatic void rf_ValidateBranchVisitedBits(RF_DagNode_t *, int, int);\n\nstatic void \nrf_RecurPrintDAG(node, depth, unvisited)\n\tRF_DagNode_t *node;\n\tint     depth;\n\tint     unvisited;\n{\n\tchar   *anttype;\n\tint     i;\n\n\tnode->visited = (unvisited) ? 0 : 1;\n\tprintf(\"(%d) %d C%d %s: %s,s%d %d/%d,a%d/%d,p%d,r%d S{\", depth,\n\t    node->nodeNum, node->commitNode, node->name, rf_NodeStatusString(node),\n\t    node->numSuccedents, node->numSuccFired, node->numSuccDone,\n\t    node->numAntecedents, node->numAntDone, node->numParams, node->numResults);\n\tfor (i = 0; i < node->numSuccedents; i++) {\n\t\tprintf(\"%d%s\", node->succedents[i]->nodeNum,\n\t\t    ((i == node->numSuccedents - 1) ? \"\\0\" : \" \"));\n\t}\n\tprintf(\"} A{\");\n\tfor (i = 0; i < node->numAntecedents; i++) {\n\t\tswitch (node->antType[i]) {\n\t\tcase rf_trueData:\n\t\t\tanttype = \"T\";\n\t\t\tbreak;\n\t\tcase rf_antiData:\n\t\t\tanttype = \"A\";\n\t\t\tbreak;\n\t\tcase rf_outputData:\n\t\t\tanttype = \"O\";\n\t\t\tbreak;\n\t\tcase rf_control:\n\t\t\tanttype = \"C\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tanttype = \"?\";\n\t\t\tbreak;\n\t\t}\n\t\tprintf(\"%d(%s)%s\", node->antecedents[i]->nodeNum, anttype, (i == node->numAntecedents - 1) ? \"\\0\" : \" \");\n\t}\n\tprintf(\"}; \");\n\trf_PrintNodeInfoString(node);\n\tfor (i = 0; i < node->numSuccedents; i++) {\n\t\tif (node->succedents[i]->visited == unvisited)\n\t\t\trf_RecurPrintDAG(node->succedents[i], depth + 1, unvisited);\n\t}\n}"
  },
  {
    "function_name": "rf_PrintNodeInfoString",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagutils.c",
    "lines": "298-358",
    "snippet": "void \nrf_PrintNodeInfoString(RF_DagNode_t * node)\n{\n\tRF_PhysDiskAddr_t *pda;\n\tint     (*df) (RF_DagNode_t *) = node->doFunc;\n\tint     i, lk, unlk;\n\tvoid   *bufPtr;\n\n\tif ((df == rf_DiskReadFunc) || (df == rf_DiskWriteFunc)\n\t    || (df == rf_DiskReadMirrorIdleFunc)\n\t    || (df == rf_DiskReadMirrorPartitionFunc)) {\n\t\tpda = (RF_PhysDiskAddr_t *) node->params[0].p;\n\t\tbufPtr = (void *) node->params[1].p;\n\t\tlk = RF_EXTRACT_LOCK_FLAG(node->params[3].v);\n\t\tunlk = RF_EXTRACT_UNLOCK_FLAG(node->params[3].v);\n\t\tRF_ASSERT(!(lk && unlk));\n\t\tprintf(\"r %d c %d offs %ld nsect %d buf 0x%lx %s\\n\", pda->row, pda->col,\n\t\t    (long) pda->startSector, (int) pda->numSector, (long) bufPtr,\n\t\t    (lk) ? \"LOCK\" : ((unlk) ? \"UNLK\" : \" \"));\n\t\treturn;\n\t}\n\tif (df == rf_DiskUnlockFunc) {\n\t\tpda = (RF_PhysDiskAddr_t *) node->params[0].p;\n\t\tlk = RF_EXTRACT_LOCK_FLAG(node->params[3].v);\n\t\tunlk = RF_EXTRACT_UNLOCK_FLAG(node->params[3].v);\n\t\tRF_ASSERT(!(lk && unlk));\n\t\tprintf(\"r %d c %d %s\\n\", pda->row, pda->col,\n\t\t    (lk) ? \"LOCK\" : ((unlk) ? \"UNLK\" : \"nop\"));\n\t\treturn;\n\t}\n\tif ((df == rf_SimpleXorFunc) || (df == rf_RegularXorFunc)\n\t    || (df == rf_RecoveryXorFunc)) {\n\t\tprintf(\"result buf 0x%lx\\n\", (long) node->results[0]);\n\t\tfor (i = 0; i < node->numParams - 1; i += 2) {\n\t\t\tpda = (RF_PhysDiskAddr_t *) node->params[i].p;\n\t\t\tbufPtr = (RF_PhysDiskAddr_t *) node->params[i + 1].p;\n\t\t\tprintf(\"    buf 0x%lx r%d c%d offs %ld nsect %d\\n\",\n\t\t\t    (long) bufPtr, pda->row, pda->col,\n\t\t\t    (long) pda->startSector, (int) pda->numSector);\n\t\t}\n\t\treturn;\n\t}\n#if RF_INCLUDE_PARITYLOGGING > 0\n\tif (df == rf_ParityLogOverwriteFunc || df == rf_ParityLogUpdateFunc) {\n\t\tfor (i = 0; i < node->numParams - 1; i += 2) {\n\t\t\tpda = (RF_PhysDiskAddr_t *) node->params[i].p;\n\t\t\tbufPtr = (RF_PhysDiskAddr_t *) node->params[i + 1].p;\n\t\t\tprintf(\" r%d c%d offs %ld nsect %d buf 0x%lx\\n\",\n\t\t\t    pda->row, pda->col, (long) pda->startSector,\n\t\t\t    (int) pda->numSector, (long) bufPtr);\n\t\t}\n\t\treturn;\n\t}\n#endif\t\t\t\t/* RF_INCLUDE_PARITYLOGGING > 0 */\n\n\tif ((df == rf_TerminateFunc) || (df == rf_NullNodeFunc)) {\n\t\tprintf(\"\\n\");\n\t\treturn;\n\t}\n\tprintf(\"?\\n\");\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void rf_RecurPrintDAG(RF_DagNode_t *, int, int);",
      "static int \nrf_ValidateBranch(RF_DagNode_t *, int *, int *,\n    RF_DagNode_t **, int);",
      "static void rf_ValidateBranchVisitedBits(RF_DagNode_t *, int, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"?\\n\""
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "!(lk && unlk)"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_EXTRACT_UNLOCK_FLAG",
          "args": [
            "node->params[3].v"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_EXTRACT_LOCK_FLAG",
          "args": [
            "node->params[3].v"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "!(lk && unlk)"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_EXTRACT_UNLOCK_FLAG",
          "args": [
            "node->params[3].v"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_EXTRACT_LOCK_FLAG",
          "args": [
            "node->params[3].v"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_map.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void rf_RecurPrintDAG(RF_DagNode_t *, int, int);\nstatic int \nrf_ValidateBranch(RF_DagNode_t *, int *, int *,\n    RF_DagNode_t **, int);\nstatic void rf_ValidateBranchVisitedBits(RF_DagNode_t *, int, int);\n\nvoid \nrf_PrintNodeInfoString(RF_DagNode_t * node)\n{\n\tRF_PhysDiskAddr_t *pda;\n\tint     (*df) (RF_DagNode_t *) = node->doFunc;\n\tint     i, lk, unlk;\n\tvoid   *bufPtr;\n\n\tif ((df == rf_DiskReadFunc) || (df == rf_DiskWriteFunc)\n\t    || (df == rf_DiskReadMirrorIdleFunc)\n\t    || (df == rf_DiskReadMirrorPartitionFunc)) {\n\t\tpda = (RF_PhysDiskAddr_t *) node->params[0].p;\n\t\tbufPtr = (void *) node->params[1].p;\n\t\tlk = RF_EXTRACT_LOCK_FLAG(node->params[3].v);\n\t\tunlk = RF_EXTRACT_UNLOCK_FLAG(node->params[3].v);\n\t\tRF_ASSERT(!(lk && unlk));\n\t\tprintf(\"r %d c %d offs %ld nsect %d buf 0x%lx %s\\n\", pda->row, pda->col,\n\t\t    (long) pda->startSector, (int) pda->numSector, (long) bufPtr,\n\t\t    (lk) ? \"LOCK\" : ((unlk) ? \"UNLK\" : \" \"));\n\t\treturn;\n\t}\n\tif (df == rf_DiskUnlockFunc) {\n\t\tpda = (RF_PhysDiskAddr_t *) node->params[0].p;\n\t\tlk = RF_EXTRACT_LOCK_FLAG(node->params[3].v);\n\t\tunlk = RF_EXTRACT_UNLOCK_FLAG(node->params[3].v);\n\t\tRF_ASSERT(!(lk && unlk));\n\t\tprintf(\"r %d c %d %s\\n\", pda->row, pda->col,\n\t\t    (lk) ? \"LOCK\" : ((unlk) ? \"UNLK\" : \"nop\"));\n\t\treturn;\n\t}\n\tif ((df == rf_SimpleXorFunc) || (df == rf_RegularXorFunc)\n\t    || (df == rf_RecoveryXorFunc)) {\n\t\tprintf(\"result buf 0x%lx\\n\", (long) node->results[0]);\n\t\tfor (i = 0; i < node->numParams - 1; i += 2) {\n\t\t\tpda = (RF_PhysDiskAddr_t *) node->params[i].p;\n\t\t\tbufPtr = (RF_PhysDiskAddr_t *) node->params[i + 1].p;\n\t\t\tprintf(\"    buf 0x%lx r%d c%d offs %ld nsect %d\\n\",\n\t\t\t    (long) bufPtr, pda->row, pda->col,\n\t\t\t    (long) pda->startSector, (int) pda->numSector);\n\t\t}\n\t\treturn;\n\t}\n#if RF_INCLUDE_PARITYLOGGING > 0\n\tif (df == rf_ParityLogOverwriteFunc || df == rf_ParityLogUpdateFunc) {\n\t\tfor (i = 0; i < node->numParams - 1; i += 2) {\n\t\t\tpda = (RF_PhysDiskAddr_t *) node->params[i].p;\n\t\t\tbufPtr = (RF_PhysDiskAddr_t *) node->params[i + 1].p;\n\t\t\tprintf(\" r%d c%d offs %ld nsect %d buf 0x%lx\\n\",\n\t\t\t    pda->row, pda->col, (long) pda->startSector,\n\t\t\t    (int) pda->numSector, (long) bufPtr);\n\t\t}\n\t\treturn;\n\t}\n#endif\t\t\t\t/* RF_INCLUDE_PARITYLOGGING > 0 */\n\n\tif ((df == rf_TerminateFunc) || (df == rf_NullNodeFunc)) {\n\t\tprintf(\"\\n\");\n\t\treturn;\n\t}\n\tprintf(\"?\\n\");\n}"
  },
  {
    "function_name": "rf_NodeStatusString",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagutils.c",
    "lines": "282-296",
    "snippet": "char   *\nrf_NodeStatusString(RF_DagNode_t * node)\n{\n\tswitch (node->status) {\n\t\tcase rf_wait:return (\"wait\");\n\tcase rf_fired:\n\t\treturn (\"fired\");\n\tcase rf_good:\n\t\treturn (\"good\");\n\tcase rf_bad:\n\t\treturn (\"bad\");\n\tdefault:\n\t\treturn (\"?\");\n\t}\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void rf_RecurPrintDAG(RF_DagNode_t *, int, int);",
      "static int \nrf_ValidateBranch(RF_DagNode_t *, int *, int *,\n    RF_DagNode_t **, int);",
      "static void rf_ValidateBranchVisitedBits(RF_DagNode_t *, int, int);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_map.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void rf_RecurPrintDAG(RF_DagNode_t *, int, int);\nstatic int \nrf_ValidateBranch(RF_DagNode_t *, int *, int *,\n    RF_DagNode_t **, int);\nstatic void rf_ValidateBranchVisitedBits(RF_DagNode_t *, int, int);\n\nchar   *\nrf_NodeStatusString(RF_DagNode_t * node)\n{\n\tswitch (node->status) {\n\t\tcase rf_wait:return (\"wait\");\n\tcase rf_fired:\n\t\treturn (\"fired\");\n\tcase rf_good:\n\t\treturn (\"good\");\n\tcase rf_bad:\n\t\treturn (\"bad\");\n\tdefault:\n\t\treturn (\"?\");\n\t}\n}"
  },
  {
    "function_name": "rf_AllocBuffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagutils.c",
    "lines": "263-275",
    "snippet": "void   *\nrf_AllocBuffer(\n    RF_Raid_t * raidPtr,\n    RF_DagHeader_t * dag_h,\n    RF_PhysDiskAddr_t * pda,\n    RF_AllocListElem_t * allocList)\n{\n\tchar   *p;\n\n\tRF_MallocAndAdd(p, pda->numSector << raidPtr->logBytesPerSector,\n\t    (char *), allocList);\n\treturn ((void *) p);\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void rf_PrintDAG(RF_DagHeader_t *);",
      "static void rf_ValidateVisitedBits(RF_DagHeader_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_MallocAndAdd",
          "args": [
            "p",
            "pda->numSector << raidPtr->logBytesPerSector",
            "(char *), allocList"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_map.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void rf_PrintDAG(RF_DagHeader_t *);\nstatic void rf_ValidateVisitedBits(RF_DagHeader_t *);\n\nvoid   *\nrf_AllocBuffer(\n    RF_Raid_t * raidPtr,\n    RF_DagHeader_t * dag_h,\n    RF_PhysDiskAddr_t * pda,\n    RF_AllocListElem_t * allocList)\n{\n\tchar   *p;\n\n\tRF_MallocAndAdd(p, pda->numSector << raidPtr->logBytesPerSector,\n\t    (char *), allocList);\n\treturn ((void *) p);\n}"
  },
  {
    "function_name": "rf_FreeDAGHeader",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagutils.c",
    "lines": "257-261",
    "snippet": "void \nrf_FreeDAGHeader(RF_DagHeader_t * dh)\n{\n\tRF_FREELIST_FREE(rf_dagh_freelist, dh, next);\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void rf_PrintDAG(RF_DagHeader_t *);",
      "static void rf_ValidateVisitedBits(RF_DagHeader_t *);",
      "static RF_FreeList_t *rf_dagh_freelist;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_FREELIST_FREE",
          "args": [
            "rf_dagh_freelist",
            "dh",
            "next"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_map.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void rf_PrintDAG(RF_DagHeader_t *);\nstatic void rf_ValidateVisitedBits(RF_DagHeader_t *);\nstatic RF_FreeList_t *rf_dagh_freelist;\n\nvoid \nrf_FreeDAGHeader(RF_DagHeader_t * dh)\n{\n\tRF_FREELIST_FREE(rf_dagh_freelist, dh, next);\n}"
  },
  {
    "function_name": "rf_AllocDAGHeader",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagutils.c",
    "lines": "245-255",
    "snippet": "RF_DagHeader_t *\nrf_AllocDAGHeader()\n{\n\tRF_DagHeader_t *dh;\n\n\tRF_FREELIST_GET(rf_dagh_freelist, dh, next, (RF_DagHeader_t *));\n\tif (dh) {\n\t\tbzero((char *) dh, sizeof(RF_DagHeader_t));\n\t}\n\treturn (dh);\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void rf_PrintDAG(RF_DagHeader_t *);",
      "static void rf_ValidateVisitedBits(RF_DagHeader_t *);",
      "static RF_FreeList_t *rf_dagh_freelist;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char *) dh",
            "sizeof(RF_DagHeader_t)"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_FREELIST_GET",
          "args": [
            "rf_dagh_freelist",
            "dh",
            "next",
            "(RF_DagHeader_t *)"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_map.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void rf_PrintDAG(RF_DagHeader_t *);\nstatic void rf_ValidateVisitedBits(RF_DagHeader_t *);\nstatic RF_FreeList_t *rf_dagh_freelist;\n\nRF_DagHeader_t *\nrf_AllocDAGHeader()\n{\n\tRF_DagHeader_t *dh;\n\n\tRF_FREELIST_GET(rf_dagh_freelist, dh, next, (RF_DagHeader_t *));\n\tif (dh) {\n\t\tbzero((char *) dh, sizeof(RF_DagHeader_t));\n\t}\n\treturn (dh);\n}"
  },
  {
    "function_name": "rf_ConfigureDAGs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagutils.c",
    "lines": "223-243",
    "snippet": "int \nrf_ConfigureDAGs(listp)\n\tRF_ShutdownList_t **listp;\n{\n\tint     rc;\n\n\tRF_FREELIST_CREATE(rf_dagh_freelist, RF_MAX_FREE_DAGH,\n\t    RF_DAGH_INC, sizeof(RF_DagHeader_t));\n\tif (rf_dagh_freelist == NULL)\n\t\treturn (ENOMEM);\n\trc = rf_ShutdownCreate(listp, rf_ShutdownDAGs, NULL);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to add to shutdown list file %s line %d rc=%d\\n\",\n\t\t    __FILE__, __LINE__, rc);\n\t\trf_ShutdownDAGs(NULL);\n\t\treturn (rc);\n\t}\n\tRF_FREELIST_PRIME(rf_dagh_freelist, RF_DAGH_INITIAL, next,\n\t    (RF_DagHeader_t *));\n\treturn (0);\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [
      "#define RF_DAGH_INITIAL   32",
      "#define RF_DAGH_INC       16",
      "#define RF_MAX_FREE_DAGH 128"
    ],
    "globals_used": [
      "static void rf_PrintDAG(RF_DagHeader_t *);",
      "static void rf_ValidateVisitedBits(RF_DagHeader_t *);",
      "static RF_FreeList_t *rf_dagh_freelist;",
      "static void rf_ShutdownDAGs(void *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_FREELIST_PRIME",
          "args": [
            "rf_dagh_freelist",
            "RF_DAGH_INITIAL",
            "next",
            "(RF_DagHeader_t *)"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_ShutdownDAGs",
          "args": [
            "NULL"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "rf_ShutdownDAGs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagutils.c",
          "lines": "216-221",
          "snippet": "static void \nrf_ShutdownDAGs(ignored)\n\tvoid   *ignored;\n{\n\tRF_FREELIST_DESTROY(rf_dagh_freelist, next, (RF_DagHeader_t *));\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_archs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void rf_PrintDAG(RF_DagHeader_t *);",
            "static void rf_ValidateVisitedBits(RF_DagHeader_t *);",
            "static RF_FreeList_t *rf_dagh_freelist;",
            "static void rf_ShutdownDAGs(void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_map.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void rf_PrintDAG(RF_DagHeader_t *);\nstatic void rf_ValidateVisitedBits(RF_DagHeader_t *);\nstatic RF_FreeList_t *rf_dagh_freelist;\nstatic void rf_ShutdownDAGs(void *);\n\nstatic void \nrf_ShutdownDAGs(ignored)\n\tvoid   *ignored;\n{\n\tRF_FREELIST_DESTROY(rf_dagh_freelist, next, (RF_DagHeader_t *));\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG3",
          "args": [
            "\"Unable to add to shutdown list file %s line %d rc=%d\\n\"",
            "__FILE__",
            "__LINE__",
            "rc"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_ShutdownCreate",
          "args": [
            "listp",
            "rf_ShutdownDAGs",
            "NULL"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_FREELIST_CREATE",
          "args": [
            "rf_dagh_freelist",
            "RF_MAX_FREE_DAGH",
            "RF_DAGH_INC",
            "sizeof(RF_DagHeader_t)"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_map.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\n#define RF_DAGH_INITIAL   32\n#define RF_DAGH_INC       16\n#define RF_MAX_FREE_DAGH 128\n\nstatic void rf_PrintDAG(RF_DagHeader_t *);\nstatic void rf_ValidateVisitedBits(RF_DagHeader_t *);\nstatic RF_FreeList_t *rf_dagh_freelist;\nstatic void rf_ShutdownDAGs(void *);\n\nint \nrf_ConfigureDAGs(listp)\n\tRF_ShutdownList_t **listp;\n{\n\tint     rc;\n\n\tRF_FREELIST_CREATE(rf_dagh_freelist, RF_MAX_FREE_DAGH,\n\t    RF_DAGH_INC, sizeof(RF_DagHeader_t));\n\tif (rf_dagh_freelist == NULL)\n\t\treturn (ENOMEM);\n\trc = rf_ShutdownCreate(listp, rf_ShutdownDAGs, NULL);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to add to shutdown list file %s line %d rc=%d\\n\",\n\t\t    __FILE__, __LINE__, rc);\n\t\trf_ShutdownDAGs(NULL);\n\t\treturn (rc);\n\t}\n\tRF_FREELIST_PRIME(rf_dagh_freelist, RF_DAGH_INITIAL, next,\n\t    (RF_DagHeader_t *));\n\treturn (0);\n}"
  },
  {
    "function_name": "rf_ShutdownDAGs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagutils.c",
    "lines": "216-221",
    "snippet": "static void \nrf_ShutdownDAGs(ignored)\n\tvoid   *ignored;\n{\n\tRF_FREELIST_DESTROY(rf_dagh_freelist, next, (RF_DagHeader_t *));\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void rf_PrintDAG(RF_DagHeader_t *);",
      "static void rf_ValidateVisitedBits(RF_DagHeader_t *);",
      "static RF_FreeList_t *rf_dagh_freelist;",
      "static void rf_ShutdownDAGs(void *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_FREELIST_DESTROY",
          "args": [
            "rf_dagh_freelist",
            "next",
            "(RF_DagHeader_t *)"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_map.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void rf_PrintDAG(RF_DagHeader_t *);\nstatic void rf_ValidateVisitedBits(RF_DagHeader_t *);\nstatic RF_FreeList_t *rf_dagh_freelist;\nstatic void rf_ShutdownDAGs(void *);\n\nstatic void \nrf_ShutdownDAGs(ignored)\n\tvoid   *ignored;\n{\n\tRF_FREELIST_DESTROY(rf_dagh_freelist, next, (RF_DagHeader_t *));\n}"
  },
  {
    "function_name": "rf_MakePropListEntry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagutils.c",
    "lines": "191-207",
    "snippet": "RF_PropHeader_t *\nrf_MakePropListEntry(\n    RF_DagHeader_t * dag_h,\n    int resultNum,\n    int paramNum,\n    RF_PropHeader_t * next,\n    RF_AllocListElem_t * allocList)\n{\n\tRF_PropHeader_t *p;\n\n\tRF_CallocAndAdd(p, 1, sizeof(RF_PropHeader_t),\n\t    (RF_PropHeader_t *), allocList);\n\tp->resultNum = resultNum;\n\tp->paramNum = paramNum;\n\tp->next = next;\n\treturn (p);\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void rf_PrintDAG(RF_DagHeader_t *);",
      "static void rf_ValidateVisitedBits(RF_DagHeader_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_CallocAndAdd",
          "args": [
            "p",
            "1",
            "sizeof(RF_PropHeader_t)",
            "(RF_PropHeader_t *), allocList"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_map.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void rf_PrintDAG(RF_DagHeader_t *);\nstatic void rf_ValidateVisitedBits(RF_DagHeader_t *);\n\nRF_PropHeader_t *\nrf_MakePropListEntry(\n    RF_DagHeader_t * dag_h,\n    int resultNum,\n    int paramNum,\n    RF_PropHeader_t * next,\n    RF_AllocListElem_t * allocList)\n{\n\tRF_PropHeader_t *p;\n\n\tRF_CallocAndAdd(p, 1, sizeof(RF_PropHeader_t),\n\t    (RF_PropHeader_t *), allocList);\n\tp->resultNum = resultNum;\n\tp->paramNum = paramNum;\n\tp->next = next;\n\treturn (p);\n}"
  },
  {
    "function_name": "rf_FreeDAG",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagutils.c",
    "lines": "153-189",
    "snippet": "void \nrf_FreeDAG(dag_h)\n\tRF_DagHeader_t *dag_h;\n{\n\tRF_AccessStripeMapHeader_t *asmap, *t_asmap;\n\tRF_DagHeader_t *nextDag;\n\tint     i;\n\n\twhile (dag_h) {\n\t\tnextDag = dag_h->next;\n\t\tfor (i = 0; dag_h->memChunk[i] && i < RF_MAXCHUNKS; i++) {\n\t\t\t/* release mem chunks */\n\t\t\trf_ReleaseMemChunk(dag_h->memChunk[i]);\n\t\t\tdag_h->memChunk[i] = NULL;\n\t\t}\n\n\t\tRF_ASSERT(i == dag_h->chunkIndex);\n\t\tif (dag_h->xtraChunkCnt > 0) {\n\t\t\t/* free xtraMemChunks */\n\t\t\tfor (i = 0; dag_h->xtraMemChunk[i] && i < dag_h->xtraChunkIndex; i++) {\n\t\t\t\trf_ReleaseMemChunk(dag_h->xtraMemChunk[i]);\n\t\t\t\tdag_h->xtraMemChunk[i] = NULL;\n\t\t\t}\n\t\t\tRF_ASSERT(i == dag_h->xtraChunkIndex);\n\t\t\t/* free ptrs to xtraMemChunks */\n\t\t\tRF_Free(dag_h->xtraMemChunk, dag_h->xtraChunkCnt * sizeof(RF_ChunkDesc_t *));\n\t\t}\n\t\trf_FreeAllocList(dag_h->allocList);\n\t\tfor (asmap = dag_h->asmList; asmap;) {\n\t\t\tt_asmap = asmap;\n\t\t\tasmap = asmap->next;\n\t\t\trf_FreeAccessStripeMap(t_asmap);\n\t\t}\n\t\trf_FreeDAGHeader(dag_h);\n\t\tdag_h = nextDag;\n\t}\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void rf_PrintDAG(RF_DagHeader_t *);",
      "static void rf_ValidateVisitedBits(RF_DagHeader_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_FreeDAGHeader",
          "args": [
            "dag_h"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "rf_FreeDAGHeader",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagutils.c",
          "lines": "257-261",
          "snippet": "void \nrf_FreeDAGHeader(RF_DagHeader_t * dh)\n{\n\tRF_FREELIST_FREE(rf_dagh_freelist, dh, next);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_archs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void rf_PrintDAG(RF_DagHeader_t *);",
            "static void rf_ValidateVisitedBits(RF_DagHeader_t *);",
            "static RF_FreeList_t *rf_dagh_freelist;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_map.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void rf_PrintDAG(RF_DagHeader_t *);\nstatic void rf_ValidateVisitedBits(RF_DagHeader_t *);\nstatic RF_FreeList_t *rf_dagh_freelist;\n\nvoid \nrf_FreeDAGHeader(RF_DagHeader_t * dh)\n{\n\tRF_FREELIST_FREE(rf_dagh_freelist, dh, next);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_FreeAccessStripeMap",
          "args": [
            "t_asmap"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "rf_FreeAccessStripeMap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_map.c",
          "lines": "537-598",
          "snippet": "void \nrf_FreeAccessStripeMap(hdr)\n\tRF_AccessStripeMapHeader_t *hdr;\n{\n\tRF_AccessStripeMap_t *p, *pt = NULL;\n\tRF_PhysDiskAddr_t *pdp, *trailer, *pdaList = NULL, *pdaEnd = NULL;\n\tint     count = 0, t, asm_count = 0;\n\n\tfor (p = hdr->stripeMap; p; p = p->next) {\n\n\t\t/* link the 3 pda lists into the accumulating pda list */\n\n\t\tif (!pdaList)\n\t\t\tpdaList = p->qInfo;\n\t\telse\n\t\t\tpdaEnd->next = p->qInfo;\n\t\tfor (trailer = NULL, pdp = p->qInfo; pdp;) {\n\t\t\ttrailer = pdp;\n\t\t\tpdp = pdp->next;\n\t\t\tcount++;\n\t\t}\n\t\tif (trailer)\n\t\t\tpdaEnd = trailer;\n\n\t\tif (!pdaList)\n\t\t\tpdaList = p->parityInfo;\n\t\telse\n\t\t\tpdaEnd->next = p->parityInfo;\n\t\tfor (trailer = NULL, pdp = p->parityInfo; pdp;) {\n\t\t\ttrailer = pdp;\n\t\t\tpdp = pdp->next;\n\t\t\tcount++;\n\t\t}\n\t\tif (trailer)\n\t\t\tpdaEnd = trailer;\n\n\t\tif (!pdaList)\n\t\t\tpdaList = p->physInfo;\n\t\telse\n\t\t\tpdaEnd->next = p->physInfo;\n\t\tfor (trailer = NULL, pdp = p->physInfo; pdp;) {\n\t\t\ttrailer = pdp;\n\t\t\tpdp = pdp->next;\n\t\t\tcount++;\n\t\t}\n\t\tif (trailer)\n\t\t\tpdaEnd = trailer;\n\n\t\tpt = p;\n\t\tasm_count++;\n\t}\n\n\t/* debug only */\n\tfor (t = 0, pdp = pdaList; pdp; pdp = pdp->next)\n\t\tt++;\n\tRF_ASSERT(t == count);\n\n\tif (pdaList)\n\t\trf_FreePDAList(pdaList, pdaEnd, count);\n\trf_FreeASMList(hdr->stripeMap, pt, asm_count);\n\trf_FreeAccessStripeMapHeader(hdr);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void rf_FreePDAList(RF_PhysDiskAddr_t * start, RF_PhysDiskAddr_t * end, int count);",
            "static void \nrf_FreeASMList(RF_AccessStripeMap_t * start, RF_AccessStripeMap_t * end,\n    int count);",
            "RF_PhysDiskAddr_t *\nrf_DuplicatePDA(pda)\n\tRF_PhysDiskAddr_t *pda;",
            "RF_PhysDiskAddr_t *\nrf_AllocPDAList(count)\n\tint     count;",
            "RF_AccessStripeMap_t *\nrf_AllocASMList(count)\n\tint     count;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_freelist.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic void rf_FreePDAList(RF_PhysDiskAddr_t * start, RF_PhysDiskAddr_t * end, int count);\nstatic void \nrf_FreeASMList(RF_AccessStripeMap_t * start, RF_AccessStripeMap_t * end,\n    int count);\nRF_PhysDiskAddr_t *\nrf_DuplicatePDA(pda)\n\tRF_PhysDiskAddr_t *pda;\nRF_PhysDiskAddr_t *\nrf_AllocPDAList(count)\n\tint     count;\nRF_AccessStripeMap_t *\nrf_AllocASMList(count)\n\tint     count;\n\nvoid \nrf_FreeAccessStripeMap(hdr)\n\tRF_AccessStripeMapHeader_t *hdr;\n{\n\tRF_AccessStripeMap_t *p, *pt = NULL;\n\tRF_PhysDiskAddr_t *pdp, *trailer, *pdaList = NULL, *pdaEnd = NULL;\n\tint     count = 0, t, asm_count = 0;\n\n\tfor (p = hdr->stripeMap; p; p = p->next) {\n\n\t\t/* link the 3 pda lists into the accumulating pda list */\n\n\t\tif (!pdaList)\n\t\t\tpdaList = p->qInfo;\n\t\telse\n\t\t\tpdaEnd->next = p->qInfo;\n\t\tfor (trailer = NULL, pdp = p->qInfo; pdp;) {\n\t\t\ttrailer = pdp;\n\t\t\tpdp = pdp->next;\n\t\t\tcount++;\n\t\t}\n\t\tif (trailer)\n\t\t\tpdaEnd = trailer;\n\n\t\tif (!pdaList)\n\t\t\tpdaList = p->parityInfo;\n\t\telse\n\t\t\tpdaEnd->next = p->parityInfo;\n\t\tfor (trailer = NULL, pdp = p->parityInfo; pdp;) {\n\t\t\ttrailer = pdp;\n\t\t\tpdp = pdp->next;\n\t\t\tcount++;\n\t\t}\n\t\tif (trailer)\n\t\t\tpdaEnd = trailer;\n\n\t\tif (!pdaList)\n\t\t\tpdaList = p->physInfo;\n\t\telse\n\t\t\tpdaEnd->next = p->physInfo;\n\t\tfor (trailer = NULL, pdp = p->physInfo; pdp;) {\n\t\t\ttrailer = pdp;\n\t\t\tpdp = pdp->next;\n\t\t\tcount++;\n\t\t}\n\t\tif (trailer)\n\t\t\tpdaEnd = trailer;\n\n\t\tpt = p;\n\t\tasm_count++;\n\t}\n\n\t/* debug only */\n\tfor (t = 0, pdp = pdaList; pdp; pdp = pdp->next)\n\t\tt++;\n\tRF_ASSERT(t == count);\n\n\tif (pdaList)\n\t\trf_FreePDAList(pdaList, pdaEnd, count);\n\trf_FreeASMList(hdr->stripeMap, pt, asm_count);\n\trf_FreeAccessStripeMapHeader(hdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_FreeAllocList",
          "args": [
            "dag_h->allocList"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "rf_FreeAllocList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_alloclist.c",
          "lines": "139-164",
          "snippet": "void \nrf_FreeAllocList(l)\n\tRF_AllocListElem_t *l;\n{\n\tint     i;\n\tRF_AllocListElem_t *temp, *p;\n\n\tfor (p = l; p; p = p->next) {\n\t\tRF_ASSERT(p->numPointers >= 0 && p->numPointers <= RF_POINTERS_PER_ALLOC_LIST_ELEMENT);\n\t\tfor (i = 0; i < p->numPointers; i++) {\n\t\t\tRF_ASSERT(p->pointers[i]);\n\t\t\tRF_Free(p->pointers[i], p->sizes[i]);\n\t\t}\n\t}\n\twhile (l) {\n\t\ttemp = l;\n\t\tl = l->next;\n\t\tif (al_free_list_count > RF_AL_FREELIST_MAX) {\n\t\t\tDO_FREE(temp, sizeof(*temp));\n\t\t} else {\n\t\t\ttemp->next = al_free_list;\n\t\t\tal_free_list = temp;\n\t\t\tal_free_list_count++;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define RF_AL_FREELIST_MAX 256"
          ],
          "globals_used": [
            "static RF_AllocListElem_t *al_free_list = NULL;",
            "static int al_free_list_count;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define RF_AL_FREELIST_MAX 256\n\nstatic RF_AllocListElem_t *al_free_list = NULL;\nstatic int al_free_list_count;\n\nvoid \nrf_FreeAllocList(l)\n\tRF_AllocListElem_t *l;\n{\n\tint     i;\n\tRF_AllocListElem_t *temp, *p;\n\n\tfor (p = l; p; p = p->next) {\n\t\tRF_ASSERT(p->numPointers >= 0 && p->numPointers <= RF_POINTERS_PER_ALLOC_LIST_ELEMENT);\n\t\tfor (i = 0; i < p->numPointers; i++) {\n\t\t\tRF_ASSERT(p->pointers[i]);\n\t\t\tRF_Free(p->pointers[i], p->sizes[i]);\n\t\t}\n\t}\n\twhile (l) {\n\t\ttemp = l;\n\t\tl = l->next;\n\t\tif (al_free_list_count > RF_AL_FREELIST_MAX) {\n\t\t\tDO_FREE(temp, sizeof(*temp));\n\t\t} else {\n\t\t\ttemp->next = al_free_list;\n\t\t\tal_free_list = temp;\n\t\t\tal_free_list_count++;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "dag_h->xtraMemChunk",
            "dag_h->xtraChunkCnt * sizeof(RF_ChunkDesc_t *)"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "i == dag_h->xtraChunkIndex"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_ReleaseMemChunk",
          "args": [
            "dag_h->xtraMemChunk[i]"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "rf_ReleaseMemChunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_memchunk.c",
          "lines": "186-211",
          "snippet": "void \nrf_ReleaseMemChunk(chunk)\n\tRF_ChunkDesc_t *chunk;\n{\n\tRF_ChunkHdr_t *hdr, *ht = NULL, *new;\n\n\tRF_LOCK_MUTEX(chunkmutex);\n\tfor (hdr = chunklist; hdr && hdr->size < chunk->size; ht = hdr, hdr = hdr->next);\n\tif (hdr && hdr->size == chunk->size) {\n\t\tchunk->next = hdr->list;\n\t\thdr->list = chunk;\n\t} else {\n\t\tRF_Malloc(new, sizeof(RF_ChunkHdr_t), (RF_ChunkHdr_t *));\n\t\tnew->size = chunk->size;\n\t\tnew->list = chunk;\n\t\tchunk->next = NULL;\n\t\tif (ht) {\n\t\t\tnew->next = ht->next;\n\t\t\tht->next = new;\n\t\t} else {\n\t\t\tnew->next = hdr;\n\t\t\tchunklist = new;\n\t\t}\n\t}\n\tRF_UNLOCK_MUTEX(chunkmutex);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_memchunk.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static RF_ChunkDesc_t *\nNewMemChunk(size, buf)\n\tint     size;",
            "RF_ChunkDesc_t *\nrf_GetMemChunk(size)\n\tint     size;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_memchunk.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic RF_ChunkDesc_t *\nNewMemChunk(size, buf)\n\tint     size;\nRF_ChunkDesc_t *\nrf_GetMemChunk(size)\n\tint     size;\n\nvoid \nrf_ReleaseMemChunk(chunk)\n\tRF_ChunkDesc_t *chunk;\n{\n\tRF_ChunkHdr_t *hdr, *ht = NULL, *new;\n\n\tRF_LOCK_MUTEX(chunkmutex);\n\tfor (hdr = chunklist; hdr && hdr->size < chunk->size; ht = hdr, hdr = hdr->next);\n\tif (hdr && hdr->size == chunk->size) {\n\t\tchunk->next = hdr->list;\n\t\thdr->list = chunk;\n\t} else {\n\t\tRF_Malloc(new, sizeof(RF_ChunkHdr_t), (RF_ChunkHdr_t *));\n\t\tnew->size = chunk->size;\n\t\tnew->list = chunk;\n\t\tchunk->next = NULL;\n\t\tif (ht) {\n\t\t\tnew->next = ht->next;\n\t\t\tht->next = new;\n\t\t} else {\n\t\t\tnew->next = hdr;\n\t\t\tchunklist = new;\n\t\t}\n\t}\n\tRF_UNLOCK_MUTEX(chunkmutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "i == dag_h->chunkIndex"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_map.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void rf_PrintDAG(RF_DagHeader_t *);\nstatic void rf_ValidateVisitedBits(RF_DagHeader_t *);\n\nvoid \nrf_FreeDAG(dag_h)\n\tRF_DagHeader_t *dag_h;\n{\n\tRF_AccessStripeMapHeader_t *asmap, *t_asmap;\n\tRF_DagHeader_t *nextDag;\n\tint     i;\n\n\twhile (dag_h) {\n\t\tnextDag = dag_h->next;\n\t\tfor (i = 0; dag_h->memChunk[i] && i < RF_MAXCHUNKS; i++) {\n\t\t\t/* release mem chunks */\n\t\t\trf_ReleaseMemChunk(dag_h->memChunk[i]);\n\t\t\tdag_h->memChunk[i] = NULL;\n\t\t}\n\n\t\tRF_ASSERT(i == dag_h->chunkIndex);\n\t\tif (dag_h->xtraChunkCnt > 0) {\n\t\t\t/* free xtraMemChunks */\n\t\t\tfor (i = 0; dag_h->xtraMemChunk[i] && i < dag_h->xtraChunkIndex; i++) {\n\t\t\t\trf_ReleaseMemChunk(dag_h->xtraMemChunk[i]);\n\t\t\t\tdag_h->xtraMemChunk[i] = NULL;\n\t\t\t}\n\t\t\tRF_ASSERT(i == dag_h->xtraChunkIndex);\n\t\t\t/* free ptrs to xtraMemChunks */\n\t\t\tRF_Free(dag_h->xtraMemChunk, dag_h->xtraChunkCnt * sizeof(RF_ChunkDesc_t *));\n\t\t}\n\t\trf_FreeAllocList(dag_h->allocList);\n\t\tfor (asmap = dag_h->asmList; asmap;) {\n\t\t\tt_asmap = asmap;\n\t\t\tasmap = asmap->next;\n\t\t\trf_FreeAccessStripeMap(t_asmap);\n\t\t}\n\t\trf_FreeDAGHeader(dag_h);\n\t\tdag_h = nextDag;\n\t}\n}"
  },
  {
    "function_name": "rf_InitNode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagutils.c",
    "lines": "74-143",
    "snippet": "void \nrf_InitNode(\n    RF_DagNode_t * node,\n    RF_NodeStatus_t initstatus,\n    int commit,\n    int (*doFunc) (RF_DagNode_t * node),\n    int (*undoFunc) (RF_DagNode_t * node),\n    int (*wakeFunc) (RF_DagNode_t * node, int status),\n    int nSucc,\n    int nAnte,\n    int nParam,\n    int nResult,\n    RF_DagHeader_t * hdr,\n    char *name,\n    RF_AllocListElem_t * alist)\n{\n\tvoid  **ptrs;\n\tint     nptrs;\n\n\tif (nAnte > RF_MAX_ANTECEDENTS)\n\t\tRF_PANIC();\n\tnode->status = initstatus;\n\tnode->commitNode = commit;\n\tnode->doFunc = doFunc;\n\tnode->undoFunc = undoFunc;\n\tnode->wakeFunc = wakeFunc;\n\tnode->numParams = nParam;\n\tnode->numResults = nResult;\n\tnode->numAntecedents = nAnte;\n\tnode->numAntDone = 0;\n\tnode->next = NULL;\n\tnode->numSuccedents = nSucc;\n\tnode->name = name;\n\tnode->dagHdr = hdr;\n\tnode->visited = 0;\n\n\t/* allocate all the pointers with one call to malloc */\n\tnptrs = nSucc + nAnte + nResult + nSucc;\n\n\tif (nptrs <= RF_DAG_PTRCACHESIZE) {\n\t\t/*\n\t         * The dag_ptrs field of the node is basically some scribble\n\t         * space to be used here. We could get rid of it, and always\n\t         * allocate the range of pointers, but that's expensive. So,\n\t         * we pick a \"common case\" size for the pointer cache. Hopefully,\n\t         * we'll find that:\n\t         * (1) Generally, nptrs doesn't exceed RF_DAG_PTRCACHESIZE by\n\t         *     only a little bit (least efficient case)\n\t         * (2) Generally, ntprs isn't a lot less than RF_DAG_PTRCACHESIZE\n\t         *     (wasted memory)\n\t         */\n\t\tptrs = (void **) node->dag_ptrs;\n\t} else {\n\t\tRF_CallocAndAdd(ptrs, nptrs, sizeof(void *), (void **), alist);\n\t}\n\tnode->succedents = (nSucc) ? (RF_DagNode_t **) ptrs : NULL;\n\tnode->antecedents = (nAnte) ? (RF_DagNode_t **) (ptrs + nSucc) : NULL;\n\tnode->results = (nResult) ? (void **) (ptrs + nSucc + nAnte) : NULL;\n\tnode->propList = (nSucc) ? (RF_PropHeader_t **) (ptrs + nSucc + nAnte + nResult) : NULL;\n\n\tif (nParam) {\n\t\tif (nParam <= RF_DAG_PARAMCACHESIZE) {\n\t\t\tnode->params = (RF_DagParam_t *) node->dag_params;\n\t\t} else {\n\t\t\tRF_CallocAndAdd(node->params, nParam, sizeof(RF_DagParam_t), (RF_DagParam_t *), alist);\n\t\t}\n\t} else {\n\t\tnode->params = NULL;\n\t}\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void rf_RecurPrintDAG(RF_DagNode_t *, int, int);",
      "static void rf_PrintDAG(RF_DagHeader_t *);",
      "static int \nrf_ValidateBranch(RF_DagNode_t *, int *, int *,\n    RF_DagNode_t **, int);",
      "static void rf_ValidateBranchVisitedBits(RF_DagNode_t *, int, int);",
      "static void rf_ValidateVisitedBits(RF_DagHeader_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_CallocAndAdd",
          "args": [
            "node->params",
            "nParam",
            "sizeof(RF_DagParam_t)",
            "(RF_DagParam_t *), alist"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_CallocAndAdd",
          "args": [
            "ptrs",
            "nptrs",
            "sizeof(void *)",
            "(void **), alist"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_PANIC",
          "args": [],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_map.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void rf_RecurPrintDAG(RF_DagNode_t *, int, int);\nstatic void rf_PrintDAG(RF_DagHeader_t *);\nstatic int \nrf_ValidateBranch(RF_DagNode_t *, int *, int *,\n    RF_DagNode_t **, int);\nstatic void rf_ValidateBranchVisitedBits(RF_DagNode_t *, int, int);\nstatic void rf_ValidateVisitedBits(RF_DagHeader_t *);\n\nvoid \nrf_InitNode(\n    RF_DagNode_t * node,\n    RF_NodeStatus_t initstatus,\n    int commit,\n    int (*doFunc) (RF_DagNode_t * node),\n    int (*undoFunc) (RF_DagNode_t * node),\n    int (*wakeFunc) (RF_DagNode_t * node, int status),\n    int nSucc,\n    int nAnte,\n    int nParam,\n    int nResult,\n    RF_DagHeader_t * hdr,\n    char *name,\n    RF_AllocListElem_t * alist)\n{\n\tvoid  **ptrs;\n\tint     nptrs;\n\n\tif (nAnte > RF_MAX_ANTECEDENTS)\n\t\tRF_PANIC();\n\tnode->status = initstatus;\n\tnode->commitNode = commit;\n\tnode->doFunc = doFunc;\n\tnode->undoFunc = undoFunc;\n\tnode->wakeFunc = wakeFunc;\n\tnode->numParams = nParam;\n\tnode->numResults = nResult;\n\tnode->numAntecedents = nAnte;\n\tnode->numAntDone = 0;\n\tnode->next = NULL;\n\tnode->numSuccedents = nSucc;\n\tnode->name = name;\n\tnode->dagHdr = hdr;\n\tnode->visited = 0;\n\n\t/* allocate all the pointers with one call to malloc */\n\tnptrs = nSucc + nAnte + nResult + nSucc;\n\n\tif (nptrs <= RF_DAG_PTRCACHESIZE) {\n\t\t/*\n\t         * The dag_ptrs field of the node is basically some scribble\n\t         * space to be used here. We could get rid of it, and always\n\t         * allocate the range of pointers, but that's expensive. So,\n\t         * we pick a \"common case\" size for the pointer cache. Hopefully,\n\t         * we'll find that:\n\t         * (1) Generally, nptrs doesn't exceed RF_DAG_PTRCACHESIZE by\n\t         *     only a little bit (least efficient case)\n\t         * (2) Generally, ntprs isn't a lot less than RF_DAG_PTRCACHESIZE\n\t         *     (wasted memory)\n\t         */\n\t\tptrs = (void **) node->dag_ptrs;\n\t} else {\n\t\tRF_CallocAndAdd(ptrs, nptrs, sizeof(void *), (void **), alist);\n\t}\n\tnode->succedents = (nSucc) ? (RF_DagNode_t **) ptrs : NULL;\n\tnode->antecedents = (nAnte) ? (RF_DagNode_t **) (ptrs + nSucc) : NULL;\n\tnode->results = (nResult) ? (void **) (ptrs + nSucc + nAnte) : NULL;\n\tnode->propList = (nSucc) ? (RF_PropHeader_t **) (ptrs + nSucc + nAnte + nResult) : NULL;\n\n\tif (nParam) {\n\t\tif (nParam <= RF_DAG_PARAMCACHESIZE) {\n\t\t\tnode->params = (RF_DagParam_t *) node->dag_params;\n\t\t} else {\n\t\t\tRF_CallocAndAdd(node->params, nParam, sizeof(RF_DagParam_t), (RF_DagParam_t *), alist);\n\t\t}\n\t} else {\n\t\tnode->params = NULL;\n\t}\n}"
  }
]