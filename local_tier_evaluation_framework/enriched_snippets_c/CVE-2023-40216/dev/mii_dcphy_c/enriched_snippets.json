[
  {
    "function_name": "dcphy_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/mii/dcphy.c",
    "lines": "480-493",
    "snippet": "void\ndcphy_reset(mii)\n\tstruct mii_softc\t*mii;\n{\n\tstruct dc_softc\t\t*sc;\n\n\tsc = mii->mii_pdata->mii_ifp->if_softc;\n\n\tDC_CLRBIT(sc, DC_SIARESET, DC_SIA_RESET);\n\tDELAY(1000);\n\tDC_SETBIT(sc, DC_SIARESET, DC_SIA_RESET);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/ic/dcreg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <dev/mii/miidevs.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/socket.h>",
      "#include <sys/errno.h>",
      "#include <sys/socket.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/device.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tdcphy_reset"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DC_SETBIT",
          "args": [
            "sc",
            "DC_SIARESET",
            "DC_SIA_RESET"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1000"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_CLRBIT",
          "args": [
            "sc",
            "DC_SIARESET",
            "DC_SIA_RESET"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <dev/mii/miidevs.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/errno.h>\n#include <sys/socket.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nvoid\tdcphy_reset;\n\nvoid\ndcphy_reset(mii)\n\tstruct mii_softc\t*mii;\n{\n\tstruct dc_softc\t\t*sc;\n\n\tsc = mii->mii_pdata->mii_ifp->if_softc;\n\n\tDC_CLRBIT(sc, DC_SIARESET, DC_SIA_RESET);\n\tDELAY(1000);\n\tDC_SETBIT(sc, DC_SIARESET, DC_SIA_RESET);\n\n\treturn;\n}"
  },
  {
    "function_name": "dcphy_auto",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/mii/dcphy.c",
    "lines": "430-478",
    "snippet": "int\ndcphy_auto(mii, waitfor)\n\tstruct mii_softc\t*mii;\n\tint\t\t\twaitfor;\n{\n\tint\t\t\ti;\n\tstruct dc_softc\t\t*sc;\n\n\tsc = mii->mii_pdata->mii_ifp->if_softc;\n\n\tif ((mii->mii_flags & MIIF_DOINGAUTO) == 0) {\n\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_PORTSEL);\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_FULLDUPLEX);\n\t\tDC_CLRBIT(sc, DC_SIARESET, DC_SIA_RESET);\n\t\tif (mii->mii_capabilities & BMSR_100TXHDX)\n\t\t\tCSR_WRITE_4(sc, DC_10BTCTRL, 0x3FFFF);\n\t\telse\n\t\t\tCSR_WRITE_4(sc, DC_10BTCTRL, 0xFFFF);\n\t\tDC_SETBIT(sc, DC_SIARESET, DC_SIA_RESET);\n\t\tDC_SETBIT(sc, DC_10BTCTRL, DC_TCTL_AUTONEGENBL);\n\t\tDC_SETBIT(sc, DC_10BTSTAT, DC_ASTAT_TXDISABLE);\n\t}\n\n\tif (waitfor) {\n\t\t/* Wait 500ms for it to complete. */\n\t\tfor (i = 0; i < 500; i++) {\n\t\t\tif ((CSR_READ_4(sc, DC_10BTSTAT) & DC_TSTAT_ANEGSTAT)\n\t\t\t    == DC_ASTAT_AUTONEGCMP)\n\t\t\t\treturn(0);\n\t\t\tDELAY(1000);\n\t\t}\n\t\t/*\n\t\t * Don't need to worry about clearing MIIF_DOINGAUTO.\n\t\t * If that's set, a timeout is pending, and it will\n\t\t * clear the flag.\n\t\t */\n\t\treturn(EIO);\n\t}\n\n\t/*\n\t * Just let it finish asynchronously.  This is for the benefit of\n\t * the tick handler driving autonegotiation.  Don't want 500ms\n\t * delays all the time while the system is running!\n\t */\n\tif ((mii->mii_flags & MIIF_DOINGAUTO) == 0)\n\t\tmii->mii_flags |= MIIF_DOINGAUTO;\n\n\treturn(EJUSTRETURN);\n}",
    "includes": [
      "#include <dev/ic/dcreg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <dev/mii/miidevs.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/socket.h>",
      "#include <sys/errno.h>",
      "#include <sys/socket.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/device.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tdcphy_auto"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1000"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "DC_10BTSTAT"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_SETBIT",
          "args": [
            "sc",
            "DC_10BTSTAT",
            "DC_ASTAT_TXDISABLE"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_SETBIT",
          "args": [
            "sc",
            "DC_10BTCTRL",
            "DC_TCTL_AUTONEGENBL"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_SETBIT",
          "args": [
            "sc",
            "DC_SIARESET",
            "DC_SIA_RESET"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "DC_10BTCTRL",
            "0xFFFF"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "DC_10BTCTRL",
            "0x3FFFF"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_CLRBIT",
          "args": [
            "sc",
            "DC_SIARESET",
            "DC_SIA_RESET"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_SETBIT",
          "args": [
            "sc",
            "DC_NETCFG",
            "DC_NETCFG_FULLDUPLEX"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_CLRBIT",
          "args": [
            "sc",
            "DC_NETCFG",
            "DC_NETCFG_PORTSEL"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <dev/mii/miidevs.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/errno.h>\n#include <sys/socket.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nint\tdcphy_auto;\n\nint\ndcphy_auto(mii, waitfor)\n\tstruct mii_softc\t*mii;\n\tint\t\t\twaitfor;\n{\n\tint\t\t\ti;\n\tstruct dc_softc\t\t*sc;\n\n\tsc = mii->mii_pdata->mii_ifp->if_softc;\n\n\tif ((mii->mii_flags & MIIF_DOINGAUTO) == 0) {\n\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_PORTSEL);\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_FULLDUPLEX);\n\t\tDC_CLRBIT(sc, DC_SIARESET, DC_SIA_RESET);\n\t\tif (mii->mii_capabilities & BMSR_100TXHDX)\n\t\t\tCSR_WRITE_4(sc, DC_10BTCTRL, 0x3FFFF);\n\t\telse\n\t\t\tCSR_WRITE_4(sc, DC_10BTCTRL, 0xFFFF);\n\t\tDC_SETBIT(sc, DC_SIARESET, DC_SIA_RESET);\n\t\tDC_SETBIT(sc, DC_10BTCTRL, DC_TCTL_AUTONEGENBL);\n\t\tDC_SETBIT(sc, DC_10BTSTAT, DC_ASTAT_TXDISABLE);\n\t}\n\n\tif (waitfor) {\n\t\t/* Wait 500ms for it to complete. */\n\t\tfor (i = 0; i < 500; i++) {\n\t\t\tif ((CSR_READ_4(sc, DC_10BTSTAT) & DC_TSTAT_ANEGSTAT)\n\t\t\t    == DC_ASTAT_AUTONEGCMP)\n\t\t\t\treturn(0);\n\t\t\tDELAY(1000);\n\t\t}\n\t\t/*\n\t\t * Don't need to worry about clearing MIIF_DOINGAUTO.\n\t\t * If that's set, a timeout is pending, and it will\n\t\t * clear the flag.\n\t\t */\n\t\treturn(EIO);\n\t}\n\n\t/*\n\t * Just let it finish asynchronously.  This is for the benefit of\n\t * the tick handler driving autonegotiation.  Don't want 500ms\n\t * delays all the time while the system is running!\n\t */\n\tif ((mii->mii_flags & MIIF_DOINGAUTO) == 0)\n\t\tmii->mii_flags |= MIIF_DOINGAUTO;\n\n\treturn(EJUSTRETURN);\n}"
  },
  {
    "function_name": "dcphy_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/mii/dcphy.c",
    "lines": "346-428",
    "snippet": "void\ndcphy_status(sc)\n\tstruct mii_softc *sc;\n{\n\tstruct mii_data *mii = sc->mii_pdata;\n\tint reg, anlpar;\n\tstruct dc_softc *dc_sc;\n\n\tdc_sc = mii->mii_ifp->if_softc;\n\n\tmii->mii_media_status = IFM_AVALID;\n\tmii->mii_media_active = IFM_ETHER;\n\n\treg = CSR_READ_4(dc_sc, DC_10BTSTAT) &\n\t     (DC_TSTAT_LS10|DC_TSTAT_LS100);\n\n\tif (!(reg & DC_TSTAT_LS10) || !(reg & DC_TSTAT_LS100))\n\t\tmii->mii_media_status |= IFM_ACTIVE;\n\n\tif (sc->mii_flags & MIIF_DOINGAUTO) {\n\t\tmii->mii_media_active |= IFM_NONE;\n\t\treturn;\n\t}\n\n\tif (CSR_READ_4(dc_sc, DC_10BTCTRL) & DC_TCTL_AUTONEGENBL &&\n\t    CSR_READ_4(dc_sc, DC_10BTSTAT) & DC_TSTAT_ANEGSTAT) {\n\t\t/* Erg, still trying, I guess... */\n\t\tif ((CSR_READ_4(dc_sc, DC_10BTSTAT) &\n\t\t    DC_ASTAT_AUTONEGCMP) != DC_ASTAT_AUTONEGCMP) {\n\t\t\tmii->mii_media_active |= IFM_NONE;\n\t\t\treturn;\n\t\t}\n\n\t\tif (CSR_READ_4(dc_sc, DC_10BTSTAT) & DC_TSTAT_LP_CAN_NWAY) {\n\t\t\tanlpar = CSR_READ_4(dc_sc, DC_10BTSTAT) >> 16;\n\t\t\tif (anlpar & ANLPAR_T4 &&\n\t\t\t    sc->mii_capabilities & BMSR_100TXHDX)\n\t\t\t\tmii->mii_media_active |= IFM_100_T4;\n\t\t\telse if (anlpar & ANLPAR_TX_FD &&\n\t\t\t    sc->mii_capabilities & BMSR_100TXHDX)\n\t\t\t\tmii->mii_media_active |= IFM_100_TX|IFM_FDX;\n\t\t\telse if (anlpar & ANLPAR_TX &&\n\t\t\t    sc->mii_capabilities & BMSR_100TXHDX)\n\t\t\t\tmii->mii_media_active |= IFM_100_TX;\n\t\t\telse if (anlpar & ANLPAR_10_FD)\n\t\t\t\tmii->mii_media_active |= IFM_10_T|IFM_FDX;\n\t\t\telse if (anlpar & ANLPAR_10)\n\t\t\t\tmii->mii_media_active |= IFM_10_T;\n\t\t\telse\n\t\t\t\tmii->mii_media_active |= IFM_NONE;\n\t\t\tif (DC_IS_INTEL(dc_sc))\n\t\t\t\tDC_CLRBIT(dc_sc, DC_10BTCTRL,\n\t\t\t\t    DC_TCTL_AUTONEGENBL);\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t * If the other side doesn't support NWAY, then the\n\t\t * best we can do is determine if we have a 10Mbps or\n\t\t * 100Mbps link. There's no way to know if the link \n\t\t * is full or half duplex, so we default to half duplex\n\t\t * and hope that the user is clever enough to manually\n\t\t * change the media settings if we're wrong.\n\t\t */\n\t\tif (!(reg & DC_TSTAT_LS100))\n\t\t\tmii->mii_media_active |= IFM_100_TX;\n\t\telse if (!(reg & DC_TSTAT_LS10))\n\t\t\tmii->mii_media_active |= IFM_10_T;\n\t\telse\n\t\t\tmii->mii_media_active |= IFM_NONE;\n\t\tif (DC_IS_INTEL(dc_sc))\n\t\t\tDC_CLRBIT(dc_sc, DC_10BTCTRL, DC_TCTL_AUTONEGENBL);\n\t\treturn;\n\t}\n\n\tif (CSR_READ_4(dc_sc, DC_NETCFG) & DC_NETCFG_SCRAMBLER)\n\t\tmii->mii_media_active |= IFM_100_TX;\n\telse\n\t\tmii->mii_media_active |= IFM_10_T;\n\tif (CSR_READ_4(dc_sc, DC_NETCFG) & DC_NETCFG_FULLDUPLEX)\n\t\tmii->mii_media_active |= IFM_FDX;\n\n\treturn;\n}",
    "includes": [
      "#include <dev/ic/dcreg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <dev/mii/miidevs.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/socket.h>",
      "#include <sys/errno.h>",
      "#include <sys/socket.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/device.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tdcphy_status"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "dc_sc",
            "DC_NETCFG"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "dc_sc",
            "DC_NETCFG"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_CLRBIT",
          "args": [
            "dc_sc",
            "DC_10BTCTRL",
            "DC_TCTL_AUTONEGENBL"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_IS_INTEL",
          "args": [
            "dc_sc"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_CLRBIT",
          "args": [
            "dc_sc",
            "DC_10BTCTRL",
            "DC_TCTL_AUTONEGENBL"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_IS_INTEL",
          "args": [
            "dc_sc"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "dc_sc",
            "DC_10BTSTAT"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "dc_sc",
            "DC_10BTSTAT"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "dc_sc",
            "DC_10BTSTAT"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "dc_sc",
            "DC_10BTSTAT"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "dc_sc",
            "DC_10BTCTRL"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "dc_sc",
            "DC_10BTSTAT"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <dev/mii/miidevs.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/errno.h>\n#include <sys/socket.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nvoid\tdcphy_status;\n\nvoid\ndcphy_status(sc)\n\tstruct mii_softc *sc;\n{\n\tstruct mii_data *mii = sc->mii_pdata;\n\tint reg, anlpar;\n\tstruct dc_softc *dc_sc;\n\n\tdc_sc = mii->mii_ifp->if_softc;\n\n\tmii->mii_media_status = IFM_AVALID;\n\tmii->mii_media_active = IFM_ETHER;\n\n\treg = CSR_READ_4(dc_sc, DC_10BTSTAT) &\n\t     (DC_TSTAT_LS10|DC_TSTAT_LS100);\n\n\tif (!(reg & DC_TSTAT_LS10) || !(reg & DC_TSTAT_LS100))\n\t\tmii->mii_media_status |= IFM_ACTIVE;\n\n\tif (sc->mii_flags & MIIF_DOINGAUTO) {\n\t\tmii->mii_media_active |= IFM_NONE;\n\t\treturn;\n\t}\n\n\tif (CSR_READ_4(dc_sc, DC_10BTCTRL) & DC_TCTL_AUTONEGENBL &&\n\t    CSR_READ_4(dc_sc, DC_10BTSTAT) & DC_TSTAT_ANEGSTAT) {\n\t\t/* Erg, still trying, I guess... */\n\t\tif ((CSR_READ_4(dc_sc, DC_10BTSTAT) &\n\t\t    DC_ASTAT_AUTONEGCMP) != DC_ASTAT_AUTONEGCMP) {\n\t\t\tmii->mii_media_active |= IFM_NONE;\n\t\t\treturn;\n\t\t}\n\n\t\tif (CSR_READ_4(dc_sc, DC_10BTSTAT) & DC_TSTAT_LP_CAN_NWAY) {\n\t\t\tanlpar = CSR_READ_4(dc_sc, DC_10BTSTAT) >> 16;\n\t\t\tif (anlpar & ANLPAR_T4 &&\n\t\t\t    sc->mii_capabilities & BMSR_100TXHDX)\n\t\t\t\tmii->mii_media_active |= IFM_100_T4;\n\t\t\telse if (anlpar & ANLPAR_TX_FD &&\n\t\t\t    sc->mii_capabilities & BMSR_100TXHDX)\n\t\t\t\tmii->mii_media_active |= IFM_100_TX|IFM_FDX;\n\t\t\telse if (anlpar & ANLPAR_TX &&\n\t\t\t    sc->mii_capabilities & BMSR_100TXHDX)\n\t\t\t\tmii->mii_media_active |= IFM_100_TX;\n\t\t\telse if (anlpar & ANLPAR_10_FD)\n\t\t\t\tmii->mii_media_active |= IFM_10_T|IFM_FDX;\n\t\t\telse if (anlpar & ANLPAR_10)\n\t\t\t\tmii->mii_media_active |= IFM_10_T;\n\t\t\telse\n\t\t\t\tmii->mii_media_active |= IFM_NONE;\n\t\t\tif (DC_IS_INTEL(dc_sc))\n\t\t\t\tDC_CLRBIT(dc_sc, DC_10BTCTRL,\n\t\t\t\t    DC_TCTL_AUTONEGENBL);\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t * If the other side doesn't support NWAY, then the\n\t\t * best we can do is determine if we have a 10Mbps or\n\t\t * 100Mbps link. There's no way to know if the link \n\t\t * is full or half duplex, so we default to half duplex\n\t\t * and hope that the user is clever enough to manually\n\t\t * change the media settings if we're wrong.\n\t\t */\n\t\tif (!(reg & DC_TSTAT_LS100))\n\t\t\tmii->mii_media_active |= IFM_100_TX;\n\t\telse if (!(reg & DC_TSTAT_LS10))\n\t\t\tmii->mii_media_active |= IFM_10_T;\n\t\telse\n\t\t\tmii->mii_media_active |= IFM_NONE;\n\t\tif (DC_IS_INTEL(dc_sc))\n\t\t\tDC_CLRBIT(dc_sc, DC_10BTCTRL, DC_TCTL_AUTONEGENBL);\n\t\treturn;\n\t}\n\n\tif (CSR_READ_4(dc_sc, DC_NETCFG) & DC_NETCFG_SCRAMBLER)\n\t\tmii->mii_media_active |= IFM_100_TX;\n\telse\n\t\tmii->mii_media_active |= IFM_10_T;\n\tif (CSR_READ_4(dc_sc, DC_NETCFG) & DC_NETCFG_FULLDUPLEX)\n\t\tmii->mii_media_active |= IFM_FDX;\n\n\treturn;\n}"
  },
  {
    "function_name": "dcphy_service",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/mii/dcphy.c",
    "lines": "172-344",
    "snippet": "int\ndcphy_service(sc, mii, cmd)\n\tstruct mii_softc *sc;\n\tstruct mii_data *mii;\n\tint cmd;\n{\n\tstruct dc_softc *dc_sc;\n\tstruct ifmedia_entry *ife = mii->mii_media.ifm_cur;\n\tint reg;\n\tu_int32_t mode;\n\n\tdc_sc = mii->mii_ifp->if_softc;\n\n\tswitch (cmd) {\n\tcase MII_POLLSTAT:\n\t\t/*\n\t\t * If we're not polling our PHY instance, just return.\n\t\t */\n\t\tif (IFM_INST(ife->ifm_media) != sc->mii_inst) {\n\t\t\treturn (0);\n\t\t}\n\t\tbreak;\n\n\tcase MII_MEDIACHG:\n\t\t/*\n\t\t * If the media indicates a different PHY instance,\n\t\t * isolate ourselves.\n\t\t */\n\t\tif (IFM_INST(ife->ifm_media) != sc->mii_inst) {\n\t\t\treturn (0);\n\t\t}\n\n\t\t/*\n\t\t * If the interface is not up, don't do anything.\n\t\t */\n\t\tif ((mii->mii_ifp->if_flags & IFF_UP) == 0)\n\t\t\tbreak;\n\n\t\tsc->mii_flags = 0;\n\t\tmii->mii_media_active = IFM_NONE;\n\t\tmode = CSR_READ_4(dc_sc, DC_NETCFG);\n\t\tmode &= ~(DC_NETCFG_FULLDUPLEX|DC_NETCFG_PORTSEL|\n\t\t    DC_NETCFG_PCS|DC_NETCFG_SCRAMBLER|DC_NETCFG_SPEEDSEL);\n\n\t\tswitch (IFM_SUBTYPE(ife->ifm_media)) {\n\t\tcase IFM_AUTO:\n\t\t\t/*dcphy_reset(sc);*/\n\t\t\t(void) dcphy_auto(sc, 0);\n\t\t\tbreak;\n\t\tcase IFM_100_T4:\n\t\t\t/*\n\t\t\t * XXX Not supported as a manual setting right now.\n\t\t\t */\n\t\t\treturn (EINVAL);\n\t\tcase IFM_100_TX:\n\t\t\tdcphy_reset(sc);\n\t\t\tDC_CLRBIT(dc_sc, DC_10BTCTRL, DC_TCTL_AUTONEGENBL);\n\t\t\tmode |= DC_NETCFG_PORTSEL|DC_NETCFG_PCS|\n\t\t\t    DC_NETCFG_SCRAMBLER;\n\t\t\tif ((ife->ifm_media & IFM_GMASK) == IFM_FDX)\n\t\t\t\tmode |= DC_NETCFG_FULLDUPLEX;\n\t\t\telse\n\t\t\t\tmode &= ~DC_NETCFG_FULLDUPLEX;\n\t\t\tCSR_WRITE_4(dc_sc, DC_NETCFG, mode);\n\t\t\tbreak;\n\t\tcase IFM_10_T:\n\t\t\tDC_CLRBIT(dc_sc, DC_SIARESET, DC_SIA_RESET);\n\t\t\tDC_CLRBIT(dc_sc, DC_10BTCTRL, 0xFFFF);\n\t\t\tif ((ife->ifm_media & IFM_GMASK) == IFM_FDX)\n\t\t\t\tDC_SETBIT(dc_sc, DC_10BTCTRL, 0x7F3D);\n\t\t\telse\n\t\t\t\tDC_SETBIT(dc_sc, DC_10BTCTRL, 0x7F3F);\n\t\t\tDC_SETBIT(dc_sc, DC_SIARESET, DC_SIA_RESET);\n\t\t\tDC_CLRBIT(dc_sc, DC_10BTCTRL, DC_TCTL_AUTONEGENBL);\n\t\t\tmode &= ~DC_NETCFG_PORTSEL;\n\t\t\tmode |= DC_NETCFG_SPEEDSEL;\n\t\t\tif ((ife->ifm_media & IFM_GMASK) == IFM_FDX)\n\t\t\t\tmode |= DC_NETCFG_FULLDUPLEX;\n\t\t\telse\n\t\t\t\tmode &= ~DC_NETCFG_FULLDUPLEX;\n\t\t\tCSR_WRITE_4(dc_sc, DC_NETCFG, mode);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn(EINVAL);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase MII_TICK:\n\t\t/*\n\t\t * If we're not currently selected, just return.\n\t\t */\n\t\tif (IFM_INST(ife->ifm_media) != sc->mii_inst)\n\t\t\treturn (0);\n\n\t\t/*\n\t\t * Only used for autonegotiation.\n\t\t */\n\t\tif (IFM_SUBTYPE(ife->ifm_media) != IFM_AUTO)\n\t\t\treturn (0);\n\n\t\t/*\n\t\t * Is the interface even up?\n\t\t */\n\t\tif ((mii->mii_ifp->if_flags & IFF_UP) == 0)\n\t\t\treturn (0);\n\n\t\tif (sc->mii_flags & MIIF_DOINGAUTO) {\n\t\t\tif (++sc->mii_ticks != 5)\n\t\t\t\treturn(0);\n\t\t\telse {\n\t\t\t\tsc->mii_ticks = 0;\n\t\t\t\tsc->mii_flags &= ~MIIF_DOINGAUTO;\n\t\t\t\tsc->mii_flags |= MIIF_AUTOTIMEOUT;\n\t\t\t}\n\t\t}\n\n\t\tsc->mii_flags &= ~MIIF_DOINGAUTO;\n\n\t\t/*\n\t\t * Check to see if we have link.  If we do, we don't\n\t\t * need to restart the autonegotiation process.  Read\n\t\t * the BMSR twice in case it's latched.\n\t\t */\n\t\treg = CSR_READ_4(dc_sc, DC_10BTSTAT) &\n\t\t    (DC_TSTAT_LS10|DC_TSTAT_LS100);\n\n\t\tif (IFM_SUBTYPE(mii->mii_media_active) == IFM_100_TX &&\n\t\t    !(reg & DC_TSTAT_LS100)) {\n\t\t\tif (sc->mii_flags & MIIF_AUTOTIMEOUT) {\n\t\t\t\tsc->mii_flags &= ~MIIF_AUTOTIMEOUT;\n\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t\treturn(0);\n\t\t} else if (IFM_SUBTYPE(mii->mii_media_active) == IFM_10_T &&\n\t\t    !(reg & DC_TSTAT_LS10)) {\n\t\t\tif (sc->mii_flags & MIIF_AUTOTIMEOUT) {\n\t\t\t\tsc->mii_flags &= ~MIIF_AUTOTIMEOUT;\n\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t\treturn(0);\n\t\t} else if (IFM_SUBTYPE(mii->mii_media_active) == IFM_NONE &&\n\t\t    (!(reg & DC_TSTAT_LS10) || !(reg & DC_TSTAT_LS100))) {\n\t\t\tif (sc->mii_flags & MIIF_AUTOTIMEOUT) {\n\t\t\t\tsc->mii_flags &= ~MIIF_AUTOTIMEOUT;\n\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t\treturn(0);\n\t\t} else if (CSR_READ_4(dc_sc, DC_ISR) & DC_ISR_LINKGOOD) {\n\t\t\tif (sc->mii_flags & MIIF_AUTOTIMEOUT) {\n\t\t\t\tsc->mii_flags &= ~MIIF_AUTOTIMEOUT;\n\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t\treturn(0);\n\t\t}\n\n\t\tsc->mii_ticks = 0;\n\t\t/*dcphy_reset(sc);*/\n\t\tdcphy_auto(sc, 0);\n\n\t\tbreak;\n\t}\n\n\t/* Update the media status. */\n\tdcphy_status(sc);\n\n\t/* Callback if something changed. */\n\tif (sc->mii_active != mii->mii_media_active || cmd == MII_MEDIACHG) {\n\t\t(*mii->mii_statchg)(sc->mii_dev.dv_parent);\n\t\tsc->mii_active = mii->mii_media_active;\n\t}\n\treturn (0);\n}",
    "includes": [
      "#include <dev/ic/dcreg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <dev/mii/miidevs.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/socket.h>",
      "#include <sys/errno.h>",
      "#include <sys/socket.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/device.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define MIIF_AUTOTIMEOUT\t0x0004"
    ],
    "globals_used": [
      "int\tdcphy_service",
      "void\tdcphy_status",
      "int\tdcphy_auto",
      "void\tdcphy_reset"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc->mii_dev.dv_parent"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dcphy_status",
          "args": [
            "sc"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "dcphy_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/mii/dcphy.c",
          "lines": "346-428",
          "snippet": "void\ndcphy_status(sc)\n\tstruct mii_softc *sc;\n{\n\tstruct mii_data *mii = sc->mii_pdata;\n\tint reg, anlpar;\n\tstruct dc_softc *dc_sc;\n\n\tdc_sc = mii->mii_ifp->if_softc;\n\n\tmii->mii_media_status = IFM_AVALID;\n\tmii->mii_media_active = IFM_ETHER;\n\n\treg = CSR_READ_4(dc_sc, DC_10BTSTAT) &\n\t     (DC_TSTAT_LS10|DC_TSTAT_LS100);\n\n\tif (!(reg & DC_TSTAT_LS10) || !(reg & DC_TSTAT_LS100))\n\t\tmii->mii_media_status |= IFM_ACTIVE;\n\n\tif (sc->mii_flags & MIIF_DOINGAUTO) {\n\t\tmii->mii_media_active |= IFM_NONE;\n\t\treturn;\n\t}\n\n\tif (CSR_READ_4(dc_sc, DC_10BTCTRL) & DC_TCTL_AUTONEGENBL &&\n\t    CSR_READ_4(dc_sc, DC_10BTSTAT) & DC_TSTAT_ANEGSTAT) {\n\t\t/* Erg, still trying, I guess... */\n\t\tif ((CSR_READ_4(dc_sc, DC_10BTSTAT) &\n\t\t    DC_ASTAT_AUTONEGCMP) != DC_ASTAT_AUTONEGCMP) {\n\t\t\tmii->mii_media_active |= IFM_NONE;\n\t\t\treturn;\n\t\t}\n\n\t\tif (CSR_READ_4(dc_sc, DC_10BTSTAT) & DC_TSTAT_LP_CAN_NWAY) {\n\t\t\tanlpar = CSR_READ_4(dc_sc, DC_10BTSTAT) >> 16;\n\t\t\tif (anlpar & ANLPAR_T4 &&\n\t\t\t    sc->mii_capabilities & BMSR_100TXHDX)\n\t\t\t\tmii->mii_media_active |= IFM_100_T4;\n\t\t\telse if (anlpar & ANLPAR_TX_FD &&\n\t\t\t    sc->mii_capabilities & BMSR_100TXHDX)\n\t\t\t\tmii->mii_media_active |= IFM_100_TX|IFM_FDX;\n\t\t\telse if (anlpar & ANLPAR_TX &&\n\t\t\t    sc->mii_capabilities & BMSR_100TXHDX)\n\t\t\t\tmii->mii_media_active |= IFM_100_TX;\n\t\t\telse if (anlpar & ANLPAR_10_FD)\n\t\t\t\tmii->mii_media_active |= IFM_10_T|IFM_FDX;\n\t\t\telse if (anlpar & ANLPAR_10)\n\t\t\t\tmii->mii_media_active |= IFM_10_T;\n\t\t\telse\n\t\t\t\tmii->mii_media_active |= IFM_NONE;\n\t\t\tif (DC_IS_INTEL(dc_sc))\n\t\t\t\tDC_CLRBIT(dc_sc, DC_10BTCTRL,\n\t\t\t\t    DC_TCTL_AUTONEGENBL);\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t * If the other side doesn't support NWAY, then the\n\t\t * best we can do is determine if we have a 10Mbps or\n\t\t * 100Mbps link. There's no way to know if the link \n\t\t * is full or half duplex, so we default to half duplex\n\t\t * and hope that the user is clever enough to manually\n\t\t * change the media settings if we're wrong.\n\t\t */\n\t\tif (!(reg & DC_TSTAT_LS100))\n\t\t\tmii->mii_media_active |= IFM_100_TX;\n\t\telse if (!(reg & DC_TSTAT_LS10))\n\t\t\tmii->mii_media_active |= IFM_10_T;\n\t\telse\n\t\t\tmii->mii_media_active |= IFM_NONE;\n\t\tif (DC_IS_INTEL(dc_sc))\n\t\t\tDC_CLRBIT(dc_sc, DC_10BTCTRL, DC_TCTL_AUTONEGENBL);\n\t\treturn;\n\t}\n\n\tif (CSR_READ_4(dc_sc, DC_NETCFG) & DC_NETCFG_SCRAMBLER)\n\t\tmii->mii_media_active |= IFM_100_TX;\n\telse\n\t\tmii->mii_media_active |= IFM_10_T;\n\tif (CSR_READ_4(dc_sc, DC_NETCFG) & DC_NETCFG_FULLDUPLEX)\n\t\tmii->mii_media_active |= IFM_FDX;\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <dev/mii/miidevs.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tdcphy_status"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <dev/mii/miidevs.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/errno.h>\n#include <sys/socket.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nvoid\tdcphy_status;\n\nvoid\ndcphy_status(sc)\n\tstruct mii_softc *sc;\n{\n\tstruct mii_data *mii = sc->mii_pdata;\n\tint reg, anlpar;\n\tstruct dc_softc *dc_sc;\n\n\tdc_sc = mii->mii_ifp->if_softc;\n\n\tmii->mii_media_status = IFM_AVALID;\n\tmii->mii_media_active = IFM_ETHER;\n\n\treg = CSR_READ_4(dc_sc, DC_10BTSTAT) &\n\t     (DC_TSTAT_LS10|DC_TSTAT_LS100);\n\n\tif (!(reg & DC_TSTAT_LS10) || !(reg & DC_TSTAT_LS100))\n\t\tmii->mii_media_status |= IFM_ACTIVE;\n\n\tif (sc->mii_flags & MIIF_DOINGAUTO) {\n\t\tmii->mii_media_active |= IFM_NONE;\n\t\treturn;\n\t}\n\n\tif (CSR_READ_4(dc_sc, DC_10BTCTRL) & DC_TCTL_AUTONEGENBL &&\n\t    CSR_READ_4(dc_sc, DC_10BTSTAT) & DC_TSTAT_ANEGSTAT) {\n\t\t/* Erg, still trying, I guess... */\n\t\tif ((CSR_READ_4(dc_sc, DC_10BTSTAT) &\n\t\t    DC_ASTAT_AUTONEGCMP) != DC_ASTAT_AUTONEGCMP) {\n\t\t\tmii->mii_media_active |= IFM_NONE;\n\t\t\treturn;\n\t\t}\n\n\t\tif (CSR_READ_4(dc_sc, DC_10BTSTAT) & DC_TSTAT_LP_CAN_NWAY) {\n\t\t\tanlpar = CSR_READ_4(dc_sc, DC_10BTSTAT) >> 16;\n\t\t\tif (anlpar & ANLPAR_T4 &&\n\t\t\t    sc->mii_capabilities & BMSR_100TXHDX)\n\t\t\t\tmii->mii_media_active |= IFM_100_T4;\n\t\t\telse if (anlpar & ANLPAR_TX_FD &&\n\t\t\t    sc->mii_capabilities & BMSR_100TXHDX)\n\t\t\t\tmii->mii_media_active |= IFM_100_TX|IFM_FDX;\n\t\t\telse if (anlpar & ANLPAR_TX &&\n\t\t\t    sc->mii_capabilities & BMSR_100TXHDX)\n\t\t\t\tmii->mii_media_active |= IFM_100_TX;\n\t\t\telse if (anlpar & ANLPAR_10_FD)\n\t\t\t\tmii->mii_media_active |= IFM_10_T|IFM_FDX;\n\t\t\telse if (anlpar & ANLPAR_10)\n\t\t\t\tmii->mii_media_active |= IFM_10_T;\n\t\t\telse\n\t\t\t\tmii->mii_media_active |= IFM_NONE;\n\t\t\tif (DC_IS_INTEL(dc_sc))\n\t\t\t\tDC_CLRBIT(dc_sc, DC_10BTCTRL,\n\t\t\t\t    DC_TCTL_AUTONEGENBL);\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t * If the other side doesn't support NWAY, then the\n\t\t * best we can do is determine if we have a 10Mbps or\n\t\t * 100Mbps link. There's no way to know if the link \n\t\t * is full or half duplex, so we default to half duplex\n\t\t * and hope that the user is clever enough to manually\n\t\t * change the media settings if we're wrong.\n\t\t */\n\t\tif (!(reg & DC_TSTAT_LS100))\n\t\t\tmii->mii_media_active |= IFM_100_TX;\n\t\telse if (!(reg & DC_TSTAT_LS10))\n\t\t\tmii->mii_media_active |= IFM_10_T;\n\t\telse\n\t\t\tmii->mii_media_active |= IFM_NONE;\n\t\tif (DC_IS_INTEL(dc_sc))\n\t\t\tDC_CLRBIT(dc_sc, DC_10BTCTRL, DC_TCTL_AUTONEGENBL);\n\t\treturn;\n\t}\n\n\tif (CSR_READ_4(dc_sc, DC_NETCFG) & DC_NETCFG_SCRAMBLER)\n\t\tmii->mii_media_active |= IFM_100_TX;\n\telse\n\t\tmii->mii_media_active |= IFM_10_T;\n\tif (CSR_READ_4(dc_sc, DC_NETCFG) & DC_NETCFG_FULLDUPLEX)\n\t\tmii->mii_media_active |= IFM_FDX;\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dcphy_auto",
          "args": [
            "sc",
            "0"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "dcphy_auto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/mii/dcphy.c",
          "lines": "430-478",
          "snippet": "int\ndcphy_auto(mii, waitfor)\n\tstruct mii_softc\t*mii;\n\tint\t\t\twaitfor;\n{\n\tint\t\t\ti;\n\tstruct dc_softc\t\t*sc;\n\n\tsc = mii->mii_pdata->mii_ifp->if_softc;\n\n\tif ((mii->mii_flags & MIIF_DOINGAUTO) == 0) {\n\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_PORTSEL);\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_FULLDUPLEX);\n\t\tDC_CLRBIT(sc, DC_SIARESET, DC_SIA_RESET);\n\t\tif (mii->mii_capabilities & BMSR_100TXHDX)\n\t\t\tCSR_WRITE_4(sc, DC_10BTCTRL, 0x3FFFF);\n\t\telse\n\t\t\tCSR_WRITE_4(sc, DC_10BTCTRL, 0xFFFF);\n\t\tDC_SETBIT(sc, DC_SIARESET, DC_SIA_RESET);\n\t\tDC_SETBIT(sc, DC_10BTCTRL, DC_TCTL_AUTONEGENBL);\n\t\tDC_SETBIT(sc, DC_10BTSTAT, DC_ASTAT_TXDISABLE);\n\t}\n\n\tif (waitfor) {\n\t\t/* Wait 500ms for it to complete. */\n\t\tfor (i = 0; i < 500; i++) {\n\t\t\tif ((CSR_READ_4(sc, DC_10BTSTAT) & DC_TSTAT_ANEGSTAT)\n\t\t\t    == DC_ASTAT_AUTONEGCMP)\n\t\t\t\treturn(0);\n\t\t\tDELAY(1000);\n\t\t}\n\t\t/*\n\t\t * Don't need to worry about clearing MIIF_DOINGAUTO.\n\t\t * If that's set, a timeout is pending, and it will\n\t\t * clear the flag.\n\t\t */\n\t\treturn(EIO);\n\t}\n\n\t/*\n\t * Just let it finish asynchronously.  This is for the benefit of\n\t * the tick handler driving autonegotiation.  Don't want 500ms\n\t * delays all the time while the system is running!\n\t */\n\tif ((mii->mii_flags & MIIF_DOINGAUTO) == 0)\n\t\tmii->mii_flags |= MIIF_DOINGAUTO;\n\n\treturn(EJUSTRETURN);\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <dev/mii/miidevs.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tdcphy_auto"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <dev/mii/miidevs.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/errno.h>\n#include <sys/socket.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nint\tdcphy_auto;\n\nint\ndcphy_auto(mii, waitfor)\n\tstruct mii_softc\t*mii;\n\tint\t\t\twaitfor;\n{\n\tint\t\t\ti;\n\tstruct dc_softc\t\t*sc;\n\n\tsc = mii->mii_pdata->mii_ifp->if_softc;\n\n\tif ((mii->mii_flags & MIIF_DOINGAUTO) == 0) {\n\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_PORTSEL);\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_FULLDUPLEX);\n\t\tDC_CLRBIT(sc, DC_SIARESET, DC_SIA_RESET);\n\t\tif (mii->mii_capabilities & BMSR_100TXHDX)\n\t\t\tCSR_WRITE_4(sc, DC_10BTCTRL, 0x3FFFF);\n\t\telse\n\t\t\tCSR_WRITE_4(sc, DC_10BTCTRL, 0xFFFF);\n\t\tDC_SETBIT(sc, DC_SIARESET, DC_SIA_RESET);\n\t\tDC_SETBIT(sc, DC_10BTCTRL, DC_TCTL_AUTONEGENBL);\n\t\tDC_SETBIT(sc, DC_10BTSTAT, DC_ASTAT_TXDISABLE);\n\t}\n\n\tif (waitfor) {\n\t\t/* Wait 500ms for it to complete. */\n\t\tfor (i = 0; i < 500; i++) {\n\t\t\tif ((CSR_READ_4(sc, DC_10BTSTAT) & DC_TSTAT_ANEGSTAT)\n\t\t\t    == DC_ASTAT_AUTONEGCMP)\n\t\t\t\treturn(0);\n\t\t\tDELAY(1000);\n\t\t}\n\t\t/*\n\t\t * Don't need to worry about clearing MIIF_DOINGAUTO.\n\t\t * If that's set, a timeout is pending, and it will\n\t\t * clear the flag.\n\t\t */\n\t\treturn(EIO);\n\t}\n\n\t/*\n\t * Just let it finish asynchronously.  This is for the benefit of\n\t * the tick handler driving autonegotiation.  Don't want 500ms\n\t * delays all the time while the system is running!\n\t */\n\tif ((mii->mii_flags & MIIF_DOINGAUTO) == 0)\n\t\tmii->mii_flags |= MIIF_DOINGAUTO;\n\n\treturn(EJUSTRETURN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "dc_sc",
            "DC_ISR"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFM_SUBTYPE",
          "args": [
            "mii->mii_media_active"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFM_SUBTYPE",
          "args": [
            "mii->mii_media_active"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFM_SUBTYPE",
          "args": [
            "mii->mii_media_active"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "dc_sc",
            "DC_10BTSTAT"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFM_SUBTYPE",
          "args": [
            "ife->ifm_media"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFM_INST",
          "args": [
            "ife->ifm_media"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "dc_sc",
            "DC_NETCFG",
            "mode"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_CLRBIT",
          "args": [
            "dc_sc",
            "DC_10BTCTRL",
            "DC_TCTL_AUTONEGENBL"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_SETBIT",
          "args": [
            "dc_sc",
            "DC_SIARESET",
            "DC_SIA_RESET"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_SETBIT",
          "args": [
            "dc_sc",
            "DC_10BTCTRL",
            "0x7F3F"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_SETBIT",
          "args": [
            "dc_sc",
            "DC_10BTCTRL",
            "0x7F3D"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_CLRBIT",
          "args": [
            "dc_sc",
            "DC_10BTCTRL",
            "0xFFFF"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_CLRBIT",
          "args": [
            "dc_sc",
            "DC_SIARESET",
            "DC_SIA_RESET"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "dc_sc",
            "DC_NETCFG",
            "mode"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_CLRBIT",
          "args": [
            "dc_sc",
            "DC_10BTCTRL",
            "DC_TCTL_AUTONEGENBL"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dcphy_reset",
          "args": [
            "sc"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "dcphy_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/mii/dcphy.c",
          "lines": "480-493",
          "snippet": "void\ndcphy_reset(mii)\n\tstruct mii_softc\t*mii;\n{\n\tstruct dc_softc\t\t*sc;\n\n\tsc = mii->mii_pdata->mii_ifp->if_softc;\n\n\tDC_CLRBIT(sc, DC_SIARESET, DC_SIA_RESET);\n\tDELAY(1000);\n\tDC_SETBIT(sc, DC_SIARESET, DC_SIA_RESET);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <dev/mii/miidevs.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tdcphy_reset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <dev/mii/miidevs.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/errno.h>\n#include <sys/socket.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nvoid\tdcphy_reset;\n\nvoid\ndcphy_reset(mii)\n\tstruct mii_softc\t*mii;\n{\n\tstruct dc_softc\t\t*sc;\n\n\tsc = mii->mii_pdata->mii_ifp->if_softc;\n\n\tDC_CLRBIT(sc, DC_SIARESET, DC_SIA_RESET);\n\tDELAY(1000);\n\tDC_SETBIT(sc, DC_SIARESET, DC_SIA_RESET);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IFM_SUBTYPE",
          "args": [
            "ife->ifm_media"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "dc_sc",
            "DC_NETCFG"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFM_INST",
          "args": [
            "ife->ifm_media"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFM_INST",
          "args": [
            "ife->ifm_media"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <dev/mii/miidevs.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/errno.h>\n#include <sys/socket.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\n#define MIIF_AUTOTIMEOUT\t0x0004\n\nint\tdcphy_service;\nvoid\tdcphy_status;\nint\tdcphy_auto;\nvoid\tdcphy_reset;\n\nint\ndcphy_service(sc, mii, cmd)\n\tstruct mii_softc *sc;\n\tstruct mii_data *mii;\n\tint cmd;\n{\n\tstruct dc_softc *dc_sc;\n\tstruct ifmedia_entry *ife = mii->mii_media.ifm_cur;\n\tint reg;\n\tu_int32_t mode;\n\n\tdc_sc = mii->mii_ifp->if_softc;\n\n\tswitch (cmd) {\n\tcase MII_POLLSTAT:\n\t\t/*\n\t\t * If we're not polling our PHY instance, just return.\n\t\t */\n\t\tif (IFM_INST(ife->ifm_media) != sc->mii_inst) {\n\t\t\treturn (0);\n\t\t}\n\t\tbreak;\n\n\tcase MII_MEDIACHG:\n\t\t/*\n\t\t * If the media indicates a different PHY instance,\n\t\t * isolate ourselves.\n\t\t */\n\t\tif (IFM_INST(ife->ifm_media) != sc->mii_inst) {\n\t\t\treturn (0);\n\t\t}\n\n\t\t/*\n\t\t * If the interface is not up, don't do anything.\n\t\t */\n\t\tif ((mii->mii_ifp->if_flags & IFF_UP) == 0)\n\t\t\tbreak;\n\n\t\tsc->mii_flags = 0;\n\t\tmii->mii_media_active = IFM_NONE;\n\t\tmode = CSR_READ_4(dc_sc, DC_NETCFG);\n\t\tmode &= ~(DC_NETCFG_FULLDUPLEX|DC_NETCFG_PORTSEL|\n\t\t    DC_NETCFG_PCS|DC_NETCFG_SCRAMBLER|DC_NETCFG_SPEEDSEL);\n\n\t\tswitch (IFM_SUBTYPE(ife->ifm_media)) {\n\t\tcase IFM_AUTO:\n\t\t\t/*dcphy_reset(sc);*/\n\t\t\t(void) dcphy_auto(sc, 0);\n\t\t\tbreak;\n\t\tcase IFM_100_T4:\n\t\t\t/*\n\t\t\t * XXX Not supported as a manual setting right now.\n\t\t\t */\n\t\t\treturn (EINVAL);\n\t\tcase IFM_100_TX:\n\t\t\tdcphy_reset(sc);\n\t\t\tDC_CLRBIT(dc_sc, DC_10BTCTRL, DC_TCTL_AUTONEGENBL);\n\t\t\tmode |= DC_NETCFG_PORTSEL|DC_NETCFG_PCS|\n\t\t\t    DC_NETCFG_SCRAMBLER;\n\t\t\tif ((ife->ifm_media & IFM_GMASK) == IFM_FDX)\n\t\t\t\tmode |= DC_NETCFG_FULLDUPLEX;\n\t\t\telse\n\t\t\t\tmode &= ~DC_NETCFG_FULLDUPLEX;\n\t\t\tCSR_WRITE_4(dc_sc, DC_NETCFG, mode);\n\t\t\tbreak;\n\t\tcase IFM_10_T:\n\t\t\tDC_CLRBIT(dc_sc, DC_SIARESET, DC_SIA_RESET);\n\t\t\tDC_CLRBIT(dc_sc, DC_10BTCTRL, 0xFFFF);\n\t\t\tif ((ife->ifm_media & IFM_GMASK) == IFM_FDX)\n\t\t\t\tDC_SETBIT(dc_sc, DC_10BTCTRL, 0x7F3D);\n\t\t\telse\n\t\t\t\tDC_SETBIT(dc_sc, DC_10BTCTRL, 0x7F3F);\n\t\t\tDC_SETBIT(dc_sc, DC_SIARESET, DC_SIA_RESET);\n\t\t\tDC_CLRBIT(dc_sc, DC_10BTCTRL, DC_TCTL_AUTONEGENBL);\n\t\t\tmode &= ~DC_NETCFG_PORTSEL;\n\t\t\tmode |= DC_NETCFG_SPEEDSEL;\n\t\t\tif ((ife->ifm_media & IFM_GMASK) == IFM_FDX)\n\t\t\t\tmode |= DC_NETCFG_FULLDUPLEX;\n\t\t\telse\n\t\t\t\tmode &= ~DC_NETCFG_FULLDUPLEX;\n\t\t\tCSR_WRITE_4(dc_sc, DC_NETCFG, mode);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn(EINVAL);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase MII_TICK:\n\t\t/*\n\t\t * If we're not currently selected, just return.\n\t\t */\n\t\tif (IFM_INST(ife->ifm_media) != sc->mii_inst)\n\t\t\treturn (0);\n\n\t\t/*\n\t\t * Only used for autonegotiation.\n\t\t */\n\t\tif (IFM_SUBTYPE(ife->ifm_media) != IFM_AUTO)\n\t\t\treturn (0);\n\n\t\t/*\n\t\t * Is the interface even up?\n\t\t */\n\t\tif ((mii->mii_ifp->if_flags & IFF_UP) == 0)\n\t\t\treturn (0);\n\n\t\tif (sc->mii_flags & MIIF_DOINGAUTO) {\n\t\t\tif (++sc->mii_ticks != 5)\n\t\t\t\treturn(0);\n\t\t\telse {\n\t\t\t\tsc->mii_ticks = 0;\n\t\t\t\tsc->mii_flags &= ~MIIF_DOINGAUTO;\n\t\t\t\tsc->mii_flags |= MIIF_AUTOTIMEOUT;\n\t\t\t}\n\t\t}\n\n\t\tsc->mii_flags &= ~MIIF_DOINGAUTO;\n\n\t\t/*\n\t\t * Check to see if we have link.  If we do, we don't\n\t\t * need to restart the autonegotiation process.  Read\n\t\t * the BMSR twice in case it's latched.\n\t\t */\n\t\treg = CSR_READ_4(dc_sc, DC_10BTSTAT) &\n\t\t    (DC_TSTAT_LS10|DC_TSTAT_LS100);\n\n\t\tif (IFM_SUBTYPE(mii->mii_media_active) == IFM_100_TX &&\n\t\t    !(reg & DC_TSTAT_LS100)) {\n\t\t\tif (sc->mii_flags & MIIF_AUTOTIMEOUT) {\n\t\t\t\tsc->mii_flags &= ~MIIF_AUTOTIMEOUT;\n\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t\treturn(0);\n\t\t} else if (IFM_SUBTYPE(mii->mii_media_active) == IFM_10_T &&\n\t\t    !(reg & DC_TSTAT_LS10)) {\n\t\t\tif (sc->mii_flags & MIIF_AUTOTIMEOUT) {\n\t\t\t\tsc->mii_flags &= ~MIIF_AUTOTIMEOUT;\n\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t\treturn(0);\n\t\t} else if (IFM_SUBTYPE(mii->mii_media_active) == IFM_NONE &&\n\t\t    (!(reg & DC_TSTAT_LS10) || !(reg & DC_TSTAT_LS100))) {\n\t\t\tif (sc->mii_flags & MIIF_AUTOTIMEOUT) {\n\t\t\t\tsc->mii_flags &= ~MIIF_AUTOTIMEOUT;\n\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t\treturn(0);\n\t\t} else if (CSR_READ_4(dc_sc, DC_ISR) & DC_ISR_LINKGOOD) {\n\t\t\tif (sc->mii_flags & MIIF_AUTOTIMEOUT) {\n\t\t\t\tsc->mii_flags &= ~MIIF_AUTOTIMEOUT;\n\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t\treturn(0);\n\t\t}\n\n\t\tsc->mii_ticks = 0;\n\t\t/*dcphy_reset(sc);*/\n\t\tdcphy_auto(sc, 0);\n\n\t\tbreak;\n\t}\n\n\t/* Update the media status. */\n\tdcphy_status(sc);\n\n\t/* Callback if something changed. */\n\tif (sc->mii_active != mii->mii_media_active || cmd == MII_MEDIACHG) {\n\t\t(*mii->mii_statchg)(sc->mii_dev.dv_parent);\n\t\tsc->mii_active = mii->mii_media_active;\n\t}\n\treturn (0);\n}"
  },
  {
    "function_name": "dcphy_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/mii/dcphy.c",
    "lines": "123-170",
    "snippet": "void\ndcphy_attach(parent, self, aux)\n\tstruct device *parent;\n\tstruct device *self;\n\tvoid *aux;\n{\n\tstruct mii_softc *sc = (struct mii_softc *)self;\n\tstruct mii_attach_args *ma = aux;\n\tstruct mii_data *mii = ma->mii_data;\n\tstruct dc_softc *dc_sc;\n\n\tprintf(\": internal PHY\\n\");\n\tsc->mii_inst = mii->mii_instance;\n\tsc->mii_phy = ma->mii_phyno;\n\tsc->mii_service = dcphy_service;\n\tsc->mii_pdata = mii;\n\n\tsc->mii_flags |= MIIF_NOISOLATE;\n\tmii->mii_instance++;\n\n\tdc_sc = mii->mii_ifp->if_softc;\n\tCSR_WRITE_4(dc_sc, DC_10BTSTAT, 0);\n\tCSR_WRITE_4(dc_sc, DC_10BTCTRL, 0);\n\n#define\tADD(m, c)\tifmedia_add(&mii->mii_media, (m), (c), NULL)\n\n\tswitch(dc_sc->dc_csid) {\n\tcase COMPAQ_PRESARIO_ID:\n\t\t/* Example of how to only allow 10Mbps modes. */\n\t\tsc->mii_capabilities = BMSR_ANEG|BMSR_10TFDX|BMSR_10THDX;\n\t\tbreak;\n\tdefault:\n\t\tADD(IFM_MAKEWORD(IFM_ETHER, IFM_100_TX, IFM_LOOP,\n\t\t    sc->mii_inst), BMCR_LOOP|BMCR_S100);\n\n\t\tsc->mii_capabilities =\n\t\t    BMSR_ANEG|BMSR_100TXFDX|BMSR_100TXHDX|\n\t\t    BMSR_10TFDX|BMSR_10THDX;\n\t\tbreak;\n\t}\n\n\tsc->mii_capabilities &= ma->mii_capmask;\n\tif ((sc->mii_capabilities & BMSR_MEDIAMASK) == 0)\n\t\tprintf(\"no media present\");\n\telse\n\t\tmii_add_media(sc);\n#undef ADD\n}",
    "includes": [
      "#include <dev/ic/dcreg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <dev/mii/miidevs.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/socket.h>",
      "#include <sys/errno.h>",
      "#include <sys/socket.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/device.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define COMPAQ_PRESARIO_ID\t0xb0bb0e11"
    ],
    "globals_used": [
      "void\tdcphy_attach",
      "int\tdcphy_service"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mii_add_media",
          "args": [
            "sc"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "mii_add_media",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/mii/mii_physubr.c",
          "lines": "198-248",
          "snippet": "void\nmii_add_media(sc)\n\tstruct mii_softc *sc;\n{\n\tstruct mii_data *mii = sc->mii_pdata;\n\n#define\tADD(m, c)\tifmedia_add(&mii->mii_media, (m), (c), NULL)\n\n\tif ((sc->mii_flags & MIIF_NOISOLATE) == 0)\n\t\tADD(IFM_MAKEWORD(IFM_ETHER, IFM_NONE, 0, sc->mii_inst),\n\t\t    MII_MEDIA_NONE);\n\n\tif (sc->mii_capabilities & BMSR_10THDX) {\n\t\tADD(IFM_MAKEWORD(IFM_ETHER, IFM_10_T, 0, sc->mii_inst),\n\t\t    MII_MEDIA_10_T);\n#if 0\n\t\tif ((sc->mii_flags & MIIF_NOLOOP) == 0)\n\t\t\tADD(IFM_MAKEWORD(IFM_ETHER, IFM_10_T, IFM_LOOP,\n\t\t\t    sc->mii_inst), MII_MEDIA_10_T);\n#endif\n\t}\n\n\tif (sc->mii_capabilities & BMSR_10TFDX)\n\t\tADD(IFM_MAKEWORD(IFM_ETHER, IFM_10_T, IFM_FDX, sc->mii_inst),\n\t\t    MII_MEDIA_10_T_FDX);\n\tif (sc->mii_capabilities & BMSR_100TXHDX) {\n\t\tADD(IFM_MAKEWORD(IFM_ETHER, IFM_100_TX, 0, sc->mii_inst),\n\t\t    MII_MEDIA_100_TX);\n#if 0\n\t\tif ((sc->mii_flags & MIIF_NOLOOP) == 0)\n\t\t\tADD(IFM_MAKEWORD(IFM_ETHER, IFM_100_T4, IFM_LOOP,\n\t\t\t    sc->mii_inst), MII_MEDIA_100_T4);\n#endif\n\t}\n\tif (sc->mii_capabilities & BMSR_100TXFDX)\n\t\tADD(IFM_MAKEWORD(IFM_ETHER, IFM_100_TX, IFM_FDX, sc->mii_inst),\n\t\t    MII_MEDIA_100_TX_FDX);\n\tif (sc->mii_capabilities & BMSR_100T4) {\n\t\tADD(IFM_MAKEWORD(IFM_ETHER, IFM_100_T4, 0, sc->mii_inst),\n\t\t    MII_MEDIA_100_T4);\n#if 0\n\t\tif ((sc->mii_flags & MIIF_NOLOOP) == 0)\n\t\t\tADD(IFM_MAKEWORD(IFM_ETHER, IFM_100_T4, IFM_LOOP,\n\t\t\t    sc->mii_inst), MII_MEDIA_100_T4);\n#endif\n\t}\n\tif (sc->mii_capabilities & BMSR_ANEG)\n\t\tADD(IFM_MAKEWORD(IFM_ETHER, IFM_AUTO, 0, sc->mii_inst),\n\t\t    MII_NMEDIA);\t/* intentionally invalid index */\n#undef ADD\n}",
          "includes": [
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nvoid\nmii_add_media(sc)\n\tstruct mii_softc *sc;\n{\n\tstruct mii_data *mii = sc->mii_pdata;\n\n#define\tADD(m, c)\tifmedia_add(&mii->mii_media, (m), (c), NULL)\n\n\tif ((sc->mii_flags & MIIF_NOISOLATE) == 0)\n\t\tADD(IFM_MAKEWORD(IFM_ETHER, IFM_NONE, 0, sc->mii_inst),\n\t\t    MII_MEDIA_NONE);\n\n\tif (sc->mii_capabilities & BMSR_10THDX) {\n\t\tADD(IFM_MAKEWORD(IFM_ETHER, IFM_10_T, 0, sc->mii_inst),\n\t\t    MII_MEDIA_10_T);\n#if 0\n\t\tif ((sc->mii_flags & MIIF_NOLOOP) == 0)\n\t\t\tADD(IFM_MAKEWORD(IFM_ETHER, IFM_10_T, IFM_LOOP,\n\t\t\t    sc->mii_inst), MII_MEDIA_10_T);\n#endif\n\t}\n\n\tif (sc->mii_capabilities & BMSR_10TFDX)\n\t\tADD(IFM_MAKEWORD(IFM_ETHER, IFM_10_T, IFM_FDX, sc->mii_inst),\n\t\t    MII_MEDIA_10_T_FDX);\n\tif (sc->mii_capabilities & BMSR_100TXHDX) {\n\t\tADD(IFM_MAKEWORD(IFM_ETHER, IFM_100_TX, 0, sc->mii_inst),\n\t\t    MII_MEDIA_100_TX);\n#if 0\n\t\tif ((sc->mii_flags & MIIF_NOLOOP) == 0)\n\t\t\tADD(IFM_MAKEWORD(IFM_ETHER, IFM_100_T4, IFM_LOOP,\n\t\t\t    sc->mii_inst), MII_MEDIA_100_T4);\n#endif\n\t}\n\tif (sc->mii_capabilities & BMSR_100TXFDX)\n\t\tADD(IFM_MAKEWORD(IFM_ETHER, IFM_100_TX, IFM_FDX, sc->mii_inst),\n\t\t    MII_MEDIA_100_TX_FDX);\n\tif (sc->mii_capabilities & BMSR_100T4) {\n\t\tADD(IFM_MAKEWORD(IFM_ETHER, IFM_100_T4, 0, sc->mii_inst),\n\t\t    MII_MEDIA_100_T4);\n#if 0\n\t\tif ((sc->mii_flags & MIIF_NOLOOP) == 0)\n\t\t\tADD(IFM_MAKEWORD(IFM_ETHER, IFM_100_T4, IFM_LOOP,\n\t\t\t    sc->mii_inst), MII_MEDIA_100_T4);\n#endif\n\t}\n\tif (sc->mii_capabilities & BMSR_ANEG)\n\t\tADD(IFM_MAKEWORD(IFM_ETHER, IFM_AUTO, 0, sc->mii_inst),\n\t\t    MII_NMEDIA);\t/* intentionally invalid index */\n#undef ADD\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"no media present\""
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ADD",
          "args": [
            "IFM_MAKEWORD(IFM_ETHER, IFM_100_TX, IFM_LOOP,\n\t\t    sc->mii_inst)",
            "BMCR_LOOP|BMCR_S100"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFM_MAKEWORD",
          "args": [
            "IFM_ETHER",
            "IFM_100_TX",
            "IFM_LOOP",
            "sc->mii_inst"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "dc_sc",
            "DC_10BTCTRL",
            "0"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "dc_sc",
            "DC_10BTSTAT",
            "0"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <dev/mii/miidevs.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/errno.h>\n#include <sys/socket.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\n#define COMPAQ_PRESARIO_ID\t0xb0bb0e11\n\nvoid\tdcphy_attach;\nint\tdcphy_service;\n\nvoid\ndcphy_attach(parent, self, aux)\n\tstruct device *parent;\n\tstruct device *self;\n\tvoid *aux;\n{\n\tstruct mii_softc *sc = (struct mii_softc *)self;\n\tstruct mii_attach_args *ma = aux;\n\tstruct mii_data *mii = ma->mii_data;\n\tstruct dc_softc *dc_sc;\n\n\tprintf(\": internal PHY\\n\");\n\tsc->mii_inst = mii->mii_instance;\n\tsc->mii_phy = ma->mii_phyno;\n\tsc->mii_service = dcphy_service;\n\tsc->mii_pdata = mii;\n\n\tsc->mii_flags |= MIIF_NOISOLATE;\n\tmii->mii_instance++;\n\n\tdc_sc = mii->mii_ifp->if_softc;\n\tCSR_WRITE_4(dc_sc, DC_10BTSTAT, 0);\n\tCSR_WRITE_4(dc_sc, DC_10BTCTRL, 0);\n\n#define\tADD(m, c)\tifmedia_add(&mii->mii_media, (m), (c), NULL)\n\n\tswitch(dc_sc->dc_csid) {\n\tcase COMPAQ_PRESARIO_ID:\n\t\t/* Example of how to only allow 10Mbps modes. */\n\t\tsc->mii_capabilities = BMSR_ANEG|BMSR_10TFDX|BMSR_10THDX;\n\t\tbreak;\n\tdefault:\n\t\tADD(IFM_MAKEWORD(IFM_ETHER, IFM_100_TX, IFM_LOOP,\n\t\t    sc->mii_inst), BMCR_LOOP|BMCR_S100);\n\n\t\tsc->mii_capabilities =\n\t\t    BMSR_ANEG|BMSR_100TXFDX|BMSR_100TXHDX|\n\t\t    BMSR_10TFDX|BMSR_10THDX;\n\t\tbreak;\n\t}\n\n\tsc->mii_capabilities &= ma->mii_capmask;\n\tif ((sc->mii_capabilities & BMSR_MEDIAMASK) == 0)\n\t\tprintf(\"no media present\");\n\telse\n\t\tmii_add_media(sc);\n#undef ADD\n}"
  },
  {
    "function_name": "dcphy_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/mii/dcphy.c",
    "lines": "105-121",
    "snippet": "int\ndcphy_match(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct mii_attach_args *ma = aux;\n\n\t/*\n\t * The dc driver will report the 21143 vendor and device\n\t * ID to let us know that it wants us to attach.\n\t */\n\tif (MII_OUI(ma->mii_id1, ma->mii_id2) == MII_OUI_xxDEC &&\n\t    MII_MODEL(ma->mii_id2) == MII_MODEL_xxDEC_xxDC)\n\t\treturn (10);\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/ic/dcreg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <dev/mii/miidevs.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/socket.h>",
      "#include <sys/errno.h>",
      "#include <sys/socket.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/device.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tdcphy_match"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MII_MODEL",
          "args": [
            "ma->mii_id2"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MII_OUI",
          "args": [
            "ma->mii_id1",
            "ma->mii_id2"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <dev/mii/miidevs.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/errno.h>\n#include <sys/socket.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nint\tdcphy_match;\n\nint\ndcphy_match(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct mii_attach_args *ma = aux;\n\n\t/*\n\t * The dc driver will report the 21143 vendor and device\n\t * ID to let us know that it wants us to attach.\n\t */\n\tif (MII_OUI(ma->mii_id1, ma->mii_id2) == MII_OUI_xxDEC &&\n\t    MII_MODEL(ma->mii_id2) == MII_MODEL_xxDEC_xxDC)\n\t\treturn (10);\n\n\treturn (0);\n}"
  }
]