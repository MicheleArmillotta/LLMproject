[
  {
    "function_name": "u14_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/uha_isa.c",
    "lines": "357-372",
    "snippet": "void\nu14_init(sc)\n\tstruct uha_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\t/* make sure interrupts are enabled */\n#ifdef UHADEBUG\n\tprintf(\"u14_init: lmask=%02x, smask=%02x\\n\",\n\t    bus_space_read_1(iot, ioh, U14_LMASK),\n\t    bus_space_read_1(iot, ioh, U14_SMASK));\n#endif\n\tbus_space_write_1(iot, ioh, U14_LMASK, 0xd1);\t/* XXX */\n\tbus_space_write_1(iot, ioh, U14_SMASK, 0x91);\t/* XXX */\n}",
    "includes": [
      "#include <dev/ic/uhavar.h>",
      "#include <dev/ic/uhareg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void u14_init"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "U14_SMASK",
            "0x91"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "U14_LMASK",
            "0xd1"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"u14_init: lmask=%02x, smask=%02x\\n\"",
            "bus_space_read_1(iot, ioh, U14_LMASK)",
            "bus_space_read_1(iot, ioh, U14_SMASK)"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "U14_SMASK"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "U14_LMASK"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/uhavar.h>\n#include <dev/ic/uhareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid u14_init;\n\nvoid\nu14_init(sc)\n\tstruct uha_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\t/* make sure interrupts are enabled */\n#ifdef UHADEBUG\n\tprintf(\"u14_init: lmask=%02x, smask=%02x\\n\",\n\t    bus_space_read_1(iot, ioh, U14_LMASK),\n\t    bus_space_read_1(iot, ioh, U14_SMASK));\n#endif\n\tbus_space_write_1(iot, ioh, U14_LMASK, 0xd1);\t/* XXX */\n\tbus_space_write_1(iot, ioh, U14_SMASK, 0x91);\t/* XXX */\n}"
  },
  {
    "function_name": "u14_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/uha_isa.c",
    "lines": "307-355",
    "snippet": "int\nu14_intr(arg)\n\tvoid *arg;\n{\n\tstruct uha_softc *sc = arg;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct uha_mscp *mscp;\n\tu_char uhastat;\n\tu_long mboxval;\n\n#ifdef\tUHADEBUG\n\tprintf(\"%s: uhaintr \", sc->sc_dev.dv_xname);\n#endif /*UHADEBUG */\n\n\tif ((bus_space_read_1(iot, ioh, U14_SINT) & U14_SDIP) == 0)\n\t\treturn (0);\n\n\tfor (;;) {\n\t\t/*\n\t\t * First get all the information and then\n\t\t * acknowledge the interrupt\n\t\t */\n\t\tuhastat = bus_space_read_1(iot, ioh, U14_SINT);\n\t\tmboxval = bus_space_read_4(iot, ioh, U14_ICMPTR);\n\t\t/* XXX Send an ABORT_ACK instead? */\n\t\tbus_space_write_1(iot, ioh, U14_SINT, U14_ICM_ACK);\n\n#ifdef\tUHADEBUG\n\t\tprintf(\"status = 0x%x \", uhastat);\n#endif /*UHADEBUG*/\n\n\t\t/*\n\t\t * Process the completed operation\n\t\t */\n\t\tmscp = uha_mscp_phys_kv(sc, mboxval);\n\t\tif (!mscp) {\n\t\t\tprintf(\"%s: BAD MSCP RETURNED!\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tcontinue;\t/* whatever it was, it'll timeout */\n\t\t}\n\n\t\tuntimeout(uha_timeout, mscp);\n\t\tuha_done(sc, mscp);\n\n\t\tif ((bus_space_read_1(iot, ioh, U14_SINT) & U14_SDIP) == 0)\n\t\t\treturn (1);\n\t}\n}",
    "includes": [
      "#include <dev/ic/uhavar.h>",
      "#include <dev/ic/uhareg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int u14_intr"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "U14_SINT"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uha_done",
          "args": [
            "sc",
            "mscp"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "uha_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/uha.c",
          "lines": "291-342",
          "snippet": "void\nuha_done(sc, mscp)\n\tstruct uha_softc *sc;\n\tstruct uha_mscp *mscp;\n{\n\tstruct scsi_sense_data *s1, *s2;\n\tstruct scsi_xfer *xs = mscp->xs;\n\n\tSC_DEBUG(xs->sc_link, SDEV_DB2, (\"uha_done\\n\"));\n\t/*\n\t * Otherwise, put the results of the operation\n\t * into the xfer and call whoever started it\n\t */\n\tif ((mscp->flags & MSCP_ALLOC) == 0) {\n\t\tprintf(\"%s: exiting ccb not allocated!\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t\treturn;\n\t}\n\tif (xs->error == XS_NOERROR) {\n\t\tif (mscp->host_stat != UHA_NO_ERR) {\n\t\t\tswitch (mscp->host_stat) {\n\t\t\tcase UHA_SBUS_TIMEOUT:\t\t/* No response */\n\t\t\t\txs->error = XS_SELTIMEOUT;\n\t\t\t\tbreak;\n\t\t\tdefault:\t/* Other scsi protocol messes */\n\t\t\t\tprintf(\"%s: host_stat %x\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, mscp->host_stat);\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t}\n\t\t} else if (mscp->target_stat != SCSI_OK) {\n\t\t\tswitch (mscp->target_stat) {\n\t\t\tcase SCSI_CHECK:\n\t\t\t\ts1 = &mscp->mscp_sense;\n\t\t\t\ts2 = &xs->sense;\n\t\t\t\t*s2 = *s1;\n\t\t\t\txs->error = XS_SENSE;\n\t\t\t\tbreak;\n\t\t\tcase SCSI_BUSY:\n\t\t\t\txs->error = XS_BUSY;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"%s: target_stat %x\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, mscp->target_stat);\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t}\n\t\t} else\n\t\t\txs->resid = 0;\n\t}\n\tuha_free_mscp(sc, mscp);\n\txs->flags |= ITSDONE;\n\tscsi_done(xs);\n}",
          "includes": [
            "#include <dev/ic/uhavar.h>",
            "#include <dev/ic/uhareg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uha_reset_mscp __P((struct uha_softc *, struct uha_mscp *));",
            "void uha_free_mscp",
            "uha_init_mscp __P((struct uha_softc *, struct uha_mscp *));",
            "struct uha_mscp *\nuha_get_mscp(sc, flags)\n\tstruct uha_softc *sc;",
            "int flags;",
            "struct uha_mscp *\nuha_mscp_phys_kv(sc, mscp_phys)\n\tstruct uha_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/uhavar.h>\n#include <dev/ic/uhareg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nuha_reset_mscp __P((struct uha_softc *, struct uha_mscp *));\nvoid uha_free_mscp;\nuha_init_mscp __P((struct uha_softc *, struct uha_mscp *));\nstruct uha_mscp *\nuha_get_mscp(sc, flags)\n\tstruct uha_softc *sc;\nint flags;\nstruct uha_mscp *\nuha_mscp_phys_kv(sc, mscp_phys)\n\tstruct uha_softc *sc;\n\nvoid\nuha_done(sc, mscp)\n\tstruct uha_softc *sc;\n\tstruct uha_mscp *mscp;\n{\n\tstruct scsi_sense_data *s1, *s2;\n\tstruct scsi_xfer *xs = mscp->xs;\n\n\tSC_DEBUG(xs->sc_link, SDEV_DB2, (\"uha_done\\n\"));\n\t/*\n\t * Otherwise, put the results of the operation\n\t * into the xfer and call whoever started it\n\t */\n\tif ((mscp->flags & MSCP_ALLOC) == 0) {\n\t\tprintf(\"%s: exiting ccb not allocated!\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t\treturn;\n\t}\n\tif (xs->error == XS_NOERROR) {\n\t\tif (mscp->host_stat != UHA_NO_ERR) {\n\t\t\tswitch (mscp->host_stat) {\n\t\t\tcase UHA_SBUS_TIMEOUT:\t\t/* No response */\n\t\t\t\txs->error = XS_SELTIMEOUT;\n\t\t\t\tbreak;\n\t\t\tdefault:\t/* Other scsi protocol messes */\n\t\t\t\tprintf(\"%s: host_stat %x\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, mscp->host_stat);\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t}\n\t\t} else if (mscp->target_stat != SCSI_OK) {\n\t\t\tswitch (mscp->target_stat) {\n\t\t\tcase SCSI_CHECK:\n\t\t\t\ts1 = &mscp->mscp_sense;\n\t\t\t\ts2 = &xs->sense;\n\t\t\t\t*s2 = *s1;\n\t\t\t\txs->error = XS_SENSE;\n\t\t\t\tbreak;\n\t\t\tcase SCSI_BUSY:\n\t\t\t\txs->error = XS_BUSY;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"%s: target_stat %x\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, mscp->target_stat);\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t}\n\t\t} else\n\t\t\txs->resid = 0;\n\t}\n\tuha_free_mscp(sc, mscp);\n\txs->flags |= ITSDONE;\n\tscsi_done(xs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "untimeout",
          "args": [
            "uha_timeout",
            "mscp"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: BAD MSCP RETURNED!\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "uha_mscp_phys_kv",
          "args": [
            "sc",
            "mboxval"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "U14_SINT",
            "U14_ICM_ACK"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_4",
          "args": [
            "iot",
            "ioh",
            "U14_ICMPTR"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "U14_SINT"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "U14_SINT"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/uhavar.h>\n#include <dev/ic/uhareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint u14_intr;\n\nint\nu14_intr(arg)\n\tvoid *arg;\n{\n\tstruct uha_softc *sc = arg;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct uha_mscp *mscp;\n\tu_char uhastat;\n\tu_long mboxval;\n\n#ifdef\tUHADEBUG\n\tprintf(\"%s: uhaintr \", sc->sc_dev.dv_xname);\n#endif /*UHADEBUG */\n\n\tif ((bus_space_read_1(iot, ioh, U14_SINT) & U14_SDIP) == 0)\n\t\treturn (0);\n\n\tfor (;;) {\n\t\t/*\n\t\t * First get all the information and then\n\t\t * acknowledge the interrupt\n\t\t */\n\t\tuhastat = bus_space_read_1(iot, ioh, U14_SINT);\n\t\tmboxval = bus_space_read_4(iot, ioh, U14_ICMPTR);\n\t\t/* XXX Send an ABORT_ACK instead? */\n\t\tbus_space_write_1(iot, ioh, U14_SINT, U14_ICM_ACK);\n\n#ifdef\tUHADEBUG\n\t\tprintf(\"status = 0x%x \", uhastat);\n#endif /*UHADEBUG*/\n\n\t\t/*\n\t\t * Process the completed operation\n\t\t */\n\t\tmscp = uha_mscp_phys_kv(sc, mboxval);\n\t\tif (!mscp) {\n\t\t\tprintf(\"%s: BAD MSCP RETURNED!\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tcontinue;\t/* whatever it was, it'll timeout */\n\t\t}\n\n\t\tuntimeout(uha_timeout, mscp);\n\t\tuha_done(sc, mscp);\n\n\t\tif ((bus_space_read_1(iot, ioh, U14_SINT) & U14_SDIP) == 0)\n\t\t\treturn (1);\n\t}\n}"
  },
  {
    "function_name": "u14_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/uha_isa.c",
    "lines": "280-302",
    "snippet": "int\nu14_poll(sc, xs, count)\n\tstruct uha_softc *sc;\n\tstruct scsi_xfer *xs;\n\tint count;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\twhile (count) {\n\t\t/*\n\t\t * If we had interrupts enabled, would we\n\t\t * have got an interrupt?\n\t\t */\n\t\tif (bus_space_read_1(iot, ioh, U14_SINT) & U14_SDIP)\n\t\t\tu14_intr(sc);\n\t\tif (xs->flags & ITSDONE)\n\t\t\treturn (0);\n\t\tdelay(1000);\n\t\tcount--;\n\t}\n\treturn (1);\n}",
    "includes": [
      "#include <dev/ic/uhavar.h>",
      "#include <dev/ic/uhareg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int u14_poll",
      "int u14_intr"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "1000"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "u14_intr",
          "args": [
            "sc"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "u14_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/uha_isa.c",
          "lines": "307-355",
          "snippet": "int\nu14_intr(arg)\n\tvoid *arg;\n{\n\tstruct uha_softc *sc = arg;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct uha_mscp *mscp;\n\tu_char uhastat;\n\tu_long mboxval;\n\n#ifdef\tUHADEBUG\n\tprintf(\"%s: uhaintr \", sc->sc_dev.dv_xname);\n#endif /*UHADEBUG */\n\n\tif ((bus_space_read_1(iot, ioh, U14_SINT) & U14_SDIP) == 0)\n\t\treturn (0);\n\n\tfor (;;) {\n\t\t/*\n\t\t * First get all the information and then\n\t\t * acknowledge the interrupt\n\t\t */\n\t\tuhastat = bus_space_read_1(iot, ioh, U14_SINT);\n\t\tmboxval = bus_space_read_4(iot, ioh, U14_ICMPTR);\n\t\t/* XXX Send an ABORT_ACK instead? */\n\t\tbus_space_write_1(iot, ioh, U14_SINT, U14_ICM_ACK);\n\n#ifdef\tUHADEBUG\n\t\tprintf(\"status = 0x%x \", uhastat);\n#endif /*UHADEBUG*/\n\n\t\t/*\n\t\t * Process the completed operation\n\t\t */\n\t\tmscp = uha_mscp_phys_kv(sc, mboxval);\n\t\tif (!mscp) {\n\t\t\tprintf(\"%s: BAD MSCP RETURNED!\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tcontinue;\t/* whatever it was, it'll timeout */\n\t\t}\n\n\t\tuntimeout(uha_timeout, mscp);\n\t\tuha_done(sc, mscp);\n\n\t\tif ((bus_space_read_1(iot, ioh, U14_SINT) & U14_SDIP) == 0)\n\t\t\treturn (1);\n\t}\n}",
          "includes": [
            "#include <dev/ic/uhavar.h>",
            "#include <dev/ic/uhareg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int u14_intr"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/uhavar.h>\n#include <dev/ic/uhareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint u14_intr;\n\nint\nu14_intr(arg)\n\tvoid *arg;\n{\n\tstruct uha_softc *sc = arg;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct uha_mscp *mscp;\n\tu_char uhastat;\n\tu_long mboxval;\n\n#ifdef\tUHADEBUG\n\tprintf(\"%s: uhaintr \", sc->sc_dev.dv_xname);\n#endif /*UHADEBUG */\n\n\tif ((bus_space_read_1(iot, ioh, U14_SINT) & U14_SDIP) == 0)\n\t\treturn (0);\n\n\tfor (;;) {\n\t\t/*\n\t\t * First get all the information and then\n\t\t * acknowledge the interrupt\n\t\t */\n\t\tuhastat = bus_space_read_1(iot, ioh, U14_SINT);\n\t\tmboxval = bus_space_read_4(iot, ioh, U14_ICMPTR);\n\t\t/* XXX Send an ABORT_ACK instead? */\n\t\tbus_space_write_1(iot, ioh, U14_SINT, U14_ICM_ACK);\n\n#ifdef\tUHADEBUG\n\t\tprintf(\"status = 0x%x \", uhastat);\n#endif /*UHADEBUG*/\n\n\t\t/*\n\t\t * Process the completed operation\n\t\t */\n\t\tmscp = uha_mscp_phys_kv(sc, mboxval);\n\t\tif (!mscp) {\n\t\t\tprintf(\"%s: BAD MSCP RETURNED!\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tcontinue;\t/* whatever it was, it'll timeout */\n\t\t}\n\n\t\tuntimeout(uha_timeout, mscp);\n\t\tuha_done(sc, mscp);\n\n\t\tif ((bus_space_read_1(iot, ioh, U14_SINT) & U14_SDIP) == 0)\n\t\t\treturn (1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "U14_SINT"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/uhavar.h>\n#include <dev/ic/uhareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint u14_poll;\nint u14_intr;\n\nint\nu14_poll(sc, xs, count)\n\tstruct uha_softc *sc;\n\tstruct scsi_xfer *xs;\n\tint count;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\twhile (count) {\n\t\t/*\n\t\t * If we had interrupts enabled, would we\n\t\t * have got an interrupt?\n\t\t */\n\t\tif (bus_space_read_1(iot, ioh, U14_SINT) & U14_SDIP)\n\t\t\tu14_intr(sc);\n\t\tif (xs->flags & ITSDONE)\n\t\t\treturn (0);\n\t\tdelay(1000);\n\t\tcount--;\n\t}\n\treturn (1);\n}"
  },
  {
    "function_name": "u14_start_mbox",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/uha_isa.c",
    "lines": "245-273",
    "snippet": "void\nu14_start_mbox(sc, mscp)\n\tstruct uha_softc *sc;\n\tstruct uha_mscp *mscp;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint spincount = 100000;\t/* 1s should be enough */\n\n\twhile (--spincount) {\n\t\tif ((bus_space_read_1(iot, ioh, U14_LINT) & U14_LDIP) == 0)\n\t\t\tbreak;\n\t\tdelay(100);\n\t}\n\tif (!spincount) {\n\t\tprintf(\"%s: uha_start_mbox, board not responding\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t}\n\n\tbus_space_write_4(iot, ioh, U14_OGMPTR, KVTOPHYS(mscp));\n\tif (mscp->flags & MSCP_ABORT)\n\t\tbus_space_write_1(iot, ioh, U14_LINT, U14_ABORT);\n\telse\n\t\tbus_space_write_1(iot, ioh, U14_LINT, U14_OGMFULL);\n\n\tif ((mscp->xs->flags & SCSI_POLL) == 0)\n\t\ttimeout(uha_timeout, mscp, (mscp->timeout * hz) / 1000);\n}",
    "includes": [
      "#include <dev/ic/uhavar.h>",
      "#include <dev/ic/uhareg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void u14_start_mbox"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "uha_timeout",
            "mscp",
            "(mscp->timeout * hz) / 1000"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "bt_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/bt.c",
          "lines": "1300-1345",
          "snippet": "void\nbt_timeout(arg)\n\tvoid *arg;\n{\n\tstruct bt_ccb *ccb = arg;\n\tstruct scsi_xfer *xs = ccb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct bt_softc *sc = sc_link->adapter_softc;\n\tint s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n\ts = splbio();\n\n#ifdef BTDIAG\n\t/*\n\t * If the ccb's mbx is not free, then the board has gone Far East?\n\t */\n\tbt_collect_mbo(sc);\n\tif (ccb->flags & CCB_SENDING) {\n\t\tprintf(\"%s: not taking commands!\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t}\n#endif\n\n\t/*\n\t * If it has been through before, then\n\t * a previous abort has failed, don't\n\t * try abort again\n\t */\n\tif (ccb->flags & CCB_ABORT) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\t\t/* XXX Must reset! */\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tccb->xs->error = XS_TIMEOUT;\n\t\tccb->timeout = BT_ABORT_TIMEOUT;\n\t\tccb->flags |= CCB_ABORT;\n\t\tbt_queue_ccb(sc, ccb);\n\t}\n\n\tsplx(s);\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include \"aha.h\"",
            "#include <dev/isa/btreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\tBT_ABORT_TIMEOUT\t2000\t/* time to wait for abort (mSec) */"
          ],
          "globals_used": [
            "bt_finish_ccbs __P((struct bt_softc *));",
            "bt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));",
            "bt_init_ccb __P((struct bt_softc *, struct bt_ccb *));",
            "void bt_queue_ccb",
            "void bt_collect_mbo",
            "void bt_timeout",
            "struct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;",
            "int flags;",
            "struct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include \"aha.h\"\n#include <dev/isa/btreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tBT_ABORT_TIMEOUT\t2000\t/* time to wait for abort (mSec) */\n\nbt_finish_ccbs __P((struct bt_softc *));\nbt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));\nbt_init_ccb __P((struct bt_softc *, struct bt_ccb *));\nvoid bt_queue_ccb;\nvoid bt_collect_mbo;\nvoid bt_timeout;\nstruct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;\nint flags;\nstruct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;\n\nvoid\nbt_timeout(arg)\n\tvoid *arg;\n{\n\tstruct bt_ccb *ccb = arg;\n\tstruct scsi_xfer *xs = ccb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct bt_softc *sc = sc_link->adapter_softc;\n\tint s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n\ts = splbio();\n\n#ifdef BTDIAG\n\t/*\n\t * If the ccb's mbx is not free, then the board has gone Far East?\n\t */\n\tbt_collect_mbo(sc);\n\tif (ccb->flags & CCB_SENDING) {\n\t\tprintf(\"%s: not taking commands!\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t}\n#endif\n\n\t/*\n\t * If it has been through before, then\n\t * a previous abort has failed, don't\n\t * try abort again\n\t */\n\tif (ccb->flags & CCB_ABORT) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\t\t/* XXX Must reset! */\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tccb->xs->error = XS_TIMEOUT;\n\t\tccb->timeout = BT_ABORT_TIMEOUT;\n\t\tccb->flags |= CCB_ABORT;\n\t\tbt_queue_ccb(sc, ccb);\n\t}\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "U14_LINT",
            "U14_OGMFULL"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "U14_LINT",
            "U14_ABORT"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_4",
          "args": [
            "iot",
            "ioh",
            "U14_OGMPTR",
            "KVTOPHYS(mscp)"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVTOPHYS",
          "args": [
            "mscp"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Debugger",
          "args": [],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: uha_start_mbox, board not responding\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "100"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "U14_LINT"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/uhavar.h>\n#include <dev/ic/uhareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid u14_start_mbox;\n\nvoid\nu14_start_mbox(sc, mscp)\n\tstruct uha_softc *sc;\n\tstruct uha_mscp *mscp;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint spincount = 100000;\t/* 1s should be enough */\n\n\twhile (--spincount) {\n\t\tif ((bus_space_read_1(iot, ioh, U14_LINT) & U14_LDIP) == 0)\n\t\t\tbreak;\n\t\tdelay(100);\n\t}\n\tif (!spincount) {\n\t\tprintf(\"%s: uha_start_mbox, board not responding\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t}\n\n\tbus_space_write_4(iot, ioh, U14_OGMPTR, KVTOPHYS(mscp));\n\tif (mscp->flags & MSCP_ABORT)\n\t\tbus_space_write_1(iot, ioh, U14_LINT, U14_ABORT);\n\telse\n\t\tbus_space_write_1(iot, ioh, U14_LINT, U14_OGMFULL);\n\n\tif ((mscp->xs->flags & SCSI_POLL) == 0)\n\t\ttimeout(uha_timeout, mscp, (mscp->timeout * hz) / 1000);\n}"
  },
  {
    "function_name": "u14_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/uha_isa.c",
    "lines": "156-240",
    "snippet": "int\nu14_find(iot, ioh, sc)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tstruct uha_softc *sc;\n{\n\tu_int16_t model, config;\n\tint irq, drq;\n\tint resetcount = 4000;\t/* 4 secs? */\n\n\tmodel = (bus_space_read_1(iot, ioh, U14_ID + 0) << 8) |\n\t\t(bus_space_read_1(iot, ioh, U14_ID + 1) << 0);\n\tif ((model & 0xfff0) != 0x5640)\n\t\treturn (0);\n\n\tconfig = (bus_space_read_1(iot, ioh, U14_CONFIG + 0) << 8) |\n\t\t (bus_space_read_1(iot, ioh, U14_CONFIG + 1) << 0);\n\n\tswitch (model & 0x000f) {\n\tcase 0x0000:\n\t\tswitch (config & U14_DMA_MASK) {\n\t\tcase U14_DMA_CH5:\n\t\t\tdrq = 5;\n\t\t\tbreak;\n\t\tcase U14_DMA_CH6:\n\t\t\tdrq = 6;\n\t\t\tbreak;\n\t\tcase U14_DMA_CH7:\n\t\t\tdrq = 7;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"u14_find: illegal drq setting %x\\n\",\n\t\t\t    config & U14_DMA_MASK);\n\t\t\treturn (0);\n\t\t}\n\t\tbreak;\n\tcase 0x0001:\n\t\t/* This is a 34f, and doesn't need an ISA DMA channel. */\n\t\tdrq = -1;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"u14_find: unknown model %x\\n\", model);\n\t\treturn (0);\n\t}\n\n\tswitch (config & U14_IRQ_MASK) {\n\tcase U14_IRQ10:\n\t\tirq = 10;\n\t\tbreak;\n\tcase U14_IRQ11:\n\t\tirq = 11;\n\t\tbreak;\n\tcase U14_IRQ14:\n\t\tirq = 14;\n\t\tbreak;\n\tcase U14_IRQ15:\n\t\tirq = 15;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"u14_find: illegal irq setting %x\\n\",\n\t\t    config & U14_IRQ_MASK);\n\t\treturn (0);\n\t}\n\n\tbus_space_write_1(iot, ioh, U14_LINT, UHA_ASRST);\n\n\twhile (--resetcount) {\n\t\tif (bus_space_read_1(iot, ioh, U14_LINT))\n\t\t\tbreak;\n\t\tdelay(1000);\t/* 1 mSec per loop */\n\t}\n\tif (!resetcount) {\n\t\tprintf(\"u14_find: board timed out during reset\\n\");\n\t\treturn (0);\n\t}\n\n\t/* if we want to fill in softc, do so now */\n\tif (sc != NULL) {\n\t\tsc->sc_irq = irq;\n\t\tsc->sc_drq = drq;\n\t\tsc->sc_scsi_dev = config & U14_HOSTID_MASK;\n\t}\n\n\treturn (1);\n}",
    "includes": [
      "#include <dev/ic/uhavar.h>",
      "#include <dev/ic/uhareg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int u14_find"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"u14_find: board timed out during reset\\n\""
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "1000"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "U14_LINT"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "U14_LINT",
            "UHA_ASRST"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "U14_CONFIG + 1"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "U14_CONFIG + 0"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "U14_ID + 1"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "U14_ID + 0"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/uhavar.h>\n#include <dev/ic/uhareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint u14_find;\n\nint\nu14_find(iot, ioh, sc)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tstruct uha_softc *sc;\n{\n\tu_int16_t model, config;\n\tint irq, drq;\n\tint resetcount = 4000;\t/* 4 secs? */\n\n\tmodel = (bus_space_read_1(iot, ioh, U14_ID + 0) << 8) |\n\t\t(bus_space_read_1(iot, ioh, U14_ID + 1) << 0);\n\tif ((model & 0xfff0) != 0x5640)\n\t\treturn (0);\n\n\tconfig = (bus_space_read_1(iot, ioh, U14_CONFIG + 0) << 8) |\n\t\t (bus_space_read_1(iot, ioh, U14_CONFIG + 1) << 0);\n\n\tswitch (model & 0x000f) {\n\tcase 0x0000:\n\t\tswitch (config & U14_DMA_MASK) {\n\t\tcase U14_DMA_CH5:\n\t\t\tdrq = 5;\n\t\t\tbreak;\n\t\tcase U14_DMA_CH6:\n\t\t\tdrq = 6;\n\t\t\tbreak;\n\t\tcase U14_DMA_CH7:\n\t\t\tdrq = 7;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"u14_find: illegal drq setting %x\\n\",\n\t\t\t    config & U14_DMA_MASK);\n\t\t\treturn (0);\n\t\t}\n\t\tbreak;\n\tcase 0x0001:\n\t\t/* This is a 34f, and doesn't need an ISA DMA channel. */\n\t\tdrq = -1;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"u14_find: unknown model %x\\n\", model);\n\t\treturn (0);\n\t}\n\n\tswitch (config & U14_IRQ_MASK) {\n\tcase U14_IRQ10:\n\t\tirq = 10;\n\t\tbreak;\n\tcase U14_IRQ11:\n\t\tirq = 11;\n\t\tbreak;\n\tcase U14_IRQ14:\n\t\tirq = 14;\n\t\tbreak;\n\tcase U14_IRQ15:\n\t\tirq = 15;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"u14_find: illegal irq setting %x\\n\",\n\t\t    config & U14_IRQ_MASK);\n\t\treturn (0);\n\t}\n\n\tbus_space_write_1(iot, ioh, U14_LINT, UHA_ASRST);\n\n\twhile (--resetcount) {\n\t\tif (bus_space_read_1(iot, ioh, U14_LINT))\n\t\t\tbreak;\n\t\tdelay(1000);\t/* 1 mSec per loop */\n\t}\n\tif (!resetcount) {\n\t\tprintf(\"u14_find: board timed out during reset\\n\");\n\t\treturn (0);\n\t}\n\n\t/* if we want to fill in softc, do so now */\n\tif (sc != NULL) {\n\t\tsc->sc_irq = irq;\n\t\tsc->sc_drq = drq;\n\t\tsc->sc_scsi_dev = config & U14_HOSTID_MASK;\n\t}\n\n\treturn (1);\n}"
  },
  {
    "function_name": "uha_isa_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/uha_isa.c",
    "lines": "113-151",
    "snippet": "void\nuha_isa_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct isa_attach_args *ia = aux;\n\tstruct uha_softc *sc = (void *)self;\n\tbus_space_tag_t iot = ia->ia_iot;\n\tbus_space_handle_t ioh;\n\tisa_chipset_tag_t ic = ia->ia_ic;\n\n\tprintf(\"\\n\");\n\n\tif (bus_space_map(iot, ia->ia_iobase, UHA_ISA_IOSIZE, 0, &ioh))\n\t\tpanic(\"uha_attach: bus_space_map failed!\");\n\n\tsc->sc_iot = iot;\n\tsc->sc_ioh = ioh;\n\tif (!u14_find(iot, ioh, sc))\n\t\tpanic(\"uha_attach: u14_find failed!\");\n\n\tif (sc->sc_drq != -1)\n\t\tisadma_cascade(sc->sc_drq);\n\n\tsc->sc_ih = isa_intr_establish(ic, sc->sc_irq, IST_EDGE, IPL_BIO,\n\t    u14_intr, sc, sc->sc_dev.dv_xname);\n\tif (sc->sc_ih == NULL) {\n\t\tprintf(\"%s: couldn't establish interrupt\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\n\t/* Save function pointers for later use. */\n\tsc->start_mbox = u14_start_mbox;\n\tsc->poll = u14_poll;\n\tsc->init = u14_init;\n\n\tuha_attach(sc);\n}",
    "includes": [
      "#include <dev/ic/uhavar.h>",
      "#include <dev/ic/uhareg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define\tUHA_ISA_IOSIZE\t16"
    ],
    "globals_used": [
      "void\tuha_isa_attach",
      "int u14_find",
      "void u14_start_mbox",
      "int u14_poll",
      "int u14_intr",
      "void u14_init"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uha_attach",
          "args": [
            "sc"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "uha_attach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/uha.c",
          "lines": "135-163",
          "snippet": "void\nuha_attach(sc)\n\tstruct uha_softc *sc;\n{\n\n\t(sc->init)(sc);\n\tTAILQ_INIT(&sc->sc_free_mscp);\n\n\t/*\n\t * fill in the prototype scsi_link.\n\t */\n#ifndef __OpenBSD__\n\tsc->sc_link.channel = SCSI_CHANNEL_ONLY_ONE;\n#endif\n\tsc->sc_link.adapter_softc = sc;\n\tsc->sc_link.adapter_target = sc->sc_scsi_dev;\n\tsc->sc_link.adapter = &uha_switch;\n\tsc->sc_link.device = &uha_dev;\n\tsc->sc_link.openings = 2;\n\n\t/*\n\t * ask the adapter what subunits are present\n\t */\n#ifdef __OpenBSD__\n\tconfig_found(&sc->sc_dev, &sc->sc_link, uhaprint);\n#else\n\tconfig_found(&sc->sc_dev, &sc->sc_link, scsiprint);\n#endif\n}",
          "includes": [
            "#include <dev/ic/uhavar.h>",
            "#include <dev/ic/uhareg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct scsi_adapter uha_switch = {\n\tuha_scsi_cmd,\n\tuhaminphys,\n\t0,\n\t0,\n};",
            "struct scsi_device uha_dev = {\n\tNULL,\t\t\t/* Use default error handler */\n\tNULL,\t\t\t/* have a queue, served by this */\n\tNULL,\t\t\t/* have no async handler */\n\tNULL,\t\t\t/* Use default 'done' routine */\n};",
            "struct uha_mscp *\nuha_get_mscp(sc, flags)\n\tstruct uha_softc *sc;",
            "struct uha_mscp *\nuha_mscp_phys_kv(sc, mscp_phys)\n\tstruct uha_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/uhavar.h>\n#include <dev/ic/uhareg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstruct scsi_adapter uha_switch = {\n\tuha_scsi_cmd,\n\tuhaminphys,\n\t0,\n\t0,\n};\nstruct scsi_device uha_dev = {\n\tNULL,\t\t\t/* Use default error handler */\n\tNULL,\t\t\t/* have a queue, served by this */\n\tNULL,\t\t\t/* have no async handler */\n\tNULL,\t\t\t/* Use default 'done' routine */\n};\nstruct uha_mscp *\nuha_get_mscp(sc, flags)\n\tstruct uha_softc *sc;\nstruct uha_mscp *\nuha_mscp_phys_kv(sc, mscp_phys)\n\tstruct uha_softc *sc;\n\nvoid\nuha_attach(sc)\n\tstruct uha_softc *sc;\n{\n\n\t(sc->init)(sc);\n\tTAILQ_INIT(&sc->sc_free_mscp);\n\n\t/*\n\t * fill in the prototype scsi_link.\n\t */\n#ifndef __OpenBSD__\n\tsc->sc_link.channel = SCSI_CHANNEL_ONLY_ONE;\n#endif\n\tsc->sc_link.adapter_softc = sc;\n\tsc->sc_link.adapter_target = sc->sc_scsi_dev;\n\tsc->sc_link.adapter = &uha_switch;\n\tsc->sc_link.device = &uha_dev;\n\tsc->sc_link.openings = 2;\n\n\t/*\n\t * ask the adapter what subunits are present\n\t */\n#ifdef __OpenBSD__\n\tconfig_found(&sc->sc_dev, &sc->sc_link, uhaprint);\n#else\n\tconfig_found(&sc->sc_dev, &sc->sc_link, scsiprint);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: couldn't establish interrupt\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "isa_intr_establish",
          "args": [
            "ic",
            "sc->sc_irq",
            "IST_EDGE",
            "IPL_BIO",
            "u14_intr",
            "sc",
            "sc->sc_dev.dv_xname"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isadma_cascade",
          "args": [
            "sc->sc_drq"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"uha_attach: u14_find failed!\""
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u14_find",
          "args": [
            "iot",
            "ioh",
            "sc"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "u14_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/uha_isa.c",
          "lines": "156-240",
          "snippet": "int\nu14_find(iot, ioh, sc)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tstruct uha_softc *sc;\n{\n\tu_int16_t model, config;\n\tint irq, drq;\n\tint resetcount = 4000;\t/* 4 secs? */\n\n\tmodel = (bus_space_read_1(iot, ioh, U14_ID + 0) << 8) |\n\t\t(bus_space_read_1(iot, ioh, U14_ID + 1) << 0);\n\tif ((model & 0xfff0) != 0x5640)\n\t\treturn (0);\n\n\tconfig = (bus_space_read_1(iot, ioh, U14_CONFIG + 0) << 8) |\n\t\t (bus_space_read_1(iot, ioh, U14_CONFIG + 1) << 0);\n\n\tswitch (model & 0x000f) {\n\tcase 0x0000:\n\t\tswitch (config & U14_DMA_MASK) {\n\t\tcase U14_DMA_CH5:\n\t\t\tdrq = 5;\n\t\t\tbreak;\n\t\tcase U14_DMA_CH6:\n\t\t\tdrq = 6;\n\t\t\tbreak;\n\t\tcase U14_DMA_CH7:\n\t\t\tdrq = 7;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"u14_find: illegal drq setting %x\\n\",\n\t\t\t    config & U14_DMA_MASK);\n\t\t\treturn (0);\n\t\t}\n\t\tbreak;\n\tcase 0x0001:\n\t\t/* This is a 34f, and doesn't need an ISA DMA channel. */\n\t\tdrq = -1;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"u14_find: unknown model %x\\n\", model);\n\t\treturn (0);\n\t}\n\n\tswitch (config & U14_IRQ_MASK) {\n\tcase U14_IRQ10:\n\t\tirq = 10;\n\t\tbreak;\n\tcase U14_IRQ11:\n\t\tirq = 11;\n\t\tbreak;\n\tcase U14_IRQ14:\n\t\tirq = 14;\n\t\tbreak;\n\tcase U14_IRQ15:\n\t\tirq = 15;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"u14_find: illegal irq setting %x\\n\",\n\t\t    config & U14_IRQ_MASK);\n\t\treturn (0);\n\t}\n\n\tbus_space_write_1(iot, ioh, U14_LINT, UHA_ASRST);\n\n\twhile (--resetcount) {\n\t\tif (bus_space_read_1(iot, ioh, U14_LINT))\n\t\t\tbreak;\n\t\tdelay(1000);\t/* 1 mSec per loop */\n\t}\n\tif (!resetcount) {\n\t\tprintf(\"u14_find: board timed out during reset\\n\");\n\t\treturn (0);\n\t}\n\n\t/* if we want to fill in softc, do so now */\n\tif (sc != NULL) {\n\t\tsc->sc_irq = irq;\n\t\tsc->sc_drq = drq;\n\t\tsc->sc_scsi_dev = config & U14_HOSTID_MASK;\n\t}\n\n\treturn (1);\n}",
          "includes": [
            "#include <dev/ic/uhavar.h>",
            "#include <dev/ic/uhareg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int u14_find"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/uhavar.h>\n#include <dev/ic/uhareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint u14_find;\n\nint\nu14_find(iot, ioh, sc)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tstruct uha_softc *sc;\n{\n\tu_int16_t model, config;\n\tint irq, drq;\n\tint resetcount = 4000;\t/* 4 secs? */\n\n\tmodel = (bus_space_read_1(iot, ioh, U14_ID + 0) << 8) |\n\t\t(bus_space_read_1(iot, ioh, U14_ID + 1) << 0);\n\tif ((model & 0xfff0) != 0x5640)\n\t\treturn (0);\n\n\tconfig = (bus_space_read_1(iot, ioh, U14_CONFIG + 0) << 8) |\n\t\t (bus_space_read_1(iot, ioh, U14_CONFIG + 1) << 0);\n\n\tswitch (model & 0x000f) {\n\tcase 0x0000:\n\t\tswitch (config & U14_DMA_MASK) {\n\t\tcase U14_DMA_CH5:\n\t\t\tdrq = 5;\n\t\t\tbreak;\n\t\tcase U14_DMA_CH6:\n\t\t\tdrq = 6;\n\t\t\tbreak;\n\t\tcase U14_DMA_CH7:\n\t\t\tdrq = 7;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"u14_find: illegal drq setting %x\\n\",\n\t\t\t    config & U14_DMA_MASK);\n\t\t\treturn (0);\n\t\t}\n\t\tbreak;\n\tcase 0x0001:\n\t\t/* This is a 34f, and doesn't need an ISA DMA channel. */\n\t\tdrq = -1;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"u14_find: unknown model %x\\n\", model);\n\t\treturn (0);\n\t}\n\n\tswitch (config & U14_IRQ_MASK) {\n\tcase U14_IRQ10:\n\t\tirq = 10;\n\t\tbreak;\n\tcase U14_IRQ11:\n\t\tirq = 11;\n\t\tbreak;\n\tcase U14_IRQ14:\n\t\tirq = 14;\n\t\tbreak;\n\tcase U14_IRQ15:\n\t\tirq = 15;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"u14_find: illegal irq setting %x\\n\",\n\t\t    config & U14_IRQ_MASK);\n\t\treturn (0);\n\t}\n\n\tbus_space_write_1(iot, ioh, U14_LINT, UHA_ASRST);\n\n\twhile (--resetcount) {\n\t\tif (bus_space_read_1(iot, ioh, U14_LINT))\n\t\t\tbreak;\n\t\tdelay(1000);\t/* 1 mSec per loop */\n\t}\n\tif (!resetcount) {\n\t\tprintf(\"u14_find: board timed out during reset\\n\");\n\t\treturn (0);\n\t}\n\n\t/* if we want to fill in softc, do so now */\n\tif (sc != NULL) {\n\t\tsc->sc_irq = irq;\n\t\tsc->sc_drq = drq;\n\t\tsc->sc_scsi_dev = config & U14_HOSTID_MASK;\n\t}\n\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"uha_attach: bus_space_map failed!\""
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "iot",
            "ia->ia_iobase",
            "UHA_ISA_IOSIZE",
            "0",
            "&ioh"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/uhavar.h>\n#include <dev/ic/uhareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tUHA_ISA_IOSIZE\t16\n\nvoid\tuha_isa_attach;\nint u14_find;\nvoid u14_start_mbox;\nint u14_poll;\nint u14_intr;\nvoid u14_init;\n\nvoid\nuha_isa_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct isa_attach_args *ia = aux;\n\tstruct uha_softc *sc = (void *)self;\n\tbus_space_tag_t iot = ia->ia_iot;\n\tbus_space_handle_t ioh;\n\tisa_chipset_tag_t ic = ia->ia_ic;\n\n\tprintf(\"\\n\");\n\n\tif (bus_space_map(iot, ia->ia_iobase, UHA_ISA_IOSIZE, 0, &ioh))\n\t\tpanic(\"uha_attach: bus_space_map failed!\");\n\n\tsc->sc_iot = iot;\n\tsc->sc_ioh = ioh;\n\tif (!u14_find(iot, ioh, sc))\n\t\tpanic(\"uha_attach: u14_find failed!\");\n\n\tif (sc->sc_drq != -1)\n\t\tisadma_cascade(sc->sc_drq);\n\n\tsc->sc_ih = isa_intr_establish(ic, sc->sc_irq, IST_EDGE, IPL_BIO,\n\t    u14_intr, sc, sc->sc_dev.dv_xname);\n\tif (sc->sc_ih == NULL) {\n\t\tprintf(\"%s: couldn't establish interrupt\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\n\t/* Save function pointers for later use. */\n\tsc->start_mbox = u14_start_mbox;\n\tsc->poll = u14_poll;\n\tsc->init = u14_init;\n\n\tuha_attach(sc);\n}"
  },
  {
    "function_name": "uha_isa_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/uha_isa.c",
    "lines": "79-108",
    "snippet": "int\nuha_isa_probe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct isa_attach_args *ia = aux;\n\tstruct uha_softc sc;\n\tbus_space_tag_t iot = ia->ia_iot;\n\tbus_space_handle_t ioh;\n\tint rv;\n\n\tif (bus_space_map(iot, ia->ia_iobase, UHA_ISA_IOSIZE, 0, &ioh))\n\t\treturn (0);\n\n\trv = u14_find(iot, ioh, &sc);\n\n\tbus_space_unmap(iot, ioh, UHA_ISA_IOSIZE);\n\n\tif (rv) {\n\t\tif (ia->ia_irq != -1 && ia->ia_irq != sc.sc_irq)\n\t\t\treturn (0);\n\t\tif (ia->ia_drq != -1 && ia->ia_drq != sc.sc_drq)\n\t\t\treturn (0);\n\t\tia->ia_irq = sc.sc_irq;\n\t\tia->ia_drq = sc.sc_drq;\n\t\tia->ia_msize = 0;\n\t\tia->ia_iosize = UHA_ISA_IOSIZE;\n\t}\n\treturn (rv);\n}",
    "includes": [
      "#include <dev/ic/uhavar.h>",
      "#include <dev/ic/uhareg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define\tUHA_ISA_IOSIZE\t16"
    ],
    "globals_used": [
      "int\tuha_isa_probe",
      "int u14_find"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_unmap",
          "args": [
            "iot",
            "ioh",
            "UHA_ISA_IOSIZE"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u14_find",
          "args": [
            "iot",
            "ioh",
            "&sc"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "u14_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/uha_isa.c",
          "lines": "156-240",
          "snippet": "int\nu14_find(iot, ioh, sc)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tstruct uha_softc *sc;\n{\n\tu_int16_t model, config;\n\tint irq, drq;\n\tint resetcount = 4000;\t/* 4 secs? */\n\n\tmodel = (bus_space_read_1(iot, ioh, U14_ID + 0) << 8) |\n\t\t(bus_space_read_1(iot, ioh, U14_ID + 1) << 0);\n\tif ((model & 0xfff0) != 0x5640)\n\t\treturn (0);\n\n\tconfig = (bus_space_read_1(iot, ioh, U14_CONFIG + 0) << 8) |\n\t\t (bus_space_read_1(iot, ioh, U14_CONFIG + 1) << 0);\n\n\tswitch (model & 0x000f) {\n\tcase 0x0000:\n\t\tswitch (config & U14_DMA_MASK) {\n\t\tcase U14_DMA_CH5:\n\t\t\tdrq = 5;\n\t\t\tbreak;\n\t\tcase U14_DMA_CH6:\n\t\t\tdrq = 6;\n\t\t\tbreak;\n\t\tcase U14_DMA_CH7:\n\t\t\tdrq = 7;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"u14_find: illegal drq setting %x\\n\",\n\t\t\t    config & U14_DMA_MASK);\n\t\t\treturn (0);\n\t\t}\n\t\tbreak;\n\tcase 0x0001:\n\t\t/* This is a 34f, and doesn't need an ISA DMA channel. */\n\t\tdrq = -1;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"u14_find: unknown model %x\\n\", model);\n\t\treturn (0);\n\t}\n\n\tswitch (config & U14_IRQ_MASK) {\n\tcase U14_IRQ10:\n\t\tirq = 10;\n\t\tbreak;\n\tcase U14_IRQ11:\n\t\tirq = 11;\n\t\tbreak;\n\tcase U14_IRQ14:\n\t\tirq = 14;\n\t\tbreak;\n\tcase U14_IRQ15:\n\t\tirq = 15;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"u14_find: illegal irq setting %x\\n\",\n\t\t    config & U14_IRQ_MASK);\n\t\treturn (0);\n\t}\n\n\tbus_space_write_1(iot, ioh, U14_LINT, UHA_ASRST);\n\n\twhile (--resetcount) {\n\t\tif (bus_space_read_1(iot, ioh, U14_LINT))\n\t\t\tbreak;\n\t\tdelay(1000);\t/* 1 mSec per loop */\n\t}\n\tif (!resetcount) {\n\t\tprintf(\"u14_find: board timed out during reset\\n\");\n\t\treturn (0);\n\t}\n\n\t/* if we want to fill in softc, do so now */\n\tif (sc != NULL) {\n\t\tsc->sc_irq = irq;\n\t\tsc->sc_drq = drq;\n\t\tsc->sc_scsi_dev = config & U14_HOSTID_MASK;\n\t}\n\n\treturn (1);\n}",
          "includes": [
            "#include <dev/ic/uhavar.h>",
            "#include <dev/ic/uhareg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int u14_find"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/uhavar.h>\n#include <dev/ic/uhareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint u14_find;\n\nint\nu14_find(iot, ioh, sc)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tstruct uha_softc *sc;\n{\n\tu_int16_t model, config;\n\tint irq, drq;\n\tint resetcount = 4000;\t/* 4 secs? */\n\n\tmodel = (bus_space_read_1(iot, ioh, U14_ID + 0) << 8) |\n\t\t(bus_space_read_1(iot, ioh, U14_ID + 1) << 0);\n\tif ((model & 0xfff0) != 0x5640)\n\t\treturn (0);\n\n\tconfig = (bus_space_read_1(iot, ioh, U14_CONFIG + 0) << 8) |\n\t\t (bus_space_read_1(iot, ioh, U14_CONFIG + 1) << 0);\n\n\tswitch (model & 0x000f) {\n\tcase 0x0000:\n\t\tswitch (config & U14_DMA_MASK) {\n\t\tcase U14_DMA_CH5:\n\t\t\tdrq = 5;\n\t\t\tbreak;\n\t\tcase U14_DMA_CH6:\n\t\t\tdrq = 6;\n\t\t\tbreak;\n\t\tcase U14_DMA_CH7:\n\t\t\tdrq = 7;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"u14_find: illegal drq setting %x\\n\",\n\t\t\t    config & U14_DMA_MASK);\n\t\t\treturn (0);\n\t\t}\n\t\tbreak;\n\tcase 0x0001:\n\t\t/* This is a 34f, and doesn't need an ISA DMA channel. */\n\t\tdrq = -1;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"u14_find: unknown model %x\\n\", model);\n\t\treturn (0);\n\t}\n\n\tswitch (config & U14_IRQ_MASK) {\n\tcase U14_IRQ10:\n\t\tirq = 10;\n\t\tbreak;\n\tcase U14_IRQ11:\n\t\tirq = 11;\n\t\tbreak;\n\tcase U14_IRQ14:\n\t\tirq = 14;\n\t\tbreak;\n\tcase U14_IRQ15:\n\t\tirq = 15;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"u14_find: illegal irq setting %x\\n\",\n\t\t    config & U14_IRQ_MASK);\n\t\treturn (0);\n\t}\n\n\tbus_space_write_1(iot, ioh, U14_LINT, UHA_ASRST);\n\n\twhile (--resetcount) {\n\t\tif (bus_space_read_1(iot, ioh, U14_LINT))\n\t\t\tbreak;\n\t\tdelay(1000);\t/* 1 mSec per loop */\n\t}\n\tif (!resetcount) {\n\t\tprintf(\"u14_find: board timed out during reset\\n\");\n\t\treturn (0);\n\t}\n\n\t/* if we want to fill in softc, do so now */\n\tif (sc != NULL) {\n\t\tsc->sc_irq = irq;\n\t\tsc->sc_drq = drq;\n\t\tsc->sc_scsi_dev = config & U14_HOSTID_MASK;\n\t}\n\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "iot",
            "ia->ia_iobase",
            "UHA_ISA_IOSIZE",
            "0",
            "&ioh"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/uhavar.h>\n#include <dev/ic/uhareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tUHA_ISA_IOSIZE\t16\n\nint\tuha_isa_probe;\nint u14_find;\n\nint\nuha_isa_probe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct isa_attach_args *ia = aux;\n\tstruct uha_softc sc;\n\tbus_space_tag_t iot = ia->ia_iot;\n\tbus_space_handle_t ioh;\n\tint rv;\n\n\tif (bus_space_map(iot, ia->ia_iobase, UHA_ISA_IOSIZE, 0, &ioh))\n\t\treturn (0);\n\n\trv = u14_find(iot, ioh, &sc);\n\n\tbus_space_unmap(iot, ioh, UHA_ISA_IOSIZE);\n\n\tif (rv) {\n\t\tif (ia->ia_irq != -1 && ia->ia_irq != sc.sc_irq)\n\t\t\treturn (0);\n\t\tif (ia->ia_drq != -1 && ia->ia_drq != sc.sc_drq)\n\t\t\treturn (0);\n\t\tia->ia_irq = sc.sc_irq;\n\t\tia->ia_drq = sc.sc_drq;\n\t\tia->ia_msize = 0;\n\t\tia->ia_iosize = UHA_ISA_IOSIZE;\n\t}\n\treturn (rv);\n}"
  }
]