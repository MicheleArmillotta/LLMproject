[
  {
    "function_name": "ahc_eisa_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/eisa/ahc_eisa.c",
    "lines": "150-325",
    "snippet": "void\nahc_eisa_attach(parent, self, aux)\nstruct device *parent, *self;\nvoid *aux;\n{\n\tahc_chip chip;\n\tu_char channel = 'A'; /* Only one channel */\n\tstruct ahc_softc *ahc = (void *)self;\n\tstruct eisa_attach_args *ea = aux;\n\tbus_space_tag_t iot = ea->ea_iot;\n\tbus_space_handle_t ioh;\n\tint irq;\n\teisa_chipset_tag_t ec = ea->ea_ec;\n\teisa_intr_handle_t ih;\n\tconst char *model, *intrstr;\n\tu_int biosctrl;\n\tu_int scsiconf;\n\tu_int scsiconf1;\n\t\n\tahc->sc_dmat = ea->ea_dmat;\n\tif (bus_space_map(iot, EISA_SLOT_ADDR(ea->ea_slot) +\n\t\t\t  AHC_EISA_SLOT_OFFSET, AHC_EISA_IOSIZE, 0, &ioh))\n\t\tpanic(\"ahc_eisa_attach: could not map I/O addresses\");\n\tif ((irq = ahc_eisa_irq(iot, ioh)) < 0)\n\t\tpanic(\"ahc_eisa_attach: ahc_eisa_irq failed!\");\n\n\tif (strcmp(ea->ea_idstring, \"ADP7770\") == 0) {\n\t\tmodel = EISA_PRODUCT_ADP7770;\n\t\tchip = AHC_AIC7770|AHC_EISA;\n\t} else if (strcmp(ea->ea_idstring, \"ADP7771\") == 0) {\n\t\tmodel = EISA_PRODUCT_ADP7771;\n\t\tchip = AHC_AIC7770|AHC_EISA;\n\t} else {\n\t\tpanic(\"ahc_eisa_attach: Unknown device type %s\",\n\t\t\t\tea->ea_idstring);\n\t}\n\tprintf(\": %s\\n\", model);\n\n\tahc_construct(ahc, iot, ioh, chip, AHC_FNONE, AHC_AIC7770_FE, channel);\n\t\n\tahc->channel = 'A';\n\tahc->channel_b = 'B';\n\tif (ahc_reset(ahc) != 0)\n\t\treturn;\n\t\n\tif (eisa_intr_map(ec, irq, &ih)) {\n\t\tprintf(\"%s: couldn't map interrupt (%d)\\n\",\n\t\t       ahc->sc_dev.dv_xname, irq);\n\t\treturn;\n\t}\n\n\t/*\n\t * Tell the user what type of interrupts we're using.\n\t * usefull for debugging irq problems\n\t */\n\tif (bootverbose) {\n\t\tprintf(\"%s: Using %s Interrupts\\n\",\n\t\t       ahc_name(ahc),\n\t\t       ahc->pause & IRQMS ?\n\t\t       \"Level Sensitive\" : \"Edge Triggered\");\n\t}\n\n\t/*\n\t * Now that we know we own the resources we need, do the \n\t * card initialization.\n\t *\n\t * First, the aic7770 card specific setup.\n\t */\n\tbiosctrl = ahc_inb(ahc, HA_274_BIOSCTRL);\n\tscsiconf = ahc_inb(ahc, SCSICONF);\n\tscsiconf1 = ahc_inb(ahc, SCSICONF + 1);\n\t\n\t/* Get the primary channel information */\n\tif ((biosctrl & CHANNEL_B_PRIMARY) != 0)\n\t\tahc->flags |= AHC_CHANNEL_B_PRIMARY;\n\n\tif ((biosctrl & BIOSMODE) == BIOSDISABLED) {\n\t\tahc->flags |= AHC_USEDEFAULTS;\n\t} else if ((ahc->features & AHC_WIDE) != 0) {\n\t\tahc->our_id = scsiconf1 & HWSCSIID;\n\t\tif (scsiconf & TERM_ENB)\n\t\t\tahc->flags |= AHC_TERM_ENB_A;\n\t} else {\n\t\tahc->our_id = scsiconf & HSCSIID;\n\t\tahc->our_id_b = scsiconf1 & HSCSIID;\n\t\tif (scsiconf & TERM_ENB)\n\t\t\tahc->flags |= AHC_TERM_ENB_A;\n\t\tif (scsiconf1 & TERM_ENB)\n\t\t\tahc->flags |= AHC_TERM_ENB_B;\n\t}\n\t/*\n\t * We have no way to tell, so assume extended\n\t * translation is enabled.\n\t */\n\t\n\tahc->flags |= AHC_EXTENDED_TRANS_A|AHC_EXTENDED_TRANS_B;\n\t\n\t/*      \n\t * See if we have a Rev E or higher aic7770. Anything below a\n\t * Rev E will have a R/O autoflush disable configuration bit.\n\t * It's still not clear exactly what is differenent about the Rev E.\n\t * We think it allows 8 bit entries in the QOUTFIFO to support\n\t * \"paging\" SCBs so you can have more than 4 commands active at\n\t * once.\n\t */\n\t{\n\t\tchar *id_string;\n\t\tu_char sblkctl;\n\t\tu_char sblkctl_orig;\n\n\t\tsblkctl_orig = AHC_INB(ahc, SBLKCTL);\n\t\tsblkctl = sblkctl_orig ^ AUTOFLUSHDIS;\n\t\tAHC_OUTB(ahc, SBLKCTL, sblkctl);\n\t\tsblkctl = AHC_INB(ahc, SBLKCTL);\n\t\tif (sblkctl != sblkctl_orig) {\n\t\t\tid_string = \"aic7770 >= Rev E, \";\n\t\t\t/*\n\t\t\t * Ensure autoflush is enabled\n\t\t\t */\n\t\t\tsblkctl &= ~AUTOFLUSHDIS;\n\t\t\tAHC_OUTB(ahc, SBLKCTL, sblkctl);\n\n\t\t\t/* Allow paging on this adapter */\n\t\t\tahc->flags |= AHC_PAGESCBS;\n\t\t} else\n\t\t\tid_string = \"aic7770 <= Rev C, \";\n\n\t\tprintf(\"%s: %s\", ahc_name(ahc), id_string);\n\t}\n\n\t/* Setup the FIFO threshold and the bus off time */\n\t{\n\t\tu_char hostconf = AHC_INB(ahc, HOSTCONF);\n\t\tAHC_OUTB(ahc, BUSSPD, hostconf & DFTHRSH);\n\t\tAHC_OUTB(ahc, BUSTIME, (hostconf << 2) & BOFF);\n\t}\n\n\t/*\n\t * Generic aic7xxx initialization.\n\t */\n\tif (ahc_init(ahc)) {\n\t\tahc_free(ahc);\n\t\treturn;\n\t}\n \n\t/*\n\t * Enable the board's BUS drivers\n\t */\n\tAHC_OUTB(ahc, BCTL, ENABLE);\n\n\tintrstr = eisa_intr_string(ec, ih);\n\t/*\n\t * The IRQMS bit enables level sensitive interrupts only allow\n\t * IRQ sharing if its set.\n\t */\n\tahc->sc_ih = eisa_intr_establish(ec, ih, ahc->pause & IRQMS\n\t\t\t\t\t ? IST_LEVEL : IST_EDGE,\n\t\t\t\t\t IPL_BIO, ahc_intr, ahc,\n\t\t\t\t\t ahc->sc_dev.dv_xname);\n\tif (ahc->sc_ih == NULL) {\n\t\tprintf(\"%s: couldn't establish interrupt\",\n\t\t       ahc->sc_dev.dv_xname);\n\t\tif (intrstr != NULL)\n\t\t\tprintf(\" at %s\", intrstr);\n\t\tprintf(\"\\n\");\n\t\tahc_free(ahc);\n\t\treturn;\n\t}\n\tif (intrstr != NULL)\n\t\tprintf(\"%s: interrupting at %s\\n\", ahc->sc_dev.dv_xname,\n\t\t       intrstr);\n\n\t/* Attach sub-devices - always succeeds */\n\tahc_attach(ahc);\n\n}",
    "includes": [
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <dev/eisa/eisadevs.h>",
      "#include <dev/eisa/eisavar.h>",
      "#include <dev/eisa/eisareg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"eisa.h\""
    ],
    "macros_used": [
      "#define bootverbose\t1",
      "#define bootverbose\t1",
      "#define AHC_EISA_IOSIZE\t\t0x100",
      "#define AHC_EISA_SLOT_OFFSET\t0xc00"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ahc_attach",
          "args": [
            "ahc"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_attach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "1481-1536",
          "snippet": "int\nahc_attach(ahc)\n\tstruct ahc_softc *ahc;\n{\n\t/*\n\t * Initialize the software queue.\n\t */\n\tLIST_INIT(&ahc->sc_xxxq);\n\n#ifdef AHC_BROKEN_CACHE\n\tif (cpu_class == CPUCLASS_386)\t/* doesn't have \"wbinvd\" instruction */\n\t\tahc_broken_cache = 0;\n#endif\n\t/*\n\t * fill in the prototype scsi_links.\n\t */\n\tahc->sc_link.adapter_target = ahc->our_id;\n\tif (ahc->features & AHC_WIDE)\n\t\tahc->sc_link.adapter_buswidth = 16;\n\tahc->sc_link.adapter_softc = ahc;\n\tahc->sc_link.adapter = &ahc_switch;\n\tahc->sc_link.openings = 2;\n\tahc->sc_link.device = &ahc_dev;\n\tahc->sc_link.flags = SCSIDEBUG_LEVEL;\n\t\n\tif (ahc->features & AHC_TWIN) {\n\t\t/* Configure the second scsi bus */\n\t\tahc->sc_link_b = ahc->sc_link;\n\t\tahc->sc_link_b.adapter_target = ahc->our_id_b;\n\t\tif (ahc->features & AHC_WIDE)\n\t\t\tahc->sc_link.adapter_buswidth = 16;\n\t}\n\n\t/*\n\t * ask the adapter what subunits are present\n\t */\n\tif ((ahc->flags & AHC_CHANNEL_B_PRIMARY) == 0) {\n\t\t/* make IS_SCSIBUS_B() == false, while probing channel A */\n\t\tahc->sc_link_b.scsibus = 0xff;\n\n\t\tconfig_found((void *)ahc, &ahc->sc_link, scsiprint);\n\t\tif (ahc->features & AHC_TWIN)\n\t\t\tconfig_found((void *)ahc, &ahc->sc_link_b, scsiprint);\n\t} else {\n\t\t/*\n\t\t * if implementation of IS_SCSIBUS_B() is changed to use\n\t\t * ahc->sc_link.scsibus, then \"ahc->sc_link.scsibus = 0xff;\"\n\t\t * is needed, here.\n\t\t */\n\n\t\t/* assert(ahc->features & AHC_TWIN); */\n\t\tconfig_found((void *)ahc, &ahc->sc_link_b, scsiprint);\n\t\tconfig_found((void *)ahc, &ahc->sc_link, scsiprint);\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "ahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "ahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "static struct scsi_adapter ahc_switch =\n{\n\tahc_scsi_cmd,\n\tahcminphys,\n\t0,\n\t0,\n};",
            "static struct scsi_device ahc_dev =\n{\n\tNULL, /* Use default error handler */\n\tNULL, /* have a queue, served by this */\n\tNULL, /* have no async handler */\n\tNULL, /* Use default 'done' routine */\n};",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "u_int our_id;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC struct;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));\nahc_loadseq __P((struct ahc_softc *ahc));\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nahc_clear_intstat __P((struct ahc_softc *ahc));\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nrestart_sequencer __P((struct ahc_softc *ahc));\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic struct scsi_adapter ahc_switch =\n{\n\tahc_scsi_cmd,\n\tahcminphys,\n\t0,\n\t0,\n};\nstatic struct scsi_device ahc_dev =\n{\n\tNULL, /* Use default error handler */\n\tNULL, /* have a queue, served by this */\n\tNULL, /* have no async handler */\n\tNULL, /* Use default 'done' routine */\n};\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nu_int our_id;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nint\nahc_attach(ahc)\n\tstruct ahc_softc *ahc;\n{\n\t/*\n\t * Initialize the software queue.\n\t */\n\tLIST_INIT(&ahc->sc_xxxq);\n\n#ifdef AHC_BROKEN_CACHE\n\tif (cpu_class == CPUCLASS_386)\t/* doesn't have \"wbinvd\" instruction */\n\t\tahc_broken_cache = 0;\n#endif\n\t/*\n\t * fill in the prototype scsi_links.\n\t */\n\tahc->sc_link.adapter_target = ahc->our_id;\n\tif (ahc->features & AHC_WIDE)\n\t\tahc->sc_link.adapter_buswidth = 16;\n\tahc->sc_link.adapter_softc = ahc;\n\tahc->sc_link.adapter = &ahc_switch;\n\tahc->sc_link.openings = 2;\n\tahc->sc_link.device = &ahc_dev;\n\tahc->sc_link.flags = SCSIDEBUG_LEVEL;\n\t\n\tif (ahc->features & AHC_TWIN) {\n\t\t/* Configure the second scsi bus */\n\t\tahc->sc_link_b = ahc->sc_link;\n\t\tahc->sc_link_b.adapter_target = ahc->our_id_b;\n\t\tif (ahc->features & AHC_WIDE)\n\t\t\tahc->sc_link.adapter_buswidth = 16;\n\t}\n\n\t/*\n\t * ask the adapter what subunits are present\n\t */\n\tif ((ahc->flags & AHC_CHANNEL_B_PRIMARY) == 0) {\n\t\t/* make IS_SCSIBUS_B() == false, while probing channel A */\n\t\tahc->sc_link_b.scsibus = 0xff;\n\n\t\tconfig_found((void *)ahc, &ahc->sc_link, scsiprint);\n\t\tif (ahc->features & AHC_TWIN)\n\t\t\tconfig_found((void *)ahc, &ahc->sc_link_b, scsiprint);\n\t} else {\n\t\t/*\n\t\t * if implementation of IS_SCSIBUS_B() is changed to use\n\t\t * ahc->sc_link.scsibus, then \"ahc->sc_link.scsibus = 0xff;\"\n\t\t * is needed, here.\n\t\t */\n\n\t\t/* assert(ahc->features & AHC_TWIN); */\n\t\tconfig_found((void *)ahc, &ahc->sc_link_b, scsiprint);\n\t\tconfig_found((void *)ahc, &ahc->sc_link, scsiprint);\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: interrupting at %s\\n\"",
            "ahc->sc_dev.dv_xname",
            "intrstr"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_free",
          "args": [
            "ahc"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_freeze_devq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "4434-4450",
          "snippet": "STATIC void\nahc_freeze_devq(ahc, sc_link)\n\tstruct ahc_softc *ahc;\n\tstruct scsi_link *sc_link;\n{\n\tint\ttarget;\n\tchar\tchannel;\n\tint\tlun;\n\n\ttarget = sc_link->target;\n\tlun = sc_link->lun;\n\tchannel = SIM_CHANNEL(ahc, sc_link);\n\t\n\tahc_search_qinfifo(ahc, target, channel, lun,\n\t\t\t   /*tag*/SCB_LIST_NULL, ROLE_UNKNOWN,\n\t\t\t   SCB_REQUEUE, SEARCH_COMPLETE);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "ahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_freeze_devq __P((struct ahc_softc *ahc,\n\t\t\t\t     struct scsi_link *sc_link));\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_handle_message_phase __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct scsi_link *sc_link));\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_freeze_devq(ahc, sc_link)\n\tstruct ahc_softc *ahc;\n\tstruct scsi_link *sc_link;\n{\n\tint\ttarget;\n\tchar\tchannel;\n\tint\tlun;\n\n\ttarget = sc_link->target;\n\tlun = sc_link->lun;\n\tchannel = SIM_CHANNEL(ahc, sc_link);\n\t\n\tahc_search_qinfifo(ahc, target, channel, lun,\n\t\t\t   /*tag*/SCB_LIST_NULL, ROLE_UNKNOWN,\n\t\t\t   SCB_REQUEUE, SEARCH_COMPLETE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eisa_intr_establish",
          "args": [
            "ec",
            "ih",
            "ahc->pause & IRQMS\n\t\t\t\t\t ? IST_LEVEL : IST_EDGE",
            "IPL_BIO",
            "ahc_intr",
            "ahc",
            "ahc->sc_dev.dv_xname"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eisa_intr_string",
          "args": [
            "ec",
            "ih"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AHC_OUTB",
          "args": [
            "ahc",
            "BCTL",
            "ENABLE"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_init",
          "args": [
            "ahc"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "3564-3953",
          "snippet": "int\nahc_init(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tint\t  max_targ = 15;\n\tint\t  i;\n\tint\t  term;\n\tu_int\t  scsi_conf;\n\tu_int\t  scsiseq_template;\n\tu_int\t  ultraenb;\n\tu_int\t  discenable;\n\tu_int\t  tagenable;\n\tsize_t\t  driver_data_size;\n\tu_int32_t physaddr;\n\tstruct scb_data *scb_data = NULL;\n\n#ifdef AHC_PRINT_SRAM\n\tprintf(\"Scratch Ram:\");\n\tfor (i = 0x20; i < 0x5f; i++) {\n\t\tif (((i % 8) == 0) && (i != 0)) {\n\t\t\tprintf (\"\\n              \");\n\t\t}\n\t\tprintf (\" 0x%x\", ahc_inb(ahc, i));\n\t}\n\tif ((ahc->features & AHC_MORE_SRAM) != 0) {\n\t\tfor (i = 0x70; i < 0x7f; i++) {\n\t\t\tif (((i % 8) == 0) && (i != 0)) {\n\t\t\t\tprintf (\"\\n              \");\n\t\t\t}\n\t\t\tprintf (\" 0x%x\", ahc_inb(ahc, i));\n\t\t}\n\t}\n\tprintf (\"\\n\");\n#endif\n\n\tif (ahc->scb_data == NULL) {\n\t\tscb_data = malloc(sizeof (struct scb_data), M_DEVBUF, M_NOWAIT);\n\t\tif (scb_data == NULL) {\n\t\t\tprintf(\"%s: cannot malloc scb_data!\\n\", ahc_name(ahc));\n\t\t\treturn (ENOMEM);\n\t\t}\n\t\tbzero(scb_data, sizeof(struct scb_data));\n\t\tahc->scb_data = scb_data;\n\t}\n\t/*\n\t * Assume we have a board at this stage and it has been reset.\n\t */\n\tif ((ahc->flags & AHC_USEDEFAULTS) != 0)\n\t\tahc->our_id = ahc->our_id_b = 7;\n\t\n\t/*\n\t * Default to allowing initiator operations.\n\t */\n\tahc->flags |= AHC_INITIATORMODE;\n\t\n\t/*\n\t * DMA tag for our command fifos and other data in system memory\n\t * the card's sequencer must be able to access.  For initiator\n\t * roles, we need to allocate space for the qinfifo, qoutfifo,\n\t * and untagged_scb arrays each of which are composed of 256\n\t * 1 byte elements.  When providing for the target mode role,\n\t * we additionally must provide space for the incoming target\n\t * command fifo.\n\t */\n\tdriver_data_size = 3 * 256 * sizeof(u_int8_t);\n\n\tif (ahc_createdmamem(ahc, driver_data_size, \n\t    &ahc->shared_data_dmamap, (caddr_t *)&ahc->qoutfifo,\n\t    &ahc->shared_data_busaddr, &ahc->shared_data_seg,\n\t    &ahc->shared_data_nseg, \"shared data\") < 0)\n\t\treturn (ENOMEM);\n\n\tahc->init_level++;\n\n\t/* Allocate SCB data now that sc_dmat is initialized */\n\tif (ahc->scb_data->maxhscbs == 0)\n\t\tif (ahcinitscbdata(ahc) != 0)\n\t\t\treturn (ENOMEM);\n\n\tahc->qinfifo = &ahc->qoutfifo[256];\n\tahc->untagged_scbs = &ahc->qinfifo[256];\n\t/* There are no untagged SCBs active yet. */\n\tfor (i = 0; i < 256; i++)\n\t\tahc->untagged_scbs[i] = SCB_LIST_NULL;\n\n\t/* All of our queues are empty */\n\tfor (i = 0; i < 256; i++)\n\t\tahc->qoutfifo[i] = SCB_LIST_NULL;\n\n\tbus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap,\n\t\t\tBUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);\n\t\n\t/*\n\t * Allocate a tstate to house information for our\n\t * initiator presence on the bus as well as the user\n\t * data for any target mode initiator.\n\t */\n\tif (ahc_alloc_tstate(ahc, ahc->our_id, 'A') == NULL) {\n\t\tprintf(\"%s: unable to allocate tmode_tstate.  \"\n\t\t       \"Failing attach\\n\", ahc_name(ahc));\n\t\treturn (-1);\n\t}\n\n\tif ((ahc->features & AHC_TWIN) != 0) {\n\t\tif (ahc_alloc_tstate(ahc, ahc->our_id_b, 'B') == NULL) {\n\t\t\tprintf(\"%s: unable to allocate tmode_tstate.  \"\n\t\t\t       \"Failing attach\\n\", ahc_name(ahc));\n\t\t\treturn (-1);\n\t\t}\n \t\tprintf(\"Twin Channel, A SCSI Id=%d, B SCSI Id=%d, primary %c, \",\n\t\t       ahc->our_id, ahc->our_id_b,\n\t\t       ahc->flags & AHC_CHANNEL_B_PRIMARY? 'B': 'A');\n\t} else {\n\t\tif ((ahc->features & AHC_WIDE) != 0) {\n\t\t\tprintf(\"Wide \");\n\t\t} else {\n\t\t\tprintf(\"Single \");\n\t\t}\n\t\tprintf(\"Channel %c, SCSI Id=%d, \", ahc->channel, ahc->our_id);\n\t}\n\n\tahc_outb(ahc, SEQ_FLAGS, 0);\n\n\tif (ahc->scb_data->maxhscbs < AHC_SCB_MAX) {\n\t\tahc->flags |= AHC_PAGESCBS;\n\t\tprintf(\"%d/%d SCBs\\n\", ahc->scb_data->maxhscbs, AHC_SCB_MAX);\n\t} else {\n\t\tahc->flags &= ~AHC_PAGESCBS;\n\t\tprintf(\"%d SCBs\\n\", ahc->scb_data->maxhscbs);\n\t}\n\n#ifdef AHC_DEBUG\n\tif (ahc_debug & AHC_SHOWMISC) {\n\t\tprintf(\"%s: hardware scb %d bytes; kernel scb %d bytes; \"\n\t\t       \"ahc_dma %d bytes\\n\",\n\t\t\tahc_name(ahc),\n\t\t        sizeof(struct hardware_scb),\n\t\t\tsizeof(struct scb),\n\t\t\tsizeof(struct ahc_dma_seg));\n\t}\n#endif /* AHC_DEBUG */\n\n\t/* Set the SCSI Id,SXFRCTL0,SXFRCTL1, and SIMODE1, for both channels*/\n\tif (ahc->features & AHC_TWIN) {\n\n\t\t/*\n\t\t * The device is gated to channel B after a chip reset,\n\t\t * so set those values first\n\t\t */\n\t\tterm = (ahc->flags & AHC_TERM_ENB_B) != 0 ? STPWEN : 0;\n\t\tif ((ahc->features & AHC_ULTRA2) != 0)\n\t\t\tahc_outb(ahc, SCSIID_ULTRA2, ahc->our_id_b);\n\t\telse\n\t\t\tahc_outb(ahc, SCSIID, ahc->our_id_b);\n\t\tscsi_conf = ahc_inb(ahc, SCSICONF + 1);\n\t\tahc_outb(ahc, SXFRCTL1, (scsi_conf & (ENSPCHK|STIMESEL))\n\t\t\t\t\t|term|ENSTIMER|ACTNEGEN);\n\t\tahc_outb(ahc, SIMODE1, ENSELTIMO|ENSCSIRST|ENSCSIPERR);\n\t\tahc_outb(ahc, SXFRCTL0, DFON|SPIOEN);\n\n\t\tif ((scsi_conf & RESET_SCSI) != 0\n\t\t && (ahc->flags & AHC_INITIATORMODE) != 0)\n\t\t\tahc->flags |= AHC_RESET_BUS_B;\n\n\t\t/* Select Channel A */\n\t\tahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) & ~SELBUSB);\n\t}\n\tterm = (ahc->flags & AHC_TERM_ENB_A) != 0 ? STPWEN : 0;\n\tif ((ahc->features & AHC_ULTRA2) != 0)\n\t\tahc_outb(ahc, SCSIID_ULTRA2, ahc->our_id);\n\telse\n\t\tahc_outb(ahc, SCSIID, ahc->our_id);\n\tscsi_conf = ahc_inb(ahc, SCSICONF);\n\tahc_outb(ahc, SXFRCTL1, (scsi_conf & (ENSPCHK|STIMESEL))\n\t\t\t\t|term\n\t\t\t\t|ENSTIMER|ACTNEGEN);\n\tahc_outb(ahc, SIMODE1, ENSELTIMO|ENSCSIRST|ENSCSIPERR);\n\tahc_outb(ahc, SXFRCTL0, DFON|SPIOEN);\n\n\tif ((scsi_conf & RESET_SCSI) != 0\n\t && (ahc->flags & AHC_INITIATORMODE) != 0)\n\t\tahc->flags |= AHC_RESET_BUS_A;\n\n\t/*\n\t * Look at the information that board initialization or\n\t * the board bios has left us.\n\t */\n\tultraenb = 0;\t\n\ttagenable = ALL_TARGETS_MASK;\n\n\t/* Grab the disconnection disable table and invert it for our needs */\n\tif (ahc->flags & AHC_USEDEFAULTS) {\n\t\tprintf(\"%s: Host Adapter Bios disabled.  Using default SCSI \"\n\t\t\t\"device parameters\\n\", ahc_name(ahc));\n\t\tahc->flags |= AHC_EXTENDED_TRANS_A|AHC_EXTENDED_TRANS_B|\n\t\t\t      AHC_TERM_ENB_A|AHC_TERM_ENB_B;\n\t\tdiscenable = ALL_TARGETS_MASK;\n\t\tif ((ahc->features & AHC_ULTRA) != 0)\n\t\t\tultraenb = ALL_TARGETS_MASK;\n\t} else {\n\t\tdiscenable = ~((ahc_inb(ahc, DISC_DSB + 1) << 8)\n\t\t\t   | ahc_inb(ahc, DISC_DSB));\n\t\tif ((ahc->features & (AHC_ULTRA|AHC_ULTRA2)) != 0)\n\t\t\tultraenb = (ahc_inb(ahc, ULTRA_ENB + 1) << 8)\n\t\t\t\t      | ahc_inb(ahc, ULTRA_ENB);\n\t}\n\n\tif ((ahc->features & (AHC_WIDE|AHC_TWIN)) == 0)\n\t\tmax_targ = 7;\n\n\tfor (i = 0; i <= max_targ; i++) {\n\t\tstruct ahc_initiator_tinfo *tinfo;\n\t\tstruct tmode_tstate *tstate;\n\t\tu_int our_id;\n\t\tu_int target_id;\n\t\tchar channel;\n\n\t\tchannel = 'A';\n\t\tour_id = ahc->our_id;\n\t\ttarget_id = i;\n\t\tif (i > 7 && (ahc->features & AHC_TWIN) != 0) {\n\t\t\tchannel = 'B';\n\t\t\tour_id = ahc->our_id_b;\n\t\t\ttarget_id = i % 8;\n\t\t}\n\t\ttinfo = ahc_fetch_transinfo(ahc, channel, our_id,\n\t\t\t\t\t    target_id, &tstate);\n\t\t/* Default to async narrow across the board */\n\t\tbzero(tinfo, sizeof(*tinfo));\n\t\tif (ahc->flags & AHC_USEDEFAULTS) {\n\t\t\tif ((ahc->features & AHC_WIDE) != 0)\n\t\t\t\ttinfo->user.width = MSG_EXT_WDTR_BUS_16_BIT;\n\n\t\t\t/*\n\t\t\t * These will be truncated when we determine the\n\t\t\t * connection type we have with the target.\n\t\t\t */\n\t\t\ttinfo->user.period = ahc_syncrates->period;\n\t\t\ttinfo->user.offset = ~0;\n\t\t} else {\n\t\t\tu_int scsirate;\n\t\t\tu_int16_t mask;\n\n\t\t\t/* Take the settings leftover in scratch RAM. */\n\t\t\tscsirate = ahc_inb(ahc, TARG_SCSIRATE + i);\n\t\t\tmask = (0x01 << i);\n\t\t\tif ((ahc->features & AHC_ULTRA2) != 0) {\n\t\t\t\tu_int offset;\n\t\t\t\tu_int maxsync;\n\n\t\t\t\tif ((scsirate & SOFS) == 0x0F) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Haven't negotiated yet,\n\t\t\t\t\t * so the format is different.\n\t\t\t\t\t */\n\t\t\t\t\tscsirate = (scsirate & SXFR) >> 4\n\t\t\t\t\t\t | (ultraenb & mask)\n\t\t\t\t\t\t  ? 0x08 : 0x0\n\t\t\t\t\t\t | (scsirate & WIDEXFER);\n\t\t\t\t\toffset = MAX_OFFSET_ULTRA2;\n\t\t\t\t} else\n\t\t\t\t\toffset = ahc_inb(ahc, TARG_OFFSET + i);\n\t\t\t\tmaxsync = AHC_SYNCRATE_ULTRA2;\n\t\t\t\tif ((ahc->features & AHC_DT) != 0)\n\t\t\t\t\tmaxsync = AHC_SYNCRATE_DT;\n\t\t\t\ttinfo->user.period =\n\t\t\t\t    ahc_find_period(ahc, scsirate, maxsync);\n\t\t\t\tif (offset == 0)\n\t\t\t\t\ttinfo->user.period = 0;\n\t\t\t\telse\n\t\t\t\t\ttinfo->user.offset = ~0;\n\t\t\t} else if ((scsirate & SOFS) != 0) {\n\t\t\t\ttinfo->user.period = \n\t\t\t\t    ahc_find_period(ahc, scsirate,\n\t\t\t\t\t\t    (ultraenb & mask)\n\t\t\t\t\t\t   ? AHC_SYNCRATE_ULTRA\n\t\t\t\t\t\t   : AHC_SYNCRATE_FAST);\n\t\t\t\tif (tinfo->user.period != 0)\n\t\t\t\t\ttinfo->user.offset = ~0;\n\t\t\t}\n\t\t\tif ((scsirate & WIDEXFER) != 0\n\t\t\t && (ahc->features & AHC_WIDE) != 0)\n\t\t\t\ttinfo->user.width = MSG_EXT_WDTR_BUS_16_BIT;\n\t\t}\n\t\ttinfo->goal = tinfo->user; /* force negotiation */\n\t\ttstate->ultraenb = ultraenb;\n\t\ttstate->discenable = discenable;\n\t\ttstate->tagenable = 0; /* Wait until the XPT says its okay */\n\t}\n\tahc->user_discenable = discenable;\n\tahc->user_tagenable = tagenable;\n\n\t/*\n\t * Tell the sequencer where it can find our arrays in memory.\n\t */\n\tphysaddr = ahc->scb_data->hscb_busaddr;\n\tahc_outb(ahc, HSCB_ADDR, physaddr & 0xFF);\n\tahc_outb(ahc, HSCB_ADDR + 1, (physaddr >> 8) & 0xFF);\n\tahc_outb(ahc, HSCB_ADDR + 2, (physaddr >> 16) & 0xFF);\n\tahc_outb(ahc, HSCB_ADDR + 3, (physaddr >> 24) & 0xFF);\n\n\tphysaddr = ahc->shared_data_busaddr;\n\tahc_outb(ahc, SCBID_ADDR, physaddr & 0xFF);\n\tahc_outb(ahc, SCBID_ADDR + 1, (physaddr >> 8) & 0xFF);\n\tahc_outb(ahc, SCBID_ADDR + 2, (physaddr >> 16) & 0xFF);\n\tahc_outb(ahc, SCBID_ADDR + 3, (physaddr >> 24) & 0xFF);\n\n\t/* Target mode incomding command fifo */\n\tphysaddr += 3 * 256 * sizeof(u_int8_t);\n\tahc_outb(ahc, TMODE_CMDADDR, physaddr & 0xFF);\n\tahc_outb(ahc, TMODE_CMDADDR + 1, (physaddr >> 8) & 0xFF);\n\tahc_outb(ahc, TMODE_CMDADDR + 2, (physaddr >> 16) & 0xFF);\n\tahc_outb(ahc, TMODE_CMDADDR + 3, (physaddr >> 24) & 0xFF);\n\n\t/*\n\t * Initialize the group code to command length table.\n\t * This overrides the values in TARG_SCSIRATE, so only\n\t * setup the table after we have processed that information.\n\t */\n\tahc_outb(ahc, CMDSIZE_TABLE, 5);\n\tahc_outb(ahc, CMDSIZE_TABLE + 1, 9);\n\tahc_outb(ahc, CMDSIZE_TABLE + 2, 9);\n\tahc_outb(ahc, CMDSIZE_TABLE + 3, 0);\n\tahc_outb(ahc, CMDSIZE_TABLE + 4, 15);\n\tahc_outb(ahc, CMDSIZE_TABLE + 5, 11);\n\tahc_outb(ahc, CMDSIZE_TABLE + 6, 0);\n\tahc_outb(ahc, CMDSIZE_TABLE + 7, 0);\n\t\t\n\t/* Tell the sequencer of our initial queue positions */\n\tahc_outb(ahc, KERNEL_QINPOS, 0);\n\tahc_outb(ahc, QINPOS, 0);\n\tahc_outb(ahc, QOUTPOS, 0);\n\n#ifdef AHC_DEBUG\n\tif (ahc_debug & AHC_SHOWMISC)\n\t\tprintf(\"NEEDSDTR == 0x%x\\nNEEDWDTR == 0x%x\\n\"\n\t\t       \"DISCENABLE == 0x%x\\nULTRAENB == 0x%x\\n\",\n\t\t       ahc->needsdtr_orig, ahc->needwdtr_orig,\n\t\t       discenable, ultraenb);\n#endif\n\n\t/* Don't have any special messages to send to targets */\n\tahc_outb(ahc, TARGET_MSG_REQUEST, 0);\n\tahc_outb(ahc, TARGET_MSG_REQUEST + 1, 0);\n\n\t/*\n\t * Use the built in queue management registers\n\t * if they are available.\n\t */\n\tif ((ahc->features & AHC_QUEUE_REGS) != 0) {\n\t\tahc_outb(ahc, QOFF_CTLSTA, SCB_QSIZE_256);\n\t\tahc_outb(ahc, SDSCB_QOFF, 0);\n\t\tahc_outb(ahc, SNSCB_QOFF, 0);\n\t\tahc_outb(ahc, HNSCB_QOFF, 0);\n\t}\n\n\n\t/* We don't have any waiting selections */\n\tahc_outb(ahc, WAITING_SCBH, SCB_LIST_NULL);\n\n\t/* Our disconnection list is empty too */\n\tahc_outb(ahc, DISCONNECTED_SCBH, SCB_LIST_NULL);\n\n\t/* Message out buffer starts empty */\n\tahc_outb(ahc, MSG_OUT, MSG_NOOP);\n\n\t/*\n\t * Setup the allowed SCSI Sequences based on operational mode.\n\t * If we are a target, we'll enalbe select in operations once\n\t * we've had a lun enabled.\n\t */\n\tscsiseq_template = ENSELO|ENAUTOATNO|ENAUTOATNP;\n\tif ((ahc->flags & AHC_INITIATORMODE) != 0)\n\t\tscsiseq_template |= ENRSELI;\n\tahc_outb(ahc, SCSISEQ_TEMPLATE, scsiseq_template);\n\n\t/*\n\t * Load the Sequencer program and Enable the adapter\n\t * in \"fast\" mode.\n         */\n\tif (bootverbose)\n\t\tprintf(\"%s: Downloading Sequencer Program...\",\n\t\t       ahc_name(ahc));\n\n\tahc_loadseq(ahc);\n\n\t/* We have to wait until after any system dumps... */\n\tshutdownhook_establish(ahc_shutdown, ahc);\n\treturn (0);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define AHC_SYNCRATE_FAST\t6",
            "#define AHC_SYNCRATE_ULTRA\t3",
            "#define AHC_SYNCRATE_ULTRA2\t1",
            "#define AHC_SYNCRATE_DT\t\t0",
            "#define bootverbose\t0",
            "#define bootverbose\t1",
            "#define ALL_TARGETS_MASK 0xFFFF"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "ahc_poll __P((struct ahc_softc *ahc, int wait));",
            "ahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "ahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));",
            "STATIC u_int",
            "STATIC struct",
            "ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "ahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));",
            "STATIC u_int",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "ahc_find_period __P((struct ahc_softc *ahc, u_int scsirate,\n\t\t\t\t  u_int maxsync));",
            "ahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));",
            "ahc_calc_residual __P((struct scb *scb));",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "ahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "static __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo",
            "ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));",
            "int    ahc_createdmamem",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "u_int our_id;",
            "struct tmode_tstate **tstate;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "static struct ahc_syncrate ahc_syncrates[] = {\n      /* ultra2    fast/ultra  period     rate */\n\t{ 0x42,      0x000,      9,      \"80.0\" },\n\t{ 0x03,      0x000,     10,      \"40.0\" },\n\t{ 0x04,      0x000,     11,      \"33.0\" },\n\t{ 0x05,      0x100,     12,      \"20.0\" },\n\t{ 0x06,      0x110,     15,      \"16.0\" },\n\t{ 0x07,      0x120,     18,      \"13.4\" },\n\t{ 0x08,      0x000,     25,      \"10.0\" },\n\t{ 0x19,      0x010,     31,      \"8.0\"  },\n\t{ 0x1a,      0x020,     37,      \"6.67\" },\n\t{ 0x1b,      0x030,     43,      \"5.7\"  },\n\t{ 0x1c,      0x040,     50,      \"5.0\"  },\n\t{ 0x00,      0x050,     56,      \"4.4\"  },\n\t{ 0x00,      0x060,     62,      \"4.0\"  },\n\t{ 0x00,      0x070,     68,      \"3.6\"  },\n\t{ 0x00,      0x000,      0,      NULL   }\n};",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "u_int *period;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "u_int *period;",
            "u_int maxsync;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define AHC_SYNCRATE_FAST\t6\n#define AHC_SYNCRATE_ULTRA\t3\n#define AHC_SYNCRATE_ULTRA2\t1\n#define AHC_SYNCRATE_DT\t\t0\n#define bootverbose\t0\n#define bootverbose\t1\n#define ALL_TARGETS_MASK 0xFFFF\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nahc_poll __P((struct ahc_softc *ahc, int wait));\nahc_setup_data __P((struct ahc_softc *ahc,\n\t\t\t\t    struct scsi_xfer *xs, struct scb *scb));\nahcallocscbs __P((struct ahc_softc *ahc));\nahc_compile_devinfo __P((struct ahc_devinfo *devinfo,\n\t\t\t\t\t u_int our_id, u_int target,\n\t\t\t\t\t u_int lun, char channel,\n\t\t\t\t\t role_t role));\nSTATIC u_int;\nSTATIC struct;\nahc_setup_initiator_msgout __P((struct ahc_softc *ahc,\n\t\t\t\t\t\tstruct ahc_devinfo *devinfo,\n\t\t\t\t\t\tstruct scb *scb));\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nahc_loadseq __P((struct ahc_softc *ahc));\nahc_match_scb __P((struct scb *scb, int target, char channel,\n\t\t\t\t   int lun, u_int tag, role_t role));\nSTATIC u_int;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nahc_clear_intstat __P((struct ahc_softc *ahc));\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nahc_find_period __P((struct ahc_softc *ahc, u_int scsirate,\n\t\t\t\t  u_int maxsync));\nahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));\nahc_calc_residual __P((struct scb *scb));\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nahc_set_recoveryscb __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct scb *scb));\nrestart_sequencer __P((struct ahc_softc *ahc));\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nstatic __inline struct ahc_initiator_tinfo *\n\tahc_fetch_transinfo;\nahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));\nint    ahc_createdmamem;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nu_int our_id;\nstruct tmode_tstate **tstate;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nstatic struct ahc_syncrate ahc_syncrates[] = {\n      /* ultra2    fast/ultra  period     rate */\n\t{ 0x42,      0x000,      9,      \"80.0\" },\n\t{ 0x03,      0x000,     10,      \"40.0\" },\n\t{ 0x04,      0x000,     11,      \"33.0\" },\n\t{ 0x05,      0x100,     12,      \"20.0\" },\n\t{ 0x06,      0x110,     15,      \"16.0\" },\n\t{ 0x07,      0x120,     18,      \"13.4\" },\n\t{ 0x08,      0x000,     25,      \"10.0\" },\n\t{ 0x19,      0x010,     31,      \"8.0\"  },\n\t{ 0x1a,      0x020,     37,      \"6.67\" },\n\t{ 0x1b,      0x030,     43,      \"5.7\"  },\n\t{ 0x1c,      0x040,     50,      \"5.0\"  },\n\t{ 0x00,      0x050,     56,      \"4.4\"  },\n\t{ 0x00,      0x060,     62,      \"4.0\"  },\n\t{ 0x00,      0x070,     68,      \"3.6\"  },\n\t{ 0x00,      0x000,      0,      NULL   }\n};\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nu_int *period;\nu_int maxsync;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nint\nahc_init(ahc)\n\tstruct ahc_softc *ahc;\n{\n\tint\t  max_targ = 15;\n\tint\t  i;\n\tint\t  term;\n\tu_int\t  scsi_conf;\n\tu_int\t  scsiseq_template;\n\tu_int\t  ultraenb;\n\tu_int\t  discenable;\n\tu_int\t  tagenable;\n\tsize_t\t  driver_data_size;\n\tu_int32_t physaddr;\n\tstruct scb_data *scb_data = NULL;\n\n#ifdef AHC_PRINT_SRAM\n\tprintf(\"Scratch Ram:\");\n\tfor (i = 0x20; i < 0x5f; i++) {\n\t\tif (((i % 8) == 0) && (i != 0)) {\n\t\t\tprintf (\"\\n              \");\n\t\t}\n\t\tprintf (\" 0x%x\", ahc_inb(ahc, i));\n\t}\n\tif ((ahc->features & AHC_MORE_SRAM) != 0) {\n\t\tfor (i = 0x70; i < 0x7f; i++) {\n\t\t\tif (((i % 8) == 0) && (i != 0)) {\n\t\t\t\tprintf (\"\\n              \");\n\t\t\t}\n\t\t\tprintf (\" 0x%x\", ahc_inb(ahc, i));\n\t\t}\n\t}\n\tprintf (\"\\n\");\n#endif\n\n\tif (ahc->scb_data == NULL) {\n\t\tscb_data = malloc(sizeof (struct scb_data), M_DEVBUF, M_NOWAIT);\n\t\tif (scb_data == NULL) {\n\t\t\tprintf(\"%s: cannot malloc scb_data!\\n\", ahc_name(ahc));\n\t\t\treturn (ENOMEM);\n\t\t}\n\t\tbzero(scb_data, sizeof(struct scb_data));\n\t\tahc->scb_data = scb_data;\n\t}\n\t/*\n\t * Assume we have a board at this stage and it has been reset.\n\t */\n\tif ((ahc->flags & AHC_USEDEFAULTS) != 0)\n\t\tahc->our_id = ahc->our_id_b = 7;\n\t\n\t/*\n\t * Default to allowing initiator operations.\n\t */\n\tahc->flags |= AHC_INITIATORMODE;\n\t\n\t/*\n\t * DMA tag for our command fifos and other data in system memory\n\t * the card's sequencer must be able to access.  For initiator\n\t * roles, we need to allocate space for the qinfifo, qoutfifo,\n\t * and untagged_scb arrays each of which are composed of 256\n\t * 1 byte elements.  When providing for the target mode role,\n\t * we additionally must provide space for the incoming target\n\t * command fifo.\n\t */\n\tdriver_data_size = 3 * 256 * sizeof(u_int8_t);\n\n\tif (ahc_createdmamem(ahc, driver_data_size, \n\t    &ahc->shared_data_dmamap, (caddr_t *)&ahc->qoutfifo,\n\t    &ahc->shared_data_busaddr, &ahc->shared_data_seg,\n\t    &ahc->shared_data_nseg, \"shared data\") < 0)\n\t\treturn (ENOMEM);\n\n\tahc->init_level++;\n\n\t/* Allocate SCB data now that sc_dmat is initialized */\n\tif (ahc->scb_data->maxhscbs == 0)\n\t\tif (ahcinitscbdata(ahc) != 0)\n\t\t\treturn (ENOMEM);\n\n\tahc->qinfifo = &ahc->qoutfifo[256];\n\tahc->untagged_scbs = &ahc->qinfifo[256];\n\t/* There are no untagged SCBs active yet. */\n\tfor (i = 0; i < 256; i++)\n\t\tahc->untagged_scbs[i] = SCB_LIST_NULL;\n\n\t/* All of our queues are empty */\n\tfor (i = 0; i < 256; i++)\n\t\tahc->qoutfifo[i] = SCB_LIST_NULL;\n\n\tbus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap,\n\t\t\tBUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);\n\t\n\t/*\n\t * Allocate a tstate to house information for our\n\t * initiator presence on the bus as well as the user\n\t * data for any target mode initiator.\n\t */\n\tif (ahc_alloc_tstate(ahc, ahc->our_id, 'A') == NULL) {\n\t\tprintf(\"%s: unable to allocate tmode_tstate.  \"\n\t\t       \"Failing attach\\n\", ahc_name(ahc));\n\t\treturn (-1);\n\t}\n\n\tif ((ahc->features & AHC_TWIN) != 0) {\n\t\tif (ahc_alloc_tstate(ahc, ahc->our_id_b, 'B') == NULL) {\n\t\t\tprintf(\"%s: unable to allocate tmode_tstate.  \"\n\t\t\t       \"Failing attach\\n\", ahc_name(ahc));\n\t\t\treturn (-1);\n\t\t}\n \t\tprintf(\"Twin Channel, A SCSI Id=%d, B SCSI Id=%d, primary %c, \",\n\t\t       ahc->our_id, ahc->our_id_b,\n\t\t       ahc->flags & AHC_CHANNEL_B_PRIMARY? 'B': 'A');\n\t} else {\n\t\tif ((ahc->features & AHC_WIDE) != 0) {\n\t\t\tprintf(\"Wide \");\n\t\t} else {\n\t\t\tprintf(\"Single \");\n\t\t}\n\t\tprintf(\"Channel %c, SCSI Id=%d, \", ahc->channel, ahc->our_id);\n\t}\n\n\tahc_outb(ahc, SEQ_FLAGS, 0);\n\n\tif (ahc->scb_data->maxhscbs < AHC_SCB_MAX) {\n\t\tahc->flags |= AHC_PAGESCBS;\n\t\tprintf(\"%d/%d SCBs\\n\", ahc->scb_data->maxhscbs, AHC_SCB_MAX);\n\t} else {\n\t\tahc->flags &= ~AHC_PAGESCBS;\n\t\tprintf(\"%d SCBs\\n\", ahc->scb_data->maxhscbs);\n\t}\n\n#ifdef AHC_DEBUG\n\tif (ahc_debug & AHC_SHOWMISC) {\n\t\tprintf(\"%s: hardware scb %d bytes; kernel scb %d bytes; \"\n\t\t       \"ahc_dma %d bytes\\n\",\n\t\t\tahc_name(ahc),\n\t\t        sizeof(struct hardware_scb),\n\t\t\tsizeof(struct scb),\n\t\t\tsizeof(struct ahc_dma_seg));\n\t}\n#endif /* AHC_DEBUG */\n\n\t/* Set the SCSI Id,SXFRCTL0,SXFRCTL1, and SIMODE1, for both channels*/\n\tif (ahc->features & AHC_TWIN) {\n\n\t\t/*\n\t\t * The device is gated to channel B after a chip reset,\n\t\t * so set those values first\n\t\t */\n\t\tterm = (ahc->flags & AHC_TERM_ENB_B) != 0 ? STPWEN : 0;\n\t\tif ((ahc->features & AHC_ULTRA2) != 0)\n\t\t\tahc_outb(ahc, SCSIID_ULTRA2, ahc->our_id_b);\n\t\telse\n\t\t\tahc_outb(ahc, SCSIID, ahc->our_id_b);\n\t\tscsi_conf = ahc_inb(ahc, SCSICONF + 1);\n\t\tahc_outb(ahc, SXFRCTL1, (scsi_conf & (ENSPCHK|STIMESEL))\n\t\t\t\t\t|term|ENSTIMER|ACTNEGEN);\n\t\tahc_outb(ahc, SIMODE1, ENSELTIMO|ENSCSIRST|ENSCSIPERR);\n\t\tahc_outb(ahc, SXFRCTL0, DFON|SPIOEN);\n\n\t\tif ((scsi_conf & RESET_SCSI) != 0\n\t\t && (ahc->flags & AHC_INITIATORMODE) != 0)\n\t\t\tahc->flags |= AHC_RESET_BUS_B;\n\n\t\t/* Select Channel A */\n\t\tahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) & ~SELBUSB);\n\t}\n\tterm = (ahc->flags & AHC_TERM_ENB_A) != 0 ? STPWEN : 0;\n\tif ((ahc->features & AHC_ULTRA2) != 0)\n\t\tahc_outb(ahc, SCSIID_ULTRA2, ahc->our_id);\n\telse\n\t\tahc_outb(ahc, SCSIID, ahc->our_id);\n\tscsi_conf = ahc_inb(ahc, SCSICONF);\n\tahc_outb(ahc, SXFRCTL1, (scsi_conf & (ENSPCHK|STIMESEL))\n\t\t\t\t|term\n\t\t\t\t|ENSTIMER|ACTNEGEN);\n\tahc_outb(ahc, SIMODE1, ENSELTIMO|ENSCSIRST|ENSCSIPERR);\n\tahc_outb(ahc, SXFRCTL0, DFON|SPIOEN);\n\n\tif ((scsi_conf & RESET_SCSI) != 0\n\t && (ahc->flags & AHC_INITIATORMODE) != 0)\n\t\tahc->flags |= AHC_RESET_BUS_A;\n\n\t/*\n\t * Look at the information that board initialization or\n\t * the board bios has left us.\n\t */\n\tultraenb = 0;\t\n\ttagenable = ALL_TARGETS_MASK;\n\n\t/* Grab the disconnection disable table and invert it for our needs */\n\tif (ahc->flags & AHC_USEDEFAULTS) {\n\t\tprintf(\"%s: Host Adapter Bios disabled.  Using default SCSI \"\n\t\t\t\"device parameters\\n\", ahc_name(ahc));\n\t\tahc->flags |= AHC_EXTENDED_TRANS_A|AHC_EXTENDED_TRANS_B|\n\t\t\t      AHC_TERM_ENB_A|AHC_TERM_ENB_B;\n\t\tdiscenable = ALL_TARGETS_MASK;\n\t\tif ((ahc->features & AHC_ULTRA) != 0)\n\t\t\tultraenb = ALL_TARGETS_MASK;\n\t} else {\n\t\tdiscenable = ~((ahc_inb(ahc, DISC_DSB + 1) << 8)\n\t\t\t   | ahc_inb(ahc, DISC_DSB));\n\t\tif ((ahc->features & (AHC_ULTRA|AHC_ULTRA2)) != 0)\n\t\t\tultraenb = (ahc_inb(ahc, ULTRA_ENB + 1) << 8)\n\t\t\t\t      | ahc_inb(ahc, ULTRA_ENB);\n\t}\n\n\tif ((ahc->features & (AHC_WIDE|AHC_TWIN)) == 0)\n\t\tmax_targ = 7;\n\n\tfor (i = 0; i <= max_targ; i++) {\n\t\tstruct ahc_initiator_tinfo *tinfo;\n\t\tstruct tmode_tstate *tstate;\n\t\tu_int our_id;\n\t\tu_int target_id;\n\t\tchar channel;\n\n\t\tchannel = 'A';\n\t\tour_id = ahc->our_id;\n\t\ttarget_id = i;\n\t\tif (i > 7 && (ahc->features & AHC_TWIN) != 0) {\n\t\t\tchannel = 'B';\n\t\t\tour_id = ahc->our_id_b;\n\t\t\ttarget_id = i % 8;\n\t\t}\n\t\ttinfo = ahc_fetch_transinfo(ahc, channel, our_id,\n\t\t\t\t\t    target_id, &tstate);\n\t\t/* Default to async narrow across the board */\n\t\tbzero(tinfo, sizeof(*tinfo));\n\t\tif (ahc->flags & AHC_USEDEFAULTS) {\n\t\t\tif ((ahc->features & AHC_WIDE) != 0)\n\t\t\t\ttinfo->user.width = MSG_EXT_WDTR_BUS_16_BIT;\n\n\t\t\t/*\n\t\t\t * These will be truncated when we determine the\n\t\t\t * connection type we have with the target.\n\t\t\t */\n\t\t\ttinfo->user.period = ahc_syncrates->period;\n\t\t\ttinfo->user.offset = ~0;\n\t\t} else {\n\t\t\tu_int scsirate;\n\t\t\tu_int16_t mask;\n\n\t\t\t/* Take the settings leftover in scratch RAM. */\n\t\t\tscsirate = ahc_inb(ahc, TARG_SCSIRATE + i);\n\t\t\tmask = (0x01 << i);\n\t\t\tif ((ahc->features & AHC_ULTRA2) != 0) {\n\t\t\t\tu_int offset;\n\t\t\t\tu_int maxsync;\n\n\t\t\t\tif ((scsirate & SOFS) == 0x0F) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Haven't negotiated yet,\n\t\t\t\t\t * so the format is different.\n\t\t\t\t\t */\n\t\t\t\t\tscsirate = (scsirate & SXFR) >> 4\n\t\t\t\t\t\t | (ultraenb & mask)\n\t\t\t\t\t\t  ? 0x08 : 0x0\n\t\t\t\t\t\t | (scsirate & WIDEXFER);\n\t\t\t\t\toffset = MAX_OFFSET_ULTRA2;\n\t\t\t\t} else\n\t\t\t\t\toffset = ahc_inb(ahc, TARG_OFFSET + i);\n\t\t\t\tmaxsync = AHC_SYNCRATE_ULTRA2;\n\t\t\t\tif ((ahc->features & AHC_DT) != 0)\n\t\t\t\t\tmaxsync = AHC_SYNCRATE_DT;\n\t\t\t\ttinfo->user.period =\n\t\t\t\t    ahc_find_period(ahc, scsirate, maxsync);\n\t\t\t\tif (offset == 0)\n\t\t\t\t\ttinfo->user.period = 0;\n\t\t\t\telse\n\t\t\t\t\ttinfo->user.offset = ~0;\n\t\t\t} else if ((scsirate & SOFS) != 0) {\n\t\t\t\ttinfo->user.period = \n\t\t\t\t    ahc_find_period(ahc, scsirate,\n\t\t\t\t\t\t    (ultraenb & mask)\n\t\t\t\t\t\t   ? AHC_SYNCRATE_ULTRA\n\t\t\t\t\t\t   : AHC_SYNCRATE_FAST);\n\t\t\t\tif (tinfo->user.period != 0)\n\t\t\t\t\ttinfo->user.offset = ~0;\n\t\t\t}\n\t\t\tif ((scsirate & WIDEXFER) != 0\n\t\t\t && (ahc->features & AHC_WIDE) != 0)\n\t\t\t\ttinfo->user.width = MSG_EXT_WDTR_BUS_16_BIT;\n\t\t}\n\t\ttinfo->goal = tinfo->user; /* force negotiation */\n\t\ttstate->ultraenb = ultraenb;\n\t\ttstate->discenable = discenable;\n\t\ttstate->tagenable = 0; /* Wait until the XPT says its okay */\n\t}\n\tahc->user_discenable = discenable;\n\tahc->user_tagenable = tagenable;\n\n\t/*\n\t * Tell the sequencer where it can find our arrays in memory.\n\t */\n\tphysaddr = ahc->scb_data->hscb_busaddr;\n\tahc_outb(ahc, HSCB_ADDR, physaddr & 0xFF);\n\tahc_outb(ahc, HSCB_ADDR + 1, (physaddr >> 8) & 0xFF);\n\tahc_outb(ahc, HSCB_ADDR + 2, (physaddr >> 16) & 0xFF);\n\tahc_outb(ahc, HSCB_ADDR + 3, (physaddr >> 24) & 0xFF);\n\n\tphysaddr = ahc->shared_data_busaddr;\n\tahc_outb(ahc, SCBID_ADDR, physaddr & 0xFF);\n\tahc_outb(ahc, SCBID_ADDR + 1, (physaddr >> 8) & 0xFF);\n\tahc_outb(ahc, SCBID_ADDR + 2, (physaddr >> 16) & 0xFF);\n\tahc_outb(ahc, SCBID_ADDR + 3, (physaddr >> 24) & 0xFF);\n\n\t/* Target mode incomding command fifo */\n\tphysaddr += 3 * 256 * sizeof(u_int8_t);\n\tahc_outb(ahc, TMODE_CMDADDR, physaddr & 0xFF);\n\tahc_outb(ahc, TMODE_CMDADDR + 1, (physaddr >> 8) & 0xFF);\n\tahc_outb(ahc, TMODE_CMDADDR + 2, (physaddr >> 16) & 0xFF);\n\tahc_outb(ahc, TMODE_CMDADDR + 3, (physaddr >> 24) & 0xFF);\n\n\t/*\n\t * Initialize the group code to command length table.\n\t * This overrides the values in TARG_SCSIRATE, so only\n\t * setup the table after we have processed that information.\n\t */\n\tahc_outb(ahc, CMDSIZE_TABLE, 5);\n\tahc_outb(ahc, CMDSIZE_TABLE + 1, 9);\n\tahc_outb(ahc, CMDSIZE_TABLE + 2, 9);\n\tahc_outb(ahc, CMDSIZE_TABLE + 3, 0);\n\tahc_outb(ahc, CMDSIZE_TABLE + 4, 15);\n\tahc_outb(ahc, CMDSIZE_TABLE + 5, 11);\n\tahc_outb(ahc, CMDSIZE_TABLE + 6, 0);\n\tahc_outb(ahc, CMDSIZE_TABLE + 7, 0);\n\t\t\n\t/* Tell the sequencer of our initial queue positions */\n\tahc_outb(ahc, KERNEL_QINPOS, 0);\n\tahc_outb(ahc, QINPOS, 0);\n\tahc_outb(ahc, QOUTPOS, 0);\n\n#ifdef AHC_DEBUG\n\tif (ahc_debug & AHC_SHOWMISC)\n\t\tprintf(\"NEEDSDTR == 0x%x\\nNEEDWDTR == 0x%x\\n\"\n\t\t       \"DISCENABLE == 0x%x\\nULTRAENB == 0x%x\\n\",\n\t\t       ahc->needsdtr_orig, ahc->needwdtr_orig,\n\t\t       discenable, ultraenb);\n#endif\n\n\t/* Don't have any special messages to send to targets */\n\tahc_outb(ahc, TARGET_MSG_REQUEST, 0);\n\tahc_outb(ahc, TARGET_MSG_REQUEST + 1, 0);\n\n\t/*\n\t * Use the built in queue management registers\n\t * if they are available.\n\t */\n\tif ((ahc->features & AHC_QUEUE_REGS) != 0) {\n\t\tahc_outb(ahc, QOFF_CTLSTA, SCB_QSIZE_256);\n\t\tahc_outb(ahc, SDSCB_QOFF, 0);\n\t\tahc_outb(ahc, SNSCB_QOFF, 0);\n\t\tahc_outb(ahc, HNSCB_QOFF, 0);\n\t}\n\n\n\t/* We don't have any waiting selections */\n\tahc_outb(ahc, WAITING_SCBH, SCB_LIST_NULL);\n\n\t/* Our disconnection list is empty too */\n\tahc_outb(ahc, DISCONNECTED_SCBH, SCB_LIST_NULL);\n\n\t/* Message out buffer starts empty */\n\tahc_outb(ahc, MSG_OUT, MSG_NOOP);\n\n\t/*\n\t * Setup the allowed SCSI Sequences based on operational mode.\n\t * If we are a target, we'll enalbe select in operations once\n\t * we've had a lun enabled.\n\t */\n\tscsiseq_template = ENSELO|ENAUTOATNO|ENAUTOATNP;\n\tif ((ahc->flags & AHC_INITIATORMODE) != 0)\n\t\tscsiseq_template |= ENRSELI;\n\tahc_outb(ahc, SCSISEQ_TEMPLATE, scsiseq_template);\n\n\t/*\n\t * Load the Sequencer program and Enable the adapter\n\t * in \"fast\" mode.\n         */\n\tif (bootverbose)\n\t\tprintf(\"%s: Downloading Sequencer Program...\",\n\t\t       ahc_name(ahc));\n\n\tahc_loadseq(ahc);\n\n\t/* We have to wait until after any system dumps... */\n\tshutdownhook_establish(ahc_shutdown, ahc);\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AHC_OUTB",
          "args": [
            "ahc",
            "BUSTIME",
            "(hostconf << 2) & BOFF"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AHC_OUTB",
          "args": [
            "ahc",
            "BUSSPD",
            "hostconf & DFTHRSH"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AHC_INB",
          "args": [
            "ahc",
            "HOSTCONF"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AHC_OUTB",
          "args": [
            "ahc",
            "SBLKCTL",
            "sblkctl"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AHC_INB",
          "args": [
            "ahc",
            "SBLKCTL"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AHC_OUTB",
          "args": [
            "ahc",
            "SBLKCTL",
            "sblkctl"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AHC_INB",
          "args": [
            "ahc",
            "SBLKCTL"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCSICONF + 1"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "SCSICONF"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_inb",
          "args": [
            "ahc",
            "HA_274_BIOSCTRL"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_name",
          "args": [
            "ahc"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eisa_intr_map",
          "args": [
            "ec",
            "irq",
            "&ih"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_reset",
          "args": [
            "ahc"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_reset_channel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "5412-5527",
          "snippet": "STATIC int\nahc_reset_channel(ahc, channel, initiate_reset)\n\tstruct ahc_softc *ahc;\n\tchar channel;\n\tint initiate_reset;\n{\n\tu_int\tinitiator, target, max_scsiid;\n\tu_int\tsblkctl;\n\tu_int\tour_id;\n\tint\tfound;\n\tint\trestart_needed;\n\tchar\tcur_channel;\n\n\tahc->pending_device = NULL;\n\n\tpause_sequencer(ahc);\n\n\t/*\n\t * Run our command complete fifos to ensure that we perform\n\t * completion processing on any commands that 'completed'\n\t * before the reset occurred.\n\t */\n\tahc_run_qoutfifo(ahc);\n\n\t/*\n\t * Reset the bus if we are initiating this reset\n\t */\n\tsblkctl = ahc_inb(ahc, SBLKCTL);\n\tcur_channel = 'A';\n\tif ((ahc->features & AHC_TWIN) != 0\n\t && ((sblkctl & SELBUSB) != 0))\n\t    cur_channel = 'B';\n\tif (cur_channel != channel) {\n\t\t/* Case 1: Command for another bus is active\n\t\t * Stealthily reset the other bus without\n\t\t * upsetting the current bus.\n\t\t */\n\t\tahc_outb(ahc, SBLKCTL, sblkctl ^ SELBUSB);\n\t\tahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENBUSFREE);\n\t\tahc_outb(ahc, SCSISEQ,\n\t\t\t ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP));\n\t\tif (initiate_reset)\n\t\t\tahc_reset_current_bus(ahc);\n\t\tahc_clear_intstat(ahc);\n\t\tahc_outb(ahc, SBLKCTL, sblkctl);\n\t\trestart_needed = FALSE;\n\t} else {\n\t\t/* Case 2: A command from this bus is active or we're idle */\n\t\tahc_clear_msg_state(ahc);\n\t\tahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENBUSFREE);\n\t\tahc_outb(ahc, SCSISEQ,\n\t\t\t ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP));\n\t\tif (initiate_reset)\n\t\t\tahc_reset_current_bus(ahc);\n\t\tahc_clear_intstat(ahc);\n\n\t\t/*\n\t\t * Since we are going to restart the sequencer, avoid\n\t\t * a race in the sequencer that could cause corruption\n\t\t * of our Q pointers by starting over from index 0.\n\t\t */\n\t\tahc->qoutfifonext = 0;\n\t\tif ((ahc->features & AHC_QUEUE_REGS) != 0)\n\t\t\tahc_outb(ahc, SDSCB_QOFF, 0);\n\t\telse\n\t\t\tahc_outb(ahc, QOUTPOS, 0);\n\t\trestart_needed = TRUE;\n\t}\n\n\t/*\n\t * Clean up all the state information for the\n\t * pending transactions on this bus.\n\t */\n\tfound = ahc_abort_scbs(ahc, ALL_TARGETS, channel,\n\t\t\t       ALL_LUNS, SCB_LIST_NULL,\n\t\t\t       ROLE_UNKNOWN, XS_RESET);\n\tif (channel == 'B') {\n\t\tour_id = ahc->our_id_b;\n\t} else {\n\t\tour_id = ahc->our_id;\n\t}\n\n\tmax_scsiid = (ahc->features & AHC_WIDE) ? 15 : 7;\n\t\n\t/*\n\t * Revert to async/narrow transfers until we renegotiate.\n\t */\n\tfor (target = 0; target <= max_scsiid; target++) {\n\n\t\tif (ahc->enabled_targets[target] == NULL)\n\t\t\tcontinue;\n\t\tfor (initiator = 0; initiator <= max_scsiid; initiator++) {\n\t\t\tstruct ahc_devinfo devinfo;\n\n\t\t\tahc_compile_devinfo(&devinfo, target, initiator,\n\t\t\t\t\t    ALL_LUNS,\n\t\t\t\t\t    channel, ROLE_UNKNOWN);\n\t\t\tahc_set_width(ahc, &devinfo,\n\t\t\t\t      MSG_EXT_WDTR_BUS_8_BIT,\n\t\t\t\t      AHC_TRANS_CUR,\n\t\t\t\t      /*paused*/TRUE,\n\t\t\t\t      /*done*/FALSE);\n\t\t\tahc_set_syncrate(ahc, &devinfo,\n\t\t\t\t\t /*syncrate*/NULL, /*period*/0,\n\t\t\t\t\t /*offset*/0, AHC_TRANS_CUR,\n\t\t\t\t\t /*paused*/TRUE,\n\t\t\t\t\t /*done*/FALSE);\n\t\t}\n\t}\n\n\tif (restart_needed)\n\t\trestart_sequencer(ahc);\n\telse\n\t\tunpause_sequencer(ahc);\n\treturn found;\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));",
            "STATIC int",
            "ahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "ahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));",
            "STATIC void",
            "ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "ahc_reset_channel __P((struct ahc_softc *ahc, char channel,\n\t\t\t\t       int initiate_reset));",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "ahc_update_target_msg_request __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t\t      struct ahc_initiator_tinfo *tinfo,\n\t\t\t\t\t      int force, int paused));",
            "STATIC void",
            "ahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));",
            "STATIC void",
            "ahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "static __inline void pause_sequencer",
            "static __inline void unpause_sequencer",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "u_int our_id;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "u_int *period;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "u_int *period;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "char channel;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_fetch_devinfo __P((struct ahc_softc *ahc,\n\t\t\t\t       struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_build_transfer_msg __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_setup_target_msgin __P((struct ahc_softc *ahc,\n\t\t\t\t\t    struct ahc_devinfo *devinfo));\nSTATIC int;\nahc_handle_msg_reject __P((struct ahc_softc *ahc,\n\t\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nahc_parse_msg __P((struct ahc_softc *ahc,\n\t\t\t\t   struct scsi_link *sc_link,\n\t\t\t\t   struct ahc_devinfo *devinfo));\nSTATIC void;\nahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,\n\t\t\t\t\t\t struct ahc_devinfo *devinfo));\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nahc_reset_channel __P((struct ahc_softc *ahc, char channel,\n\t\t\t\t       int initiate_reset));\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nahc_update_target_msg_request __P((struct ahc_softc *ahc,\n\t\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t\t      struct ahc_initiator_tinfo *tinfo,\n\t\t\t\t\t      int force, int paused));\nSTATIC void;\nahc_set_syncrate __P((struct ahc_softc *ahc,\n\t\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t\t      struct ahc_syncrate *syncrate,\n\t\t\t\t      u_int period, u_int offset,\n\t\t\t\t      u_int type, int paused, int done));\nSTATIC void;\nahc_set_width __P((struct ahc_softc *ahc,\n\t\t\t      struct ahc_devinfo *devinfo,\n\t\t\t      u_int width, u_int type, int paused, int done));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nstatic __inline void pause_sequencer;\nstatic __inline void unpause_sequencer;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nchar channel;\nu_int our_id;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nu_int *period;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nchar channel;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC int\nahc_reset_channel(ahc, channel, initiate_reset)\n\tstruct ahc_softc *ahc;\n\tchar channel;\n\tint initiate_reset;\n{\n\tu_int\tinitiator, target, max_scsiid;\n\tu_int\tsblkctl;\n\tu_int\tour_id;\n\tint\tfound;\n\tint\trestart_needed;\n\tchar\tcur_channel;\n\n\tahc->pending_device = NULL;\n\n\tpause_sequencer(ahc);\n\n\t/*\n\t * Run our command complete fifos to ensure that we perform\n\t * completion processing on any commands that 'completed'\n\t * before the reset occurred.\n\t */\n\tahc_run_qoutfifo(ahc);\n\n\t/*\n\t * Reset the bus if we are initiating this reset\n\t */\n\tsblkctl = ahc_inb(ahc, SBLKCTL);\n\tcur_channel = 'A';\n\tif ((ahc->features & AHC_TWIN) != 0\n\t && ((sblkctl & SELBUSB) != 0))\n\t    cur_channel = 'B';\n\tif (cur_channel != channel) {\n\t\t/* Case 1: Command for another bus is active\n\t\t * Stealthily reset the other bus without\n\t\t * upsetting the current bus.\n\t\t */\n\t\tahc_outb(ahc, SBLKCTL, sblkctl ^ SELBUSB);\n\t\tahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENBUSFREE);\n\t\tahc_outb(ahc, SCSISEQ,\n\t\t\t ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP));\n\t\tif (initiate_reset)\n\t\t\tahc_reset_current_bus(ahc);\n\t\tahc_clear_intstat(ahc);\n\t\tahc_outb(ahc, SBLKCTL, sblkctl);\n\t\trestart_needed = FALSE;\n\t} else {\n\t\t/* Case 2: A command from this bus is active or we're idle */\n\t\tahc_clear_msg_state(ahc);\n\t\tahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENBUSFREE);\n\t\tahc_outb(ahc, SCSISEQ,\n\t\t\t ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP));\n\t\tif (initiate_reset)\n\t\t\tahc_reset_current_bus(ahc);\n\t\tahc_clear_intstat(ahc);\n\n\t\t/*\n\t\t * Since we are going to restart the sequencer, avoid\n\t\t * a race in the sequencer that could cause corruption\n\t\t * of our Q pointers by starting over from index 0.\n\t\t */\n\t\tahc->qoutfifonext = 0;\n\t\tif ((ahc->features & AHC_QUEUE_REGS) != 0)\n\t\t\tahc_outb(ahc, SDSCB_QOFF, 0);\n\t\telse\n\t\t\tahc_outb(ahc, QOUTPOS, 0);\n\t\trestart_needed = TRUE;\n\t}\n\n\t/*\n\t * Clean up all the state information for the\n\t * pending transactions on this bus.\n\t */\n\tfound = ahc_abort_scbs(ahc, ALL_TARGETS, channel,\n\t\t\t       ALL_LUNS, SCB_LIST_NULL,\n\t\t\t       ROLE_UNKNOWN, XS_RESET);\n\tif (channel == 'B') {\n\t\tour_id = ahc->our_id_b;\n\t} else {\n\t\tour_id = ahc->our_id;\n\t}\n\n\tmax_scsiid = (ahc->features & AHC_WIDE) ? 15 : 7;\n\t\n\t/*\n\t * Revert to async/narrow transfers until we renegotiate.\n\t */\n\tfor (target = 0; target <= max_scsiid; target++) {\n\n\t\tif (ahc->enabled_targets[target] == NULL)\n\t\t\tcontinue;\n\t\tfor (initiator = 0; initiator <= max_scsiid; initiator++) {\n\t\t\tstruct ahc_devinfo devinfo;\n\n\t\t\tahc_compile_devinfo(&devinfo, target, initiator,\n\t\t\t\t\t    ALL_LUNS,\n\t\t\t\t\t    channel, ROLE_UNKNOWN);\n\t\t\tahc_set_width(ahc, &devinfo,\n\t\t\t\t      MSG_EXT_WDTR_BUS_8_BIT,\n\t\t\t\t      AHC_TRANS_CUR,\n\t\t\t\t      /*paused*/TRUE,\n\t\t\t\t      /*done*/FALSE);\n\t\t\tahc_set_syncrate(ahc, &devinfo,\n\t\t\t\t\t /*syncrate*/NULL, /*period*/0,\n\t\t\t\t\t /*offset*/0, AHC_TRANS_CUR,\n\t\t\t\t\t /*paused*/TRUE,\n\t\t\t\t\t /*done*/FALSE);\n\t\t}\n\t}\n\n\tif (restart_needed)\n\t\trestart_sequencer(ahc);\n\telse\n\t\tunpause_sequencer(ahc);\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahc_construct",
          "args": [
            "ahc",
            "iot",
            "ioh",
            "chip",
            "AHC_FNONE",
            "AHC_AIC7770_FE",
            "channel"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_construct_wdtr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "5565-5575",
          "snippet": "STATIC void\nahc_construct_wdtr(ahc, bus_width)\n\tstruct ahc_softc *ahc;\n\tu_int bus_width;\n{\n\tahc->msgout_buf[ahc->msgout_index++] = MSG_EXTENDED;\n\tahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_WDTR_LEN;\n\tahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_WDTR;\n\tahc->msgout_buf[ahc->msgout_index++] = bus_width;\n\tahc->msgout_len += 4;\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_construct_wdtr __P((struct ahc_softc *ahc, u_int bus_width));",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_construct_wdtr __P((struct ahc_softc *ahc, u_int bus_width));\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_construct_wdtr(ahc, bus_width)\n\tstruct ahc_softc *ahc;\n\tu_int bus_width;\n{\n\tahc->msgout_buf[ahc->msgout_index++] = MSG_EXTENDED;\n\tahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_WDTR_LEN;\n\tahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_WDTR;\n\tahc->msgout_buf[ahc->msgout_index++] = bus_width;\n\tahc->msgout_len += 4;\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"ahc_eisa_attach: Unknown device type %s\"",
            "ea->ea_idstring"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ea->ea_idstring",
            "\"ADP7771\""
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ea->ea_idstring",
            "\"ADP7770\""
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"ahc_eisa_attach: ahc_eisa_irq failed!\""
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_eisa_irq",
          "args": [
            "iot",
            "ioh"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_eisa_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/eisa/ahc_eisa.c",
          "lines": "83-112",
          "snippet": "int\nahc_eisa_irq(iot, ioh)\nbus_space_tag_t iot;\nbus_space_handle_t ioh;\n{\n\tint irq;\n\tu_char intdef;\n\tu_char hcntrl;\n\t\n\t/* Pause the card preseving the IRQ type */\n\thcntrl = bus_space_read_1(iot, ioh, HCNTRL) & IRQMS;\n\tbus_space_write_1(iot, ioh, HCNTRL, hcntrl | PAUSE);\n\t\n\tintdef = bus_space_read_1(iot, ioh, INTDEF);\n\tswitch (irq = (intdef & 0xf)) {\n\tcase 9:\n\tcase 10:\n\tcase 11:\n\tcase 12:\n\tcase 14:\n\tcase 15:\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"ahc_eisa_irq: illegal irq setting %d\\n\", intdef);\n\t\treturn -1;\n\t}\n\n\t/* Note that we are going and return (to probe) */\n\treturn irq;\n}",
          "includes": [
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <dev/eisa/eisadevs.h>",
            "#include <dev/eisa/eisavar.h>",
            "#include <dev/eisa/eisareg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"eisa.h\""
          ],
          "macros_used": [
            "#define INTDEF\t\t\t0x5cul\t/* Interrupt Definition Register */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <dev/eisa/eisadevs.h>\n#include <dev/eisa/eisavar.h>\n#include <dev/eisa/eisareg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"eisa.h\"\n\n#define INTDEF\t\t\t0x5cul\t/* Interrupt Definition Register */\n\nint\nahc_eisa_irq(iot, ioh)\nbus_space_tag_t iot;\nbus_space_handle_t ioh;\n{\n\tint irq;\n\tu_char intdef;\n\tu_char hcntrl;\n\t\n\t/* Pause the card preseving the IRQ type */\n\thcntrl = bus_space_read_1(iot, ioh, HCNTRL) & IRQMS;\n\tbus_space_write_1(iot, ioh, HCNTRL, hcntrl | PAUSE);\n\t\n\tintdef = bus_space_read_1(iot, ioh, INTDEF);\n\tswitch (irq = (intdef & 0xf)) {\n\tcase 9:\n\tcase 10:\n\tcase 11:\n\tcase 12:\n\tcase 14:\n\tcase 15:\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"ahc_eisa_irq: illegal irq setting %d\\n\", intdef);\n\t\treturn -1;\n\t}\n\n\t/* Note that we are going and return (to probe) */\n\treturn irq;\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"ahc_eisa_attach: could not map I/O addresses\""
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "iot",
            "EISA_SLOT_ADDR(ea->ea_slot) +\n\t\t\t  AHC_EISA_SLOT_OFFSET",
            "AHC_EISA_IOSIZE",
            "0",
            "&ioh"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EISA_SLOT_ADDR",
          "args": [
            "ea->ea_slot"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <dev/eisa/eisadevs.h>\n#include <dev/eisa/eisavar.h>\n#include <dev/eisa/eisareg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"eisa.h\"\n\n#define bootverbose\t1\n#define bootverbose\t1\n#define AHC_EISA_IOSIZE\t\t0x100\n#define AHC_EISA_SLOT_OFFSET\t0xc00\n\nvoid\nahc_eisa_attach(parent, self, aux)\nstruct device *parent, *self;\nvoid *aux;\n{\n\tahc_chip chip;\n\tu_char channel = 'A'; /* Only one channel */\n\tstruct ahc_softc *ahc = (void *)self;\n\tstruct eisa_attach_args *ea = aux;\n\tbus_space_tag_t iot = ea->ea_iot;\n\tbus_space_handle_t ioh;\n\tint irq;\n\teisa_chipset_tag_t ec = ea->ea_ec;\n\teisa_intr_handle_t ih;\n\tconst char *model, *intrstr;\n\tu_int biosctrl;\n\tu_int scsiconf;\n\tu_int scsiconf1;\n\t\n\tahc->sc_dmat = ea->ea_dmat;\n\tif (bus_space_map(iot, EISA_SLOT_ADDR(ea->ea_slot) +\n\t\t\t  AHC_EISA_SLOT_OFFSET, AHC_EISA_IOSIZE, 0, &ioh))\n\t\tpanic(\"ahc_eisa_attach: could not map I/O addresses\");\n\tif ((irq = ahc_eisa_irq(iot, ioh)) < 0)\n\t\tpanic(\"ahc_eisa_attach: ahc_eisa_irq failed!\");\n\n\tif (strcmp(ea->ea_idstring, \"ADP7770\") == 0) {\n\t\tmodel = EISA_PRODUCT_ADP7770;\n\t\tchip = AHC_AIC7770|AHC_EISA;\n\t} else if (strcmp(ea->ea_idstring, \"ADP7771\") == 0) {\n\t\tmodel = EISA_PRODUCT_ADP7771;\n\t\tchip = AHC_AIC7770|AHC_EISA;\n\t} else {\n\t\tpanic(\"ahc_eisa_attach: Unknown device type %s\",\n\t\t\t\tea->ea_idstring);\n\t}\n\tprintf(\": %s\\n\", model);\n\n\tahc_construct(ahc, iot, ioh, chip, AHC_FNONE, AHC_AIC7770_FE, channel);\n\t\n\tahc->channel = 'A';\n\tahc->channel_b = 'B';\n\tif (ahc_reset(ahc) != 0)\n\t\treturn;\n\t\n\tif (eisa_intr_map(ec, irq, &ih)) {\n\t\tprintf(\"%s: couldn't map interrupt (%d)\\n\",\n\t\t       ahc->sc_dev.dv_xname, irq);\n\t\treturn;\n\t}\n\n\t/*\n\t * Tell the user what type of interrupts we're using.\n\t * usefull for debugging irq problems\n\t */\n\tif (bootverbose) {\n\t\tprintf(\"%s: Using %s Interrupts\\n\",\n\t\t       ahc_name(ahc),\n\t\t       ahc->pause & IRQMS ?\n\t\t       \"Level Sensitive\" : \"Edge Triggered\");\n\t}\n\n\t/*\n\t * Now that we know we own the resources we need, do the \n\t * card initialization.\n\t *\n\t * First, the aic7770 card specific setup.\n\t */\n\tbiosctrl = ahc_inb(ahc, HA_274_BIOSCTRL);\n\tscsiconf = ahc_inb(ahc, SCSICONF);\n\tscsiconf1 = ahc_inb(ahc, SCSICONF + 1);\n\t\n\t/* Get the primary channel information */\n\tif ((biosctrl & CHANNEL_B_PRIMARY) != 0)\n\t\tahc->flags |= AHC_CHANNEL_B_PRIMARY;\n\n\tif ((biosctrl & BIOSMODE) == BIOSDISABLED) {\n\t\tahc->flags |= AHC_USEDEFAULTS;\n\t} else if ((ahc->features & AHC_WIDE) != 0) {\n\t\tahc->our_id = scsiconf1 & HWSCSIID;\n\t\tif (scsiconf & TERM_ENB)\n\t\t\tahc->flags |= AHC_TERM_ENB_A;\n\t} else {\n\t\tahc->our_id = scsiconf & HSCSIID;\n\t\tahc->our_id_b = scsiconf1 & HSCSIID;\n\t\tif (scsiconf & TERM_ENB)\n\t\t\tahc->flags |= AHC_TERM_ENB_A;\n\t\tif (scsiconf1 & TERM_ENB)\n\t\t\tahc->flags |= AHC_TERM_ENB_B;\n\t}\n\t/*\n\t * We have no way to tell, so assume extended\n\t * translation is enabled.\n\t */\n\t\n\tahc->flags |= AHC_EXTENDED_TRANS_A|AHC_EXTENDED_TRANS_B;\n\t\n\t/*      \n\t * See if we have a Rev E or higher aic7770. Anything below a\n\t * Rev E will have a R/O autoflush disable configuration bit.\n\t * It's still not clear exactly what is differenent about the Rev E.\n\t * We think it allows 8 bit entries in the QOUTFIFO to support\n\t * \"paging\" SCBs so you can have more than 4 commands active at\n\t * once.\n\t */\n\t{\n\t\tchar *id_string;\n\t\tu_char sblkctl;\n\t\tu_char sblkctl_orig;\n\n\t\tsblkctl_orig = AHC_INB(ahc, SBLKCTL);\n\t\tsblkctl = sblkctl_orig ^ AUTOFLUSHDIS;\n\t\tAHC_OUTB(ahc, SBLKCTL, sblkctl);\n\t\tsblkctl = AHC_INB(ahc, SBLKCTL);\n\t\tif (sblkctl != sblkctl_orig) {\n\t\t\tid_string = \"aic7770 >= Rev E, \";\n\t\t\t/*\n\t\t\t * Ensure autoflush is enabled\n\t\t\t */\n\t\t\tsblkctl &= ~AUTOFLUSHDIS;\n\t\t\tAHC_OUTB(ahc, SBLKCTL, sblkctl);\n\n\t\t\t/* Allow paging on this adapter */\n\t\t\tahc->flags |= AHC_PAGESCBS;\n\t\t} else\n\t\t\tid_string = \"aic7770 <= Rev C, \";\n\n\t\tprintf(\"%s: %s\", ahc_name(ahc), id_string);\n\t}\n\n\t/* Setup the FIFO threshold and the bus off time */\n\t{\n\t\tu_char hostconf = AHC_INB(ahc, HOSTCONF);\n\t\tAHC_OUTB(ahc, BUSSPD, hostconf & DFTHRSH);\n\t\tAHC_OUTB(ahc, BUSTIME, (hostconf << 2) & BOFF);\n\t}\n\n\t/*\n\t * Generic aic7xxx initialization.\n\t */\n\tif (ahc_init(ahc)) {\n\t\tahc_free(ahc);\n\t\treturn;\n\t}\n \n\t/*\n\t * Enable the board's BUS drivers\n\t */\n\tAHC_OUTB(ahc, BCTL, ENABLE);\n\n\tintrstr = eisa_intr_string(ec, ih);\n\t/*\n\t * The IRQMS bit enables level sensitive interrupts only allow\n\t * IRQ sharing if its set.\n\t */\n\tahc->sc_ih = eisa_intr_establish(ec, ih, ahc->pause & IRQMS\n\t\t\t\t\t ? IST_LEVEL : IST_EDGE,\n\t\t\t\t\t IPL_BIO, ahc_intr, ahc,\n\t\t\t\t\t ahc->sc_dev.dv_xname);\n\tif (ahc->sc_ih == NULL) {\n\t\tprintf(\"%s: couldn't establish interrupt\",\n\t\t       ahc->sc_dev.dv_xname);\n\t\tif (intrstr != NULL)\n\t\t\tprintf(\" at %s\", intrstr);\n\t\tprintf(\"\\n\");\n\t\tahc_free(ahc);\n\t\treturn;\n\t}\n\tif (intrstr != NULL)\n\t\tprintf(\"%s: interrupting at %s\\n\", ahc->sc_dev.dv_xname,\n\t\t       intrstr);\n\n\t/* Attach sub-devices - always succeeds */\n\tahc_attach(ahc);\n\n}"
  },
  {
    "function_name": "ahc_eisa_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/eisa/ahc_eisa.c",
    "lines": "119-148",
    "snippet": "int\nahc_eisa_match(parent, match, aux)\nstruct device *parent;\nvoid *match, *aux;\n{\n\tstruct eisa_attach_args *ea = aux;\n\tbus_space_tag_t iot = ea->ea_iot;\n\tbus_space_handle_t ioh;\n\tint irq;\n\n\t/* must match one of our known ID strings */\n\tif (strcmp(ea->ea_idstring, \"ADP7770\") &&\n\t\t strcmp(ea->ea_idstring, \"ADP7771\")\n#if 0\n\t\t && strcmp(ea->ea_idstring, \"ADP7756\")\t/* not EISA, but VL */\n\t\t && strcmp(ea->ea_idstring, \"ADP7757\")\t/* not EISA, but VL */\n#endif\n\t\t)\n\t\treturn (0);\n\n\tif (bus_space_map(iot, EISA_SLOT_ADDR(ea->ea_slot) +\n\t\t\t  AHC_EISA_SLOT_OFFSET, AHC_EISA_IOSIZE, 0, &ioh))\n\t\treturn (0);\n\n\tirq = ahc_eisa_irq(iot, ioh);\n\n\tbus_space_unmap(iot, ioh, AHC_EISA_IOSIZE);\n\n\treturn (irq >= 0);\n}",
    "includes": [
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <dev/eisa/eisadevs.h>",
      "#include <dev/eisa/eisavar.h>",
      "#include <dev/eisa/eisareg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"eisa.h\""
    ],
    "macros_used": [
      "#define AHC_EISA_IOSIZE\t\t0x100",
      "#define AHC_EISA_SLOT_OFFSET\t0xc00"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_unmap",
          "args": [
            "iot",
            "ioh",
            "AHC_EISA_IOSIZE"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahc_eisa_irq",
          "args": [
            "iot",
            "ioh"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_eisa_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/eisa/ahc_eisa.c",
          "lines": "83-112",
          "snippet": "int\nahc_eisa_irq(iot, ioh)\nbus_space_tag_t iot;\nbus_space_handle_t ioh;\n{\n\tint irq;\n\tu_char intdef;\n\tu_char hcntrl;\n\t\n\t/* Pause the card preseving the IRQ type */\n\thcntrl = bus_space_read_1(iot, ioh, HCNTRL) & IRQMS;\n\tbus_space_write_1(iot, ioh, HCNTRL, hcntrl | PAUSE);\n\t\n\tintdef = bus_space_read_1(iot, ioh, INTDEF);\n\tswitch (irq = (intdef & 0xf)) {\n\tcase 9:\n\tcase 10:\n\tcase 11:\n\tcase 12:\n\tcase 14:\n\tcase 15:\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"ahc_eisa_irq: illegal irq setting %d\\n\", intdef);\n\t\treturn -1;\n\t}\n\n\t/* Note that we are going and return (to probe) */\n\treturn irq;\n}",
          "includes": [
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <dev/eisa/eisadevs.h>",
            "#include <dev/eisa/eisavar.h>",
            "#include <dev/eisa/eisareg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"eisa.h\""
          ],
          "macros_used": [
            "#define INTDEF\t\t\t0x5cul\t/* Interrupt Definition Register */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <dev/eisa/eisadevs.h>\n#include <dev/eisa/eisavar.h>\n#include <dev/eisa/eisareg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"eisa.h\"\n\n#define INTDEF\t\t\t0x5cul\t/* Interrupt Definition Register */\n\nint\nahc_eisa_irq(iot, ioh)\nbus_space_tag_t iot;\nbus_space_handle_t ioh;\n{\n\tint irq;\n\tu_char intdef;\n\tu_char hcntrl;\n\t\n\t/* Pause the card preseving the IRQ type */\n\thcntrl = bus_space_read_1(iot, ioh, HCNTRL) & IRQMS;\n\tbus_space_write_1(iot, ioh, HCNTRL, hcntrl | PAUSE);\n\t\n\tintdef = bus_space_read_1(iot, ioh, INTDEF);\n\tswitch (irq = (intdef & 0xf)) {\n\tcase 9:\n\tcase 10:\n\tcase 11:\n\tcase 12:\n\tcase 14:\n\tcase 15:\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"ahc_eisa_irq: illegal irq setting %d\\n\", intdef);\n\t\treturn -1;\n\t}\n\n\t/* Note that we are going and return (to probe) */\n\treturn irq;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "iot",
            "EISA_SLOT_ADDR(ea->ea_slot) +\n\t\t\t  AHC_EISA_SLOT_OFFSET",
            "AHC_EISA_IOSIZE",
            "0",
            "&ioh"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EISA_SLOT_ADDR",
          "args": [
            "ea->ea_slot"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ea->ea_idstring",
            "\"ADP7757\""
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ea->ea_idstring",
            "\"ADP7756\""
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ea->ea_idstring",
            "\"ADP7771\""
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ea->ea_idstring",
            "\"ADP7770\""
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <dev/eisa/eisadevs.h>\n#include <dev/eisa/eisavar.h>\n#include <dev/eisa/eisareg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"eisa.h\"\n\n#define AHC_EISA_IOSIZE\t\t0x100\n#define AHC_EISA_SLOT_OFFSET\t0xc00\n\nint\nahc_eisa_match(parent, match, aux)\nstruct device *parent;\nvoid *match, *aux;\n{\n\tstruct eisa_attach_args *ea = aux;\n\tbus_space_tag_t iot = ea->ea_iot;\n\tbus_space_handle_t ioh;\n\tint irq;\n\n\t/* must match one of our known ID strings */\n\tif (strcmp(ea->ea_idstring, \"ADP7770\") &&\n\t\t strcmp(ea->ea_idstring, \"ADP7771\")\n#if 0\n\t\t && strcmp(ea->ea_idstring, \"ADP7756\")\t/* not EISA, but VL */\n\t\t && strcmp(ea->ea_idstring, \"ADP7757\")\t/* not EISA, but VL */\n#endif\n\t\t)\n\t\treturn (0);\n\n\tif (bus_space_map(iot, EISA_SLOT_ADDR(ea->ea_slot) +\n\t\t\t  AHC_EISA_SLOT_OFFSET, AHC_EISA_IOSIZE, 0, &ioh))\n\t\treturn (0);\n\n\tirq = ahc_eisa_irq(iot, ioh);\n\n\tbus_space_unmap(iot, ioh, AHC_EISA_IOSIZE);\n\n\treturn (irq >= 0);\n}"
  },
  {
    "function_name": "ahc_eisa_irq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/eisa/ahc_eisa.c",
    "lines": "83-112",
    "snippet": "int\nahc_eisa_irq(iot, ioh)\nbus_space_tag_t iot;\nbus_space_handle_t ioh;\n{\n\tint irq;\n\tu_char intdef;\n\tu_char hcntrl;\n\t\n\t/* Pause the card preseving the IRQ type */\n\thcntrl = bus_space_read_1(iot, ioh, HCNTRL) & IRQMS;\n\tbus_space_write_1(iot, ioh, HCNTRL, hcntrl | PAUSE);\n\t\n\tintdef = bus_space_read_1(iot, ioh, INTDEF);\n\tswitch (irq = (intdef & 0xf)) {\n\tcase 9:\n\tcase 10:\n\tcase 11:\n\tcase 12:\n\tcase 14:\n\tcase 15:\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"ahc_eisa_irq: illegal irq setting %d\\n\", intdef);\n\t\treturn -1;\n\t}\n\n\t/* Note that we are going and return (to probe) */\n\treturn irq;\n}",
    "includes": [
      "#include <dev/ic/aic7xxxvar.h>",
      "#include <dev/ic/aic7xxxreg.h>",
      "#include <dev/eisa/eisadevs.h>",
      "#include <dev/eisa/eisavar.h>",
      "#include <dev/eisa/eisareg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"eisa.h\""
    ],
    "macros_used": [
      "#define INTDEF\t\t\t0x5cul\t/* Interrupt Definition Register */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ahc_eisa_irq: illegal irq setting %d\\n\"",
            "intdef"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "INTDEF"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "HCNTRL",
            "hcntrl | PAUSE"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "HCNTRL"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <dev/eisa/eisadevs.h>\n#include <dev/eisa/eisavar.h>\n#include <dev/eisa/eisareg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"eisa.h\"\n\n#define INTDEF\t\t\t0x5cul\t/* Interrupt Definition Register */\n\nint\nahc_eisa_irq(iot, ioh)\nbus_space_tag_t iot;\nbus_space_handle_t ioh;\n{\n\tint irq;\n\tu_char intdef;\n\tu_char hcntrl;\n\t\n\t/* Pause the card preseving the IRQ type */\n\thcntrl = bus_space_read_1(iot, ioh, HCNTRL) & IRQMS;\n\tbus_space_write_1(iot, ioh, HCNTRL, hcntrl | PAUSE);\n\t\n\tintdef = bus_space_read_1(iot, ioh, INTDEF);\n\tswitch (irq = (intdef & 0xf)) {\n\tcase 9:\n\tcase 10:\n\tcase 11:\n\tcase 12:\n\tcase 14:\n\tcase 15:\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"ahc_eisa_irq: illegal irq setting %d\\n\", intdef);\n\t\treturn -1;\n\t}\n\n\t/* Note that we are going and return (to probe) */\n\treturn irq;\n}"
  }
]