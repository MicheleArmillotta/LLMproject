[
  {
    "function_name": "ev_select",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/event.c",
    "lines": "148-173",
    "snippet": "int\nev_select(ev, rw, p)\n\tregister struct evvar *ev;\n\tint rw;\n\tstruct proc *p;\n{\n\tint s = splev();\n\n\tswitch (rw) {\n\n\tcase FREAD:\n\t\t/* succeed if there is something to read */\n\t\tif (ev->ev_get != ev->ev_put) {\n\t\t\tsplx(s);\n\t\t\treturn (1);\n\t\t}\n\t\tselrecord(p, &ev->ev_sel);\n\t\tbreak;\n\n\tcase FWRITE:\n\t\tsplx(s);\n\t\treturn (1);\t/* always fails => never blocks */\n\t}\n\tsplx(s);\n\treturn (0);\n}",
    "includes": [
      "#include <dev/sun/event_var.h>",
      "#include <machine/vuid_event.h>",
      "#include <sys/vnode.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "selrecord",
          "args": [
            "p",
            "&ev->ev_sel"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splev",
          "args": [],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/sun/event_var.h>\n#include <machine/vuid_event.h>\n#include <sys/vnode.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/param.h>\n\nint\nev_select(ev, rw, p)\n\tregister struct evvar *ev;\n\tint rw;\n\tstruct proc *p;\n{\n\tint s = splev();\n\n\tswitch (rw) {\n\n\tcase FREAD:\n\t\t/* succeed if there is something to read */\n\t\tif (ev->ev_get != ev->ev_put) {\n\t\t\tsplx(s);\n\t\t\treturn (1);\n\t\t}\n\t\tselrecord(p, &ev->ev_sel);\n\t\tbreak;\n\n\tcase FWRITE:\n\t\tsplx(s);\n\t\treturn (1);\t/* always fails => never blocks */\n\t}\n\tsplx(s);\n\treturn (0);\n}"
  },
  {
    "function_name": "ev_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/event.c",
    "lines": "91-146",
    "snippet": "int\nev_read(ev, uio, flags)\n\tregister struct evvar *ev;\n\tstruct uio *uio;\n\tint flags;\n{\n\tint s, n, cnt, error;\n\n\t/*\n\t * Make sure we can return at least 1.\n\t */\n\tif (uio->uio_resid < sizeof(struct firm_event))\n\t\treturn (EMSGSIZE);\t/* ??? */\n\ts = splev();\n\twhile (ev->ev_get == ev->ev_put) {\n\t\tif (flags & IO_NDELAY) {\n\t\t\tsplx(s);\n\t\t\treturn (EWOULDBLOCK);\n\t\t}\n\t\tev->ev_wanted = 1;\n\t\terror = tsleep((caddr_t)ev, PEVENT | PCATCH, \"firm_event\", 0);\n\t\tif (error) {\n\t\t\tsplx(s);\n\t\t\treturn (error);\n\t\t}\n\t}\n\t/*\n\t * Move firm_events from tail end of queue (there is at least one\n\t * there).\n\t */\n\tif (ev->ev_put < ev->ev_get)\n\t\tcnt = EV_QSIZE - ev->ev_get;\t/* events in [get..QSIZE) */\n\telse\n\t\tcnt = ev->ev_put - ev->ev_get;\t/* events in [get..put) */\n\tsplx(s);\n\tn = howmany(uio->uio_resid, sizeof(struct firm_event));\n\tif (cnt > n)\n\t\tcnt = n;\n\terror = uiomove((caddr_t)&ev->ev_q[ev->ev_get],\n\t    cnt * sizeof(struct firm_event), uio);\n\tn -= cnt;\n\t/*\n\t * If we do not wrap to 0, used up all our space, or had an error,\n\t * stop.  Otherwise move from front of queue to put index, if there\n\t * is anything there to move.\n\t */\n\tif ((ev->ev_get = (ev->ev_get + cnt) % EV_QSIZE) != 0 ||\n\t    n == 0 || error || (cnt = ev->ev_put) == 0)\n\t\treturn (error);\n\tif (cnt > n)\n\t\tcnt = n;\n\terror = uiomove((caddr_t)&ev->ev_q[0],\n\t    cnt * sizeof(struct firm_event), uio);\n\tev->ev_get = cnt;\n\treturn (error);\n}",
    "includes": [
      "#include <dev/sun/event_var.h>",
      "#include <machine/vuid_event.h>",
      "#include <sys/vnode.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "uiomove",
          "args": [
            "(caddr_t)&ev->ev_q[0]",
            "cnt * sizeof(struct firm_event)",
            "uio"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uiomove",
          "args": [
            "(caddr_t)&ev->ev_q[ev->ev_get]",
            "cnt * sizeof(struct firm_event)",
            "uio"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "howmany",
          "args": [
            "uio->uio_resid",
            "sizeof(struct firm_event)"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tsleep",
          "args": [
            "(caddr_t)ev",
            "PEVENT | PCATCH",
            "\"firm_event\"",
            "0"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splev",
          "args": [],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/sun/event_var.h>\n#include <machine/vuid_event.h>\n#include <sys/vnode.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/param.h>\n\nint\nev_read(ev, uio, flags)\n\tregister struct evvar *ev;\n\tstruct uio *uio;\n\tint flags;\n{\n\tint s, n, cnt, error;\n\n\t/*\n\t * Make sure we can return at least 1.\n\t */\n\tif (uio->uio_resid < sizeof(struct firm_event))\n\t\treturn (EMSGSIZE);\t/* ??? */\n\ts = splev();\n\twhile (ev->ev_get == ev->ev_put) {\n\t\tif (flags & IO_NDELAY) {\n\t\t\tsplx(s);\n\t\t\treturn (EWOULDBLOCK);\n\t\t}\n\t\tev->ev_wanted = 1;\n\t\terror = tsleep((caddr_t)ev, PEVENT | PCATCH, \"firm_event\", 0);\n\t\tif (error) {\n\t\t\tsplx(s);\n\t\t\treturn (error);\n\t\t}\n\t}\n\t/*\n\t * Move firm_events from tail end of queue (there is at least one\n\t * there).\n\t */\n\tif (ev->ev_put < ev->ev_get)\n\t\tcnt = EV_QSIZE - ev->ev_get;\t/* events in [get..QSIZE) */\n\telse\n\t\tcnt = ev->ev_put - ev->ev_get;\t/* events in [get..put) */\n\tsplx(s);\n\tn = howmany(uio->uio_resid, sizeof(struct firm_event));\n\tif (cnt > n)\n\t\tcnt = n;\n\terror = uiomove((caddr_t)&ev->ev_q[ev->ev_get],\n\t    cnt * sizeof(struct firm_event), uio);\n\tn -= cnt;\n\t/*\n\t * If we do not wrap to 0, used up all our space, or had an error,\n\t * stop.  Otherwise move from front of queue to put index, if there\n\t * is anything there to move.\n\t */\n\tif ((ev->ev_get = (ev->ev_get + cnt) % EV_QSIZE) != 0 ||\n\t    n == 0 || error || (cnt = ev->ev_put) == 0)\n\t\treturn (error);\n\tif (cnt > n)\n\t\tcnt = n;\n\terror = uiomove((caddr_t)&ev->ev_q[0],\n\t    cnt * sizeof(struct firm_event), uio);\n\tev->ev_get = cnt;\n\treturn (error);\n}"
  },
  {
    "function_name": "ev_fini",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/event.c",
    "lines": "79-85",
    "snippet": "void\nev_fini(ev)\n\tregister struct evvar *ev;\n{\n\n\tfree(ev->ev_q, M_DEVBUF);\n}",
    "includes": [
      "#include <dev/sun/event_var.h>",
      "#include <machine/vuid_event.h>",
      "#include <sys/vnode.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ev->ev_q",
            "M_DEVBUF"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "epic_freebsd_attach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tx.c",
          "lines": "437-614",
          "snippet": "void\nepic_freebsd_attach(\n    pcici_t config_id,\n    int unit)\n{\n\tstruct ifnet *ifp;\n\tepic_softc_t *sc;\n#if defined(EPIC_USEIOSPACE)\n\tu_int32_t iobase;\n#else\n\tcaddr_t\tpmembase;\n#endif\n\tu_int32_t command;\n\tint i,s,tmp;\n\n\tprintf(\"tx%d\",unit);\n\n\t/* Allocate memory for softc, hardware descriptors and frag lists */\n\tsc = (epic_softc_t *) malloc( sizeof(epic_softc_t), M_DEVBUF, M_NOWAIT);\n\tif (sc == NULL)\treturn;\n\n\t/* Preinitialize softc structure */\n    \tbzero(sc, sizeof(epic_softc_t));\t\t\n\tsc->unit = unit;\n\n\t/* Fill ifnet structure */\n\tifp = &sc->sc_if;\n\tifp->if_unit = unit;\n\tifp->if_name = \"tx\";\n\tifp->if_softc = sc;\n\tifp->if_flags = IFF_BROADCAST|IFF_SIMPLEX|IFF_MULTICAST;\n\tifp->if_ioctl = epic_ifioctl;\n\tifp->if_start = epic_ifstart;\n\tifp->if_watchdog = epic_ifwatchdog;\n\tifp->if_init = (if_init_f_t*)epic_init;\n\tifp->if_timer = 0;\n\tifp->if_output = ether_output;\n\tifp->if_snd.ifq_maxlen = TX_RING_SIZE;\n\n\t/* Get iobase or membase */\n#if defined(EPIC_USEIOSPACE)\n\tcommand = PCI_CONF_READ(PCI_CFCS);\n\tcommand |= PCI_CFCS_IOEN;\n\tPCI_CONF_WRITE(PCI_CFCS, command);\n\tcommand = PCI_CONF_READ(PCI_CFCS);\n\n\tif (!(command & PCI_CFCS_IOEN)) {\n\t\tprintf(\": failed to enable memory mapping!\\n\");\n\t\tfree(sc, M_DEVBUF);\n\t\treturn;\n\t}\n\n\tif (!pci_map_port(config_id, PCI_CBIO,(u_short *) &(sc->iobase))) {\n\t\tprintf(\": cannot map port\\n\");\n\t\tfree(sc, M_DEVBUF);\n\t\treturn;\n\t}\n#else\n\tcommand = PCI_CONF_READ(PCI_CFCS);\n\tcommand |= PCI_CFCS_MAEN;\n\tPCI_CONF_WRITE(PCI_CFCS, command);\n\tcommand = PCI_CONF_READ(PCI_CFCS);\n\n\tif (!(command & PCI_CFCS_MAEN)) {\n\t\tprintf(\": failed to enable memory mapping!\\n\");\n\t\tfree(sc, M_DEVBUF);\n\t\treturn;\n\t}\n\n\tif (!pci_map_mem(config_id, PCI_CBMA,(vm_offset_t *) &(sc->csr),(vm_offset_t *) &pmembase)) {\n\t\tprintf(\": cannot map memory\\n\"); \n\t\tfree(sc, M_DEVBUF);\n\t\treturn;\n\t}\n#endif\n\n\t/* Do OS independent part, including chip wakeup and reset */\n\tif( epic_common_attach(sc) ) return;\n\n\tcommand = PCI_CONF_READ(PCI_CFCS);\n\tcommand |= PCI_CFCS_BMEN;\n\tPCI_CONF_WRITE(PCI_CFCS, command);\n\n\t/* Display ethernet address ,... */\n\tprintf(\": address %02x:%02x:%02x:%02x:%02x:%02x,\",\n\t\tsc->sc_macaddr[0],sc->sc_macaddr[1],sc->sc_macaddr[2],\n\t\tsc->sc_macaddr[3],sc->sc_macaddr[4],sc->sc_macaddr[5]);\n\n\t/* board type and ... */\n\tprintf(\" type \");\n\tfor(i=0x2c;i<0x32;i++) {\n\t\ttmp = epic_read_eeprom( sc, i );\n\t\tif( ' ' == (u_int8_t)tmp ) break;\n\t\tprintf(\"%c\",(u_int8_t)tmp);\n\t\ttmp >>= 8;\n\t\tif( ' ' == (u_int8_t)tmp ) break;\n\t\tprintf(\"%c\",(u_int8_t)tmp);\n\t}\n\n\t/* Read current media config and display it too */\n\ti = PHY_READ_2( sc, DP83840_BMCR );\n#if !defined(EPIC_NOIFMEDIA)\n\ttmp = IFM_ETHER;\n#endif\n\tif( i & BMCR_AUTONEGOTIATION ){\n\t\tprintf(\", Auto-Neg \");\n\n\t\t/* To avoid bug in QS6612 read LPAR enstead of BMSR */\n\t\ti = PHY_READ_2( sc, DP83840_LPAR );\n\t\tif( i & (ANAR_100_TX|ANAR_100_TX_FD) ) printf(\"100Mbps \");\n\t\telse printf(\"10Mbps \");\n\t\tif( i & (ANAR_10_FD|ANAR_100_TX_FD) ) printf(\"FD\");\n#if !defined(EPIC_NOIFMEDIA)\n\t\ttmp |= IFM_AUTO;\n#endif\n\t} else {\n#if defined(EPIC_NOIFMEDIA)\n\t\tifp->if_flags |= IFF_LINK0;\n#endif\n\t\tif( i & BMCR_100MBPS ) {\n\t\t\tprintf(\", 100Mbps \");\n#if !defined(EPIC_NOIFMEDIA)\n\t\t\ttmp |= IFM_100_TX;\n#else\n\t\t\tifp->if_flags |= IFF_LINK2;\n#endif\n\t\t} else {\n\t\t\tprintf(\", 10Mbps \");\n#if !defined(EPIC_NOIFMEDIA)\n\t\t\ttmp |= IFM_10_T;\n#endif\n\t\t}\n\t\tif( i & BMCR_FULL_DUPLEX ) {\n\t\t\tprintf(\"FD\");\n#if !defined(EPIC_NOIFMEDIA)\n\t\t\ttmp |= IFM_FDX;\n#else\n\t\t\tifp->if_flags |= IFF_LINK1;\n#endif\n\t\t}\n\t}\n\n\t/* Init ifmedia interface */\n#if !defined(EPIC_NOIFMEDIA)\n\tifmedia_init(&sc->ifmedia,0,epic_ifmedia_change,epic_ifmedia_status);\n\n\tfor (i=0; i<EPIC_MTYPESNUM; i++)\n\t\tifmedia_add(&sc->ifmedia,epic_mtypes[i],0,NULL);\n\n\tifmedia_set(&sc->ifmedia, tmp);\n#endif\n\n\ts = splimp();\n\n\t/* Map interrupt */\n\tif( !pci_map_int(config_id, epic_intr, (void*)sc, &net_imask) ) {\n\t\tprintf(\": couldn't map interrupt\\n\");\n\t\tfree(sc, M_DEVBUF);\n\t\treturn;\n\t}\n\n\t/* Set shut down routine to stop DMA processes on reboot */\n\tat_shutdown(epic_shutdown, sc, SHUTDOWN_POST_SYNC);\n\n\t/*  Attach to if manager */\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n\n#if NBPFILTER > 0\n\tbpfattach(ifp,DLT_EN10MB, sizeof(struct ether_header));\n#endif\n\n\tsplx(s);\n\n\tprintf(\"\\n\");\n\n\treturn;\n}",
          "includes": [
            "#include <pci/if_txvar.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_mib.h>",
            "#include <dev/pci/if_txvar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/sockio.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define\tEPIC_MTYPESNUM (sizeof(epic_mtypes) / sizeof(epic_mtypes[0]))",
            "#define EPIC_NOIFMEDIA\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_txvar.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_mib.h>\n#include <dev/pci/if_txvar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sockio.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bpfilter.h\"\n\n#define\tEPIC_MTYPESNUM (sizeof(epic_mtypes) / sizeof(epic_mtypes[0]))\n#define EPIC_NOIFMEDIA\t1\n\nvoid\nepic_freebsd_attach(\n    pcici_t config_id,\n    int unit)\n{\n\tstruct ifnet *ifp;\n\tepic_softc_t *sc;\n#if defined(EPIC_USEIOSPACE)\n\tu_int32_t iobase;\n#else\n\tcaddr_t\tpmembase;\n#endif\n\tu_int32_t command;\n\tint i,s,tmp;\n\n\tprintf(\"tx%d\",unit);\n\n\t/* Allocate memory for softc, hardware descriptors and frag lists */\n\tsc = (epic_softc_t *) malloc( sizeof(epic_softc_t), M_DEVBUF, M_NOWAIT);\n\tif (sc == NULL)\treturn;\n\n\t/* Preinitialize softc structure */\n    \tbzero(sc, sizeof(epic_softc_t));\t\t\n\tsc->unit = unit;\n\n\t/* Fill ifnet structure */\n\tifp = &sc->sc_if;\n\tifp->if_unit = unit;\n\tifp->if_name = \"tx\";\n\tifp->if_softc = sc;\n\tifp->if_flags = IFF_BROADCAST|IFF_SIMPLEX|IFF_MULTICAST;\n\tifp->if_ioctl = epic_ifioctl;\n\tifp->if_start = epic_ifstart;\n\tifp->if_watchdog = epic_ifwatchdog;\n\tifp->if_init = (if_init_f_t*)epic_init;\n\tifp->if_timer = 0;\n\tifp->if_output = ether_output;\n\tifp->if_snd.ifq_maxlen = TX_RING_SIZE;\n\n\t/* Get iobase or membase */\n#if defined(EPIC_USEIOSPACE)\n\tcommand = PCI_CONF_READ(PCI_CFCS);\n\tcommand |= PCI_CFCS_IOEN;\n\tPCI_CONF_WRITE(PCI_CFCS, command);\n\tcommand = PCI_CONF_READ(PCI_CFCS);\n\n\tif (!(command & PCI_CFCS_IOEN)) {\n\t\tprintf(\": failed to enable memory mapping!\\n\");\n\t\tfree(sc, M_DEVBUF);\n\t\treturn;\n\t}\n\n\tif (!pci_map_port(config_id, PCI_CBIO,(u_short *) &(sc->iobase))) {\n\t\tprintf(\": cannot map port\\n\");\n\t\tfree(sc, M_DEVBUF);\n\t\treturn;\n\t}\n#else\n\tcommand = PCI_CONF_READ(PCI_CFCS);\n\tcommand |= PCI_CFCS_MAEN;\n\tPCI_CONF_WRITE(PCI_CFCS, command);\n\tcommand = PCI_CONF_READ(PCI_CFCS);\n\n\tif (!(command & PCI_CFCS_MAEN)) {\n\t\tprintf(\": failed to enable memory mapping!\\n\");\n\t\tfree(sc, M_DEVBUF);\n\t\treturn;\n\t}\n\n\tif (!pci_map_mem(config_id, PCI_CBMA,(vm_offset_t *) &(sc->csr),(vm_offset_t *) &pmembase)) {\n\t\tprintf(\": cannot map memory\\n\"); \n\t\tfree(sc, M_DEVBUF);\n\t\treturn;\n\t}\n#endif\n\n\t/* Do OS independent part, including chip wakeup and reset */\n\tif( epic_common_attach(sc) ) return;\n\n\tcommand = PCI_CONF_READ(PCI_CFCS);\n\tcommand |= PCI_CFCS_BMEN;\n\tPCI_CONF_WRITE(PCI_CFCS, command);\n\n\t/* Display ethernet address ,... */\n\tprintf(\": address %02x:%02x:%02x:%02x:%02x:%02x,\",\n\t\tsc->sc_macaddr[0],sc->sc_macaddr[1],sc->sc_macaddr[2],\n\t\tsc->sc_macaddr[3],sc->sc_macaddr[4],sc->sc_macaddr[5]);\n\n\t/* board type and ... */\n\tprintf(\" type \");\n\tfor(i=0x2c;i<0x32;i++) {\n\t\ttmp = epic_read_eeprom( sc, i );\n\t\tif( ' ' == (u_int8_t)tmp ) break;\n\t\tprintf(\"%c\",(u_int8_t)tmp);\n\t\ttmp >>= 8;\n\t\tif( ' ' == (u_int8_t)tmp ) break;\n\t\tprintf(\"%c\",(u_int8_t)tmp);\n\t}\n\n\t/* Read current media config and display it too */\n\ti = PHY_READ_2( sc, DP83840_BMCR );\n#if !defined(EPIC_NOIFMEDIA)\n\ttmp = IFM_ETHER;\n#endif\n\tif( i & BMCR_AUTONEGOTIATION ){\n\t\tprintf(\", Auto-Neg \");\n\n\t\t/* To avoid bug in QS6612 read LPAR enstead of BMSR */\n\t\ti = PHY_READ_2( sc, DP83840_LPAR );\n\t\tif( i & (ANAR_100_TX|ANAR_100_TX_FD) ) printf(\"100Mbps \");\n\t\telse printf(\"10Mbps \");\n\t\tif( i & (ANAR_10_FD|ANAR_100_TX_FD) ) printf(\"FD\");\n#if !defined(EPIC_NOIFMEDIA)\n\t\ttmp |= IFM_AUTO;\n#endif\n\t} else {\n#if defined(EPIC_NOIFMEDIA)\n\t\tifp->if_flags |= IFF_LINK0;\n#endif\n\t\tif( i & BMCR_100MBPS ) {\n\t\t\tprintf(\", 100Mbps \");\n#if !defined(EPIC_NOIFMEDIA)\n\t\t\ttmp |= IFM_100_TX;\n#else\n\t\t\tifp->if_flags |= IFF_LINK2;\n#endif\n\t\t} else {\n\t\t\tprintf(\", 10Mbps \");\n#if !defined(EPIC_NOIFMEDIA)\n\t\t\ttmp |= IFM_10_T;\n#endif\n\t\t}\n\t\tif( i & BMCR_FULL_DUPLEX ) {\n\t\t\tprintf(\"FD\");\n#if !defined(EPIC_NOIFMEDIA)\n\t\t\ttmp |= IFM_FDX;\n#else\n\t\t\tifp->if_flags |= IFF_LINK1;\n#endif\n\t\t}\n\t}\n\n\t/* Init ifmedia interface */\n#if !defined(EPIC_NOIFMEDIA)\n\tifmedia_init(&sc->ifmedia,0,epic_ifmedia_change,epic_ifmedia_status);\n\n\tfor (i=0; i<EPIC_MTYPESNUM; i++)\n\t\tifmedia_add(&sc->ifmedia,epic_mtypes[i],0,NULL);\n\n\tifmedia_set(&sc->ifmedia, tmp);\n#endif\n\n\ts = splimp();\n\n\t/* Map interrupt */\n\tif( !pci_map_int(config_id, epic_intr, (void*)sc, &net_imask) ) {\n\t\tprintf(\": couldn't map interrupt\\n\");\n\t\tfree(sc, M_DEVBUF);\n\t\treturn;\n\t}\n\n\t/* Set shut down routine to stop DMA processes on reboot */\n\tat_shutdown(epic_shutdown, sc, SHUTDOWN_POST_SYNC);\n\n\t/*  Attach to if manager */\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n\n#if NBPFILTER > 0\n\tbpfattach(ifp,DLT_EN10MB, sizeof(struct ether_header));\n#endif\n\n\tsplx(s);\n\n\tprintf(\"\\n\");\n\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/sun/event_var.h>\n#include <machine/vuid_event.h>\n#include <sys/vnode.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/param.h>\n\nvoid\nev_fini(ev)\n\tregister struct evvar *ev;\n{\n\n\tfree(ev->ev_q, M_DEVBUF);\n}"
  },
  {
    "function_name": "ev_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/event.c",
    "lines": "65-74",
    "snippet": "void\nev_init(ev)\n\tregister struct evvar *ev;\n{\n\n\tev->ev_get = ev->ev_put = 0;\n\tev->ev_q = malloc((u_long)EV_QSIZE * sizeof(struct firm_event),\n\t    M_DEVBUF, M_WAITOK);\n\tbzero((caddr_t)ev->ev_q, EV_QSIZE * sizeof(struct firm_event));\n}",
    "includes": [
      "#include <dev/sun/event_var.h>",
      "#include <machine/vuid_event.h>",
      "#include <sys/vnode.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(caddr_t)ev->ev_q",
            "EV_QSIZE * sizeof(struct firm_event)"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "(u_long)EV_QSIZE * sizeof(struct firm_event)",
            "M_DEVBUF",
            "M_WAITOK"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/sun/event_var.h>\n#include <machine/vuid_event.h>\n#include <sys/vnode.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/param.h>\n\nvoid\nev_init(ev)\n\tregister struct evvar *ev;\n{\n\n\tev->ev_get = ev->ev_put = 0;\n\tev->ev_q = malloc((u_long)EV_QSIZE * sizeof(struct firm_event),\n\t    M_DEVBUF, M_WAITOK);\n\tbzero((caddr_t)ev->ev_q, EV_QSIZE * sizeof(struct firm_event));\n}"
  }
]