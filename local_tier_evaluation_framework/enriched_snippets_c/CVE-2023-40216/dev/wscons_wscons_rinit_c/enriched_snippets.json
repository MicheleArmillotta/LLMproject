[
  {
    "function_name": "rcons_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wscons_rinit.c",
    "lines": "99-136",
    "snippet": "void\nrcons_init(rc, mrow, mcol)\n\tstruct rcons *rc;\n\tint mrow, mcol;\n{\n\tstruct raster *rp = rc->rc_sp;\n\tint i;\n\n\trcons_initfont(rc, &gallant19);\n\n\ti = rp->height / rc->rc_font->height;\n\trc->rc_maxrow = min(i, mrow);\n\n\ti = rp->width / rc->rc_font->width;\n\trc->rc_maxcol = min(i, mcol);\n\n\t/* Center emulator screen (but align x origin to 32 bits) */\n\trc->rc_xorigin =\n\t    ((rp->width - rc->rc_maxcol * rc->rc_font->width) / 2) & ~0x1f;\n\trc->rc_yorigin =\n\t    (rp->height - rc->rc_maxrow * rc->rc_font->height) / 2;\n\n\t/* Raster width used for row copies */\n\trc->rc_raswidth = rc->rc_maxcol * rc->rc_font->width;\n\tif (rc->rc_raswidth & 0x1f) {\n\t\t/* Pad to 32 bits */\n\t\ti = (rc->rc_raswidth + 0x1f) & ~0x1f;\n\t\t/* Make sure width isn't too wide */\n\t\tif (rc->rc_xorigin + i <= rp->width)\n\t\t\trc->rc_raswidth = i;\n\t}\n\n\trc->rc_bits = 0;\n\n\t/* If cursor position given, assume it's there and drawn. */\n\tif (*rc->rc_crowp != -1 && *rc->rc_ccolp != -1)\n\t\trc->rc_bits |= RC_CURSOR;\n}",
    "includes": [
      "#include <dev/wscons/wscons_rfont.h>",
      "#include <dev/wscons/wscons_raster.h>",
      "#include <dev/rcons/raster.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\trcons_initfont"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "min",
          "args": [
            "i",
            "mcol"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "seq_do_timing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sequencer.c",
          "lines": "804-819",
          "snippet": "int\nseq_do_timing(sc, b)\n\tstruct sequencer_softc *sc;\n\tseq_event_rec *b;\n{\n\tunion {\n\t\tint32_t i;\n\t\tu_int8_t b[4];\n\t} u;\n\n\tu.b[0] = b->arr[4];\n\tu.b[1] = b->arr[5];\n\tu.b[2] = b->arr[6];\n\tu.b[3] = b->arr[7];\n\treturn (seq_timer(sc, SEQ_TCMD(b), u.i, b));\n}",
          "includes": [
            "#include \"midi.h\"",
            "#include <dev/sequencervar.h>",
            "#include <dev/midivar.h>",
            "#include <dev/midi_if.h>",
            "#include <sys/device.h>",
            "#include <sys/midiio.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"sequencer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"midi.h\"\n#include <dev/sequencervar.h>\n#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n\nint\nseq_do_timing(sc, b)\n\tstruct sequencer_softc *sc;\n\tseq_event_rec *b;\n{\n\tunion {\n\t\tint32_t i;\n\t\tu_int8_t b[4];\n\t} u;\n\n\tu.b[0] = b->arr[4];\n\tu.b[1] = b->arr[5];\n\tu.b[2] = b->arr[6];\n\tu.b[3] = b->arr[7];\n\treturn (seq_timer(sc, SEQ_TCMD(b), u.i, b));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcons_initfont",
          "args": [
            "rc",
            "&gallant19"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "rcons_initfont",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wscons_rinit.c",
          "lines": "59-97",
          "snippet": "void\nrcons_initfont(rc, fp)\n\tstruct rcons *rc;\n\tstruct raster_font *fp;\n{\n\tstatic int initfontdone;\n\n\trc->rc_font = fp;\n\n\t/* Get distance to top and bottom of font from font origin */\n\trc->rc_font_ascent = -(rc->rc_font->chars)['a'].homey;\n\n#if !defined(MSBYTE_FIRST) && !defined(MSBIT_FIRST) /* XXX other cases */\n\t/* swap byte order on font data.  ick. */\n\tif (!initfontdone) {\n\t\tint ch, i, n, bit;\n\t\tu_int32_t *pix, npix;\n\n\t\tfor (ch = 0; ch < 256; ch++) {\n\t\t\tif (rc->rc_font->chars[ch].r == 0)\n\t\t\t\tcontinue;\n\n\t\t\tn = rc->rc_font->chars[ch].r->linelongs *\n\t\t\t    rc->rc_font->chars[ch].r->height;\n\t\t\tpix = rc->rc_font->chars[ch].r->pixels;\n\n\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\tnpix = 0;\n\t\t\t\tfor (bit = 0; bit < 32; bit++)\n\t\t\t\t\tif (pix[i] & (1 << bit))\n\t\t\t\t\t\tnpix |= (1 << (31 - bit));\n\t\t\t\tpix[i] = npix;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tinitfontdone = 1;\n}",
          "includes": [
            "#include <dev/wscons/wscons_rfont.h>",
            "#include <dev/wscons/wscons_raster.h>",
            "#include <dev/rcons/raster.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\trcons_initfont"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wscons_rfont.h>\n#include <dev/wscons/wscons_raster.h>\n#include <dev/rcons/raster.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\trcons_initfont;\n\nvoid\nrcons_initfont(rc, fp)\n\tstruct rcons *rc;\n\tstruct raster_font *fp;\n{\n\tstatic int initfontdone;\n\n\trc->rc_font = fp;\n\n\t/* Get distance to top and bottom of font from font origin */\n\trc->rc_font_ascent = -(rc->rc_font->chars)['a'].homey;\n\n#if !defined(MSBYTE_FIRST) && !defined(MSBIT_FIRST) /* XXX other cases */\n\t/* swap byte order on font data.  ick. */\n\tif (!initfontdone) {\n\t\tint ch, i, n, bit;\n\t\tu_int32_t *pix, npix;\n\n\t\tfor (ch = 0; ch < 256; ch++) {\n\t\t\tif (rc->rc_font->chars[ch].r == 0)\n\t\t\t\tcontinue;\n\n\t\t\tn = rc->rc_font->chars[ch].r->linelongs *\n\t\t\t    rc->rc_font->chars[ch].r->height;\n\t\t\tpix = rc->rc_font->chars[ch].r->pixels;\n\n\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\tnpix = 0;\n\t\t\t\tfor (bit = 0; bit < 32; bit++)\n\t\t\t\t\tif (pix[i] & (1 << bit))\n\t\t\t\t\t\tnpix |= (1 << (31 - bit));\n\t\t\t\tpix[i] = npix;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tinitfontdone = 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wscons_rfont.h>\n#include <dev/wscons/wscons_raster.h>\n#include <dev/rcons/raster.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\trcons_initfont;\n\nvoid\nrcons_init(rc, mrow, mcol)\n\tstruct rcons *rc;\n\tint mrow, mcol;\n{\n\tstruct raster *rp = rc->rc_sp;\n\tint i;\n\n\trcons_initfont(rc, &gallant19);\n\n\ti = rp->height / rc->rc_font->height;\n\trc->rc_maxrow = min(i, mrow);\n\n\ti = rp->width / rc->rc_font->width;\n\trc->rc_maxcol = min(i, mcol);\n\n\t/* Center emulator screen (but align x origin to 32 bits) */\n\trc->rc_xorigin =\n\t    ((rp->width - rc->rc_maxcol * rc->rc_font->width) / 2) & ~0x1f;\n\trc->rc_yorigin =\n\t    (rp->height - rc->rc_maxrow * rc->rc_font->height) / 2;\n\n\t/* Raster width used for row copies */\n\trc->rc_raswidth = rc->rc_maxcol * rc->rc_font->width;\n\tif (rc->rc_raswidth & 0x1f) {\n\t\t/* Pad to 32 bits */\n\t\ti = (rc->rc_raswidth + 0x1f) & ~0x1f;\n\t\t/* Make sure width isn't too wide */\n\t\tif (rc->rc_xorigin + i <= rp->width)\n\t\t\trc->rc_raswidth = i;\n\t}\n\n\trc->rc_bits = 0;\n\n\t/* If cursor position given, assume it's there and drawn. */\n\tif (*rc->rc_crowp != -1 && *rc->rc_ccolp != -1)\n\t\trc->rc_bits |= RC_CURSOR;\n}"
  },
  {
    "function_name": "rcons_initfont",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wscons_rinit.c",
    "lines": "59-97",
    "snippet": "void\nrcons_initfont(rc, fp)\n\tstruct rcons *rc;\n\tstruct raster_font *fp;\n{\n\tstatic int initfontdone;\n\n\trc->rc_font = fp;\n\n\t/* Get distance to top and bottom of font from font origin */\n\trc->rc_font_ascent = -(rc->rc_font->chars)['a'].homey;\n\n#if !defined(MSBYTE_FIRST) && !defined(MSBIT_FIRST) /* XXX other cases */\n\t/* swap byte order on font data.  ick. */\n\tif (!initfontdone) {\n\t\tint ch, i, n, bit;\n\t\tu_int32_t *pix, npix;\n\n\t\tfor (ch = 0; ch < 256; ch++) {\n\t\t\tif (rc->rc_font->chars[ch].r == 0)\n\t\t\t\tcontinue;\n\n\t\t\tn = rc->rc_font->chars[ch].r->linelongs *\n\t\t\t    rc->rc_font->chars[ch].r->height;\n\t\t\tpix = rc->rc_font->chars[ch].r->pixels;\n\n\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\tnpix = 0;\n\t\t\t\tfor (bit = 0; bit < 32; bit++)\n\t\t\t\t\tif (pix[i] & (1 << bit))\n\t\t\t\t\t\tnpix |= (1 << (31 - bit));\n\t\t\t\tpix[i] = npix;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tinitfontdone = 1;\n}",
    "includes": [
      "#include <dev/wscons/wscons_rfont.h>",
      "#include <dev/wscons/wscons_raster.h>",
      "#include <dev/rcons/raster.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\trcons_initfont"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/wscons/wscons_rfont.h>\n#include <dev/wscons/wscons_raster.h>\n#include <dev/rcons/raster.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\trcons_initfont;\n\nvoid\nrcons_initfont(rc, fp)\n\tstruct rcons *rc;\n\tstruct raster_font *fp;\n{\n\tstatic int initfontdone;\n\n\trc->rc_font = fp;\n\n\t/* Get distance to top and bottom of font from font origin */\n\trc->rc_font_ascent = -(rc->rc_font->chars)['a'].homey;\n\n#if !defined(MSBYTE_FIRST) && !defined(MSBIT_FIRST) /* XXX other cases */\n\t/* swap byte order on font data.  ick. */\n\tif (!initfontdone) {\n\t\tint ch, i, n, bit;\n\t\tu_int32_t *pix, npix;\n\n\t\tfor (ch = 0; ch < 256; ch++) {\n\t\t\tif (rc->rc_font->chars[ch].r == 0)\n\t\t\t\tcontinue;\n\n\t\t\tn = rc->rc_font->chars[ch].r->linelongs *\n\t\t\t    rc->rc_font->chars[ch].r->height;\n\t\t\tpix = rc->rc_font->chars[ch].r->pixels;\n\n\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\tnpix = 0;\n\t\t\t\tfor (bit = 0; bit < 32; bit++)\n\t\t\t\t\tif (pix[i] & (1 << bit))\n\t\t\t\t\t\tnpix |= (1 << (31 - bit));\n\t\t\t\tpix[i] = npix;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tinitfontdone = 1;\n}"
  }
]