[
  {
    "function_name": "madattach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wss.c",
    "lines": "424-462",
    "snippet": "void\nmadattach(sc)\n    struct wss_softc *sc;\n{\n    unsigned char cs4231_mode;\n    int joy;\n\n    if (sc->mad_chip_type == MAD_NONE)\n        return;\n\n    /* Do we want the joystick disabled? */\n    joy = sc->sc_dev.dv_cfdata->cf_flags & 2 ? MC1_JOYDISABLE : 0;\n\n    /* enable WSS emulation at the I/O port */\n    mad_write(sc, MC1_PORT, M_WSS_PORT_SELECT(sc->mad_ioindex) | joy);\n    mad_write(sc, MC2_PORT, 0x03); /* ? */\n    mad_write(sc, MC3_PORT, 0xf0); /* Disable SB */\n\n    cs4231_mode = \n\tstrncmp(sc->sc_ad1848.chip_name, \"CS4248\", 6) == 0 ||\n\tstrncmp(sc->sc_ad1848.chip_name, \"CS4231\", 6) == 0 ? 0x02 : 0;\n\n    if (sc->mad_chip_type == MAD_82C929) {\n\tmad_write(sc, MC4_PORT, 0x92);\n\tmad_write(sc, MC5_PORT, 0xA5 | cs4231_mode);\n\tmad_write(sc, MC6_PORT, 0x03);\t/* Disable MPU401 */\n    } else {\n\tmad_write(sc, MC4_PORT, 0x02);\n\tmad_write(sc, MC5_PORT, 0x30 | cs4231_mode);\n    }\n\n#ifdef AUDIO_DEBUG\n    if (wssdebug) {\n\tint i;\n\tfor (i = MC1_PORT; i <= MC7_PORT; i++)\n\t    DPRINTF((\"port %03x after init = %02x\\n\", i, mad_read(sc, i)));\n    }\n#endif\n}",
    "includes": [
      "#include <dev/isa/madreg.h>",
      "#include <dev/isa/wssvar.h>",
      "#include <dev/isa/wssreg.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"port %03x after init = %02x\\n\", i, mad_read(sc, i))"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mad_read",
          "args": [
            "sc",
            "i"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "mad_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wss.c",
          "lines": "365-393",
          "snippet": "u_int\nmad_read(sc, port)\n    struct wss_softc *sc;\n    int port;\n{\n    u_int tmp;\n    int pwd;\n    int s;\n    \n    switch (sc->mad_chip_type) {\t/* Output password */\n    case MAD_82C928:\n    case MAD_OTI601D:\n\tpwd = M_PASSWD_928;\n\tbreak;\n    case MAD_82C929:\n\tpwd = M_PASSWD_929;\n\tbreak;\n    case MAD_82C931:\n\tpwd = M_PASSWD_931;\n\tbreak;\n    default:\n\tpanic(\"mad_read: Bad chip type=%d\", sc->mad_chip_type);\n    }\n    s = splaudio();\t\t/* don't want an interrupt between outb&inb */\n    bus_space_write_1(sc->sc_iot, sc->mad_ioh, MC_PASSWD_REG, pwd);\n    tmp = bus_space_read_1(sc->sc_iot, sc->mad_ioh, port);\n    splx(s);\n    return tmp;\n}",
          "includes": [
            "#include <dev/isa/madreg.h>",
            "#include <dev/isa/wssvar.h>",
            "#include <dev/isa/wssreg.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/madreg.h>\n#include <dev/isa/wssvar.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_int\nmad_read(sc, port)\n    struct wss_softc *sc;\n    int port;\n{\n    u_int tmp;\n    int pwd;\n    int s;\n    \n    switch (sc->mad_chip_type) {\t/* Output password */\n    case MAD_82C928:\n    case MAD_OTI601D:\n\tpwd = M_PASSWD_928;\n\tbreak;\n    case MAD_82C929:\n\tpwd = M_PASSWD_929;\n\tbreak;\n    case MAD_82C931:\n\tpwd = M_PASSWD_931;\n\tbreak;\n    default:\n\tpanic(\"mad_read: Bad chip type=%d\", sc->mad_chip_type);\n    }\n    s = splaudio();\t\t/* don't want an interrupt between outb&inb */\n    bus_space_write_1(sc->sc_iot, sc->mad_ioh, MC_PASSWD_REG, pwd);\n    tmp = bus_space_read_1(sc->sc_iot, sc->mad_ioh, port);\n    splx(s);\n    return tmp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mad_write",
          "args": [
            "sc",
            "MC5_PORT",
            "0x30 | cs4231_mode"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "mad_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wss.c",
          "lines": "395-422",
          "snippet": "void\nmad_write(sc, port, value)\n    struct wss_softc *sc;\n    int port;\n    int value;\n{\n    int pwd;\n    int s;\n\n    switch (sc->mad_chip_type) {\t/* Output password */\n    case MAD_82C928:\n    case MAD_OTI601D:\n\tpwd = M_PASSWD_928;\n\tbreak;\n    case MAD_82C929:\n\tpwd = M_PASSWD_929;\n\tbreak;\n    case MAD_82C931:\n\tpwd = M_PASSWD_931;\n\tbreak;\n    default:\n\tpanic(\"mad_write: Bad chip type=%d\", sc->mad_chip_type);\n    }\n    s = splaudio();\n    bus_space_write_1(sc->sc_iot, sc->mad_ioh, MC_PASSWD_REG, pwd);\n    bus_space_write_1(sc->sc_iot, sc->mad_ioh, port, value & 0xff);\n    splx(s);\n}",
          "includes": [
            "#include <dev/isa/madreg.h>",
            "#include <dev/isa/wssvar.h>",
            "#include <dev/isa/wssreg.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/madreg.h>\n#include <dev/isa/wssvar.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nmad_write(sc, port, value)\n    struct wss_softc *sc;\n    int port;\n    int value;\n{\n    int pwd;\n    int s;\n\n    switch (sc->mad_chip_type) {\t/* Output password */\n    case MAD_82C928:\n    case MAD_OTI601D:\n\tpwd = M_PASSWD_928;\n\tbreak;\n    case MAD_82C929:\n\tpwd = M_PASSWD_929;\n\tbreak;\n    case MAD_82C931:\n\tpwd = M_PASSWD_931;\n\tbreak;\n    default:\n\tpanic(\"mad_write: Bad chip type=%d\", sc->mad_chip_type);\n    }\n    s = splaudio();\n    bus_space_write_1(sc->sc_iot, sc->mad_ioh, MC_PASSWD_REG, pwd);\n    bus_space_write_1(sc->sc_iot, sc->mad_ioh, port, value & 0xff);\n    splx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "sc->sc_ad1848.chip_name",
            "\"CS4231\"",
            "6"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "sc->sc_ad1848.chip_name",
            "\"CS4248\"",
            "6"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "M_WSS_PORT_SELECT",
          "args": [
            "sc->mad_ioindex"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/madreg.h>\n#include <dev/isa/wssvar.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nmadattach(sc)\n    struct wss_softc *sc;\n{\n    unsigned char cs4231_mode;\n    int joy;\n\n    if (sc->mad_chip_type == MAD_NONE)\n        return;\n\n    /* Do we want the joystick disabled? */\n    joy = sc->sc_dev.dv_cfdata->cf_flags & 2 ? MC1_JOYDISABLE : 0;\n\n    /* enable WSS emulation at the I/O port */\n    mad_write(sc, MC1_PORT, M_WSS_PORT_SELECT(sc->mad_ioindex) | joy);\n    mad_write(sc, MC2_PORT, 0x03); /* ? */\n    mad_write(sc, MC3_PORT, 0xf0); /* Disable SB */\n\n    cs4231_mode = \n\tstrncmp(sc->sc_ad1848.chip_name, \"CS4248\", 6) == 0 ||\n\tstrncmp(sc->sc_ad1848.chip_name, \"CS4231\", 6) == 0 ? 0x02 : 0;\n\n    if (sc->mad_chip_type == MAD_82C929) {\n\tmad_write(sc, MC4_PORT, 0x92);\n\tmad_write(sc, MC5_PORT, 0xA5 | cs4231_mode);\n\tmad_write(sc, MC6_PORT, 0x03);\t/* Disable MPU401 */\n    } else {\n\tmad_write(sc, MC4_PORT, 0x02);\n\tmad_write(sc, MC5_PORT, 0x30 | cs4231_mode);\n    }\n\n#ifdef AUDIO_DEBUG\n    if (wssdebug) {\n\tint i;\n\tfor (i = MC1_PORT; i <= MC7_PORT; i++)\n\t    DPRINTF((\"port %03x after init = %02x\\n\", i, mad_read(sc, i)));\n    }\n#endif\n}"
  },
  {
    "function_name": "mad_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wss.c",
    "lines": "395-422",
    "snippet": "void\nmad_write(sc, port, value)\n    struct wss_softc *sc;\n    int port;\n    int value;\n{\n    int pwd;\n    int s;\n\n    switch (sc->mad_chip_type) {\t/* Output password */\n    case MAD_82C928:\n    case MAD_OTI601D:\n\tpwd = M_PASSWD_928;\n\tbreak;\n    case MAD_82C929:\n\tpwd = M_PASSWD_929;\n\tbreak;\n    case MAD_82C931:\n\tpwd = M_PASSWD_931;\n\tbreak;\n    default:\n\tpanic(\"mad_write: Bad chip type=%d\", sc->mad_chip_type);\n    }\n    s = splaudio();\n    bus_space_write_1(sc->sc_iot, sc->mad_ioh, MC_PASSWD_REG, pwd);\n    bus_space_write_1(sc->sc_iot, sc->mad_ioh, port, value & 0xff);\n    splx(s);\n}",
    "includes": [
      "#include <dev/isa/madreg.h>",
      "#include <dev/isa/wssvar.h>",
      "#include <dev/isa/wssreg.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->sc_iot",
            "sc->mad_ioh",
            "port",
            "value & 0xff"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->sc_iot",
            "sc->mad_ioh",
            "MC_PASSWD_REG",
            "pwd"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splaudio",
          "args": [],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"mad_write: Bad chip type=%d\"",
            "sc->mad_chip_type"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/madreg.h>\n#include <dev/isa/wssvar.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nmad_write(sc, port, value)\n    struct wss_softc *sc;\n    int port;\n    int value;\n{\n    int pwd;\n    int s;\n\n    switch (sc->mad_chip_type) {\t/* Output password */\n    case MAD_82C928:\n    case MAD_OTI601D:\n\tpwd = M_PASSWD_928;\n\tbreak;\n    case MAD_82C929:\n\tpwd = M_PASSWD_929;\n\tbreak;\n    case MAD_82C931:\n\tpwd = M_PASSWD_931;\n\tbreak;\n    default:\n\tpanic(\"mad_write: Bad chip type=%d\", sc->mad_chip_type);\n    }\n    s = splaudio();\n    bus_space_write_1(sc->sc_iot, sc->mad_ioh, MC_PASSWD_REG, pwd);\n    bus_space_write_1(sc->sc_iot, sc->mad_ioh, port, value & 0xff);\n    splx(s);\n}"
  },
  {
    "function_name": "mad_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wss.c",
    "lines": "365-393",
    "snippet": "u_int\nmad_read(sc, port)\n    struct wss_softc *sc;\n    int port;\n{\n    u_int tmp;\n    int pwd;\n    int s;\n    \n    switch (sc->mad_chip_type) {\t/* Output password */\n    case MAD_82C928:\n    case MAD_OTI601D:\n\tpwd = M_PASSWD_928;\n\tbreak;\n    case MAD_82C929:\n\tpwd = M_PASSWD_929;\n\tbreak;\n    case MAD_82C931:\n\tpwd = M_PASSWD_931;\n\tbreak;\n    default:\n\tpanic(\"mad_read: Bad chip type=%d\", sc->mad_chip_type);\n    }\n    s = splaudio();\t\t/* don't want an interrupt between outb&inb */\n    bus_space_write_1(sc->sc_iot, sc->mad_ioh, MC_PASSWD_REG, pwd);\n    tmp = bus_space_read_1(sc->sc_iot, sc->mad_ioh, port);\n    splx(s);\n    return tmp;\n}",
    "includes": [
      "#include <dev/isa/madreg.h>",
      "#include <dev/isa/wssvar.h>",
      "#include <dev/isa/wssreg.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "sc->sc_iot",
            "sc->mad_ioh",
            "port"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->sc_iot",
            "sc->mad_ioh",
            "MC_PASSWD_REG",
            "pwd"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splaudio",
          "args": [],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"mad_read: Bad chip type=%d\"",
            "sc->mad_chip_type"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/madreg.h>\n#include <dev/isa/wssvar.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_int\nmad_read(sc, port)\n    struct wss_softc *sc;\n    int port;\n{\n    u_int tmp;\n    int pwd;\n    int s;\n    \n    switch (sc->mad_chip_type) {\t/* Output password */\n    case MAD_82C928:\n    case MAD_OTI601D:\n\tpwd = M_PASSWD_928;\n\tbreak;\n    case MAD_82C929:\n\tpwd = M_PASSWD_929;\n\tbreak;\n    case MAD_82C931:\n\tpwd = M_PASSWD_931;\n\tbreak;\n    default:\n\tpanic(\"mad_read: Bad chip type=%d\", sc->mad_chip_type);\n    }\n    s = splaudio();\t\t/* don't want an interrupt between outb&inb */\n    bus_space_write_1(sc->sc_iot, sc->mad_ioh, MC_PASSWD_REG, pwd);\n    tmp = bus_space_read_1(sc->sc_iot, sc->mad_ioh, port);\n    splx(s);\n    return tmp;\n}"
  },
  {
    "function_name": "wss_query_devinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wss.c",
    "lines": "201-329",
    "snippet": "int\nwss_query_devinfo(addr, dip)\n    void *addr;\n    mixer_devinfo_t *dip;\n{\n    DPRINTF((\"wss_query_devinfo: index=%d\\n\", dip->index));\n\n    switch(dip->index) {\n    case WSS_MIC_IN_LVL:\t/* Microphone */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = WSS_INPUT_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = WSS_MIC_IN_MUTE;\n\tstrcpy(dip->label.name, AudioNmicrophone);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case WSS_LINE_IN_LVL:\t/* line/CD */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = WSS_INPUT_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = WSS_LINE_IN_MUTE;\n\tstrcpy(dip->label.name, AudioNcd);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case WSS_DAC_LVL:\t\t/*  dacout */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = WSS_INPUT_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = WSS_DAC_MUTE;\n\tstrcpy(dip->label.name, AudioNdac);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case WSS_REC_LVL:\t/* record level */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = WSS_RECORD_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = WSS_RECORD_SOURCE;\n\tstrcpy(dip->label.name, AudioNrecord);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case WSS_MON_LVL:\t/* monitor level */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = WSS_MONITOR_CLASS;\n\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioNmonitor);\n\tdip->un.v.num_channels = 1;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case WSS_INPUT_CLASS:\t\t\t/* input class descriptor */\n\tdip->type = AUDIO_MIXER_CLASS;\n\tdip->mixer_class = WSS_INPUT_CLASS;\n\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioCinputs);\n\tbreak;\n\n    case WSS_MONITOR_CLASS:\t\t\t/* monitor class descriptor */\n\tdip->type = AUDIO_MIXER_CLASS;\n\tdip->mixer_class = WSS_MONITOR_CLASS;\n\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioCmonitor);\n\tbreak;\n\t    \n    case WSS_RECORD_CLASS:\t\t\t/* record source class */\n\tdip->type = AUDIO_MIXER_CLASS;\n\tdip->mixer_class = WSS_RECORD_CLASS;\n\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioCrecord);\n\tbreak;\n\t\n    case WSS_MIC_IN_MUTE:\n\tdip->mixer_class = WSS_INPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = WSS_MIC_IN_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tgoto mute;\n\t\n    case WSS_LINE_IN_MUTE:\n\tdip->mixer_class = WSS_INPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = WSS_LINE_IN_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tgoto mute;\n\t\n    case WSS_DAC_MUTE:\n\tdip->mixer_class = WSS_INPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = WSS_DAC_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n    mute:\n\tstrcpy(dip->label.name, AudioNmute);\n\tdip->un.e.num_mem = 2;\n\tstrcpy(dip->un.e.member[0].label.name, AudioNoff);\n\tdip->un.e.member[0].ord = 0;\n\tstrcpy(dip->un.e.member[1].label.name, AudioNon);\n\tdip->un.e.member[1].ord = 1;\n\tbreak;\n\n    case WSS_RECORD_SOURCE:\n\tdip->mixer_class = WSS_RECORD_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = WSS_REC_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioNsource);\n\tdip->un.e.num_mem = 3;\n\tstrcpy(dip->un.e.member[0].label.name, AudioNmicrophone);\n\tdip->un.e.member[0].ord = WSS_MIC_IN_LVL;\n\tstrcpy(dip->un.e.member[1].label.name, AudioNcd);\n\tdip->un.e.member[1].ord = WSS_LINE_IN_LVL;\n\tstrcpy(dip->un.e.member[2].label.name, AudioNdac);\n\tdip->un.e.member[2].ord = WSS_DAC_LVL;\n\tbreak;\n\n    default:\n\treturn ENXIO;\n\t/*NOTREACHED*/\n    }\n    DPRINTF((\"AUDIO_MIXER_DEVINFO: name=%s\\n\", dip->label.name));\n\n    return 0;\n}",
    "includes": [
      "#include <dev/isa/madreg.h>",
      "#include <dev/isa/wssvar.h>",
      "#include <dev/isa/wssreg.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\twss_query_devinfo"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"AUDIO_MIXER_DEVINFO: name=%s\\n\", dip->label.name)"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.e.member[2].label.name",
            "AudioNdac"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.e.member[1].label.name",
            "AudioNcd"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.e.member[0].label.name",
            "AudioNmicrophone"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNsource"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.e.member[1].label.name",
            "AudioNon"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.e.member[0].label.name",
            "AudioNoff"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNmute"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioCrecord"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioCmonitor"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioCinputs"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.v.units.name",
            "AudioNvolume"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNmonitor"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.v.units.name",
            "AudioNvolume"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNrecord"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.v.units.name",
            "AudioNvolume"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNdac"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.v.units.name",
            "AudioNvolume"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNcd"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.v.units.name",
            "AudioNvolume"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNmicrophone"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"wss_query_devinfo: index=%d\\n\", dip->index)"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/madreg.h>\n#include <dev/isa/wssvar.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\twss_query_devinfo;\n\nint\nwss_query_devinfo(addr, dip)\n    void *addr;\n    mixer_devinfo_t *dip;\n{\n    DPRINTF((\"wss_query_devinfo: index=%d\\n\", dip->index));\n\n    switch(dip->index) {\n    case WSS_MIC_IN_LVL:\t/* Microphone */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = WSS_INPUT_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = WSS_MIC_IN_MUTE;\n\tstrcpy(dip->label.name, AudioNmicrophone);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case WSS_LINE_IN_LVL:\t/* line/CD */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = WSS_INPUT_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = WSS_LINE_IN_MUTE;\n\tstrcpy(dip->label.name, AudioNcd);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case WSS_DAC_LVL:\t\t/*  dacout */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = WSS_INPUT_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = WSS_DAC_MUTE;\n\tstrcpy(dip->label.name, AudioNdac);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case WSS_REC_LVL:\t/* record level */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = WSS_RECORD_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = WSS_RECORD_SOURCE;\n\tstrcpy(dip->label.name, AudioNrecord);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case WSS_MON_LVL:\t/* monitor level */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = WSS_MONITOR_CLASS;\n\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioNmonitor);\n\tdip->un.v.num_channels = 1;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case WSS_INPUT_CLASS:\t\t\t/* input class descriptor */\n\tdip->type = AUDIO_MIXER_CLASS;\n\tdip->mixer_class = WSS_INPUT_CLASS;\n\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioCinputs);\n\tbreak;\n\n    case WSS_MONITOR_CLASS:\t\t\t/* monitor class descriptor */\n\tdip->type = AUDIO_MIXER_CLASS;\n\tdip->mixer_class = WSS_MONITOR_CLASS;\n\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioCmonitor);\n\tbreak;\n\t    \n    case WSS_RECORD_CLASS:\t\t\t/* record source class */\n\tdip->type = AUDIO_MIXER_CLASS;\n\tdip->mixer_class = WSS_RECORD_CLASS;\n\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioCrecord);\n\tbreak;\n\t\n    case WSS_MIC_IN_MUTE:\n\tdip->mixer_class = WSS_INPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = WSS_MIC_IN_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tgoto mute;\n\t\n    case WSS_LINE_IN_MUTE:\n\tdip->mixer_class = WSS_INPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = WSS_LINE_IN_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tgoto mute;\n\t\n    case WSS_DAC_MUTE:\n\tdip->mixer_class = WSS_INPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = WSS_DAC_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n    mute:\n\tstrcpy(dip->label.name, AudioNmute);\n\tdip->un.e.num_mem = 2;\n\tstrcpy(dip->un.e.member[0].label.name, AudioNoff);\n\tdip->un.e.member[0].ord = 0;\n\tstrcpy(dip->un.e.member[1].label.name, AudioNon);\n\tdip->un.e.member[1].ord = 1;\n\tbreak;\n\n    case WSS_RECORD_SOURCE:\n\tdip->mixer_class = WSS_RECORD_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = WSS_REC_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioNsource);\n\tdip->un.e.num_mem = 3;\n\tstrcpy(dip->un.e.member[0].label.name, AudioNmicrophone);\n\tdip->un.e.member[0].ord = WSS_MIC_IN_LVL;\n\tstrcpy(dip->un.e.member[1].label.name, AudioNcd);\n\tdip->un.e.member[1].ord = WSS_LINE_IN_LVL;\n\tstrcpy(dip->un.e.member[2].label.name, AudioNdac);\n\tdip->un.e.member[2].ord = WSS_DAC_LVL;\n\tbreak;\n\n    default:\n\treturn ENXIO;\n\t/*NOTREACHED*/\n    }\n    DPRINTF((\"AUDIO_MIXER_DEVINFO: name=%s\\n\", dip->label.name));\n\n    return 0;\n}"
  },
  {
    "function_name": "wss_mixer_get_port",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wss.c",
    "lines": "191-199",
    "snippet": "int\nwss_mixer_get_port(addr, cp)\n    void *addr;\n    mixer_ctrl_t *cp;\n{\n    struct ad1848_softc *ac = addr;\n\n    return (ad1848_mixer_get_port(ac, mappings, nummap, cp));\n}",
    "includes": [
      "#include <dev/isa/madreg.h>",
      "#include <dev/isa/wssvar.h>",
      "#include <dev/isa/wssreg.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\twss_mixer_get_port",
      "static ad1848_devmap_t mappings[] = {\n{ WSS_MIC_IN_LVL, AD1848_KIND_LVL, AD1848_AUX2_CHANNEL },\n{ WSS_LINE_IN_LVL, AD1848_KIND_LVL, AD1848_AUX1_CHANNEL },\n{ WSS_DAC_LVL, AD1848_KIND_LVL, AD1848_DAC_CHANNEL },\n{ WSS_MON_LVL, AD1848_KIND_LVL, AD1848_MONO_CHANNEL },\n{ WSS_MIC_IN_MUTE, AD1848_KIND_MUTE, AD1848_AUX2_CHANNEL },\n{ WSS_LINE_IN_MUTE, AD1848_KIND_MUTE, AD1848_AUX1_CHANNEL },\n{ WSS_DAC_MUTE, AD1848_KIND_MUTE, AD1848_DAC_CHANNEL },\n{ WSS_REC_LVL, AD1848_KIND_RECORDGAIN, -1 },\n{ WSS_RECORD_SOURCE, AD1848_KIND_RECORDSOURCE, -1}\n};",
      "static int nummap = sizeof(mappings) / sizeof(mappings[0]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ad1848_mixer_get_port",
          "args": [
            "ac",
            "mappings",
            "nummap",
            "cp"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "ad1848_mixer_get_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "793-865",
          "snippet": "int     \nad1848_mixer_get_port(ac, map, cnt, cp)\n  struct ad1848_softc *ac;\n  struct ad1848_devmap *map;\n  int cnt;\n  mixer_ctrl_t *cp;\n{\n  ad1848_devmap_t *entry;\n  struct ad1848_volume vol;\n  int error = EINVAL;\n  int dev;\n\n  if (!(entry = ad1848_mixer_find_dev(map, cnt, cp)))\n    return (ENXIO);\n\n  dev = entry->dev;\n\n  switch (entry->kind) {\n  case AD1848_KIND_LVL:\n    if (cp->type != AUDIO_MIXER_VALUE)\n      break;\n\n    if (dev < AD1848_AUX2_CHANNEL ||\n\tdev > AD1848_MONITOR_CHANNEL)\n      break;\n\n    if (cp->un.value.num_channels != 1 &&\n        mixer_channel_info[dev].right_reg == 0) \n      break;\n\n    error = ad1848_get_device_gain(ac, dev, &vol);\n    if (!error)\n      ad1848_from_vol(cp, &vol);\n\n    break;\n\n  case AD1848_KIND_MUTE:\n    if (cp->type != AUDIO_MIXER_ENUM) break;\n\n    cp->un.ord = ac->mute[dev] ? 1 : 0;\n    error = 0;\n    break;\n\n  case AD1848_KIND_RECORDGAIN:\n    if (cp->type != AUDIO_MIXER_VALUE) break;\n\n    error = ad1848_get_rec_gain(ac, &vol);\n    if (!error)\n      ad1848_from_vol(cp, &vol);\n\n    break;\n\n  case AD1848_KIND_MICGAIN:\n    if (cp->type != AUDIO_MIXER_VALUE) break;\n\n    error = ad1848_get_mic_gain(ac, &vol);\n    if (!error)\n      ad1848_from_vol(cp, &vol);\n\n    break;\n\n  case AD1848_KIND_RECORDSOURCE:\n    if (cp->type != AUDIO_MIXER_ENUM) break;\n    cp->un.ord = ad1848_get_rec_port(ac);\n    error = 0;\n    break;\n  default:\n    printf (\"Invalid kind\\n\");\n    break;\n  }\n\n  return (error);\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct ad1848_mixerinfo {\n  int  left_reg;\n  int  right_reg;\n  int  atten_bits;\n  int  atten_mask;\n} mixer_channel_info[] = \n{ { SP_LEFT_AUX2_CONTROL, SP_RIGHT_AUX2_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_AUX1_CONTROL, SP_RIGHT_AUX1_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_OUTPUT_CONTROL, SP_RIGHT_OUTPUT_CONTROL, \n    OUTPUT_ATTEN_BITS, OUTPUT_ATTEN_MASK }, \n  { CS_LEFT_LINE_CONTROL, CS_RIGHT_LINE_CONTROL, LINE_INPUT_ATTEN_BITS,\n    LINE_INPUT_ATTEN_MASK },\n  { CS_MONO_IO_CONTROL, 0, MONO_INPUT_ATTEN_BITS, MONO_INPUT_ATTEN_MASK },\n  { SP_DIGITAL_MIX, 0, OUTPUT_ATTEN_BITS, MIX_ATTEN_MASK }\n};",
            "static ad1848_devmap_t *ad1848_mixer_find_dev",
            "static ad1848_devmap_t *\nad1848_mixer_find_dev(map, cnt, cp)\n  ad1848_devmap_t *map;",
            "int cnt;",
            "mixer_ctrl_t *cp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct ad1848_mixerinfo {\n  int  left_reg;\n  int  right_reg;\n  int  atten_bits;\n  int  atten_mask;\n} mixer_channel_info[] = \n{ { SP_LEFT_AUX2_CONTROL, SP_RIGHT_AUX2_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_AUX1_CONTROL, SP_RIGHT_AUX1_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_OUTPUT_CONTROL, SP_RIGHT_OUTPUT_CONTROL, \n    OUTPUT_ATTEN_BITS, OUTPUT_ATTEN_MASK }, \n  { CS_LEFT_LINE_CONTROL, CS_RIGHT_LINE_CONTROL, LINE_INPUT_ATTEN_BITS,\n    LINE_INPUT_ATTEN_MASK },\n  { CS_MONO_IO_CONTROL, 0, MONO_INPUT_ATTEN_BITS, MONO_INPUT_ATTEN_MASK },\n  { SP_DIGITAL_MIX, 0, OUTPUT_ATTEN_BITS, MIX_ATTEN_MASK }\n};\nstatic ad1848_devmap_t *ad1848_mixer_find_dev;\nstatic ad1848_devmap_t *\nad1848_mixer_find_dev(map, cnt, cp)\n  ad1848_devmap_t *map;\nint cnt;\nmixer_ctrl_t *cp;\n\nint     \nad1848_mixer_get_port(ac, map, cnt, cp)\n  struct ad1848_softc *ac;\n  struct ad1848_devmap *map;\n  int cnt;\n  mixer_ctrl_t *cp;\n{\n  ad1848_devmap_t *entry;\n  struct ad1848_volume vol;\n  int error = EINVAL;\n  int dev;\n\n  if (!(entry = ad1848_mixer_find_dev(map, cnt, cp)))\n    return (ENXIO);\n\n  dev = entry->dev;\n\n  switch (entry->kind) {\n  case AD1848_KIND_LVL:\n    if (cp->type != AUDIO_MIXER_VALUE)\n      break;\n\n    if (dev < AD1848_AUX2_CHANNEL ||\n\tdev > AD1848_MONITOR_CHANNEL)\n      break;\n\n    if (cp->un.value.num_channels != 1 &&\n        mixer_channel_info[dev].right_reg == 0) \n      break;\n\n    error = ad1848_get_device_gain(ac, dev, &vol);\n    if (!error)\n      ad1848_from_vol(cp, &vol);\n\n    break;\n\n  case AD1848_KIND_MUTE:\n    if (cp->type != AUDIO_MIXER_ENUM) break;\n\n    cp->un.ord = ac->mute[dev] ? 1 : 0;\n    error = 0;\n    break;\n\n  case AD1848_KIND_RECORDGAIN:\n    if (cp->type != AUDIO_MIXER_VALUE) break;\n\n    error = ad1848_get_rec_gain(ac, &vol);\n    if (!error)\n      ad1848_from_vol(cp, &vol);\n\n    break;\n\n  case AD1848_KIND_MICGAIN:\n    if (cp->type != AUDIO_MIXER_VALUE) break;\n\n    error = ad1848_get_mic_gain(ac, &vol);\n    if (!error)\n      ad1848_from_vol(cp, &vol);\n\n    break;\n\n  case AD1848_KIND_RECORDSOURCE:\n    if (cp->type != AUDIO_MIXER_ENUM) break;\n    cp->un.ord = ad1848_get_rec_port(ac);\n    error = 0;\n    break;\n  default:\n    printf (\"Invalid kind\\n\");\n    break;\n  }\n\n  return (error);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/madreg.h>\n#include <dev/isa/wssvar.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\twss_mixer_get_port;\nstatic ad1848_devmap_t mappings[] = {\n{ WSS_MIC_IN_LVL, AD1848_KIND_LVL, AD1848_AUX2_CHANNEL },\n{ WSS_LINE_IN_LVL, AD1848_KIND_LVL, AD1848_AUX1_CHANNEL },\n{ WSS_DAC_LVL, AD1848_KIND_LVL, AD1848_DAC_CHANNEL },\n{ WSS_MON_LVL, AD1848_KIND_LVL, AD1848_MONO_CHANNEL },\n{ WSS_MIC_IN_MUTE, AD1848_KIND_MUTE, AD1848_AUX2_CHANNEL },\n{ WSS_LINE_IN_MUTE, AD1848_KIND_MUTE, AD1848_AUX1_CHANNEL },\n{ WSS_DAC_MUTE, AD1848_KIND_MUTE, AD1848_DAC_CHANNEL },\n{ WSS_REC_LVL, AD1848_KIND_RECORDGAIN, -1 },\n{ WSS_RECORD_SOURCE, AD1848_KIND_RECORDSOURCE, -1}\n};\nstatic int nummap = sizeof(mappings) / sizeof(mappings[0]);\n\nint\nwss_mixer_get_port(addr, cp)\n    void *addr;\n    mixer_ctrl_t *cp;\n{\n    struct ad1848_softc *ac = addr;\n\n    return (ad1848_mixer_get_port(ac, mappings, nummap, cp));\n}"
  },
  {
    "function_name": "wss_mixer_set_port",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wss.c",
    "lines": "181-189",
    "snippet": "int\nwss_mixer_set_port(addr, cp)\n    void *addr;\n    mixer_ctrl_t *cp;\n{\n    struct ad1848_softc *ac = addr;\n\n    return (ad1848_mixer_set_port(ac, mappings, nummap, cp));\n}",
    "includes": [
      "#include <dev/isa/madreg.h>",
      "#include <dev/isa/wssvar.h>",
      "#include <dev/isa/wssreg.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\twss_mixer_set_port",
      "static ad1848_devmap_t mappings[] = {\n{ WSS_MIC_IN_LVL, AD1848_KIND_LVL, AD1848_AUX2_CHANNEL },\n{ WSS_LINE_IN_LVL, AD1848_KIND_LVL, AD1848_AUX1_CHANNEL },\n{ WSS_DAC_LVL, AD1848_KIND_LVL, AD1848_DAC_CHANNEL },\n{ WSS_MON_LVL, AD1848_KIND_LVL, AD1848_MONO_CHANNEL },\n{ WSS_MIC_IN_MUTE, AD1848_KIND_MUTE, AD1848_AUX2_CHANNEL },\n{ WSS_LINE_IN_MUTE, AD1848_KIND_MUTE, AD1848_AUX1_CHANNEL },\n{ WSS_DAC_MUTE, AD1848_KIND_MUTE, AD1848_DAC_CHANNEL },\n{ WSS_REC_LVL, AD1848_KIND_RECORDGAIN, -1 },\n{ WSS_RECORD_SOURCE, AD1848_KIND_RECORDSOURCE, -1}\n};",
      "static int nummap = sizeof(mappings) / sizeof(mappings[0]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ad1848_mixer_set_port",
          "args": [
            "ac",
            "mappings",
            "nummap",
            "cp"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "ad1848_mixer_set_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "867-934",
          "snippet": "int     \nad1848_mixer_set_port(ac, map, cnt, cp)\n  struct ad1848_softc *ac;\n  struct ad1848_devmap *map;\n  int cnt;\n  mixer_ctrl_t *cp;\n{\n  ad1848_devmap_t *entry;\n  struct ad1848_volume vol;\n  int error = EINVAL;\n  int dev;\n\n  if (!(entry = ad1848_mixer_find_dev(map, cnt, cp)))\n    return (ENXIO);\n\n  dev = entry->dev;\n\n  switch (entry->kind) {\n  case AD1848_KIND_LVL:\n    if (cp->type != AUDIO_MIXER_VALUE)\n      break;\n\n    if (dev < AD1848_AUX2_CHANNEL ||\n\tdev > AD1848_MONITOR_CHANNEL)\n      break;\n\n    if (cp->un.value.num_channels != 1 &&\n        mixer_channel_info[dev].right_reg == 0) \n      break;\n    \n    ad1848_to_vol(cp, &vol);\n    error = ad1848_set_channel_gain(ac, dev, &vol);\n    break;\n\n  case AD1848_KIND_MUTE:\n    if (cp->type != AUDIO_MIXER_ENUM) break;\n    \n    ac->mute[dev] = (cp->un.ord ? MUTE_ALL : 0);\n    ad1848_mute_channel(ac, dev, ac->mute[dev]);\n    error = 0;\n    break;\n\n  case AD1848_KIND_RECORDGAIN:\n    if (cp->type != AUDIO_MIXER_VALUE) break;\n\n    ad1848_to_vol(cp, &vol);\n    error = ad1848_set_rec_gain(ac, &vol);\n    break;\n\n  case AD1848_KIND_MICGAIN:\n    if (cp->type != AUDIO_MIXER_VALUE) break;\n\n    ad1848_to_vol(cp, &vol);\n    error = ad1848_set_mic_gain(ac, &vol);\n    break;\n\n  case AD1848_KIND_RECORDSOURCE:\n    if (cp->type != AUDIO_MIXER_ENUM) break;\n\n    error = ad1848_set_rec_port(ac,  cp->un.ord);\n    break;\n  default:\n    printf (\"Invalid kind\\n\");\n    break;\n  }\n\n  return (error);\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct ad1848_mixerinfo {\n  int  left_reg;\n  int  right_reg;\n  int  atten_bits;\n  int  atten_mask;\n} mixer_channel_info[] = \n{ { SP_LEFT_AUX2_CONTROL, SP_RIGHT_AUX2_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_AUX1_CONTROL, SP_RIGHT_AUX1_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_OUTPUT_CONTROL, SP_RIGHT_OUTPUT_CONTROL, \n    OUTPUT_ATTEN_BITS, OUTPUT_ATTEN_MASK }, \n  { CS_LEFT_LINE_CONTROL, CS_RIGHT_LINE_CONTROL, LINE_INPUT_ATTEN_BITS,\n    LINE_INPUT_ATTEN_MASK },\n  { CS_MONO_IO_CONTROL, 0, MONO_INPUT_ATTEN_BITS, MONO_INPUT_ATTEN_MASK },\n  { SP_DIGITAL_MIX, 0, OUTPUT_ATTEN_BITS, MIX_ATTEN_MASK }\n};",
            "static ad1848_devmap_t *ad1848_mixer_find_dev",
            "static ad1848_devmap_t *\nad1848_mixer_find_dev(map, cnt, cp)\n  ad1848_devmap_t *map;",
            "int cnt;",
            "mixer_ctrl_t *cp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct ad1848_mixerinfo {\n  int  left_reg;\n  int  right_reg;\n  int  atten_bits;\n  int  atten_mask;\n} mixer_channel_info[] = \n{ { SP_LEFT_AUX2_CONTROL, SP_RIGHT_AUX2_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_AUX1_CONTROL, SP_RIGHT_AUX1_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_OUTPUT_CONTROL, SP_RIGHT_OUTPUT_CONTROL, \n    OUTPUT_ATTEN_BITS, OUTPUT_ATTEN_MASK }, \n  { CS_LEFT_LINE_CONTROL, CS_RIGHT_LINE_CONTROL, LINE_INPUT_ATTEN_BITS,\n    LINE_INPUT_ATTEN_MASK },\n  { CS_MONO_IO_CONTROL, 0, MONO_INPUT_ATTEN_BITS, MONO_INPUT_ATTEN_MASK },\n  { SP_DIGITAL_MIX, 0, OUTPUT_ATTEN_BITS, MIX_ATTEN_MASK }\n};\nstatic ad1848_devmap_t *ad1848_mixer_find_dev;\nstatic ad1848_devmap_t *\nad1848_mixer_find_dev(map, cnt, cp)\n  ad1848_devmap_t *map;\nint cnt;\nmixer_ctrl_t *cp;\n\nint     \nad1848_mixer_set_port(ac, map, cnt, cp)\n  struct ad1848_softc *ac;\n  struct ad1848_devmap *map;\n  int cnt;\n  mixer_ctrl_t *cp;\n{\n  ad1848_devmap_t *entry;\n  struct ad1848_volume vol;\n  int error = EINVAL;\n  int dev;\n\n  if (!(entry = ad1848_mixer_find_dev(map, cnt, cp)))\n    return (ENXIO);\n\n  dev = entry->dev;\n\n  switch (entry->kind) {\n  case AD1848_KIND_LVL:\n    if (cp->type != AUDIO_MIXER_VALUE)\n      break;\n\n    if (dev < AD1848_AUX2_CHANNEL ||\n\tdev > AD1848_MONITOR_CHANNEL)\n      break;\n\n    if (cp->un.value.num_channels != 1 &&\n        mixer_channel_info[dev].right_reg == 0) \n      break;\n    \n    ad1848_to_vol(cp, &vol);\n    error = ad1848_set_channel_gain(ac, dev, &vol);\n    break;\n\n  case AD1848_KIND_MUTE:\n    if (cp->type != AUDIO_MIXER_ENUM) break;\n    \n    ac->mute[dev] = (cp->un.ord ? MUTE_ALL : 0);\n    ad1848_mute_channel(ac, dev, ac->mute[dev]);\n    error = 0;\n    break;\n\n  case AD1848_KIND_RECORDGAIN:\n    if (cp->type != AUDIO_MIXER_VALUE) break;\n\n    ad1848_to_vol(cp, &vol);\n    error = ad1848_set_rec_gain(ac, &vol);\n    break;\n\n  case AD1848_KIND_MICGAIN:\n    if (cp->type != AUDIO_MIXER_VALUE) break;\n\n    ad1848_to_vol(cp, &vol);\n    error = ad1848_set_mic_gain(ac, &vol);\n    break;\n\n  case AD1848_KIND_RECORDSOURCE:\n    if (cp->type != AUDIO_MIXER_ENUM) break;\n\n    error = ad1848_set_rec_port(ac,  cp->un.ord);\n    break;\n  default:\n    printf (\"Invalid kind\\n\");\n    break;\n  }\n\n  return (error);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/madreg.h>\n#include <dev/isa/wssvar.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\twss_mixer_set_port;\nstatic ad1848_devmap_t mappings[] = {\n{ WSS_MIC_IN_LVL, AD1848_KIND_LVL, AD1848_AUX2_CHANNEL },\n{ WSS_LINE_IN_LVL, AD1848_KIND_LVL, AD1848_AUX1_CHANNEL },\n{ WSS_DAC_LVL, AD1848_KIND_LVL, AD1848_DAC_CHANNEL },\n{ WSS_MON_LVL, AD1848_KIND_LVL, AD1848_MONO_CHANNEL },\n{ WSS_MIC_IN_MUTE, AD1848_KIND_MUTE, AD1848_AUX2_CHANNEL },\n{ WSS_LINE_IN_MUTE, AD1848_KIND_MUTE, AD1848_AUX1_CHANNEL },\n{ WSS_DAC_MUTE, AD1848_KIND_MUTE, AD1848_DAC_CHANNEL },\n{ WSS_REC_LVL, AD1848_KIND_RECORDGAIN, -1 },\n{ WSS_RECORD_SOURCE, AD1848_KIND_RECORDSOURCE, -1}\n};\nstatic int nummap = sizeof(mappings) / sizeof(mappings[0]);\n\nint\nwss_mixer_set_port(addr, cp)\n    void *addr;\n    mixer_ctrl_t *cp;\n{\n    struct ad1848_softc *ac = addr;\n\n    return (ad1848_mixer_set_port(ac, mappings, nummap, cp));\n}"
  },
  {
    "function_name": "wss_getdev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wss.c",
    "lines": "158-165",
    "snippet": "int\nwss_getdev(addr, retp)\n    void *addr;\n    struct audio_device *retp;\n{\n    *retp = wss_device;\n    return 0;\n}",
    "includes": [
      "#include <dev/isa/madreg.h>",
      "#include <dev/isa/wssvar.h>",
      "#include <dev/isa/wssreg.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct audio_device wss_device = {\n\t\"wss,ad1848\",\n\t\"\",\n\t\"WSS\"\n};",
      "int\twss_getdev"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/isa/madreg.h>\n#include <dev/isa/wssvar.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct audio_device wss_device = {\n\t\"wss,ad1848\",\n\t\"\",\n\t\"WSS\"\n};\nint\twss_getdev;\n\nint\nwss_getdev(addr, retp)\n    void *addr;\n    struct audio_device *retp;\n{\n    *retp = wss_device;\n    return 0;\n}"
  },
  {
    "function_name": "wssattach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wss.c",
    "lines": "120-156",
    "snippet": "void\nwssattach(sc)\n    struct wss_softc *sc;\n{\n    int version;\n    \n    madattach(sc);\n\n    sc->sc_ih = isa_intr_establish(sc->sc_ic, sc->wss_irq, IST_EDGE, IPL_AUDIO,\n        ad1848_intr, &sc->sc_ad1848, sc->sc_dev.dv_xname);\n\n    ad1848_attach(&sc->sc_ad1848);\n    \n    version = bus_space_read_1(sc->sc_iot, sc->sc_ioh, WSS_STATUS) & WSS_VERSMASK;\n    printf(\" (vers %d)\", version);\n    switch(sc->mad_chip_type) {\n    case MAD_82C928:\n\tprintf(\", 82C928\");\n\tbreak;\n    case MAD_OTI601D:\n\tprintf(\", OTI-601D\");\n\tbreak;\n    case MAD_82C929:\n\tprintf(\", 82C929\");\n\tbreak;\n    case MAD_82C931:\n\tprintf(\", 82C931\");\n\tbreak;\n    default:\n\tbreak;\n    }\n    printf(\"\\n\");\n\n    sc->sc_ad1848.parent = sc;\n\n    audio_attach_mi(&wss_hw_if, &sc->sc_ad1848, &sc->sc_dev);\n}",
    "includes": [
      "#include <dev/isa/madreg.h>",
      "#include <dev/isa/wssvar.h>",
      "#include <dev/isa/wssreg.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct audio_hw_if wss_hw_if = {\n\tad1848_open,\n\tad1848_close,\n\tNULL,\n\tad1848_query_encoding,\n\tad1848_set_params,\n\tad1848_round_blocksize,\n\tad1848_commit_settings,\n\tad1848_dma_init_output,\n\tad1848_dma_init_input,\n\tad1848_dma_output,\n\tad1848_dma_input,\n\tad1848_halt_out_dma,\n\tad1848_halt_in_dma,\n\tNULL,\n\twss_getdev,\n\tNULL,\n\twss_mixer_set_port,\n\twss_mixer_get_port,\n\twss_query_devinfo,\n\tad1848_malloc,\n\tad1848_free,\n\tad1848_round,\n\tad1848_mappage,\n\tad1848_get_props,\n\tNULL,\n\tNULL\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audio_attach_mi",
          "args": [
            "&wss_hw_if",
            "&sc->sc_ad1848",
            "&sc->sc_dev"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "audio_attach_mi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "394-408",
          "snippet": "void\naudio_attach_mi(ahwp, hdlp, dev)\n\tstruct audio_hw_if *ahwp;\n\tvoid *hdlp;\n\tstruct device *dev;\n{\n\tstruct audio_attach_args arg;\n\n\tif (ahwp != NULL) {\n\t\targ.type = AUDIODEV_TYPE_AUDIO;\n\t\targ.hwif = ahwp;\n\t\targ.hdl = hdlp;\n\t\t(void)config_found(dev, &arg, audioprint);\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nvoid\naudio_attach_mi(ahwp, hdlp, dev)\n\tstruct audio_hw_if *ahwp;\n\tvoid *hdlp;\n\tstruct device *dev;\n{\n\tstruct audio_attach_args arg;\n\n\tif (ahwp != NULL) {\n\t\targ.type = AUDIODEV_TYPE_AUDIO;\n\t\targ.hwif = ahwp;\n\t\targ.hdl = hdlp;\n\t\t(void)config_found(dev, &arg, audioprint);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "sc->sc_iot",
            "sc->sc_ioh",
            "WSS_STATUS"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ad1848_attach",
          "args": [
            "&sc->sc_ad1848"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "ad1848_attach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "502-577",
          "snippet": "void\nad1848_attach(sc)\n    struct ad1848_softc *sc;\n{\n    int i;\n    struct ad1848_volume vol_mid = {220, 220};\n    struct ad1848_volume vol_0   = {0, 0};\n    struct audio_params pparams, rparams;\n    int timeout;\n    \n    sc->sc_locked = 0;\n    sc->sc_playrun = NOTRUNNING;\n    sc->sc_recrun = NOTRUNNING;\n\n    if (sc->sc_drq != -1) {\n\tif (isa_dmamap_create(sc->sc_isa, sc->sc_drq, MAX_ISADMA,\n\t    BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW)) {\n\t\tprintf(\"ad1848_attach: can't create map for drq %d\\n\",\n\t\t    sc->sc_drq);\n\t\treturn;\n\t}\n    }\n    if (sc->sc_recdrq != -1 && sc->sc_recdrq != sc->sc_drq) {\n\tif (isa_dmamap_create(sc->sc_isa, sc->sc_recdrq, MAX_ISADMA,\n\t    BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW)) {\n\t\tprintf(\"ad1848_attach: can't creape map for drq %d\\n\",\n\t\t    sc->sc_recdrq);\n\t\treturn;\n\t}\n    }\n\n    /* Initialize the ad1848... */\n    for (i = 0; i < 0x10; i++) {\n\tad_write(sc, i, ad1848_init_values[i]);\n        timeout = 100000;\n        while (timeout > 0 && ad_read(sc, AD1848_IADDR) & SP_IN_INIT)\n\t    timeout--;\n    }\n    /* ...and additional CS4231 stuff too */\n    if (sc->mode == 2) {\n\t    ad_write(sc, SP_INTERFACE_CONFIG, 0); /* disable SINGLE_DMA */\n\t    for (i = 0x10; i < 0x20; i++)\n\t\t    if (ad1848_init_values[i] != 0) {\n\t\t\t    ad_write(sc, i, ad1848_init_values[i]);\n\t\t\t    timeout = 100000;\n    \t\t\t    while (timeout > 0 && \n\t\t\t\t   ad_read(sc, AD1848_IADDR) & SP_IN_INIT)\n\t\t\t\ttimeout--;\n\t\t    }\n    }\n    ad1848_reset(sc);\n\n    pparams = audio_default;\n    rparams = audio_default;\n    (void) ad1848_set_params(sc, AUMODE_RECORD|AUMODE_PLAY, 0, &pparams, &rparams);\n\n    /* Set default gains */\n    (void) ad1848_set_rec_gain(sc, &vol_mid);\n    (void) ad1848_set_channel_gain(sc, AD1848_DAC_CHANNEL, &vol_mid);\n    (void) ad1848_set_channel_gain(sc, AD1848_MONITOR_CHANNEL, &vol_0);\n    (void) ad1848_set_channel_gain(sc, AD1848_AUX1_CHANNEL, &vol_mid);\t/* CD volume */\n    if (sc->mode == 2) {\n\t(void) ad1848_set_channel_gain(sc, AD1848_AUX2_CHANNEL, &vol_mid); /* CD volume */\n\t(void) ad1848_set_channel_gain(sc, AD1848_LINE_CHANNEL, &vol_mid);\n\t(void) ad1848_set_channel_gain(sc, AD1848_MONO_CHANNEL, &vol_0);\n\tsc->mute[AD1848_MONO_CHANNEL] = MUTE_ALL;\n    } else\n\t(void) ad1848_set_channel_gain(sc, AD1848_AUX2_CHANNEL, &vol_0);\n\n    /* Set default port */\n    (void) ad1848_set_rec_port(sc, MIC_IN_PORT);\n\n    if (sc->chip_name)\n\tprintf(\": %s\", sc->chip_name);\n#undef WAITREADY\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ad1848_init_values[] = {\n\t\t\t/* Left Input Control */\n    GAIN_12|INPUT_MIC_GAIN_ENABLE,\n\t\t\t/* Right Input Control */\n    GAIN_12|INPUT_MIC_GAIN_ENABLE,\n    ATTEN_12,\t\t/* Left Aux #1 Input Control */\n    ATTEN_12,\t\t/* Right Aux #1 Input Control */\n    ATTEN_12,\t\t/* Left Aux #2 Input Control */\n    ATTEN_12,\t\t/* Right Aux #2 Input Control */\n    /* bits 5-0 are attenuation select */\n    ATTEN_12,\t\t/* Left DAC output Control */\n    ATTEN_12,\t\t/* Right DAC output Control */\n\t\t\t/* Clock and Data Format */\n    CLOCK_XTAL1|FMT_PCM8,\n\t\t\t/* Interface Config */\n    SINGLE_DMA|AUTO_CAL_ENABLE,\n    INTERRUPT_ENABLE,\t/* Pin control */\n    0x00,\t\t/* Test and Init */\n    MODE2,\t\t/* Misc control */\n    ATTEN_0<<2,\t\t/* Digital Mix Control */\n    0,\t\t\t/* Upper base Count */\n    0,\t\t\t/* Lower base Count */\n\n    /* These are for CS4231 &c. only (additional registers): */\n    0,\t\t\t/* Alt feature 1 */\n    0,\t\t\t/* Alt feature 2 */\n    ATTEN_12,\t\t/* Left line in */\n    ATTEN_12,\t\t/* Right line in */\n    0,\t\t\t/* Timer low */\n    0,\t\t\t/* Timer high */\n    0,\t\t\t/* unused */\n    0,\t\t\t/* unused */\n    0,\t\t\t/* IRQ status */\n    0,\t\t\t/* unused */\n\t\t\t/* Mono input (a.k.a speaker) (mic) Control */\n    MONO_INPUT_MUTE|ATTEN_6,\t\t/* mute speaker by default */\n    0,\t\t\t/* unused */\n    0,\t\t\t/* record format */\n    0,\t\t\t/* Crystal Clock Select */\n    0,\t\t\t/* upper record count */\n    0\t\t\t/* lower record count */\n};",
            "void\tad1848_reset",
            "static int ad_read",
            "static void ad_write",
            "static ad1848_devmap_t *\nad1848_mixer_find_dev(map, cnt, cp)\n  ad1848_devmap_t *map;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int ad1848_init_values[] = {\n\t\t\t/* Left Input Control */\n    GAIN_12|INPUT_MIC_GAIN_ENABLE,\n\t\t\t/* Right Input Control */\n    GAIN_12|INPUT_MIC_GAIN_ENABLE,\n    ATTEN_12,\t\t/* Left Aux #1 Input Control */\n    ATTEN_12,\t\t/* Right Aux #1 Input Control */\n    ATTEN_12,\t\t/* Left Aux #2 Input Control */\n    ATTEN_12,\t\t/* Right Aux #2 Input Control */\n    /* bits 5-0 are attenuation select */\n    ATTEN_12,\t\t/* Left DAC output Control */\n    ATTEN_12,\t\t/* Right DAC output Control */\n\t\t\t/* Clock and Data Format */\n    CLOCK_XTAL1|FMT_PCM8,\n\t\t\t/* Interface Config */\n    SINGLE_DMA|AUTO_CAL_ENABLE,\n    INTERRUPT_ENABLE,\t/* Pin control */\n    0x00,\t\t/* Test and Init */\n    MODE2,\t\t/* Misc control */\n    ATTEN_0<<2,\t\t/* Digital Mix Control */\n    0,\t\t\t/* Upper base Count */\n    0,\t\t\t/* Lower base Count */\n\n    /* These are for CS4231 &c. only (additional registers): */\n    0,\t\t\t/* Alt feature 1 */\n    0,\t\t\t/* Alt feature 2 */\n    ATTEN_12,\t\t/* Left line in */\n    ATTEN_12,\t\t/* Right line in */\n    0,\t\t\t/* Timer low */\n    0,\t\t\t/* Timer high */\n    0,\t\t\t/* unused */\n    0,\t\t\t/* unused */\n    0,\t\t\t/* IRQ status */\n    0,\t\t\t/* unused */\n\t\t\t/* Mono input (a.k.a speaker) (mic) Control */\n    MONO_INPUT_MUTE|ATTEN_6,\t\t/* mute speaker by default */\n    0,\t\t\t/* unused */\n    0,\t\t\t/* record format */\n    0,\t\t\t/* Crystal Clock Select */\n    0,\t\t\t/* upper record count */\n    0\t\t\t/* lower record count */\n};\nvoid\tad1848_reset;\nstatic int ad_read;\nstatic void ad_write;\nstatic ad1848_devmap_t *\nad1848_mixer_find_dev(map, cnt, cp)\n  ad1848_devmap_t *map;\n\nvoid\nad1848_attach(sc)\n    struct ad1848_softc *sc;\n{\n    int i;\n    struct ad1848_volume vol_mid = {220, 220};\n    struct ad1848_volume vol_0   = {0, 0};\n    struct audio_params pparams, rparams;\n    int timeout;\n    \n    sc->sc_locked = 0;\n    sc->sc_playrun = NOTRUNNING;\n    sc->sc_recrun = NOTRUNNING;\n\n    if (sc->sc_drq != -1) {\n\tif (isa_dmamap_create(sc->sc_isa, sc->sc_drq, MAX_ISADMA,\n\t    BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW)) {\n\t\tprintf(\"ad1848_attach: can't create map for drq %d\\n\",\n\t\t    sc->sc_drq);\n\t\treturn;\n\t}\n    }\n    if (sc->sc_recdrq != -1 && sc->sc_recdrq != sc->sc_drq) {\n\tif (isa_dmamap_create(sc->sc_isa, sc->sc_recdrq, MAX_ISADMA,\n\t    BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW)) {\n\t\tprintf(\"ad1848_attach: can't creape map for drq %d\\n\",\n\t\t    sc->sc_recdrq);\n\t\treturn;\n\t}\n    }\n\n    /* Initialize the ad1848... */\n    for (i = 0; i < 0x10; i++) {\n\tad_write(sc, i, ad1848_init_values[i]);\n        timeout = 100000;\n        while (timeout > 0 && ad_read(sc, AD1848_IADDR) & SP_IN_INIT)\n\t    timeout--;\n    }\n    /* ...and additional CS4231 stuff too */\n    if (sc->mode == 2) {\n\t    ad_write(sc, SP_INTERFACE_CONFIG, 0); /* disable SINGLE_DMA */\n\t    for (i = 0x10; i < 0x20; i++)\n\t\t    if (ad1848_init_values[i] != 0) {\n\t\t\t    ad_write(sc, i, ad1848_init_values[i]);\n\t\t\t    timeout = 100000;\n    \t\t\t    while (timeout > 0 && \n\t\t\t\t   ad_read(sc, AD1848_IADDR) & SP_IN_INIT)\n\t\t\t\ttimeout--;\n\t\t    }\n    }\n    ad1848_reset(sc);\n\n    pparams = audio_default;\n    rparams = audio_default;\n    (void) ad1848_set_params(sc, AUMODE_RECORD|AUMODE_PLAY, 0, &pparams, &rparams);\n\n    /* Set default gains */\n    (void) ad1848_set_rec_gain(sc, &vol_mid);\n    (void) ad1848_set_channel_gain(sc, AD1848_DAC_CHANNEL, &vol_mid);\n    (void) ad1848_set_channel_gain(sc, AD1848_MONITOR_CHANNEL, &vol_0);\n    (void) ad1848_set_channel_gain(sc, AD1848_AUX1_CHANNEL, &vol_mid);\t/* CD volume */\n    if (sc->mode == 2) {\n\t(void) ad1848_set_channel_gain(sc, AD1848_AUX2_CHANNEL, &vol_mid); /* CD volume */\n\t(void) ad1848_set_channel_gain(sc, AD1848_LINE_CHANNEL, &vol_mid);\n\t(void) ad1848_set_channel_gain(sc, AD1848_MONO_CHANNEL, &vol_0);\n\tsc->mute[AD1848_MONO_CHANNEL] = MUTE_ALL;\n    } else\n\t(void) ad1848_set_channel_gain(sc, AD1848_AUX2_CHANNEL, &vol_0);\n\n    /* Set default port */\n    (void) ad1848_set_rec_port(sc, MIC_IN_PORT);\n\n    if (sc->chip_name)\n\tprintf(\": %s\", sc->chip_name);\n#undef WAITREADY\n}"
        }
      },
      {
        "call_info": {
          "callee": "isa_intr_establish",
          "args": [
            "sc->sc_ic",
            "sc->wss_irq",
            "IST_EDGE",
            "IPL_AUDIO",
            "ad1848_intr",
            "&sc->sc_ad1848",
            "sc->sc_dev.dv_xname"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "madattach",
          "args": [
            "sc"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "madattach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wss.c",
          "lines": "424-462",
          "snippet": "void\nmadattach(sc)\n    struct wss_softc *sc;\n{\n    unsigned char cs4231_mode;\n    int joy;\n\n    if (sc->mad_chip_type == MAD_NONE)\n        return;\n\n    /* Do we want the joystick disabled? */\n    joy = sc->sc_dev.dv_cfdata->cf_flags & 2 ? MC1_JOYDISABLE : 0;\n\n    /* enable WSS emulation at the I/O port */\n    mad_write(sc, MC1_PORT, M_WSS_PORT_SELECT(sc->mad_ioindex) | joy);\n    mad_write(sc, MC2_PORT, 0x03); /* ? */\n    mad_write(sc, MC3_PORT, 0xf0); /* Disable SB */\n\n    cs4231_mode = \n\tstrncmp(sc->sc_ad1848.chip_name, \"CS4248\", 6) == 0 ||\n\tstrncmp(sc->sc_ad1848.chip_name, \"CS4231\", 6) == 0 ? 0x02 : 0;\n\n    if (sc->mad_chip_type == MAD_82C929) {\n\tmad_write(sc, MC4_PORT, 0x92);\n\tmad_write(sc, MC5_PORT, 0xA5 | cs4231_mode);\n\tmad_write(sc, MC6_PORT, 0x03);\t/* Disable MPU401 */\n    } else {\n\tmad_write(sc, MC4_PORT, 0x02);\n\tmad_write(sc, MC5_PORT, 0x30 | cs4231_mode);\n    }\n\n#ifdef AUDIO_DEBUG\n    if (wssdebug) {\n\tint i;\n\tfor (i = MC1_PORT; i <= MC7_PORT; i++)\n\t    DPRINTF((\"port %03x after init = %02x\\n\", i, mad_read(sc, i)));\n    }\n#endif\n}",
          "includes": [
            "#include <dev/isa/madreg.h>",
            "#include <dev/isa/wssvar.h>",
            "#include <dev/isa/wssreg.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/madreg.h>\n#include <dev/isa/wssvar.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nmadattach(sc)\n    struct wss_softc *sc;\n{\n    unsigned char cs4231_mode;\n    int joy;\n\n    if (sc->mad_chip_type == MAD_NONE)\n        return;\n\n    /* Do we want the joystick disabled? */\n    joy = sc->sc_dev.dv_cfdata->cf_flags & 2 ? MC1_JOYDISABLE : 0;\n\n    /* enable WSS emulation at the I/O port */\n    mad_write(sc, MC1_PORT, M_WSS_PORT_SELECT(sc->mad_ioindex) | joy);\n    mad_write(sc, MC2_PORT, 0x03); /* ? */\n    mad_write(sc, MC3_PORT, 0xf0); /* Disable SB */\n\n    cs4231_mode = \n\tstrncmp(sc->sc_ad1848.chip_name, \"CS4248\", 6) == 0 ||\n\tstrncmp(sc->sc_ad1848.chip_name, \"CS4231\", 6) == 0 ? 0x02 : 0;\n\n    if (sc->mad_chip_type == MAD_82C929) {\n\tmad_write(sc, MC4_PORT, 0x92);\n\tmad_write(sc, MC5_PORT, 0xA5 | cs4231_mode);\n\tmad_write(sc, MC6_PORT, 0x03);\t/* Disable MPU401 */\n    } else {\n\tmad_write(sc, MC4_PORT, 0x02);\n\tmad_write(sc, MC5_PORT, 0x30 | cs4231_mode);\n    }\n\n#ifdef AUDIO_DEBUG\n    if (wssdebug) {\n\tint i;\n\tfor (i = MC1_PORT; i <= MC7_PORT; i++)\n\t    DPRINTF((\"port %03x after init = %02x\\n\", i, mad_read(sc, i)));\n    }\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/madreg.h>\n#include <dev/isa/wssvar.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct audio_hw_if wss_hw_if = {\n\tad1848_open,\n\tad1848_close,\n\tNULL,\n\tad1848_query_encoding,\n\tad1848_set_params,\n\tad1848_round_blocksize,\n\tad1848_commit_settings,\n\tad1848_dma_init_output,\n\tad1848_dma_init_input,\n\tad1848_dma_output,\n\tad1848_dma_input,\n\tad1848_halt_out_dma,\n\tad1848_halt_in_dma,\n\tNULL,\n\twss_getdev,\n\tNULL,\n\twss_mixer_set_port,\n\twss_mixer_get_port,\n\twss_query_devinfo,\n\tad1848_malloc,\n\tad1848_free,\n\tad1848_round,\n\tad1848_mappage,\n\tad1848_get_props,\n\tNULL,\n\tNULL\n};\n\nvoid\nwssattach(sc)\n    struct wss_softc *sc;\n{\n    int version;\n    \n    madattach(sc);\n\n    sc->sc_ih = isa_intr_establish(sc->sc_ic, sc->wss_irq, IST_EDGE, IPL_AUDIO,\n        ad1848_intr, &sc->sc_ad1848, sc->sc_dev.dv_xname);\n\n    ad1848_attach(&sc->sc_ad1848);\n    \n    version = bus_space_read_1(sc->sc_iot, sc->sc_ioh, WSS_STATUS) & WSS_VERSMASK;\n    printf(\" (vers %d)\", version);\n    switch(sc->mad_chip_type) {\n    case MAD_82C928:\n\tprintf(\", 82C928\");\n\tbreak;\n    case MAD_OTI601D:\n\tprintf(\", OTI-601D\");\n\tbreak;\n    case MAD_82C929:\n\tprintf(\", 82C929\");\n\tbreak;\n    case MAD_82C931:\n\tprintf(\", 82C931\");\n\tbreak;\n    default:\n\tbreak;\n    }\n    printf(\"\\n\");\n\n    sc->sc_ad1848.parent = sc;\n\n    audio_attach_mi(&wss_hw_if, &sc->sc_ad1848, &sc->sc_dev);\n}"
  }
]