[
  {
    "function_name": "asc_DumpLog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/tc/asc.c",
    "lines": "2132-2156",
    "snippet": "void\nasc_DumpLog(str)\n\tchar *str;\n{\n\tregister struct asc_log *lp;\n\tregister u_int status;\n\n\tprintf(\"asc: %s: cmd %x bn %d cnt %d\\n\", str, asc_debug_cmd,\n\t\tasc_debug_bn, asc_debug_sz);\n\tlp = asc_logp;\n\tdo {\n\t\tstatus = lp->status;\n\t\tprintf(\"asc%d tgt %d status %x ss %x ir %x cond %d:%x msg %x resid %d\\n\",\n\t\t\tstatus >> 24,\n\t\t\tlp->target,\n\t\t\t(status >> 16) & 0xFF,\n\t\t\t(status >> 8) & 0xFF,\n\t\t\tstatus & 0XFF,\n\t\t\tlp->state,\n\t\t\tasc_scripts[lp->state].condition,\n\t\t\tlp->msg, lp->resid);\n\t\tif (++lp >= &asc_log[NLOG])\n\t\t\tlp = asc_log;\n\t} while (lp != asc_logp);\n}",
    "includes": [
      "#include <dev/tc/ascvar.h>",
      "#include <pmax/pmax/kmin.h>",
      "#include <pmax/pmax/asic.h>",
      "#include <pmax/dev/ascreg.h>",
      "#include <pmax/dev/scsi.h>",
      "#include <pmax/dev/device.h>",
      "#include <machine/bus.h>",
      "#include <machine/autoconf.h>",
      "#include <machine/cpu.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/tc/ioasicvar.h>",
      "#include <dev/tc/tcvar.h>",
      "#include <sys/reboot.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/errno.h>",
      "#include <sys/conf.h>",
      "#include <sys/buf.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <asc.h>"
    ],
    "macros_used": [
      "#define NLOG 32"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"asc%d tgt %d status %x ss %x ir %x cond %d:%x msg %x resid %d\\n\"",
            "status >> 24",
            "lp->target",
            "(status >> 16) & 0xFF",
            "(status >> 8) & 0xFF",
            "status & 0XFF",
            "lp->state",
            "asc_scripts[lp->state].condition",
            "lp->msg",
            "lp->resid"
          ],
          "line": 2144
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/tc/ascvar.h>\n#include <pmax/pmax/kmin.h>\n#include <pmax/pmax/asic.h>\n#include <pmax/dev/ascreg.h>\n#include <pmax/dev/scsi.h>\n#include <pmax/dev/device.h>\n#include <machine/bus.h>\n#include <machine/autoconf.h>\n#include <machine/cpu.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/tc/ioasicvar.h>\n#include <dev/tc/tcvar.h>\n#include <sys/reboot.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/errno.h>\n#include <sys/conf.h>\n#include <sys/buf.h>\n#include <sys/dkstat.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <asc.h>\n\n#define NLOG 32\n\nvoid\nasc_DumpLog(str)\n\tchar *str;\n{\n\tregister struct asc_log *lp;\n\tregister u_int status;\n\n\tprintf(\"asc: %s: cmd %x bn %d cnt %d\\n\", str, asc_debug_cmd,\n\t\tasc_debug_bn, asc_debug_sz);\n\tlp = asc_logp;\n\tdo {\n\t\tstatus = lp->status;\n\t\tprintf(\"asc%d tgt %d status %x ss %x ir %x cond %d:%x msg %x resid %d\\n\",\n\t\t\tstatus >> 24,\n\t\t\tlp->target,\n\t\t\t(status >> 16) & 0xFF,\n\t\t\t(status >> 8) & 0xFF,\n\t\t\tstatus & 0XFF,\n\t\t\tlp->state,\n\t\t\tasc_scripts[lp->state].condition,\n\t\t\tlp->msg, lp->resid);\n\t\tif (++lp >= &asc_log[NLOG])\n\t\t\tlp = asc_log;\n\t} while (lp != asc_logp);\n}"
  },
  {
    "function_name": "asc_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/tc/asc.c",
    "lines": "2111-2128",
    "snippet": "void\nasc_timeout(arg)\n\tvoid *arg;\n{\n\tint s = splbio();\n\tScsiCmd *scsicmd = (ScsiCmd *) arg;\n\n\tprintf(\"asc_timeout: cmd %p drive %d\\n\", scsicmd, scsicmd->sd->sd_drive);\n#ifdef DEBUG\n\tasc_DumpLog(\"asc_timeout\");\n#endif\n#if 0\n\tpanic(\"asc_timeout\");\n#else\n\tboot(RB_NOSYNC); /* XXX */\n#endif\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/tc/ascvar.h>",
      "#include <pmax/pmax/kmin.h>",
      "#include <pmax/pmax/asic.h>",
      "#include <pmax/dev/ascreg.h>",
      "#include <pmax/dev/scsi.h>",
      "#include <pmax/dev/device.h>",
      "#include <machine/bus.h>",
      "#include <machine/autoconf.h>",
      "#include <machine/cpu.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/tc/ioasicvar.h>",
      "#include <dev/tc/tcvar.h>",
      "#include <sys/reboot.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/errno.h>",
      "#include <sys/conf.h>",
      "#include <sys/buf.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <asc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 2127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boot",
          "args": [
            "RB_NOSYNC"
          ],
          "line": 2125
        },
        "resolved": true,
        "details": {
          "function_name": "rf_UnbootRaidframe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_driver.c",
          "lines": "194-213",
          "snippet": "int \nrf_UnbootRaidframe()\n{\n\tint     rc;\n\n\tRF_LOCK_MUTEX(configureMutex);\n\tif (configureCount) {\n\t\tRF_UNLOCK_MUTEX(configureMutex);\n\t\treturn (EBUSY);\n\t}\n\traidframe_booted = 0;\n\tRF_UNLOCK_MUTEX(configureMutex);\n\trc = rf_mutex_destroy(&configureMutex);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to destroy mutex file %s line %d rc=%d\\n\", __FILE__,\n\t\t    __LINE__, rc);\n\t\tRF_PANIC();\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include <sys/buf.h>",
            "#include \"rf_kintf.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_nwayxor.h\"",
            "#include \"rf_mcpair.h\"",
            "#include \"rf_memchunk.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_callback.h\"",
            "#include \"rf_revent.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_decluster.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_states.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_aselect.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include <sys/errno.h>",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_archs.h\"",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int raidframe_booted = 0;",
            "static int configureCount = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_options.h\"\n#include \"rf_driver.h\"\n#include \"rf_copyback.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_nwayxor.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_memchunk.h\"\n#include \"rf_engine.h\"\n#include \"rf_callback.h\"\n#include \"rf_revent.h\"\n#include \"rf_map.h\"\n#include \"rf_decluster.h\"\n#include \"rf_freelist.h\"\n#include \"rf_states.h\"\n#include \"rf_desc.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_utils.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_aselect.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n#include \"rf_archs.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic int raidframe_booted = 0;\nstatic int configureCount = 0;\n\nint \nrf_UnbootRaidframe()\n{\n\tint     rc;\n\n\tRF_LOCK_MUTEX(configureMutex);\n\tif (configureCount) {\n\t\tRF_UNLOCK_MUTEX(configureMutex);\n\t\treturn (EBUSY);\n\t}\n\traidframe_booted = 0;\n\tRF_UNLOCK_MUTEX(configureMutex);\n\trc = rf_mutex_destroy(&configureMutex);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to destroy mutex file %s line %d rc=%d\\n\", __FILE__,\n\t\t    __LINE__, rc);\n\t\tRF_PANIC();\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"asc_timeout\""
          ],
          "line": 2123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asc_DumpLog",
          "args": [
            "\"asc_timeout\""
          ],
          "line": 2120
        },
        "resolved": true,
        "details": {
          "function_name": "asc_DumpLog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/tc/asc.c",
          "lines": "2132-2156",
          "snippet": "void\nasc_DumpLog(str)\n\tchar *str;\n{\n\tregister struct asc_log *lp;\n\tregister u_int status;\n\n\tprintf(\"asc: %s: cmd %x bn %d cnt %d\\n\", str, asc_debug_cmd,\n\t\tasc_debug_bn, asc_debug_sz);\n\tlp = asc_logp;\n\tdo {\n\t\tstatus = lp->status;\n\t\tprintf(\"asc%d tgt %d status %x ss %x ir %x cond %d:%x msg %x resid %d\\n\",\n\t\t\tstatus >> 24,\n\t\t\tlp->target,\n\t\t\t(status >> 16) & 0xFF,\n\t\t\t(status >> 8) & 0xFF,\n\t\t\tstatus & 0XFF,\n\t\t\tlp->state,\n\t\t\tasc_scripts[lp->state].condition,\n\t\t\tlp->msg, lp->resid);\n\t\tif (++lp >= &asc_log[NLOG])\n\t\t\tlp = asc_log;\n\t} while (lp != asc_logp);\n}",
          "includes": [
            "#include <dev/tc/ascvar.h>",
            "#include <pmax/pmax/kmin.h>",
            "#include <pmax/pmax/asic.h>",
            "#include <pmax/dev/ascreg.h>",
            "#include <pmax/dev/scsi.h>",
            "#include <pmax/dev/device.h>",
            "#include <machine/bus.h>",
            "#include <machine/autoconf.h>",
            "#include <machine/cpu.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/tc/ioasicvar.h>",
            "#include <dev/tc/tcvar.h>",
            "#include <sys/reboot.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/errno.h>",
            "#include <sys/conf.h>",
            "#include <sys/buf.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <asc.h>"
          ],
          "macros_used": [
            "#define NLOG 32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/tc/ascvar.h>\n#include <pmax/pmax/kmin.h>\n#include <pmax/pmax/asic.h>\n#include <pmax/dev/ascreg.h>\n#include <pmax/dev/scsi.h>\n#include <pmax/dev/device.h>\n#include <machine/bus.h>\n#include <machine/autoconf.h>\n#include <machine/cpu.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/tc/ioasicvar.h>\n#include <dev/tc/tcvar.h>\n#include <sys/reboot.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/errno.h>\n#include <sys/conf.h>\n#include <sys/buf.h>\n#include <sys/dkstat.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <asc.h>\n\n#define NLOG 32\n\nvoid\nasc_DumpLog(str)\n\tchar *str;\n{\n\tregister struct asc_log *lp;\n\tregister u_int status;\n\n\tprintf(\"asc: %s: cmd %x bn %d cnt %d\\n\", str, asc_debug_cmd,\n\t\tasc_debug_bn, asc_debug_sz);\n\tlp = asc_logp;\n\tdo {\n\t\tstatus = lp->status;\n\t\tprintf(\"asc%d tgt %d status %x ss %x ir %x cond %d:%x msg %x resid %d\\n\",\n\t\t\tstatus >> 24,\n\t\t\tlp->target,\n\t\t\t(status >> 16) & 0xFF,\n\t\t\t(status >> 8) & 0xFF,\n\t\t\tstatus & 0XFF,\n\t\t\tlp->state,\n\t\t\tasc_scripts[lp->state].condition,\n\t\t\tlp->msg, lp->resid);\n\t\tif (++lp >= &asc_log[NLOG])\n\t\t\tlp = asc_log;\n\t} while (lp != asc_logp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"asc_timeout: cmd %p drive %d\\n\"",
            "scsicmd",
            "scsicmd->sd->sd_drive"
          ],
          "line": 2118
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 2115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/tc/ascvar.h>\n#include <pmax/pmax/kmin.h>\n#include <pmax/pmax/asic.h>\n#include <pmax/dev/ascreg.h>\n#include <pmax/dev/scsi.h>\n#include <pmax/dev/device.h>\n#include <machine/bus.h>\n#include <machine/autoconf.h>\n#include <machine/cpu.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/tc/ioasicvar.h>\n#include <dev/tc/tcvar.h>\n#include <sys/reboot.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/errno.h>\n#include <sys/conf.h>\n#include <sys/buf.h>\n#include <sys/dkstat.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <asc.h>\n\nvoid\nasc_timeout(arg)\n\tvoid *arg;\n{\n\tint s = splbio();\n\tScsiCmd *scsicmd = (ScsiCmd *) arg;\n\n\tprintf(\"asc_timeout: cmd %p drive %d\\n\", scsicmd, scsicmd->sd->sd_drive);\n#ifdef DEBUG\n\tasc_DumpLog(\"asc_timeout\");\n#endif\n#if 0\n\tpanic(\"asc_timeout\");\n#else\n\tboot(RB_NOSYNC); /* XXX */\n#endif\n\tsplx(s);\n}"
  },
  {
    "function_name": "asc_disconnect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/tc/asc.c",
    "lines": "2079-2109",
    "snippet": "static int\nasc_disconnect(asc, status, ss, ir)\n\tregister asc_softc_t asc;\n\tregister int status, ss, ir;\n{\n\tint i;\n#ifdef DIAGNOSTIC\n\t/* later Mach driver checks for late asych disconnect here. */\n\tregister State *state = &asc->st[asc->target];\n\n\tif (!(state->flags & DISCONN)) {\n\t\tprintf(\"asc_disconnect: device %d: DISCONN not set!\\n\",\n\t\t\tasc->target);\n\t}\n#endif /*DIAGNOSTIC*/\n\tasc->target = -1;\n\tasc->state = ASC_STATE_RESEL;\n\t/*\n\t * Look for another device that is ready.\n\t * May want to keep last one started and increment for fairness\n\t * rather than always starting at zero.\n\t */\n\tfor (i = 0; i < ASC_NCMD; i++) {\n\t\t/* don't restart a disconnected command */\n\t\tif (!asc->cmd[i] || asc->st[i].flags & DISCONN)\n\t\t\tcontinue;\n\t\tasc_startcmd(asc, i);\n\t\treturn (0);\n\t}\n\treturn (1);\n}",
    "includes": [
      "#include <dev/tc/ascvar.h>",
      "#include <pmax/pmax/kmin.h>",
      "#include <pmax/pmax/asic.h>",
      "#include <pmax/dev/ascreg.h>",
      "#include <pmax/dev/scsi.h>",
      "#include <pmax/dev/device.h>",
      "#include <machine/bus.h>",
      "#include <machine/autoconf.h>",
      "#include <machine/cpu.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/tc/ioasicvar.h>",
      "#include <dev/tc/tcvar.h>",
      "#include <sys/reboot.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/errno.h>",
      "#include <sys/conf.h>",
      "#include <sys/buf.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <asc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "asc_startcmd",
          "args": [
            "asc",
            "i"
          ],
          "line": 2105
        },
        "resolved": true,
        "details": {
          "function_name": "asc_startcmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/tc/asc.c",
          "lines": "660-809",
          "snippet": "static void\nasc_startcmd(asc, target)\n\tasc_softc_t asc;\n\tint target;\n{\n\tregister asc_regmap_t *regs;\n\tregister ScsiCmd *scsicmd;\n\tregister State *state;\n\tint len;\n\n\t/*\n\t * See if another target is currently selected on this SCSI bus.\n\t */\n\tif (asc->target >= 0)\n\t\treturn;\n\n\tregs = asc->regs;\n\n\t/*\n\t * If a reselection is in progress, it is Ok to ignore it since\n\t * the ASC will automatically cancel the command and flush\n\t * the FIFO if the ASC is reselected before the command starts.\n\t * If we try to use ASC_CMD_DISABLE_SEL, we can hang the system if\n\t * a reselect occurs before starting the command.\n\t */\n\n\tasc->state = ASC_STATE_BUSY;\n\tasc->target = target;\n\n\t/* cache some pointers */\n\tscsicmd = asc->cmd[target];\n\tstate = &asc->st[target];\n\n#ifdef DEBUG\n\tif (asc_debug > 1) {\n\t\tprintf(\"asc_startcmd: %s target %d cmd %x len %d\\n\",\n\t\t    scsicmd->sd->sd_driver->d_name, target,\n\t\t    scsicmd->cmd[0], scsicmd->buflen);\n\t}\n#endif\n\n\t/* Try to avoid reselect collisions */\n\tif ((regs->asc_status & (ASC_CSR_INT|SCSI_PHASE_MSG_IN)) ==\n\t    (ASC_CSR_INT|SCSI_PHASE_MSG_IN)) {\n/*\t\tprintf(\"asc_startcmd: possible reselect in progress\\n\"); */\n\t\treturn;\n\t}\n\n\t/*\n\t * Init the chip and target state.\n\t */\n\tstate->flags = state->flags & DID_SYNC;\n\tstate->error = 0;\n\tstate->script = (script_t *)0;\n\tstate->msg_out = SCSI_NO_OP;\n\n\tlen = scsicmd->cmdlen;\n\tstate->dmalen = len;\n\n\t/* check for simple SCSI command with no data transfer */\n\tif ((state->buflen = scsicmd->buflen) == 0) {\n\t\t/* check for sync negotiation */\n\t\tif ((scsicmd->flags & SCSICMD_USE_SYNC) &&\n\t\t    !(state->flags & DID_SYNC)) {\n\t\t\tasc->script = &asc_scripts[SCRIPT_TRY_SYNC];\n\t\t\tstate->flags |= TRY_SYNC;\n\t\t} else\n\t\t\tasc->script = &asc_scripts[SCRIPT_SIMPLE];\n\t\tstate->buf = (char *)0;\n\t} else if (scsicmd->flags & SCSICMD_DATA_TO_DEVICE) {\n\t\tasc->script = &asc_scripts[SCRIPT_DATA_OUT];\n\t\tstate->buf = scsicmd->buf;\n\t\tstate->flags |= DMA_OUT;\n\t} else {\n\t\tasc->script = &asc_scripts[SCRIPT_DATA_IN];\n\t\tstate->buf = scsicmd->buf;\n\t\tstate->flags |= DMA_IN;\n\t}\n\n#ifdef DEBUG\n\tasc_debug_cmd = scsicmd->cmd[0];\n\tif (scsicmd->cmd[0] == SCSI_READ_EXT) {\n\t\tasc_debug_bn = (scsicmd->cmd[2] << 24) |\n\t\t\t(scsicmd->cmd[3] << 16) |\n\t\t\t(scsicmd->cmd[4] << 8) |\n\t\t\tscsicmd->cmd[5];\n\t\tasc_debug_sz = (scsicmd->cmd[7] << 8) | scsicmd->cmd[8];\n\t}\n\tasc_logp->status = PACK(asc->sc_dev.dv_unit, 0, 0, asc_debug_cmd);\n\tasc_logp->target = asc->target;\n\tasc_logp->state = asc->script - asc_scripts;\n\tasc_logp->msg = SCSI_DIS_REC_IDENTIFY;\n\tasc_logp->resid = scsicmd->buflen;\n\tif (++asc_logp >= &asc_log[NLOG])\n\t\tasc_logp = asc_log;\n#endif\n\n\t/* preload the FIFO with the message to be sent */\n\tregs->asc_fifo = SCSI_DIS_REC_IDENTIFY;\n\ttc_mb();\n\n\t/* initialize the DMA */\n\tlen = (*asc->dma_start)(asc, state, scsicmd->cmd, ASCDMA_WRITE,\n\t   len, 0);\n\tASC_TC_PUT(regs, len);\n\treadback(regs->asc_cmd);\n\n\tregs->asc_dbus_id = target;\n\treadback(regs->asc_dbus_id);\n\tregs->asc_syn_p = state->sync_period;\n\treadback(regs->asc_syn_p);\n\tregs->asc_syn_o = state->sync_offset;\n\treadback(regs->asc_syn_o);\n\n\t/* Try to avoid reselect collisions */\n\tif ((regs->asc_status & (ASC_CSR_INT|SCSI_PHASE_MSG_IN)) ==\n\t    (ASC_CSR_INT|SCSI_PHASE_MSG_IN)) {\n/*\t\tprintf(\"asc_startcmd: reselect in progress (before select)\\n\");*/\n\t\treturn;\n\t}\n\n\tif (state->flags & TRY_SYNC)\n\t\tregs->asc_cmd = len = ASC_CMD_SEL_ATN_STOP;\n\telse\n\t\tregs->asc_cmd = len = ASC_CMD_SEL_ATN | ASC_CMD_DMA;\n\treadback(regs->asc_cmd);\n\n\t/* Try to avoid reselect collisions */\n\tif ((regs->asc_status & (ASC_CSR_INT|SCSI_PHASE_MSG_IN)) ==\n\t    (ASC_CSR_INT|SCSI_PHASE_MSG_IN)) {\n/*\t\tprintf(\"asc_startcmd: reselect in progress after select\\n\");*/\n\t\treturn;\n\t} else {\n\t\t/*\n\t\t * Here's a potentially nasty but infrequent problem:  a\n\t\t * reselect may have occurred, but did not interrupt.\n\t\t */\n\t\tif (regs->asc_cmd != len &&\n\t\t    regs->asc_cmd == (ASC_CMD_NOP|ASC_CMD_DMA)) {\n\t\t    \tif ((regs->asc_status & ASC_CSR_INT) == 0) {\n\t\t    \t\tdelay(250);\n\t\t    \t\tif (regs->asc_status == SCSI_PHASE_MSG_IN) {\n\t\t    \t\t\tprintf(\"asc_startcmd: reselect failed to interrupt?\\n\");\n\t\t    \t\t\t/* XXXX THIS NEEDS FIXING */\n\t\t    \t\t}\n\t\t    \t}\n\t\t}\n\t}\n\n}",
          "includes": [
            "#include <dev/tc/ascvar.h>",
            "#include <pmax/pmax/kmin.h>",
            "#include <pmax/pmax/asic.h>",
            "#include <pmax/dev/ascreg.h>",
            "#include <pmax/dev/scsi.h>",
            "#include <pmax/dev/device.h>",
            "#include <machine/bus.h>",
            "#include <machine/autoconf.h>",
            "#include <machine/cpu.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/tc/ioasicvar.h>",
            "#include <dev/tc/tcvar.h>",
            "#include <sys/reboot.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/errno.h>",
            "#include <sys/conf.h>",
            "#include <sys/buf.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <asc.h>"
          ],
          "macros_used": [
            "#define\tSCRIPT_TRY_SYNC\t\t12",
            "#define\tSCRIPT_SIMPLE\t\t6",
            "#define\tSCRIPT_DATA_OUT\t\t3",
            "#define\tSCRIPT_DATA_IN\t\t0",
            "#define NLOG 32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/tc/ascvar.h>\n#include <pmax/pmax/kmin.h>\n#include <pmax/pmax/asic.h>\n#include <pmax/dev/ascreg.h>\n#include <pmax/dev/scsi.h>\n#include <pmax/dev/device.h>\n#include <machine/bus.h>\n#include <machine/autoconf.h>\n#include <machine/cpu.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/tc/ioasicvar.h>\n#include <dev/tc/tcvar.h>\n#include <sys/reboot.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/errno.h>\n#include <sys/conf.h>\n#include <sys/buf.h>\n#include <sys/dkstat.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <asc.h>\n\n#define\tSCRIPT_TRY_SYNC\t\t12\n#define\tSCRIPT_SIMPLE\t\t6\n#define\tSCRIPT_DATA_OUT\t\t3\n#define\tSCRIPT_DATA_IN\t\t0\n#define NLOG 32\n\nstatic void\nasc_startcmd(asc, target)\n\tasc_softc_t asc;\n\tint target;\n{\n\tregister asc_regmap_t *regs;\n\tregister ScsiCmd *scsicmd;\n\tregister State *state;\n\tint len;\n\n\t/*\n\t * See if another target is currently selected on this SCSI bus.\n\t */\n\tif (asc->target >= 0)\n\t\treturn;\n\n\tregs = asc->regs;\n\n\t/*\n\t * If a reselection is in progress, it is Ok to ignore it since\n\t * the ASC will automatically cancel the command and flush\n\t * the FIFO if the ASC is reselected before the command starts.\n\t * If we try to use ASC_CMD_DISABLE_SEL, we can hang the system if\n\t * a reselect occurs before starting the command.\n\t */\n\n\tasc->state = ASC_STATE_BUSY;\n\tasc->target = target;\n\n\t/* cache some pointers */\n\tscsicmd = asc->cmd[target];\n\tstate = &asc->st[target];\n\n#ifdef DEBUG\n\tif (asc_debug > 1) {\n\t\tprintf(\"asc_startcmd: %s target %d cmd %x len %d\\n\",\n\t\t    scsicmd->sd->sd_driver->d_name, target,\n\t\t    scsicmd->cmd[0], scsicmd->buflen);\n\t}\n#endif\n\n\t/* Try to avoid reselect collisions */\n\tif ((regs->asc_status & (ASC_CSR_INT|SCSI_PHASE_MSG_IN)) ==\n\t    (ASC_CSR_INT|SCSI_PHASE_MSG_IN)) {\n/*\t\tprintf(\"asc_startcmd: possible reselect in progress\\n\"); */\n\t\treturn;\n\t}\n\n\t/*\n\t * Init the chip and target state.\n\t */\n\tstate->flags = state->flags & DID_SYNC;\n\tstate->error = 0;\n\tstate->script = (script_t *)0;\n\tstate->msg_out = SCSI_NO_OP;\n\n\tlen = scsicmd->cmdlen;\n\tstate->dmalen = len;\n\n\t/* check for simple SCSI command with no data transfer */\n\tif ((state->buflen = scsicmd->buflen) == 0) {\n\t\t/* check for sync negotiation */\n\t\tif ((scsicmd->flags & SCSICMD_USE_SYNC) &&\n\t\t    !(state->flags & DID_SYNC)) {\n\t\t\tasc->script = &asc_scripts[SCRIPT_TRY_SYNC];\n\t\t\tstate->flags |= TRY_SYNC;\n\t\t} else\n\t\t\tasc->script = &asc_scripts[SCRIPT_SIMPLE];\n\t\tstate->buf = (char *)0;\n\t} else if (scsicmd->flags & SCSICMD_DATA_TO_DEVICE) {\n\t\tasc->script = &asc_scripts[SCRIPT_DATA_OUT];\n\t\tstate->buf = scsicmd->buf;\n\t\tstate->flags |= DMA_OUT;\n\t} else {\n\t\tasc->script = &asc_scripts[SCRIPT_DATA_IN];\n\t\tstate->buf = scsicmd->buf;\n\t\tstate->flags |= DMA_IN;\n\t}\n\n#ifdef DEBUG\n\tasc_debug_cmd = scsicmd->cmd[0];\n\tif (scsicmd->cmd[0] == SCSI_READ_EXT) {\n\t\tasc_debug_bn = (scsicmd->cmd[2] << 24) |\n\t\t\t(scsicmd->cmd[3] << 16) |\n\t\t\t(scsicmd->cmd[4] << 8) |\n\t\t\tscsicmd->cmd[5];\n\t\tasc_debug_sz = (scsicmd->cmd[7] << 8) | scsicmd->cmd[8];\n\t}\n\tasc_logp->status = PACK(asc->sc_dev.dv_unit, 0, 0, asc_debug_cmd);\n\tasc_logp->target = asc->target;\n\tasc_logp->state = asc->script - asc_scripts;\n\tasc_logp->msg = SCSI_DIS_REC_IDENTIFY;\n\tasc_logp->resid = scsicmd->buflen;\n\tif (++asc_logp >= &asc_log[NLOG])\n\t\tasc_logp = asc_log;\n#endif\n\n\t/* preload the FIFO with the message to be sent */\n\tregs->asc_fifo = SCSI_DIS_REC_IDENTIFY;\n\ttc_mb();\n\n\t/* initialize the DMA */\n\tlen = (*asc->dma_start)(asc, state, scsicmd->cmd, ASCDMA_WRITE,\n\t   len, 0);\n\tASC_TC_PUT(regs, len);\n\treadback(regs->asc_cmd);\n\n\tregs->asc_dbus_id = target;\n\treadback(regs->asc_dbus_id);\n\tregs->asc_syn_p = state->sync_period;\n\treadback(regs->asc_syn_p);\n\tregs->asc_syn_o = state->sync_offset;\n\treadback(regs->asc_syn_o);\n\n\t/* Try to avoid reselect collisions */\n\tif ((regs->asc_status & (ASC_CSR_INT|SCSI_PHASE_MSG_IN)) ==\n\t    (ASC_CSR_INT|SCSI_PHASE_MSG_IN)) {\n/*\t\tprintf(\"asc_startcmd: reselect in progress (before select)\\n\");*/\n\t\treturn;\n\t}\n\n\tif (state->flags & TRY_SYNC)\n\t\tregs->asc_cmd = len = ASC_CMD_SEL_ATN_STOP;\n\telse\n\t\tregs->asc_cmd = len = ASC_CMD_SEL_ATN | ASC_CMD_DMA;\n\treadback(regs->asc_cmd);\n\n\t/* Try to avoid reselect collisions */\n\tif ((regs->asc_status & (ASC_CSR_INT|SCSI_PHASE_MSG_IN)) ==\n\t    (ASC_CSR_INT|SCSI_PHASE_MSG_IN)) {\n/*\t\tprintf(\"asc_startcmd: reselect in progress after select\\n\");*/\n\t\treturn;\n\t} else {\n\t\t/*\n\t\t * Here's a potentially nasty but infrequent problem:  a\n\t\t * reselect may have occurred, but did not interrupt.\n\t\t */\n\t\tif (regs->asc_cmd != len &&\n\t\t    regs->asc_cmd == (ASC_CMD_NOP|ASC_CMD_DMA)) {\n\t\t    \tif ((regs->asc_status & ASC_CSR_INT) == 0) {\n\t\t    \t\tdelay(250);\n\t\t    \t\tif (regs->asc_status == SCSI_PHASE_MSG_IN) {\n\t\t    \t\t\tprintf(\"asc_startcmd: reselect failed to interrupt?\\n\");\n\t\t    \t\t\t/* XXXX THIS NEEDS FIXING */\n\t\t    \t\t}\n\t\t    \t}\n\t\t}\n\t}\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"asc_disconnect: device %d: DISCONN not set!\\n\"",
            "asc->target"
          ],
          "line": 2090
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/tc/ascvar.h>\n#include <pmax/pmax/kmin.h>\n#include <pmax/pmax/asic.h>\n#include <pmax/dev/ascreg.h>\n#include <pmax/dev/scsi.h>\n#include <pmax/dev/device.h>\n#include <machine/bus.h>\n#include <machine/autoconf.h>\n#include <machine/cpu.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/tc/ioasicvar.h>\n#include <dev/tc/tcvar.h>\n#include <sys/reboot.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/errno.h>\n#include <sys/conf.h>\n#include <sys/buf.h>\n#include <sys/dkstat.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <asc.h>\n\nstatic int\nasc_disconnect(asc, status, ss, ir)\n\tregister asc_softc_t asc;\n\tregister int status, ss, ir;\n{\n\tint i;\n#ifdef DIAGNOSTIC\n\t/* later Mach driver checks for late asych disconnect here. */\n\tregister State *state = &asc->st[asc->target];\n\n\tif (!(state->flags & DISCONN)) {\n\t\tprintf(\"asc_disconnect: device %d: DISCONN not set!\\n\",\n\t\t\tasc->target);\n\t}\n#endif /*DIAGNOSTIC*/\n\tasc->target = -1;\n\tasc->state = ASC_STATE_RESEL;\n\t/*\n\t * Look for another device that is ready.\n\t * May want to keep last one started and increment for fairness\n\t * rather than always starting at zero.\n\t */\n\tfor (i = 0; i < ASC_NCMD; i++) {\n\t\t/* don't restart a disconnected command */\n\t\tif (!asc->cmd[i] || asc->st[i].flags & DISCONN)\n\t\t\tcontinue;\n\t\tasc_startcmd(asc, i);\n\t\treturn (0);\n\t}\n\treturn (1);\n}"
  },
  {
    "function_name": "asc_msg_in",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/tc/asc.c",
    "lines": "1885-2076",
    "snippet": "static int\nasc_msg_in(asc, status, ss, ir)\n\tregister asc_softc_t asc;\n\tregister int status, ss, ir;\n{\n\tregister asc_regmap_t *regs = asc->regs;\n\tregister State *state = &asc->st[asc->target];\n\tregister int msg;\n\tint i;\n\n\t/* read one message byte */\n\tmsg = regs->asc_fifo;\n#ifdef DEBUG\n\tif (asc_logp == asc_log)\n\t\tasc_log[NLOG - 1].msg = msg;\n\telse\n\t\tasc_logp[-1].msg = msg;\n#endif\n\n\t/* check for multi-byte message */\n\tif (state->msglen != 0) {\n\t\t/* first byte is the message length */\n\t\tif (state->msglen < 0) {\n\t\t\tstate->msglen = msg;\n\t\t\treturn (1);\n\t\t}\n\t\tif (state->msgcnt >= state->msglen) {\n\t\t  \tprintf(\"asc: msg_in too big, msgcnt %d msglen %d\\n\",\n\t\t\t       state->msgcnt, state->msglen);\n\t\t\tgoto abort;\n\t\t}\n\t\tstate->msg_in[state->msgcnt++] = msg;\n\n\t\t/* did we just read the last byte of the message? */\n\t\tif (state->msgcnt != state->msglen)\n\t\t\treturn (1);\n\n\t\t/* process an extended message */\n#ifdef DEBUG\n\t\tif (asc_debug > 2)\n\t\t\tprintf(\"asc_msg_in: msg %x %x %x\\n\",\n\t\t\t\tstate->msg_in[0],\n\t\t\t\tstate->msg_in[1],\n\t\t\t\tstate->msg_in[2]);\n#endif\n\t\tswitch (state->msg_in[0]) {\n\t\tcase SCSI_SYNCHRONOUS_XFER:\n\t\t\tstate->flags |= DID_SYNC;\n\t\t\tstate->sync_offset = state->msg_in[2];\n\n\t\t\t/* convert SCSI period to ASC period */\n\t\t\ti = state->msg_in[1] / asc->tb_ticks;\n\t\t\tif (i < asc->min_period)\n\t\t\t\ti = asc->min_period;\n\t\t\telse if (i >= asc->max_period) {\n\t\t\t\t/* can't do sync transfer, period too long */\n\t\t\t\tprintf(\"%s: SCSI device %d: sync xfer period too long (%d)\\n\",\n\t\t\t\t\tasc->sc_dev.dv_xname, asc->target, i);\n\t\t\t\ti = asc->max_period;\n\t\t\t\tstate->sync_offset = 0;\n\t\t\t}\n\t\t\tif ((i * asc->tb_ticks) != state->msg_in[1])\n\t\t\t\ti++;\n\t\t\tstate->sync_period = i & 0x1F;\n\n\t\t\t/*\n\t\t\t * If this is a request, check minimums and\n\t\t\t * send back an acknowledge.\n\t\t\t */\n\t\t\tif (!(state->flags & TRY_SYNC)) {\n\t\t\t\tregs->asc_cmd = ASC_CMD_SET_ATN;\n\t\t\t\treadback(regs->asc_cmd);\n\n\t\t\t\tif (state->sync_period < asc->min_period)\n\t\t\t\t\tstate->sync_period =\n\t\t\t\t\t\tasc->min_period;\n\t\t\t\tif (state->sync_offset > ASC_MAX_OFFSET)\n\t\t\t\t\tstate->sync_offset =\n\t\t\t\t\t\tASC_MAX_OFFSET;\n\t\t\t\tasc->script = &asc_scripts[SCRIPT_REPLY_SYNC];\n\t\t\t\tregs->asc_syn_p = state->sync_period;\n\t\t\t\treadback(regs->asc_syn_p);\n\t\t\t\tregs->asc_syn_o = state->sync_offset;\n\t\t\t\treadback(regs->asc_syn_o);\n\t\t\t\tregs->asc_cmd = ASC_CMD_MSG_ACPT;\n\t\t\t\treadback(regs->asc_cmd);\n\t\t\t\treturn (0);\n\t\t\t}\n\n\t\t\tregs->asc_syn_p = state->sync_period;\n\t\t\treadback(regs->asc_syn_p);\n\t\t\tregs->asc_syn_o = state->sync_offset;\n\t\t\treadback(regs->asc_syn_o);\n\t\t\tgoto done;\n\n\t\tdefault:\n\t\t\tprintf(\"%s: SCSI device %d: rejecting extended message 0x%x\\n\",\n\t\t\t\tasc->sc_dev.dv_xname, asc->target,\n\t\t\t\tstate->msg_in[0]);\n\t\t\tgoto reject;\n\t\t}\n\t}\n\n\t/* process first byte of a message */\n#ifdef DEBUG\n\tif (asc_debug > 2)\n\t\tprintf(\"asc_msg_in: msg %x\\n\", msg);\n#endif\n\tswitch (msg) {\n#if 0\n\tcase SCSI_MESSAGE_REJECT:\n\t\tprintf(\" did not like SYNCH xfer \"); /* XXX */\n\t\tstate->flags |= DID_SYNC;\n\t\tregs->asc_cmd = ASC_CMD_MSG_ACPT;\n\t\treadback(regs->asc_cmd);\n\t\tstatus = asc_wait(regs, ASC_CSR_INT);\n\t\tir = regs->asc_intr;\n\t\t/* some just break out here, some dont */\n\t\tif (ASC_PHASE(status) == SCSI_PHASE_MSG_OUT) {\n\t\t\tregs->asc_fifo = SCSI_ABORT;\n\t\t\tregs->asc_cmd = ASC_CMD_XFER_INFO;\n\t\t\treadback(regs->asc_cmd);\n\t\t\tstatus = asc_wait(regs, ASC_CSR_INT);\n\t\t\tir = regs->asc_intr;\n\t\t}\n\t\tif (ir & ASC_INT_DISC) {\n\t\t\tasc_end(asc, status, 0, ir);\n\t\t\treturn (0);\n\t\t}\n\t\tgoto status;\n#endif /*0*/\n\n\tcase SCSI_EXTENDED_MSG: /* read an extended message */\n\t\t/* setup to read message length next */\n\t\tstate->msglen = -1;\n\t\tstate->msgcnt = 0;\n\t\treturn (1);\n\n\tcase SCSI_NO_OP:\n\t\tbreak;\n\n\tcase SCSI_SAVE_DATA_POINTER:\n\t\t/* expect another message */\n\t\treturn (1);\n\n\tcase SCSI_RESTORE_POINTERS:\n\t\t/*\n\t\t * Need to do the following if resuming synchonous data in\n\t\t * on an odd byte boundary.\n\t\tregs->asc_cnfg2 |= ASC_CNFG2_RFB;\n\t\t */\n\t\tbreak;\n\n\tcase SCSI_DISCONNECT:\n\t\tif (state->flags & DISCONN) {\n\t\t\tprintf(\"asc: disconnected target %d disconnecting again\\n\",\n\t\t\t    asc->target);\n\t\t\tgoto abort;\n\t\t}\n\t\tstate->flags |= DISCONN;\n\t\tregs->asc_cmd = ASC_CMD_MSG_ACPT;\n\t\treadback(regs->asc_cmd);\n\t\tasc->script = &asc_scripts[SCRIPT_DISCONNECT];\n\t\treturn (0);\n\n\tdefault:\n\t\tprintf(\"%s: SCSI device %d: rejecting message 0x%x\\n\",\n\t\t\tasc->sc_dev.dv_xname, asc->target, msg);\n\treject:\n\t\t/* request a message out before acknowledging this message */\n\t\tstate->msg_out = SCSI_MESSAGE_REJECT;\n\t\tregs->asc_cmd = ASC_CMD_SET_ATN;\n\t\treadback(regs->asc_cmd);\n\t}\n\ndone:\n\t/* return to original script */\n\tregs->asc_cmd = ASC_CMD_MSG_ACPT;\n\treadback(regs->asc_cmd);\n\tif (!state->script) {\n\t  \tprintf(\"asc_msg_in: target %d, no script?\\n\", asc->target);\n\n\tabort:\n#ifdef DEBUG\n\t\tasc_DumpLog(\"asc_msg_in\");\n#endif\n\t\tpanic(\"asc_msg_in\");\n\t}\n\tasc->script = state->script;\n\tstate->script = (script_t *)0;\n\treturn (0);\n}",
    "includes": [
      "#include <dev/tc/ascvar.h>",
      "#include <pmax/pmax/kmin.h>",
      "#include <pmax/pmax/asic.h>",
      "#include <pmax/dev/ascreg.h>",
      "#include <pmax/dev/scsi.h>",
      "#include <pmax/dev/device.h>",
      "#include <machine/bus.h>",
      "#include <machine/autoconf.h>",
      "#include <machine/cpu.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/tc/ioasicvar.h>",
      "#include <dev/tc/tcvar.h>",
      "#include <sys/reboot.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/errno.h>",
      "#include <sys/conf.h>",
      "#include <sys/buf.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <asc.h>"
    ],
    "macros_used": [
      "#define\tSCRIPT_DISCONNECT\t15",
      "#define\tSCRIPT_REPLY_SYNC\t11",
      "#define NLOG 32"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"asc_msg_in\""
          ],
          "line": 2071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asc_DumpLog",
          "args": [
            "\"asc_msg_in\""
          ],
          "line": 2069
        },
        "resolved": true,
        "details": {
          "function_name": "asc_DumpLog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/tc/asc.c",
          "lines": "2132-2156",
          "snippet": "void\nasc_DumpLog(str)\n\tchar *str;\n{\n\tregister struct asc_log *lp;\n\tregister u_int status;\n\n\tprintf(\"asc: %s: cmd %x bn %d cnt %d\\n\", str, asc_debug_cmd,\n\t\tasc_debug_bn, asc_debug_sz);\n\tlp = asc_logp;\n\tdo {\n\t\tstatus = lp->status;\n\t\tprintf(\"asc%d tgt %d status %x ss %x ir %x cond %d:%x msg %x resid %d\\n\",\n\t\t\tstatus >> 24,\n\t\t\tlp->target,\n\t\t\t(status >> 16) & 0xFF,\n\t\t\t(status >> 8) & 0xFF,\n\t\t\tstatus & 0XFF,\n\t\t\tlp->state,\n\t\t\tasc_scripts[lp->state].condition,\n\t\t\tlp->msg, lp->resid);\n\t\tif (++lp >= &asc_log[NLOG])\n\t\t\tlp = asc_log;\n\t} while (lp != asc_logp);\n}",
          "includes": [
            "#include <dev/tc/ascvar.h>",
            "#include <pmax/pmax/kmin.h>",
            "#include <pmax/pmax/asic.h>",
            "#include <pmax/dev/ascreg.h>",
            "#include <pmax/dev/scsi.h>",
            "#include <pmax/dev/device.h>",
            "#include <machine/bus.h>",
            "#include <machine/autoconf.h>",
            "#include <machine/cpu.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/tc/ioasicvar.h>",
            "#include <dev/tc/tcvar.h>",
            "#include <sys/reboot.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/errno.h>",
            "#include <sys/conf.h>",
            "#include <sys/buf.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <asc.h>"
          ],
          "macros_used": [
            "#define NLOG 32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/tc/ascvar.h>\n#include <pmax/pmax/kmin.h>\n#include <pmax/pmax/asic.h>\n#include <pmax/dev/ascreg.h>\n#include <pmax/dev/scsi.h>\n#include <pmax/dev/device.h>\n#include <machine/bus.h>\n#include <machine/autoconf.h>\n#include <machine/cpu.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/tc/ioasicvar.h>\n#include <dev/tc/tcvar.h>\n#include <sys/reboot.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/errno.h>\n#include <sys/conf.h>\n#include <sys/buf.h>\n#include <sys/dkstat.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <asc.h>\n\n#define NLOG 32\n\nvoid\nasc_DumpLog(str)\n\tchar *str;\n{\n\tregister struct asc_log *lp;\n\tregister u_int status;\n\n\tprintf(\"asc: %s: cmd %x bn %d cnt %d\\n\", str, asc_debug_cmd,\n\t\tasc_debug_bn, asc_debug_sz);\n\tlp = asc_logp;\n\tdo {\n\t\tstatus = lp->status;\n\t\tprintf(\"asc%d tgt %d status %x ss %x ir %x cond %d:%x msg %x resid %d\\n\",\n\t\t\tstatus >> 24,\n\t\t\tlp->target,\n\t\t\t(status >> 16) & 0xFF,\n\t\t\t(status >> 8) & 0xFF,\n\t\t\tstatus & 0XFF,\n\t\t\tlp->state,\n\t\t\tasc_scripts[lp->state].condition,\n\t\t\tlp->msg, lp->resid);\n\t\tif (++lp >= &asc_log[NLOG])\n\t\t\tlp = asc_log;\n\t} while (lp != asc_logp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"asc_msg_in: target %d, no script?\\n\"",
            "asc->target"
          ],
          "line": 2065
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "readback",
          "args": [
            "regs->asc_cmd"
          ],
          "line": 2063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readback",
          "args": [
            "regs->asc_cmd"
          ],
          "line": 2057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readback",
          "args": [
            "regs->asc_cmd"
          ],
          "line": 2046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asc_end",
          "args": [
            "asc",
            "status",
            "0",
            "ir"
          ],
          "line": 2011
        },
        "resolved": true,
        "details": {
          "function_name": "asc_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/tc/asc.c",
          "lines": "1366-1448",
          "snippet": "static int\nasc_end(asc, status, ss, ir)\n\tregister asc_softc_t asc;\n\tregister int status, ss, ir;\n{\n\tregister ScsiCmd *scsicmd;\n\tregister State *state;\n\tregister int i, target;\n\n\tasc->state = ASC_STATE_IDLE;\n\ttarget = asc->target;\n\tasc->target = -1;\n\tscsicmd = asc->cmd[target];\n\tasc->cmd[target] = (ScsiCmd *)0;\n\tstate = &asc->st[target];\n\tuntimeout(asc_timeout, scsicmd);\n\n#ifdef DEBUG\n\tif (asc_debug > 1) {\n\t\tprintf(\"asc_end: %s target %d cmd %x err %d resid %d\\n\",\n\t\t\tscsicmd->sd->sd_driver->d_name, target,\n\t\t\tscsicmd->cmd[0], state->error, state->buflen);\n\t}\n#endif\n#ifdef DIAGNOSTIC\n\tif (target < 0 || !scsicmd)\n\t\tpanic(\"asc_end\");\n#endif\n\n\t/* look for disconnected devices */\n\tfor (i = 0; i < ASC_NCMD; i++) {\n\t\tif (!asc->cmd[i] || !(asc->st[i].flags & DISCONN))\n\t\t\tcontinue;\n\t\tasc->regs->asc_cmd = ASC_CMD_ENABLE_SEL;\n\t\treadback(asc->regs->asc_cmd);\n\t\tasc->state = ASC_STATE_RESEL;\n\t\tasc->script = &asc_scripts[SCRIPT_RESEL];\n\t\tbreak;\n\t}\n\n#ifdef USE_NEW_SCSI\n\tif(scsicmd->error == XS_NOERROR && !(state->flags & CHECK_SENSE)) {\n\t\tif((state->statusByte & ST_MASK) == SCSI_CHECK) {\n\t\t\tstruct scsi_sense *ss = (void *)&state->cmd;\n\t\t\t/* Save return values */\n\t\t\tscsicmd->resid = state->buflen;\n\t\t\tscsicmd->status = state->statusByte;\n\t\t\t/* Set up sense request command */\n\t\t\tbzero(ss, sizeof(*ss));\n\t\t\tss->opcode = REQUEST_SENSE;\n\t\t\tss->byte2 = sc_link->lun << 5;\n\t\t\tss->length = sizeof(struct scsi_sense_data);\n\t\t\tstate->cmdlen = sizeof(*ss);\n\t\t\tstate->buf = (vm_offset_t)&scsicmd->sense;\n\t\t\tstate->buflen = sizeof(struct scsi_sense_data);\n\t\t\tstate->flags |= CHECK_SENSE;\n\t\t\tMachFlushDCache(state->buf, state->buflen);\n\t\t\tasc->cmd[target] = scsicmd;\n\t\t\tasc_startcmd(asc, target);\n\t\t\treturn(0);\n\t\t}\n\t}\n#endif /*USE_NEW_SCSI*/\n\n\t/*\n\t * Look for another device that is ready.\n\t * May want to keep last one started and increment for fairness\n\t * rather than always starting at zero.\n\t */\n\tfor (i = 0; i < ASC_NCMD; i++) {\n\t\t/* don't restart a disconnected command */\n\t\tif (!asc->cmd[i] || (asc->st[i].flags & DISCONN))\n\t\t\tcontinue;\n\t\tasc_startcmd(asc, i);\n\t\tbreak;\n\t}\n\n\t/* signal device driver that the command is done */\n\t(*scsicmd->sd->sd_driver->d_done)(scsicmd->unit, state->error,\n\t\tstate->buflen, state->statusByte);\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/tc/ascvar.h>",
            "#include <pmax/pmax/kmin.h>",
            "#include <pmax/pmax/asic.h>",
            "#include <pmax/dev/ascreg.h>",
            "#include <pmax/dev/scsi.h>",
            "#include <pmax/dev/device.h>",
            "#include <machine/bus.h>",
            "#include <machine/autoconf.h>",
            "#include <machine/cpu.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/tc/ioasicvar.h>",
            "#include <dev/tc/tcvar.h>",
            "#include <sys/reboot.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/errno.h>",
            "#include <sys/conf.h>",
            "#include <sys/buf.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <asc.h>"
          ],
          "macros_used": [
            "#define\tSCRIPT_RESEL\t\t16"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/tc/ascvar.h>\n#include <pmax/pmax/kmin.h>\n#include <pmax/pmax/asic.h>\n#include <pmax/dev/ascreg.h>\n#include <pmax/dev/scsi.h>\n#include <pmax/dev/device.h>\n#include <machine/bus.h>\n#include <machine/autoconf.h>\n#include <machine/cpu.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/tc/ioasicvar.h>\n#include <dev/tc/tcvar.h>\n#include <sys/reboot.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/errno.h>\n#include <sys/conf.h>\n#include <sys/buf.h>\n#include <sys/dkstat.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <asc.h>\n\n#define\tSCRIPT_RESEL\t\t16\n\nstatic int\nasc_end(asc, status, ss, ir)\n\tregister asc_softc_t asc;\n\tregister int status, ss, ir;\n{\n\tregister ScsiCmd *scsicmd;\n\tregister State *state;\n\tregister int i, target;\n\n\tasc->state = ASC_STATE_IDLE;\n\ttarget = asc->target;\n\tasc->target = -1;\n\tscsicmd = asc->cmd[target];\n\tasc->cmd[target] = (ScsiCmd *)0;\n\tstate = &asc->st[target];\n\tuntimeout(asc_timeout, scsicmd);\n\n#ifdef DEBUG\n\tif (asc_debug > 1) {\n\t\tprintf(\"asc_end: %s target %d cmd %x err %d resid %d\\n\",\n\t\t\tscsicmd->sd->sd_driver->d_name, target,\n\t\t\tscsicmd->cmd[0], state->error, state->buflen);\n\t}\n#endif\n#ifdef DIAGNOSTIC\n\tif (target < 0 || !scsicmd)\n\t\tpanic(\"asc_end\");\n#endif\n\n\t/* look for disconnected devices */\n\tfor (i = 0; i < ASC_NCMD; i++) {\n\t\tif (!asc->cmd[i] || !(asc->st[i].flags & DISCONN))\n\t\t\tcontinue;\n\t\tasc->regs->asc_cmd = ASC_CMD_ENABLE_SEL;\n\t\treadback(asc->regs->asc_cmd);\n\t\tasc->state = ASC_STATE_RESEL;\n\t\tasc->script = &asc_scripts[SCRIPT_RESEL];\n\t\tbreak;\n\t}\n\n#ifdef USE_NEW_SCSI\n\tif(scsicmd->error == XS_NOERROR && !(state->flags & CHECK_SENSE)) {\n\t\tif((state->statusByte & ST_MASK) == SCSI_CHECK) {\n\t\t\tstruct scsi_sense *ss = (void *)&state->cmd;\n\t\t\t/* Save return values */\n\t\t\tscsicmd->resid = state->buflen;\n\t\t\tscsicmd->status = state->statusByte;\n\t\t\t/* Set up sense request command */\n\t\t\tbzero(ss, sizeof(*ss));\n\t\t\tss->opcode = REQUEST_SENSE;\n\t\t\tss->byte2 = sc_link->lun << 5;\n\t\t\tss->length = sizeof(struct scsi_sense_data);\n\t\t\tstate->cmdlen = sizeof(*ss);\n\t\t\tstate->buf = (vm_offset_t)&scsicmd->sense;\n\t\t\tstate->buflen = sizeof(struct scsi_sense_data);\n\t\t\tstate->flags |= CHECK_SENSE;\n\t\t\tMachFlushDCache(state->buf, state->buflen);\n\t\t\tasc->cmd[target] = scsicmd;\n\t\t\tasc_startcmd(asc, target);\n\t\t\treturn(0);\n\t\t}\n\t}\n#endif /*USE_NEW_SCSI*/\n\n\t/*\n\t * Look for another device that is ready.\n\t * May want to keep last one started and increment for fairness\n\t * rather than always starting at zero.\n\t */\n\tfor (i = 0; i < ASC_NCMD; i++) {\n\t\t/* don't restart a disconnected command */\n\t\tif (!asc->cmd[i] || (asc->st[i].flags & DISCONN))\n\t\t\tcontinue;\n\t\tasc_startcmd(asc, i);\n\t\tbreak;\n\t}\n\n\t/* signal device driver that the command is done */\n\t(*scsicmd->sd->sd_driver->d_done)(scsicmd->unit, state->error,\n\t\tstate->buflen, state->statusByte);\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "asc_wait",
          "args": [
            "regs",
            "ASC_CSR_INT"
          ],
          "line": 2007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readback",
          "args": [
            "regs->asc_cmd"
          ],
          "line": 2006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASC_PHASE",
          "args": [
            "status"
          ],
          "line": 2003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asc_wait",
          "args": [
            "regs",
            "ASC_CSR_INT"
          ],
          "line": 2000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readback",
          "args": [
            "regs->asc_cmd"
          ],
          "line": 1999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readback",
          "args": [
            "regs->asc_syn_o"
          ],
          "line": 1977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readback",
          "args": [
            "regs->asc_syn_p"
          ],
          "line": 1975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readback",
          "args": [
            "regs->asc_cmd"
          ],
          "line": 1970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readback",
          "args": [
            "regs->asc_syn_o"
          ],
          "line": 1968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readback",
          "args": [
            "regs->asc_syn_p"
          ],
          "line": 1966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readback",
          "args": [
            "regs->asc_cmd"
          ],
          "line": 1956
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/tc/ascvar.h>\n#include <pmax/pmax/kmin.h>\n#include <pmax/pmax/asic.h>\n#include <pmax/dev/ascreg.h>\n#include <pmax/dev/scsi.h>\n#include <pmax/dev/device.h>\n#include <machine/bus.h>\n#include <machine/autoconf.h>\n#include <machine/cpu.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/tc/ioasicvar.h>\n#include <dev/tc/tcvar.h>\n#include <sys/reboot.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/errno.h>\n#include <sys/conf.h>\n#include <sys/buf.h>\n#include <sys/dkstat.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <asc.h>\n\n#define\tSCRIPT_DISCONNECT\t15\n#define\tSCRIPT_REPLY_SYNC\t11\n#define NLOG 32\n\nstatic int\nasc_msg_in(asc, status, ss, ir)\n\tregister asc_softc_t asc;\n\tregister int status, ss, ir;\n{\n\tregister asc_regmap_t *regs = asc->regs;\n\tregister State *state = &asc->st[asc->target];\n\tregister int msg;\n\tint i;\n\n\t/* read one message byte */\n\tmsg = regs->asc_fifo;\n#ifdef DEBUG\n\tif (asc_logp == asc_log)\n\t\tasc_log[NLOG - 1].msg = msg;\n\telse\n\t\tasc_logp[-1].msg = msg;\n#endif\n\n\t/* check for multi-byte message */\n\tif (state->msglen != 0) {\n\t\t/* first byte is the message length */\n\t\tif (state->msglen < 0) {\n\t\t\tstate->msglen = msg;\n\t\t\treturn (1);\n\t\t}\n\t\tif (state->msgcnt >= state->msglen) {\n\t\t  \tprintf(\"asc: msg_in too big, msgcnt %d msglen %d\\n\",\n\t\t\t       state->msgcnt, state->msglen);\n\t\t\tgoto abort;\n\t\t}\n\t\tstate->msg_in[state->msgcnt++] = msg;\n\n\t\t/* did we just read the last byte of the message? */\n\t\tif (state->msgcnt != state->msglen)\n\t\t\treturn (1);\n\n\t\t/* process an extended message */\n#ifdef DEBUG\n\t\tif (asc_debug > 2)\n\t\t\tprintf(\"asc_msg_in: msg %x %x %x\\n\",\n\t\t\t\tstate->msg_in[0],\n\t\t\t\tstate->msg_in[1],\n\t\t\t\tstate->msg_in[2]);\n#endif\n\t\tswitch (state->msg_in[0]) {\n\t\tcase SCSI_SYNCHRONOUS_XFER:\n\t\t\tstate->flags |= DID_SYNC;\n\t\t\tstate->sync_offset = state->msg_in[2];\n\n\t\t\t/* convert SCSI period to ASC period */\n\t\t\ti = state->msg_in[1] / asc->tb_ticks;\n\t\t\tif (i < asc->min_period)\n\t\t\t\ti = asc->min_period;\n\t\t\telse if (i >= asc->max_period) {\n\t\t\t\t/* can't do sync transfer, period too long */\n\t\t\t\tprintf(\"%s: SCSI device %d: sync xfer period too long (%d)\\n\",\n\t\t\t\t\tasc->sc_dev.dv_xname, asc->target, i);\n\t\t\t\ti = asc->max_period;\n\t\t\t\tstate->sync_offset = 0;\n\t\t\t}\n\t\t\tif ((i * asc->tb_ticks) != state->msg_in[1])\n\t\t\t\ti++;\n\t\t\tstate->sync_period = i & 0x1F;\n\n\t\t\t/*\n\t\t\t * If this is a request, check minimums and\n\t\t\t * send back an acknowledge.\n\t\t\t */\n\t\t\tif (!(state->flags & TRY_SYNC)) {\n\t\t\t\tregs->asc_cmd = ASC_CMD_SET_ATN;\n\t\t\t\treadback(regs->asc_cmd);\n\n\t\t\t\tif (state->sync_period < asc->min_period)\n\t\t\t\t\tstate->sync_period =\n\t\t\t\t\t\tasc->min_period;\n\t\t\t\tif (state->sync_offset > ASC_MAX_OFFSET)\n\t\t\t\t\tstate->sync_offset =\n\t\t\t\t\t\tASC_MAX_OFFSET;\n\t\t\t\tasc->script = &asc_scripts[SCRIPT_REPLY_SYNC];\n\t\t\t\tregs->asc_syn_p = state->sync_period;\n\t\t\t\treadback(regs->asc_syn_p);\n\t\t\t\tregs->asc_syn_o = state->sync_offset;\n\t\t\t\treadback(regs->asc_syn_o);\n\t\t\t\tregs->asc_cmd = ASC_CMD_MSG_ACPT;\n\t\t\t\treadback(regs->asc_cmd);\n\t\t\t\treturn (0);\n\t\t\t}\n\n\t\t\tregs->asc_syn_p = state->sync_period;\n\t\t\treadback(regs->asc_syn_p);\n\t\t\tregs->asc_syn_o = state->sync_offset;\n\t\t\treadback(regs->asc_syn_o);\n\t\t\tgoto done;\n\n\t\tdefault:\n\t\t\tprintf(\"%s: SCSI device %d: rejecting extended message 0x%x\\n\",\n\t\t\t\tasc->sc_dev.dv_xname, asc->target,\n\t\t\t\tstate->msg_in[0]);\n\t\t\tgoto reject;\n\t\t}\n\t}\n\n\t/* process first byte of a message */\n#ifdef DEBUG\n\tif (asc_debug > 2)\n\t\tprintf(\"asc_msg_in: msg %x\\n\", msg);\n#endif\n\tswitch (msg) {\n#if 0\n\tcase SCSI_MESSAGE_REJECT:\n\t\tprintf(\" did not like SYNCH xfer \"); /* XXX */\n\t\tstate->flags |= DID_SYNC;\n\t\tregs->asc_cmd = ASC_CMD_MSG_ACPT;\n\t\treadback(regs->asc_cmd);\n\t\tstatus = asc_wait(regs, ASC_CSR_INT);\n\t\tir = regs->asc_intr;\n\t\t/* some just break out here, some dont */\n\t\tif (ASC_PHASE(status) == SCSI_PHASE_MSG_OUT) {\n\t\t\tregs->asc_fifo = SCSI_ABORT;\n\t\t\tregs->asc_cmd = ASC_CMD_XFER_INFO;\n\t\t\treadback(regs->asc_cmd);\n\t\t\tstatus = asc_wait(regs, ASC_CSR_INT);\n\t\t\tir = regs->asc_intr;\n\t\t}\n\t\tif (ir & ASC_INT_DISC) {\n\t\t\tasc_end(asc, status, 0, ir);\n\t\t\treturn (0);\n\t\t}\n\t\tgoto status;\n#endif /*0*/\n\n\tcase SCSI_EXTENDED_MSG: /* read an extended message */\n\t\t/* setup to read message length next */\n\t\tstate->msglen = -1;\n\t\tstate->msgcnt = 0;\n\t\treturn (1);\n\n\tcase SCSI_NO_OP:\n\t\tbreak;\n\n\tcase SCSI_SAVE_DATA_POINTER:\n\t\t/* expect another message */\n\t\treturn (1);\n\n\tcase SCSI_RESTORE_POINTERS:\n\t\t/*\n\t\t * Need to do the following if resuming synchonous data in\n\t\t * on an odd byte boundary.\n\t\tregs->asc_cnfg2 |= ASC_CNFG2_RFB;\n\t\t */\n\t\tbreak;\n\n\tcase SCSI_DISCONNECT:\n\t\tif (state->flags & DISCONN) {\n\t\t\tprintf(\"asc: disconnected target %d disconnecting again\\n\",\n\t\t\t    asc->target);\n\t\t\tgoto abort;\n\t\t}\n\t\tstate->flags |= DISCONN;\n\t\tregs->asc_cmd = ASC_CMD_MSG_ACPT;\n\t\treadback(regs->asc_cmd);\n\t\tasc->script = &asc_scripts[SCRIPT_DISCONNECT];\n\t\treturn (0);\n\n\tdefault:\n\t\tprintf(\"%s: SCSI device %d: rejecting message 0x%x\\n\",\n\t\t\tasc->sc_dev.dv_xname, asc->target, msg);\n\treject:\n\t\t/* request a message out before acknowledging this message */\n\t\tstate->msg_out = SCSI_MESSAGE_REJECT;\n\t\tregs->asc_cmd = ASC_CMD_SET_ATN;\n\t\treadback(regs->asc_cmd);\n\t}\n\ndone:\n\t/* return to original script */\n\tregs->asc_cmd = ASC_CMD_MSG_ACPT;\n\treadback(regs->asc_cmd);\n\tif (!state->script) {\n\t  \tprintf(\"asc_msg_in: target %d, no script?\\n\", asc->target);\n\n\tabort:\n#ifdef DEBUG\n\t\tasc_DumpLog(\"asc_msg_in\");\n#endif\n\t\tpanic(\"asc_msg_in\");\n\t}\n\tasc->script = state->script;\n\tstate->script = (script_t *)0;\n\treturn (0);\n}"
  },
  {
    "function_name": "asc_replysync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/tc/asc.c",
    "lines": "1845-1882",
    "snippet": "static int\nasc_replysync(asc, status, ss, ir)\n\tregister asc_softc_t asc;\n\tregister int status, ss, ir;\n{\n\tregister asc_regmap_t *regs = asc->regs;\n\tregister State *state = &asc->st[asc->target];\n\n#ifdef DEBUG\n\tif (asc_debug > 2)\n\t\tprintf(\"asc_replysync: %x %x\\n\",\n\t\t\tasc_to_scsi_period[state->sync_period] * asc->tb_ticks,\n\t\t\tstate->sync_offset);\n#endif\n\t/* send synchronous transfer in response to a request */\n\tregs->asc_fifo = SCSI_EXTENDED_MSG;\n\ttc_mb();\n\tregs->asc_fifo = 3;\n\ttc_mb();\n\tregs->asc_fifo = SCSI_SYNCHRONOUS_XFER;\n\ttc_mb();\n\tregs->asc_fifo = asc_to_scsi_period[state->sync_period] * asc->tb_ticks;\n\ttc_mb();\n\tregs->asc_fifo = state->sync_offset;\n\tregs->asc_cmd = ASC_CMD_XFER_INFO;\n\treadback(regs->asc_cmd);\n\n\t/* return to the appropriate script */\n\tif (!state->script) {\n#ifdef DEBUG\n\t\tasc_DumpLog(\"asc_replsync\");\n#endif\n\t\tpanic(\"asc_replysync\");\n\t}\n\tasc->script = state->script;\n\tstate->script = (script_t *)0;\n\treturn (0);\n}",
    "includes": [
      "#include <dev/tc/ascvar.h>",
      "#include <pmax/pmax/kmin.h>",
      "#include <pmax/pmax/asic.h>",
      "#include <pmax/dev/ascreg.h>",
      "#include <pmax/dev/scsi.h>",
      "#include <pmax/dev/device.h>",
      "#include <machine/bus.h>",
      "#include <machine/autoconf.h>",
      "#include <machine/cpu.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/tc/ioasicvar.h>",
      "#include <dev/tc/tcvar.h>",
      "#include <sys/reboot.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/errno.h>",
      "#include <sys/conf.h>",
      "#include <sys/buf.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <asc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"asc_replysync\""
          ],
          "line": 1877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asc_DumpLog",
          "args": [
            "\"asc_replsync\""
          ],
          "line": 1875
        },
        "resolved": true,
        "details": {
          "function_name": "asc_DumpLog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/tc/asc.c",
          "lines": "2132-2156",
          "snippet": "void\nasc_DumpLog(str)\n\tchar *str;\n{\n\tregister struct asc_log *lp;\n\tregister u_int status;\n\n\tprintf(\"asc: %s: cmd %x bn %d cnt %d\\n\", str, asc_debug_cmd,\n\t\tasc_debug_bn, asc_debug_sz);\n\tlp = asc_logp;\n\tdo {\n\t\tstatus = lp->status;\n\t\tprintf(\"asc%d tgt %d status %x ss %x ir %x cond %d:%x msg %x resid %d\\n\",\n\t\t\tstatus >> 24,\n\t\t\tlp->target,\n\t\t\t(status >> 16) & 0xFF,\n\t\t\t(status >> 8) & 0xFF,\n\t\t\tstatus & 0XFF,\n\t\t\tlp->state,\n\t\t\tasc_scripts[lp->state].condition,\n\t\t\tlp->msg, lp->resid);\n\t\tif (++lp >= &asc_log[NLOG])\n\t\t\tlp = asc_log;\n\t} while (lp != asc_logp);\n}",
          "includes": [
            "#include <dev/tc/ascvar.h>",
            "#include <pmax/pmax/kmin.h>",
            "#include <pmax/pmax/asic.h>",
            "#include <pmax/dev/ascreg.h>",
            "#include <pmax/dev/scsi.h>",
            "#include <pmax/dev/device.h>",
            "#include <machine/bus.h>",
            "#include <machine/autoconf.h>",
            "#include <machine/cpu.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/tc/ioasicvar.h>",
            "#include <dev/tc/tcvar.h>",
            "#include <sys/reboot.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/errno.h>",
            "#include <sys/conf.h>",
            "#include <sys/buf.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <asc.h>"
          ],
          "macros_used": [
            "#define NLOG 32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/tc/ascvar.h>\n#include <pmax/pmax/kmin.h>\n#include <pmax/pmax/asic.h>\n#include <pmax/dev/ascreg.h>\n#include <pmax/dev/scsi.h>\n#include <pmax/dev/device.h>\n#include <machine/bus.h>\n#include <machine/autoconf.h>\n#include <machine/cpu.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/tc/ioasicvar.h>\n#include <dev/tc/tcvar.h>\n#include <sys/reboot.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/errno.h>\n#include <sys/conf.h>\n#include <sys/buf.h>\n#include <sys/dkstat.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <asc.h>\n\n#define NLOG 32\n\nvoid\nasc_DumpLog(str)\n\tchar *str;\n{\n\tregister struct asc_log *lp;\n\tregister u_int status;\n\n\tprintf(\"asc: %s: cmd %x bn %d cnt %d\\n\", str, asc_debug_cmd,\n\t\tasc_debug_bn, asc_debug_sz);\n\tlp = asc_logp;\n\tdo {\n\t\tstatus = lp->status;\n\t\tprintf(\"asc%d tgt %d status %x ss %x ir %x cond %d:%x msg %x resid %d\\n\",\n\t\t\tstatus >> 24,\n\t\t\tlp->target,\n\t\t\t(status >> 16) & 0xFF,\n\t\t\t(status >> 8) & 0xFF,\n\t\t\tstatus & 0XFF,\n\t\t\tlp->state,\n\t\t\tasc_scripts[lp->state].condition,\n\t\t\tlp->msg, lp->resid);\n\t\tif (++lp >= &asc_log[NLOG])\n\t\t\tlp = asc_log;\n\t} while (lp != asc_logp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "readback",
          "args": [
            "regs->asc_cmd"
          ],
          "line": 1870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tc_mb",
          "args": [],
          "line": 1867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tc_mb",
          "args": [],
          "line": 1865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tc_mb",
          "args": [],
          "line": 1863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tc_mb",
          "args": [],
          "line": 1861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"asc_replysync: %x %x\\n\"",
            "asc_to_scsi_period[state->sync_period] * asc->tb_ticks",
            "state->sync_offset"
          ],
          "line": 1855
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/tc/ascvar.h>\n#include <pmax/pmax/kmin.h>\n#include <pmax/pmax/asic.h>\n#include <pmax/dev/ascreg.h>\n#include <pmax/dev/scsi.h>\n#include <pmax/dev/device.h>\n#include <machine/bus.h>\n#include <machine/autoconf.h>\n#include <machine/cpu.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/tc/ioasicvar.h>\n#include <dev/tc/tcvar.h>\n#include <sys/reboot.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/errno.h>\n#include <sys/conf.h>\n#include <sys/buf.h>\n#include <sys/dkstat.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <asc.h>\n\nstatic int\nasc_replysync(asc, status, ss, ir)\n\tregister asc_softc_t asc;\n\tregister int status, ss, ir;\n{\n\tregister asc_regmap_t *regs = asc->regs;\n\tregister State *state = &asc->st[asc->target];\n\n#ifdef DEBUG\n\tif (asc_debug > 2)\n\t\tprintf(\"asc_replysync: %x %x\\n\",\n\t\t\tasc_to_scsi_period[state->sync_period] * asc->tb_ticks,\n\t\t\tstate->sync_offset);\n#endif\n\t/* send synchronous transfer in response to a request */\n\tregs->asc_fifo = SCSI_EXTENDED_MSG;\n\ttc_mb();\n\tregs->asc_fifo = 3;\n\ttc_mb();\n\tregs->asc_fifo = SCSI_SYNCHRONOUS_XFER;\n\ttc_mb();\n\tregs->asc_fifo = asc_to_scsi_period[state->sync_period] * asc->tb_ticks;\n\ttc_mb();\n\tregs->asc_fifo = state->sync_offset;\n\tregs->asc_cmd = ASC_CMD_XFER_INFO;\n\treadback(regs->asc_cmd);\n\n\t/* return to the appropriate script */\n\tif (!state->script) {\n#ifdef DEBUG\n\t\tasc_DumpLog(\"asc_replsync\");\n#endif\n\t\tpanic(\"asc_replysync\");\n\t}\n\tasc->script = state->script;\n\tstate->script = (script_t *)0;\n\treturn (0);\n}"
  },
  {
    "function_name": "asc_sendsync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/tc/asc.c",
    "lines": "1820-1842",
    "snippet": "static int\nasc_sendsync(asc, status, ss, ir)\n\tregister asc_softc_t asc;\n\tregister int status, ss, ir;\n{\n\tregister asc_regmap_t *regs = asc->regs;\n\tregister State *state = &asc->st[asc->target];\n\n\t/* send the extended synchronous negotiation message */\n\tregs->asc_fifo = SCSI_EXTENDED_MSG;\n\ttc_mb();\n\tregs->asc_fifo = 3;\n\ttc_mb();\n\tregs->asc_fifo = SCSI_SYNCHRONOUS_XFER;\n\ttc_mb();\n\tregs->asc_fifo = SCSI_MIN_PERIOD;\n\ttc_mb();\n\tregs->asc_fifo = ASC_MAX_OFFSET;\n\t/* state to resume after we see the sync reply message */\n\tstate->script = asc->script + 2;\n\tstate->msglen = 0;\n\treturn (1);\n}",
    "includes": [
      "#include <dev/tc/ascvar.h>",
      "#include <pmax/pmax/kmin.h>",
      "#include <pmax/pmax/asic.h>",
      "#include <pmax/dev/ascreg.h>",
      "#include <pmax/dev/scsi.h>",
      "#include <pmax/dev/device.h>",
      "#include <machine/bus.h>",
      "#include <machine/autoconf.h>",
      "#include <machine/cpu.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/tc/ioasicvar.h>",
      "#include <dev/tc/tcvar.h>",
      "#include <sys/reboot.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/errno.h>",
      "#include <sys/conf.h>",
      "#include <sys/buf.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <asc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tc_mb",
          "args": [],
          "line": 1836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tc_mb",
          "args": [],
          "line": 1834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tc_mb",
          "args": [],
          "line": 1832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tc_mb",
          "args": [],
          "line": 1830
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/tc/ascvar.h>\n#include <pmax/pmax/kmin.h>\n#include <pmax/pmax/asic.h>\n#include <pmax/dev/ascreg.h>\n#include <pmax/dev/scsi.h>\n#include <pmax/dev/device.h>\n#include <machine/bus.h>\n#include <machine/autoconf.h>\n#include <machine/cpu.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/tc/ioasicvar.h>\n#include <dev/tc/tcvar.h>\n#include <sys/reboot.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/errno.h>\n#include <sys/conf.h>\n#include <sys/buf.h>\n#include <sys/dkstat.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <asc.h>\n\nstatic int\nasc_sendsync(asc, status, ss, ir)\n\tregister asc_softc_t asc;\n\tregister int status, ss, ir;\n{\n\tregister asc_regmap_t *regs = asc->regs;\n\tregister State *state = &asc->st[asc->target];\n\n\t/* send the extended synchronous negotiation message */\n\tregs->asc_fifo = SCSI_EXTENDED_MSG;\n\ttc_mb();\n\tregs->asc_fifo = 3;\n\ttc_mb();\n\tregs->asc_fifo = SCSI_SYNCHRONOUS_XFER;\n\ttc_mb();\n\tregs->asc_fifo = SCSI_MIN_PERIOD;\n\ttc_mb();\n\tregs->asc_fifo = ASC_MAX_OFFSET;\n\t/* state to resume after we see the sync reply message */\n\tstate->script = asc->script + 2;\n\tstate->msglen = 0;\n\treturn (1);\n}"
  },
  {
    "function_name": "asc_resume_dma_out",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/tc/asc.c",
    "lines": "1773-1817",
    "snippet": "static int\nasc_resume_dma_out(asc, status, ss, ir)\n\tregister asc_softc_t asc;\n\tregister int status, ss, ir;\n{\n\tregister asc_regmap_t *regs = asc->regs;\n\tregister State *state = &asc->st[asc->target];\n\tregister int len, off;\n\n\t/* setup to finish writing this chunk */\n\tlen = state->dmaresid;\n\toff = state->dmalen - len;\n\tif (off & 1) {\n\t\tprintf(\"asc_resume_dma_out: odd xfer dmalen %d len %d off %d\\n\",\n\t\t\tstate->dmalen, len, off); /* XXX */\n\t\tregs->asc_fifo = state->buf[off];\n\t\toff++;\n\t\tlen--;\n\t}\n#ifdef DEBUG\n\tif (asc_logp == asc_log)\n\t\tasc_log[NLOG - 1].resid = len;\n\telse\n\t\tasc_logp[-1].resid = len;\n#endif\n\t/* XXX may result in redundant copy of data */\n\tlen = (*asc->dma_start)(asc, state, state->buf + off, ASCDMA_WRITE, len, off);\n\tASC_TC_PUT(regs, len);\n#ifdef DEBUG\n\tif (asc_debug > 2)\n\t\tprintf(\"asc_resume_dma_out: buflen %d dmalen %d len %d off %d\\n\",\n\t\t\tstate->dmalen, state->buflen, len, off);\n#endif\n\n\t/* check for next chunk */\n\tstate->flags |= DMA_IN_PROGRESS;\n\tstate->flags &= ~DMA_RESUME;\n\tif (state->dmalen != state->buflen) {\n\t\tregs->asc_cmd = ASC_CMD_XFER_INFO | ASC_CMD_DMA;\n\t\treadback(regs->asc_cmd);\n\t\tasc->script = &asc_scripts[SCRIPT_CONTINUE_OUT];\n\t\treturn (0);\n\t}\n\treturn (1);\n}",
    "includes": [
      "#include <dev/tc/ascvar.h>",
      "#include <pmax/pmax/kmin.h>",
      "#include <pmax/pmax/asic.h>",
      "#include <pmax/dev/ascreg.h>",
      "#include <pmax/dev/scsi.h>",
      "#include <pmax/dev/device.h>",
      "#include <machine/bus.h>",
      "#include <machine/autoconf.h>",
      "#include <machine/cpu.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/tc/ioasicvar.h>",
      "#include <dev/tc/tcvar.h>",
      "#include <sys/reboot.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/errno.h>",
      "#include <sys/conf.h>",
      "#include <sys/buf.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <asc.h>"
    ],
    "macros_used": [
      "#define\tSCRIPT_CONTINUE_OUT\t5",
      "#define NLOG 32"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "readback",
          "args": [
            "regs->asc_cmd"
          ],
          "line": 1812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"asc_resume_dma_out: buflen %d dmalen %d len %d off %d\\n\"",
            "state->dmalen",
            "state->buflen",
            "len",
            "off"
          ],
          "line": 1803
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASC_TC_PUT",
          "args": [
            "regs",
            "len"
          ],
          "line": 1800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "asc",
            "state",
            "state->buf + off",
            "ASCDMA_WRITE",
            "len",
            "off"
          ],
          "line": 1799
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/tc/ascvar.h>\n#include <pmax/pmax/kmin.h>\n#include <pmax/pmax/asic.h>\n#include <pmax/dev/ascreg.h>\n#include <pmax/dev/scsi.h>\n#include <pmax/dev/device.h>\n#include <machine/bus.h>\n#include <machine/autoconf.h>\n#include <machine/cpu.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/tc/ioasicvar.h>\n#include <dev/tc/tcvar.h>\n#include <sys/reboot.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/errno.h>\n#include <sys/conf.h>\n#include <sys/buf.h>\n#include <sys/dkstat.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <asc.h>\n\n#define\tSCRIPT_CONTINUE_OUT\t5\n#define NLOG 32\n\nstatic int\nasc_resume_dma_out(asc, status, ss, ir)\n\tregister asc_softc_t asc;\n\tregister int status, ss, ir;\n{\n\tregister asc_regmap_t *regs = asc->regs;\n\tregister State *state = &asc->st[asc->target];\n\tregister int len, off;\n\n\t/* setup to finish writing this chunk */\n\tlen = state->dmaresid;\n\toff = state->dmalen - len;\n\tif (off & 1) {\n\t\tprintf(\"asc_resume_dma_out: odd xfer dmalen %d len %d off %d\\n\",\n\t\t\tstate->dmalen, len, off); /* XXX */\n\t\tregs->asc_fifo = state->buf[off];\n\t\toff++;\n\t\tlen--;\n\t}\n#ifdef DEBUG\n\tif (asc_logp == asc_log)\n\t\tasc_log[NLOG - 1].resid = len;\n\telse\n\t\tasc_logp[-1].resid = len;\n#endif\n\t/* XXX may result in redundant copy of data */\n\tlen = (*asc->dma_start)(asc, state, state->buf + off, ASCDMA_WRITE, len, off);\n\tASC_TC_PUT(regs, len);\n#ifdef DEBUG\n\tif (asc_debug > 2)\n\t\tprintf(\"asc_resume_dma_out: buflen %d dmalen %d len %d off %d\\n\",\n\t\t\tstate->dmalen, state->buflen, len, off);\n#endif\n\n\t/* check for next chunk */\n\tstate->flags |= DMA_IN_PROGRESS;\n\tstate->flags &= ~DMA_RESUME;\n\tif (state->dmalen != state->buflen) {\n\t\tregs->asc_cmd = ASC_CMD_XFER_INFO | ASC_CMD_DMA;\n\t\treadback(regs->asc_cmd);\n\t\tasc->script = &asc_scripts[SCRIPT_CONTINUE_OUT];\n\t\treturn (0);\n\t}\n\treturn (1);\n}"
  },
  {
    "function_name": "asc_resume_out",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/tc/asc.c",
    "lines": "1735-1770",
    "snippet": "static int\nasc_resume_out(asc, status, ss, ir)\n\tregister asc_softc_t asc;\n\tregister int status, ss, ir;\n{\n\tregister asc_regmap_t *regs = asc->regs;\n\tregister State *state = &asc->st[asc->target];\n\tregister int len;\n\n\t/* setup for this chunk */\n\tlen = state->buflen;\n#ifdef DEBUG\n\tif (asc_logp == asc_log)\n\t\tasc_log[NLOG - 1].resid = len;\n\telse\n\t\tasc_logp[-1].resid = len;\n#endif\n\tlen = (*asc->dma_start)(asc, state, state->buf, ASCDMA_WRITE, len, 0);\n\tstate->dmalen = len;\n\tASC_TC_PUT(regs, len);\n#ifdef DEBUG\n\tif (asc_debug > 2)\n\t\tprintf(\"asc_resume_out: buflen %d, len %d\\n\", state->buflen,\n\t\t\tlen);\n#endif\n\n\t/* check for next chunk */\n\tstate->flags |= DMA_IN_PROGRESS;\n\tif (len != state->buflen) {\n\t\tregs->asc_cmd = ASC_CMD_XFER_INFO | ASC_CMD_DMA;\n\t\treadback(regs->asc_cmd);\n\t\tasc->script = &asc_scripts[SCRIPT_CONTINUE_OUT];\n\t\treturn (0);\n\t}\n\treturn (1);\n}",
    "includes": [
      "#include <dev/tc/ascvar.h>",
      "#include <pmax/pmax/kmin.h>",
      "#include <pmax/pmax/asic.h>",
      "#include <pmax/dev/ascreg.h>",
      "#include <pmax/dev/scsi.h>",
      "#include <pmax/dev/device.h>",
      "#include <machine/bus.h>",
      "#include <machine/autoconf.h>",
      "#include <machine/cpu.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/tc/ioasicvar.h>",
      "#include <dev/tc/tcvar.h>",
      "#include <sys/reboot.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/errno.h>",
      "#include <sys/conf.h>",
      "#include <sys/buf.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <asc.h>"
    ],
    "macros_used": [
      "#define\tSCRIPT_CONTINUE_OUT\t5",
      "#define NLOG 32"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "readback",
          "args": [
            "regs->asc_cmd"
          ],
          "line": 1765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"asc_resume_out: buflen %d, len %d\\n\"",
            "state->buflen",
            "len"
          ],
          "line": 1757
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASC_TC_PUT",
          "args": [
            "regs",
            "len"
          ],
          "line": 1754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "asc",
            "state",
            "state->buf",
            "ASCDMA_WRITE",
            "len",
            "0"
          ],
          "line": 1752
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/tc/ascvar.h>\n#include <pmax/pmax/kmin.h>\n#include <pmax/pmax/asic.h>\n#include <pmax/dev/ascreg.h>\n#include <pmax/dev/scsi.h>\n#include <pmax/dev/device.h>\n#include <machine/bus.h>\n#include <machine/autoconf.h>\n#include <machine/cpu.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/tc/ioasicvar.h>\n#include <dev/tc/tcvar.h>\n#include <sys/reboot.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/errno.h>\n#include <sys/conf.h>\n#include <sys/buf.h>\n#include <sys/dkstat.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <asc.h>\n\n#define\tSCRIPT_CONTINUE_OUT\t5\n#define NLOG 32\n\nstatic int\nasc_resume_out(asc, status, ss, ir)\n\tregister asc_softc_t asc;\n\tregister int status, ss, ir;\n{\n\tregister asc_regmap_t *regs = asc->regs;\n\tregister State *state = &asc->st[asc->target];\n\tregister int len;\n\n\t/* setup for this chunk */\n\tlen = state->buflen;\n#ifdef DEBUG\n\tif (asc_logp == asc_log)\n\t\tasc_log[NLOG - 1].resid = len;\n\telse\n\t\tasc_logp[-1].resid = len;\n#endif\n\tlen = (*asc->dma_start)(asc, state, state->buf, ASCDMA_WRITE, len, 0);\n\tstate->dmalen = len;\n\tASC_TC_PUT(regs, len);\n#ifdef DEBUG\n\tif (asc_debug > 2)\n\t\tprintf(\"asc_resume_out: buflen %d, len %d\\n\", state->buflen,\n\t\t\tlen);\n#endif\n\n\t/* check for next chunk */\n\tstate->flags |= DMA_IN_PROGRESS;\n\tif (len != state->buflen) {\n\t\tregs->asc_cmd = ASC_CMD_XFER_INFO | ASC_CMD_DMA;\n\t\treadback(regs->asc_cmd);\n\t\tasc->script = &asc_scripts[SCRIPT_CONTINUE_OUT];\n\t\treturn (0);\n\t}\n\treturn (1);\n}"
  },
  {
    "function_name": "asc_last_dma_out",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/tc/asc.c",
    "lines": "1705-1732",
    "snippet": "static int\nasc_last_dma_out(asc, status, ss, ir)\n\tregister asc_softc_t asc;\n\tregister int status, ss, ir;\n{\n\tregister asc_regmap_t *regs = asc->regs;\n\tregister State *state = &asc->st[asc->target];\n\tregister int len, fifo;\n\n\tASC_TC_GET(regs, len);\n\tfifo = regs->asc_flags & ASC_FLAGS_FIFO_CNT;\n#ifdef DEBUG\n\tif (asc_debug > 2)\n\t\tprintf(\"asc_last_dma_out: buflen %d dmalen %d tc %d fifo %d\\n\",\n\t\t\tstate->buflen, state->dmalen, len, fifo);\n#endif\n\tif (fifo) {\n\t\tlen += fifo;\n\t\tregs->asc_cmd = ASC_CMD_FLUSH;\n\t\treadback(regs->asc_cmd);\n\t\tprintf(\"asc_last_dma_out: buflen %d dmalen %d tc %d fifo %d\\n\",\n\t\t\tstate->buflen, state->dmalen, len, fifo);\n\t}\n\tstate->flags &= ~DMA_IN_PROGRESS;\n\tlen = state->dmalen - len;\n\tstate->buflen -= len;\n\treturn (1);\n}",
    "includes": [
      "#include <dev/tc/ascvar.h>",
      "#include <pmax/pmax/kmin.h>",
      "#include <pmax/pmax/asic.h>",
      "#include <pmax/dev/ascreg.h>",
      "#include <pmax/dev/scsi.h>",
      "#include <pmax/dev/device.h>",
      "#include <machine/bus.h>",
      "#include <machine/autoconf.h>",
      "#include <machine/cpu.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/tc/ioasicvar.h>",
      "#include <dev/tc/tcvar.h>",
      "#include <sys/reboot.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/errno.h>",
      "#include <sys/conf.h>",
      "#include <sys/buf.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <asc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"asc_last_dma_out: buflen %d dmalen %d tc %d fifo %d\\n\"",
            "state->buflen",
            "state->dmalen",
            "len",
            "fifo"
          ],
          "line": 1725
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "readback",
          "args": [
            "regs->asc_cmd"
          ],
          "line": 1724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASC_TC_GET",
          "args": [
            "regs",
            "len"
          ],
          "line": 1714
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/tc/ascvar.h>\n#include <pmax/pmax/kmin.h>\n#include <pmax/pmax/asic.h>\n#include <pmax/dev/ascreg.h>\n#include <pmax/dev/scsi.h>\n#include <pmax/dev/device.h>\n#include <machine/bus.h>\n#include <machine/autoconf.h>\n#include <machine/cpu.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/tc/ioasicvar.h>\n#include <dev/tc/tcvar.h>\n#include <sys/reboot.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/errno.h>\n#include <sys/conf.h>\n#include <sys/buf.h>\n#include <sys/dkstat.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <asc.h>\n\nstatic int\nasc_last_dma_out(asc, status, ss, ir)\n\tregister asc_softc_t asc;\n\tregister int status, ss, ir;\n{\n\tregister asc_regmap_t *regs = asc->regs;\n\tregister State *state = &asc->st[asc->target];\n\tregister int len, fifo;\n\n\tASC_TC_GET(regs, len);\n\tfifo = regs->asc_flags & ASC_FLAGS_FIFO_CNT;\n#ifdef DEBUG\n\tif (asc_debug > 2)\n\t\tprintf(\"asc_last_dma_out: buflen %d dmalen %d tc %d fifo %d\\n\",\n\t\t\tstate->buflen, state->dmalen, len, fifo);\n#endif\n\tif (fifo) {\n\t\tlen += fifo;\n\t\tregs->asc_cmd = ASC_CMD_FLUSH;\n\t\treadback(regs->asc_cmd);\n\t\tprintf(\"asc_last_dma_out: buflen %d dmalen %d tc %d fifo %d\\n\",\n\t\t\tstate->buflen, state->dmalen, len, fifo);\n\t}\n\tstate->flags &= ~DMA_IN_PROGRESS;\n\tlen = state->dmalen - len;\n\tstate->buflen -= len;\n\treturn (1);\n}"
  },
  {
    "function_name": "asc_dma_out",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/tc/asc.c",
    "lines": "1646-1702",
    "snippet": "static int\nasc_dma_out(asc, status, ss, ir)\n\tregister asc_softc_t asc;\n\tregister int status, ss, ir;\n{\n\tregister asc_regmap_t *regs = asc->regs;\n\tregister State *state = &asc->st[asc->target];\n\tregister int len, fifo;\n\n\tif (state->flags & DMA_IN_PROGRESS) {\n\t\t/* check to be sure previous chunk was finished */\n\t\tASC_TC_GET(regs, len);\n\t\tfifo = regs->asc_flags & ASC_FLAGS_FIFO_CNT;\n\t\tif (len || fifo)\n\t\t\tprintf(\"asc_dma_out: buflen %d dmalen %d tc %d fifo %d\\n\",\n\t\t\t\tstate->buflen, state->dmalen, len, fifo); /* XXX */\n\t\tlen += fifo;\n\t\tlen = state->dmalen - len;\n\t\tstate->buf += len;\n\t\tstate->buflen -= len;\n\t}\n\n\t/*\n\t * Flush the fifo - sometimes there seems to be something left\n\t * in the fifo.  Since the dma output has not been started,\n\t * the fifo is supposed to be empty.\n\t */\n\tif (regs->asc_flags & ASC_FLAGS_FIFO_CNT) {\n\t\twhile (regs->asc_flags & ASC_FLAGS_FIFO_CNT)\n\t\t\tregs->asc_fifo;\n\t}\n\t/* setup for this chunk */\n\tlen = state->buflen;\n#ifdef DEBUG\n\tif (asc_logp == asc_log)\n\t\tasc_log[NLOG - 1].resid = len;\n\telse\n\t\tasc_logp[-1].resid = len;\n#endif\n\tlen = (*asc->dma_start)(asc, state, state->buf, ASCDMA_WRITE, len, 0);\n\tstate->dmalen = len;\n\tASC_TC_PUT(regs, len);\n#ifdef DEBUG\n\tif (asc_debug > 2)\n\t\tprintf(\"asc_dma_out: buflen %d, len %d\\n\", state->buflen, len);\n#endif\n\n\t/* check for next chunk */\n\tstate->flags |= DMA_IN_PROGRESS;\n\tif (len != state->buflen) {\n\t\tregs->asc_cmd = ASC_CMD_XFER_INFO | ASC_CMD_DMA;\n\t\treadback(regs->asc_cmd);\n\t\tasc->script = &asc_scripts[SCRIPT_CONTINUE_OUT];\n\t\treturn (0);\n\t}\n\treturn (1);\n}",
    "includes": [
      "#include <dev/tc/ascvar.h>",
      "#include <pmax/pmax/kmin.h>",
      "#include <pmax/pmax/asic.h>",
      "#include <pmax/dev/ascreg.h>",
      "#include <pmax/dev/scsi.h>",
      "#include <pmax/dev/device.h>",
      "#include <machine/bus.h>",
      "#include <machine/autoconf.h>",
      "#include <machine/cpu.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/tc/ioasicvar.h>",
      "#include <dev/tc/tcvar.h>",
      "#include <sys/reboot.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/errno.h>",
      "#include <sys/conf.h>",
      "#include <sys/buf.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <asc.h>"
    ],
    "macros_used": [
      "#define\tSCRIPT_CONTINUE_OUT\t5",
      "#define NLOG 32"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "readback",
          "args": [
            "regs->asc_cmd"
          ],
          "line": 1697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"asc_dma_out: buflen %d, len %d\\n\"",
            "state->buflen",
            "len"
          ],
          "line": 1690
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASC_TC_PUT",
          "args": [
            "regs",
            "len"
          ],
          "line": 1687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "asc",
            "state",
            "state->buf",
            "ASCDMA_WRITE",
            "len",
            "0"
          ],
          "line": 1685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASC_TC_GET",
          "args": [
            "regs",
            "len"
          ],
          "line": 1657
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/tc/ascvar.h>\n#include <pmax/pmax/kmin.h>\n#include <pmax/pmax/asic.h>\n#include <pmax/dev/ascreg.h>\n#include <pmax/dev/scsi.h>\n#include <pmax/dev/device.h>\n#include <machine/bus.h>\n#include <machine/autoconf.h>\n#include <machine/cpu.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/tc/ioasicvar.h>\n#include <dev/tc/tcvar.h>\n#include <sys/reboot.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/errno.h>\n#include <sys/conf.h>\n#include <sys/buf.h>\n#include <sys/dkstat.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <asc.h>\n\n#define\tSCRIPT_CONTINUE_OUT\t5\n#define NLOG 32\n\nstatic int\nasc_dma_out(asc, status, ss, ir)\n\tregister asc_softc_t asc;\n\tregister int status, ss, ir;\n{\n\tregister asc_regmap_t *regs = asc->regs;\n\tregister State *state = &asc->st[asc->target];\n\tregister int len, fifo;\n\n\tif (state->flags & DMA_IN_PROGRESS) {\n\t\t/* check to be sure previous chunk was finished */\n\t\tASC_TC_GET(regs, len);\n\t\tfifo = regs->asc_flags & ASC_FLAGS_FIFO_CNT;\n\t\tif (len || fifo)\n\t\t\tprintf(\"asc_dma_out: buflen %d dmalen %d tc %d fifo %d\\n\",\n\t\t\t\tstate->buflen, state->dmalen, len, fifo); /* XXX */\n\t\tlen += fifo;\n\t\tlen = state->dmalen - len;\n\t\tstate->buf += len;\n\t\tstate->buflen -= len;\n\t}\n\n\t/*\n\t * Flush the fifo - sometimes there seems to be something left\n\t * in the fifo.  Since the dma output has not been started,\n\t * the fifo is supposed to be empty.\n\t */\n\tif (regs->asc_flags & ASC_FLAGS_FIFO_CNT) {\n\t\twhile (regs->asc_flags & ASC_FLAGS_FIFO_CNT)\n\t\t\tregs->asc_fifo;\n\t}\n\t/* setup for this chunk */\n\tlen = state->buflen;\n#ifdef DEBUG\n\tif (asc_logp == asc_log)\n\t\tasc_log[NLOG - 1].resid = len;\n\telse\n\t\tasc_logp[-1].resid = len;\n#endif\n\tlen = (*asc->dma_start)(asc, state, state->buf, ASCDMA_WRITE, len, 0);\n\tstate->dmalen = len;\n\tASC_TC_PUT(regs, len);\n#ifdef DEBUG\n\tif (asc_debug > 2)\n\t\tprintf(\"asc_dma_out: buflen %d, len %d\\n\", state->buflen, len);\n#endif\n\n\t/* check for next chunk */\n\tstate->flags |= DMA_IN_PROGRESS;\n\tif (len != state->buflen) {\n\t\tregs->asc_cmd = ASC_CMD_XFER_INFO | ASC_CMD_DMA;\n\t\treadback(regs->asc_cmd);\n\t\tasc->script = &asc_scripts[SCRIPT_CONTINUE_OUT];\n\t\treturn (0);\n\t}\n\treturn (1);\n}"
  },
  {
    "function_name": "asc_resume_dma_in",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/tc/asc.c",
    "lines": "1602-1643",
    "snippet": "static int\nasc_resume_dma_in(asc, status, ss, ir)\n\tregister asc_softc_t asc;\n\tregister int status, ss, ir;\n{\n\tregister asc_regmap_t *regs = asc->regs;\n\tregister State *state = &asc->st[asc->target];\n\tregister int len, off;\n\n\t/* setup to finish reading the current chunk */\n\tlen = state->dmaresid;\n\toff = state->dmalen - len;\n\tif ((off & 1) && state->sync_offset) {\n\t\tprintf(\"asc_resume_dma_in: odd xfer dmalen %d len %d off %d\\n\",\n\t\t\tstate->dmalen, len, off); /* XXX */\n\t\tregs->asc_res_fifo = state->buf[off];\n\t}\n#ifdef DEBUG\n\tif (asc_logp == asc_log)\n\t\tasc_log[NLOG - 1].resid = len;\n\telse\n\t\tasc_logp[-1].resid = len;\n#endif\n\tlen = (*asc->dma_start)(asc, state, state->buf + off, ASCDMA_READ, len, off);\n\tASC_TC_PUT(regs, len);\n#ifdef DEBUG\n\tif (asc_debug > 2)\n\t\tprintf(\"asc_resume_dma_in: buflen %d dmalen %d len %d off %d\\n\",\n\t\t\tstate->dmalen, state->buflen, len, off);\n#endif\n\n\t/* check for next chunk */\n\tstate->flags |= DMA_IN_PROGRESS;\n\tstate->flags &= ~DMA_RESUME;\n\tif (state->dmalen != state->buflen) {\n\t\tregs->asc_cmd = ASC_CMD_XFER_INFO | ASC_CMD_DMA;\n\t\treadback(regs->asc_cmd);\n\t\tasc->script = &asc_scripts[SCRIPT_CONTINUE_IN];\n\t\treturn (0);\n\t}\n\treturn (1);\n}",
    "includes": [
      "#include <dev/tc/ascvar.h>",
      "#include <pmax/pmax/kmin.h>",
      "#include <pmax/pmax/asic.h>",
      "#include <pmax/dev/ascreg.h>",
      "#include <pmax/dev/scsi.h>",
      "#include <pmax/dev/device.h>",
      "#include <machine/bus.h>",
      "#include <machine/autoconf.h>",
      "#include <machine/cpu.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/tc/ioasicvar.h>",
      "#include <dev/tc/tcvar.h>",
      "#include <sys/reboot.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/errno.h>",
      "#include <sys/conf.h>",
      "#include <sys/buf.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <asc.h>"
    ],
    "macros_used": [
      "#define\tSCRIPT_CONTINUE_IN\t2",
      "#define NLOG 32"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "readback",
          "args": [
            "regs->asc_cmd"
          ],
          "line": 1638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"asc_resume_dma_in: buflen %d dmalen %d len %d off %d\\n\"",
            "state->dmalen",
            "state->buflen",
            "len",
            "off"
          ],
          "line": 1629
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASC_TC_PUT",
          "args": [
            "regs",
            "len"
          ],
          "line": 1626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "asc",
            "state",
            "state->buf + off",
            "ASCDMA_READ",
            "len",
            "off"
          ],
          "line": 1625
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/tc/ascvar.h>\n#include <pmax/pmax/kmin.h>\n#include <pmax/pmax/asic.h>\n#include <pmax/dev/ascreg.h>\n#include <pmax/dev/scsi.h>\n#include <pmax/dev/device.h>\n#include <machine/bus.h>\n#include <machine/autoconf.h>\n#include <machine/cpu.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/tc/ioasicvar.h>\n#include <dev/tc/tcvar.h>\n#include <sys/reboot.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/errno.h>\n#include <sys/conf.h>\n#include <sys/buf.h>\n#include <sys/dkstat.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <asc.h>\n\n#define\tSCRIPT_CONTINUE_IN\t2\n#define NLOG 32\n\nstatic int\nasc_resume_dma_in(asc, status, ss, ir)\n\tregister asc_softc_t asc;\n\tregister int status, ss, ir;\n{\n\tregister asc_regmap_t *regs = asc->regs;\n\tregister State *state = &asc->st[asc->target];\n\tregister int len, off;\n\n\t/* setup to finish reading the current chunk */\n\tlen = state->dmaresid;\n\toff = state->dmalen - len;\n\tif ((off & 1) && state->sync_offset) {\n\t\tprintf(\"asc_resume_dma_in: odd xfer dmalen %d len %d off %d\\n\",\n\t\t\tstate->dmalen, len, off); /* XXX */\n\t\tregs->asc_res_fifo = state->buf[off];\n\t}\n#ifdef DEBUG\n\tif (asc_logp == asc_log)\n\t\tasc_log[NLOG - 1].resid = len;\n\telse\n\t\tasc_logp[-1].resid = len;\n#endif\n\tlen = (*asc->dma_start)(asc, state, state->buf + off, ASCDMA_READ, len, off);\n\tASC_TC_PUT(regs, len);\n#ifdef DEBUG\n\tif (asc_debug > 2)\n\t\tprintf(\"asc_resume_dma_in: buflen %d dmalen %d len %d off %d\\n\",\n\t\t\tstate->dmalen, state->buflen, len, off);\n#endif\n\n\t/* check for next chunk */\n\tstate->flags |= DMA_IN_PROGRESS;\n\tstate->flags &= ~DMA_RESUME;\n\tif (state->dmalen != state->buflen) {\n\t\tregs->asc_cmd = ASC_CMD_XFER_INFO | ASC_CMD_DMA;\n\t\treadback(regs->asc_cmd);\n\t\tasc->script = &asc_scripts[SCRIPT_CONTINUE_IN];\n\t\treturn (0);\n\t}\n\treturn (1);\n}"
  },
  {
    "function_name": "asc_resume_in",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/tc/asc.c",
    "lines": "1564-1599",
    "snippet": "static int\nasc_resume_in(asc, status, ss, ir)\n\tregister asc_softc_t asc;\n\tregister int status, ss, ir;\n{\n\tregister asc_regmap_t *regs = asc->regs;\n\tregister State *state = &asc->st[asc->target];\n\tregister int len;\n\n\t/* setup to start reading the next chunk */\n\tlen = state->buflen;\n#ifdef DEBUG\n\tif (asc_logp == asc_log)\n\t\tasc_log[NLOG - 1].resid = len;\n\telse\n\t\tasc_logp[-1].resid = len;\n#endif\n\tlen = (*asc->dma_start)(asc, state, state->buf, ASCDMA_READ, len, 0);\n\tstate->dmalen = len;\n\tASC_TC_PUT(regs, len);\n#ifdef DEBUG\n\tif (asc_debug > 2)\n\t\tprintf(\"asc_resume_in: buflen %d, len %d\\n\", state->buflen,\n\t\t\tlen);\n#endif\n\n\t/* check for next chunk */\n\tstate->flags |= DMA_IN_PROGRESS;\n\tif (len != state->buflen) {\n\t\tregs->asc_cmd = ASC_CMD_XFER_INFO | ASC_CMD_DMA;\n\t\treadback(regs->asc_cmd);\n\t\tasc->script = &asc_scripts[SCRIPT_CONTINUE_IN];\n\t\treturn (0);\n\t}\n\treturn (1);\n}",
    "includes": [
      "#include <dev/tc/ascvar.h>",
      "#include <pmax/pmax/kmin.h>",
      "#include <pmax/pmax/asic.h>",
      "#include <pmax/dev/ascreg.h>",
      "#include <pmax/dev/scsi.h>",
      "#include <pmax/dev/device.h>",
      "#include <machine/bus.h>",
      "#include <machine/autoconf.h>",
      "#include <machine/cpu.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/tc/ioasicvar.h>",
      "#include <dev/tc/tcvar.h>",
      "#include <sys/reboot.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/errno.h>",
      "#include <sys/conf.h>",
      "#include <sys/buf.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <asc.h>"
    ],
    "macros_used": [
      "#define\tSCRIPT_CONTINUE_IN\t2",
      "#define NLOG 32"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "readback",
          "args": [
            "regs->asc_cmd"
          ],
          "line": 1594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"asc_resume_in: buflen %d, len %d\\n\"",
            "state->buflen",
            "len"
          ],
          "line": 1586
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASC_TC_PUT",
          "args": [
            "regs",
            "len"
          ],
          "line": 1583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "asc",
            "state",
            "state->buf",
            "ASCDMA_READ",
            "len",
            "0"
          ],
          "line": 1581
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/tc/ascvar.h>\n#include <pmax/pmax/kmin.h>\n#include <pmax/pmax/asic.h>\n#include <pmax/dev/ascreg.h>\n#include <pmax/dev/scsi.h>\n#include <pmax/dev/device.h>\n#include <machine/bus.h>\n#include <machine/autoconf.h>\n#include <machine/cpu.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/tc/ioasicvar.h>\n#include <dev/tc/tcvar.h>\n#include <sys/reboot.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/errno.h>\n#include <sys/conf.h>\n#include <sys/buf.h>\n#include <sys/dkstat.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <asc.h>\n\n#define\tSCRIPT_CONTINUE_IN\t2\n#define NLOG 32\n\nstatic int\nasc_resume_in(asc, status, ss, ir)\n\tregister asc_softc_t asc;\n\tregister int status, ss, ir;\n{\n\tregister asc_regmap_t *regs = asc->regs;\n\tregister State *state = &asc->st[asc->target];\n\tregister int len;\n\n\t/* setup to start reading the next chunk */\n\tlen = state->buflen;\n#ifdef DEBUG\n\tif (asc_logp == asc_log)\n\t\tasc_log[NLOG - 1].resid = len;\n\telse\n\t\tasc_logp[-1].resid = len;\n#endif\n\tlen = (*asc->dma_start)(asc, state, state->buf, ASCDMA_READ, len, 0);\n\tstate->dmalen = len;\n\tASC_TC_PUT(regs, len);\n#ifdef DEBUG\n\tif (asc_debug > 2)\n\t\tprintf(\"asc_resume_in: buflen %d, len %d\\n\", state->buflen,\n\t\t\tlen);\n#endif\n\n\t/* check for next chunk */\n\tstate->flags |= DMA_IN_PROGRESS;\n\tif (len != state->buflen) {\n\t\tregs->asc_cmd = ASC_CMD_XFER_INFO | ASC_CMD_DMA;\n\t\treadback(regs->asc_cmd);\n\t\tasc->script = &asc_scripts[SCRIPT_CONTINUE_IN];\n\t\treturn (0);\n\t}\n\treturn (1);\n}"
  },
  {
    "function_name": "asc_last_dma_in",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/tc/asc.c",
    "lines": "1533-1561",
    "snippet": "static int\nasc_last_dma_in(asc, status, ss, ir)\n\tregister asc_softc_t asc;\n\tregister int status, ss, ir;\n{\n\tregister asc_regmap_t *regs = asc->regs;\n\tregister State *state = &asc->st[asc->target];\n\tregister int len, fifo;\n\n\tASC_TC_GET(regs, len);\n\tfifo = regs->asc_flags & ASC_FLAGS_FIFO_CNT;\n#ifdef DEBUG\n\tif (asc_debug > 2)\n\t\tprintf(\"asc_last_dma_in: buflen %d dmalen %d tc %d fifo %d\\n\",\n\t\t\tstate->buflen, state->dmalen, len, fifo);\n#endif\n\tif (fifo) {\n\t\t/* device must be trying to send more than we expect */\n\t\tregs->asc_cmd = ASC_CMD_FLUSH;\n\t\treadback(regs->asc_cmd);\n\t}\n\tstate->flags &= ~DMA_IN_PROGRESS;\n\tlen = state->dmalen - len;\n\tstate->dmalen = len;\t/* dma_end may need actual length */\n\t(*asc->dma_end)(asc, state, ASCDMA_READ);\n\tstate->buflen -= len;\n\n\treturn (1);\n}",
    "includes": [
      "#include <dev/tc/ascvar.h>",
      "#include <pmax/pmax/kmin.h>",
      "#include <pmax/pmax/asic.h>",
      "#include <pmax/dev/ascreg.h>",
      "#include <pmax/dev/scsi.h>",
      "#include <pmax/dev/device.h>",
      "#include <machine/bus.h>",
      "#include <machine/autoconf.h>",
      "#include <machine/cpu.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/tc/ioasicvar.h>",
      "#include <dev/tc/tcvar.h>",
      "#include <sys/reboot.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/errno.h>",
      "#include <sys/conf.h>",
      "#include <sys/buf.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <asc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "asc",
            "state",
            "ASCDMA_READ"
          ],
          "line": 1557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readback",
          "args": [
            "regs->asc_cmd"
          ],
          "line": 1552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"asc_last_dma_in: buflen %d dmalen %d tc %d fifo %d\\n\"",
            "state->buflen",
            "state->dmalen",
            "len",
            "fifo"
          ],
          "line": 1546
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASC_TC_GET",
          "args": [
            "regs",
            "len"
          ],
          "line": 1542
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/tc/ascvar.h>\n#include <pmax/pmax/kmin.h>\n#include <pmax/pmax/asic.h>\n#include <pmax/dev/ascreg.h>\n#include <pmax/dev/scsi.h>\n#include <pmax/dev/device.h>\n#include <machine/bus.h>\n#include <machine/autoconf.h>\n#include <machine/cpu.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/tc/ioasicvar.h>\n#include <dev/tc/tcvar.h>\n#include <sys/reboot.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/errno.h>\n#include <sys/conf.h>\n#include <sys/buf.h>\n#include <sys/dkstat.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <asc.h>\n\nstatic int\nasc_last_dma_in(asc, status, ss, ir)\n\tregister asc_softc_t asc;\n\tregister int status, ss, ir;\n{\n\tregister asc_regmap_t *regs = asc->regs;\n\tregister State *state = &asc->st[asc->target];\n\tregister int len, fifo;\n\n\tASC_TC_GET(regs, len);\n\tfifo = regs->asc_flags & ASC_FLAGS_FIFO_CNT;\n#ifdef DEBUG\n\tif (asc_debug > 2)\n\t\tprintf(\"asc_last_dma_in: buflen %d dmalen %d tc %d fifo %d\\n\",\n\t\t\tstate->buflen, state->dmalen, len, fifo);\n#endif\n\tif (fifo) {\n\t\t/* device must be trying to send more than we expect */\n\t\tregs->asc_cmd = ASC_CMD_FLUSH;\n\t\treadback(regs->asc_cmd);\n\t}\n\tstate->flags &= ~DMA_IN_PROGRESS;\n\tlen = state->dmalen - len;\n\tstate->dmalen = len;\t/* dma_end may need actual length */\n\t(*asc->dma_end)(asc, state, ASCDMA_READ);\n\tstate->buflen -= len;\n\n\treturn (1);\n}"
  },
  {
    "function_name": "asc_dma_in",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/tc/asc.c",
    "lines": "1451-1530",
    "snippet": "static int\nasc_dma_in(asc, status, ss, ir)\n\tregister asc_softc_t asc;\n\tregister int status, ss, ir;\n{\n\tregister asc_regmap_t *regs = asc->regs;\n\tregister State *state = &asc->st[asc->target];\n\tregister int len;\n\n\t/* check for previous chunk in buffer */\n\tif (state->flags & DMA_IN_PROGRESS) {\n\t\t/*\n\t\t * Only count bytes that have been copied to memory.\n\t\t * There may be some bytes in the FIFO if synchonous transfers\n\t\t * are in progress.\n\t\t */\n\t\tASC_TC_GET(regs, len);\n\t\tlen = state->dmalen - len;\n\t\tstate->dmalen = len;\t/* dma_end may need actual length */\n\t\t(*asc->dma_end)(asc, state, ASCDMA_READ);\n\t\tstate->buf += len;\n\t\tstate->buflen -= len;\n\t}\n\n\tif (!(state->flags & DMA_IN_PROGRESS) &&\n\t    (regs->asc_flags & ASC_FLAGS_FIFO_CNT) != 0) {\n\t  \tvolatile int async_fifo_junk = 0;\n\n\t\t/*\n\t\t * If the target is asynchronous, the FIFO contains\n\t\t * a byte of garbage. (see the Mach mk84 53c94 driver,\n\t\t * where this occurs on tk-50s and exabytes.)\n\t\t * It also occurs on  asynch disks like SCSI-1 disks.\n\t\t * Recover by reading the byte of junk from the fifo if,\n\t\t * and only if, the target is async. If the target is\n\t\t * synch, there is no junk, and reading the fifo\n\t\t * deadlocks our SCSI state machine.\n\t\t */\n\t\t if (state->sync_offset == 0)\n\t\t\tasync_fifo_junk = regs->asc_fifo;\n#ifdef ASC_DIAGNOSTIC\n\t\tprintf(\"%s: asc_dma_in: FIFO count %x flags %x sync_offset %d\",\n\t\t    asc->sc_dev.dv_xname, regs->asc_flags,\n\t\t       state->flags, state->sync_offset);\n\t\tif (state->sync_offset != 0)\n\t\t\tprintf(\"\\n\");\n\t\telse\n\t\t\tprintf(\" unexpected fifo data %x\\n\", async_fifo_junk);\n#ifdef DEBUG\n\t\tasc_DumpLog(\"asc_dma_in\");\n#endif\t/* DEBUG */\n#endif\t/* ASC_DIAGNOSTIC */\n\n\t}\n\t/* setup to start reading the next chunk */\n\tlen = state->buflen;\n#ifdef DEBUG\n\tif (asc_logp == asc_log)\n\t\tasc_log[NLOG - 1].resid = len;\n\telse\n\t\tasc_logp[-1].resid = len;\n#endif\n\tlen = (*asc->dma_start)(asc, state, state->buf, ASCDMA_READ, len, 0);\n\tstate->dmalen = len;\n\tASC_TC_PUT(regs, len);\n#ifdef DEBUG\n\tif (asc_debug > 2)\n\t\tprintf(\"asc_dma_in: buflen %d, len %d\\n\", state->buflen, len);\n#endif\n\n\t/* check for next chunk */\n\tstate->flags |= DMA_IN_PROGRESS;\n\tif (len != state->buflen) {\n\t\tregs->asc_cmd = ASC_CMD_XFER_INFO | ASC_CMD_DMA;\n\t\treadback(regs->asc_cmd);\n\t\tasc->script = &asc_scripts[SCRIPT_CONTINUE_IN];\n\t\treturn (0);\n\t}\n\treturn (1);\n}",
    "includes": [
      "#include <dev/tc/ascvar.h>",
      "#include <pmax/pmax/kmin.h>",
      "#include <pmax/pmax/asic.h>",
      "#include <pmax/dev/ascreg.h>",
      "#include <pmax/dev/scsi.h>",
      "#include <pmax/dev/device.h>",
      "#include <machine/bus.h>",
      "#include <machine/autoconf.h>",
      "#include <machine/cpu.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/tc/ioasicvar.h>",
      "#include <dev/tc/tcvar.h>",
      "#include <sys/reboot.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/errno.h>",
      "#include <sys/conf.h>",
      "#include <sys/buf.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <asc.h>"
    ],
    "macros_used": [
      "#define\tSCRIPT_CONTINUE_IN\t2",
      "#define NLOG 32"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "readback",
          "args": [
            "regs->asc_cmd"
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"asc_dma_in: buflen %d, len %d\\n\"",
            "state->buflen",
            "len"
          ],
          "line": 1518
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASC_TC_PUT",
          "args": [
            "regs",
            "len"
          ],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "asc",
            "state",
            "state->buf",
            "ASCDMA_READ",
            "len",
            "0"
          ],
          "line": 1513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asc_DumpLog",
          "args": [
            "\"asc_dma_in\""
          ],
          "line": 1500
        },
        "resolved": true,
        "details": {
          "function_name": "asc_DumpLog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/tc/asc.c",
          "lines": "2132-2156",
          "snippet": "void\nasc_DumpLog(str)\n\tchar *str;\n{\n\tregister struct asc_log *lp;\n\tregister u_int status;\n\n\tprintf(\"asc: %s: cmd %x bn %d cnt %d\\n\", str, asc_debug_cmd,\n\t\tasc_debug_bn, asc_debug_sz);\n\tlp = asc_logp;\n\tdo {\n\t\tstatus = lp->status;\n\t\tprintf(\"asc%d tgt %d status %x ss %x ir %x cond %d:%x msg %x resid %d\\n\",\n\t\t\tstatus >> 24,\n\t\t\tlp->target,\n\t\t\t(status >> 16) & 0xFF,\n\t\t\t(status >> 8) & 0xFF,\n\t\t\tstatus & 0XFF,\n\t\t\tlp->state,\n\t\t\tasc_scripts[lp->state].condition,\n\t\t\tlp->msg, lp->resid);\n\t\tif (++lp >= &asc_log[NLOG])\n\t\t\tlp = asc_log;\n\t} while (lp != asc_logp);\n}",
          "includes": [
            "#include <dev/tc/ascvar.h>",
            "#include <pmax/pmax/kmin.h>",
            "#include <pmax/pmax/asic.h>",
            "#include <pmax/dev/ascreg.h>",
            "#include <pmax/dev/scsi.h>",
            "#include <pmax/dev/device.h>",
            "#include <machine/bus.h>",
            "#include <machine/autoconf.h>",
            "#include <machine/cpu.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/tc/ioasicvar.h>",
            "#include <dev/tc/tcvar.h>",
            "#include <sys/reboot.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/errno.h>",
            "#include <sys/conf.h>",
            "#include <sys/buf.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <asc.h>"
          ],
          "macros_used": [
            "#define NLOG 32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/tc/ascvar.h>\n#include <pmax/pmax/kmin.h>\n#include <pmax/pmax/asic.h>\n#include <pmax/dev/ascreg.h>\n#include <pmax/dev/scsi.h>\n#include <pmax/dev/device.h>\n#include <machine/bus.h>\n#include <machine/autoconf.h>\n#include <machine/cpu.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/tc/ioasicvar.h>\n#include <dev/tc/tcvar.h>\n#include <sys/reboot.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/errno.h>\n#include <sys/conf.h>\n#include <sys/buf.h>\n#include <sys/dkstat.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <asc.h>\n\n#define NLOG 32\n\nvoid\nasc_DumpLog(str)\n\tchar *str;\n{\n\tregister struct asc_log *lp;\n\tregister u_int status;\n\n\tprintf(\"asc: %s: cmd %x bn %d cnt %d\\n\", str, asc_debug_cmd,\n\t\tasc_debug_bn, asc_debug_sz);\n\tlp = asc_logp;\n\tdo {\n\t\tstatus = lp->status;\n\t\tprintf(\"asc%d tgt %d status %x ss %x ir %x cond %d:%x msg %x resid %d\\n\",\n\t\t\tstatus >> 24,\n\t\t\tlp->target,\n\t\t\t(status >> 16) & 0xFF,\n\t\t\t(status >> 8) & 0xFF,\n\t\t\tstatus & 0XFF,\n\t\t\tlp->state,\n\t\t\tasc_scripts[lp->state].condition,\n\t\t\tlp->msg, lp->resid);\n\t\tif (++lp >= &asc_log[NLOG])\n\t\t\tlp = asc_log;\n\t} while (lp != asc_logp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "asc",
            "state",
            "ASCDMA_READ"
          ],
          "line": 1470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASC_TC_GET",
          "args": [
            "regs",
            "len"
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/tc/ascvar.h>\n#include <pmax/pmax/kmin.h>\n#include <pmax/pmax/asic.h>\n#include <pmax/dev/ascreg.h>\n#include <pmax/dev/scsi.h>\n#include <pmax/dev/device.h>\n#include <machine/bus.h>\n#include <machine/autoconf.h>\n#include <machine/cpu.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/tc/ioasicvar.h>\n#include <dev/tc/tcvar.h>\n#include <sys/reboot.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/errno.h>\n#include <sys/conf.h>\n#include <sys/buf.h>\n#include <sys/dkstat.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <asc.h>\n\n#define\tSCRIPT_CONTINUE_IN\t2\n#define NLOG 32\n\nstatic int\nasc_dma_in(asc, status, ss, ir)\n\tregister asc_softc_t asc;\n\tregister int status, ss, ir;\n{\n\tregister asc_regmap_t *regs = asc->regs;\n\tregister State *state = &asc->st[asc->target];\n\tregister int len;\n\n\t/* check for previous chunk in buffer */\n\tif (state->flags & DMA_IN_PROGRESS) {\n\t\t/*\n\t\t * Only count bytes that have been copied to memory.\n\t\t * There may be some bytes in the FIFO if synchonous transfers\n\t\t * are in progress.\n\t\t */\n\t\tASC_TC_GET(regs, len);\n\t\tlen = state->dmalen - len;\n\t\tstate->dmalen = len;\t/* dma_end may need actual length */\n\t\t(*asc->dma_end)(asc, state, ASCDMA_READ);\n\t\tstate->buf += len;\n\t\tstate->buflen -= len;\n\t}\n\n\tif (!(state->flags & DMA_IN_PROGRESS) &&\n\t    (regs->asc_flags & ASC_FLAGS_FIFO_CNT) != 0) {\n\t  \tvolatile int async_fifo_junk = 0;\n\n\t\t/*\n\t\t * If the target is asynchronous, the FIFO contains\n\t\t * a byte of garbage. (see the Mach mk84 53c94 driver,\n\t\t * where this occurs on tk-50s and exabytes.)\n\t\t * It also occurs on  asynch disks like SCSI-1 disks.\n\t\t * Recover by reading the byte of junk from the fifo if,\n\t\t * and only if, the target is async. If the target is\n\t\t * synch, there is no junk, and reading the fifo\n\t\t * deadlocks our SCSI state machine.\n\t\t */\n\t\t if (state->sync_offset == 0)\n\t\t\tasync_fifo_junk = regs->asc_fifo;\n#ifdef ASC_DIAGNOSTIC\n\t\tprintf(\"%s: asc_dma_in: FIFO count %x flags %x sync_offset %d\",\n\t\t    asc->sc_dev.dv_xname, regs->asc_flags,\n\t\t       state->flags, state->sync_offset);\n\t\tif (state->sync_offset != 0)\n\t\t\tprintf(\"\\n\");\n\t\telse\n\t\t\tprintf(\" unexpected fifo data %x\\n\", async_fifo_junk);\n#ifdef DEBUG\n\t\tasc_DumpLog(\"asc_dma_in\");\n#endif\t/* DEBUG */\n#endif\t/* ASC_DIAGNOSTIC */\n\n\t}\n\t/* setup to start reading the next chunk */\n\tlen = state->buflen;\n#ifdef DEBUG\n\tif (asc_logp == asc_log)\n\t\tasc_log[NLOG - 1].resid = len;\n\telse\n\t\tasc_logp[-1].resid = len;\n#endif\n\tlen = (*asc->dma_start)(asc, state, state->buf, ASCDMA_READ, len, 0);\n\tstate->dmalen = len;\n\tASC_TC_PUT(regs, len);\n#ifdef DEBUG\n\tif (asc_debug > 2)\n\t\tprintf(\"asc_dma_in: buflen %d, len %d\\n\", state->buflen, len);\n#endif\n\n\t/* check for next chunk */\n\tstate->flags |= DMA_IN_PROGRESS;\n\tif (len != state->buflen) {\n\t\tregs->asc_cmd = ASC_CMD_XFER_INFO | ASC_CMD_DMA;\n\t\treadback(regs->asc_cmd);\n\t\tasc->script = &asc_scripts[SCRIPT_CONTINUE_IN];\n\t\treturn (0);\n\t}\n\treturn (1);\n}"
  },
  {
    "function_name": "asc_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/tc/asc.c",
    "lines": "1366-1448",
    "snippet": "static int\nasc_end(asc, status, ss, ir)\n\tregister asc_softc_t asc;\n\tregister int status, ss, ir;\n{\n\tregister ScsiCmd *scsicmd;\n\tregister State *state;\n\tregister int i, target;\n\n\tasc->state = ASC_STATE_IDLE;\n\ttarget = asc->target;\n\tasc->target = -1;\n\tscsicmd = asc->cmd[target];\n\tasc->cmd[target] = (ScsiCmd *)0;\n\tstate = &asc->st[target];\n\tuntimeout(asc_timeout, scsicmd);\n\n#ifdef DEBUG\n\tif (asc_debug > 1) {\n\t\tprintf(\"asc_end: %s target %d cmd %x err %d resid %d\\n\",\n\t\t\tscsicmd->sd->sd_driver->d_name, target,\n\t\t\tscsicmd->cmd[0], state->error, state->buflen);\n\t}\n#endif\n#ifdef DIAGNOSTIC\n\tif (target < 0 || !scsicmd)\n\t\tpanic(\"asc_end\");\n#endif\n\n\t/* look for disconnected devices */\n\tfor (i = 0; i < ASC_NCMD; i++) {\n\t\tif (!asc->cmd[i] || !(asc->st[i].flags & DISCONN))\n\t\t\tcontinue;\n\t\tasc->regs->asc_cmd = ASC_CMD_ENABLE_SEL;\n\t\treadback(asc->regs->asc_cmd);\n\t\tasc->state = ASC_STATE_RESEL;\n\t\tasc->script = &asc_scripts[SCRIPT_RESEL];\n\t\tbreak;\n\t}\n\n#ifdef USE_NEW_SCSI\n\tif(scsicmd->error == XS_NOERROR && !(state->flags & CHECK_SENSE)) {\n\t\tif((state->statusByte & ST_MASK) == SCSI_CHECK) {\n\t\t\tstruct scsi_sense *ss = (void *)&state->cmd;\n\t\t\t/* Save return values */\n\t\t\tscsicmd->resid = state->buflen;\n\t\t\tscsicmd->status = state->statusByte;\n\t\t\t/* Set up sense request command */\n\t\t\tbzero(ss, sizeof(*ss));\n\t\t\tss->opcode = REQUEST_SENSE;\n\t\t\tss->byte2 = sc_link->lun << 5;\n\t\t\tss->length = sizeof(struct scsi_sense_data);\n\t\t\tstate->cmdlen = sizeof(*ss);\n\t\t\tstate->buf = (vm_offset_t)&scsicmd->sense;\n\t\t\tstate->buflen = sizeof(struct scsi_sense_data);\n\t\t\tstate->flags |= CHECK_SENSE;\n\t\t\tMachFlushDCache(state->buf, state->buflen);\n\t\t\tasc->cmd[target] = scsicmd;\n\t\t\tasc_startcmd(asc, target);\n\t\t\treturn(0);\n\t\t}\n\t}\n#endif /*USE_NEW_SCSI*/\n\n\t/*\n\t * Look for another device that is ready.\n\t * May want to keep last one started and increment for fairness\n\t * rather than always starting at zero.\n\t */\n\tfor (i = 0; i < ASC_NCMD; i++) {\n\t\t/* don't restart a disconnected command */\n\t\tif (!asc->cmd[i] || (asc->st[i].flags & DISCONN))\n\t\t\tcontinue;\n\t\tasc_startcmd(asc, i);\n\t\tbreak;\n\t}\n\n\t/* signal device driver that the command is done */\n\t(*scsicmd->sd->sd_driver->d_done)(scsicmd->unit, state->error,\n\t\tstate->buflen, state->statusByte);\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/tc/ascvar.h>",
      "#include <pmax/pmax/kmin.h>",
      "#include <pmax/pmax/asic.h>",
      "#include <pmax/dev/ascreg.h>",
      "#include <pmax/dev/scsi.h>",
      "#include <pmax/dev/device.h>",
      "#include <machine/bus.h>",
      "#include <machine/autoconf.h>",
      "#include <machine/cpu.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/tc/ioasicvar.h>",
      "#include <dev/tc/tcvar.h>",
      "#include <sys/reboot.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/errno.h>",
      "#include <sys/conf.h>",
      "#include <sys/buf.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <asc.h>"
    ],
    "macros_used": [
      "#define\tSCRIPT_RESEL\t\t16"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "scsicmd->unit",
            "state->error",
            "state->buflen",
            "state->statusByte"
          ],
          "line": 1444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asc_startcmd",
          "args": [
            "asc",
            "i"
          ],
          "line": 1439
        },
        "resolved": true,
        "details": {
          "function_name": "asc_startcmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/tc/asc.c",
          "lines": "660-809",
          "snippet": "static void\nasc_startcmd(asc, target)\n\tasc_softc_t asc;\n\tint target;\n{\n\tregister asc_regmap_t *regs;\n\tregister ScsiCmd *scsicmd;\n\tregister State *state;\n\tint len;\n\n\t/*\n\t * See if another target is currently selected on this SCSI bus.\n\t */\n\tif (asc->target >= 0)\n\t\treturn;\n\n\tregs = asc->regs;\n\n\t/*\n\t * If a reselection is in progress, it is Ok to ignore it since\n\t * the ASC will automatically cancel the command and flush\n\t * the FIFO if the ASC is reselected before the command starts.\n\t * If we try to use ASC_CMD_DISABLE_SEL, we can hang the system if\n\t * a reselect occurs before starting the command.\n\t */\n\n\tasc->state = ASC_STATE_BUSY;\n\tasc->target = target;\n\n\t/* cache some pointers */\n\tscsicmd = asc->cmd[target];\n\tstate = &asc->st[target];\n\n#ifdef DEBUG\n\tif (asc_debug > 1) {\n\t\tprintf(\"asc_startcmd: %s target %d cmd %x len %d\\n\",\n\t\t    scsicmd->sd->sd_driver->d_name, target,\n\t\t    scsicmd->cmd[0], scsicmd->buflen);\n\t}\n#endif\n\n\t/* Try to avoid reselect collisions */\n\tif ((regs->asc_status & (ASC_CSR_INT|SCSI_PHASE_MSG_IN)) ==\n\t    (ASC_CSR_INT|SCSI_PHASE_MSG_IN)) {\n/*\t\tprintf(\"asc_startcmd: possible reselect in progress\\n\"); */\n\t\treturn;\n\t}\n\n\t/*\n\t * Init the chip and target state.\n\t */\n\tstate->flags = state->flags & DID_SYNC;\n\tstate->error = 0;\n\tstate->script = (script_t *)0;\n\tstate->msg_out = SCSI_NO_OP;\n\n\tlen = scsicmd->cmdlen;\n\tstate->dmalen = len;\n\n\t/* check for simple SCSI command with no data transfer */\n\tif ((state->buflen = scsicmd->buflen) == 0) {\n\t\t/* check for sync negotiation */\n\t\tif ((scsicmd->flags & SCSICMD_USE_SYNC) &&\n\t\t    !(state->flags & DID_SYNC)) {\n\t\t\tasc->script = &asc_scripts[SCRIPT_TRY_SYNC];\n\t\t\tstate->flags |= TRY_SYNC;\n\t\t} else\n\t\t\tasc->script = &asc_scripts[SCRIPT_SIMPLE];\n\t\tstate->buf = (char *)0;\n\t} else if (scsicmd->flags & SCSICMD_DATA_TO_DEVICE) {\n\t\tasc->script = &asc_scripts[SCRIPT_DATA_OUT];\n\t\tstate->buf = scsicmd->buf;\n\t\tstate->flags |= DMA_OUT;\n\t} else {\n\t\tasc->script = &asc_scripts[SCRIPT_DATA_IN];\n\t\tstate->buf = scsicmd->buf;\n\t\tstate->flags |= DMA_IN;\n\t}\n\n#ifdef DEBUG\n\tasc_debug_cmd = scsicmd->cmd[0];\n\tif (scsicmd->cmd[0] == SCSI_READ_EXT) {\n\t\tasc_debug_bn = (scsicmd->cmd[2] << 24) |\n\t\t\t(scsicmd->cmd[3] << 16) |\n\t\t\t(scsicmd->cmd[4] << 8) |\n\t\t\tscsicmd->cmd[5];\n\t\tasc_debug_sz = (scsicmd->cmd[7] << 8) | scsicmd->cmd[8];\n\t}\n\tasc_logp->status = PACK(asc->sc_dev.dv_unit, 0, 0, asc_debug_cmd);\n\tasc_logp->target = asc->target;\n\tasc_logp->state = asc->script - asc_scripts;\n\tasc_logp->msg = SCSI_DIS_REC_IDENTIFY;\n\tasc_logp->resid = scsicmd->buflen;\n\tif (++asc_logp >= &asc_log[NLOG])\n\t\tasc_logp = asc_log;\n#endif\n\n\t/* preload the FIFO with the message to be sent */\n\tregs->asc_fifo = SCSI_DIS_REC_IDENTIFY;\n\ttc_mb();\n\n\t/* initialize the DMA */\n\tlen = (*asc->dma_start)(asc, state, scsicmd->cmd, ASCDMA_WRITE,\n\t   len, 0);\n\tASC_TC_PUT(regs, len);\n\treadback(regs->asc_cmd);\n\n\tregs->asc_dbus_id = target;\n\treadback(regs->asc_dbus_id);\n\tregs->asc_syn_p = state->sync_period;\n\treadback(regs->asc_syn_p);\n\tregs->asc_syn_o = state->sync_offset;\n\treadback(regs->asc_syn_o);\n\n\t/* Try to avoid reselect collisions */\n\tif ((regs->asc_status & (ASC_CSR_INT|SCSI_PHASE_MSG_IN)) ==\n\t    (ASC_CSR_INT|SCSI_PHASE_MSG_IN)) {\n/*\t\tprintf(\"asc_startcmd: reselect in progress (before select)\\n\");*/\n\t\treturn;\n\t}\n\n\tif (state->flags & TRY_SYNC)\n\t\tregs->asc_cmd = len = ASC_CMD_SEL_ATN_STOP;\n\telse\n\t\tregs->asc_cmd = len = ASC_CMD_SEL_ATN | ASC_CMD_DMA;\n\treadback(regs->asc_cmd);\n\n\t/* Try to avoid reselect collisions */\n\tif ((regs->asc_status & (ASC_CSR_INT|SCSI_PHASE_MSG_IN)) ==\n\t    (ASC_CSR_INT|SCSI_PHASE_MSG_IN)) {\n/*\t\tprintf(\"asc_startcmd: reselect in progress after select\\n\");*/\n\t\treturn;\n\t} else {\n\t\t/*\n\t\t * Here's a potentially nasty but infrequent problem:  a\n\t\t * reselect may have occurred, but did not interrupt.\n\t\t */\n\t\tif (regs->asc_cmd != len &&\n\t\t    regs->asc_cmd == (ASC_CMD_NOP|ASC_CMD_DMA)) {\n\t\t    \tif ((regs->asc_status & ASC_CSR_INT) == 0) {\n\t\t    \t\tdelay(250);\n\t\t    \t\tif (regs->asc_status == SCSI_PHASE_MSG_IN) {\n\t\t    \t\t\tprintf(\"asc_startcmd: reselect failed to interrupt?\\n\");\n\t\t    \t\t\t/* XXXX THIS NEEDS FIXING */\n\t\t    \t\t}\n\t\t    \t}\n\t\t}\n\t}\n\n}",
          "includes": [
            "#include <dev/tc/ascvar.h>",
            "#include <pmax/pmax/kmin.h>",
            "#include <pmax/pmax/asic.h>",
            "#include <pmax/dev/ascreg.h>",
            "#include <pmax/dev/scsi.h>",
            "#include <pmax/dev/device.h>",
            "#include <machine/bus.h>",
            "#include <machine/autoconf.h>",
            "#include <machine/cpu.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/tc/ioasicvar.h>",
            "#include <dev/tc/tcvar.h>",
            "#include <sys/reboot.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/errno.h>",
            "#include <sys/conf.h>",
            "#include <sys/buf.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <asc.h>"
          ],
          "macros_used": [
            "#define\tSCRIPT_TRY_SYNC\t\t12",
            "#define\tSCRIPT_SIMPLE\t\t6",
            "#define\tSCRIPT_DATA_OUT\t\t3",
            "#define\tSCRIPT_DATA_IN\t\t0",
            "#define NLOG 32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/tc/ascvar.h>\n#include <pmax/pmax/kmin.h>\n#include <pmax/pmax/asic.h>\n#include <pmax/dev/ascreg.h>\n#include <pmax/dev/scsi.h>\n#include <pmax/dev/device.h>\n#include <machine/bus.h>\n#include <machine/autoconf.h>\n#include <machine/cpu.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/tc/ioasicvar.h>\n#include <dev/tc/tcvar.h>\n#include <sys/reboot.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/errno.h>\n#include <sys/conf.h>\n#include <sys/buf.h>\n#include <sys/dkstat.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <asc.h>\n\n#define\tSCRIPT_TRY_SYNC\t\t12\n#define\tSCRIPT_SIMPLE\t\t6\n#define\tSCRIPT_DATA_OUT\t\t3\n#define\tSCRIPT_DATA_IN\t\t0\n#define NLOG 32\n\nstatic void\nasc_startcmd(asc, target)\n\tasc_softc_t asc;\n\tint target;\n{\n\tregister asc_regmap_t *regs;\n\tregister ScsiCmd *scsicmd;\n\tregister State *state;\n\tint len;\n\n\t/*\n\t * See if another target is currently selected on this SCSI bus.\n\t */\n\tif (asc->target >= 0)\n\t\treturn;\n\n\tregs = asc->regs;\n\n\t/*\n\t * If a reselection is in progress, it is Ok to ignore it since\n\t * the ASC will automatically cancel the command and flush\n\t * the FIFO if the ASC is reselected before the command starts.\n\t * If we try to use ASC_CMD_DISABLE_SEL, we can hang the system if\n\t * a reselect occurs before starting the command.\n\t */\n\n\tasc->state = ASC_STATE_BUSY;\n\tasc->target = target;\n\n\t/* cache some pointers */\n\tscsicmd = asc->cmd[target];\n\tstate = &asc->st[target];\n\n#ifdef DEBUG\n\tif (asc_debug > 1) {\n\t\tprintf(\"asc_startcmd: %s target %d cmd %x len %d\\n\",\n\t\t    scsicmd->sd->sd_driver->d_name, target,\n\t\t    scsicmd->cmd[0], scsicmd->buflen);\n\t}\n#endif\n\n\t/* Try to avoid reselect collisions */\n\tif ((regs->asc_status & (ASC_CSR_INT|SCSI_PHASE_MSG_IN)) ==\n\t    (ASC_CSR_INT|SCSI_PHASE_MSG_IN)) {\n/*\t\tprintf(\"asc_startcmd: possible reselect in progress\\n\"); */\n\t\treturn;\n\t}\n\n\t/*\n\t * Init the chip and target state.\n\t */\n\tstate->flags = state->flags & DID_SYNC;\n\tstate->error = 0;\n\tstate->script = (script_t *)0;\n\tstate->msg_out = SCSI_NO_OP;\n\n\tlen = scsicmd->cmdlen;\n\tstate->dmalen = len;\n\n\t/* check for simple SCSI command with no data transfer */\n\tif ((state->buflen = scsicmd->buflen) == 0) {\n\t\t/* check for sync negotiation */\n\t\tif ((scsicmd->flags & SCSICMD_USE_SYNC) &&\n\t\t    !(state->flags & DID_SYNC)) {\n\t\t\tasc->script = &asc_scripts[SCRIPT_TRY_SYNC];\n\t\t\tstate->flags |= TRY_SYNC;\n\t\t} else\n\t\t\tasc->script = &asc_scripts[SCRIPT_SIMPLE];\n\t\tstate->buf = (char *)0;\n\t} else if (scsicmd->flags & SCSICMD_DATA_TO_DEVICE) {\n\t\tasc->script = &asc_scripts[SCRIPT_DATA_OUT];\n\t\tstate->buf = scsicmd->buf;\n\t\tstate->flags |= DMA_OUT;\n\t} else {\n\t\tasc->script = &asc_scripts[SCRIPT_DATA_IN];\n\t\tstate->buf = scsicmd->buf;\n\t\tstate->flags |= DMA_IN;\n\t}\n\n#ifdef DEBUG\n\tasc_debug_cmd = scsicmd->cmd[0];\n\tif (scsicmd->cmd[0] == SCSI_READ_EXT) {\n\t\tasc_debug_bn = (scsicmd->cmd[2] << 24) |\n\t\t\t(scsicmd->cmd[3] << 16) |\n\t\t\t(scsicmd->cmd[4] << 8) |\n\t\t\tscsicmd->cmd[5];\n\t\tasc_debug_sz = (scsicmd->cmd[7] << 8) | scsicmd->cmd[8];\n\t}\n\tasc_logp->status = PACK(asc->sc_dev.dv_unit, 0, 0, asc_debug_cmd);\n\tasc_logp->target = asc->target;\n\tasc_logp->state = asc->script - asc_scripts;\n\tasc_logp->msg = SCSI_DIS_REC_IDENTIFY;\n\tasc_logp->resid = scsicmd->buflen;\n\tif (++asc_logp >= &asc_log[NLOG])\n\t\tasc_logp = asc_log;\n#endif\n\n\t/* preload the FIFO with the message to be sent */\n\tregs->asc_fifo = SCSI_DIS_REC_IDENTIFY;\n\ttc_mb();\n\n\t/* initialize the DMA */\n\tlen = (*asc->dma_start)(asc, state, scsicmd->cmd, ASCDMA_WRITE,\n\t   len, 0);\n\tASC_TC_PUT(regs, len);\n\treadback(regs->asc_cmd);\n\n\tregs->asc_dbus_id = target;\n\treadback(regs->asc_dbus_id);\n\tregs->asc_syn_p = state->sync_period;\n\treadback(regs->asc_syn_p);\n\tregs->asc_syn_o = state->sync_offset;\n\treadback(regs->asc_syn_o);\n\n\t/* Try to avoid reselect collisions */\n\tif ((regs->asc_status & (ASC_CSR_INT|SCSI_PHASE_MSG_IN)) ==\n\t    (ASC_CSR_INT|SCSI_PHASE_MSG_IN)) {\n/*\t\tprintf(\"asc_startcmd: reselect in progress (before select)\\n\");*/\n\t\treturn;\n\t}\n\n\tif (state->flags & TRY_SYNC)\n\t\tregs->asc_cmd = len = ASC_CMD_SEL_ATN_STOP;\n\telse\n\t\tregs->asc_cmd = len = ASC_CMD_SEL_ATN | ASC_CMD_DMA;\n\treadback(regs->asc_cmd);\n\n\t/* Try to avoid reselect collisions */\n\tif ((regs->asc_status & (ASC_CSR_INT|SCSI_PHASE_MSG_IN)) ==\n\t    (ASC_CSR_INT|SCSI_PHASE_MSG_IN)) {\n/*\t\tprintf(\"asc_startcmd: reselect in progress after select\\n\");*/\n\t\treturn;\n\t} else {\n\t\t/*\n\t\t * Here's a potentially nasty but infrequent problem:  a\n\t\t * reselect may have occurred, but did not interrupt.\n\t\t */\n\t\tif (regs->asc_cmd != len &&\n\t\t    regs->asc_cmd == (ASC_CMD_NOP|ASC_CMD_DMA)) {\n\t\t    \tif ((regs->asc_status & ASC_CSR_INT) == 0) {\n\t\t    \t\tdelay(250);\n\t\t    \t\tif (regs->asc_status == SCSI_PHASE_MSG_IN) {\n\t\t    \t\t\tprintf(\"asc_startcmd: reselect failed to interrupt?\\n\");\n\t\t    \t\t\t/* XXXX THIS NEEDS FIXING */\n\t\t    \t\t}\n\t\t    \t}\n\t\t}\n\t}\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "MachFlushDCache",
          "args": [
            "state->buf",
            "state->buflen"
          ],
          "line": 1422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "ss",
            "sizeof(*ss)"
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readback",
          "args": [
            "asc->regs->asc_cmd"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"asc_end\""
          ],
          "line": 1392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"asc_end: %s target %d cmd %x err %d resid %d\\n\"",
            "scsicmd->sd->sd_driver->d_name",
            "target",
            "scsicmd->cmd[0]",
            "state->error",
            "state->buflen"
          ],
          "line": 1385
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "untimeout",
          "args": [
            "asc_timeout",
            "scsicmd"
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/tc/ascvar.h>\n#include <pmax/pmax/kmin.h>\n#include <pmax/pmax/asic.h>\n#include <pmax/dev/ascreg.h>\n#include <pmax/dev/scsi.h>\n#include <pmax/dev/device.h>\n#include <machine/bus.h>\n#include <machine/autoconf.h>\n#include <machine/cpu.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/tc/ioasicvar.h>\n#include <dev/tc/tcvar.h>\n#include <sys/reboot.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/errno.h>\n#include <sys/conf.h>\n#include <sys/buf.h>\n#include <sys/dkstat.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <asc.h>\n\n#define\tSCRIPT_RESEL\t\t16\n\nstatic int\nasc_end(asc, status, ss, ir)\n\tregister asc_softc_t asc;\n\tregister int status, ss, ir;\n{\n\tregister ScsiCmd *scsicmd;\n\tregister State *state;\n\tregister int i, target;\n\n\tasc->state = ASC_STATE_IDLE;\n\ttarget = asc->target;\n\tasc->target = -1;\n\tscsicmd = asc->cmd[target];\n\tasc->cmd[target] = (ScsiCmd *)0;\n\tstate = &asc->st[target];\n\tuntimeout(asc_timeout, scsicmd);\n\n#ifdef DEBUG\n\tif (asc_debug > 1) {\n\t\tprintf(\"asc_end: %s target %d cmd %x err %d resid %d\\n\",\n\t\t\tscsicmd->sd->sd_driver->d_name, target,\n\t\t\tscsicmd->cmd[0], state->error, state->buflen);\n\t}\n#endif\n#ifdef DIAGNOSTIC\n\tif (target < 0 || !scsicmd)\n\t\tpanic(\"asc_end\");\n#endif\n\n\t/* look for disconnected devices */\n\tfor (i = 0; i < ASC_NCMD; i++) {\n\t\tif (!asc->cmd[i] || !(asc->st[i].flags & DISCONN))\n\t\t\tcontinue;\n\t\tasc->regs->asc_cmd = ASC_CMD_ENABLE_SEL;\n\t\treadback(asc->regs->asc_cmd);\n\t\tasc->state = ASC_STATE_RESEL;\n\t\tasc->script = &asc_scripts[SCRIPT_RESEL];\n\t\tbreak;\n\t}\n\n#ifdef USE_NEW_SCSI\n\tif(scsicmd->error == XS_NOERROR && !(state->flags & CHECK_SENSE)) {\n\t\tif((state->statusByte & ST_MASK) == SCSI_CHECK) {\n\t\t\tstruct scsi_sense *ss = (void *)&state->cmd;\n\t\t\t/* Save return values */\n\t\t\tscsicmd->resid = state->buflen;\n\t\t\tscsicmd->status = state->statusByte;\n\t\t\t/* Set up sense request command */\n\t\t\tbzero(ss, sizeof(*ss));\n\t\t\tss->opcode = REQUEST_SENSE;\n\t\t\tss->byte2 = sc_link->lun << 5;\n\t\t\tss->length = sizeof(struct scsi_sense_data);\n\t\t\tstate->cmdlen = sizeof(*ss);\n\t\t\tstate->buf = (vm_offset_t)&scsicmd->sense;\n\t\t\tstate->buflen = sizeof(struct scsi_sense_data);\n\t\t\tstate->flags |= CHECK_SENSE;\n\t\t\tMachFlushDCache(state->buf, state->buflen);\n\t\t\tasc->cmd[target] = scsicmd;\n\t\t\tasc_startcmd(asc, target);\n\t\t\treturn(0);\n\t\t}\n\t}\n#endif /*USE_NEW_SCSI*/\n\n\t/*\n\t * Look for another device that is ready.\n\t * May want to keep last one started and increment for fairness\n\t * rather than always starting at zero.\n\t */\n\tfor (i = 0; i < ASC_NCMD; i++) {\n\t\t/* don't restart a disconnected command */\n\t\tif (!asc->cmd[i] || (asc->st[i].flags & DISCONN))\n\t\t\tcontinue;\n\t\tasc_startcmd(asc, i);\n\t\tbreak;\n\t}\n\n\t/* signal device driver that the command is done */\n\t(*scsicmd->sd->sd_driver->d_done)(scsicmd->unit, state->error,\n\t\tstate->buflen, state->statusByte);\n\n\treturn (0);\n}"
  },
  {
    "function_name": "asc_get_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/tc/asc.c",
    "lines": "1317-1363",
    "snippet": "static int\nasc_get_status(asc, status, ss, ir)\n\tregister asc_softc_t asc;\n\tregister int status, ss, ir;\n{\n\tregister asc_regmap_t *regs = asc->regs;\n\tregister int data;\n\n\t/*\n\t * Get the last two bytes in the FIFO.\n\t */\n\tif ((data = regs->asc_flags & ASC_FLAGS_FIFO_CNT) != 2) {\n\t\tprintf(\"asc_get_status: cmdreg %x, fifo cnt %d\\n\",\n\t\t       regs->asc_cmd, data); /* XXX */\n#ifdef DEBUG\n\t\tasc_DumpLog(\"get_status\"); /* XXX */\n#endif\n\t\tif (data < 2) {\n\t\t\tasc->regs->asc_cmd = ASC_CMD_MSG_ACPT;\n\t\t\treadback(asc->regs->asc_cmd);\n\t\t\treturn (0);\n\t\t}\n\t\tdo {\n\t\t\tdata = regs->asc_fifo;\n\t\t} while ((regs->asc_flags & ASC_FLAGS_FIFO_CNT) > 2);\n\t}\n\n\t/* save the status byte */\n\tasc->st[asc->target].statusByte = data = regs->asc_fifo;\n#ifdef DEBUG\n\tif (asc_logp == asc_log)\n\t\tasc_log[NLOG - 1].msg = data;\n\telse\n\t\tasc_logp[-1].msg = data;\n#endif\n\n\t/* get the (presumed) command_complete message */\n\tif ((data = regs->asc_fifo) == SCSI_COMMAND_COMPLETE)\n\t\treturn (1);\n\n#ifdef DEBUG\n\tprintf(\"asc_get_status: status %x cmd %x\\n\",\n\t\tasc->st[asc->target].statusByte, data);\n\tasc_DumpLog(\"asc_get_status\");\n#endif\n\treturn (0);\n}",
    "includes": [
      "#include <dev/tc/ascvar.h>",
      "#include <pmax/pmax/kmin.h>",
      "#include <pmax/pmax/asic.h>",
      "#include <pmax/dev/ascreg.h>",
      "#include <pmax/dev/scsi.h>",
      "#include <pmax/dev/device.h>",
      "#include <machine/bus.h>",
      "#include <machine/autoconf.h>",
      "#include <machine/cpu.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/tc/ioasicvar.h>",
      "#include <dev/tc/tcvar.h>",
      "#include <sys/reboot.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/errno.h>",
      "#include <sys/conf.h>",
      "#include <sys/buf.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <asc.h>"
    ],
    "macros_used": [
      "#define NLOG 32"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "asc_DumpLog",
          "args": [
            "\"asc_get_status\""
          ],
          "line": 1360
        },
        "resolved": true,
        "details": {
          "function_name": "asc_DumpLog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/tc/asc.c",
          "lines": "2132-2156",
          "snippet": "void\nasc_DumpLog(str)\n\tchar *str;\n{\n\tregister struct asc_log *lp;\n\tregister u_int status;\n\n\tprintf(\"asc: %s: cmd %x bn %d cnt %d\\n\", str, asc_debug_cmd,\n\t\tasc_debug_bn, asc_debug_sz);\n\tlp = asc_logp;\n\tdo {\n\t\tstatus = lp->status;\n\t\tprintf(\"asc%d tgt %d status %x ss %x ir %x cond %d:%x msg %x resid %d\\n\",\n\t\t\tstatus >> 24,\n\t\t\tlp->target,\n\t\t\t(status >> 16) & 0xFF,\n\t\t\t(status >> 8) & 0xFF,\n\t\t\tstatus & 0XFF,\n\t\t\tlp->state,\n\t\t\tasc_scripts[lp->state].condition,\n\t\t\tlp->msg, lp->resid);\n\t\tif (++lp >= &asc_log[NLOG])\n\t\t\tlp = asc_log;\n\t} while (lp != asc_logp);\n}",
          "includes": [
            "#include <dev/tc/ascvar.h>",
            "#include <pmax/pmax/kmin.h>",
            "#include <pmax/pmax/asic.h>",
            "#include <pmax/dev/ascreg.h>",
            "#include <pmax/dev/scsi.h>",
            "#include <pmax/dev/device.h>",
            "#include <machine/bus.h>",
            "#include <machine/autoconf.h>",
            "#include <machine/cpu.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/tc/ioasicvar.h>",
            "#include <dev/tc/tcvar.h>",
            "#include <sys/reboot.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/errno.h>",
            "#include <sys/conf.h>",
            "#include <sys/buf.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <asc.h>"
          ],
          "macros_used": [
            "#define NLOG 32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/tc/ascvar.h>\n#include <pmax/pmax/kmin.h>\n#include <pmax/pmax/asic.h>\n#include <pmax/dev/ascreg.h>\n#include <pmax/dev/scsi.h>\n#include <pmax/dev/device.h>\n#include <machine/bus.h>\n#include <machine/autoconf.h>\n#include <machine/cpu.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/tc/ioasicvar.h>\n#include <dev/tc/tcvar.h>\n#include <sys/reboot.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/errno.h>\n#include <sys/conf.h>\n#include <sys/buf.h>\n#include <sys/dkstat.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <asc.h>\n\n#define NLOG 32\n\nvoid\nasc_DumpLog(str)\n\tchar *str;\n{\n\tregister struct asc_log *lp;\n\tregister u_int status;\n\n\tprintf(\"asc: %s: cmd %x bn %d cnt %d\\n\", str, asc_debug_cmd,\n\t\tasc_debug_bn, asc_debug_sz);\n\tlp = asc_logp;\n\tdo {\n\t\tstatus = lp->status;\n\t\tprintf(\"asc%d tgt %d status %x ss %x ir %x cond %d:%x msg %x resid %d\\n\",\n\t\t\tstatus >> 24,\n\t\t\tlp->target,\n\t\t\t(status >> 16) & 0xFF,\n\t\t\t(status >> 8) & 0xFF,\n\t\t\tstatus & 0XFF,\n\t\t\tlp->state,\n\t\t\tasc_scripts[lp->state].condition,\n\t\t\tlp->msg, lp->resid);\n\t\tif (++lp >= &asc_log[NLOG])\n\t\t\tlp = asc_log;\n\t} while (lp != asc_logp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"asc_get_status: status %x cmd %x\\n\"",
            "asc->st[asc->target].statusByte",
            "data"
          ],
          "line": 1358
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "readback",
          "args": [
            "asc->regs->asc_cmd"
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/tc/ascvar.h>\n#include <pmax/pmax/kmin.h>\n#include <pmax/pmax/asic.h>\n#include <pmax/dev/ascreg.h>\n#include <pmax/dev/scsi.h>\n#include <pmax/dev/device.h>\n#include <machine/bus.h>\n#include <machine/autoconf.h>\n#include <machine/cpu.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/tc/ioasicvar.h>\n#include <dev/tc/tcvar.h>\n#include <sys/reboot.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/errno.h>\n#include <sys/conf.h>\n#include <sys/buf.h>\n#include <sys/dkstat.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <asc.h>\n\n#define NLOG 32\n\nstatic int\nasc_get_status(asc, status, ss, ir)\n\tregister asc_softc_t asc;\n\tregister int status, ss, ir;\n{\n\tregister asc_regmap_t *regs = asc->regs;\n\tregister int data;\n\n\t/*\n\t * Get the last two bytes in the FIFO.\n\t */\n\tif ((data = regs->asc_flags & ASC_FLAGS_FIFO_CNT) != 2) {\n\t\tprintf(\"asc_get_status: cmdreg %x, fifo cnt %d\\n\",\n\t\t       regs->asc_cmd, data); /* XXX */\n#ifdef DEBUG\n\t\tasc_DumpLog(\"get_status\"); /* XXX */\n#endif\n\t\tif (data < 2) {\n\t\t\tasc->regs->asc_cmd = ASC_CMD_MSG_ACPT;\n\t\t\treadback(asc->regs->asc_cmd);\n\t\t\treturn (0);\n\t\t}\n\t\tdo {\n\t\t\tdata = regs->asc_fifo;\n\t\t} while ((regs->asc_flags & ASC_FLAGS_FIFO_CNT) > 2);\n\t}\n\n\t/* save the status byte */\n\tasc->st[asc->target].statusByte = data = regs->asc_fifo;\n#ifdef DEBUG\n\tif (asc_logp == asc_log)\n\t\tasc_log[NLOG - 1].msg = data;\n\telse\n\t\tasc_logp[-1].msg = data;\n#endif\n\n\t/* get the (presumed) command_complete message */\n\tif ((data = regs->asc_fifo) == SCSI_COMMAND_COMPLETE)\n\t\treturn (1);\n\n#ifdef DEBUG\n\tprintf(\"asc_get_status: status %x cmd %x\\n\",\n\t\tasc->st[asc->target].statusByte, data);\n\tasc_DumpLog(\"asc_get_status\");\n#endif\n\treturn (0);\n}"
  },
  {
    "function_name": "script_nop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/tc/asc.c",
    "lines": "1308-1314",
    "snippet": "static int\nscript_nop(asc, status, ss, ir)\n\tregister asc_softc_t asc;\n\tregister int status, ss, ir;\n{\n\treturn (1);\n}",
    "includes": [
      "#include <dev/tc/ascvar.h>",
      "#include <pmax/pmax/kmin.h>",
      "#include <pmax/pmax/asic.h>",
      "#include <pmax/dev/ascreg.h>",
      "#include <pmax/dev/scsi.h>",
      "#include <pmax/dev/device.h>",
      "#include <machine/bus.h>",
      "#include <machine/autoconf.h>",
      "#include <machine/cpu.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/tc/ioasicvar.h>",
      "#include <dev/tc/tcvar.h>",
      "#include <sys/reboot.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/errno.h>",
      "#include <sys/conf.h>",
      "#include <sys/buf.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <asc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <dev/tc/ascvar.h>\n#include <pmax/pmax/kmin.h>\n#include <pmax/pmax/asic.h>\n#include <pmax/dev/ascreg.h>\n#include <pmax/dev/scsi.h>\n#include <pmax/dev/device.h>\n#include <machine/bus.h>\n#include <machine/autoconf.h>\n#include <machine/cpu.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/tc/ioasicvar.h>\n#include <dev/tc/tcvar.h>\n#include <sys/reboot.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/errno.h>\n#include <sys/conf.h>\n#include <sys/buf.h>\n#include <sys/dkstat.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <asc.h>\n\nstatic int\nscript_nop(asc, status, ss, ir)\n\tregister asc_softc_t asc;\n\tregister int status, ss, ir;\n{\n\treturn (1);\n}"
  },
  {
    "function_name": "asc_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/tc/asc.c",
    "lines": "819-1300",
    "snippet": "int\nasc_intr(sc)\n\tvoid *sc;\n{\n\tregister asc_softc_t asc = (asc_softc_t) sc;\n\tregister asc_regmap_t *regs = asc->regs;\n\tregister State *state;\n\tregister script_t *scpt;\n\tregister int ss, ir, status;\n\tregister unsigned char cmd_was;\n\tstatic int ill_cmd_count = 0;\t\t\t/* XXX */\n\n\t/* collect ephemeral information */\n\tstatus = regs->asc_status;\nagain:\n\tss = regs->asc_ss;\n\tcmd_was = regs->asc_cmd;\n\n\t/* drop spurious interrupts */\n\tif ((status & ASC_CSR_INT) == 0)\n\t\treturn (-1);\t\t/* XXX */\n\n\tir = regs->asc_intr;\t/* this resets the previous two: i.e.,*/\n\t\t\t\t/* this re-latches CSR (and SSTEP) */\n\tscpt = asc->script;\n\n\n#ifdef DEBUG\n\tasc_logp->status = PACK(asc->sc_dev.dv_unit, status, ss, ir);\n\tasc_logp->target = (asc->state == ASC_STATE_BUSY) ? asc->target : -1;\n\tasc_logp->state = scpt - asc_scripts;\n\tasc_logp->msg = cmd_was;\n\tasc_logp->resid = 0;\n\tif (++asc_logp >= &asc_log[NLOG])\n\t\tasc_logp = asc_log;\n\tif (asc_debug > 2)\n\t\tprintf(\"asc_intr: status %x ss %x ir %x cond %d:%x\\n\",\n\t\t\tstatus, ss, ir, scpt - asc_scripts, scpt->condition);\n#endif\n\n\t/* This must be done withing 250msec of disconnect */\n\tif (ir & ASC_INT_DISC) {\n\t\tregs->asc_cmd = ASC_CMD_ENABLE_SEL;\n\t\treadback(regs->asc_cmd);\n\t}\n\n\t/* check the expected state */\n\tif (SCRIPT_MATCH(ir, status) == scpt->condition) {\n\t\t/*\n\t\t * Perform the appropriate operation, then proceed.\n\t\t */\n\t\tif ((*scpt->action)(asc, status, ss, ir)) {\n\t\t\tregs->asc_cmd = scpt->command;\n\t\t\treadback(regs->asc_cmd);\n\t\t\tasc->script = scpt->next;\n\t\t}\n\t\tgoto done;\n\t}\n\n\t/*\n\t * Check for parity error.\n\t * Hardware will automatically set ATN\n\t * to request the device for a MSG_OUT phase.\n\t */\n\tif (status & ASC_CSR_PE) {\n\t\tprintf(\"%s: SCSI device %d: incomming parity error seen\\n\",\n\t\t\tasc->sc_dev.dv_xname, asc->target);\n\t\tasc->st[asc->target].flags |= PARITY_ERR;\n\t}\n\n\t/*\n\t * Check for gross error.\n\t * Probably a bug in a device driver.\n\t */\n\tif (status & ASC_CSR_GE) {\n\t\tprintf(\"%s: SCSI device %d: gross error\\n\",\n\t\t\tasc->sc_dev.dv_xname, asc->target);\n\t\tgoto abort;\n\t}\n\n\t/* check for message in or out */\n\tif ((ir & ~ASC_INT_FC) == ASC_INT_BS) {\n\t\tregister int len, fifo;\n\n\t\tstate = &asc->st[asc->target];\n\t\tswitch (ASC_PHASE(status)) {\n\t\tcase SCSI_PHASE_DATAI:\n\t\t\tif ((asc->script - asc_scripts) == SCRIPT_DATA_IN + 1 ||\n\t\t\t    (asc->script - asc_scripts) == SCRIPT_CONTINUE_IN) {\n\t\t\t    \t/*\n\t\t\t    \t * From the Mach driver:\n\t\t\t    \t * After a reconnect and restart dma in, we\n\t\t\t    \t * seem to have gotten an interrupt even though\n\t\t\t    \t * the DMA is running.  The Mach driver just\n\t\t\t    \t * ignores this interrupt.\n\t\t\t    \t */\n\t\t\t\tASC_TC_GET(regs, len);\n\t\t\t\tfifo = regs->asc_flags & ASC_FLAGS_FIFO_CNT;\n\t\t\t    \tprintf(\"asc_intr: ignoring strange interrupt\");\n\t\t\t    \tprintf(\" tc %d fifo residue %d\\n\", len, fifo);\n\t\t\t    \tgoto done;\n\t\t\t}\n\t\t\t/* FALLTHROUGH */\n\t\tcase SCSI_PHASE_DATAO:\n\t\t\tASC_TC_GET(regs, len);\n\t\t\tfifo = regs->asc_flags & ASC_FLAGS_FIFO_CNT;\n\t\t\tprintf(\"asc_intr: data overrun: buflen %d dmalen %d tc %d fifo %d\\n\",\n\t\t\t\tstate->buflen, state->dmalen, len, fifo);\n\t\t\tgoto abort;\n\n\t\tcase SCSI_PHASE_MSG_IN:\n\t\t\tbreak;\n\n\t\tcase SCSI_PHASE_MSG_OUT:\n\t\t\t/*\n\t\t\t * Check for parity error.\n\t\t\t * Hardware will automatically set ATN\n\t\t\t * to request the device for a MSG_OUT phase.\n\t\t\t */\n\t\t\tif (state->flags & PARITY_ERR) {\n\t\t\t\tstate->flags &= ~PARITY_ERR;\n\t\t\t\tstate->msg_out = SCSI_MESSAGE_PARITY_ERROR;\n\t\t\t\t/* reset message in counter */\n\t\t\t\tstate->msglen = 0;\n\t\t\t} else\n\t\t\t\tstate->msg_out = SCSI_NO_OP;\n\t\t\tregs->asc_fifo = state->msg_out;\n\t\t\tregs->asc_cmd = ASC_CMD_XFER_INFO;\n\t\t\treadback(regs->asc_cmd);\n\t\t\tgoto done;\n\n\t\tcase SCSI_PHASE_STATUS:\n\t\t\t/* probably an error in the SCSI command */\n\t\t\tasc->script = &asc_scripts[SCRIPT_GET_STATUS];\n\t\t\tregs->asc_cmd = ASC_CMD_I_COMPLETE;\n\t\t\treadback(regs->asc_cmd);\n\t\t\tgoto done;\n\n\t\tcase SCSI_PHASE_COMMAND:\n\t\t\t/*\n\t\t\t * This seems to occur after the command is sent\n\t\t\t * following sync negotiation.  The device still\n\t\t\t * wants more command data.  The fifo appears to\n\t\t\t * to still have the unsent data - but the 53C94\n\t\t\t * signaled TC.  If the fifo still contains data,\n\t\t\t * transfer it, otherwise do a transfer pad.  The\n\t\t\t * target should then continue through the rest of\n\t\t\t * the phases and complete normally.\n\t\t\t */\n\t\t\tprintf(\"asc_intr: tgt %d command phase TC zero\",\n\t\t\t    asc->target);\n\t\t\tif ((regs->asc_flags & ASC_FLAGS_FIFO_CNT) != 0) {\n\t\t\t\tprintf(\" with non-empty fifo %d\\n\",\n\t\t\t\t    regs->asc_flags & ASC_FLAGS_FIFO_CNT);\n\t\t\t\tregs->asc_cmd = ASC_CMD_XFER_INFO;\n\t\t\t} else {\n\t\t\t\tprintf(\"; padding command\\n\");\n\t\t\t\tASC_TC_PUT(regs, 0xff);\n\t\t\t\tregs->asc_cmd = ASC_CMD_XFER_PAD | ASC_CMD_DMA;\n\t\t\t}\n\t\t\tgoto done;\n\n\t\tdefault:\n\t\t\tprintf(\"asc_intr: target %d, unknown phase 0x%x\\n\", \n\t\t\t  \tasc->target, status);\n\t\t\tgoto abort;\n\t\t}\n\n\t\tif (state->script) {\n\t\t\tprintf(\"asc_intr: target %d, incomplete script %p\\n\", \n\t\t\t  \tasc->target, state->script);\n\t\t\tgoto abort;\n\t\t}\n\n\t\t/* check for DMA in progress */\n\t\tASC_TC_GET(regs, len);\n\t\tfifo = regs->asc_flags & ASC_FLAGS_FIFO_CNT;\n\t\t/* flush any data in the FIFO */\n\t\tif (fifo) {\n\t\t\tif (state->flags & DMA_OUT) {\n#ifdef ASC_DIAGNOSTIC\n\t \t\t\tprintf(\"asc: DMA_OUT, fifo resid %d, len %d, flags 0x%x\\n\",\n\t\t\t\t    fifo, len, state->flags);\n#endif /* ASC_DIAGNOSTIC */\n\t\t\t\tlen += fifo;\n\t\t\t} else if (state->flags & DMA_IN) {\n#ifdef ASC_DIAGNOSTIC\n\t\t\t\tprintf(\"asc_intr: IN: dmalen %d len %d fifo %d\\n\",\n\t\t\t\t\tstate->dmalen, len, fifo); /* XXX */\n#endif /* ASC_DIAGNOSTIC */\n\t\t\t} else\n\t\t\t\tprintf(\"asc_intr: dmalen %d len %d fifo %d\\n\",\n\t\t\t\t\tstate->dmalen, len, fifo); /* XXX */\n\t\t\tregs->asc_cmd = ASC_CMD_FLUSH;\n\t\t\ttc_mb();\n\t\t\treadback(regs->asc_cmd);\n\t\t\tDELAY(2);\n\t\t}\n\t\tif (len && (state->flags & DMA_IN_PROGRESS)) {\n\t\t\t/* save number of bytes still to be sent or received */\n\t\t\tstate->dmaresid = len;\n\t\t\tstate->flags &= ~DMA_IN_PROGRESS;\n\t\t\tASC_TC_PUT(regs, 0);\n#ifdef DEBUG\n\t\t\tif (asc_logp == asc_log)\n\t\t\t\tasc_log[NLOG - 1].resid = len;\n\t\t\telse\n\t\t\t\tasc_logp[-1].resid = len;\n#endif\n\t\t\t/* setup state to resume to */\n\t\t\tif (state->flags & DMA_IN) {\n\t\t\t\t/*\n\t\t\t\t * Since the ASC_CNFG3_SRB bit of the\n\t\t\t\t * cnfg3 register bit is not set,\n\t\t\t\t * we just transferred an extra byte.\n\t\t\t\t * Since we can't resume on an odd byte\n\t\t\t\t * boundary, we copy the valid data out\n\t\t\t\t * and resume DMA at the start address.\n\t\t\t\t */\n\t\t\t\tif (len & 1) {\n\t\t\t\t\tprintf(\"asc_intr: msg in len %d (fifo %d)\\n\",\n\t\t\t\t\t\tlen, fifo); /* XXX */\n\t\t\t\t\tlen = state->dmalen - len;\n\t\t\t\t\tgoto do_in;\n\t\t\t\t}\n\t\t\t\tstate->script =\n\t\t\t\t\t&asc_scripts[SCRIPT_RESUME_DMA_IN];\n\t\t\t\tstate->flags |= DMA_RESUME;\n\t\t\t} else if (state->flags & DMA_OUT) {\n\t\t\t\tstate->script =\n\t\t\t\t\t&asc_scripts[SCRIPT_RESUME_DMA_OUT];\n\t\t\t\tstate->flags |= DMA_RESUME;\n\t\t\t} else\n\t\t\t\tstate->script = asc->script;\n\t\t} else if (state->flags & DMA_IN) {\n#ifdef ASC_DIAGNOSTIC\n\t\t\tif (len) {\n\t\t\t\tprintf(\"asc_intr: 1: len %d (fifo %d)\\n\",\n\t\t\t\t\tlen, fifo); /* XXX */\n\t\t\t}\n#endif\n\t\t\t/* setup state to resume to */\n\t\t\tif (state->flags & DMA_IN_PROGRESS) {\n\t\t\t\tlen = state->dmalen;\n\t\t\t\tstate->flags &= ~DMA_IN_PROGRESS;\n\t\t\tdo_in:\n\t\t\t\tstate->dmalen = len;\t/* dma_end needs actual length */\n\t\t\t\t(*asc->dma_end)(asc, state, ASCDMA_READ);\n\t\t\t\tstate->buf += len;\n\t\t\t\tstate->buflen -= len;\n\t\t\t}\n\t\t\tif (state->buflen)\n\t\t\t\tstate->script = (state->flags & DMA_RESUME) ?\n\t\t\t\t    &asc_scripts[SCRIPT_RESUME_DMA_IN] :\n\t\t\t\t    &asc_scripts[SCRIPT_RESUME_IN];\n\t\t\telse\n\t\t\t\tstate->script =\n\t\t\t\t    &asc_scripts[SCRIPT_RESUME_NO_DATA];\n\t\t} else if (state->flags & DMA_OUT) {\n\t\t\tif (len) {\n#ifdef DEBUG\n\t\t\t\tprintf(\"asc_intr: 2: len %d (fifo %d)\\n\", len,\n\t\t\t\t\tfifo); /* XXX */\n#endif\n\t\t\t}\n\t\t\t/*\n\t\t\t * If this is the last chunk, the next expected\n\t\t\t * state is to get status.\n\t\t\t */\n\t\t\tif (state->flags & DMA_IN_PROGRESS) {\n\t\t\t\tstate->flags &= ~DMA_IN_PROGRESS;\n\t\t\t\t(*asc->dma_end)(asc, state, ASCDMA_WRITE);\n\t\t\t\tlen = state->dmalen;\n\t\t\t\tstate->buf += len;\n\t\t\t\tstate->buflen -= len;\n\t\t\t}\n\t\t\tif (state->buflen)\n\t\t\t\tstate->script = (state->flags & DMA_RESUME) ?\n\t\t\t\t    &asc_scripts[SCRIPT_RESUME_DMA_OUT] :\n\t\t\t\t    &asc_scripts[SCRIPT_RESUME_OUT];\n\t\t\telse\n\t\t\t\tstate->script =\n\t\t\t\t    &asc_scripts[SCRIPT_RESUME_NO_DATA];\n\t\t} else if (asc->script == &asc_scripts[SCRIPT_SIMPLE])\n\t\t\tstate->script = &asc_scripts[SCRIPT_RESUME_NO_DATA];\n\t\telse\n\t\t\tstate->script = asc->script;\n\n\t\t/* setup to receive a message */\n\t\tasc->script = &asc_scripts[SCRIPT_MSG_IN];\n\t\tstate->msglen = 0;\n\t\tregs->asc_cmd = ASC_CMD_XFER_INFO;\n\t\treadback(regs->asc_cmd);\n\t\tgoto done;\n\t}\n\n\t/* check for SCSI bus reset */\n\tif (ir & ASC_INT_RESET) {\n\t\tregister int i;\n\n\t\tprintf(\"%s: SCSI bus reset!!\\n\", asc->sc_dev.dv_xname);\n\t\t/* need to flush any pending commands */\n\t\tfor (i = 0; i < ASC_NCMD; i++) {\n\t\t\tif (!asc->cmd[i])\n\t\t\t\tcontinue;\n\t\t\tasc->st[i].error = EIO;\n\t\t\tasc_end(asc, 0, 0, 0);\n\t\t}\n\t\t/* rearbitrate synchronous offset */\n\t\tfor (i = 0; i < ASC_NCMD; i++) {\n\t\t\tasc->st[i].sync_offset = 0;\n\t\t\tasc->st[i].flags = 0;\n\t\t}\n\t\tasc->target = -1;\n\t\treturn 0 ; /* XXX ??? */\n\t}\n\n\t/* check for disconnect */\n\tif (ir & ASC_INT_DISC) {\n\t\tstate = &asc->st[asc->target];\n\t\tswitch (asc->script - asc_scripts) {\n\t\tcase SCRIPT_DONE:\n\t\tcase SCRIPT_DISCONNECT:\n\t\t\t/*\n\t\t\t * Disconnects can happen normally when the\n\t\t\t * command is complete with the phase being\n\t\t\t * either SCSI_PHASE_DATAO or SCSI_PHASE_MSG_IN.\n\t\t\t * The SCRIPT_MATCH() only checks for one phase\n\t\t\t * so we can wind up here.\n\t\t\t * Perform the appropriate operation, then proceed.\n\t\t\t */\n\t\t\tif ((*scpt->action)(asc, status, ss, ir)) {\n\t\t\t\tregs->asc_cmd = scpt->command;\n\t\t\t\treadback(regs->asc_cmd);\n\t\t\t\tasc->script = scpt->next;\n\t\t\t}\n\t\t\tgoto done;\n\n\t\tcase SCRIPT_TRY_SYNC:\n\t\tcase SCRIPT_SIMPLE:\n\t\tcase SCRIPT_DATA_IN:\n\t\tcase SCRIPT_DATA_OUT: /* one of the starting scripts */\n\t\t\tif (ASC_SS(ss) == 0) {\n\t\t\t\t/* device did not respond */\n\t\t\t\tif (regs->asc_flags & ASC_FLAGS_FIFO_CNT) {\n\t\t\t\t\tregs->asc_cmd = ASC_CMD_FLUSH;\n\t\t\t\t\treadback(regs->asc_cmd);\n\t\t\t\t}\n\t\t\t\tstate->error = ENXIO;\n\t\t\t\tasc_end(asc, status, ss, ir);\n\t\t\t\treturn 0 ; /* XXX ??? */\n\t\t\t}\n\t\t\t/* FALLTHROUGH */\n\n\t\tdefault:\n\t\t\tprintf(\"%s: SCSI device %d: unexpected disconnect\\n\",\n\t\t\t\tasc->sc_dev.dv_xname, asc->target);\n#ifdef DEBUG\n\t\t\tasc_DumpLog(\"asc_disc\");\n#endif\n\t\t\t/*\n\t\t\t * On rare occasions my RZ24 does a disconnect during\n\t\t\t * data in phase and the following seems to keep it\n\t\t\t * happy.\n\t\t\t * XXX Should a scsi disk ever do this??\n\t\t\t */\n\t\t\tasc->script = &asc_scripts[SCRIPT_RESEL];\n\t\t\tasc->state = ASC_STATE_RESEL;\n\t\t\tstate->flags |= DISCONN;\n\t\t\tregs->asc_cmd = ASC_CMD_ENABLE_SEL;\n\t\t\treadback(regs->asc_cmd);\n\t\t\treturn 0 ; /* XXX ??? */\n\t\t}\n\t}\n\n\t/* mhitch - debug - check select/reselect collision */\n\tif ((ir & ASC_INT_ILL) && (regs->asc_cmd & ASC_CMD_SEL_ATN)) {\n\t\tprintf(\"asc_intr: Illegal command status %x ir %x\\n\",\n\t\t    status, ir);\n\t\t/* Should process reselect? */\n\t}\n\n\t/* check for illegal command */\n\tif (ir & ASC_INT_ILL) {\n#ifdef ASC_DIAGNOSTIC\n\t\tprintf(\"asc_intr: Illegal command status %x ir %x cmd %x ? %x\\n\",\n\t\t    status, ir, regs->asc_cmd, asc_scripts[SCRIPT_MSG_IN].command);\n#endif\n\t\t/*\n\t\t * On a 5000/200, I see this frequently when using an RD52\n\t\t * CDROM.  The 53c94 doesn't seem to get the Message Accept\n\t\t * command, and generates an \"Illegal Command\" interrupt.\n\t\t * Re-issuing the Message Accept at this point seems to keep\n\t\t * things going.  Don't allow this too many times in a row,\n\t\t * just to make sure we don't get hung up.  mhitch\n\t\t */\n\t\tif (ill_cmd_count++ != 3) {\t\t\t/* XXX */\n\t\t\tregs->asc_cmd = ASC_CMD_MSG_ACPT;\t/* XXX */\n\t\t\treadback(regs->asc_cmd);\t\t/* XXX */\n\t\t\tgoto done;\t\t\t\t/* XXX */\n\t\t}\t\t\t\t\t\t/* XXX */\n\t\tprintf(\"asc_intr: Illegal command tgt %d\\n\", asc->target);\n\t\tgoto abort;\t/* XXX */\n\t}\n\till_cmd_count = 0;\t\t\t\t\t/* XXX */\n\n\t/* check for reselect */\n\tif (ir & ASC_INT_RESEL) {\n\t\tunsigned fifo, id, msg;\n\n\t\tfifo = regs->asc_flags & ASC_FLAGS_FIFO_CNT;\n\t\tif (fifo < 2) {\n\t\t\tprintf(\"asc_intr: target %d, reselect, fifo %d too small for msg\\n\", \n\t\t\t  \tasc->target, fifo);\n\n\t\t\tgoto abort;\n\t\t}\n\t\t/* read unencoded SCSI ID and convert to binary */\n\t\tmsg = regs->asc_fifo & asc->myidmask;\n\t\tfor (id = 0; (msg & 1) == 0; id++)\n\t\t\tmsg >>= 1;\n\t\t/* read identify message */\n\t\tmsg = regs->asc_fifo;\n#ifdef DEBUG\n\t\tif (asc_logp == asc_log)\n\t\t\tasc_log[NLOG - 1].msg = msg;\n\t\telse\n\t\t\tasc_logp[-1].msg = msg;\n#endif\n\t\t/*\n\t\t * TC may have been initialized during a selection attempt.\n\t\t * Clear it to prevent possible confusion later.\n\t\t */\n\t\tASC_TC_PUT(regs,0);\t/* ensure TC clear */\n\t\tasc->state = ASC_STATE_BUSY;\n\t\tasc->target = id;\n\t\tstate = &asc->st[id];\n\t\tasc->script = state->script;\n\t\tstate->script = (script_t *)0;\n\t\tif (!(state->flags & DISCONN)) {\n\t\t\tprintf(\"asc_intr: reselect tgt %d, flags 0x%x not disconnected\\n\",\n\t\t\t       asc->target, state->flags);\n\t\t\tgoto abort;\n\t\t}\n\t\tstate->flags &= ~DISCONN;\n\t\tregs->asc_syn_p = state->sync_period;\n\t\tregs->asc_syn_o = state->sync_offset;\n\t\tregs->asc_cmd = ASC_CMD_MSG_ACPT;\n\t\treadback(regs->asc_cmd);\n\t\tgoto done;\n\t}\n\n\t/* check if we are being selected as a target */\n\tif (ir & (ASC_INT_SEL | ASC_INT_SEL_ATN)) {\n\t\t\tprintf(\"asc_intr: host adaptor selected as target\\n\");\n\t\tgoto abort;\n\t}\n\t/*\n\t * 'ir' must be just ASC_INT_FC.\n\t * This is normal if canceling an ASC_ENABLE_SEL.\n\t */\n\ndone:\n\ttc_mb();\n\t/* watch out for HW race conditions and setup & hold time violations */\n\tir = regs->asc_status;\n\twhile (ir != (status = regs->asc_status))\n\t\tir = status;\n\tif (status & ASC_CSR_INT)\n\t\tgoto again;\n\treturn 0 ; /* XXX ??? */\n\nabort:\n#ifdef DEBUG\n\tasc_DumpLog(\"asc_intr\");\n#endif\n#if 0\n\tpanic(\"asc_intr\");\n#else\n\tboot(RB_NOSYNC); /* XXX */\n#endif\n}",
    "includes": [
      "#include <dev/tc/ascvar.h>",
      "#include <pmax/pmax/kmin.h>",
      "#include <pmax/pmax/asic.h>",
      "#include <pmax/dev/ascreg.h>",
      "#include <pmax/dev/scsi.h>",
      "#include <pmax/dev/device.h>",
      "#include <machine/bus.h>",
      "#include <machine/autoconf.h>",
      "#include <machine/cpu.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/tc/ioasicvar.h>",
      "#include <dev/tc/tcvar.h>",
      "#include <sys/reboot.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/errno.h>",
      "#include <sys/conf.h>",
      "#include <sys/buf.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <asc.h>"
    ],
    "macros_used": [
      "#define\tSCRIPT_RESUME_NO_DATA\t21",
      "#define\tSCRIPT_RESUME_DMA_OUT\t20",
      "#define\tSCRIPT_RESUME_OUT\t19",
      "#define\tSCRIPT_RESUME_DMA_IN\t18",
      "#define\tSCRIPT_RESUME_IN\t17",
      "#define\tSCRIPT_RESEL\t\t16",
      "#define\tSCRIPT_DISCONNECT\t15",
      "#define\tSCRIPT_TRY_SYNC\t\t12",
      "#define\tSCRIPT_MSG_IN\t\t9",
      "#define\tSCRIPT_DONE\t\t8",
      "#define\tSCRIPT_GET_STATUS\t7",
      "#define\tSCRIPT_SIMPLE\t\t6",
      "#define\tSCRIPT_DATA_OUT\t\t3",
      "#define\tSCRIPT_CONTINUE_IN\t2",
      "#define\tSCRIPT_DATA_IN\t\t0",
      "#define NLOG 32"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "boot",
          "args": [
            "RB_NOSYNC"
          ],
          "line": 1298
        },
        "resolved": true,
        "details": {
          "function_name": "rf_UnbootRaidframe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_driver.c",
          "lines": "194-213",
          "snippet": "int \nrf_UnbootRaidframe()\n{\n\tint     rc;\n\n\tRF_LOCK_MUTEX(configureMutex);\n\tif (configureCount) {\n\t\tRF_UNLOCK_MUTEX(configureMutex);\n\t\treturn (EBUSY);\n\t}\n\traidframe_booted = 0;\n\tRF_UNLOCK_MUTEX(configureMutex);\n\trc = rf_mutex_destroy(&configureMutex);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to destroy mutex file %s line %d rc=%d\\n\", __FILE__,\n\t\t    __LINE__, rc);\n\t\tRF_PANIC();\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include <sys/buf.h>",
            "#include \"rf_kintf.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_nwayxor.h\"",
            "#include \"rf_mcpair.h\"",
            "#include \"rf_memchunk.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_callback.h\"",
            "#include \"rf_revent.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_decluster.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_states.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_aselect.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include <sys/errno.h>",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_archs.h\"",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int raidframe_booted = 0;",
            "static int configureCount = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_options.h\"\n#include \"rf_driver.h\"\n#include \"rf_copyback.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_nwayxor.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_memchunk.h\"\n#include \"rf_engine.h\"\n#include \"rf_callback.h\"\n#include \"rf_revent.h\"\n#include \"rf_map.h\"\n#include \"rf_decluster.h\"\n#include \"rf_freelist.h\"\n#include \"rf_states.h\"\n#include \"rf_desc.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_utils.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_aselect.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n#include \"rf_archs.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic int raidframe_booted = 0;\nstatic int configureCount = 0;\n\nint \nrf_UnbootRaidframe()\n{\n\tint     rc;\n\n\tRF_LOCK_MUTEX(configureMutex);\n\tif (configureCount) {\n\t\tRF_UNLOCK_MUTEX(configureMutex);\n\t\treturn (EBUSY);\n\t}\n\traidframe_booted = 0;\n\tRF_UNLOCK_MUTEX(configureMutex);\n\trc = rf_mutex_destroy(&configureMutex);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to destroy mutex file %s line %d rc=%d\\n\", __FILE__,\n\t\t    __LINE__, rc);\n\t\tRF_PANIC();\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"asc_intr\""
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asc_DumpLog",
          "args": [
            "\"asc_intr\""
          ],
          "line": 1293
        },
        "resolved": true,
        "details": {
          "function_name": "asc_DumpLog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/tc/asc.c",
          "lines": "2132-2156",
          "snippet": "void\nasc_DumpLog(str)\n\tchar *str;\n{\n\tregister struct asc_log *lp;\n\tregister u_int status;\n\n\tprintf(\"asc: %s: cmd %x bn %d cnt %d\\n\", str, asc_debug_cmd,\n\t\tasc_debug_bn, asc_debug_sz);\n\tlp = asc_logp;\n\tdo {\n\t\tstatus = lp->status;\n\t\tprintf(\"asc%d tgt %d status %x ss %x ir %x cond %d:%x msg %x resid %d\\n\",\n\t\t\tstatus >> 24,\n\t\t\tlp->target,\n\t\t\t(status >> 16) & 0xFF,\n\t\t\t(status >> 8) & 0xFF,\n\t\t\tstatus & 0XFF,\n\t\t\tlp->state,\n\t\t\tasc_scripts[lp->state].condition,\n\t\t\tlp->msg, lp->resid);\n\t\tif (++lp >= &asc_log[NLOG])\n\t\t\tlp = asc_log;\n\t} while (lp != asc_logp);\n}",
          "includes": [
            "#include <dev/tc/ascvar.h>",
            "#include <pmax/pmax/kmin.h>",
            "#include <pmax/pmax/asic.h>",
            "#include <pmax/dev/ascreg.h>",
            "#include <pmax/dev/scsi.h>",
            "#include <pmax/dev/device.h>",
            "#include <machine/bus.h>",
            "#include <machine/autoconf.h>",
            "#include <machine/cpu.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/tc/ioasicvar.h>",
            "#include <dev/tc/tcvar.h>",
            "#include <sys/reboot.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/errno.h>",
            "#include <sys/conf.h>",
            "#include <sys/buf.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <asc.h>"
          ],
          "macros_used": [
            "#define NLOG 32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/tc/ascvar.h>\n#include <pmax/pmax/kmin.h>\n#include <pmax/pmax/asic.h>\n#include <pmax/dev/ascreg.h>\n#include <pmax/dev/scsi.h>\n#include <pmax/dev/device.h>\n#include <machine/bus.h>\n#include <machine/autoconf.h>\n#include <machine/cpu.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/tc/ioasicvar.h>\n#include <dev/tc/tcvar.h>\n#include <sys/reboot.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/errno.h>\n#include <sys/conf.h>\n#include <sys/buf.h>\n#include <sys/dkstat.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <asc.h>\n\n#define NLOG 32\n\nvoid\nasc_DumpLog(str)\n\tchar *str;\n{\n\tregister struct asc_log *lp;\n\tregister u_int status;\n\n\tprintf(\"asc: %s: cmd %x bn %d cnt %d\\n\", str, asc_debug_cmd,\n\t\tasc_debug_bn, asc_debug_sz);\n\tlp = asc_logp;\n\tdo {\n\t\tstatus = lp->status;\n\t\tprintf(\"asc%d tgt %d status %x ss %x ir %x cond %d:%x msg %x resid %d\\n\",\n\t\t\tstatus >> 24,\n\t\t\tlp->target,\n\t\t\t(status >> 16) & 0xFF,\n\t\t\t(status >> 8) & 0xFF,\n\t\t\tstatus & 0XFF,\n\t\t\tlp->state,\n\t\t\tasc_scripts[lp->state].condition,\n\t\t\tlp->msg, lp->resid);\n\t\tif (++lp >= &asc_log[NLOG])\n\t\t\tlp = asc_log;\n\t} while (lp != asc_logp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tc_mb",
          "args": [],
          "line": 1282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"asc_intr: host adaptor selected as target\\n\""
          ],
          "line": 1273
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "readback",
          "args": [
            "regs->asc_cmd"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASC_TC_PUT",
          "args": [
            "regs",
            "0"
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readback",
          "args": [
            "regs->asc_cmd"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readback",
          "args": [
            "regs->asc_cmd"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asc_end",
          "args": [
            "asc",
            "status",
            "ss",
            "ir"
          ],
          "line": 1168
        },
        "resolved": true,
        "details": {
          "function_name": "asc_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/tc/asc.c",
          "lines": "1366-1448",
          "snippet": "static int\nasc_end(asc, status, ss, ir)\n\tregister asc_softc_t asc;\n\tregister int status, ss, ir;\n{\n\tregister ScsiCmd *scsicmd;\n\tregister State *state;\n\tregister int i, target;\n\n\tasc->state = ASC_STATE_IDLE;\n\ttarget = asc->target;\n\tasc->target = -1;\n\tscsicmd = asc->cmd[target];\n\tasc->cmd[target] = (ScsiCmd *)0;\n\tstate = &asc->st[target];\n\tuntimeout(asc_timeout, scsicmd);\n\n#ifdef DEBUG\n\tif (asc_debug > 1) {\n\t\tprintf(\"asc_end: %s target %d cmd %x err %d resid %d\\n\",\n\t\t\tscsicmd->sd->sd_driver->d_name, target,\n\t\t\tscsicmd->cmd[0], state->error, state->buflen);\n\t}\n#endif\n#ifdef DIAGNOSTIC\n\tif (target < 0 || !scsicmd)\n\t\tpanic(\"asc_end\");\n#endif\n\n\t/* look for disconnected devices */\n\tfor (i = 0; i < ASC_NCMD; i++) {\n\t\tif (!asc->cmd[i] || !(asc->st[i].flags & DISCONN))\n\t\t\tcontinue;\n\t\tasc->regs->asc_cmd = ASC_CMD_ENABLE_SEL;\n\t\treadback(asc->regs->asc_cmd);\n\t\tasc->state = ASC_STATE_RESEL;\n\t\tasc->script = &asc_scripts[SCRIPT_RESEL];\n\t\tbreak;\n\t}\n\n#ifdef USE_NEW_SCSI\n\tif(scsicmd->error == XS_NOERROR && !(state->flags & CHECK_SENSE)) {\n\t\tif((state->statusByte & ST_MASK) == SCSI_CHECK) {\n\t\t\tstruct scsi_sense *ss = (void *)&state->cmd;\n\t\t\t/* Save return values */\n\t\t\tscsicmd->resid = state->buflen;\n\t\t\tscsicmd->status = state->statusByte;\n\t\t\t/* Set up sense request command */\n\t\t\tbzero(ss, sizeof(*ss));\n\t\t\tss->opcode = REQUEST_SENSE;\n\t\t\tss->byte2 = sc_link->lun << 5;\n\t\t\tss->length = sizeof(struct scsi_sense_data);\n\t\t\tstate->cmdlen = sizeof(*ss);\n\t\t\tstate->buf = (vm_offset_t)&scsicmd->sense;\n\t\t\tstate->buflen = sizeof(struct scsi_sense_data);\n\t\t\tstate->flags |= CHECK_SENSE;\n\t\t\tMachFlushDCache(state->buf, state->buflen);\n\t\t\tasc->cmd[target] = scsicmd;\n\t\t\tasc_startcmd(asc, target);\n\t\t\treturn(0);\n\t\t}\n\t}\n#endif /*USE_NEW_SCSI*/\n\n\t/*\n\t * Look for another device that is ready.\n\t * May want to keep last one started and increment for fairness\n\t * rather than always starting at zero.\n\t */\n\tfor (i = 0; i < ASC_NCMD; i++) {\n\t\t/* don't restart a disconnected command */\n\t\tif (!asc->cmd[i] || (asc->st[i].flags & DISCONN))\n\t\t\tcontinue;\n\t\tasc_startcmd(asc, i);\n\t\tbreak;\n\t}\n\n\t/* signal device driver that the command is done */\n\t(*scsicmd->sd->sd_driver->d_done)(scsicmd->unit, state->error,\n\t\tstate->buflen, state->statusByte);\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/tc/ascvar.h>",
            "#include <pmax/pmax/kmin.h>",
            "#include <pmax/pmax/asic.h>",
            "#include <pmax/dev/ascreg.h>",
            "#include <pmax/dev/scsi.h>",
            "#include <pmax/dev/device.h>",
            "#include <machine/bus.h>",
            "#include <machine/autoconf.h>",
            "#include <machine/cpu.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/tc/ioasicvar.h>",
            "#include <dev/tc/tcvar.h>",
            "#include <sys/reboot.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/errno.h>",
            "#include <sys/conf.h>",
            "#include <sys/buf.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <asc.h>"
          ],
          "macros_used": [
            "#define\tSCRIPT_RESEL\t\t16"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/tc/ascvar.h>\n#include <pmax/pmax/kmin.h>\n#include <pmax/pmax/asic.h>\n#include <pmax/dev/ascreg.h>\n#include <pmax/dev/scsi.h>\n#include <pmax/dev/device.h>\n#include <machine/bus.h>\n#include <machine/autoconf.h>\n#include <machine/cpu.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/tc/ioasicvar.h>\n#include <dev/tc/tcvar.h>\n#include <sys/reboot.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/errno.h>\n#include <sys/conf.h>\n#include <sys/buf.h>\n#include <sys/dkstat.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <asc.h>\n\n#define\tSCRIPT_RESEL\t\t16\n\nstatic int\nasc_end(asc, status, ss, ir)\n\tregister asc_softc_t asc;\n\tregister int status, ss, ir;\n{\n\tregister ScsiCmd *scsicmd;\n\tregister State *state;\n\tregister int i, target;\n\n\tasc->state = ASC_STATE_IDLE;\n\ttarget = asc->target;\n\tasc->target = -1;\n\tscsicmd = asc->cmd[target];\n\tasc->cmd[target] = (ScsiCmd *)0;\n\tstate = &asc->st[target];\n\tuntimeout(asc_timeout, scsicmd);\n\n#ifdef DEBUG\n\tif (asc_debug > 1) {\n\t\tprintf(\"asc_end: %s target %d cmd %x err %d resid %d\\n\",\n\t\t\tscsicmd->sd->sd_driver->d_name, target,\n\t\t\tscsicmd->cmd[0], state->error, state->buflen);\n\t}\n#endif\n#ifdef DIAGNOSTIC\n\tif (target < 0 || !scsicmd)\n\t\tpanic(\"asc_end\");\n#endif\n\n\t/* look for disconnected devices */\n\tfor (i = 0; i < ASC_NCMD; i++) {\n\t\tif (!asc->cmd[i] || !(asc->st[i].flags & DISCONN))\n\t\t\tcontinue;\n\t\tasc->regs->asc_cmd = ASC_CMD_ENABLE_SEL;\n\t\treadback(asc->regs->asc_cmd);\n\t\tasc->state = ASC_STATE_RESEL;\n\t\tasc->script = &asc_scripts[SCRIPT_RESEL];\n\t\tbreak;\n\t}\n\n#ifdef USE_NEW_SCSI\n\tif(scsicmd->error == XS_NOERROR && !(state->flags & CHECK_SENSE)) {\n\t\tif((state->statusByte & ST_MASK) == SCSI_CHECK) {\n\t\t\tstruct scsi_sense *ss = (void *)&state->cmd;\n\t\t\t/* Save return values */\n\t\t\tscsicmd->resid = state->buflen;\n\t\t\tscsicmd->status = state->statusByte;\n\t\t\t/* Set up sense request command */\n\t\t\tbzero(ss, sizeof(*ss));\n\t\t\tss->opcode = REQUEST_SENSE;\n\t\t\tss->byte2 = sc_link->lun << 5;\n\t\t\tss->length = sizeof(struct scsi_sense_data);\n\t\t\tstate->cmdlen = sizeof(*ss);\n\t\t\tstate->buf = (vm_offset_t)&scsicmd->sense;\n\t\t\tstate->buflen = sizeof(struct scsi_sense_data);\n\t\t\tstate->flags |= CHECK_SENSE;\n\t\t\tMachFlushDCache(state->buf, state->buflen);\n\t\t\tasc->cmd[target] = scsicmd;\n\t\t\tasc_startcmd(asc, target);\n\t\t\treturn(0);\n\t\t}\n\t}\n#endif /*USE_NEW_SCSI*/\n\n\t/*\n\t * Look for another device that is ready.\n\t * May want to keep last one started and increment for fairness\n\t * rather than always starting at zero.\n\t */\n\tfor (i = 0; i < ASC_NCMD; i++) {\n\t\t/* don't restart a disconnected command */\n\t\tif (!asc->cmd[i] || (asc->st[i].flags & DISCONN))\n\t\t\tcontinue;\n\t\tasc_startcmd(asc, i);\n\t\tbreak;\n\t}\n\n\t/* signal device driver that the command is done */\n\t(*scsicmd->sd->sd_driver->d_done)(scsicmd->unit, state->error,\n\t\tstate->buflen, state->statusByte);\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "readback",
          "args": [
            "regs->asc_cmd"
          ],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASC_SS",
          "args": [
            "ss"
          ],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readback",
          "args": [
            "regs->asc_cmd"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "asc",
            "status",
            "ss",
            "ir"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readback",
          "args": [
            "regs->asc_cmd"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "asc",
            "state",
            "ASCDMA_WRITE"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "asc",
            "state",
            "ASCDMA_READ"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASC_TC_PUT",
          "args": [
            "regs",
            "0"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "2"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readback",
          "args": [
            "regs->asc_cmd"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tc_mb",
          "args": [],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASC_TC_GET",
          "args": [
            "regs",
            "len"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASC_TC_PUT",
          "args": [
            "regs",
            "0xff"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readback",
          "args": [
            "regs->asc_cmd"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readback",
          "args": [
            "regs->asc_cmd"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASC_TC_GET",
          "args": [
            "regs",
            "len"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASC_TC_GET",
          "args": [
            "regs",
            "len"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASC_PHASE",
          "args": [
            "status"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readback",
          "args": [
            "regs->asc_cmd"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "asc",
            "status",
            "ss",
            "ir"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCRIPT_MATCH",
          "args": [
            "ir",
            "status"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readback",
          "args": [
            "regs->asc_cmd"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PACK",
          "args": [
            "asc->sc_dev.dv_unit",
            "status",
            "ss",
            "ir"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/tc/ascvar.h>\n#include <pmax/pmax/kmin.h>\n#include <pmax/pmax/asic.h>\n#include <pmax/dev/ascreg.h>\n#include <pmax/dev/scsi.h>\n#include <pmax/dev/device.h>\n#include <machine/bus.h>\n#include <machine/autoconf.h>\n#include <machine/cpu.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/tc/ioasicvar.h>\n#include <dev/tc/tcvar.h>\n#include <sys/reboot.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/errno.h>\n#include <sys/conf.h>\n#include <sys/buf.h>\n#include <sys/dkstat.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <asc.h>\n\n#define\tSCRIPT_RESUME_NO_DATA\t21\n#define\tSCRIPT_RESUME_DMA_OUT\t20\n#define\tSCRIPT_RESUME_OUT\t19\n#define\tSCRIPT_RESUME_DMA_IN\t18\n#define\tSCRIPT_RESUME_IN\t17\n#define\tSCRIPT_RESEL\t\t16\n#define\tSCRIPT_DISCONNECT\t15\n#define\tSCRIPT_TRY_SYNC\t\t12\n#define\tSCRIPT_MSG_IN\t\t9\n#define\tSCRIPT_DONE\t\t8\n#define\tSCRIPT_GET_STATUS\t7\n#define\tSCRIPT_SIMPLE\t\t6\n#define\tSCRIPT_DATA_OUT\t\t3\n#define\tSCRIPT_CONTINUE_IN\t2\n#define\tSCRIPT_DATA_IN\t\t0\n#define NLOG 32\n\nint\nasc_intr(sc)\n\tvoid *sc;\n{\n\tregister asc_softc_t asc = (asc_softc_t) sc;\n\tregister asc_regmap_t *regs = asc->regs;\n\tregister State *state;\n\tregister script_t *scpt;\n\tregister int ss, ir, status;\n\tregister unsigned char cmd_was;\n\tstatic int ill_cmd_count = 0;\t\t\t/* XXX */\n\n\t/* collect ephemeral information */\n\tstatus = regs->asc_status;\nagain:\n\tss = regs->asc_ss;\n\tcmd_was = regs->asc_cmd;\n\n\t/* drop spurious interrupts */\n\tif ((status & ASC_CSR_INT) == 0)\n\t\treturn (-1);\t\t/* XXX */\n\n\tir = regs->asc_intr;\t/* this resets the previous two: i.e.,*/\n\t\t\t\t/* this re-latches CSR (and SSTEP) */\n\tscpt = asc->script;\n\n\n#ifdef DEBUG\n\tasc_logp->status = PACK(asc->sc_dev.dv_unit, status, ss, ir);\n\tasc_logp->target = (asc->state == ASC_STATE_BUSY) ? asc->target : -1;\n\tasc_logp->state = scpt - asc_scripts;\n\tasc_logp->msg = cmd_was;\n\tasc_logp->resid = 0;\n\tif (++asc_logp >= &asc_log[NLOG])\n\t\tasc_logp = asc_log;\n\tif (asc_debug > 2)\n\t\tprintf(\"asc_intr: status %x ss %x ir %x cond %d:%x\\n\",\n\t\t\tstatus, ss, ir, scpt - asc_scripts, scpt->condition);\n#endif\n\n\t/* This must be done withing 250msec of disconnect */\n\tif (ir & ASC_INT_DISC) {\n\t\tregs->asc_cmd = ASC_CMD_ENABLE_SEL;\n\t\treadback(regs->asc_cmd);\n\t}\n\n\t/* check the expected state */\n\tif (SCRIPT_MATCH(ir, status) == scpt->condition) {\n\t\t/*\n\t\t * Perform the appropriate operation, then proceed.\n\t\t */\n\t\tif ((*scpt->action)(asc, status, ss, ir)) {\n\t\t\tregs->asc_cmd = scpt->command;\n\t\t\treadback(regs->asc_cmd);\n\t\t\tasc->script = scpt->next;\n\t\t}\n\t\tgoto done;\n\t}\n\n\t/*\n\t * Check for parity error.\n\t * Hardware will automatically set ATN\n\t * to request the device for a MSG_OUT phase.\n\t */\n\tif (status & ASC_CSR_PE) {\n\t\tprintf(\"%s: SCSI device %d: incomming parity error seen\\n\",\n\t\t\tasc->sc_dev.dv_xname, asc->target);\n\t\tasc->st[asc->target].flags |= PARITY_ERR;\n\t}\n\n\t/*\n\t * Check for gross error.\n\t * Probably a bug in a device driver.\n\t */\n\tif (status & ASC_CSR_GE) {\n\t\tprintf(\"%s: SCSI device %d: gross error\\n\",\n\t\t\tasc->sc_dev.dv_xname, asc->target);\n\t\tgoto abort;\n\t}\n\n\t/* check for message in or out */\n\tif ((ir & ~ASC_INT_FC) == ASC_INT_BS) {\n\t\tregister int len, fifo;\n\n\t\tstate = &asc->st[asc->target];\n\t\tswitch (ASC_PHASE(status)) {\n\t\tcase SCSI_PHASE_DATAI:\n\t\t\tif ((asc->script - asc_scripts) == SCRIPT_DATA_IN + 1 ||\n\t\t\t    (asc->script - asc_scripts) == SCRIPT_CONTINUE_IN) {\n\t\t\t    \t/*\n\t\t\t    \t * From the Mach driver:\n\t\t\t    \t * After a reconnect and restart dma in, we\n\t\t\t    \t * seem to have gotten an interrupt even though\n\t\t\t    \t * the DMA is running.  The Mach driver just\n\t\t\t    \t * ignores this interrupt.\n\t\t\t    \t */\n\t\t\t\tASC_TC_GET(regs, len);\n\t\t\t\tfifo = regs->asc_flags & ASC_FLAGS_FIFO_CNT;\n\t\t\t    \tprintf(\"asc_intr: ignoring strange interrupt\");\n\t\t\t    \tprintf(\" tc %d fifo residue %d\\n\", len, fifo);\n\t\t\t    \tgoto done;\n\t\t\t}\n\t\t\t/* FALLTHROUGH */\n\t\tcase SCSI_PHASE_DATAO:\n\t\t\tASC_TC_GET(regs, len);\n\t\t\tfifo = regs->asc_flags & ASC_FLAGS_FIFO_CNT;\n\t\t\tprintf(\"asc_intr: data overrun: buflen %d dmalen %d tc %d fifo %d\\n\",\n\t\t\t\tstate->buflen, state->dmalen, len, fifo);\n\t\t\tgoto abort;\n\n\t\tcase SCSI_PHASE_MSG_IN:\n\t\t\tbreak;\n\n\t\tcase SCSI_PHASE_MSG_OUT:\n\t\t\t/*\n\t\t\t * Check for parity error.\n\t\t\t * Hardware will automatically set ATN\n\t\t\t * to request the device for a MSG_OUT phase.\n\t\t\t */\n\t\t\tif (state->flags & PARITY_ERR) {\n\t\t\t\tstate->flags &= ~PARITY_ERR;\n\t\t\t\tstate->msg_out = SCSI_MESSAGE_PARITY_ERROR;\n\t\t\t\t/* reset message in counter */\n\t\t\t\tstate->msglen = 0;\n\t\t\t} else\n\t\t\t\tstate->msg_out = SCSI_NO_OP;\n\t\t\tregs->asc_fifo = state->msg_out;\n\t\t\tregs->asc_cmd = ASC_CMD_XFER_INFO;\n\t\t\treadback(regs->asc_cmd);\n\t\t\tgoto done;\n\n\t\tcase SCSI_PHASE_STATUS:\n\t\t\t/* probably an error in the SCSI command */\n\t\t\tasc->script = &asc_scripts[SCRIPT_GET_STATUS];\n\t\t\tregs->asc_cmd = ASC_CMD_I_COMPLETE;\n\t\t\treadback(regs->asc_cmd);\n\t\t\tgoto done;\n\n\t\tcase SCSI_PHASE_COMMAND:\n\t\t\t/*\n\t\t\t * This seems to occur after the command is sent\n\t\t\t * following sync negotiation.  The device still\n\t\t\t * wants more command data.  The fifo appears to\n\t\t\t * to still have the unsent data - but the 53C94\n\t\t\t * signaled TC.  If the fifo still contains data,\n\t\t\t * transfer it, otherwise do a transfer pad.  The\n\t\t\t * target should then continue through the rest of\n\t\t\t * the phases and complete normally.\n\t\t\t */\n\t\t\tprintf(\"asc_intr: tgt %d command phase TC zero\",\n\t\t\t    asc->target);\n\t\t\tif ((regs->asc_flags & ASC_FLAGS_FIFO_CNT) != 0) {\n\t\t\t\tprintf(\" with non-empty fifo %d\\n\",\n\t\t\t\t    regs->asc_flags & ASC_FLAGS_FIFO_CNT);\n\t\t\t\tregs->asc_cmd = ASC_CMD_XFER_INFO;\n\t\t\t} else {\n\t\t\t\tprintf(\"; padding command\\n\");\n\t\t\t\tASC_TC_PUT(regs, 0xff);\n\t\t\t\tregs->asc_cmd = ASC_CMD_XFER_PAD | ASC_CMD_DMA;\n\t\t\t}\n\t\t\tgoto done;\n\n\t\tdefault:\n\t\t\tprintf(\"asc_intr: target %d, unknown phase 0x%x\\n\", \n\t\t\t  \tasc->target, status);\n\t\t\tgoto abort;\n\t\t}\n\n\t\tif (state->script) {\n\t\t\tprintf(\"asc_intr: target %d, incomplete script %p\\n\", \n\t\t\t  \tasc->target, state->script);\n\t\t\tgoto abort;\n\t\t}\n\n\t\t/* check for DMA in progress */\n\t\tASC_TC_GET(regs, len);\n\t\tfifo = regs->asc_flags & ASC_FLAGS_FIFO_CNT;\n\t\t/* flush any data in the FIFO */\n\t\tif (fifo) {\n\t\t\tif (state->flags & DMA_OUT) {\n#ifdef ASC_DIAGNOSTIC\n\t \t\t\tprintf(\"asc: DMA_OUT, fifo resid %d, len %d, flags 0x%x\\n\",\n\t\t\t\t    fifo, len, state->flags);\n#endif /* ASC_DIAGNOSTIC */\n\t\t\t\tlen += fifo;\n\t\t\t} else if (state->flags & DMA_IN) {\n#ifdef ASC_DIAGNOSTIC\n\t\t\t\tprintf(\"asc_intr: IN: dmalen %d len %d fifo %d\\n\",\n\t\t\t\t\tstate->dmalen, len, fifo); /* XXX */\n#endif /* ASC_DIAGNOSTIC */\n\t\t\t} else\n\t\t\t\tprintf(\"asc_intr: dmalen %d len %d fifo %d\\n\",\n\t\t\t\t\tstate->dmalen, len, fifo); /* XXX */\n\t\t\tregs->asc_cmd = ASC_CMD_FLUSH;\n\t\t\ttc_mb();\n\t\t\treadback(regs->asc_cmd);\n\t\t\tDELAY(2);\n\t\t}\n\t\tif (len && (state->flags & DMA_IN_PROGRESS)) {\n\t\t\t/* save number of bytes still to be sent or received */\n\t\t\tstate->dmaresid = len;\n\t\t\tstate->flags &= ~DMA_IN_PROGRESS;\n\t\t\tASC_TC_PUT(regs, 0);\n#ifdef DEBUG\n\t\t\tif (asc_logp == asc_log)\n\t\t\t\tasc_log[NLOG - 1].resid = len;\n\t\t\telse\n\t\t\t\tasc_logp[-1].resid = len;\n#endif\n\t\t\t/* setup state to resume to */\n\t\t\tif (state->flags & DMA_IN) {\n\t\t\t\t/*\n\t\t\t\t * Since the ASC_CNFG3_SRB bit of the\n\t\t\t\t * cnfg3 register bit is not set,\n\t\t\t\t * we just transferred an extra byte.\n\t\t\t\t * Since we can't resume on an odd byte\n\t\t\t\t * boundary, we copy the valid data out\n\t\t\t\t * and resume DMA at the start address.\n\t\t\t\t */\n\t\t\t\tif (len & 1) {\n\t\t\t\t\tprintf(\"asc_intr: msg in len %d (fifo %d)\\n\",\n\t\t\t\t\t\tlen, fifo); /* XXX */\n\t\t\t\t\tlen = state->dmalen - len;\n\t\t\t\t\tgoto do_in;\n\t\t\t\t}\n\t\t\t\tstate->script =\n\t\t\t\t\t&asc_scripts[SCRIPT_RESUME_DMA_IN];\n\t\t\t\tstate->flags |= DMA_RESUME;\n\t\t\t} else if (state->flags & DMA_OUT) {\n\t\t\t\tstate->script =\n\t\t\t\t\t&asc_scripts[SCRIPT_RESUME_DMA_OUT];\n\t\t\t\tstate->flags |= DMA_RESUME;\n\t\t\t} else\n\t\t\t\tstate->script = asc->script;\n\t\t} else if (state->flags & DMA_IN) {\n#ifdef ASC_DIAGNOSTIC\n\t\t\tif (len) {\n\t\t\t\tprintf(\"asc_intr: 1: len %d (fifo %d)\\n\",\n\t\t\t\t\tlen, fifo); /* XXX */\n\t\t\t}\n#endif\n\t\t\t/* setup state to resume to */\n\t\t\tif (state->flags & DMA_IN_PROGRESS) {\n\t\t\t\tlen = state->dmalen;\n\t\t\t\tstate->flags &= ~DMA_IN_PROGRESS;\n\t\t\tdo_in:\n\t\t\t\tstate->dmalen = len;\t/* dma_end needs actual length */\n\t\t\t\t(*asc->dma_end)(asc, state, ASCDMA_READ);\n\t\t\t\tstate->buf += len;\n\t\t\t\tstate->buflen -= len;\n\t\t\t}\n\t\t\tif (state->buflen)\n\t\t\t\tstate->script = (state->flags & DMA_RESUME) ?\n\t\t\t\t    &asc_scripts[SCRIPT_RESUME_DMA_IN] :\n\t\t\t\t    &asc_scripts[SCRIPT_RESUME_IN];\n\t\t\telse\n\t\t\t\tstate->script =\n\t\t\t\t    &asc_scripts[SCRIPT_RESUME_NO_DATA];\n\t\t} else if (state->flags & DMA_OUT) {\n\t\t\tif (len) {\n#ifdef DEBUG\n\t\t\t\tprintf(\"asc_intr: 2: len %d (fifo %d)\\n\", len,\n\t\t\t\t\tfifo); /* XXX */\n#endif\n\t\t\t}\n\t\t\t/*\n\t\t\t * If this is the last chunk, the next expected\n\t\t\t * state is to get status.\n\t\t\t */\n\t\t\tif (state->flags & DMA_IN_PROGRESS) {\n\t\t\t\tstate->flags &= ~DMA_IN_PROGRESS;\n\t\t\t\t(*asc->dma_end)(asc, state, ASCDMA_WRITE);\n\t\t\t\tlen = state->dmalen;\n\t\t\t\tstate->buf += len;\n\t\t\t\tstate->buflen -= len;\n\t\t\t}\n\t\t\tif (state->buflen)\n\t\t\t\tstate->script = (state->flags & DMA_RESUME) ?\n\t\t\t\t    &asc_scripts[SCRIPT_RESUME_DMA_OUT] :\n\t\t\t\t    &asc_scripts[SCRIPT_RESUME_OUT];\n\t\t\telse\n\t\t\t\tstate->script =\n\t\t\t\t    &asc_scripts[SCRIPT_RESUME_NO_DATA];\n\t\t} else if (asc->script == &asc_scripts[SCRIPT_SIMPLE])\n\t\t\tstate->script = &asc_scripts[SCRIPT_RESUME_NO_DATA];\n\t\telse\n\t\t\tstate->script = asc->script;\n\n\t\t/* setup to receive a message */\n\t\tasc->script = &asc_scripts[SCRIPT_MSG_IN];\n\t\tstate->msglen = 0;\n\t\tregs->asc_cmd = ASC_CMD_XFER_INFO;\n\t\treadback(regs->asc_cmd);\n\t\tgoto done;\n\t}\n\n\t/* check for SCSI bus reset */\n\tif (ir & ASC_INT_RESET) {\n\t\tregister int i;\n\n\t\tprintf(\"%s: SCSI bus reset!!\\n\", asc->sc_dev.dv_xname);\n\t\t/* need to flush any pending commands */\n\t\tfor (i = 0; i < ASC_NCMD; i++) {\n\t\t\tif (!asc->cmd[i])\n\t\t\t\tcontinue;\n\t\t\tasc->st[i].error = EIO;\n\t\t\tasc_end(asc, 0, 0, 0);\n\t\t}\n\t\t/* rearbitrate synchronous offset */\n\t\tfor (i = 0; i < ASC_NCMD; i++) {\n\t\t\tasc->st[i].sync_offset = 0;\n\t\t\tasc->st[i].flags = 0;\n\t\t}\n\t\tasc->target = -1;\n\t\treturn 0 ; /* XXX ??? */\n\t}\n\n\t/* check for disconnect */\n\tif (ir & ASC_INT_DISC) {\n\t\tstate = &asc->st[asc->target];\n\t\tswitch (asc->script - asc_scripts) {\n\t\tcase SCRIPT_DONE:\n\t\tcase SCRIPT_DISCONNECT:\n\t\t\t/*\n\t\t\t * Disconnects can happen normally when the\n\t\t\t * command is complete with the phase being\n\t\t\t * either SCSI_PHASE_DATAO or SCSI_PHASE_MSG_IN.\n\t\t\t * The SCRIPT_MATCH() only checks for one phase\n\t\t\t * so we can wind up here.\n\t\t\t * Perform the appropriate operation, then proceed.\n\t\t\t */\n\t\t\tif ((*scpt->action)(asc, status, ss, ir)) {\n\t\t\t\tregs->asc_cmd = scpt->command;\n\t\t\t\treadback(regs->asc_cmd);\n\t\t\t\tasc->script = scpt->next;\n\t\t\t}\n\t\t\tgoto done;\n\n\t\tcase SCRIPT_TRY_SYNC:\n\t\tcase SCRIPT_SIMPLE:\n\t\tcase SCRIPT_DATA_IN:\n\t\tcase SCRIPT_DATA_OUT: /* one of the starting scripts */\n\t\t\tif (ASC_SS(ss) == 0) {\n\t\t\t\t/* device did not respond */\n\t\t\t\tif (regs->asc_flags & ASC_FLAGS_FIFO_CNT) {\n\t\t\t\t\tregs->asc_cmd = ASC_CMD_FLUSH;\n\t\t\t\t\treadback(regs->asc_cmd);\n\t\t\t\t}\n\t\t\t\tstate->error = ENXIO;\n\t\t\t\tasc_end(asc, status, ss, ir);\n\t\t\t\treturn 0 ; /* XXX ??? */\n\t\t\t}\n\t\t\t/* FALLTHROUGH */\n\n\t\tdefault:\n\t\t\tprintf(\"%s: SCSI device %d: unexpected disconnect\\n\",\n\t\t\t\tasc->sc_dev.dv_xname, asc->target);\n#ifdef DEBUG\n\t\t\tasc_DumpLog(\"asc_disc\");\n#endif\n\t\t\t/*\n\t\t\t * On rare occasions my RZ24 does a disconnect during\n\t\t\t * data in phase and the following seems to keep it\n\t\t\t * happy.\n\t\t\t * XXX Should a scsi disk ever do this??\n\t\t\t */\n\t\t\tasc->script = &asc_scripts[SCRIPT_RESEL];\n\t\t\tasc->state = ASC_STATE_RESEL;\n\t\t\tstate->flags |= DISCONN;\n\t\t\tregs->asc_cmd = ASC_CMD_ENABLE_SEL;\n\t\t\treadback(regs->asc_cmd);\n\t\t\treturn 0 ; /* XXX ??? */\n\t\t}\n\t}\n\n\t/* mhitch - debug - check select/reselect collision */\n\tif ((ir & ASC_INT_ILL) && (regs->asc_cmd & ASC_CMD_SEL_ATN)) {\n\t\tprintf(\"asc_intr: Illegal command status %x ir %x\\n\",\n\t\t    status, ir);\n\t\t/* Should process reselect? */\n\t}\n\n\t/* check for illegal command */\n\tif (ir & ASC_INT_ILL) {\n#ifdef ASC_DIAGNOSTIC\n\t\tprintf(\"asc_intr: Illegal command status %x ir %x cmd %x ? %x\\n\",\n\t\t    status, ir, regs->asc_cmd, asc_scripts[SCRIPT_MSG_IN].command);\n#endif\n\t\t/*\n\t\t * On a 5000/200, I see this frequently when using an RD52\n\t\t * CDROM.  The 53c94 doesn't seem to get the Message Accept\n\t\t * command, and generates an \"Illegal Command\" interrupt.\n\t\t * Re-issuing the Message Accept at this point seems to keep\n\t\t * things going.  Don't allow this too many times in a row,\n\t\t * just to make sure we don't get hung up.  mhitch\n\t\t */\n\t\tif (ill_cmd_count++ != 3) {\t\t\t/* XXX */\n\t\t\tregs->asc_cmd = ASC_CMD_MSG_ACPT;\t/* XXX */\n\t\t\treadback(regs->asc_cmd);\t\t/* XXX */\n\t\t\tgoto done;\t\t\t\t/* XXX */\n\t\t}\t\t\t\t\t\t/* XXX */\n\t\tprintf(\"asc_intr: Illegal command tgt %d\\n\", asc->target);\n\t\tgoto abort;\t/* XXX */\n\t}\n\till_cmd_count = 0;\t\t\t\t\t/* XXX */\n\n\t/* check for reselect */\n\tif (ir & ASC_INT_RESEL) {\n\t\tunsigned fifo, id, msg;\n\n\t\tfifo = regs->asc_flags & ASC_FLAGS_FIFO_CNT;\n\t\tif (fifo < 2) {\n\t\t\tprintf(\"asc_intr: target %d, reselect, fifo %d too small for msg\\n\", \n\t\t\t  \tasc->target, fifo);\n\n\t\t\tgoto abort;\n\t\t}\n\t\t/* read unencoded SCSI ID and convert to binary */\n\t\tmsg = regs->asc_fifo & asc->myidmask;\n\t\tfor (id = 0; (msg & 1) == 0; id++)\n\t\t\tmsg >>= 1;\n\t\t/* read identify message */\n\t\tmsg = regs->asc_fifo;\n#ifdef DEBUG\n\t\tif (asc_logp == asc_log)\n\t\t\tasc_log[NLOG - 1].msg = msg;\n\t\telse\n\t\t\tasc_logp[-1].msg = msg;\n#endif\n\t\t/*\n\t\t * TC may have been initialized during a selection attempt.\n\t\t * Clear it to prevent possible confusion later.\n\t\t */\n\t\tASC_TC_PUT(regs,0);\t/* ensure TC clear */\n\t\tasc->state = ASC_STATE_BUSY;\n\t\tasc->target = id;\n\t\tstate = &asc->st[id];\n\t\tasc->script = state->script;\n\t\tstate->script = (script_t *)0;\n\t\tif (!(state->flags & DISCONN)) {\n\t\t\tprintf(\"asc_intr: reselect tgt %d, flags 0x%x not disconnected\\n\",\n\t\t\t       asc->target, state->flags);\n\t\t\tgoto abort;\n\t\t}\n\t\tstate->flags &= ~DISCONN;\n\t\tregs->asc_syn_p = state->sync_period;\n\t\tregs->asc_syn_o = state->sync_offset;\n\t\tregs->asc_cmd = ASC_CMD_MSG_ACPT;\n\t\treadback(regs->asc_cmd);\n\t\tgoto done;\n\t}\n\n\t/* check if we are being selected as a target */\n\tif (ir & (ASC_INT_SEL | ASC_INT_SEL_ATN)) {\n\t\t\tprintf(\"asc_intr: host adaptor selected as target\\n\");\n\t\tgoto abort;\n\t}\n\t/*\n\t * 'ir' must be just ASC_INT_FC.\n\t * This is normal if canceling an ASC_ENABLE_SEL.\n\t */\n\ndone:\n\ttc_mb();\n\t/* watch out for HW race conditions and setup & hold time violations */\n\tir = regs->asc_status;\n\twhile (ir != (status = regs->asc_status))\n\t\tir = status;\n\tif (status & ASC_CSR_INT)\n\t\tgoto again;\n\treturn 0 ; /* XXX ??? */\n\nabort:\n#ifdef DEBUG\n\tasc_DumpLog(\"asc_intr\");\n#endif\n#if 0\n\tpanic(\"asc_intr\");\n#else\n\tboot(RB_NOSYNC); /* XXX */\n#endif\n}"
  },
  {
    "function_name": "asc_startcmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/tc/asc.c",
    "lines": "660-809",
    "snippet": "static void\nasc_startcmd(asc, target)\n\tasc_softc_t asc;\n\tint target;\n{\n\tregister asc_regmap_t *regs;\n\tregister ScsiCmd *scsicmd;\n\tregister State *state;\n\tint len;\n\n\t/*\n\t * See if another target is currently selected on this SCSI bus.\n\t */\n\tif (asc->target >= 0)\n\t\treturn;\n\n\tregs = asc->regs;\n\n\t/*\n\t * If a reselection is in progress, it is Ok to ignore it since\n\t * the ASC will automatically cancel the command and flush\n\t * the FIFO if the ASC is reselected before the command starts.\n\t * If we try to use ASC_CMD_DISABLE_SEL, we can hang the system if\n\t * a reselect occurs before starting the command.\n\t */\n\n\tasc->state = ASC_STATE_BUSY;\n\tasc->target = target;\n\n\t/* cache some pointers */\n\tscsicmd = asc->cmd[target];\n\tstate = &asc->st[target];\n\n#ifdef DEBUG\n\tif (asc_debug > 1) {\n\t\tprintf(\"asc_startcmd: %s target %d cmd %x len %d\\n\",\n\t\t    scsicmd->sd->sd_driver->d_name, target,\n\t\t    scsicmd->cmd[0], scsicmd->buflen);\n\t}\n#endif\n\n\t/* Try to avoid reselect collisions */\n\tif ((regs->asc_status & (ASC_CSR_INT|SCSI_PHASE_MSG_IN)) ==\n\t    (ASC_CSR_INT|SCSI_PHASE_MSG_IN)) {\n/*\t\tprintf(\"asc_startcmd: possible reselect in progress\\n\"); */\n\t\treturn;\n\t}\n\n\t/*\n\t * Init the chip and target state.\n\t */\n\tstate->flags = state->flags & DID_SYNC;\n\tstate->error = 0;\n\tstate->script = (script_t *)0;\n\tstate->msg_out = SCSI_NO_OP;\n\n\tlen = scsicmd->cmdlen;\n\tstate->dmalen = len;\n\n\t/* check for simple SCSI command with no data transfer */\n\tif ((state->buflen = scsicmd->buflen) == 0) {\n\t\t/* check for sync negotiation */\n\t\tif ((scsicmd->flags & SCSICMD_USE_SYNC) &&\n\t\t    !(state->flags & DID_SYNC)) {\n\t\t\tasc->script = &asc_scripts[SCRIPT_TRY_SYNC];\n\t\t\tstate->flags |= TRY_SYNC;\n\t\t} else\n\t\t\tasc->script = &asc_scripts[SCRIPT_SIMPLE];\n\t\tstate->buf = (char *)0;\n\t} else if (scsicmd->flags & SCSICMD_DATA_TO_DEVICE) {\n\t\tasc->script = &asc_scripts[SCRIPT_DATA_OUT];\n\t\tstate->buf = scsicmd->buf;\n\t\tstate->flags |= DMA_OUT;\n\t} else {\n\t\tasc->script = &asc_scripts[SCRIPT_DATA_IN];\n\t\tstate->buf = scsicmd->buf;\n\t\tstate->flags |= DMA_IN;\n\t}\n\n#ifdef DEBUG\n\tasc_debug_cmd = scsicmd->cmd[0];\n\tif (scsicmd->cmd[0] == SCSI_READ_EXT) {\n\t\tasc_debug_bn = (scsicmd->cmd[2] << 24) |\n\t\t\t(scsicmd->cmd[3] << 16) |\n\t\t\t(scsicmd->cmd[4] << 8) |\n\t\t\tscsicmd->cmd[5];\n\t\tasc_debug_sz = (scsicmd->cmd[7] << 8) | scsicmd->cmd[8];\n\t}\n\tasc_logp->status = PACK(asc->sc_dev.dv_unit, 0, 0, asc_debug_cmd);\n\tasc_logp->target = asc->target;\n\tasc_logp->state = asc->script - asc_scripts;\n\tasc_logp->msg = SCSI_DIS_REC_IDENTIFY;\n\tasc_logp->resid = scsicmd->buflen;\n\tif (++asc_logp >= &asc_log[NLOG])\n\t\tasc_logp = asc_log;\n#endif\n\n\t/* preload the FIFO with the message to be sent */\n\tregs->asc_fifo = SCSI_DIS_REC_IDENTIFY;\n\ttc_mb();\n\n\t/* initialize the DMA */\n\tlen = (*asc->dma_start)(asc, state, scsicmd->cmd, ASCDMA_WRITE,\n\t   len, 0);\n\tASC_TC_PUT(regs, len);\n\treadback(regs->asc_cmd);\n\n\tregs->asc_dbus_id = target;\n\treadback(regs->asc_dbus_id);\n\tregs->asc_syn_p = state->sync_period;\n\treadback(regs->asc_syn_p);\n\tregs->asc_syn_o = state->sync_offset;\n\treadback(regs->asc_syn_o);\n\n\t/* Try to avoid reselect collisions */\n\tif ((regs->asc_status & (ASC_CSR_INT|SCSI_PHASE_MSG_IN)) ==\n\t    (ASC_CSR_INT|SCSI_PHASE_MSG_IN)) {\n/*\t\tprintf(\"asc_startcmd: reselect in progress (before select)\\n\");*/\n\t\treturn;\n\t}\n\n\tif (state->flags & TRY_SYNC)\n\t\tregs->asc_cmd = len = ASC_CMD_SEL_ATN_STOP;\n\telse\n\t\tregs->asc_cmd = len = ASC_CMD_SEL_ATN | ASC_CMD_DMA;\n\treadback(regs->asc_cmd);\n\n\t/* Try to avoid reselect collisions */\n\tif ((regs->asc_status & (ASC_CSR_INT|SCSI_PHASE_MSG_IN)) ==\n\t    (ASC_CSR_INT|SCSI_PHASE_MSG_IN)) {\n/*\t\tprintf(\"asc_startcmd: reselect in progress after select\\n\");*/\n\t\treturn;\n\t} else {\n\t\t/*\n\t\t * Here's a potentially nasty but infrequent problem:  a\n\t\t * reselect may have occurred, but did not interrupt.\n\t\t */\n\t\tif (regs->asc_cmd != len &&\n\t\t    regs->asc_cmd == (ASC_CMD_NOP|ASC_CMD_DMA)) {\n\t\t    \tif ((regs->asc_status & ASC_CSR_INT) == 0) {\n\t\t    \t\tdelay(250);\n\t\t    \t\tif (regs->asc_status == SCSI_PHASE_MSG_IN) {\n\t\t    \t\t\tprintf(\"asc_startcmd: reselect failed to interrupt?\\n\");\n\t\t    \t\t\t/* XXXX THIS NEEDS FIXING */\n\t\t    \t\t}\n\t\t    \t}\n\t\t}\n\t}\n\n}",
    "includes": [
      "#include <dev/tc/ascvar.h>",
      "#include <pmax/pmax/kmin.h>",
      "#include <pmax/pmax/asic.h>",
      "#include <pmax/dev/ascreg.h>",
      "#include <pmax/dev/scsi.h>",
      "#include <pmax/dev/device.h>",
      "#include <machine/bus.h>",
      "#include <machine/autoconf.h>",
      "#include <machine/cpu.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/tc/ioasicvar.h>",
      "#include <dev/tc/tcvar.h>",
      "#include <sys/reboot.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/errno.h>",
      "#include <sys/conf.h>",
      "#include <sys/buf.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <asc.h>"
    ],
    "macros_used": [
      "#define\tSCRIPT_TRY_SYNC\t\t12",
      "#define\tSCRIPT_SIMPLE\t\t6",
      "#define\tSCRIPT_DATA_OUT\t\t3",
      "#define\tSCRIPT_DATA_IN\t\t0",
      "#define NLOG 32"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"asc_startcmd: reselect failed to interrupt?\\n\""
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "250"
          ],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "readback",
          "args": [
            "regs->asc_cmd"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readback",
          "args": [
            "regs->asc_syn_o"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readback",
          "args": [
            "regs->asc_syn_p"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readback",
          "args": [
            "regs->asc_dbus_id"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readback",
          "args": [
            "regs->asc_cmd"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASC_TC_PUT",
          "args": [
            "regs",
            "len"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "asc",
            "state",
            "scsicmd->cmd",
            "ASCDMA_WRITE",
            "len",
            "0"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tc_mb",
          "args": [],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PACK",
          "args": [
            "asc->sc_dev.dv_unit",
            "0",
            "0",
            "asc_debug_cmd"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/tc/ascvar.h>\n#include <pmax/pmax/kmin.h>\n#include <pmax/pmax/asic.h>\n#include <pmax/dev/ascreg.h>\n#include <pmax/dev/scsi.h>\n#include <pmax/dev/device.h>\n#include <machine/bus.h>\n#include <machine/autoconf.h>\n#include <machine/cpu.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/tc/ioasicvar.h>\n#include <dev/tc/tcvar.h>\n#include <sys/reboot.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/errno.h>\n#include <sys/conf.h>\n#include <sys/buf.h>\n#include <sys/dkstat.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <asc.h>\n\n#define\tSCRIPT_TRY_SYNC\t\t12\n#define\tSCRIPT_SIMPLE\t\t6\n#define\tSCRIPT_DATA_OUT\t\t3\n#define\tSCRIPT_DATA_IN\t\t0\n#define NLOG 32\n\nstatic void\nasc_startcmd(asc, target)\n\tasc_softc_t asc;\n\tint target;\n{\n\tregister asc_regmap_t *regs;\n\tregister ScsiCmd *scsicmd;\n\tregister State *state;\n\tint len;\n\n\t/*\n\t * See if another target is currently selected on this SCSI bus.\n\t */\n\tif (asc->target >= 0)\n\t\treturn;\n\n\tregs = asc->regs;\n\n\t/*\n\t * If a reselection is in progress, it is Ok to ignore it since\n\t * the ASC will automatically cancel the command and flush\n\t * the FIFO if the ASC is reselected before the command starts.\n\t * If we try to use ASC_CMD_DISABLE_SEL, we can hang the system if\n\t * a reselect occurs before starting the command.\n\t */\n\n\tasc->state = ASC_STATE_BUSY;\n\tasc->target = target;\n\n\t/* cache some pointers */\n\tscsicmd = asc->cmd[target];\n\tstate = &asc->st[target];\n\n#ifdef DEBUG\n\tif (asc_debug > 1) {\n\t\tprintf(\"asc_startcmd: %s target %d cmd %x len %d\\n\",\n\t\t    scsicmd->sd->sd_driver->d_name, target,\n\t\t    scsicmd->cmd[0], scsicmd->buflen);\n\t}\n#endif\n\n\t/* Try to avoid reselect collisions */\n\tif ((regs->asc_status & (ASC_CSR_INT|SCSI_PHASE_MSG_IN)) ==\n\t    (ASC_CSR_INT|SCSI_PHASE_MSG_IN)) {\n/*\t\tprintf(\"asc_startcmd: possible reselect in progress\\n\"); */\n\t\treturn;\n\t}\n\n\t/*\n\t * Init the chip and target state.\n\t */\n\tstate->flags = state->flags & DID_SYNC;\n\tstate->error = 0;\n\tstate->script = (script_t *)0;\n\tstate->msg_out = SCSI_NO_OP;\n\n\tlen = scsicmd->cmdlen;\n\tstate->dmalen = len;\n\n\t/* check for simple SCSI command with no data transfer */\n\tif ((state->buflen = scsicmd->buflen) == 0) {\n\t\t/* check for sync negotiation */\n\t\tif ((scsicmd->flags & SCSICMD_USE_SYNC) &&\n\t\t    !(state->flags & DID_SYNC)) {\n\t\t\tasc->script = &asc_scripts[SCRIPT_TRY_SYNC];\n\t\t\tstate->flags |= TRY_SYNC;\n\t\t} else\n\t\t\tasc->script = &asc_scripts[SCRIPT_SIMPLE];\n\t\tstate->buf = (char *)0;\n\t} else if (scsicmd->flags & SCSICMD_DATA_TO_DEVICE) {\n\t\tasc->script = &asc_scripts[SCRIPT_DATA_OUT];\n\t\tstate->buf = scsicmd->buf;\n\t\tstate->flags |= DMA_OUT;\n\t} else {\n\t\tasc->script = &asc_scripts[SCRIPT_DATA_IN];\n\t\tstate->buf = scsicmd->buf;\n\t\tstate->flags |= DMA_IN;\n\t}\n\n#ifdef DEBUG\n\tasc_debug_cmd = scsicmd->cmd[0];\n\tif (scsicmd->cmd[0] == SCSI_READ_EXT) {\n\t\tasc_debug_bn = (scsicmd->cmd[2] << 24) |\n\t\t\t(scsicmd->cmd[3] << 16) |\n\t\t\t(scsicmd->cmd[4] << 8) |\n\t\t\tscsicmd->cmd[5];\n\t\tasc_debug_sz = (scsicmd->cmd[7] << 8) | scsicmd->cmd[8];\n\t}\n\tasc_logp->status = PACK(asc->sc_dev.dv_unit, 0, 0, asc_debug_cmd);\n\tasc_logp->target = asc->target;\n\tasc_logp->state = asc->script - asc_scripts;\n\tasc_logp->msg = SCSI_DIS_REC_IDENTIFY;\n\tasc_logp->resid = scsicmd->buflen;\n\tif (++asc_logp >= &asc_log[NLOG])\n\t\tasc_logp = asc_log;\n#endif\n\n\t/* preload the FIFO with the message to be sent */\n\tregs->asc_fifo = SCSI_DIS_REC_IDENTIFY;\n\ttc_mb();\n\n\t/* initialize the DMA */\n\tlen = (*asc->dma_start)(asc, state, scsicmd->cmd, ASCDMA_WRITE,\n\t   len, 0);\n\tASC_TC_PUT(regs, len);\n\treadback(regs->asc_cmd);\n\n\tregs->asc_dbus_id = target;\n\treadback(regs->asc_dbus_id);\n\tregs->asc_syn_p = state->sync_period;\n\treadback(regs->asc_syn_p);\n\tregs->asc_syn_o = state->sync_offset;\n\treadback(regs->asc_syn_o);\n\n\t/* Try to avoid reselect collisions */\n\tif ((regs->asc_status & (ASC_CSR_INT|SCSI_PHASE_MSG_IN)) ==\n\t    (ASC_CSR_INT|SCSI_PHASE_MSG_IN)) {\n/*\t\tprintf(\"asc_startcmd: reselect in progress (before select)\\n\");*/\n\t\treturn;\n\t}\n\n\tif (state->flags & TRY_SYNC)\n\t\tregs->asc_cmd = len = ASC_CMD_SEL_ATN_STOP;\n\telse\n\t\tregs->asc_cmd = len = ASC_CMD_SEL_ATN | ASC_CMD_DMA;\n\treadback(regs->asc_cmd);\n\n\t/* Try to avoid reselect collisions */\n\tif ((regs->asc_status & (ASC_CSR_INT|SCSI_PHASE_MSG_IN)) ==\n\t    (ASC_CSR_INT|SCSI_PHASE_MSG_IN)) {\n/*\t\tprintf(\"asc_startcmd: reselect in progress after select\\n\");*/\n\t\treturn;\n\t} else {\n\t\t/*\n\t\t * Here's a potentially nasty but infrequent problem:  a\n\t\t * reselect may have occurred, but did not interrupt.\n\t\t */\n\t\tif (regs->asc_cmd != len &&\n\t\t    regs->asc_cmd == (ASC_CMD_NOP|ASC_CMD_DMA)) {\n\t\t    \tif ((regs->asc_status & ASC_CSR_INT) == 0) {\n\t\t    \t\tdelay(250);\n\t\t    \t\tif (regs->asc_status == SCSI_PHASE_MSG_IN) {\n\t\t    \t\t\tprintf(\"asc_startcmd: reselect failed to interrupt?\\n\");\n\t\t    \t\t\t/* XXXX THIS NEEDS FIXING */\n\t\t    \t\t}\n\t\t    \t}\n\t\t}\n\t}\n\n}"
  },
  {
    "function_name": "asc_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/tc/asc.c",
    "lines": "623-655",
    "snippet": "static void\nasc_reset(asc, regs)\n\tasc_softc_t asc;\n\tasc_regmap_t *regs;\n{\n\n\t/*\n\t * Reset chip and wait till done\n\t */\n\tregs->asc_cmd = ASC_CMD_RESET;\n\ttc_syncbus(); DELAY(25);\n\n\t/* spec says this is needed after reset */\n\tregs->asc_cmd = ASC_CMD_NOP;\n\ttc_syncbus(); DELAY(25);\n\n\t/*\n\t * Set up various chip parameters\n\t */\n\tregs->asc_ccf = asc->ccf;\n\ttc_syncbus(); DELAY(25);\n\tregs->asc_sel_timo = asc->timeout_250;\n\t/* restore our ID */\n\tregs->asc_cnfg1 = asc->sc_id | ASC_CNFG1_P_CHECK;\n\t/* include ASC_CNFG2_SCSI2 if you want to allow SCSI II commands */\n\tregs->asc_cnfg2 = /* ASC_CNFG2_RFB | ASC_CNFG2_SCSI2 | */ ASC_CNFG2_EPL;\n\tregs->asc_cnfg3 = 0;\n\t/* zero anything else */\n\tASC_TC_PUT(regs, 0);\n\tregs->asc_syn_p = asc->min_period;\n\tregs->asc_syn_o = 0;\t/* async for now */\n\ttc_mb();\n}",
    "includes": [
      "#include <dev/tc/ascvar.h>",
      "#include <pmax/pmax/kmin.h>",
      "#include <pmax/pmax/asic.h>",
      "#include <pmax/dev/ascreg.h>",
      "#include <pmax/dev/scsi.h>",
      "#include <pmax/dev/device.h>",
      "#include <machine/bus.h>",
      "#include <machine/autoconf.h>",
      "#include <machine/cpu.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/tc/ioasicvar.h>",
      "#include <dev/tc/tcvar.h>",
      "#include <sys/reboot.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/errno.h>",
      "#include <sys/conf.h>",
      "#include <sys/buf.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <asc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tc_mb",
          "args": [],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASC_TC_PUT",
          "args": [
            "regs",
            "0"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "25"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tc_syncbus",
          "args": [],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "25"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tc_syncbus",
          "args": [],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "25"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tc_syncbus",
          "args": [],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/tc/ascvar.h>\n#include <pmax/pmax/kmin.h>\n#include <pmax/pmax/asic.h>\n#include <pmax/dev/ascreg.h>\n#include <pmax/dev/scsi.h>\n#include <pmax/dev/device.h>\n#include <machine/bus.h>\n#include <machine/autoconf.h>\n#include <machine/cpu.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/tc/ioasicvar.h>\n#include <dev/tc/tcvar.h>\n#include <sys/reboot.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/errno.h>\n#include <sys/conf.h>\n#include <sys/buf.h>\n#include <sys/dkstat.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <asc.h>\n\nstatic void\nasc_reset(asc, regs)\n\tasc_softc_t asc;\n\tasc_regmap_t *regs;\n{\n\n\t/*\n\t * Reset chip and wait till done\n\t */\n\tregs->asc_cmd = ASC_CMD_RESET;\n\ttc_syncbus(); DELAY(25);\n\n\t/* spec says this is needed after reset */\n\tregs->asc_cmd = ASC_CMD_NOP;\n\ttc_syncbus(); DELAY(25);\n\n\t/*\n\t * Set up various chip parameters\n\t */\n\tregs->asc_ccf = asc->ccf;\n\ttc_syncbus(); DELAY(25);\n\tregs->asc_sel_timo = asc->timeout_250;\n\t/* restore our ID */\n\tregs->asc_cnfg1 = asc->sc_id | ASC_CNFG1_P_CHECK;\n\t/* include ASC_CNFG2_SCSI2 if you want to allow SCSI II commands */\n\tregs->asc_cnfg2 = /* ASC_CNFG2_RFB | ASC_CNFG2_SCSI2 | */ ASC_CNFG2_EPL;\n\tregs->asc_cnfg3 = 0;\n\t/* zero anything else */\n\tASC_TC_PUT(regs, 0);\n\tregs->asc_syn_p = asc->min_period;\n\tregs->asc_syn_o = 0;\t/* async for now */\n\ttc_mb();\n}"
  },
  {
    "function_name": "asc_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/tc/asc.c",
    "lines": "598-620",
    "snippet": "int\nasc_poll(asc, target)\n\tstruct asc_softc *asc;\n\tint target;\n{\n\tstruct scsi_xfer *scsicmd = asc->cmd[target];\n\tint count = scsicmd->timeout * 10;\n\n\twhile(count) {\n\t\tif(asc->regs->asc_status &ASC_CSR_INT) {\n\t\t\tasc_intr(asc);\n\t\t}\n\t\tif(scsicmd->flags & ITSDONE)\n\t\t\tbreak;\n\t\tDELAY(5);\n\t\tcount--;\n\t}\n\tif(count == 0) {\n\t\tscsicmd->error = XS_TIMEOUT;\n\t\tasc_end(asc, 0, 0, 0);\n\t}\n\treturn COMPLETE;\n}",
    "includes": [
      "#include <dev/tc/ascvar.h>",
      "#include <pmax/pmax/kmin.h>",
      "#include <pmax/pmax/asic.h>",
      "#include <pmax/dev/ascreg.h>",
      "#include <pmax/dev/scsi.h>",
      "#include <pmax/dev/device.h>",
      "#include <machine/bus.h>",
      "#include <machine/autoconf.h>",
      "#include <machine/cpu.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/tc/ioasicvar.h>",
      "#include <dev/tc/tcvar.h>",
      "#include <sys/reboot.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/errno.h>",
      "#include <sys/conf.h>",
      "#include <sys/buf.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <asc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "asc_end",
          "args": [
            "asc",
            "0",
            "0",
            "0"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "asc_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/tc/asc.c",
          "lines": "1366-1448",
          "snippet": "static int\nasc_end(asc, status, ss, ir)\n\tregister asc_softc_t asc;\n\tregister int status, ss, ir;\n{\n\tregister ScsiCmd *scsicmd;\n\tregister State *state;\n\tregister int i, target;\n\n\tasc->state = ASC_STATE_IDLE;\n\ttarget = asc->target;\n\tasc->target = -1;\n\tscsicmd = asc->cmd[target];\n\tasc->cmd[target] = (ScsiCmd *)0;\n\tstate = &asc->st[target];\n\tuntimeout(asc_timeout, scsicmd);\n\n#ifdef DEBUG\n\tif (asc_debug > 1) {\n\t\tprintf(\"asc_end: %s target %d cmd %x err %d resid %d\\n\",\n\t\t\tscsicmd->sd->sd_driver->d_name, target,\n\t\t\tscsicmd->cmd[0], state->error, state->buflen);\n\t}\n#endif\n#ifdef DIAGNOSTIC\n\tif (target < 0 || !scsicmd)\n\t\tpanic(\"asc_end\");\n#endif\n\n\t/* look for disconnected devices */\n\tfor (i = 0; i < ASC_NCMD; i++) {\n\t\tif (!asc->cmd[i] || !(asc->st[i].flags & DISCONN))\n\t\t\tcontinue;\n\t\tasc->regs->asc_cmd = ASC_CMD_ENABLE_SEL;\n\t\treadback(asc->regs->asc_cmd);\n\t\tasc->state = ASC_STATE_RESEL;\n\t\tasc->script = &asc_scripts[SCRIPT_RESEL];\n\t\tbreak;\n\t}\n\n#ifdef USE_NEW_SCSI\n\tif(scsicmd->error == XS_NOERROR && !(state->flags & CHECK_SENSE)) {\n\t\tif((state->statusByte & ST_MASK) == SCSI_CHECK) {\n\t\t\tstruct scsi_sense *ss = (void *)&state->cmd;\n\t\t\t/* Save return values */\n\t\t\tscsicmd->resid = state->buflen;\n\t\t\tscsicmd->status = state->statusByte;\n\t\t\t/* Set up sense request command */\n\t\t\tbzero(ss, sizeof(*ss));\n\t\t\tss->opcode = REQUEST_SENSE;\n\t\t\tss->byte2 = sc_link->lun << 5;\n\t\t\tss->length = sizeof(struct scsi_sense_data);\n\t\t\tstate->cmdlen = sizeof(*ss);\n\t\t\tstate->buf = (vm_offset_t)&scsicmd->sense;\n\t\t\tstate->buflen = sizeof(struct scsi_sense_data);\n\t\t\tstate->flags |= CHECK_SENSE;\n\t\t\tMachFlushDCache(state->buf, state->buflen);\n\t\t\tasc->cmd[target] = scsicmd;\n\t\t\tasc_startcmd(asc, target);\n\t\t\treturn(0);\n\t\t}\n\t}\n#endif /*USE_NEW_SCSI*/\n\n\t/*\n\t * Look for another device that is ready.\n\t * May want to keep last one started and increment for fairness\n\t * rather than always starting at zero.\n\t */\n\tfor (i = 0; i < ASC_NCMD; i++) {\n\t\t/* don't restart a disconnected command */\n\t\tif (!asc->cmd[i] || (asc->st[i].flags & DISCONN))\n\t\t\tcontinue;\n\t\tasc_startcmd(asc, i);\n\t\tbreak;\n\t}\n\n\t/* signal device driver that the command is done */\n\t(*scsicmd->sd->sd_driver->d_done)(scsicmd->unit, state->error,\n\t\tstate->buflen, state->statusByte);\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/tc/ascvar.h>",
            "#include <pmax/pmax/kmin.h>",
            "#include <pmax/pmax/asic.h>",
            "#include <pmax/dev/ascreg.h>",
            "#include <pmax/dev/scsi.h>",
            "#include <pmax/dev/device.h>",
            "#include <machine/bus.h>",
            "#include <machine/autoconf.h>",
            "#include <machine/cpu.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/tc/ioasicvar.h>",
            "#include <dev/tc/tcvar.h>",
            "#include <sys/reboot.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/errno.h>",
            "#include <sys/conf.h>",
            "#include <sys/buf.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <asc.h>"
          ],
          "macros_used": [
            "#define\tSCRIPT_RESEL\t\t16"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/tc/ascvar.h>\n#include <pmax/pmax/kmin.h>\n#include <pmax/pmax/asic.h>\n#include <pmax/dev/ascreg.h>\n#include <pmax/dev/scsi.h>\n#include <pmax/dev/device.h>\n#include <machine/bus.h>\n#include <machine/autoconf.h>\n#include <machine/cpu.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/tc/ioasicvar.h>\n#include <dev/tc/tcvar.h>\n#include <sys/reboot.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/errno.h>\n#include <sys/conf.h>\n#include <sys/buf.h>\n#include <sys/dkstat.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <asc.h>\n\n#define\tSCRIPT_RESEL\t\t16\n\nstatic int\nasc_end(asc, status, ss, ir)\n\tregister asc_softc_t asc;\n\tregister int status, ss, ir;\n{\n\tregister ScsiCmd *scsicmd;\n\tregister State *state;\n\tregister int i, target;\n\n\tasc->state = ASC_STATE_IDLE;\n\ttarget = asc->target;\n\tasc->target = -1;\n\tscsicmd = asc->cmd[target];\n\tasc->cmd[target] = (ScsiCmd *)0;\n\tstate = &asc->st[target];\n\tuntimeout(asc_timeout, scsicmd);\n\n#ifdef DEBUG\n\tif (asc_debug > 1) {\n\t\tprintf(\"asc_end: %s target %d cmd %x err %d resid %d\\n\",\n\t\t\tscsicmd->sd->sd_driver->d_name, target,\n\t\t\tscsicmd->cmd[0], state->error, state->buflen);\n\t}\n#endif\n#ifdef DIAGNOSTIC\n\tif (target < 0 || !scsicmd)\n\t\tpanic(\"asc_end\");\n#endif\n\n\t/* look for disconnected devices */\n\tfor (i = 0; i < ASC_NCMD; i++) {\n\t\tif (!asc->cmd[i] || !(asc->st[i].flags & DISCONN))\n\t\t\tcontinue;\n\t\tasc->regs->asc_cmd = ASC_CMD_ENABLE_SEL;\n\t\treadback(asc->regs->asc_cmd);\n\t\tasc->state = ASC_STATE_RESEL;\n\t\tasc->script = &asc_scripts[SCRIPT_RESEL];\n\t\tbreak;\n\t}\n\n#ifdef USE_NEW_SCSI\n\tif(scsicmd->error == XS_NOERROR && !(state->flags & CHECK_SENSE)) {\n\t\tif((state->statusByte & ST_MASK) == SCSI_CHECK) {\n\t\t\tstruct scsi_sense *ss = (void *)&state->cmd;\n\t\t\t/* Save return values */\n\t\t\tscsicmd->resid = state->buflen;\n\t\t\tscsicmd->status = state->statusByte;\n\t\t\t/* Set up sense request command */\n\t\t\tbzero(ss, sizeof(*ss));\n\t\t\tss->opcode = REQUEST_SENSE;\n\t\t\tss->byte2 = sc_link->lun << 5;\n\t\t\tss->length = sizeof(struct scsi_sense_data);\n\t\t\tstate->cmdlen = sizeof(*ss);\n\t\t\tstate->buf = (vm_offset_t)&scsicmd->sense;\n\t\t\tstate->buflen = sizeof(struct scsi_sense_data);\n\t\t\tstate->flags |= CHECK_SENSE;\n\t\t\tMachFlushDCache(state->buf, state->buflen);\n\t\t\tasc->cmd[target] = scsicmd;\n\t\t\tasc_startcmd(asc, target);\n\t\t\treturn(0);\n\t\t}\n\t}\n#endif /*USE_NEW_SCSI*/\n\n\t/*\n\t * Look for another device that is ready.\n\t * May want to keep last one started and increment for fairness\n\t * rather than always starting at zero.\n\t */\n\tfor (i = 0; i < ASC_NCMD; i++) {\n\t\t/* don't restart a disconnected command */\n\t\tif (!asc->cmd[i] || (asc->st[i].flags & DISCONN))\n\t\t\tcontinue;\n\t\tasc_startcmd(asc, i);\n\t\tbreak;\n\t}\n\n\t/* signal device driver that the command is done */\n\t(*scsicmd->sd->sd_driver->d_done)(scsicmd->unit, state->error,\n\t\tstate->buflen, state->statusByte);\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "5"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asc_intr",
          "args": [
            "asc"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "asc_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/tc/asc.c",
          "lines": "819-1300",
          "snippet": "int\nasc_intr(sc)\n\tvoid *sc;\n{\n\tregister asc_softc_t asc = (asc_softc_t) sc;\n\tregister asc_regmap_t *regs = asc->regs;\n\tregister State *state;\n\tregister script_t *scpt;\n\tregister int ss, ir, status;\n\tregister unsigned char cmd_was;\n\tstatic int ill_cmd_count = 0;\t\t\t/* XXX */\n\n\t/* collect ephemeral information */\n\tstatus = regs->asc_status;\nagain:\n\tss = regs->asc_ss;\n\tcmd_was = regs->asc_cmd;\n\n\t/* drop spurious interrupts */\n\tif ((status & ASC_CSR_INT) == 0)\n\t\treturn (-1);\t\t/* XXX */\n\n\tir = regs->asc_intr;\t/* this resets the previous two: i.e.,*/\n\t\t\t\t/* this re-latches CSR (and SSTEP) */\n\tscpt = asc->script;\n\n\n#ifdef DEBUG\n\tasc_logp->status = PACK(asc->sc_dev.dv_unit, status, ss, ir);\n\tasc_logp->target = (asc->state == ASC_STATE_BUSY) ? asc->target : -1;\n\tasc_logp->state = scpt - asc_scripts;\n\tasc_logp->msg = cmd_was;\n\tasc_logp->resid = 0;\n\tif (++asc_logp >= &asc_log[NLOG])\n\t\tasc_logp = asc_log;\n\tif (asc_debug > 2)\n\t\tprintf(\"asc_intr: status %x ss %x ir %x cond %d:%x\\n\",\n\t\t\tstatus, ss, ir, scpt - asc_scripts, scpt->condition);\n#endif\n\n\t/* This must be done withing 250msec of disconnect */\n\tif (ir & ASC_INT_DISC) {\n\t\tregs->asc_cmd = ASC_CMD_ENABLE_SEL;\n\t\treadback(regs->asc_cmd);\n\t}\n\n\t/* check the expected state */\n\tif (SCRIPT_MATCH(ir, status) == scpt->condition) {\n\t\t/*\n\t\t * Perform the appropriate operation, then proceed.\n\t\t */\n\t\tif ((*scpt->action)(asc, status, ss, ir)) {\n\t\t\tregs->asc_cmd = scpt->command;\n\t\t\treadback(regs->asc_cmd);\n\t\t\tasc->script = scpt->next;\n\t\t}\n\t\tgoto done;\n\t}\n\n\t/*\n\t * Check for parity error.\n\t * Hardware will automatically set ATN\n\t * to request the device for a MSG_OUT phase.\n\t */\n\tif (status & ASC_CSR_PE) {\n\t\tprintf(\"%s: SCSI device %d: incomming parity error seen\\n\",\n\t\t\tasc->sc_dev.dv_xname, asc->target);\n\t\tasc->st[asc->target].flags |= PARITY_ERR;\n\t}\n\n\t/*\n\t * Check for gross error.\n\t * Probably a bug in a device driver.\n\t */\n\tif (status & ASC_CSR_GE) {\n\t\tprintf(\"%s: SCSI device %d: gross error\\n\",\n\t\t\tasc->sc_dev.dv_xname, asc->target);\n\t\tgoto abort;\n\t}\n\n\t/* check for message in or out */\n\tif ((ir & ~ASC_INT_FC) == ASC_INT_BS) {\n\t\tregister int len, fifo;\n\n\t\tstate = &asc->st[asc->target];\n\t\tswitch (ASC_PHASE(status)) {\n\t\tcase SCSI_PHASE_DATAI:\n\t\t\tif ((asc->script - asc_scripts) == SCRIPT_DATA_IN + 1 ||\n\t\t\t    (asc->script - asc_scripts) == SCRIPT_CONTINUE_IN) {\n\t\t\t    \t/*\n\t\t\t    \t * From the Mach driver:\n\t\t\t    \t * After a reconnect and restart dma in, we\n\t\t\t    \t * seem to have gotten an interrupt even though\n\t\t\t    \t * the DMA is running.  The Mach driver just\n\t\t\t    \t * ignores this interrupt.\n\t\t\t    \t */\n\t\t\t\tASC_TC_GET(regs, len);\n\t\t\t\tfifo = regs->asc_flags & ASC_FLAGS_FIFO_CNT;\n\t\t\t    \tprintf(\"asc_intr: ignoring strange interrupt\");\n\t\t\t    \tprintf(\" tc %d fifo residue %d\\n\", len, fifo);\n\t\t\t    \tgoto done;\n\t\t\t}\n\t\t\t/* FALLTHROUGH */\n\t\tcase SCSI_PHASE_DATAO:\n\t\t\tASC_TC_GET(regs, len);\n\t\t\tfifo = regs->asc_flags & ASC_FLAGS_FIFO_CNT;\n\t\t\tprintf(\"asc_intr: data overrun: buflen %d dmalen %d tc %d fifo %d\\n\",\n\t\t\t\tstate->buflen, state->dmalen, len, fifo);\n\t\t\tgoto abort;\n\n\t\tcase SCSI_PHASE_MSG_IN:\n\t\t\tbreak;\n\n\t\tcase SCSI_PHASE_MSG_OUT:\n\t\t\t/*\n\t\t\t * Check for parity error.\n\t\t\t * Hardware will automatically set ATN\n\t\t\t * to request the device for a MSG_OUT phase.\n\t\t\t */\n\t\t\tif (state->flags & PARITY_ERR) {\n\t\t\t\tstate->flags &= ~PARITY_ERR;\n\t\t\t\tstate->msg_out = SCSI_MESSAGE_PARITY_ERROR;\n\t\t\t\t/* reset message in counter */\n\t\t\t\tstate->msglen = 0;\n\t\t\t} else\n\t\t\t\tstate->msg_out = SCSI_NO_OP;\n\t\t\tregs->asc_fifo = state->msg_out;\n\t\t\tregs->asc_cmd = ASC_CMD_XFER_INFO;\n\t\t\treadback(regs->asc_cmd);\n\t\t\tgoto done;\n\n\t\tcase SCSI_PHASE_STATUS:\n\t\t\t/* probably an error in the SCSI command */\n\t\t\tasc->script = &asc_scripts[SCRIPT_GET_STATUS];\n\t\t\tregs->asc_cmd = ASC_CMD_I_COMPLETE;\n\t\t\treadback(regs->asc_cmd);\n\t\t\tgoto done;\n\n\t\tcase SCSI_PHASE_COMMAND:\n\t\t\t/*\n\t\t\t * This seems to occur after the command is sent\n\t\t\t * following sync negotiation.  The device still\n\t\t\t * wants more command data.  The fifo appears to\n\t\t\t * to still have the unsent data - but the 53C94\n\t\t\t * signaled TC.  If the fifo still contains data,\n\t\t\t * transfer it, otherwise do a transfer pad.  The\n\t\t\t * target should then continue through the rest of\n\t\t\t * the phases and complete normally.\n\t\t\t */\n\t\t\tprintf(\"asc_intr: tgt %d command phase TC zero\",\n\t\t\t    asc->target);\n\t\t\tif ((regs->asc_flags & ASC_FLAGS_FIFO_CNT) != 0) {\n\t\t\t\tprintf(\" with non-empty fifo %d\\n\",\n\t\t\t\t    regs->asc_flags & ASC_FLAGS_FIFO_CNT);\n\t\t\t\tregs->asc_cmd = ASC_CMD_XFER_INFO;\n\t\t\t} else {\n\t\t\t\tprintf(\"; padding command\\n\");\n\t\t\t\tASC_TC_PUT(regs, 0xff);\n\t\t\t\tregs->asc_cmd = ASC_CMD_XFER_PAD | ASC_CMD_DMA;\n\t\t\t}\n\t\t\tgoto done;\n\n\t\tdefault:\n\t\t\tprintf(\"asc_intr: target %d, unknown phase 0x%x\\n\", \n\t\t\t  \tasc->target, status);\n\t\t\tgoto abort;\n\t\t}\n\n\t\tif (state->script) {\n\t\t\tprintf(\"asc_intr: target %d, incomplete script %p\\n\", \n\t\t\t  \tasc->target, state->script);\n\t\t\tgoto abort;\n\t\t}\n\n\t\t/* check for DMA in progress */\n\t\tASC_TC_GET(regs, len);\n\t\tfifo = regs->asc_flags & ASC_FLAGS_FIFO_CNT;\n\t\t/* flush any data in the FIFO */\n\t\tif (fifo) {\n\t\t\tif (state->flags & DMA_OUT) {\n#ifdef ASC_DIAGNOSTIC\n\t \t\t\tprintf(\"asc: DMA_OUT, fifo resid %d, len %d, flags 0x%x\\n\",\n\t\t\t\t    fifo, len, state->flags);\n#endif /* ASC_DIAGNOSTIC */\n\t\t\t\tlen += fifo;\n\t\t\t} else if (state->flags & DMA_IN) {\n#ifdef ASC_DIAGNOSTIC\n\t\t\t\tprintf(\"asc_intr: IN: dmalen %d len %d fifo %d\\n\",\n\t\t\t\t\tstate->dmalen, len, fifo); /* XXX */\n#endif /* ASC_DIAGNOSTIC */\n\t\t\t} else\n\t\t\t\tprintf(\"asc_intr: dmalen %d len %d fifo %d\\n\",\n\t\t\t\t\tstate->dmalen, len, fifo); /* XXX */\n\t\t\tregs->asc_cmd = ASC_CMD_FLUSH;\n\t\t\ttc_mb();\n\t\t\treadback(regs->asc_cmd);\n\t\t\tDELAY(2);\n\t\t}\n\t\tif (len && (state->flags & DMA_IN_PROGRESS)) {\n\t\t\t/* save number of bytes still to be sent or received */\n\t\t\tstate->dmaresid = len;\n\t\t\tstate->flags &= ~DMA_IN_PROGRESS;\n\t\t\tASC_TC_PUT(regs, 0);\n#ifdef DEBUG\n\t\t\tif (asc_logp == asc_log)\n\t\t\t\tasc_log[NLOG - 1].resid = len;\n\t\t\telse\n\t\t\t\tasc_logp[-1].resid = len;\n#endif\n\t\t\t/* setup state to resume to */\n\t\t\tif (state->flags & DMA_IN) {\n\t\t\t\t/*\n\t\t\t\t * Since the ASC_CNFG3_SRB bit of the\n\t\t\t\t * cnfg3 register bit is not set,\n\t\t\t\t * we just transferred an extra byte.\n\t\t\t\t * Since we can't resume on an odd byte\n\t\t\t\t * boundary, we copy the valid data out\n\t\t\t\t * and resume DMA at the start address.\n\t\t\t\t */\n\t\t\t\tif (len & 1) {\n\t\t\t\t\tprintf(\"asc_intr: msg in len %d (fifo %d)\\n\",\n\t\t\t\t\t\tlen, fifo); /* XXX */\n\t\t\t\t\tlen = state->dmalen - len;\n\t\t\t\t\tgoto do_in;\n\t\t\t\t}\n\t\t\t\tstate->script =\n\t\t\t\t\t&asc_scripts[SCRIPT_RESUME_DMA_IN];\n\t\t\t\tstate->flags |= DMA_RESUME;\n\t\t\t} else if (state->flags & DMA_OUT) {\n\t\t\t\tstate->script =\n\t\t\t\t\t&asc_scripts[SCRIPT_RESUME_DMA_OUT];\n\t\t\t\tstate->flags |= DMA_RESUME;\n\t\t\t} else\n\t\t\t\tstate->script = asc->script;\n\t\t} else if (state->flags & DMA_IN) {\n#ifdef ASC_DIAGNOSTIC\n\t\t\tif (len) {\n\t\t\t\tprintf(\"asc_intr: 1: len %d (fifo %d)\\n\",\n\t\t\t\t\tlen, fifo); /* XXX */\n\t\t\t}\n#endif\n\t\t\t/* setup state to resume to */\n\t\t\tif (state->flags & DMA_IN_PROGRESS) {\n\t\t\t\tlen = state->dmalen;\n\t\t\t\tstate->flags &= ~DMA_IN_PROGRESS;\n\t\t\tdo_in:\n\t\t\t\tstate->dmalen = len;\t/* dma_end needs actual length */\n\t\t\t\t(*asc->dma_end)(asc, state, ASCDMA_READ);\n\t\t\t\tstate->buf += len;\n\t\t\t\tstate->buflen -= len;\n\t\t\t}\n\t\t\tif (state->buflen)\n\t\t\t\tstate->script = (state->flags & DMA_RESUME) ?\n\t\t\t\t    &asc_scripts[SCRIPT_RESUME_DMA_IN] :\n\t\t\t\t    &asc_scripts[SCRIPT_RESUME_IN];\n\t\t\telse\n\t\t\t\tstate->script =\n\t\t\t\t    &asc_scripts[SCRIPT_RESUME_NO_DATA];\n\t\t} else if (state->flags & DMA_OUT) {\n\t\t\tif (len) {\n#ifdef DEBUG\n\t\t\t\tprintf(\"asc_intr: 2: len %d (fifo %d)\\n\", len,\n\t\t\t\t\tfifo); /* XXX */\n#endif\n\t\t\t}\n\t\t\t/*\n\t\t\t * If this is the last chunk, the next expected\n\t\t\t * state is to get status.\n\t\t\t */\n\t\t\tif (state->flags & DMA_IN_PROGRESS) {\n\t\t\t\tstate->flags &= ~DMA_IN_PROGRESS;\n\t\t\t\t(*asc->dma_end)(asc, state, ASCDMA_WRITE);\n\t\t\t\tlen = state->dmalen;\n\t\t\t\tstate->buf += len;\n\t\t\t\tstate->buflen -= len;\n\t\t\t}\n\t\t\tif (state->buflen)\n\t\t\t\tstate->script = (state->flags & DMA_RESUME) ?\n\t\t\t\t    &asc_scripts[SCRIPT_RESUME_DMA_OUT] :\n\t\t\t\t    &asc_scripts[SCRIPT_RESUME_OUT];\n\t\t\telse\n\t\t\t\tstate->script =\n\t\t\t\t    &asc_scripts[SCRIPT_RESUME_NO_DATA];\n\t\t} else if (asc->script == &asc_scripts[SCRIPT_SIMPLE])\n\t\t\tstate->script = &asc_scripts[SCRIPT_RESUME_NO_DATA];\n\t\telse\n\t\t\tstate->script = asc->script;\n\n\t\t/* setup to receive a message */\n\t\tasc->script = &asc_scripts[SCRIPT_MSG_IN];\n\t\tstate->msglen = 0;\n\t\tregs->asc_cmd = ASC_CMD_XFER_INFO;\n\t\treadback(regs->asc_cmd);\n\t\tgoto done;\n\t}\n\n\t/* check for SCSI bus reset */\n\tif (ir & ASC_INT_RESET) {\n\t\tregister int i;\n\n\t\tprintf(\"%s: SCSI bus reset!!\\n\", asc->sc_dev.dv_xname);\n\t\t/* need to flush any pending commands */\n\t\tfor (i = 0; i < ASC_NCMD; i++) {\n\t\t\tif (!asc->cmd[i])\n\t\t\t\tcontinue;\n\t\t\tasc->st[i].error = EIO;\n\t\t\tasc_end(asc, 0, 0, 0);\n\t\t}\n\t\t/* rearbitrate synchronous offset */\n\t\tfor (i = 0; i < ASC_NCMD; i++) {\n\t\t\tasc->st[i].sync_offset = 0;\n\t\t\tasc->st[i].flags = 0;\n\t\t}\n\t\tasc->target = -1;\n\t\treturn 0 ; /* XXX ??? */\n\t}\n\n\t/* check for disconnect */\n\tif (ir & ASC_INT_DISC) {\n\t\tstate = &asc->st[asc->target];\n\t\tswitch (asc->script - asc_scripts) {\n\t\tcase SCRIPT_DONE:\n\t\tcase SCRIPT_DISCONNECT:\n\t\t\t/*\n\t\t\t * Disconnects can happen normally when the\n\t\t\t * command is complete with the phase being\n\t\t\t * either SCSI_PHASE_DATAO or SCSI_PHASE_MSG_IN.\n\t\t\t * The SCRIPT_MATCH() only checks for one phase\n\t\t\t * so we can wind up here.\n\t\t\t * Perform the appropriate operation, then proceed.\n\t\t\t */\n\t\t\tif ((*scpt->action)(asc, status, ss, ir)) {\n\t\t\t\tregs->asc_cmd = scpt->command;\n\t\t\t\treadback(regs->asc_cmd);\n\t\t\t\tasc->script = scpt->next;\n\t\t\t}\n\t\t\tgoto done;\n\n\t\tcase SCRIPT_TRY_SYNC:\n\t\tcase SCRIPT_SIMPLE:\n\t\tcase SCRIPT_DATA_IN:\n\t\tcase SCRIPT_DATA_OUT: /* one of the starting scripts */\n\t\t\tif (ASC_SS(ss) == 0) {\n\t\t\t\t/* device did not respond */\n\t\t\t\tif (regs->asc_flags & ASC_FLAGS_FIFO_CNT) {\n\t\t\t\t\tregs->asc_cmd = ASC_CMD_FLUSH;\n\t\t\t\t\treadback(regs->asc_cmd);\n\t\t\t\t}\n\t\t\t\tstate->error = ENXIO;\n\t\t\t\tasc_end(asc, status, ss, ir);\n\t\t\t\treturn 0 ; /* XXX ??? */\n\t\t\t}\n\t\t\t/* FALLTHROUGH */\n\n\t\tdefault:\n\t\t\tprintf(\"%s: SCSI device %d: unexpected disconnect\\n\",\n\t\t\t\tasc->sc_dev.dv_xname, asc->target);\n#ifdef DEBUG\n\t\t\tasc_DumpLog(\"asc_disc\");\n#endif\n\t\t\t/*\n\t\t\t * On rare occasions my RZ24 does a disconnect during\n\t\t\t * data in phase and the following seems to keep it\n\t\t\t * happy.\n\t\t\t * XXX Should a scsi disk ever do this??\n\t\t\t */\n\t\t\tasc->script = &asc_scripts[SCRIPT_RESEL];\n\t\t\tasc->state = ASC_STATE_RESEL;\n\t\t\tstate->flags |= DISCONN;\n\t\t\tregs->asc_cmd = ASC_CMD_ENABLE_SEL;\n\t\t\treadback(regs->asc_cmd);\n\t\t\treturn 0 ; /* XXX ??? */\n\t\t}\n\t}\n\n\t/* mhitch - debug - check select/reselect collision */\n\tif ((ir & ASC_INT_ILL) && (regs->asc_cmd & ASC_CMD_SEL_ATN)) {\n\t\tprintf(\"asc_intr: Illegal command status %x ir %x\\n\",\n\t\t    status, ir);\n\t\t/* Should process reselect? */\n\t}\n\n\t/* check for illegal command */\n\tif (ir & ASC_INT_ILL) {\n#ifdef ASC_DIAGNOSTIC\n\t\tprintf(\"asc_intr: Illegal command status %x ir %x cmd %x ? %x\\n\",\n\t\t    status, ir, regs->asc_cmd, asc_scripts[SCRIPT_MSG_IN].command);\n#endif\n\t\t/*\n\t\t * On a 5000/200, I see this frequently when using an RD52\n\t\t * CDROM.  The 53c94 doesn't seem to get the Message Accept\n\t\t * command, and generates an \"Illegal Command\" interrupt.\n\t\t * Re-issuing the Message Accept at this point seems to keep\n\t\t * things going.  Don't allow this too many times in a row,\n\t\t * just to make sure we don't get hung up.  mhitch\n\t\t */\n\t\tif (ill_cmd_count++ != 3) {\t\t\t/* XXX */\n\t\t\tregs->asc_cmd = ASC_CMD_MSG_ACPT;\t/* XXX */\n\t\t\treadback(regs->asc_cmd);\t\t/* XXX */\n\t\t\tgoto done;\t\t\t\t/* XXX */\n\t\t}\t\t\t\t\t\t/* XXX */\n\t\tprintf(\"asc_intr: Illegal command tgt %d\\n\", asc->target);\n\t\tgoto abort;\t/* XXX */\n\t}\n\till_cmd_count = 0;\t\t\t\t\t/* XXX */\n\n\t/* check for reselect */\n\tif (ir & ASC_INT_RESEL) {\n\t\tunsigned fifo, id, msg;\n\n\t\tfifo = regs->asc_flags & ASC_FLAGS_FIFO_CNT;\n\t\tif (fifo < 2) {\n\t\t\tprintf(\"asc_intr: target %d, reselect, fifo %d too small for msg\\n\", \n\t\t\t  \tasc->target, fifo);\n\n\t\t\tgoto abort;\n\t\t}\n\t\t/* read unencoded SCSI ID and convert to binary */\n\t\tmsg = regs->asc_fifo & asc->myidmask;\n\t\tfor (id = 0; (msg & 1) == 0; id++)\n\t\t\tmsg >>= 1;\n\t\t/* read identify message */\n\t\tmsg = regs->asc_fifo;\n#ifdef DEBUG\n\t\tif (asc_logp == asc_log)\n\t\t\tasc_log[NLOG - 1].msg = msg;\n\t\telse\n\t\t\tasc_logp[-1].msg = msg;\n#endif\n\t\t/*\n\t\t * TC may have been initialized during a selection attempt.\n\t\t * Clear it to prevent possible confusion later.\n\t\t */\n\t\tASC_TC_PUT(regs,0);\t/* ensure TC clear */\n\t\tasc->state = ASC_STATE_BUSY;\n\t\tasc->target = id;\n\t\tstate = &asc->st[id];\n\t\tasc->script = state->script;\n\t\tstate->script = (script_t *)0;\n\t\tif (!(state->flags & DISCONN)) {\n\t\t\tprintf(\"asc_intr: reselect tgt %d, flags 0x%x not disconnected\\n\",\n\t\t\t       asc->target, state->flags);\n\t\t\tgoto abort;\n\t\t}\n\t\tstate->flags &= ~DISCONN;\n\t\tregs->asc_syn_p = state->sync_period;\n\t\tregs->asc_syn_o = state->sync_offset;\n\t\tregs->asc_cmd = ASC_CMD_MSG_ACPT;\n\t\treadback(regs->asc_cmd);\n\t\tgoto done;\n\t}\n\n\t/* check if we are being selected as a target */\n\tif (ir & (ASC_INT_SEL | ASC_INT_SEL_ATN)) {\n\t\t\tprintf(\"asc_intr: host adaptor selected as target\\n\");\n\t\tgoto abort;\n\t}\n\t/*\n\t * 'ir' must be just ASC_INT_FC.\n\t * This is normal if canceling an ASC_ENABLE_SEL.\n\t */\n\ndone:\n\ttc_mb();\n\t/* watch out for HW race conditions and setup & hold time violations */\n\tir = regs->asc_status;\n\twhile (ir != (status = regs->asc_status))\n\t\tir = status;\n\tif (status & ASC_CSR_INT)\n\t\tgoto again;\n\treturn 0 ; /* XXX ??? */\n\nabort:\n#ifdef DEBUG\n\tasc_DumpLog(\"asc_intr\");\n#endif\n#if 0\n\tpanic(\"asc_intr\");\n#else\n\tboot(RB_NOSYNC); /* XXX */\n#endif\n}",
          "includes": [
            "#include <dev/tc/ascvar.h>",
            "#include <pmax/pmax/kmin.h>",
            "#include <pmax/pmax/asic.h>",
            "#include <pmax/dev/ascreg.h>",
            "#include <pmax/dev/scsi.h>",
            "#include <pmax/dev/device.h>",
            "#include <machine/bus.h>",
            "#include <machine/autoconf.h>",
            "#include <machine/cpu.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/tc/ioasicvar.h>",
            "#include <dev/tc/tcvar.h>",
            "#include <sys/reboot.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/errno.h>",
            "#include <sys/conf.h>",
            "#include <sys/buf.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <asc.h>"
          ],
          "macros_used": [
            "#define\tSCRIPT_RESUME_NO_DATA\t21",
            "#define\tSCRIPT_RESUME_DMA_OUT\t20",
            "#define\tSCRIPT_RESUME_OUT\t19",
            "#define\tSCRIPT_RESUME_DMA_IN\t18",
            "#define\tSCRIPT_RESUME_IN\t17",
            "#define\tSCRIPT_RESEL\t\t16",
            "#define\tSCRIPT_DISCONNECT\t15",
            "#define\tSCRIPT_TRY_SYNC\t\t12",
            "#define\tSCRIPT_MSG_IN\t\t9",
            "#define\tSCRIPT_DONE\t\t8",
            "#define\tSCRIPT_GET_STATUS\t7",
            "#define\tSCRIPT_SIMPLE\t\t6",
            "#define\tSCRIPT_DATA_OUT\t\t3",
            "#define\tSCRIPT_CONTINUE_IN\t2",
            "#define\tSCRIPT_DATA_IN\t\t0",
            "#define NLOG 32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/tc/ascvar.h>\n#include <pmax/pmax/kmin.h>\n#include <pmax/pmax/asic.h>\n#include <pmax/dev/ascreg.h>\n#include <pmax/dev/scsi.h>\n#include <pmax/dev/device.h>\n#include <machine/bus.h>\n#include <machine/autoconf.h>\n#include <machine/cpu.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/tc/ioasicvar.h>\n#include <dev/tc/tcvar.h>\n#include <sys/reboot.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/errno.h>\n#include <sys/conf.h>\n#include <sys/buf.h>\n#include <sys/dkstat.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <asc.h>\n\n#define\tSCRIPT_RESUME_NO_DATA\t21\n#define\tSCRIPT_RESUME_DMA_OUT\t20\n#define\tSCRIPT_RESUME_OUT\t19\n#define\tSCRIPT_RESUME_DMA_IN\t18\n#define\tSCRIPT_RESUME_IN\t17\n#define\tSCRIPT_RESEL\t\t16\n#define\tSCRIPT_DISCONNECT\t15\n#define\tSCRIPT_TRY_SYNC\t\t12\n#define\tSCRIPT_MSG_IN\t\t9\n#define\tSCRIPT_DONE\t\t8\n#define\tSCRIPT_GET_STATUS\t7\n#define\tSCRIPT_SIMPLE\t\t6\n#define\tSCRIPT_DATA_OUT\t\t3\n#define\tSCRIPT_CONTINUE_IN\t2\n#define\tSCRIPT_DATA_IN\t\t0\n#define NLOG 32\n\nint\nasc_intr(sc)\n\tvoid *sc;\n{\n\tregister asc_softc_t asc = (asc_softc_t) sc;\n\tregister asc_regmap_t *regs = asc->regs;\n\tregister State *state;\n\tregister script_t *scpt;\n\tregister int ss, ir, status;\n\tregister unsigned char cmd_was;\n\tstatic int ill_cmd_count = 0;\t\t\t/* XXX */\n\n\t/* collect ephemeral information */\n\tstatus = regs->asc_status;\nagain:\n\tss = regs->asc_ss;\n\tcmd_was = regs->asc_cmd;\n\n\t/* drop spurious interrupts */\n\tif ((status & ASC_CSR_INT) == 0)\n\t\treturn (-1);\t\t/* XXX */\n\n\tir = regs->asc_intr;\t/* this resets the previous two: i.e.,*/\n\t\t\t\t/* this re-latches CSR (and SSTEP) */\n\tscpt = asc->script;\n\n\n#ifdef DEBUG\n\tasc_logp->status = PACK(asc->sc_dev.dv_unit, status, ss, ir);\n\tasc_logp->target = (asc->state == ASC_STATE_BUSY) ? asc->target : -1;\n\tasc_logp->state = scpt - asc_scripts;\n\tasc_logp->msg = cmd_was;\n\tasc_logp->resid = 0;\n\tif (++asc_logp >= &asc_log[NLOG])\n\t\tasc_logp = asc_log;\n\tif (asc_debug > 2)\n\t\tprintf(\"asc_intr: status %x ss %x ir %x cond %d:%x\\n\",\n\t\t\tstatus, ss, ir, scpt - asc_scripts, scpt->condition);\n#endif\n\n\t/* This must be done withing 250msec of disconnect */\n\tif (ir & ASC_INT_DISC) {\n\t\tregs->asc_cmd = ASC_CMD_ENABLE_SEL;\n\t\treadback(regs->asc_cmd);\n\t}\n\n\t/* check the expected state */\n\tif (SCRIPT_MATCH(ir, status) == scpt->condition) {\n\t\t/*\n\t\t * Perform the appropriate operation, then proceed.\n\t\t */\n\t\tif ((*scpt->action)(asc, status, ss, ir)) {\n\t\t\tregs->asc_cmd = scpt->command;\n\t\t\treadback(regs->asc_cmd);\n\t\t\tasc->script = scpt->next;\n\t\t}\n\t\tgoto done;\n\t}\n\n\t/*\n\t * Check for parity error.\n\t * Hardware will automatically set ATN\n\t * to request the device for a MSG_OUT phase.\n\t */\n\tif (status & ASC_CSR_PE) {\n\t\tprintf(\"%s: SCSI device %d: incomming parity error seen\\n\",\n\t\t\tasc->sc_dev.dv_xname, asc->target);\n\t\tasc->st[asc->target].flags |= PARITY_ERR;\n\t}\n\n\t/*\n\t * Check for gross error.\n\t * Probably a bug in a device driver.\n\t */\n\tif (status & ASC_CSR_GE) {\n\t\tprintf(\"%s: SCSI device %d: gross error\\n\",\n\t\t\tasc->sc_dev.dv_xname, asc->target);\n\t\tgoto abort;\n\t}\n\n\t/* check for message in or out */\n\tif ((ir & ~ASC_INT_FC) == ASC_INT_BS) {\n\t\tregister int len, fifo;\n\n\t\tstate = &asc->st[asc->target];\n\t\tswitch (ASC_PHASE(status)) {\n\t\tcase SCSI_PHASE_DATAI:\n\t\t\tif ((asc->script - asc_scripts) == SCRIPT_DATA_IN + 1 ||\n\t\t\t    (asc->script - asc_scripts) == SCRIPT_CONTINUE_IN) {\n\t\t\t    \t/*\n\t\t\t    \t * From the Mach driver:\n\t\t\t    \t * After a reconnect and restart dma in, we\n\t\t\t    \t * seem to have gotten an interrupt even though\n\t\t\t    \t * the DMA is running.  The Mach driver just\n\t\t\t    \t * ignores this interrupt.\n\t\t\t    \t */\n\t\t\t\tASC_TC_GET(regs, len);\n\t\t\t\tfifo = regs->asc_flags & ASC_FLAGS_FIFO_CNT;\n\t\t\t    \tprintf(\"asc_intr: ignoring strange interrupt\");\n\t\t\t    \tprintf(\" tc %d fifo residue %d\\n\", len, fifo);\n\t\t\t    \tgoto done;\n\t\t\t}\n\t\t\t/* FALLTHROUGH */\n\t\tcase SCSI_PHASE_DATAO:\n\t\t\tASC_TC_GET(regs, len);\n\t\t\tfifo = regs->asc_flags & ASC_FLAGS_FIFO_CNT;\n\t\t\tprintf(\"asc_intr: data overrun: buflen %d dmalen %d tc %d fifo %d\\n\",\n\t\t\t\tstate->buflen, state->dmalen, len, fifo);\n\t\t\tgoto abort;\n\n\t\tcase SCSI_PHASE_MSG_IN:\n\t\t\tbreak;\n\n\t\tcase SCSI_PHASE_MSG_OUT:\n\t\t\t/*\n\t\t\t * Check for parity error.\n\t\t\t * Hardware will automatically set ATN\n\t\t\t * to request the device for a MSG_OUT phase.\n\t\t\t */\n\t\t\tif (state->flags & PARITY_ERR) {\n\t\t\t\tstate->flags &= ~PARITY_ERR;\n\t\t\t\tstate->msg_out = SCSI_MESSAGE_PARITY_ERROR;\n\t\t\t\t/* reset message in counter */\n\t\t\t\tstate->msglen = 0;\n\t\t\t} else\n\t\t\t\tstate->msg_out = SCSI_NO_OP;\n\t\t\tregs->asc_fifo = state->msg_out;\n\t\t\tregs->asc_cmd = ASC_CMD_XFER_INFO;\n\t\t\treadback(regs->asc_cmd);\n\t\t\tgoto done;\n\n\t\tcase SCSI_PHASE_STATUS:\n\t\t\t/* probably an error in the SCSI command */\n\t\t\tasc->script = &asc_scripts[SCRIPT_GET_STATUS];\n\t\t\tregs->asc_cmd = ASC_CMD_I_COMPLETE;\n\t\t\treadback(regs->asc_cmd);\n\t\t\tgoto done;\n\n\t\tcase SCSI_PHASE_COMMAND:\n\t\t\t/*\n\t\t\t * This seems to occur after the command is sent\n\t\t\t * following sync negotiation.  The device still\n\t\t\t * wants more command data.  The fifo appears to\n\t\t\t * to still have the unsent data - but the 53C94\n\t\t\t * signaled TC.  If the fifo still contains data,\n\t\t\t * transfer it, otherwise do a transfer pad.  The\n\t\t\t * target should then continue through the rest of\n\t\t\t * the phases and complete normally.\n\t\t\t */\n\t\t\tprintf(\"asc_intr: tgt %d command phase TC zero\",\n\t\t\t    asc->target);\n\t\t\tif ((regs->asc_flags & ASC_FLAGS_FIFO_CNT) != 0) {\n\t\t\t\tprintf(\" with non-empty fifo %d\\n\",\n\t\t\t\t    regs->asc_flags & ASC_FLAGS_FIFO_CNT);\n\t\t\t\tregs->asc_cmd = ASC_CMD_XFER_INFO;\n\t\t\t} else {\n\t\t\t\tprintf(\"; padding command\\n\");\n\t\t\t\tASC_TC_PUT(regs, 0xff);\n\t\t\t\tregs->asc_cmd = ASC_CMD_XFER_PAD | ASC_CMD_DMA;\n\t\t\t}\n\t\t\tgoto done;\n\n\t\tdefault:\n\t\t\tprintf(\"asc_intr: target %d, unknown phase 0x%x\\n\", \n\t\t\t  \tasc->target, status);\n\t\t\tgoto abort;\n\t\t}\n\n\t\tif (state->script) {\n\t\t\tprintf(\"asc_intr: target %d, incomplete script %p\\n\", \n\t\t\t  \tasc->target, state->script);\n\t\t\tgoto abort;\n\t\t}\n\n\t\t/* check for DMA in progress */\n\t\tASC_TC_GET(regs, len);\n\t\tfifo = regs->asc_flags & ASC_FLAGS_FIFO_CNT;\n\t\t/* flush any data in the FIFO */\n\t\tif (fifo) {\n\t\t\tif (state->flags & DMA_OUT) {\n#ifdef ASC_DIAGNOSTIC\n\t \t\t\tprintf(\"asc: DMA_OUT, fifo resid %d, len %d, flags 0x%x\\n\",\n\t\t\t\t    fifo, len, state->flags);\n#endif /* ASC_DIAGNOSTIC */\n\t\t\t\tlen += fifo;\n\t\t\t} else if (state->flags & DMA_IN) {\n#ifdef ASC_DIAGNOSTIC\n\t\t\t\tprintf(\"asc_intr: IN: dmalen %d len %d fifo %d\\n\",\n\t\t\t\t\tstate->dmalen, len, fifo); /* XXX */\n#endif /* ASC_DIAGNOSTIC */\n\t\t\t} else\n\t\t\t\tprintf(\"asc_intr: dmalen %d len %d fifo %d\\n\",\n\t\t\t\t\tstate->dmalen, len, fifo); /* XXX */\n\t\t\tregs->asc_cmd = ASC_CMD_FLUSH;\n\t\t\ttc_mb();\n\t\t\treadback(regs->asc_cmd);\n\t\t\tDELAY(2);\n\t\t}\n\t\tif (len && (state->flags & DMA_IN_PROGRESS)) {\n\t\t\t/* save number of bytes still to be sent or received */\n\t\t\tstate->dmaresid = len;\n\t\t\tstate->flags &= ~DMA_IN_PROGRESS;\n\t\t\tASC_TC_PUT(regs, 0);\n#ifdef DEBUG\n\t\t\tif (asc_logp == asc_log)\n\t\t\t\tasc_log[NLOG - 1].resid = len;\n\t\t\telse\n\t\t\t\tasc_logp[-1].resid = len;\n#endif\n\t\t\t/* setup state to resume to */\n\t\t\tif (state->flags & DMA_IN) {\n\t\t\t\t/*\n\t\t\t\t * Since the ASC_CNFG3_SRB bit of the\n\t\t\t\t * cnfg3 register bit is not set,\n\t\t\t\t * we just transferred an extra byte.\n\t\t\t\t * Since we can't resume on an odd byte\n\t\t\t\t * boundary, we copy the valid data out\n\t\t\t\t * and resume DMA at the start address.\n\t\t\t\t */\n\t\t\t\tif (len & 1) {\n\t\t\t\t\tprintf(\"asc_intr: msg in len %d (fifo %d)\\n\",\n\t\t\t\t\t\tlen, fifo); /* XXX */\n\t\t\t\t\tlen = state->dmalen - len;\n\t\t\t\t\tgoto do_in;\n\t\t\t\t}\n\t\t\t\tstate->script =\n\t\t\t\t\t&asc_scripts[SCRIPT_RESUME_DMA_IN];\n\t\t\t\tstate->flags |= DMA_RESUME;\n\t\t\t} else if (state->flags & DMA_OUT) {\n\t\t\t\tstate->script =\n\t\t\t\t\t&asc_scripts[SCRIPT_RESUME_DMA_OUT];\n\t\t\t\tstate->flags |= DMA_RESUME;\n\t\t\t} else\n\t\t\t\tstate->script = asc->script;\n\t\t} else if (state->flags & DMA_IN) {\n#ifdef ASC_DIAGNOSTIC\n\t\t\tif (len) {\n\t\t\t\tprintf(\"asc_intr: 1: len %d (fifo %d)\\n\",\n\t\t\t\t\tlen, fifo); /* XXX */\n\t\t\t}\n#endif\n\t\t\t/* setup state to resume to */\n\t\t\tif (state->flags & DMA_IN_PROGRESS) {\n\t\t\t\tlen = state->dmalen;\n\t\t\t\tstate->flags &= ~DMA_IN_PROGRESS;\n\t\t\tdo_in:\n\t\t\t\tstate->dmalen = len;\t/* dma_end needs actual length */\n\t\t\t\t(*asc->dma_end)(asc, state, ASCDMA_READ);\n\t\t\t\tstate->buf += len;\n\t\t\t\tstate->buflen -= len;\n\t\t\t}\n\t\t\tif (state->buflen)\n\t\t\t\tstate->script = (state->flags & DMA_RESUME) ?\n\t\t\t\t    &asc_scripts[SCRIPT_RESUME_DMA_IN] :\n\t\t\t\t    &asc_scripts[SCRIPT_RESUME_IN];\n\t\t\telse\n\t\t\t\tstate->script =\n\t\t\t\t    &asc_scripts[SCRIPT_RESUME_NO_DATA];\n\t\t} else if (state->flags & DMA_OUT) {\n\t\t\tif (len) {\n#ifdef DEBUG\n\t\t\t\tprintf(\"asc_intr: 2: len %d (fifo %d)\\n\", len,\n\t\t\t\t\tfifo); /* XXX */\n#endif\n\t\t\t}\n\t\t\t/*\n\t\t\t * If this is the last chunk, the next expected\n\t\t\t * state is to get status.\n\t\t\t */\n\t\t\tif (state->flags & DMA_IN_PROGRESS) {\n\t\t\t\tstate->flags &= ~DMA_IN_PROGRESS;\n\t\t\t\t(*asc->dma_end)(asc, state, ASCDMA_WRITE);\n\t\t\t\tlen = state->dmalen;\n\t\t\t\tstate->buf += len;\n\t\t\t\tstate->buflen -= len;\n\t\t\t}\n\t\t\tif (state->buflen)\n\t\t\t\tstate->script = (state->flags & DMA_RESUME) ?\n\t\t\t\t    &asc_scripts[SCRIPT_RESUME_DMA_OUT] :\n\t\t\t\t    &asc_scripts[SCRIPT_RESUME_OUT];\n\t\t\telse\n\t\t\t\tstate->script =\n\t\t\t\t    &asc_scripts[SCRIPT_RESUME_NO_DATA];\n\t\t} else if (asc->script == &asc_scripts[SCRIPT_SIMPLE])\n\t\t\tstate->script = &asc_scripts[SCRIPT_RESUME_NO_DATA];\n\t\telse\n\t\t\tstate->script = asc->script;\n\n\t\t/* setup to receive a message */\n\t\tasc->script = &asc_scripts[SCRIPT_MSG_IN];\n\t\tstate->msglen = 0;\n\t\tregs->asc_cmd = ASC_CMD_XFER_INFO;\n\t\treadback(regs->asc_cmd);\n\t\tgoto done;\n\t}\n\n\t/* check for SCSI bus reset */\n\tif (ir & ASC_INT_RESET) {\n\t\tregister int i;\n\n\t\tprintf(\"%s: SCSI bus reset!!\\n\", asc->sc_dev.dv_xname);\n\t\t/* need to flush any pending commands */\n\t\tfor (i = 0; i < ASC_NCMD; i++) {\n\t\t\tif (!asc->cmd[i])\n\t\t\t\tcontinue;\n\t\t\tasc->st[i].error = EIO;\n\t\t\tasc_end(asc, 0, 0, 0);\n\t\t}\n\t\t/* rearbitrate synchronous offset */\n\t\tfor (i = 0; i < ASC_NCMD; i++) {\n\t\t\tasc->st[i].sync_offset = 0;\n\t\t\tasc->st[i].flags = 0;\n\t\t}\n\t\tasc->target = -1;\n\t\treturn 0 ; /* XXX ??? */\n\t}\n\n\t/* check for disconnect */\n\tif (ir & ASC_INT_DISC) {\n\t\tstate = &asc->st[asc->target];\n\t\tswitch (asc->script - asc_scripts) {\n\t\tcase SCRIPT_DONE:\n\t\tcase SCRIPT_DISCONNECT:\n\t\t\t/*\n\t\t\t * Disconnects can happen normally when the\n\t\t\t * command is complete with the phase being\n\t\t\t * either SCSI_PHASE_DATAO or SCSI_PHASE_MSG_IN.\n\t\t\t * The SCRIPT_MATCH() only checks for one phase\n\t\t\t * so we can wind up here.\n\t\t\t * Perform the appropriate operation, then proceed.\n\t\t\t */\n\t\t\tif ((*scpt->action)(asc, status, ss, ir)) {\n\t\t\t\tregs->asc_cmd = scpt->command;\n\t\t\t\treadback(regs->asc_cmd);\n\t\t\t\tasc->script = scpt->next;\n\t\t\t}\n\t\t\tgoto done;\n\n\t\tcase SCRIPT_TRY_SYNC:\n\t\tcase SCRIPT_SIMPLE:\n\t\tcase SCRIPT_DATA_IN:\n\t\tcase SCRIPT_DATA_OUT: /* one of the starting scripts */\n\t\t\tif (ASC_SS(ss) == 0) {\n\t\t\t\t/* device did not respond */\n\t\t\t\tif (regs->asc_flags & ASC_FLAGS_FIFO_CNT) {\n\t\t\t\t\tregs->asc_cmd = ASC_CMD_FLUSH;\n\t\t\t\t\treadback(regs->asc_cmd);\n\t\t\t\t}\n\t\t\t\tstate->error = ENXIO;\n\t\t\t\tasc_end(asc, status, ss, ir);\n\t\t\t\treturn 0 ; /* XXX ??? */\n\t\t\t}\n\t\t\t/* FALLTHROUGH */\n\n\t\tdefault:\n\t\t\tprintf(\"%s: SCSI device %d: unexpected disconnect\\n\",\n\t\t\t\tasc->sc_dev.dv_xname, asc->target);\n#ifdef DEBUG\n\t\t\tasc_DumpLog(\"asc_disc\");\n#endif\n\t\t\t/*\n\t\t\t * On rare occasions my RZ24 does a disconnect during\n\t\t\t * data in phase and the following seems to keep it\n\t\t\t * happy.\n\t\t\t * XXX Should a scsi disk ever do this??\n\t\t\t */\n\t\t\tasc->script = &asc_scripts[SCRIPT_RESEL];\n\t\t\tasc->state = ASC_STATE_RESEL;\n\t\t\tstate->flags |= DISCONN;\n\t\t\tregs->asc_cmd = ASC_CMD_ENABLE_SEL;\n\t\t\treadback(regs->asc_cmd);\n\t\t\treturn 0 ; /* XXX ??? */\n\t\t}\n\t}\n\n\t/* mhitch - debug - check select/reselect collision */\n\tif ((ir & ASC_INT_ILL) && (regs->asc_cmd & ASC_CMD_SEL_ATN)) {\n\t\tprintf(\"asc_intr: Illegal command status %x ir %x\\n\",\n\t\t    status, ir);\n\t\t/* Should process reselect? */\n\t}\n\n\t/* check for illegal command */\n\tif (ir & ASC_INT_ILL) {\n#ifdef ASC_DIAGNOSTIC\n\t\tprintf(\"asc_intr: Illegal command status %x ir %x cmd %x ? %x\\n\",\n\t\t    status, ir, regs->asc_cmd, asc_scripts[SCRIPT_MSG_IN].command);\n#endif\n\t\t/*\n\t\t * On a 5000/200, I see this frequently when using an RD52\n\t\t * CDROM.  The 53c94 doesn't seem to get the Message Accept\n\t\t * command, and generates an \"Illegal Command\" interrupt.\n\t\t * Re-issuing the Message Accept at this point seems to keep\n\t\t * things going.  Don't allow this too many times in a row,\n\t\t * just to make sure we don't get hung up.  mhitch\n\t\t */\n\t\tif (ill_cmd_count++ != 3) {\t\t\t/* XXX */\n\t\t\tregs->asc_cmd = ASC_CMD_MSG_ACPT;\t/* XXX */\n\t\t\treadback(regs->asc_cmd);\t\t/* XXX */\n\t\t\tgoto done;\t\t\t\t/* XXX */\n\t\t}\t\t\t\t\t\t/* XXX */\n\t\tprintf(\"asc_intr: Illegal command tgt %d\\n\", asc->target);\n\t\tgoto abort;\t/* XXX */\n\t}\n\till_cmd_count = 0;\t\t\t\t\t/* XXX */\n\n\t/* check for reselect */\n\tif (ir & ASC_INT_RESEL) {\n\t\tunsigned fifo, id, msg;\n\n\t\tfifo = regs->asc_flags & ASC_FLAGS_FIFO_CNT;\n\t\tif (fifo < 2) {\n\t\t\tprintf(\"asc_intr: target %d, reselect, fifo %d too small for msg\\n\", \n\t\t\t  \tasc->target, fifo);\n\n\t\t\tgoto abort;\n\t\t}\n\t\t/* read unencoded SCSI ID and convert to binary */\n\t\tmsg = regs->asc_fifo & asc->myidmask;\n\t\tfor (id = 0; (msg & 1) == 0; id++)\n\t\t\tmsg >>= 1;\n\t\t/* read identify message */\n\t\tmsg = regs->asc_fifo;\n#ifdef DEBUG\n\t\tif (asc_logp == asc_log)\n\t\t\tasc_log[NLOG - 1].msg = msg;\n\t\telse\n\t\t\tasc_logp[-1].msg = msg;\n#endif\n\t\t/*\n\t\t * TC may have been initialized during a selection attempt.\n\t\t * Clear it to prevent possible confusion later.\n\t\t */\n\t\tASC_TC_PUT(regs,0);\t/* ensure TC clear */\n\t\tasc->state = ASC_STATE_BUSY;\n\t\tasc->target = id;\n\t\tstate = &asc->st[id];\n\t\tasc->script = state->script;\n\t\tstate->script = (script_t *)0;\n\t\tif (!(state->flags & DISCONN)) {\n\t\t\tprintf(\"asc_intr: reselect tgt %d, flags 0x%x not disconnected\\n\",\n\t\t\t       asc->target, state->flags);\n\t\t\tgoto abort;\n\t\t}\n\t\tstate->flags &= ~DISCONN;\n\t\tregs->asc_syn_p = state->sync_period;\n\t\tregs->asc_syn_o = state->sync_offset;\n\t\tregs->asc_cmd = ASC_CMD_MSG_ACPT;\n\t\treadback(regs->asc_cmd);\n\t\tgoto done;\n\t}\n\n\t/* check if we are being selected as a target */\n\tif (ir & (ASC_INT_SEL | ASC_INT_SEL_ATN)) {\n\t\t\tprintf(\"asc_intr: host adaptor selected as target\\n\");\n\t\tgoto abort;\n\t}\n\t/*\n\t * 'ir' must be just ASC_INT_FC.\n\t * This is normal if canceling an ASC_ENABLE_SEL.\n\t */\n\ndone:\n\ttc_mb();\n\t/* watch out for HW race conditions and setup & hold time violations */\n\tir = regs->asc_status;\n\twhile (ir != (status = regs->asc_status))\n\t\tir = status;\n\tif (status & ASC_CSR_INT)\n\t\tgoto again;\n\treturn 0 ; /* XXX ??? */\n\nabort:\n#ifdef DEBUG\n\tasc_DumpLog(\"asc_intr\");\n#endif\n#if 0\n\tpanic(\"asc_intr\");\n#else\n\tboot(RB_NOSYNC); /* XXX */\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/tc/ascvar.h>\n#include <pmax/pmax/kmin.h>\n#include <pmax/pmax/asic.h>\n#include <pmax/dev/ascreg.h>\n#include <pmax/dev/scsi.h>\n#include <pmax/dev/device.h>\n#include <machine/bus.h>\n#include <machine/autoconf.h>\n#include <machine/cpu.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/tc/ioasicvar.h>\n#include <dev/tc/tcvar.h>\n#include <sys/reboot.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/errno.h>\n#include <sys/conf.h>\n#include <sys/buf.h>\n#include <sys/dkstat.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <asc.h>\n\nint\nasc_poll(asc, target)\n\tstruct asc_softc *asc;\n\tint target;\n{\n\tstruct scsi_xfer *scsicmd = asc->cmd[target];\n\tint count = scsicmd->timeout * 10;\n\n\twhile(count) {\n\t\tif(asc->regs->asc_status &ASC_CSR_INT) {\n\t\t\tasc_intr(asc);\n\t\t}\n\t\tif(scsicmd->flags & ITSDONE)\n\t\t\tbreak;\n\t\tDELAY(5);\n\t\tcount--;\n\t}\n\tif(count == 0) {\n\t\tscsicmd->error = XS_TIMEOUT;\n\t\tasc_end(asc, 0, 0, 0);\n\t}\n\treturn COMPLETE;\n}"
  },
  {
    "function_name": "asc_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/tc/asc.c",
    "lines": "563-594",
    "snippet": "void\nasc_start(scsicmd)\n\tregister ScsiCmd *scsicmd;\t/* command to start */\n{\n\tregister struct pmax_scsi_device *sdp = scsicmd->sd;\n\tregister asc_softc_t asc = asc_cd.cd_devs[sdp->sd_ctlr];\n\tint s;\n\n\ts = splbio();\n\t/*\n\t * Check if another command is already in progress.\n\t * We may have to change this if we allow SCSI devices with\n\t * separate LUNs.\n\t */\n\tif (asc->cmd[sdp->sd_drive]) {\n\t\tprintf(\"asc %d: device %s busy at start\\n\",\n\t\t\tsdp->sd_ctlr,\t/*XXX*/\n\t\t\tsdp->sd_driver->d_name);\n\t\t(*sdp->sd_driver->d_done)(scsicmd->unit, EBUSY,\n\t\t\tscsicmd->buflen, 0);\n\t\tsplx(s);\n\t}\n\tasc->cmd[sdp->sd_drive] = scsicmd;\n\t/*\n\t * Kludge: use a 60 second timeout if data is being transfered,\n\t * otherwise use a 30 minute timeout.\n\t */\n\ttimeout(asc_timeout, scsicmd, hz * (scsicmd->buflen == 0 ?\n\t    1800 : 60));\n\tasc_startcmd(asc, sdp->sd_drive);\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/tc/ascvar.h>",
      "#include <pmax/pmax/kmin.h>",
      "#include <pmax/pmax/asic.h>",
      "#include <pmax/dev/ascreg.h>",
      "#include <pmax/dev/scsi.h>",
      "#include <pmax/dev/device.h>",
      "#include <machine/bus.h>",
      "#include <machine/autoconf.h>",
      "#include <machine/cpu.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/tc/ioasicvar.h>",
      "#include <dev/tc/tcvar.h>",
      "#include <sys/reboot.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/errno.h>",
      "#include <sys/conf.h>",
      "#include <sys/buf.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <asc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asc_startcmd",
          "args": [
            "asc",
            "sdp->sd_drive"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "asc_startcmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/tc/asc.c",
          "lines": "660-809",
          "snippet": "static void\nasc_startcmd(asc, target)\n\tasc_softc_t asc;\n\tint target;\n{\n\tregister asc_regmap_t *regs;\n\tregister ScsiCmd *scsicmd;\n\tregister State *state;\n\tint len;\n\n\t/*\n\t * See if another target is currently selected on this SCSI bus.\n\t */\n\tif (asc->target >= 0)\n\t\treturn;\n\n\tregs = asc->regs;\n\n\t/*\n\t * If a reselection is in progress, it is Ok to ignore it since\n\t * the ASC will automatically cancel the command and flush\n\t * the FIFO if the ASC is reselected before the command starts.\n\t * If we try to use ASC_CMD_DISABLE_SEL, we can hang the system if\n\t * a reselect occurs before starting the command.\n\t */\n\n\tasc->state = ASC_STATE_BUSY;\n\tasc->target = target;\n\n\t/* cache some pointers */\n\tscsicmd = asc->cmd[target];\n\tstate = &asc->st[target];\n\n#ifdef DEBUG\n\tif (asc_debug > 1) {\n\t\tprintf(\"asc_startcmd: %s target %d cmd %x len %d\\n\",\n\t\t    scsicmd->sd->sd_driver->d_name, target,\n\t\t    scsicmd->cmd[0], scsicmd->buflen);\n\t}\n#endif\n\n\t/* Try to avoid reselect collisions */\n\tif ((regs->asc_status & (ASC_CSR_INT|SCSI_PHASE_MSG_IN)) ==\n\t    (ASC_CSR_INT|SCSI_PHASE_MSG_IN)) {\n/*\t\tprintf(\"asc_startcmd: possible reselect in progress\\n\"); */\n\t\treturn;\n\t}\n\n\t/*\n\t * Init the chip and target state.\n\t */\n\tstate->flags = state->flags & DID_SYNC;\n\tstate->error = 0;\n\tstate->script = (script_t *)0;\n\tstate->msg_out = SCSI_NO_OP;\n\n\tlen = scsicmd->cmdlen;\n\tstate->dmalen = len;\n\n\t/* check for simple SCSI command with no data transfer */\n\tif ((state->buflen = scsicmd->buflen) == 0) {\n\t\t/* check for sync negotiation */\n\t\tif ((scsicmd->flags & SCSICMD_USE_SYNC) &&\n\t\t    !(state->flags & DID_SYNC)) {\n\t\t\tasc->script = &asc_scripts[SCRIPT_TRY_SYNC];\n\t\t\tstate->flags |= TRY_SYNC;\n\t\t} else\n\t\t\tasc->script = &asc_scripts[SCRIPT_SIMPLE];\n\t\tstate->buf = (char *)0;\n\t} else if (scsicmd->flags & SCSICMD_DATA_TO_DEVICE) {\n\t\tasc->script = &asc_scripts[SCRIPT_DATA_OUT];\n\t\tstate->buf = scsicmd->buf;\n\t\tstate->flags |= DMA_OUT;\n\t} else {\n\t\tasc->script = &asc_scripts[SCRIPT_DATA_IN];\n\t\tstate->buf = scsicmd->buf;\n\t\tstate->flags |= DMA_IN;\n\t}\n\n#ifdef DEBUG\n\tasc_debug_cmd = scsicmd->cmd[0];\n\tif (scsicmd->cmd[0] == SCSI_READ_EXT) {\n\t\tasc_debug_bn = (scsicmd->cmd[2] << 24) |\n\t\t\t(scsicmd->cmd[3] << 16) |\n\t\t\t(scsicmd->cmd[4] << 8) |\n\t\t\tscsicmd->cmd[5];\n\t\tasc_debug_sz = (scsicmd->cmd[7] << 8) | scsicmd->cmd[8];\n\t}\n\tasc_logp->status = PACK(asc->sc_dev.dv_unit, 0, 0, asc_debug_cmd);\n\tasc_logp->target = asc->target;\n\tasc_logp->state = asc->script - asc_scripts;\n\tasc_logp->msg = SCSI_DIS_REC_IDENTIFY;\n\tasc_logp->resid = scsicmd->buflen;\n\tif (++asc_logp >= &asc_log[NLOG])\n\t\tasc_logp = asc_log;\n#endif\n\n\t/* preload the FIFO with the message to be sent */\n\tregs->asc_fifo = SCSI_DIS_REC_IDENTIFY;\n\ttc_mb();\n\n\t/* initialize the DMA */\n\tlen = (*asc->dma_start)(asc, state, scsicmd->cmd, ASCDMA_WRITE,\n\t   len, 0);\n\tASC_TC_PUT(regs, len);\n\treadback(regs->asc_cmd);\n\n\tregs->asc_dbus_id = target;\n\treadback(regs->asc_dbus_id);\n\tregs->asc_syn_p = state->sync_period;\n\treadback(regs->asc_syn_p);\n\tregs->asc_syn_o = state->sync_offset;\n\treadback(regs->asc_syn_o);\n\n\t/* Try to avoid reselect collisions */\n\tif ((regs->asc_status & (ASC_CSR_INT|SCSI_PHASE_MSG_IN)) ==\n\t    (ASC_CSR_INT|SCSI_PHASE_MSG_IN)) {\n/*\t\tprintf(\"asc_startcmd: reselect in progress (before select)\\n\");*/\n\t\treturn;\n\t}\n\n\tif (state->flags & TRY_SYNC)\n\t\tregs->asc_cmd = len = ASC_CMD_SEL_ATN_STOP;\n\telse\n\t\tregs->asc_cmd = len = ASC_CMD_SEL_ATN | ASC_CMD_DMA;\n\treadback(regs->asc_cmd);\n\n\t/* Try to avoid reselect collisions */\n\tif ((regs->asc_status & (ASC_CSR_INT|SCSI_PHASE_MSG_IN)) ==\n\t    (ASC_CSR_INT|SCSI_PHASE_MSG_IN)) {\n/*\t\tprintf(\"asc_startcmd: reselect in progress after select\\n\");*/\n\t\treturn;\n\t} else {\n\t\t/*\n\t\t * Here's a potentially nasty but infrequent problem:  a\n\t\t * reselect may have occurred, but did not interrupt.\n\t\t */\n\t\tif (regs->asc_cmd != len &&\n\t\t    regs->asc_cmd == (ASC_CMD_NOP|ASC_CMD_DMA)) {\n\t\t    \tif ((regs->asc_status & ASC_CSR_INT) == 0) {\n\t\t    \t\tdelay(250);\n\t\t    \t\tif (regs->asc_status == SCSI_PHASE_MSG_IN) {\n\t\t    \t\t\tprintf(\"asc_startcmd: reselect failed to interrupt?\\n\");\n\t\t    \t\t\t/* XXXX THIS NEEDS FIXING */\n\t\t    \t\t}\n\t\t    \t}\n\t\t}\n\t}\n\n}",
          "includes": [
            "#include <dev/tc/ascvar.h>",
            "#include <pmax/pmax/kmin.h>",
            "#include <pmax/pmax/asic.h>",
            "#include <pmax/dev/ascreg.h>",
            "#include <pmax/dev/scsi.h>",
            "#include <pmax/dev/device.h>",
            "#include <machine/bus.h>",
            "#include <machine/autoconf.h>",
            "#include <machine/cpu.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/tc/ioasicvar.h>",
            "#include <dev/tc/tcvar.h>",
            "#include <sys/reboot.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/errno.h>",
            "#include <sys/conf.h>",
            "#include <sys/buf.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <asc.h>"
          ],
          "macros_used": [
            "#define\tSCRIPT_TRY_SYNC\t\t12",
            "#define\tSCRIPT_SIMPLE\t\t6",
            "#define\tSCRIPT_DATA_OUT\t\t3",
            "#define\tSCRIPT_DATA_IN\t\t0",
            "#define NLOG 32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/tc/ascvar.h>\n#include <pmax/pmax/kmin.h>\n#include <pmax/pmax/asic.h>\n#include <pmax/dev/ascreg.h>\n#include <pmax/dev/scsi.h>\n#include <pmax/dev/device.h>\n#include <machine/bus.h>\n#include <machine/autoconf.h>\n#include <machine/cpu.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/tc/ioasicvar.h>\n#include <dev/tc/tcvar.h>\n#include <sys/reboot.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/errno.h>\n#include <sys/conf.h>\n#include <sys/buf.h>\n#include <sys/dkstat.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <asc.h>\n\n#define\tSCRIPT_TRY_SYNC\t\t12\n#define\tSCRIPT_SIMPLE\t\t6\n#define\tSCRIPT_DATA_OUT\t\t3\n#define\tSCRIPT_DATA_IN\t\t0\n#define NLOG 32\n\nstatic void\nasc_startcmd(asc, target)\n\tasc_softc_t asc;\n\tint target;\n{\n\tregister asc_regmap_t *regs;\n\tregister ScsiCmd *scsicmd;\n\tregister State *state;\n\tint len;\n\n\t/*\n\t * See if another target is currently selected on this SCSI bus.\n\t */\n\tif (asc->target >= 0)\n\t\treturn;\n\n\tregs = asc->regs;\n\n\t/*\n\t * If a reselection is in progress, it is Ok to ignore it since\n\t * the ASC will automatically cancel the command and flush\n\t * the FIFO if the ASC is reselected before the command starts.\n\t * If we try to use ASC_CMD_DISABLE_SEL, we can hang the system if\n\t * a reselect occurs before starting the command.\n\t */\n\n\tasc->state = ASC_STATE_BUSY;\n\tasc->target = target;\n\n\t/* cache some pointers */\n\tscsicmd = asc->cmd[target];\n\tstate = &asc->st[target];\n\n#ifdef DEBUG\n\tif (asc_debug > 1) {\n\t\tprintf(\"asc_startcmd: %s target %d cmd %x len %d\\n\",\n\t\t    scsicmd->sd->sd_driver->d_name, target,\n\t\t    scsicmd->cmd[0], scsicmd->buflen);\n\t}\n#endif\n\n\t/* Try to avoid reselect collisions */\n\tif ((regs->asc_status & (ASC_CSR_INT|SCSI_PHASE_MSG_IN)) ==\n\t    (ASC_CSR_INT|SCSI_PHASE_MSG_IN)) {\n/*\t\tprintf(\"asc_startcmd: possible reselect in progress\\n\"); */\n\t\treturn;\n\t}\n\n\t/*\n\t * Init the chip and target state.\n\t */\n\tstate->flags = state->flags & DID_SYNC;\n\tstate->error = 0;\n\tstate->script = (script_t *)0;\n\tstate->msg_out = SCSI_NO_OP;\n\n\tlen = scsicmd->cmdlen;\n\tstate->dmalen = len;\n\n\t/* check for simple SCSI command with no data transfer */\n\tif ((state->buflen = scsicmd->buflen) == 0) {\n\t\t/* check for sync negotiation */\n\t\tif ((scsicmd->flags & SCSICMD_USE_SYNC) &&\n\t\t    !(state->flags & DID_SYNC)) {\n\t\t\tasc->script = &asc_scripts[SCRIPT_TRY_SYNC];\n\t\t\tstate->flags |= TRY_SYNC;\n\t\t} else\n\t\t\tasc->script = &asc_scripts[SCRIPT_SIMPLE];\n\t\tstate->buf = (char *)0;\n\t} else if (scsicmd->flags & SCSICMD_DATA_TO_DEVICE) {\n\t\tasc->script = &asc_scripts[SCRIPT_DATA_OUT];\n\t\tstate->buf = scsicmd->buf;\n\t\tstate->flags |= DMA_OUT;\n\t} else {\n\t\tasc->script = &asc_scripts[SCRIPT_DATA_IN];\n\t\tstate->buf = scsicmd->buf;\n\t\tstate->flags |= DMA_IN;\n\t}\n\n#ifdef DEBUG\n\tasc_debug_cmd = scsicmd->cmd[0];\n\tif (scsicmd->cmd[0] == SCSI_READ_EXT) {\n\t\tasc_debug_bn = (scsicmd->cmd[2] << 24) |\n\t\t\t(scsicmd->cmd[3] << 16) |\n\t\t\t(scsicmd->cmd[4] << 8) |\n\t\t\tscsicmd->cmd[5];\n\t\tasc_debug_sz = (scsicmd->cmd[7] << 8) | scsicmd->cmd[8];\n\t}\n\tasc_logp->status = PACK(asc->sc_dev.dv_unit, 0, 0, asc_debug_cmd);\n\tasc_logp->target = asc->target;\n\tasc_logp->state = asc->script - asc_scripts;\n\tasc_logp->msg = SCSI_DIS_REC_IDENTIFY;\n\tasc_logp->resid = scsicmd->buflen;\n\tif (++asc_logp >= &asc_log[NLOG])\n\t\tasc_logp = asc_log;\n#endif\n\n\t/* preload the FIFO with the message to be sent */\n\tregs->asc_fifo = SCSI_DIS_REC_IDENTIFY;\n\ttc_mb();\n\n\t/* initialize the DMA */\n\tlen = (*asc->dma_start)(asc, state, scsicmd->cmd, ASCDMA_WRITE,\n\t   len, 0);\n\tASC_TC_PUT(regs, len);\n\treadback(regs->asc_cmd);\n\n\tregs->asc_dbus_id = target;\n\treadback(regs->asc_dbus_id);\n\tregs->asc_syn_p = state->sync_period;\n\treadback(regs->asc_syn_p);\n\tregs->asc_syn_o = state->sync_offset;\n\treadback(regs->asc_syn_o);\n\n\t/* Try to avoid reselect collisions */\n\tif ((regs->asc_status & (ASC_CSR_INT|SCSI_PHASE_MSG_IN)) ==\n\t    (ASC_CSR_INT|SCSI_PHASE_MSG_IN)) {\n/*\t\tprintf(\"asc_startcmd: reselect in progress (before select)\\n\");*/\n\t\treturn;\n\t}\n\n\tif (state->flags & TRY_SYNC)\n\t\tregs->asc_cmd = len = ASC_CMD_SEL_ATN_STOP;\n\telse\n\t\tregs->asc_cmd = len = ASC_CMD_SEL_ATN | ASC_CMD_DMA;\n\treadback(regs->asc_cmd);\n\n\t/* Try to avoid reselect collisions */\n\tif ((regs->asc_status & (ASC_CSR_INT|SCSI_PHASE_MSG_IN)) ==\n\t    (ASC_CSR_INT|SCSI_PHASE_MSG_IN)) {\n/*\t\tprintf(\"asc_startcmd: reselect in progress after select\\n\");*/\n\t\treturn;\n\t} else {\n\t\t/*\n\t\t * Here's a potentially nasty but infrequent problem:  a\n\t\t * reselect may have occurred, but did not interrupt.\n\t\t */\n\t\tif (regs->asc_cmd != len &&\n\t\t    regs->asc_cmd == (ASC_CMD_NOP|ASC_CMD_DMA)) {\n\t\t    \tif ((regs->asc_status & ASC_CSR_INT) == 0) {\n\t\t    \t\tdelay(250);\n\t\t    \t\tif (regs->asc_status == SCSI_PHASE_MSG_IN) {\n\t\t    \t\t\tprintf(\"asc_startcmd: reselect failed to interrupt?\\n\");\n\t\t    \t\t\t/* XXXX THIS NEEDS FIXING */\n\t\t    \t\t}\n\t\t    \t}\n\t\t}\n\t}\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "asc_timeout",
            "scsicmd",
            "hz * (scsicmd->buflen == 0 ?\n\t    1800 : 60)"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "asc_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/tc/asc.c",
          "lines": "2111-2128",
          "snippet": "void\nasc_timeout(arg)\n\tvoid *arg;\n{\n\tint s = splbio();\n\tScsiCmd *scsicmd = (ScsiCmd *) arg;\n\n\tprintf(\"asc_timeout: cmd %p drive %d\\n\", scsicmd, scsicmd->sd->sd_drive);\n#ifdef DEBUG\n\tasc_DumpLog(\"asc_timeout\");\n#endif\n#if 0\n\tpanic(\"asc_timeout\");\n#else\n\tboot(RB_NOSYNC); /* XXX */\n#endif\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/tc/ascvar.h>",
            "#include <pmax/pmax/kmin.h>",
            "#include <pmax/pmax/asic.h>",
            "#include <pmax/dev/ascreg.h>",
            "#include <pmax/dev/scsi.h>",
            "#include <pmax/dev/device.h>",
            "#include <machine/bus.h>",
            "#include <machine/autoconf.h>",
            "#include <machine/cpu.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/tc/ioasicvar.h>",
            "#include <dev/tc/tcvar.h>",
            "#include <sys/reboot.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/errno.h>",
            "#include <sys/conf.h>",
            "#include <sys/buf.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <asc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/tc/ascvar.h>\n#include <pmax/pmax/kmin.h>\n#include <pmax/pmax/asic.h>\n#include <pmax/dev/ascreg.h>\n#include <pmax/dev/scsi.h>\n#include <pmax/dev/device.h>\n#include <machine/bus.h>\n#include <machine/autoconf.h>\n#include <machine/cpu.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/tc/ioasicvar.h>\n#include <dev/tc/tcvar.h>\n#include <sys/reboot.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/errno.h>\n#include <sys/conf.h>\n#include <sys/buf.h>\n#include <sys/dkstat.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <asc.h>\n\nvoid\nasc_timeout(arg)\n\tvoid *arg;\n{\n\tint s = splbio();\n\tScsiCmd *scsicmd = (ScsiCmd *) arg;\n\n\tprintf(\"asc_timeout: cmd %p drive %d\\n\", scsicmd, scsicmd->sd->sd_drive);\n#ifdef DEBUG\n\tasc_DumpLog(\"asc_timeout\");\n#endif\n#if 0\n\tpanic(\"asc_timeout\");\n#else\n\tboot(RB_NOSYNC); /* XXX */\n#endif\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "scsicmd->unit",
            "EBUSY",
            "scsicmd->buflen",
            "0"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"asc %d: device %s busy at start\\n\"",
            "sdp->sd_ctlr",
            "/*XXX*/sdp->sd_driver->d_name"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/tc/ascvar.h>\n#include <pmax/pmax/kmin.h>\n#include <pmax/pmax/asic.h>\n#include <pmax/dev/ascreg.h>\n#include <pmax/dev/scsi.h>\n#include <pmax/dev/device.h>\n#include <machine/bus.h>\n#include <machine/autoconf.h>\n#include <machine/cpu.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/tc/ioasicvar.h>\n#include <dev/tc/tcvar.h>\n#include <sys/reboot.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/errno.h>\n#include <sys/conf.h>\n#include <sys/buf.h>\n#include <sys/dkstat.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <asc.h>\n\nvoid\nasc_start(scsicmd)\n\tregister ScsiCmd *scsicmd;\t/* command to start */\n{\n\tregister struct pmax_scsi_device *sdp = scsicmd->sd;\n\tregister asc_softc_t asc = asc_cd.cd_devs[sdp->sd_ctlr];\n\tint s;\n\n\ts = splbio();\n\t/*\n\t * Check if another command is already in progress.\n\t * We may have to change this if we allow SCSI devices with\n\t * separate LUNs.\n\t */\n\tif (asc->cmd[sdp->sd_drive]) {\n\t\tprintf(\"asc %d: device %s busy at start\\n\",\n\t\t\tsdp->sd_ctlr,\t/*XXX*/\n\t\t\tsdp->sd_driver->d_name);\n\t\t(*sdp->sd_driver->d_done)(scsicmd->unit, EBUSY,\n\t\t\tscsicmd->buflen, 0);\n\t\tsplx(s);\n\t}\n\tasc->cmd[sdp->sd_drive] = scsicmd;\n\t/*\n\t * Kludge: use a 60 second timeout if data is being transfered,\n\t * otherwise use a 30 minute timeout.\n\t */\n\ttimeout(asc_timeout, scsicmd, hz * (scsicmd->buflen == 0 ?\n\t    1800 : 60));\n\tasc_startcmd(asc, sdp->sd_drive);\n\tsplx(s);\n}"
  },
  {
    "function_name": "asc_minphys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/tc/asc.c",
    "lines": "551-556",
    "snippet": "void\nasc_minphys(bp)\n\tstruct buf *bp;\n{\n\t/*XXX*/\n}",
    "includes": [
      "#include <dev/tc/ascvar.h>",
      "#include <pmax/pmax/kmin.h>",
      "#include <pmax/pmax/asic.h>",
      "#include <pmax/dev/ascreg.h>",
      "#include <pmax/dev/scsi.h>",
      "#include <pmax/dev/device.h>",
      "#include <machine/bus.h>",
      "#include <machine/autoconf.h>",
      "#include <machine/cpu.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/tc/ioasicvar.h>",
      "#include <dev/tc/tcvar.h>",
      "#include <sys/reboot.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/errno.h>",
      "#include <sys/conf.h>",
      "#include <sys/buf.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <asc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <dev/tc/ascvar.h>\n#include <pmax/pmax/kmin.h>\n#include <pmax/pmax/asic.h>\n#include <pmax/dev/ascreg.h>\n#include <pmax/dev/scsi.h>\n#include <pmax/dev/device.h>\n#include <machine/bus.h>\n#include <machine/autoconf.h>\n#include <machine/cpu.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/tc/ioasicvar.h>\n#include <dev/tc/tcvar.h>\n#include <sys/reboot.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/errno.h>\n#include <sys/conf.h>\n#include <sys/buf.h>\n#include <sys/dkstat.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <asc.h>\n\nvoid\nasc_minphys(bp)\n\tstruct buf *bp;\n{\n\t/*XXX*/\n}"
  },
  {
    "function_name": "ascattach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/tc/asc.c",
    "lines": "450-546",
    "snippet": "void\nascattach(asc, bus_speed)\n\tregister asc_softc_t asc;\n\tint bus_speed;\n{\n\tregister asc_regmap_t *regs;\n\tint id, s;\n\n\tint unit;\n\n\tunit = asc->sc_dev.dv_unit;\n\t\n\t/*\n\t * Set up machine dependencies.\n\t * (1) timing based on turbochannel frequency\n\t */\n\n\t/* dma setup done in parent-specific attach code */\n\n\t/*\n\t * Now for timing. The 3max has a 25Mhz tb whereas the 3min and\n\t * maxine are 12.5Mhz.\n\t */\n\tswitch (bus_speed) {\n\tcase ASC_SPEED_25_MHZ:\n\t\tasc->min_period = ASC_MIN_PERIOD25;\n\t\tasc->max_period = ASC_MAX_PERIOD25;\n\t\tasc->ccf = ASC_CCF(25);\n\t\tasc->timeout_250 = ASC_TIMEOUT_250(25, asc->ccf);\n\t\tasc->tb_ticks = 10;\n\t\tbreak;\n\n\tcase ASC_SPEED_12_5_MHZ:\n\tdefault:\n\t\tasc->min_period = ASC_MIN_PERIOD12;\n\t\tasc->max_period = ASC_MAX_PERIOD12;\n\t\tasc->ccf = ASC_CCF(13);\n\t\tasc->timeout_250 = ASC_TIMEOUT_250(13, asc->ccf);\n\t\tasc->tb_ticks = 20;\n\t\tbreak;\n\t};\n\n\tasc->state = ASC_STATE_IDLE;\n\tasc->target = -1;\n\n\tregs = asc->regs;\n\n\t/*\n\t * Reset chip, fully.  Note that interrupts are already enabled.\n\t */\n\ts = splbio();\n\n\t/* preserve our ID for now */\n\tasc->sc_id = regs->asc_cnfg1 & ASC_CNFG1_MY_BUS_ID;\n\tasc->myidmask = ~(1 << asc->sc_id);\n\n\tasc_reset(asc, regs);\n\n\t/*\n\t * Our SCSI id on the bus.\n\t * The user can set this via the prom on 3maxen/pmaxen.\n\t * If this changes it is easy to fix: make a default that\n\t * can be changed as boot arg.\n\t */\n#ifdef\tunneeded\n\tregs->asc_cnfg1 = (regs->asc_cnfg1 & ~ASC_CNFG1_MY_BUS_ID) |\n\t\t\t      (scsi_initiator_id[unit] & 0x7);\n\tasc->sc_id = regs->asc_cnfg1 & ASC_CNFG1_MY_BUS_ID;\n#endif\n\n\tid = asc->sc_id;\n\tsplx(s);\n\n\t/* Hack for old-sytle SCSI-device probe */\n\t(void) pmax_add_scsi(&ascdriver, unit);\n\n\tprintf(\": target %d\\n\", id);\n\n\n#ifdef USE_NEW_SCSI\n\t/*\n\t * fill in the prototype scsi_link.\n\t */\n\tasc->sc_link.channel = SCSI_CHANNEL_ONLY_ONE;\n\tasc->sc_link.adapter_softc = asc;\n\tasc->sc_link.adapter_target = asc->sc_id;\n\tasc->sc_link.adapter = &asc_switch;\n\tasc->sc_link.device = &asc_dev;\n\tasc->sc_link.openings = 2;\n\n\t/*\n\t * Now try to attach all the sub-devices.\n\t */\n\tconfig_found(self, &asc->sc_link, scsiprint);\n\n#endif /* USE_NEW_SCSI */\n}",
    "includes": [
      "#include <dev/tc/ascvar.h>",
      "#include <pmax/pmax/kmin.h>",
      "#include <pmax/pmax/asic.h>",
      "#include <pmax/dev/ascreg.h>",
      "#include <pmax/dev/scsi.h>",
      "#include <pmax/dev/device.h>",
      "#include <machine/bus.h>",
      "#include <machine/autoconf.h>",
      "#include <machine/cpu.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/tc/ioasicvar.h>",
      "#include <dev/tc/tcvar.h>",
      "#include <sys/reboot.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/errno.h>",
      "#include <sys/conf.h>",
      "#include <sys/buf.h>",
      "#include <sys/dkstat.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <asc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "config_found",
          "args": [
            "self",
            "&asc->sc_link",
            "scsiprint"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\": target %d\\n\"",
            "id"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmax_add_scsi",
          "args": [
            "&ascdriver",
            "unit"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asc_reset",
          "args": [
            "asc",
            "regs"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "asc_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/tc/asc.c",
          "lines": "623-655",
          "snippet": "static void\nasc_reset(asc, regs)\n\tasc_softc_t asc;\n\tasc_regmap_t *regs;\n{\n\n\t/*\n\t * Reset chip and wait till done\n\t */\n\tregs->asc_cmd = ASC_CMD_RESET;\n\ttc_syncbus(); DELAY(25);\n\n\t/* spec says this is needed after reset */\n\tregs->asc_cmd = ASC_CMD_NOP;\n\ttc_syncbus(); DELAY(25);\n\n\t/*\n\t * Set up various chip parameters\n\t */\n\tregs->asc_ccf = asc->ccf;\n\ttc_syncbus(); DELAY(25);\n\tregs->asc_sel_timo = asc->timeout_250;\n\t/* restore our ID */\n\tregs->asc_cnfg1 = asc->sc_id | ASC_CNFG1_P_CHECK;\n\t/* include ASC_CNFG2_SCSI2 if you want to allow SCSI II commands */\n\tregs->asc_cnfg2 = /* ASC_CNFG2_RFB | ASC_CNFG2_SCSI2 | */ ASC_CNFG2_EPL;\n\tregs->asc_cnfg3 = 0;\n\t/* zero anything else */\n\tASC_TC_PUT(regs, 0);\n\tregs->asc_syn_p = asc->min_period;\n\tregs->asc_syn_o = 0;\t/* async for now */\n\ttc_mb();\n}",
          "includes": [
            "#include <dev/tc/ascvar.h>",
            "#include <pmax/pmax/kmin.h>",
            "#include <pmax/pmax/asic.h>",
            "#include <pmax/dev/ascreg.h>",
            "#include <pmax/dev/scsi.h>",
            "#include <pmax/dev/device.h>",
            "#include <machine/bus.h>",
            "#include <machine/autoconf.h>",
            "#include <machine/cpu.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/tc/ioasicvar.h>",
            "#include <dev/tc/tcvar.h>",
            "#include <sys/reboot.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/errno.h>",
            "#include <sys/conf.h>",
            "#include <sys/buf.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <asc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/tc/ascvar.h>\n#include <pmax/pmax/kmin.h>\n#include <pmax/pmax/asic.h>\n#include <pmax/dev/ascreg.h>\n#include <pmax/dev/scsi.h>\n#include <pmax/dev/device.h>\n#include <machine/bus.h>\n#include <machine/autoconf.h>\n#include <machine/cpu.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/tc/ioasicvar.h>\n#include <dev/tc/tcvar.h>\n#include <sys/reboot.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/errno.h>\n#include <sys/conf.h>\n#include <sys/buf.h>\n#include <sys/dkstat.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <asc.h>\n\nstatic void\nasc_reset(asc, regs)\n\tasc_softc_t asc;\n\tasc_regmap_t *regs;\n{\n\n\t/*\n\t * Reset chip and wait till done\n\t */\n\tregs->asc_cmd = ASC_CMD_RESET;\n\ttc_syncbus(); DELAY(25);\n\n\t/* spec says this is needed after reset */\n\tregs->asc_cmd = ASC_CMD_NOP;\n\ttc_syncbus(); DELAY(25);\n\n\t/*\n\t * Set up various chip parameters\n\t */\n\tregs->asc_ccf = asc->ccf;\n\ttc_syncbus(); DELAY(25);\n\tregs->asc_sel_timo = asc->timeout_250;\n\t/* restore our ID */\n\tregs->asc_cnfg1 = asc->sc_id | ASC_CNFG1_P_CHECK;\n\t/* include ASC_CNFG2_SCSI2 if you want to allow SCSI II commands */\n\tregs->asc_cnfg2 = /* ASC_CNFG2_RFB | ASC_CNFG2_SCSI2 | */ ASC_CNFG2_EPL;\n\tregs->asc_cnfg3 = 0;\n\t/* zero anything else */\n\tASC_TC_PUT(regs, 0);\n\tregs->asc_syn_p = asc->min_period;\n\tregs->asc_syn_o = 0;\t/* async for now */\n\ttc_mb();\n}"
        }
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASC_TIMEOUT_250",
          "args": [
            "13",
            "asc->ccf"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASC_CCF",
          "args": [
            "13"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASC_TIMEOUT_250",
          "args": [
            "25",
            "asc->ccf"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASC_CCF",
          "args": [
            "25"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/tc/ascvar.h>\n#include <pmax/pmax/kmin.h>\n#include <pmax/pmax/asic.h>\n#include <pmax/dev/ascreg.h>\n#include <pmax/dev/scsi.h>\n#include <pmax/dev/device.h>\n#include <machine/bus.h>\n#include <machine/autoconf.h>\n#include <machine/cpu.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/tc/ioasicvar.h>\n#include <dev/tc/tcvar.h>\n#include <sys/reboot.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/errno.h>\n#include <sys/conf.h>\n#include <sys/buf.h>\n#include <sys/dkstat.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <asc.h>\n\nvoid\nascattach(asc, bus_speed)\n\tregister asc_softc_t asc;\n\tint bus_speed;\n{\n\tregister asc_regmap_t *regs;\n\tint id, s;\n\n\tint unit;\n\n\tunit = asc->sc_dev.dv_unit;\n\t\n\t/*\n\t * Set up machine dependencies.\n\t * (1) timing based on turbochannel frequency\n\t */\n\n\t/* dma setup done in parent-specific attach code */\n\n\t/*\n\t * Now for timing. The 3max has a 25Mhz tb whereas the 3min and\n\t * maxine are 12.5Mhz.\n\t */\n\tswitch (bus_speed) {\n\tcase ASC_SPEED_25_MHZ:\n\t\tasc->min_period = ASC_MIN_PERIOD25;\n\t\tasc->max_period = ASC_MAX_PERIOD25;\n\t\tasc->ccf = ASC_CCF(25);\n\t\tasc->timeout_250 = ASC_TIMEOUT_250(25, asc->ccf);\n\t\tasc->tb_ticks = 10;\n\t\tbreak;\n\n\tcase ASC_SPEED_12_5_MHZ:\n\tdefault:\n\t\tasc->min_period = ASC_MIN_PERIOD12;\n\t\tasc->max_period = ASC_MAX_PERIOD12;\n\t\tasc->ccf = ASC_CCF(13);\n\t\tasc->timeout_250 = ASC_TIMEOUT_250(13, asc->ccf);\n\t\tasc->tb_ticks = 20;\n\t\tbreak;\n\t};\n\n\tasc->state = ASC_STATE_IDLE;\n\tasc->target = -1;\n\n\tregs = asc->regs;\n\n\t/*\n\t * Reset chip, fully.  Note that interrupts are already enabled.\n\t */\n\ts = splbio();\n\n\t/* preserve our ID for now */\n\tasc->sc_id = regs->asc_cnfg1 & ASC_CNFG1_MY_BUS_ID;\n\tasc->myidmask = ~(1 << asc->sc_id);\n\n\tasc_reset(asc, regs);\n\n\t/*\n\t * Our SCSI id on the bus.\n\t * The user can set this via the prom on 3maxen/pmaxen.\n\t * If this changes it is easy to fix: make a default that\n\t * can be changed as boot arg.\n\t */\n#ifdef\tunneeded\n\tregs->asc_cnfg1 = (regs->asc_cnfg1 & ~ASC_CNFG1_MY_BUS_ID) |\n\t\t\t      (scsi_initiator_id[unit] & 0x7);\n\tasc->sc_id = regs->asc_cnfg1 & ASC_CNFG1_MY_BUS_ID;\n#endif\n\n\tid = asc->sc_id;\n\tsplx(s);\n\n\t/* Hack for old-sytle SCSI-device probe */\n\t(void) pmax_add_scsi(&ascdriver, unit);\n\n\tprintf(\": target %d\\n\", id);\n\n\n#ifdef USE_NEW_SCSI\n\t/*\n\t * fill in the prototype scsi_link.\n\t */\n\tasc->sc_link.channel = SCSI_CHANNEL_ONLY_ONE;\n\tasc->sc_link.adapter_softc = asc;\n\tasc->sc_link.adapter_target = asc->sc_id;\n\tasc->sc_link.adapter = &asc_switch;\n\tasc->sc_link.device = &asc_dev;\n\tasc->sc_link.openings = 2;\n\n\t/*\n\t * Now try to attach all the sub-devices.\n\t */\n\tconfig_found(self, &asc->sc_link, scsiprint);\n\n#endif /* USE_NEW_SCSI */\n}"
  }
]