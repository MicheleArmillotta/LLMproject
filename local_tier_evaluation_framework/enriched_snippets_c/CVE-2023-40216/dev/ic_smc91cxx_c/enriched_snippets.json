[
  {
    "function_name": "smc91cxx_disable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/smc91cxx.c",
    "lines": "1184-1193",
    "snippet": "void\nsmc91cxx_disable(sc)\n\tstruct smc91cxx_softc *sc;\n{\n\n\tif (sc->sc_enabled != 0 && sc->sc_disable != NULL) {\n\t\t(*sc->sc_disable)(sc);\n\t\tsc->sc_enabled = 0;\n\t}\n}",
    "includes": [
      "#include <dev/ic/smc91cxxvar.h>",
      "#include <dev/ic/smc91cxxreg.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netccitt/pk_extern.h>",
      "#include <netccitt/pk_var.h>",
      "#include <netccitt/pk.h>",
      "#include <netccitt/x25.h>",
      "#include <sys/socketvar.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/rnd.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\tsmc91cxx_disable"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/smc91cxxvar.h>\n#include <dev/ic/smc91cxxreg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netccitt/pk_extern.h>\n#include <netccitt/pk_var.h>\n#include <netccitt/pk.h>\n#include <netccitt/x25.h>\n#include <sys/socketvar.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/rnd.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\tsmc91cxx_disable;\n\nvoid\nsmc91cxx_disable(sc)\n\tstruct smc91cxx_softc *sc;\n{\n\n\tif (sc->sc_enabled != 0 && sc->sc_disable != NULL) {\n\t\t(*sc->sc_disable)(sc);\n\t\tsc->sc_enabled = 0;\n\t}\n}"
  },
  {
    "function_name": "smc91cxx_enable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/smc91cxx.c",
    "lines": "1164-1179",
    "snippet": "int\nsmc91cxx_enable(sc)\n\tstruct smc91cxx_softc *sc;\n{\n\n\tif (sc->sc_enabled == 0 && sc->sc_enable != NULL) {\n\t\tif ((*sc->sc_enable)(sc) != 0) {\n\t\t\tprintf(\"%s: device enable failed\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\treturn (EIO);\n\t\t}\n\t}\n\n\tsc->sc_enabled = 1;\n\treturn (0);\n}",
    "includes": [
      "#include <dev/ic/smc91cxxvar.h>",
      "#include <dev/ic/smc91cxxreg.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netccitt/pk_extern.h>",
      "#include <netccitt/pk_var.h>",
      "#include <netccitt/pk.h>",
      "#include <netccitt/x25.h>",
      "#include <sys/socketvar.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/rnd.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\tsmc91cxx_enable"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: device enable failed\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 1171
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/smc91cxxvar.h>\n#include <dev/ic/smc91cxxreg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netccitt/pk_extern.h>\n#include <netccitt/pk_var.h>\n#include <netccitt/pk.h>\n#include <netccitt/x25.h>\n#include <sys/socketvar.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/rnd.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\tsmc91cxx_enable;\n\nint\nsmc91cxx_enable(sc)\n\tstruct smc91cxx_softc *sc;\n{\n\n\tif (sc->sc_enabled == 0 && sc->sc_enable != NULL) {\n\t\tif ((*sc->sc_enable)(sc) != 0) {\n\t\t\tprintf(\"%s: device enable failed\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\treturn (EIO);\n\t\t}\n\t}\n\n\tsc->sc_enabled = 1;\n\treturn (0);\n}"
  },
  {
    "function_name": "smc91cxx_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/smc91cxx.c",
    "lines": "1135-1159",
    "snippet": "void\nsmc91cxx_stop(sc)\n\tstruct smc91cxx_softc *sc;\n{\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\n\t/*\n\t * Clear interrupt mask; disable all interrupts.\n\t */\n\tSMC_SELECT_BANK(sc, 2);\n\tbus_space_write_1(bst, bsh, INTR_MASK_REG_B, 0);\n\n\t/*\n\t * Disable transmitter and receiver.\n\t */\n\tSMC_SELECT_BANK(sc, 0);\n\tbus_space_write_2(bst, bsh, RECV_CONTROL_REG_W, 0);\n\tbus_space_write_2(bst, bsh, TXMIT_CONTROL_REG_W, 0);\n\n\t/*\n\t * Cancel watchdog timer.\n\t */\n\tsc->sc_arpcom.ac_if.if_timer = 0;\n}",
    "includes": [
      "#include <dev/ic/smc91cxxvar.h>",
      "#include <dev/ic/smc91cxxreg.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netccitt/pk_extern.h>",
      "#include <netccitt/pk_var.h>",
      "#include <netccitt/pk.h>",
      "#include <netccitt/x25.h>",
      "#include <sys/socketvar.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/rnd.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "bst",
            "bsh",
            "TXMIT_CONTROL_REG_W",
            "0"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "bst",
            "bsh",
            "RECV_CONTROL_REG_W",
            "0"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SMC_SELECT_BANK",
          "args": [
            "sc",
            "0"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "bst",
            "bsh",
            "INTR_MASK_REG_B",
            "0"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SMC_SELECT_BANK",
          "args": [
            "sc",
            "2"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/smc91cxxvar.h>\n#include <dev/ic/smc91cxxreg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netccitt/pk_extern.h>\n#include <netccitt/pk_var.h>\n#include <netccitt/pk.h>\n#include <netccitt/x25.h>\n#include <sys/socketvar.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/rnd.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\nsmc91cxx_stop(sc)\n\tstruct smc91cxx_softc *sc;\n{\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\n\t/*\n\t * Clear interrupt mask; disable all interrupts.\n\t */\n\tSMC_SELECT_BANK(sc, 2);\n\tbus_space_write_1(bst, bsh, INTR_MASK_REG_B, 0);\n\n\t/*\n\t * Disable transmitter and receiver.\n\t */\n\tSMC_SELECT_BANK(sc, 0);\n\tbus_space_write_2(bst, bsh, RECV_CONTROL_REG_W, 0);\n\tbus_space_write_2(bst, bsh, TXMIT_CONTROL_REG_W, 0);\n\n\t/*\n\t * Cancel watchdog timer.\n\t */\n\tsc->sc_arpcom.ac_if.if_timer = 0;\n}"
  },
  {
    "function_name": "smc91cxx_watchdog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/smc91cxx.c",
    "lines": "1120-1130",
    "snippet": "void\nsmc91cxx_watchdog(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct smc91cxx_softc *sc = ifp->if_softc;\n\n\tlog(LOG_ERR, \"%s: device timeout\\n\", sc->sc_dev.dv_xname);\n\t++sc->sc_arpcom.ac_if.if_oerrors;\n\n\tsmc91cxx_reset(sc);\n}",
    "includes": [
      "#include <dev/ic/smc91cxxvar.h>",
      "#include <dev/ic/smc91cxxreg.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netccitt/pk_extern.h>",
      "#include <netccitt/pk_var.h>",
      "#include <netccitt/pk.h>",
      "#include <netccitt/x25.h>",
      "#include <sys/socketvar.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/rnd.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\tsmc91cxx_reset",
      "void\tsmc91cxx_watchdog"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "smc91cxx_reset",
          "args": [
            "sc"
          ],
          "line": 1129
        },
        "resolved": true,
        "details": {
          "function_name": "smc91cxx_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/smc91cxx.c",
          "lines": "1105-1115",
          "snippet": "void\nsmc91cxx_reset(sc)\n\tstruct smc91cxx_softc *sc;\n{\n\tint s;\n\n\ts = splnet();\n\tsmc91cxx_stop(sc);\n\tsmc91cxx_init(sc);\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/ic/smc91cxxvar.h>",
            "#include <dev/ic/smc91cxxreg.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netccitt/pk_extern.h>",
            "#include <netccitt/pk_var.h>",
            "#include <netccitt/pk.h>",
            "#include <netccitt/x25.h>",
            "#include <sys/socketvar.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/rnd.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsmc91cxx_reset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/smc91cxxvar.h>\n#include <dev/ic/smc91cxxreg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netccitt/pk_extern.h>\n#include <netccitt/pk_var.h>\n#include <netccitt/pk.h>\n#include <netccitt/x25.h>\n#include <sys/socketvar.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/rnd.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\tsmc91cxx_reset;\n\nvoid\nsmc91cxx_reset(sc)\n\tstruct smc91cxx_softc *sc;\n{\n\tint s;\n\n\ts = splnet();\n\tsmc91cxx_stop(sc);\n\tsmc91cxx_init(sc);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log",
          "args": [
            "LOG_ERR",
            "\"%s: device timeout\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 1126
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_log2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
          "lines": "1387-1401",
          "snippet": "int\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}",
          "includes": [
            "#include <dev/ic/tcic2var.h>",
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/smc91cxxvar.h>\n#include <dev/ic/smc91cxxreg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netccitt/pk_extern.h>\n#include <netccitt/pk_var.h>\n#include <netccitt/pk.h>\n#include <netccitt/x25.h>\n#include <sys/socketvar.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/rnd.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\tsmc91cxx_reset;\nvoid\tsmc91cxx_watchdog;\n\nvoid\nsmc91cxx_watchdog(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct smc91cxx_softc *sc = ifp->if_softc;\n\n\tlog(LOG_ERR, \"%s: device timeout\\n\", sc->sc_dev.dv_xname);\n\t++sc->sc_arpcom.ac_if.if_oerrors;\n\n\tsmc91cxx_reset(sc);\n}"
  },
  {
    "function_name": "smc91cxx_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/smc91cxx.c",
    "lines": "1105-1115",
    "snippet": "void\nsmc91cxx_reset(sc)\n\tstruct smc91cxx_softc *sc;\n{\n\tint s;\n\n\ts = splnet();\n\tsmc91cxx_stop(sc);\n\tsmc91cxx_init(sc);\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/ic/smc91cxxvar.h>",
      "#include <dev/ic/smc91cxxreg.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netccitt/pk_extern.h>",
      "#include <netccitt/pk_var.h>",
      "#include <netccitt/pk.h>",
      "#include <netccitt/x25.h>",
      "#include <sys/socketvar.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/rnd.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\tsmc91cxx_reset"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smc91cxx_init",
          "args": [
            "sc"
          ],
          "line": 1113
        },
        "resolved": true,
        "details": {
          "function_name": "smc91cxx_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/smc91cxx.c",
          "lines": "361-469",
          "snippet": "void\nsmc91cxx_init(sc)\n\tstruct smc91cxx_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tu_int16_t tmp;\n\tint s, i;\n\n\ts = splnet();\n\n\t/*\n\t * This resets the registersmostly to defaults, but doesn't\n\t * affect the EEPROM.  After the reset cycle, we pause briefly\n\t * for the chip to recover.\n\t *\n\t * XXX how long are we really supposed to delay?  --thorpej\n\t */\n\tSMC_SELECT_BANK(sc, 0);\n\tbus_space_write_2(bst, bsh, RECV_CONTROL_REG_W, RCR_SOFTRESET);\n\tdelay(100);\n\tbus_space_write_2(bst, bsh, RECV_CONTROL_REG_W, 0);\n\tdelay(200);\n\n\tbus_space_write_2(bst, bsh, TXMIT_CONTROL_REG_W, 0);\n\n\t/* Set the Ethernet address. */\n\tSMC_SELECT_BANK(sc, 1);\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++ )\n\t\tbus_space_write_1(bst, bsh, IAR_ADDR0_REG_W + i,\n\t\t    sc->sc_arpcom.ac_enaddr[i]);\n\n\t/*\n\t * Set the control register to automatically release successfully\n\t * transmitted packets (making the best use of our limited memory)\n\t * and enable the EPH interrupt on certain TX errors.\n\t */\n\tbus_space_write_2(bst, bsh, CONTROL_REG_W, (CTR_AUTO_RELEASE |\n\t    CTR_TE_ENABLE | CTR_CR_ENABLE | CTR_LE_ENABLE));\n\n\t/*\n\t * Reset the MMU and wait for it to be un-busy.\n\t */\n\tSMC_SELECT_BANK(sc, 2);\n\tbus_space_write_2(bst, bsh, MMU_CMD_REG_W, MMUCR_RESET);\n\twhile (bus_space_read_2(bst, bsh, MMU_CMD_REG_W) & MMUCR_BUSY)\n\t\t/* XXX bound this loop! */ ;\n\n\t/*\n\t * Disable all interrupts.\n\t */\n\tbus_space_write_1(bst, bsh, INTR_MASK_REG_B, 0);\n\n\t/*\n\t * Set current media.\n\t */\n\tsmc91cxx_set_media(sc, sc->sc_media.ifm_cur->ifm_media);\n\n\t/*\n\t * Set the receive filter.  We want receive enable and auto\n\t * strip of CRC from received packet.  If we are in promisc. mode,\n\t * then set that bit as well.\n\t *\n\t * XXX Initialize multicast filter.  For now, we just accept\n\t * XXX all multicast.\n\t */\n\tSMC_SELECT_BANK(sc, 0);\n\n\ttmp = RCR_ENABLE | RCR_STRIP_CRC | RCR_ALMUL;\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\ttmp |= RCR_PROMISC;\n\n\tbus_space_write_2(bst, bsh, RECV_CONTROL_REG_W, tmp);\n\n\t/*\n\t * Set transmitter control to \"enabled\".\n\t */\n\ttmp = TCR_ENABLE;\n\n#ifndef SMC91CXX_SW_PAD\n\t/*\n\t * Enable hardware padding of transmitted packets.\n\t * XXX doesn't work?\n\t */\n\ttmp |= TCR_PAD_ENABLE;\n#endif\n\n\tbus_space_write_2(bst, bsh, TXMIT_CONTROL_REG_W, tmp);\n\n\t/*\n\t * Now, enable interrupts.\n\t */\n\tSMC_SELECT_BANK(sc, 2);\n\n\tbus_space_write_1(bst, bsh, INTR_MASK_REG_B,\n\t    IM_EPH_INT | IM_RX_OVRN_INT | IM_RCV_INT | IM_TX_INT);\n\n\t/* Interface is now running, with no output active. */\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t/*\n\t * Attempt to start any pending transmission.\n\t */\n\tsmc91cxx_start(ifp);\n\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/ic/smc91cxxvar.h>",
            "#include <dev/ic/smc91cxxreg.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netccitt/pk_extern.h>",
            "#include <netccitt/pk_var.h>",
            "#include <netccitt/pk.h>",
            "#include <netccitt/x25.h>",
            "#include <sys/socketvar.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/rnd.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define ETHER_ADDR_LEN\t\t6",
            "#define\tSMC91CXX_SW_PAD"
          ],
          "globals_used": [
            "int\tsmc91cxx_set_media",
            "void\tsmc91cxx_start"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/smc91cxxvar.h>\n#include <dev/ic/smc91cxxreg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netccitt/pk_extern.h>\n#include <netccitt/pk_var.h>\n#include <netccitt/pk.h>\n#include <netccitt/x25.h>\n#include <sys/socketvar.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/rnd.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define ETHER_ADDR_LEN\t\t6\n#define\tSMC91CXX_SW_PAD\n\nint\tsmc91cxx_set_media;\nvoid\tsmc91cxx_start;\n\nvoid\nsmc91cxx_init(sc)\n\tstruct smc91cxx_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tu_int16_t tmp;\n\tint s, i;\n\n\ts = splnet();\n\n\t/*\n\t * This resets the registersmostly to defaults, but doesn't\n\t * affect the EEPROM.  After the reset cycle, we pause briefly\n\t * for the chip to recover.\n\t *\n\t * XXX how long are we really supposed to delay?  --thorpej\n\t */\n\tSMC_SELECT_BANK(sc, 0);\n\tbus_space_write_2(bst, bsh, RECV_CONTROL_REG_W, RCR_SOFTRESET);\n\tdelay(100);\n\tbus_space_write_2(bst, bsh, RECV_CONTROL_REG_W, 0);\n\tdelay(200);\n\n\tbus_space_write_2(bst, bsh, TXMIT_CONTROL_REG_W, 0);\n\n\t/* Set the Ethernet address. */\n\tSMC_SELECT_BANK(sc, 1);\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++ )\n\t\tbus_space_write_1(bst, bsh, IAR_ADDR0_REG_W + i,\n\t\t    sc->sc_arpcom.ac_enaddr[i]);\n\n\t/*\n\t * Set the control register to automatically release successfully\n\t * transmitted packets (making the best use of our limited memory)\n\t * and enable the EPH interrupt on certain TX errors.\n\t */\n\tbus_space_write_2(bst, bsh, CONTROL_REG_W, (CTR_AUTO_RELEASE |\n\t    CTR_TE_ENABLE | CTR_CR_ENABLE | CTR_LE_ENABLE));\n\n\t/*\n\t * Reset the MMU and wait for it to be un-busy.\n\t */\n\tSMC_SELECT_BANK(sc, 2);\n\tbus_space_write_2(bst, bsh, MMU_CMD_REG_W, MMUCR_RESET);\n\twhile (bus_space_read_2(bst, bsh, MMU_CMD_REG_W) & MMUCR_BUSY)\n\t\t/* XXX bound this loop! */ ;\n\n\t/*\n\t * Disable all interrupts.\n\t */\n\tbus_space_write_1(bst, bsh, INTR_MASK_REG_B, 0);\n\n\t/*\n\t * Set current media.\n\t */\n\tsmc91cxx_set_media(sc, sc->sc_media.ifm_cur->ifm_media);\n\n\t/*\n\t * Set the receive filter.  We want receive enable and auto\n\t * strip of CRC from received packet.  If we are in promisc. mode,\n\t * then set that bit as well.\n\t *\n\t * XXX Initialize multicast filter.  For now, we just accept\n\t * XXX all multicast.\n\t */\n\tSMC_SELECT_BANK(sc, 0);\n\n\ttmp = RCR_ENABLE | RCR_STRIP_CRC | RCR_ALMUL;\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\ttmp |= RCR_PROMISC;\n\n\tbus_space_write_2(bst, bsh, RECV_CONTROL_REG_W, tmp);\n\n\t/*\n\t * Set transmitter control to \"enabled\".\n\t */\n\ttmp = TCR_ENABLE;\n\n#ifndef SMC91CXX_SW_PAD\n\t/*\n\t * Enable hardware padding of transmitted packets.\n\t * XXX doesn't work?\n\t */\n\ttmp |= TCR_PAD_ENABLE;\n#endif\n\n\tbus_space_write_2(bst, bsh, TXMIT_CONTROL_REG_W, tmp);\n\n\t/*\n\t * Now, enable interrupts.\n\t */\n\tSMC_SELECT_BANK(sc, 2);\n\n\tbus_space_write_1(bst, bsh, INTR_MASK_REG_B,\n\t    IM_EPH_INT | IM_RX_OVRN_INT | IM_RCV_INT | IM_TX_INT);\n\n\t/* Interface is now running, with no output active. */\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t/*\n\t * Attempt to start any pending transmission.\n\t */\n\tsmc91cxx_start(ifp);\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smc91cxx_stop",
          "args": [
            "sc"
          ],
          "line": 1112
        },
        "resolved": true,
        "details": {
          "function_name": "smc91cxx_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/smc91cxx.c",
          "lines": "1135-1159",
          "snippet": "void\nsmc91cxx_stop(sc)\n\tstruct smc91cxx_softc *sc;\n{\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\n\t/*\n\t * Clear interrupt mask; disable all interrupts.\n\t */\n\tSMC_SELECT_BANK(sc, 2);\n\tbus_space_write_1(bst, bsh, INTR_MASK_REG_B, 0);\n\n\t/*\n\t * Disable transmitter and receiver.\n\t */\n\tSMC_SELECT_BANK(sc, 0);\n\tbus_space_write_2(bst, bsh, RECV_CONTROL_REG_W, 0);\n\tbus_space_write_2(bst, bsh, TXMIT_CONTROL_REG_W, 0);\n\n\t/*\n\t * Cancel watchdog timer.\n\t */\n\tsc->sc_arpcom.ac_if.if_timer = 0;\n}",
          "includes": [
            "#include <dev/ic/smc91cxxvar.h>",
            "#include <dev/ic/smc91cxxreg.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netccitt/pk_extern.h>",
            "#include <netccitt/pk_var.h>",
            "#include <netccitt/pk.h>",
            "#include <netccitt/x25.h>",
            "#include <sys/socketvar.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/rnd.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/smc91cxxvar.h>\n#include <dev/ic/smc91cxxreg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netccitt/pk_extern.h>\n#include <netccitt/pk_var.h>\n#include <netccitt/pk.h>\n#include <netccitt/x25.h>\n#include <sys/socketvar.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/rnd.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\nsmc91cxx_stop(sc)\n\tstruct smc91cxx_softc *sc;\n{\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\n\t/*\n\t * Clear interrupt mask; disable all interrupts.\n\t */\n\tSMC_SELECT_BANK(sc, 2);\n\tbus_space_write_1(bst, bsh, INTR_MASK_REG_B, 0);\n\n\t/*\n\t * Disable transmitter and receiver.\n\t */\n\tSMC_SELECT_BANK(sc, 0);\n\tbus_space_write_2(bst, bsh, RECV_CONTROL_REG_W, 0);\n\tbus_space_write_2(bst, bsh, TXMIT_CONTROL_REG_W, 0);\n\n\t/*\n\t * Cancel watchdog timer.\n\t */\n\tsc->sc_arpcom.ac_if.if_timer = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splnet",
          "args": [],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/smc91cxxvar.h>\n#include <dev/ic/smc91cxxreg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netccitt/pk_extern.h>\n#include <netccitt/pk_var.h>\n#include <netccitt/pk.h>\n#include <netccitt/x25.h>\n#include <sys/socketvar.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/rnd.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\tsmc91cxx_reset;\n\nvoid\nsmc91cxx_reset(sc)\n\tstruct smc91cxx_softc *sc;\n{\n\tint s;\n\n\ts = splnet();\n\tsmc91cxx_stop(sc);\n\tsmc91cxx_init(sc);\n\tsplx(s);\n}"
  },
  {
    "function_name": "smc91cxx_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/smc91cxx.c",
    "lines": "975-1100",
    "snippet": "int\nsmc91cxx_ioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tu_long cmd;\n\tcaddr_t data;\n{\n\tstruct smc91cxx_softc *sc = ifp->if_softc;\n\tstruct ifaddr *ifa = (struct ifaddr *)data;\n\tstruct ifreq *ifr = (struct ifreq *)data;\n\tint s, error = 0;\n\n\ts = splnet();\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tif ((error = smc91cxx_enable(sc)) != 0)\n\t\t\tbreak;\n\t\tifp->if_flags |= IFF_UP;\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\tsmc91cxx_init(sc);\n\t\tarp_ifinit(&sc->sc_arpcom, ifa);\n\t\tbreak;\n#endif\n#ifdef NS\n\t\tcase AF_NS:\n\t\t    {\n\t\t\tstruct ns_addr *ina = &IA_SNS(ifa)->sns_addr;\n\n\t\t\tif (ns_nullhost(*ina))\n\t\t\t\tina->x_host =\n\t\t\t\t    *(union ns_host *)LLADDR(ifp->if_sadl);\n\t\t\telse {\n\t\t\t\tbcopy(ina->x_host.c_host, LLADDR(ifp->if_sadl), \n\t\t\t\t    ETHER_ADDR_LEN);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Set new address.  Reset, because the receiver\n\t\t\t * has to be stopped before we can set the new\n\t\t\t * MAC address.\n\t\t\t */\n\t\t\tsmc91cxx_reset(sc);\n\t\t\tbreak;\n\t\t    }\n#endif\n\t\tdefault:\n\t\t\tsmc91cxx_init(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n#if defined(CCITT) && defined(LLC)\n\tcase SIOCSIFCONF_X25:\n\t\tif ((error = smc91cxx_enable(sc)) != 0)\n\t\t\tbreak;\n\t\tifp->if_flags |= IFF_UP;\n\t\tifa->ifa_rtrequest = cons_rtrequest;\t/* XXX */\n\t\terror = x25_llcglue(PRC_IFUP, ifa->ifa_addr);\n\t\tif (error == 0)\n\t\t\tsmc91cxx_init(sc);\n\t\tbreak;\n#endif\n\n\tcase SIOCSIFFLAGS:\n\t\tif ((ifp->if_flags & IFF_UP) == 0 &&\n\t\t    (ifp->if_flags & IFF_RUNNING) != 0) {\n\t\t\t/*\n\t\t\t * If interface is marked down and it is running,\n\t\t\t * stop it.\n\t\t\t */\n\t\t\tsmc91cxx_stop(sc);\n\t\t\tifp->if_flags &= ~IFF_RUNNING;\n\t\t\tsmc91cxx_disable(sc);\n\t\t} else if ((ifp->if_flags & IFF_UP) != 0 &&\n\t\t\t   (ifp->if_flags & IFF_RUNNING) == 0) {\n\t\t\t/*\n\t\t\t * If interface is marked up and it is stopped,\n\t\t\t * start it.\n\t\t\t */\n\t\t\tif ((error = smc91cxx_enable(sc)) != 0)\n\t\t\t\tbreak;\n\t\t\tsmc91cxx_init(sc);\n\t\t} else if (sc->sc_enabled) {\n\t\t\t/*\n\t\t\t * Reset the interface to pick up changes in any\n\t\t\t * other flags that affect hardware registers.\n\t\t\t */\n\t\t\tsmc91cxx_reset(sc);\n\t\t}\n\t\tbreak;\n\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\t\tif (sc->sc_enabled == 0) {\n\t\t\terror = EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\terror = (cmd == SIOCADDMULTI) ?\n\t\t    ether_addmulti(ifr, &sc->sc_arpcom) :\n\t\t    ether_delmulti(ifr, &sc->sc_arpcom);\n\t\tif (error == ENETRESET) {\n\t\t\t/*\n\t\t\t * Multicast list has changed; set the hardware\n\t\t\t * filter accordingly.\n\t\t\t */\n\t\t\tsmc91cxx_reset(sc);\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\n\tcase SIOCGIFMEDIA:\n\tcase SIOCSIFMEDIA:\n\t\terror = ifmedia_ioctl(ifp, ifr, &sc->sc_media, cmd);\n\t\tbreak;\n\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\tsplx(s);\n\treturn (error);\n}",
    "includes": [
      "#include <dev/ic/smc91cxxvar.h>",
      "#include <dev/ic/smc91cxxreg.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netccitt/pk_extern.h>",
      "#include <netccitt/pk_var.h>",
      "#include <netccitt/pk.h>",
      "#include <netccitt/x25.h>",
      "#include <sys/socketvar.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/rnd.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define ETHER_ADDR_LEN\t\t6"
    ],
    "globals_used": [
      "void\tsmc91cxx_reset",
      "int\tsmc91cxx_ioctl",
      "int\tsmc91cxx_enable",
      "void\tsmc91cxx_disable"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_ioctl",
          "args": [
            "ifp",
            "ifr",
            "&sc->sc_media",
            "cmd"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smc91cxx_reset",
          "args": [
            "sc"
          ],
          "line": 1083
        },
        "resolved": true,
        "details": {
          "function_name": "smc91cxx_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/smc91cxx.c",
          "lines": "1105-1115",
          "snippet": "void\nsmc91cxx_reset(sc)\n\tstruct smc91cxx_softc *sc;\n{\n\tint s;\n\n\ts = splnet();\n\tsmc91cxx_stop(sc);\n\tsmc91cxx_init(sc);\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/ic/smc91cxxvar.h>",
            "#include <dev/ic/smc91cxxreg.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netccitt/pk_extern.h>",
            "#include <netccitt/pk_var.h>",
            "#include <netccitt/pk.h>",
            "#include <netccitt/x25.h>",
            "#include <sys/socketvar.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/rnd.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsmc91cxx_reset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/smc91cxxvar.h>\n#include <dev/ic/smc91cxxreg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netccitt/pk_extern.h>\n#include <netccitt/pk_var.h>\n#include <netccitt/pk.h>\n#include <netccitt/x25.h>\n#include <sys/socketvar.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/rnd.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\tsmc91cxx_reset;\n\nvoid\nsmc91cxx_reset(sc)\n\tstruct smc91cxx_softc *sc;\n{\n\tint s;\n\n\ts = splnet();\n\tsmc91cxx_stop(sc);\n\tsmc91cxx_init(sc);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ether_delmulti",
          "args": [
            "ifr",
            "&sc->sc_arpcom"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_addmulti",
          "args": [
            "ifr",
            "&sc->sc_arpcom"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smc91cxx_init",
          "args": [
            "sc"
          ],
          "line": 1058
        },
        "resolved": true,
        "details": {
          "function_name": "smc91cxx_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/smc91cxx.c",
          "lines": "361-469",
          "snippet": "void\nsmc91cxx_init(sc)\n\tstruct smc91cxx_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tu_int16_t tmp;\n\tint s, i;\n\n\ts = splnet();\n\n\t/*\n\t * This resets the registersmostly to defaults, but doesn't\n\t * affect the EEPROM.  After the reset cycle, we pause briefly\n\t * for the chip to recover.\n\t *\n\t * XXX how long are we really supposed to delay?  --thorpej\n\t */\n\tSMC_SELECT_BANK(sc, 0);\n\tbus_space_write_2(bst, bsh, RECV_CONTROL_REG_W, RCR_SOFTRESET);\n\tdelay(100);\n\tbus_space_write_2(bst, bsh, RECV_CONTROL_REG_W, 0);\n\tdelay(200);\n\n\tbus_space_write_2(bst, bsh, TXMIT_CONTROL_REG_W, 0);\n\n\t/* Set the Ethernet address. */\n\tSMC_SELECT_BANK(sc, 1);\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++ )\n\t\tbus_space_write_1(bst, bsh, IAR_ADDR0_REG_W + i,\n\t\t    sc->sc_arpcom.ac_enaddr[i]);\n\n\t/*\n\t * Set the control register to automatically release successfully\n\t * transmitted packets (making the best use of our limited memory)\n\t * and enable the EPH interrupt on certain TX errors.\n\t */\n\tbus_space_write_2(bst, bsh, CONTROL_REG_W, (CTR_AUTO_RELEASE |\n\t    CTR_TE_ENABLE | CTR_CR_ENABLE | CTR_LE_ENABLE));\n\n\t/*\n\t * Reset the MMU and wait for it to be un-busy.\n\t */\n\tSMC_SELECT_BANK(sc, 2);\n\tbus_space_write_2(bst, bsh, MMU_CMD_REG_W, MMUCR_RESET);\n\twhile (bus_space_read_2(bst, bsh, MMU_CMD_REG_W) & MMUCR_BUSY)\n\t\t/* XXX bound this loop! */ ;\n\n\t/*\n\t * Disable all interrupts.\n\t */\n\tbus_space_write_1(bst, bsh, INTR_MASK_REG_B, 0);\n\n\t/*\n\t * Set current media.\n\t */\n\tsmc91cxx_set_media(sc, sc->sc_media.ifm_cur->ifm_media);\n\n\t/*\n\t * Set the receive filter.  We want receive enable and auto\n\t * strip of CRC from received packet.  If we are in promisc. mode,\n\t * then set that bit as well.\n\t *\n\t * XXX Initialize multicast filter.  For now, we just accept\n\t * XXX all multicast.\n\t */\n\tSMC_SELECT_BANK(sc, 0);\n\n\ttmp = RCR_ENABLE | RCR_STRIP_CRC | RCR_ALMUL;\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\ttmp |= RCR_PROMISC;\n\n\tbus_space_write_2(bst, bsh, RECV_CONTROL_REG_W, tmp);\n\n\t/*\n\t * Set transmitter control to \"enabled\".\n\t */\n\ttmp = TCR_ENABLE;\n\n#ifndef SMC91CXX_SW_PAD\n\t/*\n\t * Enable hardware padding of transmitted packets.\n\t * XXX doesn't work?\n\t */\n\ttmp |= TCR_PAD_ENABLE;\n#endif\n\n\tbus_space_write_2(bst, bsh, TXMIT_CONTROL_REG_W, tmp);\n\n\t/*\n\t * Now, enable interrupts.\n\t */\n\tSMC_SELECT_BANK(sc, 2);\n\n\tbus_space_write_1(bst, bsh, INTR_MASK_REG_B,\n\t    IM_EPH_INT | IM_RX_OVRN_INT | IM_RCV_INT | IM_TX_INT);\n\n\t/* Interface is now running, with no output active. */\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t/*\n\t * Attempt to start any pending transmission.\n\t */\n\tsmc91cxx_start(ifp);\n\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/ic/smc91cxxvar.h>",
            "#include <dev/ic/smc91cxxreg.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netccitt/pk_extern.h>",
            "#include <netccitt/pk_var.h>",
            "#include <netccitt/pk.h>",
            "#include <netccitt/x25.h>",
            "#include <sys/socketvar.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/rnd.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define ETHER_ADDR_LEN\t\t6",
            "#define\tSMC91CXX_SW_PAD"
          ],
          "globals_used": [
            "int\tsmc91cxx_set_media",
            "void\tsmc91cxx_start"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/smc91cxxvar.h>\n#include <dev/ic/smc91cxxreg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netccitt/pk_extern.h>\n#include <netccitt/pk_var.h>\n#include <netccitt/pk.h>\n#include <netccitt/x25.h>\n#include <sys/socketvar.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/rnd.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define ETHER_ADDR_LEN\t\t6\n#define\tSMC91CXX_SW_PAD\n\nint\tsmc91cxx_set_media;\nvoid\tsmc91cxx_start;\n\nvoid\nsmc91cxx_init(sc)\n\tstruct smc91cxx_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tu_int16_t tmp;\n\tint s, i;\n\n\ts = splnet();\n\n\t/*\n\t * This resets the registersmostly to defaults, but doesn't\n\t * affect the EEPROM.  After the reset cycle, we pause briefly\n\t * for the chip to recover.\n\t *\n\t * XXX how long are we really supposed to delay?  --thorpej\n\t */\n\tSMC_SELECT_BANK(sc, 0);\n\tbus_space_write_2(bst, bsh, RECV_CONTROL_REG_W, RCR_SOFTRESET);\n\tdelay(100);\n\tbus_space_write_2(bst, bsh, RECV_CONTROL_REG_W, 0);\n\tdelay(200);\n\n\tbus_space_write_2(bst, bsh, TXMIT_CONTROL_REG_W, 0);\n\n\t/* Set the Ethernet address. */\n\tSMC_SELECT_BANK(sc, 1);\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++ )\n\t\tbus_space_write_1(bst, bsh, IAR_ADDR0_REG_W + i,\n\t\t    sc->sc_arpcom.ac_enaddr[i]);\n\n\t/*\n\t * Set the control register to automatically release successfully\n\t * transmitted packets (making the best use of our limited memory)\n\t * and enable the EPH interrupt on certain TX errors.\n\t */\n\tbus_space_write_2(bst, bsh, CONTROL_REG_W, (CTR_AUTO_RELEASE |\n\t    CTR_TE_ENABLE | CTR_CR_ENABLE | CTR_LE_ENABLE));\n\n\t/*\n\t * Reset the MMU and wait for it to be un-busy.\n\t */\n\tSMC_SELECT_BANK(sc, 2);\n\tbus_space_write_2(bst, bsh, MMU_CMD_REG_W, MMUCR_RESET);\n\twhile (bus_space_read_2(bst, bsh, MMU_CMD_REG_W) & MMUCR_BUSY)\n\t\t/* XXX bound this loop! */ ;\n\n\t/*\n\t * Disable all interrupts.\n\t */\n\tbus_space_write_1(bst, bsh, INTR_MASK_REG_B, 0);\n\n\t/*\n\t * Set current media.\n\t */\n\tsmc91cxx_set_media(sc, sc->sc_media.ifm_cur->ifm_media);\n\n\t/*\n\t * Set the receive filter.  We want receive enable and auto\n\t * strip of CRC from received packet.  If we are in promisc. mode,\n\t * then set that bit as well.\n\t *\n\t * XXX Initialize multicast filter.  For now, we just accept\n\t * XXX all multicast.\n\t */\n\tSMC_SELECT_BANK(sc, 0);\n\n\ttmp = RCR_ENABLE | RCR_STRIP_CRC | RCR_ALMUL;\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\ttmp |= RCR_PROMISC;\n\n\tbus_space_write_2(bst, bsh, RECV_CONTROL_REG_W, tmp);\n\n\t/*\n\t * Set transmitter control to \"enabled\".\n\t */\n\ttmp = TCR_ENABLE;\n\n#ifndef SMC91CXX_SW_PAD\n\t/*\n\t * Enable hardware padding of transmitted packets.\n\t * XXX doesn't work?\n\t */\n\ttmp |= TCR_PAD_ENABLE;\n#endif\n\n\tbus_space_write_2(bst, bsh, TXMIT_CONTROL_REG_W, tmp);\n\n\t/*\n\t * Now, enable interrupts.\n\t */\n\tSMC_SELECT_BANK(sc, 2);\n\n\tbus_space_write_1(bst, bsh, INTR_MASK_REG_B,\n\t    IM_EPH_INT | IM_RX_OVRN_INT | IM_RCV_INT | IM_TX_INT);\n\n\t/* Interface is now running, with no output active. */\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t/*\n\t * Attempt to start any pending transmission.\n\t */\n\tsmc91cxx_start(ifp);\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smc91cxx_enable",
          "args": [
            "sc"
          ],
          "line": 1056
        },
        "resolved": true,
        "details": {
          "function_name": "smc91cxx_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/smc91cxx.c",
          "lines": "1164-1179",
          "snippet": "int\nsmc91cxx_enable(sc)\n\tstruct smc91cxx_softc *sc;\n{\n\n\tif (sc->sc_enabled == 0 && sc->sc_enable != NULL) {\n\t\tif ((*sc->sc_enable)(sc) != 0) {\n\t\t\tprintf(\"%s: device enable failed\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\treturn (EIO);\n\t\t}\n\t}\n\n\tsc->sc_enabled = 1;\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/smc91cxxvar.h>",
            "#include <dev/ic/smc91cxxreg.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netccitt/pk_extern.h>",
            "#include <netccitt/pk_var.h>",
            "#include <netccitt/pk.h>",
            "#include <netccitt/x25.h>",
            "#include <sys/socketvar.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/rnd.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\tsmc91cxx_enable"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/smc91cxxvar.h>\n#include <dev/ic/smc91cxxreg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netccitt/pk_extern.h>\n#include <netccitt/pk_var.h>\n#include <netccitt/pk.h>\n#include <netccitt/x25.h>\n#include <sys/socketvar.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/rnd.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\tsmc91cxx_enable;\n\nint\nsmc91cxx_enable(sc)\n\tstruct smc91cxx_softc *sc;\n{\n\n\tif (sc->sc_enabled == 0 && sc->sc_enable != NULL) {\n\t\tif ((*sc->sc_enable)(sc) != 0) {\n\t\t\tprintf(\"%s: device enable failed\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\treturn (EIO);\n\t\t}\n\t}\n\n\tsc->sc_enabled = 1;\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smc91cxx_disable",
          "args": [
            "sc"
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "smc91cxx_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/smc91cxx.c",
          "lines": "1184-1193",
          "snippet": "void\nsmc91cxx_disable(sc)\n\tstruct smc91cxx_softc *sc;\n{\n\n\tif (sc->sc_enabled != 0 && sc->sc_disable != NULL) {\n\t\t(*sc->sc_disable)(sc);\n\t\tsc->sc_enabled = 0;\n\t}\n}",
          "includes": [
            "#include <dev/ic/smc91cxxvar.h>",
            "#include <dev/ic/smc91cxxreg.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netccitt/pk_extern.h>",
            "#include <netccitt/pk_var.h>",
            "#include <netccitt/pk.h>",
            "#include <netccitt/x25.h>",
            "#include <sys/socketvar.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/rnd.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsmc91cxx_disable"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/smc91cxxvar.h>\n#include <dev/ic/smc91cxxreg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netccitt/pk_extern.h>\n#include <netccitt/pk_var.h>\n#include <netccitt/pk.h>\n#include <netccitt/x25.h>\n#include <sys/socketvar.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/rnd.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\tsmc91cxx_disable;\n\nvoid\nsmc91cxx_disable(sc)\n\tstruct smc91cxx_softc *sc;\n{\n\n\tif (sc->sc_enabled != 0 && sc->sc_disable != NULL) {\n\t\t(*sc->sc_disable)(sc);\n\t\tsc->sc_enabled = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "smc91cxx_stop",
          "args": [
            "sc"
          ],
          "line": 1047
        },
        "resolved": true,
        "details": {
          "function_name": "smc91cxx_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/smc91cxx.c",
          "lines": "1135-1159",
          "snippet": "void\nsmc91cxx_stop(sc)\n\tstruct smc91cxx_softc *sc;\n{\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\n\t/*\n\t * Clear interrupt mask; disable all interrupts.\n\t */\n\tSMC_SELECT_BANK(sc, 2);\n\tbus_space_write_1(bst, bsh, INTR_MASK_REG_B, 0);\n\n\t/*\n\t * Disable transmitter and receiver.\n\t */\n\tSMC_SELECT_BANK(sc, 0);\n\tbus_space_write_2(bst, bsh, RECV_CONTROL_REG_W, 0);\n\tbus_space_write_2(bst, bsh, TXMIT_CONTROL_REG_W, 0);\n\n\t/*\n\t * Cancel watchdog timer.\n\t */\n\tsc->sc_arpcom.ac_if.if_timer = 0;\n}",
          "includes": [
            "#include <dev/ic/smc91cxxvar.h>",
            "#include <dev/ic/smc91cxxreg.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netccitt/pk_extern.h>",
            "#include <netccitt/pk_var.h>",
            "#include <netccitt/pk.h>",
            "#include <netccitt/x25.h>",
            "#include <sys/socketvar.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/rnd.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/smc91cxxvar.h>\n#include <dev/ic/smc91cxxreg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netccitt/pk_extern.h>\n#include <netccitt/pk_var.h>\n#include <netccitt/pk.h>\n#include <netccitt/x25.h>\n#include <sys/socketvar.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/rnd.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\nsmc91cxx_stop(sc)\n\tstruct smc91cxx_softc *sc;\n{\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\n\t/*\n\t * Clear interrupt mask; disable all interrupts.\n\t */\n\tSMC_SELECT_BANK(sc, 2);\n\tbus_space_write_1(bst, bsh, INTR_MASK_REG_B, 0);\n\n\t/*\n\t * Disable transmitter and receiver.\n\t */\n\tSMC_SELECT_BANK(sc, 0);\n\tbus_space_write_2(bst, bsh, RECV_CONTROL_REG_W, 0);\n\tbus_space_write_2(bst, bsh, TXMIT_CONTROL_REG_W, 0);\n\n\t/*\n\t * Cancel watchdog timer.\n\t */\n\tsc->sc_arpcom.ac_if.if_timer = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "x25_llcglue",
          "args": [
            "PRC_IFUP",
            "ifa->ifa_addr"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "ina->x_host.c_host",
            "LLADDR(ifp->if_sadl)",
            "ETHER_ADDR_LEN"
          ],
          "line": 1009
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "LLADDR",
          "args": [
            "ifp->if_sadl"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LLADDR",
          "args": [
            "ifp->if_sadl"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_nullhost",
          "args": [
            "*ina"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IA_SNS",
          "args": [
            "ifa"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arp_ifinit",
          "args": [
            "&sc->sc_arpcom",
            "ifa"
          ],
          "line": 997
        },
        "resolved": true,
        "details": {
          "function_name": "arp_ifinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_devar.h",
          "lines": "929-936",
          "snippet": "static void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}",
          "includes": [
            "#include <sys/devconf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/devconf.h>\n\nstatic void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splnet",
          "args": [],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/smc91cxxvar.h>\n#include <dev/ic/smc91cxxreg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netccitt/pk_extern.h>\n#include <netccitt/pk_var.h>\n#include <netccitt/pk.h>\n#include <netccitt/x25.h>\n#include <sys/socketvar.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/rnd.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define ETHER_ADDR_LEN\t\t6\n\nvoid\tsmc91cxx_reset;\nint\tsmc91cxx_ioctl;\nint\tsmc91cxx_enable;\nvoid\tsmc91cxx_disable;\n\nint\nsmc91cxx_ioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tu_long cmd;\n\tcaddr_t data;\n{\n\tstruct smc91cxx_softc *sc = ifp->if_softc;\n\tstruct ifaddr *ifa = (struct ifaddr *)data;\n\tstruct ifreq *ifr = (struct ifreq *)data;\n\tint s, error = 0;\n\n\ts = splnet();\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tif ((error = smc91cxx_enable(sc)) != 0)\n\t\t\tbreak;\n\t\tifp->if_flags |= IFF_UP;\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\tsmc91cxx_init(sc);\n\t\tarp_ifinit(&sc->sc_arpcom, ifa);\n\t\tbreak;\n#endif\n#ifdef NS\n\t\tcase AF_NS:\n\t\t    {\n\t\t\tstruct ns_addr *ina = &IA_SNS(ifa)->sns_addr;\n\n\t\t\tif (ns_nullhost(*ina))\n\t\t\t\tina->x_host =\n\t\t\t\t    *(union ns_host *)LLADDR(ifp->if_sadl);\n\t\t\telse {\n\t\t\t\tbcopy(ina->x_host.c_host, LLADDR(ifp->if_sadl), \n\t\t\t\t    ETHER_ADDR_LEN);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Set new address.  Reset, because the receiver\n\t\t\t * has to be stopped before we can set the new\n\t\t\t * MAC address.\n\t\t\t */\n\t\t\tsmc91cxx_reset(sc);\n\t\t\tbreak;\n\t\t    }\n#endif\n\t\tdefault:\n\t\t\tsmc91cxx_init(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n#if defined(CCITT) && defined(LLC)\n\tcase SIOCSIFCONF_X25:\n\t\tif ((error = smc91cxx_enable(sc)) != 0)\n\t\t\tbreak;\n\t\tifp->if_flags |= IFF_UP;\n\t\tifa->ifa_rtrequest = cons_rtrequest;\t/* XXX */\n\t\terror = x25_llcglue(PRC_IFUP, ifa->ifa_addr);\n\t\tif (error == 0)\n\t\t\tsmc91cxx_init(sc);\n\t\tbreak;\n#endif\n\n\tcase SIOCSIFFLAGS:\n\t\tif ((ifp->if_flags & IFF_UP) == 0 &&\n\t\t    (ifp->if_flags & IFF_RUNNING) != 0) {\n\t\t\t/*\n\t\t\t * If interface is marked down and it is running,\n\t\t\t * stop it.\n\t\t\t */\n\t\t\tsmc91cxx_stop(sc);\n\t\t\tifp->if_flags &= ~IFF_RUNNING;\n\t\t\tsmc91cxx_disable(sc);\n\t\t} else if ((ifp->if_flags & IFF_UP) != 0 &&\n\t\t\t   (ifp->if_flags & IFF_RUNNING) == 0) {\n\t\t\t/*\n\t\t\t * If interface is marked up and it is stopped,\n\t\t\t * start it.\n\t\t\t */\n\t\t\tif ((error = smc91cxx_enable(sc)) != 0)\n\t\t\t\tbreak;\n\t\t\tsmc91cxx_init(sc);\n\t\t} else if (sc->sc_enabled) {\n\t\t\t/*\n\t\t\t * Reset the interface to pick up changes in any\n\t\t\t * other flags that affect hardware registers.\n\t\t\t */\n\t\t\tsmc91cxx_reset(sc);\n\t\t}\n\t\tbreak;\n\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\t\tif (sc->sc_enabled == 0) {\n\t\t\terror = EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\terror = (cmd == SIOCADDMULTI) ?\n\t\t    ether_addmulti(ifr, &sc->sc_arpcom) :\n\t\t    ether_delmulti(ifr, &sc->sc_arpcom);\n\t\tif (error == ENETRESET) {\n\t\t\t/*\n\t\t\t * Multicast list has changed; set the hardware\n\t\t\t * filter accordingly.\n\t\t\t */\n\t\t\tsmc91cxx_reset(sc);\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\n\tcase SIOCGIFMEDIA:\n\tcase SIOCSIFMEDIA:\n\t\terror = ifmedia_ioctl(ifp, ifr, &sc->sc_media, cmd);\n\t\tbreak;\n\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\tsplx(s);\n\treturn (error);\n}"
  },
  {
    "function_name": "smc91cxx_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/smc91cxx.c",
    "lines": "854-970",
    "snippet": "void\nsmc91cxx_read(sc)\n\tstruct smc91cxx_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tstruct ether_header *eh;\n\tstruct mbuf *m;\n\tu_int16_t status, packetno, packetlen;\n\tu_int8_t *data;\n\n again:\n\t/*\n\t * Set data pointer to the beginning of the packet.  Since\n\t * PTR_RCV is set, the packet number will be found automatically\n\t * in FIFO_PORTS_REG_W, FIFO_RX_MASK.\n\t */\n\tbus_space_write_2(bst, bsh, POINTER_REG_W,\n\t    PTR_READ | PTR_RCV | PTR_AUTOINC /* | 0x0000 */);\n\n\t/*\n\t * First two words are status and packet length.\n\t */\n\tstatus = bus_space_read_2(bst, bsh, DATA_REG_W);\n\tpacketlen = bus_space_read_2(bst, bsh, DATA_REG_W);\n\n\t/*\n\t * The packet length includes 3 extra words: status, length,\n\t * and an extra word that includes the control byte.\n\t */\n\tpacketlen -= 6;\n\n\t/*\n\t * Account for receive errors and discard.\n\t */\n\tif (status & RS_ERRORS) {\n\t\tifp->if_ierrors++;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Adjust for odd-length packet.\n\t */\n\tif (status & RS_ODDFRAME)\n\t\tpacketlen++;\n\n\t/*\n\t * Allocate a header mbuf.\n\t */\n\tMGETHDR(m, M_DONTWAIT, MT_DATA);\n\tif (m == NULL)\n\t\tgoto out;\n\n\tm->m_pkthdr.rcvif = ifp;\n\tm->m_pkthdr.len = m->m_len = packetlen;\n\n\t/*\n\t * Always put the packet in a cluster.\n\t * XXX should chain small mbufs if less than threshold.\n\t */\n\tMCLGET(m, M_DONTWAIT);\n\tif ((m->m_flags & M_EXT) == 0) {\n\t\tm_freem(m);\n\t\tifp->if_ierrors++;\n\t\tprintf(\"%s: can't allocate cluster for incoming packet\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Pull the packet off the interface.\n\t */\n\teh = mtod(m, struct ether_header *);\n\tdata = mtod(m, u_int8_t *);\n\tbus_space_read_multi_2(bst, bsh, DATA_REG_W, (u_int16_t *)data,\n\t    packetlen >> 1);\n\tif (packetlen & 1) {\n\t\tdata += packetlen & ~1;\n\t\t*data = bus_space_read_1(bst, bsh, DATA_REG_B);\n\t}\n\n\tifp->if_ipackets++;\n\n#if NBPFILTER > 0\n\t/*\n\t * Hand the packet off to bpf listeners.  If there's a bpf listener,\n\t * we need to check if the packet is ours.\n\t */\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\n\t/*\n\t * Strip the ethernet header.\n\t */\n\tm->m_pkthdr.len = m->m_len = packetlen - sizeof(struct ether_header);\n\tm->m_data += sizeof(struct ether_header);\n\n\tether_input(ifp, eh, m);\n\n out:\n\t/*\n\t * Tell the card to free the memory occupied by this packet.\n\t */\n\twhile (bus_space_read_2(bst, bsh, MMU_CMD_REG_W) & MMUCR_BUSY)\n\t\t/* XXX bound this loop! */ ;\n\tbus_space_write_2(bst, bsh, MMU_CMD_REG_W, MMUCR_RELEASE);\n\n\t/*\n\t * Check for another packet.\n\t */\n\tpacketno = bus_space_read_2(bst, bsh, FIFO_PORTS_REG_W);\n\tif (packetno & FIFO_REMPTY)\n\t\treturn;\n\tgoto again;\n}",
    "includes": [
      "#include <dev/ic/smc91cxxvar.h>",
      "#include <dev/ic/smc91cxxreg.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netccitt/pk_extern.h>",
      "#include <netccitt/pk_var.h>",
      "#include <netccitt/pk.h>",
      "#include <netccitt/x25.h>",
      "#include <sys/socketvar.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/rnd.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\tsmc91cxx_read"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "bst",
            "bsh",
            "FIFO_PORTS_REG_W"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "bst",
            "bsh",
            "MMU_CMD_REG_W",
            "MMUCR_RELEASE"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "bst",
            "bsh",
            "MMU_CMD_REG_W"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_input",
          "args": [
            "ifp",
            "eh",
            "m"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_mtap",
          "args": [
            "ifp->if_bpf",
            "m"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "bst",
            "bsh",
            "DATA_REG_B"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_multi_2",
          "args": [
            "bst",
            "bsh",
            "DATA_REG_W",
            "(u_int16_t *)data",
            "packetlen >> 1"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "u_int8_t*"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "structether_header*"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: can't allocate cluster for incoming packet\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 919
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MCLGET",
          "args": [
            "m",
            "M_DONTWAIT"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MGETHDR",
          "args": [
            "m",
            "M_DONTWAIT",
            "MT_DATA"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "bst",
            "bsh",
            "DATA_REG_W"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "bst",
            "bsh",
            "DATA_REG_W"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "bst",
            "bsh",
            "POINTER_REG_W",
            "PTR_READ | PTR_RCV | PTR_AUTOINC/* | 0x0000 */"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/smc91cxxvar.h>\n#include <dev/ic/smc91cxxreg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netccitt/pk_extern.h>\n#include <netccitt/pk_var.h>\n#include <netccitt/pk.h>\n#include <netccitt/x25.h>\n#include <sys/socketvar.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/rnd.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\tsmc91cxx_read;\n\nvoid\nsmc91cxx_read(sc)\n\tstruct smc91cxx_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tstruct ether_header *eh;\n\tstruct mbuf *m;\n\tu_int16_t status, packetno, packetlen;\n\tu_int8_t *data;\n\n again:\n\t/*\n\t * Set data pointer to the beginning of the packet.  Since\n\t * PTR_RCV is set, the packet number will be found automatically\n\t * in FIFO_PORTS_REG_W, FIFO_RX_MASK.\n\t */\n\tbus_space_write_2(bst, bsh, POINTER_REG_W,\n\t    PTR_READ | PTR_RCV | PTR_AUTOINC /* | 0x0000 */);\n\n\t/*\n\t * First two words are status and packet length.\n\t */\n\tstatus = bus_space_read_2(bst, bsh, DATA_REG_W);\n\tpacketlen = bus_space_read_2(bst, bsh, DATA_REG_W);\n\n\t/*\n\t * The packet length includes 3 extra words: status, length,\n\t * and an extra word that includes the control byte.\n\t */\n\tpacketlen -= 6;\n\n\t/*\n\t * Account for receive errors and discard.\n\t */\n\tif (status & RS_ERRORS) {\n\t\tifp->if_ierrors++;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Adjust for odd-length packet.\n\t */\n\tif (status & RS_ODDFRAME)\n\t\tpacketlen++;\n\n\t/*\n\t * Allocate a header mbuf.\n\t */\n\tMGETHDR(m, M_DONTWAIT, MT_DATA);\n\tif (m == NULL)\n\t\tgoto out;\n\n\tm->m_pkthdr.rcvif = ifp;\n\tm->m_pkthdr.len = m->m_len = packetlen;\n\n\t/*\n\t * Always put the packet in a cluster.\n\t * XXX should chain small mbufs if less than threshold.\n\t */\n\tMCLGET(m, M_DONTWAIT);\n\tif ((m->m_flags & M_EXT) == 0) {\n\t\tm_freem(m);\n\t\tifp->if_ierrors++;\n\t\tprintf(\"%s: can't allocate cluster for incoming packet\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Pull the packet off the interface.\n\t */\n\teh = mtod(m, struct ether_header *);\n\tdata = mtod(m, u_int8_t *);\n\tbus_space_read_multi_2(bst, bsh, DATA_REG_W, (u_int16_t *)data,\n\t    packetlen >> 1);\n\tif (packetlen & 1) {\n\t\tdata += packetlen & ~1;\n\t\t*data = bus_space_read_1(bst, bsh, DATA_REG_B);\n\t}\n\n\tifp->if_ipackets++;\n\n#if NBPFILTER > 0\n\t/*\n\t * Hand the packet off to bpf listeners.  If there's a bpf listener,\n\t * we need to check if the packet is ours.\n\t */\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\n\t/*\n\t * Strip the ethernet header.\n\t */\n\tm->m_pkthdr.len = m->m_len = packetlen - sizeof(struct ether_header);\n\tm->m_data += sizeof(struct ether_header);\n\n\tether_input(ifp, eh, m);\n\n out:\n\t/*\n\t * Tell the card to free the memory occupied by this packet.\n\t */\n\twhile (bus_space_read_2(bst, bsh, MMU_CMD_REG_W) & MMUCR_BUSY)\n\t\t/* XXX bound this loop! */ ;\n\tbus_space_write_2(bst, bsh, MMU_CMD_REG_W, MMUCR_RELEASE);\n\n\t/*\n\t * Check for another packet.\n\t */\n\tpacketno = bus_space_read_2(bst, bsh, FIFO_PORTS_REG_W);\n\tif (packetno & FIFO_REMPTY)\n\t\treturn;\n\tgoto again;\n}"
  },
  {
    "function_name": "smc91cxx_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/smc91cxx.c",
    "lines": "660-848",
    "snippet": "int\nsmc91cxx_intr(arg)\n\tvoid *arg;\n{\n\tstruct smc91cxx_softc *sc = arg;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tu_int8_t mask, interrupts, status;\n\tu_int16_t packetno, tx_status, card_stats;\n\n\tif (sc->sc_enabled == 0)\n\t\treturn (0);\n\n\tSMC_SELECT_BANK(sc, 2);\n\n\t/*\n\t * Obtain the current interrupt mask.\n\t */\n\tmask = bus_space_read_1(bst, bsh, INTR_MASK_REG_B);\n\n\t/*\n\t * Get the set of interrupt which occurred and eliminate any\n\t * which are not enabled.\n\t */\n\tinterrupts = bus_space_read_1(bst, bsh, INTR_STAT_REG_B);\n\tstatus = interrupts & mask;\n\n\t/* Ours? */\n\tif (status == 0)\n\t\treturn (0);\n\n\t/*\n\t * It's ours; disable all interrupts while we process them.\n\t */\n\tbus_space_write_1(bst, bsh, INTR_MASK_REG_B, 0);\n\n\t/*\n\t * Receive overrun interrupts.\n\t */\n\tif (status & IM_RX_OVRN_INT) {\n\t\tbus_space_write_1(bst, bsh, INTR_ACK_REG_B, IM_RX_OVRN_INT);\n\t\tifp->if_ierrors++;\n\t}\n\n\t/*\n\t * Receive interrupts.\n\t */\n\tif (status & IM_RCV_INT) {\n#if 1 /* DIAGNOSTIC */\n\t\tpacketno = bus_space_read_2(bst, bsh, FIFO_PORTS_REG_W);\n\t\tif (packetno & FIFO_REMPTY)\n\t\t\tprintf(\"%s: receive interrupt on empty fifo\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\telse\n#endif\n\t\tsmc91cxx_read(sc);\n\t}\n\n\t/*\n\t * Memory allocation interrupts.\n\t */\n\tif (status & IM_ALLOC_INT) {\n\t\t/* Disable this interrupt. */\n\t\tmask &= ~IM_ALLOC_INT;\n\n\t\t/*\n\t\t * Release the just-allocated memory.  We will reallocate\n\t\t * it through the normal start logic.\n\t\t */\n\t\twhile (bus_space_read_2(bst, bsh, MMU_CMD_REG_W) & MMUCR_BUSY)\n\t\t\t/* XXX bound this loop! */ ;\n\t\tbus_space_write_2(bst, bsh, MMU_CMD_REG_W, MMUCR_FREEPKT);\n\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\t\tifp->if_timer = 0;\n\t}\n\n\t/*\n\t * Transmit complete interrupt.  Handle transmission error messages.\n\t * This will only be called on error condition because of AUTO RELEASE\n\t * mode.\n\t */\n\tif (status & IM_TX_INT) {\n\t\tbus_space_write_1(bst, bsh, INTR_ACK_REG_B, IM_TX_INT);\n\n\t\tpacketno = bus_space_read_2(bst, bsh, FIFO_PORTS_REG_W) &\n\t\t    FIFO_TX_MASK;\n\n\t\t/*\n\t\t * Select this as the packet to read from.\n\t\t */\n\t\tbus_space_write_1(bst, bsh, PACKET_NUM_REG_B, packetno);\n\n\t\t/*\n\t\t * Position the pointer to the beginning of the packet.\n\t\t */\n\t\tbus_space_write_2(bst, bsh, POINTER_REG_W,\n\t\t    PTR_AUTOINC | PTR_READ /* | 0x0000 */);\n\n\t\t/*\n\t\t * Fetch the TX status word.  This will be a copy of\n\t\t * the EPH_STATUS_REG_W at the time of the transmission\n\t\t * failure.\n\t\t */\n\t\ttx_status = bus_space_read_2(bst, bsh, DATA_REG_W);\n\n\t\tif (tx_status & EPHSR_TX_SUC)\n\t\t\tprintf(\"%s: successful packet caused TX interrupt?!\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\telse\n\t\t\tifp->if_oerrors++;\n\n\t\tif (tx_status & EPHSR_LATCOL)\n\t\t\tifp->if_collisions++;\n\n\t\t/*\n\t\t * Some of these errors disable the transmitter; reenable it.\n\t\t */\n\t\tSMC_SELECT_BANK(sc, 0);\n#ifdef SMC91CXX_SW_PAD\n\t\tbus_space_write_2(bst, bsh, TXMIT_CONTROL_REG_W, TCR_ENABLE);\n#else\n\t\tbus_space_write_2(bst, bsh, TXMIT_CONTROL_REG_W,\n\t\t    TCR_ENABLE | TCR_PAD_ENABLE);\n#endif\n\n\t\t/*\n\t\t * Kill the failed packet and wait for the MMU to unbusy.\n\t\t */\n\t\tSMC_SELECT_BANK(sc, 2);\n\t\twhile (bus_space_read_2(bst, bsh, MMU_CMD_REG_W) & MMUCR_BUSY)\n\t\t\t/* XXX bound this loop! */ ;\n\t\tbus_space_write_2(bst, bsh, MMU_CMD_REG_W, MMUCR_FREEPKT);\n\n\t\tifp->if_timer = 0;\n\t}\n\n\t/*\n\t * Transmit underrun interrupts.  We use this opportunity to\n\t * update transmit statistics from the card.\n\t */\n\tif (status & IM_TX_EMPTY_INT) {\n\t\tbus_space_write_1(bst, bsh, INTR_ACK_REG_B, IM_TX_EMPTY_INT);\n\n\t\t/* Disable this interrupt. */\n\t\tmask &= ~IM_TX_EMPTY_INT;\n\n\t\tSMC_SELECT_BANK(sc, 0);\n\t\tcard_stats = bus_space_read_2(bst, bsh, COUNTER_REG_W);\n\n\t\t/* Single collisions. */\n\t\tifp->if_collisions += card_stats & ECR_COLN_MASK;\n\n\t\t/* Multiple collisions. */\n\t\tifp->if_collisions += (card_stats & ECR_MCOLN_MASK) >> 4;\n\n\t\tSMC_SELECT_BANK(sc, 2);\n\n\t\tifp->if_timer = 0;\n\t}\n\n\t/*\n\t * Other errors.  Reset the interface.\n\t */\n\tif (status & IM_EPH_INT) {\n\t\tsmc91cxx_stop(sc);\n\t\tsmc91cxx_init(sc);\n\t}\n\n\t/*\n\t * Attempt to queue more packets for transmission.\n\t */\n\tsmc91cxx_start(ifp);\n\n\t/*\n\t * Reenable the interrupts we wish to receive now that processing\n\t * is complete.\n\t */\n\tmask |= bus_space_read_1(bst, bsh, INTR_MASK_REG_B);\n\tbus_space_write_1(bst, bsh, INTR_MASK_REG_B, mask);\n\n#if NRND > 0\n\tif (status)\n\t\trnd_add_uint32(&sc->rnd_source, status);\n#endif\n\n\treturn (1);\n}",
    "includes": [
      "#include <dev/ic/smc91cxxvar.h>",
      "#include <dev/ic/smc91cxxreg.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netccitt/pk_extern.h>",
      "#include <netccitt/pk_var.h>",
      "#include <netccitt/pk.h>",
      "#include <netccitt/x25.h>",
      "#include <sys/socketvar.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/rnd.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define\tSMC91CXX_SW_PAD"
    ],
    "globals_used": [
      "void\tsmc91cxx_read",
      "void\tsmc91cxx_start"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rnd_add_uint32",
          "args": [
            "&sc->rnd_source",
            "status"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "bst",
            "bsh",
            "INTR_MASK_REG_B",
            "mask"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "bst",
            "bsh",
            "INTR_MASK_REG_B"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smc91cxx_start",
          "args": [
            "ifp"
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "smc91cxx_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/smc91cxx.c",
          "lines": "475-655",
          "snippet": "void\nsmc91cxx_start(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct smc91cxx_softc *sc = ifp->if_softc;\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tu_int len;\n\tstruct mbuf *m, *top;\n\tu_int16_t length, npages;\n\tu_int8_t packetno;\n\tint timo, pad;\n\n\tif ((ifp->if_flags & (IFF_RUNNING|IFF_OACTIVE)) != IFF_RUNNING)\n\t\treturn;\n\n again:\n\t/*\n\t * Peek at the next packet.\n\t */\n\tif ((m = ifp->if_snd.ifq_head) == NULL)\n\t\treturn;\n\n\t/*\n\t * Compute the frame length and set pad to give an overall even\n\t * number of bytes.  Below, we assume that the packet length\n\t * is even.\n\t */\n\tfor (len = 0, top = m; m != NULL; m = m->m_next)\n\t\tlen += m->m_len;\n\tpad = (len & 1);\n\n\t/*\n\t * We drop packets that are too large.  Perhaps we should\n\t * truncate them instead?\n\t */\n\tif ((len + pad) > (ETHER_MAX_LEN - ETHER_CRC_LEN)) {\n\t\tprintf(\"%s: large packet discarded\\n\", sc->sc_dev.dv_xname);\n\t\tifp->if_oerrors++;\n\t\tIF_DEQUEUE(&ifp->if_snd, m);\n\t\tm_freem(m);\n\t\tgoto readcheck;\n\t}\n\n#ifdef SMC91CXX_SW_PAD\n\t/*\n\t * Not using hardware padding; pad to ETHER_MIN_LEN.\n\t */\n\tif (len < (ETHER_MIN_LEN - ETHER_CRC_LEN))\n\t\tpad = ETHER_MIN_LEN - ETHER_CRC_LEN - len;\n#endif\n\n\tlength = pad + len;\n\n\t/*\n\t * The MMU has a 256 byte page size.  The MMU expects us to\n\t * ask for \"npages - 1\".  We include space for the status word,\n\t * byte count, and control bytes in the allocation request.\n\t */\n\tnpages = (length + 6) >> 8;\n\n\t/*\n\t * Now allocate the memory.\n\t */\n\tSMC_SELECT_BANK(sc, 2);\n\tbus_space_write_2(bst, bsh, MMU_CMD_REG_W, MMUCR_ALLOC | npages);\n\n\ttimo = MEMORY_WAIT_TIME;\n\tdo {\n\t\tif (bus_space_read_1(bst, bsh, INTR_STAT_REG_B) & IM_ALLOC_INT)\n\t\t\tbreak;\n\t\tdelay(1);\n\t} while (--timo);\n\n\tpacketno = bus_space_read_1(bst, bsh, ALLOC_RESULT_REG_B);\n\n\tif (packetno & ARR_FAILED || timo == 0) {\n\t\t/*\n\t\t * No transmit memory is available.  Record the number\n\t\t * of requestd pages and enable the allocation completion\n\t\t * interrupt.  Set up the watchdog timer in case we miss\n\t\t * the interrupt.  Mark the interface as active so that\n\t\t * no one else attempts to transmit while we're allocating\n\t\t * memory.\n\t\t */\n\t\tbus_space_write_1(bst, bsh, INTR_MASK_REG_B,\n\t\t    bus_space_read_1(bst, bsh, INTR_MASK_REG_B) | IM_ALLOC_INT);\n\n\t\tifp->if_timer = 5;\n\t\tifp->if_flags |= IFF_OACTIVE;\n\n\t\treturn;\n\t}\n\n\t/*\n\t * We have a packet number - set the data window.\n\t */\n\tbus_space_write_1(bst, bsh, PACKET_NUM_REG_B, packetno);\n\n\t/*\n\t * Point to the beginning of the packet.\n\t */\n\tbus_space_write_2(bst, bsh, POINTER_REG_W, PTR_AUTOINC /* | 0x0000 */);\n\n\t/*\n\t * Send the packet length (+6 for stats, length, and control bytes)\n\t * and the status word (set to zeros).\n\t */\n\tbus_space_write_2(bst, bsh, DATA_REG_W, 0);\n\tbus_space_write_1(bst, bsh, DATA_REG_B, (length + 6) & 0xff);\n\tbus_space_write_1(bst, bsh, DATA_REG_B, ((length + 6) >> 8) & 0xff);\n\n\t/*\n\t * Get the packet from the kernel.  This will include the Ethernet\n\t * frame header, MAC address, etc.\n\t */\n\tIF_DEQUEUE(&ifp->if_snd, m);\n\n\t/*\n\t * Push the packet out to the card.\n\t */\n\tfor (top = m; m != NULL; m = m->m_next) {\n\t\t/* Words... */\n\t\tbus_space_write_multi_2(bst, bsh, DATA_REG_W,\n\t\t    mtod(m, u_int16_t *), m->m_len >> 1);\n\n\t\t/* ...and the remaining byte, if any. */\n\t\tif (m->m_len & 1)\n\t\t\tbus_space_write_1(bst, bsh, DATA_REG_B,\n\t\t\t  *(u_int8_t *)(mtod(m, u_int8_t *) + (m->m_len - 1)));\n\t}\n\n#ifdef SMC91CXX_SW_PAD\n\t/*\n\t * Push out padding.\n\t */\n\twhile (pad > 1) {\n\t\tbus_space_write_2(bst, bsh, DATA_REG_W, 0);\n\t\tpad -= 2;\n\t}\n\tif (pad)\n\t\tbus_space_write_1(bst, bsh, DATA_REG_B, 0);\n#endif\n\n\t/*\n\t * Push out control byte and unused packet byte.  The control byte\n\t * is 0, meaning the packet is even lengthed and no special\n\t * CRC handling is necessary.\n\t */\n\tbus_space_write_2(bst, bsh, DATA_REG_W, 0);\n\n\t/*\n\t * Enable transmit interrupts and let the chip go.  Set a watchdog\n\t * in case we miss the interrupt.\n\t */\n\tbus_space_write_1(bst, bsh, INTR_MASK_REG_B,\n\t    bus_space_read_1(bst, bsh, INTR_MASK_REG_B) |\n\t    IM_TX_INT | IM_TX_EMPTY_INT);\n\n\tbus_space_write_2(bst, bsh, MMU_CMD_REG_W, MMUCR_ENQUEUE);\n\n\tifp->if_timer = 5;\n\n#if NBPFILTER > 0\n\t/* Hand off a copy to the bpf. */\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, top);\n#endif\n\n\tifp->if_opackets++;\n\tm_freem(top);\n\n readcheck:\n\t/*\n\t * Check for incoming pcakets.  We don't want to overflow the small\n\t * RX FIFO.  If nothing has arrived, attempt to queue another\n\t * transmit packet.\n\t */\n\tif (bus_space_read_2(bst, bsh, FIFO_PORTS_REG_W) & FIFO_REMPTY)\n\t\tgoto again;\n}",
          "includes": [
            "#include <dev/ic/smc91cxxvar.h>",
            "#include <dev/ic/smc91cxxreg.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netccitt/pk_extern.h>",
            "#include <netccitt/pk_var.h>",
            "#include <netccitt/pk.h>",
            "#include <netccitt/x25.h>",
            "#include <sys/socketvar.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/rnd.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define\tETHER_CRC_LEN\t4",
            "#define\tETHER_MIN_LEN\t64",
            "#define\tETHER_MAX_LEN\t1518",
            "#define\tSMC91CXX_SW_PAD"
          ],
          "globals_used": [
            "void\tsmc91cxx_start"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/smc91cxxvar.h>\n#include <dev/ic/smc91cxxreg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netccitt/pk_extern.h>\n#include <netccitt/pk_var.h>\n#include <netccitt/pk.h>\n#include <netccitt/x25.h>\n#include <sys/socketvar.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/rnd.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tETHER_CRC_LEN\t4\n#define\tETHER_MIN_LEN\t64\n#define\tETHER_MAX_LEN\t1518\n#define\tSMC91CXX_SW_PAD\n\nvoid\tsmc91cxx_start;\n\nvoid\nsmc91cxx_start(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct smc91cxx_softc *sc = ifp->if_softc;\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tu_int len;\n\tstruct mbuf *m, *top;\n\tu_int16_t length, npages;\n\tu_int8_t packetno;\n\tint timo, pad;\n\n\tif ((ifp->if_flags & (IFF_RUNNING|IFF_OACTIVE)) != IFF_RUNNING)\n\t\treturn;\n\n again:\n\t/*\n\t * Peek at the next packet.\n\t */\n\tif ((m = ifp->if_snd.ifq_head) == NULL)\n\t\treturn;\n\n\t/*\n\t * Compute the frame length and set pad to give an overall even\n\t * number of bytes.  Below, we assume that the packet length\n\t * is even.\n\t */\n\tfor (len = 0, top = m; m != NULL; m = m->m_next)\n\t\tlen += m->m_len;\n\tpad = (len & 1);\n\n\t/*\n\t * We drop packets that are too large.  Perhaps we should\n\t * truncate them instead?\n\t */\n\tif ((len + pad) > (ETHER_MAX_LEN - ETHER_CRC_LEN)) {\n\t\tprintf(\"%s: large packet discarded\\n\", sc->sc_dev.dv_xname);\n\t\tifp->if_oerrors++;\n\t\tIF_DEQUEUE(&ifp->if_snd, m);\n\t\tm_freem(m);\n\t\tgoto readcheck;\n\t}\n\n#ifdef SMC91CXX_SW_PAD\n\t/*\n\t * Not using hardware padding; pad to ETHER_MIN_LEN.\n\t */\n\tif (len < (ETHER_MIN_LEN - ETHER_CRC_LEN))\n\t\tpad = ETHER_MIN_LEN - ETHER_CRC_LEN - len;\n#endif\n\n\tlength = pad + len;\n\n\t/*\n\t * The MMU has a 256 byte page size.  The MMU expects us to\n\t * ask for \"npages - 1\".  We include space for the status word,\n\t * byte count, and control bytes in the allocation request.\n\t */\n\tnpages = (length + 6) >> 8;\n\n\t/*\n\t * Now allocate the memory.\n\t */\n\tSMC_SELECT_BANK(sc, 2);\n\tbus_space_write_2(bst, bsh, MMU_CMD_REG_W, MMUCR_ALLOC | npages);\n\n\ttimo = MEMORY_WAIT_TIME;\n\tdo {\n\t\tif (bus_space_read_1(bst, bsh, INTR_STAT_REG_B) & IM_ALLOC_INT)\n\t\t\tbreak;\n\t\tdelay(1);\n\t} while (--timo);\n\n\tpacketno = bus_space_read_1(bst, bsh, ALLOC_RESULT_REG_B);\n\n\tif (packetno & ARR_FAILED || timo == 0) {\n\t\t/*\n\t\t * No transmit memory is available.  Record the number\n\t\t * of requestd pages and enable the allocation completion\n\t\t * interrupt.  Set up the watchdog timer in case we miss\n\t\t * the interrupt.  Mark the interface as active so that\n\t\t * no one else attempts to transmit while we're allocating\n\t\t * memory.\n\t\t */\n\t\tbus_space_write_1(bst, bsh, INTR_MASK_REG_B,\n\t\t    bus_space_read_1(bst, bsh, INTR_MASK_REG_B) | IM_ALLOC_INT);\n\n\t\tifp->if_timer = 5;\n\t\tifp->if_flags |= IFF_OACTIVE;\n\n\t\treturn;\n\t}\n\n\t/*\n\t * We have a packet number - set the data window.\n\t */\n\tbus_space_write_1(bst, bsh, PACKET_NUM_REG_B, packetno);\n\n\t/*\n\t * Point to the beginning of the packet.\n\t */\n\tbus_space_write_2(bst, bsh, POINTER_REG_W, PTR_AUTOINC /* | 0x0000 */);\n\n\t/*\n\t * Send the packet length (+6 for stats, length, and control bytes)\n\t * and the status word (set to zeros).\n\t */\n\tbus_space_write_2(bst, bsh, DATA_REG_W, 0);\n\tbus_space_write_1(bst, bsh, DATA_REG_B, (length + 6) & 0xff);\n\tbus_space_write_1(bst, bsh, DATA_REG_B, ((length + 6) >> 8) & 0xff);\n\n\t/*\n\t * Get the packet from the kernel.  This will include the Ethernet\n\t * frame header, MAC address, etc.\n\t */\n\tIF_DEQUEUE(&ifp->if_snd, m);\n\n\t/*\n\t * Push the packet out to the card.\n\t */\n\tfor (top = m; m != NULL; m = m->m_next) {\n\t\t/* Words... */\n\t\tbus_space_write_multi_2(bst, bsh, DATA_REG_W,\n\t\t    mtod(m, u_int16_t *), m->m_len >> 1);\n\n\t\t/* ...and the remaining byte, if any. */\n\t\tif (m->m_len & 1)\n\t\t\tbus_space_write_1(bst, bsh, DATA_REG_B,\n\t\t\t  *(u_int8_t *)(mtod(m, u_int8_t *) + (m->m_len - 1)));\n\t}\n\n#ifdef SMC91CXX_SW_PAD\n\t/*\n\t * Push out padding.\n\t */\n\twhile (pad > 1) {\n\t\tbus_space_write_2(bst, bsh, DATA_REG_W, 0);\n\t\tpad -= 2;\n\t}\n\tif (pad)\n\t\tbus_space_write_1(bst, bsh, DATA_REG_B, 0);\n#endif\n\n\t/*\n\t * Push out control byte and unused packet byte.  The control byte\n\t * is 0, meaning the packet is even lengthed and no special\n\t * CRC handling is necessary.\n\t */\n\tbus_space_write_2(bst, bsh, DATA_REG_W, 0);\n\n\t/*\n\t * Enable transmit interrupts and let the chip go.  Set a watchdog\n\t * in case we miss the interrupt.\n\t */\n\tbus_space_write_1(bst, bsh, INTR_MASK_REG_B,\n\t    bus_space_read_1(bst, bsh, INTR_MASK_REG_B) |\n\t    IM_TX_INT | IM_TX_EMPTY_INT);\n\n\tbus_space_write_2(bst, bsh, MMU_CMD_REG_W, MMUCR_ENQUEUE);\n\n\tifp->if_timer = 5;\n\n#if NBPFILTER > 0\n\t/* Hand off a copy to the bpf. */\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, top);\n#endif\n\n\tifp->if_opackets++;\n\tm_freem(top);\n\n readcheck:\n\t/*\n\t * Check for incoming pcakets.  We don't want to overflow the small\n\t * RX FIFO.  If nothing has arrived, attempt to queue another\n\t * transmit packet.\n\t */\n\tif (bus_space_read_2(bst, bsh, FIFO_PORTS_REG_W) & FIFO_REMPTY)\n\t\tgoto again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smc91cxx_init",
          "args": [
            "sc"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "smc91cxx_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/smc91cxx.c",
          "lines": "361-469",
          "snippet": "void\nsmc91cxx_init(sc)\n\tstruct smc91cxx_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tu_int16_t tmp;\n\tint s, i;\n\n\ts = splnet();\n\n\t/*\n\t * This resets the registersmostly to defaults, but doesn't\n\t * affect the EEPROM.  After the reset cycle, we pause briefly\n\t * for the chip to recover.\n\t *\n\t * XXX how long are we really supposed to delay?  --thorpej\n\t */\n\tSMC_SELECT_BANK(sc, 0);\n\tbus_space_write_2(bst, bsh, RECV_CONTROL_REG_W, RCR_SOFTRESET);\n\tdelay(100);\n\tbus_space_write_2(bst, bsh, RECV_CONTROL_REG_W, 0);\n\tdelay(200);\n\n\tbus_space_write_2(bst, bsh, TXMIT_CONTROL_REG_W, 0);\n\n\t/* Set the Ethernet address. */\n\tSMC_SELECT_BANK(sc, 1);\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++ )\n\t\tbus_space_write_1(bst, bsh, IAR_ADDR0_REG_W + i,\n\t\t    sc->sc_arpcom.ac_enaddr[i]);\n\n\t/*\n\t * Set the control register to automatically release successfully\n\t * transmitted packets (making the best use of our limited memory)\n\t * and enable the EPH interrupt on certain TX errors.\n\t */\n\tbus_space_write_2(bst, bsh, CONTROL_REG_W, (CTR_AUTO_RELEASE |\n\t    CTR_TE_ENABLE | CTR_CR_ENABLE | CTR_LE_ENABLE));\n\n\t/*\n\t * Reset the MMU and wait for it to be un-busy.\n\t */\n\tSMC_SELECT_BANK(sc, 2);\n\tbus_space_write_2(bst, bsh, MMU_CMD_REG_W, MMUCR_RESET);\n\twhile (bus_space_read_2(bst, bsh, MMU_CMD_REG_W) & MMUCR_BUSY)\n\t\t/* XXX bound this loop! */ ;\n\n\t/*\n\t * Disable all interrupts.\n\t */\n\tbus_space_write_1(bst, bsh, INTR_MASK_REG_B, 0);\n\n\t/*\n\t * Set current media.\n\t */\n\tsmc91cxx_set_media(sc, sc->sc_media.ifm_cur->ifm_media);\n\n\t/*\n\t * Set the receive filter.  We want receive enable and auto\n\t * strip of CRC from received packet.  If we are in promisc. mode,\n\t * then set that bit as well.\n\t *\n\t * XXX Initialize multicast filter.  For now, we just accept\n\t * XXX all multicast.\n\t */\n\tSMC_SELECT_BANK(sc, 0);\n\n\ttmp = RCR_ENABLE | RCR_STRIP_CRC | RCR_ALMUL;\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\ttmp |= RCR_PROMISC;\n\n\tbus_space_write_2(bst, bsh, RECV_CONTROL_REG_W, tmp);\n\n\t/*\n\t * Set transmitter control to \"enabled\".\n\t */\n\ttmp = TCR_ENABLE;\n\n#ifndef SMC91CXX_SW_PAD\n\t/*\n\t * Enable hardware padding of transmitted packets.\n\t * XXX doesn't work?\n\t */\n\ttmp |= TCR_PAD_ENABLE;\n#endif\n\n\tbus_space_write_2(bst, bsh, TXMIT_CONTROL_REG_W, tmp);\n\n\t/*\n\t * Now, enable interrupts.\n\t */\n\tSMC_SELECT_BANK(sc, 2);\n\n\tbus_space_write_1(bst, bsh, INTR_MASK_REG_B,\n\t    IM_EPH_INT | IM_RX_OVRN_INT | IM_RCV_INT | IM_TX_INT);\n\n\t/* Interface is now running, with no output active. */\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t/*\n\t * Attempt to start any pending transmission.\n\t */\n\tsmc91cxx_start(ifp);\n\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/ic/smc91cxxvar.h>",
            "#include <dev/ic/smc91cxxreg.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netccitt/pk_extern.h>",
            "#include <netccitt/pk_var.h>",
            "#include <netccitt/pk.h>",
            "#include <netccitt/x25.h>",
            "#include <sys/socketvar.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/rnd.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define ETHER_ADDR_LEN\t\t6",
            "#define\tSMC91CXX_SW_PAD"
          ],
          "globals_used": [
            "int\tsmc91cxx_set_media",
            "void\tsmc91cxx_start"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/smc91cxxvar.h>\n#include <dev/ic/smc91cxxreg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netccitt/pk_extern.h>\n#include <netccitt/pk_var.h>\n#include <netccitt/pk.h>\n#include <netccitt/x25.h>\n#include <sys/socketvar.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/rnd.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define ETHER_ADDR_LEN\t\t6\n#define\tSMC91CXX_SW_PAD\n\nint\tsmc91cxx_set_media;\nvoid\tsmc91cxx_start;\n\nvoid\nsmc91cxx_init(sc)\n\tstruct smc91cxx_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tu_int16_t tmp;\n\tint s, i;\n\n\ts = splnet();\n\n\t/*\n\t * This resets the registersmostly to defaults, but doesn't\n\t * affect the EEPROM.  After the reset cycle, we pause briefly\n\t * for the chip to recover.\n\t *\n\t * XXX how long are we really supposed to delay?  --thorpej\n\t */\n\tSMC_SELECT_BANK(sc, 0);\n\tbus_space_write_2(bst, bsh, RECV_CONTROL_REG_W, RCR_SOFTRESET);\n\tdelay(100);\n\tbus_space_write_2(bst, bsh, RECV_CONTROL_REG_W, 0);\n\tdelay(200);\n\n\tbus_space_write_2(bst, bsh, TXMIT_CONTROL_REG_W, 0);\n\n\t/* Set the Ethernet address. */\n\tSMC_SELECT_BANK(sc, 1);\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++ )\n\t\tbus_space_write_1(bst, bsh, IAR_ADDR0_REG_W + i,\n\t\t    sc->sc_arpcom.ac_enaddr[i]);\n\n\t/*\n\t * Set the control register to automatically release successfully\n\t * transmitted packets (making the best use of our limited memory)\n\t * and enable the EPH interrupt on certain TX errors.\n\t */\n\tbus_space_write_2(bst, bsh, CONTROL_REG_W, (CTR_AUTO_RELEASE |\n\t    CTR_TE_ENABLE | CTR_CR_ENABLE | CTR_LE_ENABLE));\n\n\t/*\n\t * Reset the MMU and wait for it to be un-busy.\n\t */\n\tSMC_SELECT_BANK(sc, 2);\n\tbus_space_write_2(bst, bsh, MMU_CMD_REG_W, MMUCR_RESET);\n\twhile (bus_space_read_2(bst, bsh, MMU_CMD_REG_W) & MMUCR_BUSY)\n\t\t/* XXX bound this loop! */ ;\n\n\t/*\n\t * Disable all interrupts.\n\t */\n\tbus_space_write_1(bst, bsh, INTR_MASK_REG_B, 0);\n\n\t/*\n\t * Set current media.\n\t */\n\tsmc91cxx_set_media(sc, sc->sc_media.ifm_cur->ifm_media);\n\n\t/*\n\t * Set the receive filter.  We want receive enable and auto\n\t * strip of CRC from received packet.  If we are in promisc. mode,\n\t * then set that bit as well.\n\t *\n\t * XXX Initialize multicast filter.  For now, we just accept\n\t * XXX all multicast.\n\t */\n\tSMC_SELECT_BANK(sc, 0);\n\n\ttmp = RCR_ENABLE | RCR_STRIP_CRC | RCR_ALMUL;\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\ttmp |= RCR_PROMISC;\n\n\tbus_space_write_2(bst, bsh, RECV_CONTROL_REG_W, tmp);\n\n\t/*\n\t * Set transmitter control to \"enabled\".\n\t */\n\ttmp = TCR_ENABLE;\n\n#ifndef SMC91CXX_SW_PAD\n\t/*\n\t * Enable hardware padding of transmitted packets.\n\t * XXX doesn't work?\n\t */\n\ttmp |= TCR_PAD_ENABLE;\n#endif\n\n\tbus_space_write_2(bst, bsh, TXMIT_CONTROL_REG_W, tmp);\n\n\t/*\n\t * Now, enable interrupts.\n\t */\n\tSMC_SELECT_BANK(sc, 2);\n\n\tbus_space_write_1(bst, bsh, INTR_MASK_REG_B,\n\t    IM_EPH_INT | IM_RX_OVRN_INT | IM_RCV_INT | IM_TX_INT);\n\n\t/* Interface is now running, with no output active. */\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t/*\n\t * Attempt to start any pending transmission.\n\t */\n\tsmc91cxx_start(ifp);\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smc91cxx_stop",
          "args": [
            "sc"
          ],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "smc91cxx_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/smc91cxx.c",
          "lines": "1135-1159",
          "snippet": "void\nsmc91cxx_stop(sc)\n\tstruct smc91cxx_softc *sc;\n{\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\n\t/*\n\t * Clear interrupt mask; disable all interrupts.\n\t */\n\tSMC_SELECT_BANK(sc, 2);\n\tbus_space_write_1(bst, bsh, INTR_MASK_REG_B, 0);\n\n\t/*\n\t * Disable transmitter and receiver.\n\t */\n\tSMC_SELECT_BANK(sc, 0);\n\tbus_space_write_2(bst, bsh, RECV_CONTROL_REG_W, 0);\n\tbus_space_write_2(bst, bsh, TXMIT_CONTROL_REG_W, 0);\n\n\t/*\n\t * Cancel watchdog timer.\n\t */\n\tsc->sc_arpcom.ac_if.if_timer = 0;\n}",
          "includes": [
            "#include <dev/ic/smc91cxxvar.h>",
            "#include <dev/ic/smc91cxxreg.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netccitt/pk_extern.h>",
            "#include <netccitt/pk_var.h>",
            "#include <netccitt/pk.h>",
            "#include <netccitt/x25.h>",
            "#include <sys/socketvar.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/rnd.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/smc91cxxvar.h>\n#include <dev/ic/smc91cxxreg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netccitt/pk_extern.h>\n#include <netccitt/pk_var.h>\n#include <netccitt/pk.h>\n#include <netccitt/x25.h>\n#include <sys/socketvar.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/rnd.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\nsmc91cxx_stop(sc)\n\tstruct smc91cxx_softc *sc;\n{\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\n\t/*\n\t * Clear interrupt mask; disable all interrupts.\n\t */\n\tSMC_SELECT_BANK(sc, 2);\n\tbus_space_write_1(bst, bsh, INTR_MASK_REG_B, 0);\n\n\t/*\n\t * Disable transmitter and receiver.\n\t */\n\tSMC_SELECT_BANK(sc, 0);\n\tbus_space_write_2(bst, bsh, RECV_CONTROL_REG_W, 0);\n\tbus_space_write_2(bst, bsh, TXMIT_CONTROL_REG_W, 0);\n\n\t/*\n\t * Cancel watchdog timer.\n\t */\n\tsc->sc_arpcom.ac_if.if_timer = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SMC_SELECT_BANK",
          "args": [
            "sc",
            "2"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "bst",
            "bsh",
            "COUNTER_REG_W"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SMC_SELECT_BANK",
          "args": [
            "sc",
            "0"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "bst",
            "bsh",
            "INTR_ACK_REG_B",
            "IM_TX_EMPTY_INT"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "bst",
            "bsh",
            "MMU_CMD_REG_W",
            "MMUCR_FREEPKT"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "bst",
            "bsh",
            "MMU_CMD_REG_W"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SMC_SELECT_BANK",
          "args": [
            "sc",
            "2"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "bst",
            "bsh",
            "TXMIT_CONTROL_REG_W",
            "TCR_ENABLE | TCR_PAD_ENABLE"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "bst",
            "bsh",
            "TXMIT_CONTROL_REG_W",
            "TCR_ENABLE"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SMC_SELECT_BANK",
          "args": [
            "sc",
            "0"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: successful packet caused TX interrupt?!\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "bst",
            "bsh",
            "DATA_REG_W"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "bst",
            "bsh",
            "POINTER_REG_W",
            "PTR_AUTOINC | PTR_READ/* | 0x0000 */"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "bst",
            "bsh",
            "PACKET_NUM_REG_B",
            "packetno"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "bst",
            "bsh",
            "FIFO_PORTS_REG_W"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "bst",
            "bsh",
            "INTR_ACK_REG_B",
            "IM_TX_INT"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "bst",
            "bsh",
            "MMU_CMD_REG_W",
            "MMUCR_FREEPKT"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "bst",
            "bsh",
            "MMU_CMD_REG_W"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smc91cxx_read",
          "args": [
            "sc"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "smc91cxx_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/smc91cxx.c",
          "lines": "854-970",
          "snippet": "void\nsmc91cxx_read(sc)\n\tstruct smc91cxx_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tstruct ether_header *eh;\n\tstruct mbuf *m;\n\tu_int16_t status, packetno, packetlen;\n\tu_int8_t *data;\n\n again:\n\t/*\n\t * Set data pointer to the beginning of the packet.  Since\n\t * PTR_RCV is set, the packet number will be found automatically\n\t * in FIFO_PORTS_REG_W, FIFO_RX_MASK.\n\t */\n\tbus_space_write_2(bst, bsh, POINTER_REG_W,\n\t    PTR_READ | PTR_RCV | PTR_AUTOINC /* | 0x0000 */);\n\n\t/*\n\t * First two words are status and packet length.\n\t */\n\tstatus = bus_space_read_2(bst, bsh, DATA_REG_W);\n\tpacketlen = bus_space_read_2(bst, bsh, DATA_REG_W);\n\n\t/*\n\t * The packet length includes 3 extra words: status, length,\n\t * and an extra word that includes the control byte.\n\t */\n\tpacketlen -= 6;\n\n\t/*\n\t * Account for receive errors and discard.\n\t */\n\tif (status & RS_ERRORS) {\n\t\tifp->if_ierrors++;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Adjust for odd-length packet.\n\t */\n\tif (status & RS_ODDFRAME)\n\t\tpacketlen++;\n\n\t/*\n\t * Allocate a header mbuf.\n\t */\n\tMGETHDR(m, M_DONTWAIT, MT_DATA);\n\tif (m == NULL)\n\t\tgoto out;\n\n\tm->m_pkthdr.rcvif = ifp;\n\tm->m_pkthdr.len = m->m_len = packetlen;\n\n\t/*\n\t * Always put the packet in a cluster.\n\t * XXX should chain small mbufs if less than threshold.\n\t */\n\tMCLGET(m, M_DONTWAIT);\n\tif ((m->m_flags & M_EXT) == 0) {\n\t\tm_freem(m);\n\t\tifp->if_ierrors++;\n\t\tprintf(\"%s: can't allocate cluster for incoming packet\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Pull the packet off the interface.\n\t */\n\teh = mtod(m, struct ether_header *);\n\tdata = mtod(m, u_int8_t *);\n\tbus_space_read_multi_2(bst, bsh, DATA_REG_W, (u_int16_t *)data,\n\t    packetlen >> 1);\n\tif (packetlen & 1) {\n\t\tdata += packetlen & ~1;\n\t\t*data = bus_space_read_1(bst, bsh, DATA_REG_B);\n\t}\n\n\tifp->if_ipackets++;\n\n#if NBPFILTER > 0\n\t/*\n\t * Hand the packet off to bpf listeners.  If there's a bpf listener,\n\t * we need to check if the packet is ours.\n\t */\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\n\t/*\n\t * Strip the ethernet header.\n\t */\n\tm->m_pkthdr.len = m->m_len = packetlen - sizeof(struct ether_header);\n\tm->m_data += sizeof(struct ether_header);\n\n\tether_input(ifp, eh, m);\n\n out:\n\t/*\n\t * Tell the card to free the memory occupied by this packet.\n\t */\n\twhile (bus_space_read_2(bst, bsh, MMU_CMD_REG_W) & MMUCR_BUSY)\n\t\t/* XXX bound this loop! */ ;\n\tbus_space_write_2(bst, bsh, MMU_CMD_REG_W, MMUCR_RELEASE);\n\n\t/*\n\t * Check for another packet.\n\t */\n\tpacketno = bus_space_read_2(bst, bsh, FIFO_PORTS_REG_W);\n\tif (packetno & FIFO_REMPTY)\n\t\treturn;\n\tgoto again;\n}",
          "includes": [
            "#include <dev/ic/smc91cxxvar.h>",
            "#include <dev/ic/smc91cxxreg.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netccitt/pk_extern.h>",
            "#include <netccitt/pk_var.h>",
            "#include <netccitt/pk.h>",
            "#include <netccitt/x25.h>",
            "#include <sys/socketvar.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/rnd.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsmc91cxx_read"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/smc91cxxvar.h>\n#include <dev/ic/smc91cxxreg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netccitt/pk_extern.h>\n#include <netccitt/pk_var.h>\n#include <netccitt/pk.h>\n#include <netccitt/x25.h>\n#include <sys/socketvar.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/rnd.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\tsmc91cxx_read;\n\nvoid\nsmc91cxx_read(sc)\n\tstruct smc91cxx_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tstruct ether_header *eh;\n\tstruct mbuf *m;\n\tu_int16_t status, packetno, packetlen;\n\tu_int8_t *data;\n\n again:\n\t/*\n\t * Set data pointer to the beginning of the packet.  Since\n\t * PTR_RCV is set, the packet number will be found automatically\n\t * in FIFO_PORTS_REG_W, FIFO_RX_MASK.\n\t */\n\tbus_space_write_2(bst, bsh, POINTER_REG_W,\n\t    PTR_READ | PTR_RCV | PTR_AUTOINC /* | 0x0000 */);\n\n\t/*\n\t * First two words are status and packet length.\n\t */\n\tstatus = bus_space_read_2(bst, bsh, DATA_REG_W);\n\tpacketlen = bus_space_read_2(bst, bsh, DATA_REG_W);\n\n\t/*\n\t * The packet length includes 3 extra words: status, length,\n\t * and an extra word that includes the control byte.\n\t */\n\tpacketlen -= 6;\n\n\t/*\n\t * Account for receive errors and discard.\n\t */\n\tif (status & RS_ERRORS) {\n\t\tifp->if_ierrors++;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Adjust for odd-length packet.\n\t */\n\tif (status & RS_ODDFRAME)\n\t\tpacketlen++;\n\n\t/*\n\t * Allocate a header mbuf.\n\t */\n\tMGETHDR(m, M_DONTWAIT, MT_DATA);\n\tif (m == NULL)\n\t\tgoto out;\n\n\tm->m_pkthdr.rcvif = ifp;\n\tm->m_pkthdr.len = m->m_len = packetlen;\n\n\t/*\n\t * Always put the packet in a cluster.\n\t * XXX should chain small mbufs if less than threshold.\n\t */\n\tMCLGET(m, M_DONTWAIT);\n\tif ((m->m_flags & M_EXT) == 0) {\n\t\tm_freem(m);\n\t\tifp->if_ierrors++;\n\t\tprintf(\"%s: can't allocate cluster for incoming packet\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Pull the packet off the interface.\n\t */\n\teh = mtod(m, struct ether_header *);\n\tdata = mtod(m, u_int8_t *);\n\tbus_space_read_multi_2(bst, bsh, DATA_REG_W, (u_int16_t *)data,\n\t    packetlen >> 1);\n\tif (packetlen & 1) {\n\t\tdata += packetlen & ~1;\n\t\t*data = bus_space_read_1(bst, bsh, DATA_REG_B);\n\t}\n\n\tifp->if_ipackets++;\n\n#if NBPFILTER > 0\n\t/*\n\t * Hand the packet off to bpf listeners.  If there's a bpf listener,\n\t * we need to check if the packet is ours.\n\t */\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\n\t/*\n\t * Strip the ethernet header.\n\t */\n\tm->m_pkthdr.len = m->m_len = packetlen - sizeof(struct ether_header);\n\tm->m_data += sizeof(struct ether_header);\n\n\tether_input(ifp, eh, m);\n\n out:\n\t/*\n\t * Tell the card to free the memory occupied by this packet.\n\t */\n\twhile (bus_space_read_2(bst, bsh, MMU_CMD_REG_W) & MMUCR_BUSY)\n\t\t/* XXX bound this loop! */ ;\n\tbus_space_write_2(bst, bsh, MMU_CMD_REG_W, MMUCR_RELEASE);\n\n\t/*\n\t * Check for another packet.\n\t */\n\tpacketno = bus_space_read_2(bst, bsh, FIFO_PORTS_REG_W);\n\tif (packetno & FIFO_REMPTY)\n\t\treturn;\n\tgoto again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "bst",
            "bsh",
            "FIFO_PORTS_REG_W"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "bst",
            "bsh",
            "INTR_ACK_REG_B",
            "IM_RX_OVRN_INT"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "bst",
            "bsh",
            "INTR_MASK_REG_B",
            "0"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "bst",
            "bsh",
            "INTR_STAT_REG_B"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "bst",
            "bsh",
            "INTR_MASK_REG_B"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SMC_SELECT_BANK",
          "args": [
            "sc",
            "2"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/smc91cxxvar.h>\n#include <dev/ic/smc91cxxreg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netccitt/pk_extern.h>\n#include <netccitt/pk_var.h>\n#include <netccitt/pk.h>\n#include <netccitt/x25.h>\n#include <sys/socketvar.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/rnd.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tSMC91CXX_SW_PAD\n\nvoid\tsmc91cxx_read;\nvoid\tsmc91cxx_start;\n\nint\nsmc91cxx_intr(arg)\n\tvoid *arg;\n{\n\tstruct smc91cxx_softc *sc = arg;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tu_int8_t mask, interrupts, status;\n\tu_int16_t packetno, tx_status, card_stats;\n\n\tif (sc->sc_enabled == 0)\n\t\treturn (0);\n\n\tSMC_SELECT_BANK(sc, 2);\n\n\t/*\n\t * Obtain the current interrupt mask.\n\t */\n\tmask = bus_space_read_1(bst, bsh, INTR_MASK_REG_B);\n\n\t/*\n\t * Get the set of interrupt which occurred and eliminate any\n\t * which are not enabled.\n\t */\n\tinterrupts = bus_space_read_1(bst, bsh, INTR_STAT_REG_B);\n\tstatus = interrupts & mask;\n\n\t/* Ours? */\n\tif (status == 0)\n\t\treturn (0);\n\n\t/*\n\t * It's ours; disable all interrupts while we process them.\n\t */\n\tbus_space_write_1(bst, bsh, INTR_MASK_REG_B, 0);\n\n\t/*\n\t * Receive overrun interrupts.\n\t */\n\tif (status & IM_RX_OVRN_INT) {\n\t\tbus_space_write_1(bst, bsh, INTR_ACK_REG_B, IM_RX_OVRN_INT);\n\t\tifp->if_ierrors++;\n\t}\n\n\t/*\n\t * Receive interrupts.\n\t */\n\tif (status & IM_RCV_INT) {\n#if 1 /* DIAGNOSTIC */\n\t\tpacketno = bus_space_read_2(bst, bsh, FIFO_PORTS_REG_W);\n\t\tif (packetno & FIFO_REMPTY)\n\t\t\tprintf(\"%s: receive interrupt on empty fifo\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\telse\n#endif\n\t\tsmc91cxx_read(sc);\n\t}\n\n\t/*\n\t * Memory allocation interrupts.\n\t */\n\tif (status & IM_ALLOC_INT) {\n\t\t/* Disable this interrupt. */\n\t\tmask &= ~IM_ALLOC_INT;\n\n\t\t/*\n\t\t * Release the just-allocated memory.  We will reallocate\n\t\t * it through the normal start logic.\n\t\t */\n\t\twhile (bus_space_read_2(bst, bsh, MMU_CMD_REG_W) & MMUCR_BUSY)\n\t\t\t/* XXX bound this loop! */ ;\n\t\tbus_space_write_2(bst, bsh, MMU_CMD_REG_W, MMUCR_FREEPKT);\n\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\t\tifp->if_timer = 0;\n\t}\n\n\t/*\n\t * Transmit complete interrupt.  Handle transmission error messages.\n\t * This will only be called on error condition because of AUTO RELEASE\n\t * mode.\n\t */\n\tif (status & IM_TX_INT) {\n\t\tbus_space_write_1(bst, bsh, INTR_ACK_REG_B, IM_TX_INT);\n\n\t\tpacketno = bus_space_read_2(bst, bsh, FIFO_PORTS_REG_W) &\n\t\t    FIFO_TX_MASK;\n\n\t\t/*\n\t\t * Select this as the packet to read from.\n\t\t */\n\t\tbus_space_write_1(bst, bsh, PACKET_NUM_REG_B, packetno);\n\n\t\t/*\n\t\t * Position the pointer to the beginning of the packet.\n\t\t */\n\t\tbus_space_write_2(bst, bsh, POINTER_REG_W,\n\t\t    PTR_AUTOINC | PTR_READ /* | 0x0000 */);\n\n\t\t/*\n\t\t * Fetch the TX status word.  This will be a copy of\n\t\t * the EPH_STATUS_REG_W at the time of the transmission\n\t\t * failure.\n\t\t */\n\t\ttx_status = bus_space_read_2(bst, bsh, DATA_REG_W);\n\n\t\tif (tx_status & EPHSR_TX_SUC)\n\t\t\tprintf(\"%s: successful packet caused TX interrupt?!\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\telse\n\t\t\tifp->if_oerrors++;\n\n\t\tif (tx_status & EPHSR_LATCOL)\n\t\t\tifp->if_collisions++;\n\n\t\t/*\n\t\t * Some of these errors disable the transmitter; reenable it.\n\t\t */\n\t\tSMC_SELECT_BANK(sc, 0);\n#ifdef SMC91CXX_SW_PAD\n\t\tbus_space_write_2(bst, bsh, TXMIT_CONTROL_REG_W, TCR_ENABLE);\n#else\n\t\tbus_space_write_2(bst, bsh, TXMIT_CONTROL_REG_W,\n\t\t    TCR_ENABLE | TCR_PAD_ENABLE);\n#endif\n\n\t\t/*\n\t\t * Kill the failed packet and wait for the MMU to unbusy.\n\t\t */\n\t\tSMC_SELECT_BANK(sc, 2);\n\t\twhile (bus_space_read_2(bst, bsh, MMU_CMD_REG_W) & MMUCR_BUSY)\n\t\t\t/* XXX bound this loop! */ ;\n\t\tbus_space_write_2(bst, bsh, MMU_CMD_REG_W, MMUCR_FREEPKT);\n\n\t\tifp->if_timer = 0;\n\t}\n\n\t/*\n\t * Transmit underrun interrupts.  We use this opportunity to\n\t * update transmit statistics from the card.\n\t */\n\tif (status & IM_TX_EMPTY_INT) {\n\t\tbus_space_write_1(bst, bsh, INTR_ACK_REG_B, IM_TX_EMPTY_INT);\n\n\t\t/* Disable this interrupt. */\n\t\tmask &= ~IM_TX_EMPTY_INT;\n\n\t\tSMC_SELECT_BANK(sc, 0);\n\t\tcard_stats = bus_space_read_2(bst, bsh, COUNTER_REG_W);\n\n\t\t/* Single collisions. */\n\t\tifp->if_collisions += card_stats & ECR_COLN_MASK;\n\n\t\t/* Multiple collisions. */\n\t\tifp->if_collisions += (card_stats & ECR_MCOLN_MASK) >> 4;\n\n\t\tSMC_SELECT_BANK(sc, 2);\n\n\t\tifp->if_timer = 0;\n\t}\n\n\t/*\n\t * Other errors.  Reset the interface.\n\t */\n\tif (status & IM_EPH_INT) {\n\t\tsmc91cxx_stop(sc);\n\t\tsmc91cxx_init(sc);\n\t}\n\n\t/*\n\t * Attempt to queue more packets for transmission.\n\t */\n\tsmc91cxx_start(ifp);\n\n\t/*\n\t * Reenable the interrupts we wish to receive now that processing\n\t * is complete.\n\t */\n\tmask |= bus_space_read_1(bst, bsh, INTR_MASK_REG_B);\n\tbus_space_write_1(bst, bsh, INTR_MASK_REG_B, mask);\n\n#if NRND > 0\n\tif (status)\n\t\trnd_add_uint32(&sc->rnd_source, status);\n#endif\n\n\treturn (1);\n}"
  },
  {
    "function_name": "smc91cxx_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/smc91cxx.c",
    "lines": "475-655",
    "snippet": "void\nsmc91cxx_start(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct smc91cxx_softc *sc = ifp->if_softc;\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tu_int len;\n\tstruct mbuf *m, *top;\n\tu_int16_t length, npages;\n\tu_int8_t packetno;\n\tint timo, pad;\n\n\tif ((ifp->if_flags & (IFF_RUNNING|IFF_OACTIVE)) != IFF_RUNNING)\n\t\treturn;\n\n again:\n\t/*\n\t * Peek at the next packet.\n\t */\n\tif ((m = ifp->if_snd.ifq_head) == NULL)\n\t\treturn;\n\n\t/*\n\t * Compute the frame length and set pad to give an overall even\n\t * number of bytes.  Below, we assume that the packet length\n\t * is even.\n\t */\n\tfor (len = 0, top = m; m != NULL; m = m->m_next)\n\t\tlen += m->m_len;\n\tpad = (len & 1);\n\n\t/*\n\t * We drop packets that are too large.  Perhaps we should\n\t * truncate them instead?\n\t */\n\tif ((len + pad) > (ETHER_MAX_LEN - ETHER_CRC_LEN)) {\n\t\tprintf(\"%s: large packet discarded\\n\", sc->sc_dev.dv_xname);\n\t\tifp->if_oerrors++;\n\t\tIF_DEQUEUE(&ifp->if_snd, m);\n\t\tm_freem(m);\n\t\tgoto readcheck;\n\t}\n\n#ifdef SMC91CXX_SW_PAD\n\t/*\n\t * Not using hardware padding; pad to ETHER_MIN_LEN.\n\t */\n\tif (len < (ETHER_MIN_LEN - ETHER_CRC_LEN))\n\t\tpad = ETHER_MIN_LEN - ETHER_CRC_LEN - len;\n#endif\n\n\tlength = pad + len;\n\n\t/*\n\t * The MMU has a 256 byte page size.  The MMU expects us to\n\t * ask for \"npages - 1\".  We include space for the status word,\n\t * byte count, and control bytes in the allocation request.\n\t */\n\tnpages = (length + 6) >> 8;\n\n\t/*\n\t * Now allocate the memory.\n\t */\n\tSMC_SELECT_BANK(sc, 2);\n\tbus_space_write_2(bst, bsh, MMU_CMD_REG_W, MMUCR_ALLOC | npages);\n\n\ttimo = MEMORY_WAIT_TIME;\n\tdo {\n\t\tif (bus_space_read_1(bst, bsh, INTR_STAT_REG_B) & IM_ALLOC_INT)\n\t\t\tbreak;\n\t\tdelay(1);\n\t} while (--timo);\n\n\tpacketno = bus_space_read_1(bst, bsh, ALLOC_RESULT_REG_B);\n\n\tif (packetno & ARR_FAILED || timo == 0) {\n\t\t/*\n\t\t * No transmit memory is available.  Record the number\n\t\t * of requestd pages and enable the allocation completion\n\t\t * interrupt.  Set up the watchdog timer in case we miss\n\t\t * the interrupt.  Mark the interface as active so that\n\t\t * no one else attempts to transmit while we're allocating\n\t\t * memory.\n\t\t */\n\t\tbus_space_write_1(bst, bsh, INTR_MASK_REG_B,\n\t\t    bus_space_read_1(bst, bsh, INTR_MASK_REG_B) | IM_ALLOC_INT);\n\n\t\tifp->if_timer = 5;\n\t\tifp->if_flags |= IFF_OACTIVE;\n\n\t\treturn;\n\t}\n\n\t/*\n\t * We have a packet number - set the data window.\n\t */\n\tbus_space_write_1(bst, bsh, PACKET_NUM_REG_B, packetno);\n\n\t/*\n\t * Point to the beginning of the packet.\n\t */\n\tbus_space_write_2(bst, bsh, POINTER_REG_W, PTR_AUTOINC /* | 0x0000 */);\n\n\t/*\n\t * Send the packet length (+6 for stats, length, and control bytes)\n\t * and the status word (set to zeros).\n\t */\n\tbus_space_write_2(bst, bsh, DATA_REG_W, 0);\n\tbus_space_write_1(bst, bsh, DATA_REG_B, (length + 6) & 0xff);\n\tbus_space_write_1(bst, bsh, DATA_REG_B, ((length + 6) >> 8) & 0xff);\n\n\t/*\n\t * Get the packet from the kernel.  This will include the Ethernet\n\t * frame header, MAC address, etc.\n\t */\n\tIF_DEQUEUE(&ifp->if_snd, m);\n\n\t/*\n\t * Push the packet out to the card.\n\t */\n\tfor (top = m; m != NULL; m = m->m_next) {\n\t\t/* Words... */\n\t\tbus_space_write_multi_2(bst, bsh, DATA_REG_W,\n\t\t    mtod(m, u_int16_t *), m->m_len >> 1);\n\n\t\t/* ...and the remaining byte, if any. */\n\t\tif (m->m_len & 1)\n\t\t\tbus_space_write_1(bst, bsh, DATA_REG_B,\n\t\t\t  *(u_int8_t *)(mtod(m, u_int8_t *) + (m->m_len - 1)));\n\t}\n\n#ifdef SMC91CXX_SW_PAD\n\t/*\n\t * Push out padding.\n\t */\n\twhile (pad > 1) {\n\t\tbus_space_write_2(bst, bsh, DATA_REG_W, 0);\n\t\tpad -= 2;\n\t}\n\tif (pad)\n\t\tbus_space_write_1(bst, bsh, DATA_REG_B, 0);\n#endif\n\n\t/*\n\t * Push out control byte and unused packet byte.  The control byte\n\t * is 0, meaning the packet is even lengthed and no special\n\t * CRC handling is necessary.\n\t */\n\tbus_space_write_2(bst, bsh, DATA_REG_W, 0);\n\n\t/*\n\t * Enable transmit interrupts and let the chip go.  Set a watchdog\n\t * in case we miss the interrupt.\n\t */\n\tbus_space_write_1(bst, bsh, INTR_MASK_REG_B,\n\t    bus_space_read_1(bst, bsh, INTR_MASK_REG_B) |\n\t    IM_TX_INT | IM_TX_EMPTY_INT);\n\n\tbus_space_write_2(bst, bsh, MMU_CMD_REG_W, MMUCR_ENQUEUE);\n\n\tifp->if_timer = 5;\n\n#if NBPFILTER > 0\n\t/* Hand off a copy to the bpf. */\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, top);\n#endif\n\n\tifp->if_opackets++;\n\tm_freem(top);\n\n readcheck:\n\t/*\n\t * Check for incoming pcakets.  We don't want to overflow the small\n\t * RX FIFO.  If nothing has arrived, attempt to queue another\n\t * transmit packet.\n\t */\n\tif (bus_space_read_2(bst, bsh, FIFO_PORTS_REG_W) & FIFO_REMPTY)\n\t\tgoto again;\n}",
    "includes": [
      "#include <dev/ic/smc91cxxvar.h>",
      "#include <dev/ic/smc91cxxreg.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netccitt/pk_extern.h>",
      "#include <netccitt/pk_var.h>",
      "#include <netccitt/pk.h>",
      "#include <netccitt/x25.h>",
      "#include <sys/socketvar.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/rnd.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define\tETHER_CRC_LEN\t4",
      "#define\tETHER_MIN_LEN\t64",
      "#define\tETHER_MAX_LEN\t1518",
      "#define\tSMC91CXX_SW_PAD"
    ],
    "globals_used": [
      "void\tsmc91cxx_start"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "bst",
            "bsh",
            "FIFO_PORTS_REG_W"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "top"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_mtap",
          "args": [
            "ifp->if_bpf",
            "top"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "bst",
            "bsh",
            "MMU_CMD_REG_W",
            "MMUCR_ENQUEUE"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "bst",
            "bsh",
            "INTR_MASK_REG_B",
            "bus_space_read_1(bst, bsh, INTR_MASK_REG_B) |\n\t    IM_TX_INT | IM_TX_EMPTY_INT"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "bst",
            "bsh",
            "INTR_MASK_REG_B"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "bst",
            "bsh",
            "DATA_REG_W",
            "0"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "bst",
            "bsh",
            "DATA_REG_B",
            "0"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "bst",
            "bsh",
            "DATA_REG_W",
            "0"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "bst",
            "bsh",
            "DATA_REG_B",
            "*(u_int8_t *)(mtod(m, u_int8_t *) + (m->m_len - 1))"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_multi_2",
          "args": [
            "bst",
            "bsh",
            "DATA_REG_W",
            "mtod(m, u_int16_t *)",
            "m->m_len >> 1"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "u_int16_t*"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_DEQUEUE",
          "args": [
            "&ifp->if_snd",
            "m"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "bst",
            "bsh",
            "DATA_REG_B",
            "((length + 6) >> 8) & 0xff"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "bst",
            "bsh",
            "DATA_REG_B",
            "(length + 6) & 0xff"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "bst",
            "bsh",
            "DATA_REG_W",
            "0"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "bst",
            "bsh",
            "POINTER_REG_W",
            "PTR_AUTOINC/* | 0x0000 */"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "bst",
            "bsh",
            "PACKET_NUM_REG_B",
            "packetno"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "bst",
            "bsh",
            "INTR_MASK_REG_B",
            "bus_space_read_1(bst, bsh, INTR_MASK_REG_B) | IM_ALLOC_INT"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "bst",
            "bsh",
            "INTR_MASK_REG_B"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "bst",
            "bsh",
            "ALLOC_RESULT_REG_B"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "1"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "dc_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "215-222",
          "snippet": "void dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_delay"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_delay;\n\nvoid dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "bst",
            "bsh",
            "INTR_STAT_REG_B"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "bst",
            "bsh",
            "MMU_CMD_REG_W",
            "MMUCR_ALLOC | npages"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SMC_SELECT_BANK",
          "args": [
            "sc",
            "2"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_DEQUEUE",
          "args": [
            "&ifp->if_snd",
            "m"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: large packet discarded\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/smc91cxxvar.h>\n#include <dev/ic/smc91cxxreg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netccitt/pk_extern.h>\n#include <netccitt/pk_var.h>\n#include <netccitt/pk.h>\n#include <netccitt/x25.h>\n#include <sys/socketvar.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/rnd.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tETHER_CRC_LEN\t4\n#define\tETHER_MIN_LEN\t64\n#define\tETHER_MAX_LEN\t1518\n#define\tSMC91CXX_SW_PAD\n\nvoid\tsmc91cxx_start;\n\nvoid\nsmc91cxx_start(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct smc91cxx_softc *sc = ifp->if_softc;\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tu_int len;\n\tstruct mbuf *m, *top;\n\tu_int16_t length, npages;\n\tu_int8_t packetno;\n\tint timo, pad;\n\n\tif ((ifp->if_flags & (IFF_RUNNING|IFF_OACTIVE)) != IFF_RUNNING)\n\t\treturn;\n\n again:\n\t/*\n\t * Peek at the next packet.\n\t */\n\tif ((m = ifp->if_snd.ifq_head) == NULL)\n\t\treturn;\n\n\t/*\n\t * Compute the frame length and set pad to give an overall even\n\t * number of bytes.  Below, we assume that the packet length\n\t * is even.\n\t */\n\tfor (len = 0, top = m; m != NULL; m = m->m_next)\n\t\tlen += m->m_len;\n\tpad = (len & 1);\n\n\t/*\n\t * We drop packets that are too large.  Perhaps we should\n\t * truncate them instead?\n\t */\n\tif ((len + pad) > (ETHER_MAX_LEN - ETHER_CRC_LEN)) {\n\t\tprintf(\"%s: large packet discarded\\n\", sc->sc_dev.dv_xname);\n\t\tifp->if_oerrors++;\n\t\tIF_DEQUEUE(&ifp->if_snd, m);\n\t\tm_freem(m);\n\t\tgoto readcheck;\n\t}\n\n#ifdef SMC91CXX_SW_PAD\n\t/*\n\t * Not using hardware padding; pad to ETHER_MIN_LEN.\n\t */\n\tif (len < (ETHER_MIN_LEN - ETHER_CRC_LEN))\n\t\tpad = ETHER_MIN_LEN - ETHER_CRC_LEN - len;\n#endif\n\n\tlength = pad + len;\n\n\t/*\n\t * The MMU has a 256 byte page size.  The MMU expects us to\n\t * ask for \"npages - 1\".  We include space for the status word,\n\t * byte count, and control bytes in the allocation request.\n\t */\n\tnpages = (length + 6) >> 8;\n\n\t/*\n\t * Now allocate the memory.\n\t */\n\tSMC_SELECT_BANK(sc, 2);\n\tbus_space_write_2(bst, bsh, MMU_CMD_REG_W, MMUCR_ALLOC | npages);\n\n\ttimo = MEMORY_WAIT_TIME;\n\tdo {\n\t\tif (bus_space_read_1(bst, bsh, INTR_STAT_REG_B) & IM_ALLOC_INT)\n\t\t\tbreak;\n\t\tdelay(1);\n\t} while (--timo);\n\n\tpacketno = bus_space_read_1(bst, bsh, ALLOC_RESULT_REG_B);\n\n\tif (packetno & ARR_FAILED || timo == 0) {\n\t\t/*\n\t\t * No transmit memory is available.  Record the number\n\t\t * of requestd pages and enable the allocation completion\n\t\t * interrupt.  Set up the watchdog timer in case we miss\n\t\t * the interrupt.  Mark the interface as active so that\n\t\t * no one else attempts to transmit while we're allocating\n\t\t * memory.\n\t\t */\n\t\tbus_space_write_1(bst, bsh, INTR_MASK_REG_B,\n\t\t    bus_space_read_1(bst, bsh, INTR_MASK_REG_B) | IM_ALLOC_INT);\n\n\t\tifp->if_timer = 5;\n\t\tifp->if_flags |= IFF_OACTIVE;\n\n\t\treturn;\n\t}\n\n\t/*\n\t * We have a packet number - set the data window.\n\t */\n\tbus_space_write_1(bst, bsh, PACKET_NUM_REG_B, packetno);\n\n\t/*\n\t * Point to the beginning of the packet.\n\t */\n\tbus_space_write_2(bst, bsh, POINTER_REG_W, PTR_AUTOINC /* | 0x0000 */);\n\n\t/*\n\t * Send the packet length (+6 for stats, length, and control bytes)\n\t * and the status word (set to zeros).\n\t */\n\tbus_space_write_2(bst, bsh, DATA_REG_W, 0);\n\tbus_space_write_1(bst, bsh, DATA_REG_B, (length + 6) & 0xff);\n\tbus_space_write_1(bst, bsh, DATA_REG_B, ((length + 6) >> 8) & 0xff);\n\n\t/*\n\t * Get the packet from the kernel.  This will include the Ethernet\n\t * frame header, MAC address, etc.\n\t */\n\tIF_DEQUEUE(&ifp->if_snd, m);\n\n\t/*\n\t * Push the packet out to the card.\n\t */\n\tfor (top = m; m != NULL; m = m->m_next) {\n\t\t/* Words... */\n\t\tbus_space_write_multi_2(bst, bsh, DATA_REG_W,\n\t\t    mtod(m, u_int16_t *), m->m_len >> 1);\n\n\t\t/* ...and the remaining byte, if any. */\n\t\tif (m->m_len & 1)\n\t\t\tbus_space_write_1(bst, bsh, DATA_REG_B,\n\t\t\t  *(u_int8_t *)(mtod(m, u_int8_t *) + (m->m_len - 1)));\n\t}\n\n#ifdef SMC91CXX_SW_PAD\n\t/*\n\t * Push out padding.\n\t */\n\twhile (pad > 1) {\n\t\tbus_space_write_2(bst, bsh, DATA_REG_W, 0);\n\t\tpad -= 2;\n\t}\n\tif (pad)\n\t\tbus_space_write_1(bst, bsh, DATA_REG_B, 0);\n#endif\n\n\t/*\n\t * Push out control byte and unused packet byte.  The control byte\n\t * is 0, meaning the packet is even lengthed and no special\n\t * CRC handling is necessary.\n\t */\n\tbus_space_write_2(bst, bsh, DATA_REG_W, 0);\n\n\t/*\n\t * Enable transmit interrupts and let the chip go.  Set a watchdog\n\t * in case we miss the interrupt.\n\t */\n\tbus_space_write_1(bst, bsh, INTR_MASK_REG_B,\n\t    bus_space_read_1(bst, bsh, INTR_MASK_REG_B) |\n\t    IM_TX_INT | IM_TX_EMPTY_INT);\n\n\tbus_space_write_2(bst, bsh, MMU_CMD_REG_W, MMUCR_ENQUEUE);\n\n\tifp->if_timer = 5;\n\n#if NBPFILTER > 0\n\t/* Hand off a copy to the bpf. */\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, top);\n#endif\n\n\tifp->if_opackets++;\n\tm_freem(top);\n\n readcheck:\n\t/*\n\t * Check for incoming pcakets.  We don't want to overflow the small\n\t * RX FIFO.  If nothing has arrived, attempt to queue another\n\t * transmit packet.\n\t */\n\tif (bus_space_read_2(bst, bsh, FIFO_PORTS_REG_W) & FIFO_REMPTY)\n\t\tgoto again;\n}"
  },
  {
    "function_name": "smc91cxx_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/smc91cxx.c",
    "lines": "361-469",
    "snippet": "void\nsmc91cxx_init(sc)\n\tstruct smc91cxx_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tu_int16_t tmp;\n\tint s, i;\n\n\ts = splnet();\n\n\t/*\n\t * This resets the registersmostly to defaults, but doesn't\n\t * affect the EEPROM.  After the reset cycle, we pause briefly\n\t * for the chip to recover.\n\t *\n\t * XXX how long are we really supposed to delay?  --thorpej\n\t */\n\tSMC_SELECT_BANK(sc, 0);\n\tbus_space_write_2(bst, bsh, RECV_CONTROL_REG_W, RCR_SOFTRESET);\n\tdelay(100);\n\tbus_space_write_2(bst, bsh, RECV_CONTROL_REG_W, 0);\n\tdelay(200);\n\n\tbus_space_write_2(bst, bsh, TXMIT_CONTROL_REG_W, 0);\n\n\t/* Set the Ethernet address. */\n\tSMC_SELECT_BANK(sc, 1);\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++ )\n\t\tbus_space_write_1(bst, bsh, IAR_ADDR0_REG_W + i,\n\t\t    sc->sc_arpcom.ac_enaddr[i]);\n\n\t/*\n\t * Set the control register to automatically release successfully\n\t * transmitted packets (making the best use of our limited memory)\n\t * and enable the EPH interrupt on certain TX errors.\n\t */\n\tbus_space_write_2(bst, bsh, CONTROL_REG_W, (CTR_AUTO_RELEASE |\n\t    CTR_TE_ENABLE | CTR_CR_ENABLE | CTR_LE_ENABLE));\n\n\t/*\n\t * Reset the MMU and wait for it to be un-busy.\n\t */\n\tSMC_SELECT_BANK(sc, 2);\n\tbus_space_write_2(bst, bsh, MMU_CMD_REG_W, MMUCR_RESET);\n\twhile (bus_space_read_2(bst, bsh, MMU_CMD_REG_W) & MMUCR_BUSY)\n\t\t/* XXX bound this loop! */ ;\n\n\t/*\n\t * Disable all interrupts.\n\t */\n\tbus_space_write_1(bst, bsh, INTR_MASK_REG_B, 0);\n\n\t/*\n\t * Set current media.\n\t */\n\tsmc91cxx_set_media(sc, sc->sc_media.ifm_cur->ifm_media);\n\n\t/*\n\t * Set the receive filter.  We want receive enable and auto\n\t * strip of CRC from received packet.  If we are in promisc. mode,\n\t * then set that bit as well.\n\t *\n\t * XXX Initialize multicast filter.  For now, we just accept\n\t * XXX all multicast.\n\t */\n\tSMC_SELECT_BANK(sc, 0);\n\n\ttmp = RCR_ENABLE | RCR_STRIP_CRC | RCR_ALMUL;\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\ttmp |= RCR_PROMISC;\n\n\tbus_space_write_2(bst, bsh, RECV_CONTROL_REG_W, tmp);\n\n\t/*\n\t * Set transmitter control to \"enabled\".\n\t */\n\ttmp = TCR_ENABLE;\n\n#ifndef SMC91CXX_SW_PAD\n\t/*\n\t * Enable hardware padding of transmitted packets.\n\t * XXX doesn't work?\n\t */\n\ttmp |= TCR_PAD_ENABLE;\n#endif\n\n\tbus_space_write_2(bst, bsh, TXMIT_CONTROL_REG_W, tmp);\n\n\t/*\n\t * Now, enable interrupts.\n\t */\n\tSMC_SELECT_BANK(sc, 2);\n\n\tbus_space_write_1(bst, bsh, INTR_MASK_REG_B,\n\t    IM_EPH_INT | IM_RX_OVRN_INT | IM_RCV_INT | IM_TX_INT);\n\n\t/* Interface is now running, with no output active. */\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t/*\n\t * Attempt to start any pending transmission.\n\t */\n\tsmc91cxx_start(ifp);\n\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/ic/smc91cxxvar.h>",
      "#include <dev/ic/smc91cxxreg.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netccitt/pk_extern.h>",
      "#include <netccitt/pk_var.h>",
      "#include <netccitt/pk.h>",
      "#include <netccitt/x25.h>",
      "#include <sys/socketvar.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/rnd.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define ETHER_ADDR_LEN\t\t6",
      "#define\tSMC91CXX_SW_PAD"
    ],
    "globals_used": [
      "int\tsmc91cxx_set_media",
      "void\tsmc91cxx_start"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smc91cxx_start",
          "args": [
            "ifp"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "smc91cxx_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/smc91cxx.c",
          "lines": "475-655",
          "snippet": "void\nsmc91cxx_start(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct smc91cxx_softc *sc = ifp->if_softc;\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tu_int len;\n\tstruct mbuf *m, *top;\n\tu_int16_t length, npages;\n\tu_int8_t packetno;\n\tint timo, pad;\n\n\tif ((ifp->if_flags & (IFF_RUNNING|IFF_OACTIVE)) != IFF_RUNNING)\n\t\treturn;\n\n again:\n\t/*\n\t * Peek at the next packet.\n\t */\n\tif ((m = ifp->if_snd.ifq_head) == NULL)\n\t\treturn;\n\n\t/*\n\t * Compute the frame length and set pad to give an overall even\n\t * number of bytes.  Below, we assume that the packet length\n\t * is even.\n\t */\n\tfor (len = 0, top = m; m != NULL; m = m->m_next)\n\t\tlen += m->m_len;\n\tpad = (len & 1);\n\n\t/*\n\t * We drop packets that are too large.  Perhaps we should\n\t * truncate them instead?\n\t */\n\tif ((len + pad) > (ETHER_MAX_LEN - ETHER_CRC_LEN)) {\n\t\tprintf(\"%s: large packet discarded\\n\", sc->sc_dev.dv_xname);\n\t\tifp->if_oerrors++;\n\t\tIF_DEQUEUE(&ifp->if_snd, m);\n\t\tm_freem(m);\n\t\tgoto readcheck;\n\t}\n\n#ifdef SMC91CXX_SW_PAD\n\t/*\n\t * Not using hardware padding; pad to ETHER_MIN_LEN.\n\t */\n\tif (len < (ETHER_MIN_LEN - ETHER_CRC_LEN))\n\t\tpad = ETHER_MIN_LEN - ETHER_CRC_LEN - len;\n#endif\n\n\tlength = pad + len;\n\n\t/*\n\t * The MMU has a 256 byte page size.  The MMU expects us to\n\t * ask for \"npages - 1\".  We include space for the status word,\n\t * byte count, and control bytes in the allocation request.\n\t */\n\tnpages = (length + 6) >> 8;\n\n\t/*\n\t * Now allocate the memory.\n\t */\n\tSMC_SELECT_BANK(sc, 2);\n\tbus_space_write_2(bst, bsh, MMU_CMD_REG_W, MMUCR_ALLOC | npages);\n\n\ttimo = MEMORY_WAIT_TIME;\n\tdo {\n\t\tif (bus_space_read_1(bst, bsh, INTR_STAT_REG_B) & IM_ALLOC_INT)\n\t\t\tbreak;\n\t\tdelay(1);\n\t} while (--timo);\n\n\tpacketno = bus_space_read_1(bst, bsh, ALLOC_RESULT_REG_B);\n\n\tif (packetno & ARR_FAILED || timo == 0) {\n\t\t/*\n\t\t * No transmit memory is available.  Record the number\n\t\t * of requestd pages and enable the allocation completion\n\t\t * interrupt.  Set up the watchdog timer in case we miss\n\t\t * the interrupt.  Mark the interface as active so that\n\t\t * no one else attempts to transmit while we're allocating\n\t\t * memory.\n\t\t */\n\t\tbus_space_write_1(bst, bsh, INTR_MASK_REG_B,\n\t\t    bus_space_read_1(bst, bsh, INTR_MASK_REG_B) | IM_ALLOC_INT);\n\n\t\tifp->if_timer = 5;\n\t\tifp->if_flags |= IFF_OACTIVE;\n\n\t\treturn;\n\t}\n\n\t/*\n\t * We have a packet number - set the data window.\n\t */\n\tbus_space_write_1(bst, bsh, PACKET_NUM_REG_B, packetno);\n\n\t/*\n\t * Point to the beginning of the packet.\n\t */\n\tbus_space_write_2(bst, bsh, POINTER_REG_W, PTR_AUTOINC /* | 0x0000 */);\n\n\t/*\n\t * Send the packet length (+6 for stats, length, and control bytes)\n\t * and the status word (set to zeros).\n\t */\n\tbus_space_write_2(bst, bsh, DATA_REG_W, 0);\n\tbus_space_write_1(bst, bsh, DATA_REG_B, (length + 6) & 0xff);\n\tbus_space_write_1(bst, bsh, DATA_REG_B, ((length + 6) >> 8) & 0xff);\n\n\t/*\n\t * Get the packet from the kernel.  This will include the Ethernet\n\t * frame header, MAC address, etc.\n\t */\n\tIF_DEQUEUE(&ifp->if_snd, m);\n\n\t/*\n\t * Push the packet out to the card.\n\t */\n\tfor (top = m; m != NULL; m = m->m_next) {\n\t\t/* Words... */\n\t\tbus_space_write_multi_2(bst, bsh, DATA_REG_W,\n\t\t    mtod(m, u_int16_t *), m->m_len >> 1);\n\n\t\t/* ...and the remaining byte, if any. */\n\t\tif (m->m_len & 1)\n\t\t\tbus_space_write_1(bst, bsh, DATA_REG_B,\n\t\t\t  *(u_int8_t *)(mtod(m, u_int8_t *) + (m->m_len - 1)));\n\t}\n\n#ifdef SMC91CXX_SW_PAD\n\t/*\n\t * Push out padding.\n\t */\n\twhile (pad > 1) {\n\t\tbus_space_write_2(bst, bsh, DATA_REG_W, 0);\n\t\tpad -= 2;\n\t}\n\tif (pad)\n\t\tbus_space_write_1(bst, bsh, DATA_REG_B, 0);\n#endif\n\n\t/*\n\t * Push out control byte and unused packet byte.  The control byte\n\t * is 0, meaning the packet is even lengthed and no special\n\t * CRC handling is necessary.\n\t */\n\tbus_space_write_2(bst, bsh, DATA_REG_W, 0);\n\n\t/*\n\t * Enable transmit interrupts and let the chip go.  Set a watchdog\n\t * in case we miss the interrupt.\n\t */\n\tbus_space_write_1(bst, bsh, INTR_MASK_REG_B,\n\t    bus_space_read_1(bst, bsh, INTR_MASK_REG_B) |\n\t    IM_TX_INT | IM_TX_EMPTY_INT);\n\n\tbus_space_write_2(bst, bsh, MMU_CMD_REG_W, MMUCR_ENQUEUE);\n\n\tifp->if_timer = 5;\n\n#if NBPFILTER > 0\n\t/* Hand off a copy to the bpf. */\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, top);\n#endif\n\n\tifp->if_opackets++;\n\tm_freem(top);\n\n readcheck:\n\t/*\n\t * Check for incoming pcakets.  We don't want to overflow the small\n\t * RX FIFO.  If nothing has arrived, attempt to queue another\n\t * transmit packet.\n\t */\n\tif (bus_space_read_2(bst, bsh, FIFO_PORTS_REG_W) & FIFO_REMPTY)\n\t\tgoto again;\n}",
          "includes": [
            "#include <dev/ic/smc91cxxvar.h>",
            "#include <dev/ic/smc91cxxreg.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netccitt/pk_extern.h>",
            "#include <netccitt/pk_var.h>",
            "#include <netccitt/pk.h>",
            "#include <netccitt/x25.h>",
            "#include <sys/socketvar.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/rnd.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define\tETHER_CRC_LEN\t4",
            "#define\tETHER_MIN_LEN\t64",
            "#define\tETHER_MAX_LEN\t1518",
            "#define\tSMC91CXX_SW_PAD"
          ],
          "globals_used": [
            "void\tsmc91cxx_start"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/smc91cxxvar.h>\n#include <dev/ic/smc91cxxreg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netccitt/pk_extern.h>\n#include <netccitt/pk_var.h>\n#include <netccitt/pk.h>\n#include <netccitt/x25.h>\n#include <sys/socketvar.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/rnd.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tETHER_CRC_LEN\t4\n#define\tETHER_MIN_LEN\t64\n#define\tETHER_MAX_LEN\t1518\n#define\tSMC91CXX_SW_PAD\n\nvoid\tsmc91cxx_start;\n\nvoid\nsmc91cxx_start(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct smc91cxx_softc *sc = ifp->if_softc;\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tu_int len;\n\tstruct mbuf *m, *top;\n\tu_int16_t length, npages;\n\tu_int8_t packetno;\n\tint timo, pad;\n\n\tif ((ifp->if_flags & (IFF_RUNNING|IFF_OACTIVE)) != IFF_RUNNING)\n\t\treturn;\n\n again:\n\t/*\n\t * Peek at the next packet.\n\t */\n\tif ((m = ifp->if_snd.ifq_head) == NULL)\n\t\treturn;\n\n\t/*\n\t * Compute the frame length and set pad to give an overall even\n\t * number of bytes.  Below, we assume that the packet length\n\t * is even.\n\t */\n\tfor (len = 0, top = m; m != NULL; m = m->m_next)\n\t\tlen += m->m_len;\n\tpad = (len & 1);\n\n\t/*\n\t * We drop packets that are too large.  Perhaps we should\n\t * truncate them instead?\n\t */\n\tif ((len + pad) > (ETHER_MAX_LEN - ETHER_CRC_LEN)) {\n\t\tprintf(\"%s: large packet discarded\\n\", sc->sc_dev.dv_xname);\n\t\tifp->if_oerrors++;\n\t\tIF_DEQUEUE(&ifp->if_snd, m);\n\t\tm_freem(m);\n\t\tgoto readcheck;\n\t}\n\n#ifdef SMC91CXX_SW_PAD\n\t/*\n\t * Not using hardware padding; pad to ETHER_MIN_LEN.\n\t */\n\tif (len < (ETHER_MIN_LEN - ETHER_CRC_LEN))\n\t\tpad = ETHER_MIN_LEN - ETHER_CRC_LEN - len;\n#endif\n\n\tlength = pad + len;\n\n\t/*\n\t * The MMU has a 256 byte page size.  The MMU expects us to\n\t * ask for \"npages - 1\".  We include space for the status word,\n\t * byte count, and control bytes in the allocation request.\n\t */\n\tnpages = (length + 6) >> 8;\n\n\t/*\n\t * Now allocate the memory.\n\t */\n\tSMC_SELECT_BANK(sc, 2);\n\tbus_space_write_2(bst, bsh, MMU_CMD_REG_W, MMUCR_ALLOC | npages);\n\n\ttimo = MEMORY_WAIT_TIME;\n\tdo {\n\t\tif (bus_space_read_1(bst, bsh, INTR_STAT_REG_B) & IM_ALLOC_INT)\n\t\t\tbreak;\n\t\tdelay(1);\n\t} while (--timo);\n\n\tpacketno = bus_space_read_1(bst, bsh, ALLOC_RESULT_REG_B);\n\n\tif (packetno & ARR_FAILED || timo == 0) {\n\t\t/*\n\t\t * No transmit memory is available.  Record the number\n\t\t * of requestd pages and enable the allocation completion\n\t\t * interrupt.  Set up the watchdog timer in case we miss\n\t\t * the interrupt.  Mark the interface as active so that\n\t\t * no one else attempts to transmit while we're allocating\n\t\t * memory.\n\t\t */\n\t\tbus_space_write_1(bst, bsh, INTR_MASK_REG_B,\n\t\t    bus_space_read_1(bst, bsh, INTR_MASK_REG_B) | IM_ALLOC_INT);\n\n\t\tifp->if_timer = 5;\n\t\tifp->if_flags |= IFF_OACTIVE;\n\n\t\treturn;\n\t}\n\n\t/*\n\t * We have a packet number - set the data window.\n\t */\n\tbus_space_write_1(bst, bsh, PACKET_NUM_REG_B, packetno);\n\n\t/*\n\t * Point to the beginning of the packet.\n\t */\n\tbus_space_write_2(bst, bsh, POINTER_REG_W, PTR_AUTOINC /* | 0x0000 */);\n\n\t/*\n\t * Send the packet length (+6 for stats, length, and control bytes)\n\t * and the status word (set to zeros).\n\t */\n\tbus_space_write_2(bst, bsh, DATA_REG_W, 0);\n\tbus_space_write_1(bst, bsh, DATA_REG_B, (length + 6) & 0xff);\n\tbus_space_write_1(bst, bsh, DATA_REG_B, ((length + 6) >> 8) & 0xff);\n\n\t/*\n\t * Get the packet from the kernel.  This will include the Ethernet\n\t * frame header, MAC address, etc.\n\t */\n\tIF_DEQUEUE(&ifp->if_snd, m);\n\n\t/*\n\t * Push the packet out to the card.\n\t */\n\tfor (top = m; m != NULL; m = m->m_next) {\n\t\t/* Words... */\n\t\tbus_space_write_multi_2(bst, bsh, DATA_REG_W,\n\t\t    mtod(m, u_int16_t *), m->m_len >> 1);\n\n\t\t/* ...and the remaining byte, if any. */\n\t\tif (m->m_len & 1)\n\t\t\tbus_space_write_1(bst, bsh, DATA_REG_B,\n\t\t\t  *(u_int8_t *)(mtod(m, u_int8_t *) + (m->m_len - 1)));\n\t}\n\n#ifdef SMC91CXX_SW_PAD\n\t/*\n\t * Push out padding.\n\t */\n\twhile (pad > 1) {\n\t\tbus_space_write_2(bst, bsh, DATA_REG_W, 0);\n\t\tpad -= 2;\n\t}\n\tif (pad)\n\t\tbus_space_write_1(bst, bsh, DATA_REG_B, 0);\n#endif\n\n\t/*\n\t * Push out control byte and unused packet byte.  The control byte\n\t * is 0, meaning the packet is even lengthed and no special\n\t * CRC handling is necessary.\n\t */\n\tbus_space_write_2(bst, bsh, DATA_REG_W, 0);\n\n\t/*\n\t * Enable transmit interrupts and let the chip go.  Set a watchdog\n\t * in case we miss the interrupt.\n\t */\n\tbus_space_write_1(bst, bsh, INTR_MASK_REG_B,\n\t    bus_space_read_1(bst, bsh, INTR_MASK_REG_B) |\n\t    IM_TX_INT | IM_TX_EMPTY_INT);\n\n\tbus_space_write_2(bst, bsh, MMU_CMD_REG_W, MMUCR_ENQUEUE);\n\n\tifp->if_timer = 5;\n\n#if NBPFILTER > 0\n\t/* Hand off a copy to the bpf. */\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, top);\n#endif\n\n\tifp->if_opackets++;\n\tm_freem(top);\n\n readcheck:\n\t/*\n\t * Check for incoming pcakets.  We don't want to overflow the small\n\t * RX FIFO.  If nothing has arrived, attempt to queue another\n\t * transmit packet.\n\t */\n\tif (bus_space_read_2(bst, bsh, FIFO_PORTS_REG_W) & FIFO_REMPTY)\n\t\tgoto again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "bst",
            "bsh",
            "INTR_MASK_REG_B",
            "IM_EPH_INT | IM_RX_OVRN_INT | IM_RCV_INT | IM_TX_INT"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SMC_SELECT_BANK",
          "args": [
            "sc",
            "2"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "bst",
            "bsh",
            "TXMIT_CONTROL_REG_W",
            "tmp"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "bst",
            "bsh",
            "RECV_CONTROL_REG_W",
            "tmp"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SMC_SELECT_BANK",
          "args": [
            "sc",
            "0"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smc91cxx_set_media",
          "args": [
            "sc",
            "sc->sc_media.ifm_cur->ifm_media"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "smc91cxx_set_media",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/smc91cxx.c",
          "lines": "293-331",
          "snippet": "int\nsmc91cxx_set_media(sc, media)\n\tstruct smc91cxx_softc *sc;\n\tint media;\n{\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tu_int16_t tmp;\n\n\t/*\n\t * If the interface is not currently powered on, just return.\n\t * When it is enabled later, smc91cxx_init() will properly set\n\t * up the media for us.\n\t */\n\tif (sc->sc_enabled == 0)\n\t\treturn (0);\n\n\tif (IFM_TYPE(media) != IFM_ETHER)\n\t\treturn (EINVAL);\n\n\tswitch (IFM_SUBTYPE(media)) {\n\tcase IFM_10_T:\n\tcase IFM_10_5:\n\t\tSMC_SELECT_BANK(sc, 1);\n\t\ttmp = bus_space_read_2(bst, bsh, CONFIG_REG_W);\n\t\tif (IFM_SUBTYPE(media) == IFM_10_5)\n\t\t\ttmp |= CR_AUI_SELECT;\n\t\telse\n\t\t\ttmp &= ~CR_AUI_SELECT;\n\t\tbus_space_write_2(bst, bsh, CONFIG_REG_W, tmp);\n\t\tdelay(20000);\t/* XXX is this needed? */\n\t\tbreak;\n\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/smc91cxxvar.h>",
            "#include <dev/ic/smc91cxxreg.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netccitt/pk_extern.h>",
            "#include <netccitt/pk_var.h>",
            "#include <netccitt/pk.h>",
            "#include <netccitt/x25.h>",
            "#include <sys/socketvar.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/rnd.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\tsmc91cxx_set_media"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/smc91cxxvar.h>\n#include <dev/ic/smc91cxxreg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netccitt/pk_extern.h>\n#include <netccitt/pk_var.h>\n#include <netccitt/pk.h>\n#include <netccitt/x25.h>\n#include <sys/socketvar.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/rnd.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\tsmc91cxx_set_media;\n\nint\nsmc91cxx_set_media(sc, media)\n\tstruct smc91cxx_softc *sc;\n\tint media;\n{\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tu_int16_t tmp;\n\n\t/*\n\t * If the interface is not currently powered on, just return.\n\t * When it is enabled later, smc91cxx_init() will properly set\n\t * up the media for us.\n\t */\n\tif (sc->sc_enabled == 0)\n\t\treturn (0);\n\n\tif (IFM_TYPE(media) != IFM_ETHER)\n\t\treturn (EINVAL);\n\n\tswitch (IFM_SUBTYPE(media)) {\n\tcase IFM_10_T:\n\tcase IFM_10_5:\n\t\tSMC_SELECT_BANK(sc, 1);\n\t\ttmp = bus_space_read_2(bst, bsh, CONFIG_REG_W);\n\t\tif (IFM_SUBTYPE(media) == IFM_10_5)\n\t\t\ttmp |= CR_AUI_SELECT;\n\t\telse\n\t\t\ttmp &= ~CR_AUI_SELECT;\n\t\tbus_space_write_2(bst, bsh, CONFIG_REG_W, tmp);\n\t\tdelay(20000);\t/* XXX is this needed? */\n\t\tbreak;\n\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "bst",
            "bsh",
            "INTR_MASK_REG_B",
            "0"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "bst",
            "bsh",
            "MMU_CMD_REG_W"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "bst",
            "bsh",
            "MMU_CMD_REG_W",
            "MMUCR_RESET"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SMC_SELECT_BANK",
          "args": [
            "sc",
            "2"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "bst",
            "bsh",
            "CONTROL_REG_W",
            "(CTR_AUTO_RELEASE |\n\t    CTR_TE_ENABLE | CTR_CR_ENABLE | CTR_LE_ENABLE)"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "bst",
            "bsh",
            "IAR_ADDR0_REG_W + i",
            "sc->sc_arpcom.ac_enaddr[i]"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SMC_SELECT_BANK",
          "args": [
            "sc",
            "1"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "bst",
            "bsh",
            "TXMIT_CONTROL_REG_W",
            "0"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "200"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "dc_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "215-222",
          "snippet": "void dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_delay"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_delay;\n\nvoid dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "bst",
            "bsh",
            "RECV_CONTROL_REG_W",
            "0"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "bst",
            "bsh",
            "RECV_CONTROL_REG_W",
            "RCR_SOFTRESET"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SMC_SELECT_BANK",
          "args": [
            "sc",
            "0"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splnet",
          "args": [],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/smc91cxxvar.h>\n#include <dev/ic/smc91cxxreg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netccitt/pk_extern.h>\n#include <netccitt/pk_var.h>\n#include <netccitt/pk.h>\n#include <netccitt/x25.h>\n#include <sys/socketvar.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/rnd.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define ETHER_ADDR_LEN\t\t6\n#define\tSMC91CXX_SW_PAD\n\nint\tsmc91cxx_set_media;\nvoid\tsmc91cxx_start;\n\nvoid\nsmc91cxx_init(sc)\n\tstruct smc91cxx_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tu_int16_t tmp;\n\tint s, i;\n\n\ts = splnet();\n\n\t/*\n\t * This resets the registersmostly to defaults, but doesn't\n\t * affect the EEPROM.  After the reset cycle, we pause briefly\n\t * for the chip to recover.\n\t *\n\t * XXX how long are we really supposed to delay?  --thorpej\n\t */\n\tSMC_SELECT_BANK(sc, 0);\n\tbus_space_write_2(bst, bsh, RECV_CONTROL_REG_W, RCR_SOFTRESET);\n\tdelay(100);\n\tbus_space_write_2(bst, bsh, RECV_CONTROL_REG_W, 0);\n\tdelay(200);\n\n\tbus_space_write_2(bst, bsh, TXMIT_CONTROL_REG_W, 0);\n\n\t/* Set the Ethernet address. */\n\tSMC_SELECT_BANK(sc, 1);\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++ )\n\t\tbus_space_write_1(bst, bsh, IAR_ADDR0_REG_W + i,\n\t\t    sc->sc_arpcom.ac_enaddr[i]);\n\n\t/*\n\t * Set the control register to automatically release successfully\n\t * transmitted packets (making the best use of our limited memory)\n\t * and enable the EPH interrupt on certain TX errors.\n\t */\n\tbus_space_write_2(bst, bsh, CONTROL_REG_W, (CTR_AUTO_RELEASE |\n\t    CTR_TE_ENABLE | CTR_CR_ENABLE | CTR_LE_ENABLE));\n\n\t/*\n\t * Reset the MMU and wait for it to be un-busy.\n\t */\n\tSMC_SELECT_BANK(sc, 2);\n\tbus_space_write_2(bst, bsh, MMU_CMD_REG_W, MMUCR_RESET);\n\twhile (bus_space_read_2(bst, bsh, MMU_CMD_REG_W) & MMUCR_BUSY)\n\t\t/* XXX bound this loop! */ ;\n\n\t/*\n\t * Disable all interrupts.\n\t */\n\tbus_space_write_1(bst, bsh, INTR_MASK_REG_B, 0);\n\n\t/*\n\t * Set current media.\n\t */\n\tsmc91cxx_set_media(sc, sc->sc_media.ifm_cur->ifm_media);\n\n\t/*\n\t * Set the receive filter.  We want receive enable and auto\n\t * strip of CRC from received packet.  If we are in promisc. mode,\n\t * then set that bit as well.\n\t *\n\t * XXX Initialize multicast filter.  For now, we just accept\n\t * XXX all multicast.\n\t */\n\tSMC_SELECT_BANK(sc, 0);\n\n\ttmp = RCR_ENABLE | RCR_STRIP_CRC | RCR_ALMUL;\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\ttmp |= RCR_PROMISC;\n\n\tbus_space_write_2(bst, bsh, RECV_CONTROL_REG_W, tmp);\n\n\t/*\n\t * Set transmitter control to \"enabled\".\n\t */\n\ttmp = TCR_ENABLE;\n\n#ifndef SMC91CXX_SW_PAD\n\t/*\n\t * Enable hardware padding of transmitted packets.\n\t * XXX doesn't work?\n\t */\n\ttmp |= TCR_PAD_ENABLE;\n#endif\n\n\tbus_space_write_2(bst, bsh, TXMIT_CONTROL_REG_W, tmp);\n\n\t/*\n\t * Now, enable interrupts.\n\t */\n\tSMC_SELECT_BANK(sc, 2);\n\n\tbus_space_write_1(bst, bsh, INTR_MASK_REG_B,\n\t    IM_EPH_INT | IM_RX_OVRN_INT | IM_RCV_INT | IM_TX_INT);\n\n\t/* Interface is now running, with no output active. */\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t/*\n\t * Attempt to start any pending transmission.\n\t */\n\tsmc91cxx_start(ifp);\n\n\tsplx(s);\n}"
  },
  {
    "function_name": "smc91cxx_mediastatus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/smc91cxx.c",
    "lines": "336-356",
    "snippet": "void\nsmc91cxx_mediastatus(ifp, ifmr)\n\tstruct ifnet *ifp;\n\tstruct ifmediareq *ifmr;\n{\n\tstruct smc91cxx_softc *sc = ifp->if_softc;\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tu_int16_t tmp;\n\n\tif (sc->sc_enabled == 0) {\n\t\tifmr->ifm_active = IFM_ETHER | IFM_NONE;\n\t\tifmr->ifm_status = 0;\n\t\treturn;\n\t}\n\n\tSMC_SELECT_BANK(sc, 1);\n\ttmp = bus_space_read_2(bst, bsh, CONFIG_REG_W);\n\tifmr->ifm_active =\n\t    IFM_ETHER | ((tmp & CR_AUI_SELECT) ? IFM_10_5 : IFM_10_T);\n}",
    "includes": [
      "#include <dev/ic/smc91cxxvar.h>",
      "#include <dev/ic/smc91cxxreg.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netccitt/pk_extern.h>",
      "#include <netccitt/pk_var.h>",
      "#include <netccitt/pk.h>",
      "#include <netccitt/x25.h>",
      "#include <sys/socketvar.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/rnd.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\tsmc91cxx_mediastatus"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "bst",
            "bsh",
            "CONFIG_REG_W"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SMC_SELECT_BANK",
          "args": [
            "sc",
            "1"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/smc91cxxvar.h>\n#include <dev/ic/smc91cxxreg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netccitt/pk_extern.h>\n#include <netccitt/pk_var.h>\n#include <netccitt/pk.h>\n#include <netccitt/x25.h>\n#include <sys/socketvar.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/rnd.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\tsmc91cxx_mediastatus;\n\nvoid\nsmc91cxx_mediastatus(ifp, ifmr)\n\tstruct ifnet *ifp;\n\tstruct ifmediareq *ifmr;\n{\n\tstruct smc91cxx_softc *sc = ifp->if_softc;\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tu_int16_t tmp;\n\n\tif (sc->sc_enabled == 0) {\n\t\tifmr->ifm_active = IFM_ETHER | IFM_NONE;\n\t\tifmr->ifm_status = 0;\n\t\treturn;\n\t}\n\n\tSMC_SELECT_BANK(sc, 1);\n\ttmp = bus_space_read_2(bst, bsh, CONFIG_REG_W);\n\tifmr->ifm_active =\n\t    IFM_ETHER | ((tmp & CR_AUI_SELECT) ? IFM_10_5 : IFM_10_T);\n}"
  },
  {
    "function_name": "smc91cxx_set_media",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/smc91cxx.c",
    "lines": "293-331",
    "snippet": "int\nsmc91cxx_set_media(sc, media)\n\tstruct smc91cxx_softc *sc;\n\tint media;\n{\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tu_int16_t tmp;\n\n\t/*\n\t * If the interface is not currently powered on, just return.\n\t * When it is enabled later, smc91cxx_init() will properly set\n\t * up the media for us.\n\t */\n\tif (sc->sc_enabled == 0)\n\t\treturn (0);\n\n\tif (IFM_TYPE(media) != IFM_ETHER)\n\t\treturn (EINVAL);\n\n\tswitch (IFM_SUBTYPE(media)) {\n\tcase IFM_10_T:\n\tcase IFM_10_5:\n\t\tSMC_SELECT_BANK(sc, 1);\n\t\ttmp = bus_space_read_2(bst, bsh, CONFIG_REG_W);\n\t\tif (IFM_SUBTYPE(media) == IFM_10_5)\n\t\t\ttmp |= CR_AUI_SELECT;\n\t\telse\n\t\t\ttmp &= ~CR_AUI_SELECT;\n\t\tbus_space_write_2(bst, bsh, CONFIG_REG_W, tmp);\n\t\tdelay(20000);\t/* XXX is this needed? */\n\t\tbreak;\n\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/ic/smc91cxxvar.h>",
      "#include <dev/ic/smc91cxxreg.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netccitt/pk_extern.h>",
      "#include <netccitt/pk_var.h>",
      "#include <netccitt/pk.h>",
      "#include <netccitt/x25.h>",
      "#include <sys/socketvar.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/rnd.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\tsmc91cxx_set_media"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "20000"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "dc_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "215-222",
          "snippet": "void dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_delay"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_delay;\n\nvoid dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "bst",
            "bsh",
            "CONFIG_REG_W",
            "tmp"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFM_SUBTYPE",
          "args": [
            "media"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "bst",
            "bsh",
            "CONFIG_REG_W"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SMC_SELECT_BANK",
          "args": [
            "sc",
            "1"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFM_SUBTYPE",
          "args": [
            "media"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFM_TYPE",
          "args": [
            "media"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/smc91cxxvar.h>\n#include <dev/ic/smc91cxxreg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netccitt/pk_extern.h>\n#include <netccitt/pk_var.h>\n#include <netccitt/pk.h>\n#include <netccitt/x25.h>\n#include <sys/socketvar.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/rnd.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\tsmc91cxx_set_media;\n\nint\nsmc91cxx_set_media(sc, media)\n\tstruct smc91cxx_softc *sc;\n\tint media;\n{\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tu_int16_t tmp;\n\n\t/*\n\t * If the interface is not currently powered on, just return.\n\t * When it is enabled later, smc91cxx_init() will properly set\n\t * up the media for us.\n\t */\n\tif (sc->sc_enabled == 0)\n\t\treturn (0);\n\n\tif (IFM_TYPE(media) != IFM_ETHER)\n\t\treturn (EINVAL);\n\n\tswitch (IFM_SUBTYPE(media)) {\n\tcase IFM_10_T:\n\tcase IFM_10_5:\n\t\tSMC_SELECT_BANK(sc, 1);\n\t\ttmp = bus_space_read_2(bst, bsh, CONFIG_REG_W);\n\t\tif (IFM_SUBTYPE(media) == IFM_10_5)\n\t\t\ttmp |= CR_AUI_SELECT;\n\t\telse\n\t\t\ttmp &= ~CR_AUI_SELECT;\n\t\tbus_space_write_2(bst, bsh, CONFIG_REG_W, tmp);\n\t\tdelay(20000);\t/* XXX is this needed? */\n\t\tbreak;\n\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\n\treturn (0);\n}"
  },
  {
    "function_name": "smc91cxx_mediachange",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/smc91cxx.c",
    "lines": "284-291",
    "snippet": "int\nsmc91cxx_mediachange(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct smc91cxx_softc *sc = ifp->if_softc;\n\n\treturn (smc91cxx_set_media(sc, sc->sc_media.ifm_media));\n}",
    "includes": [
      "#include <dev/ic/smc91cxxvar.h>",
      "#include <dev/ic/smc91cxxreg.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netccitt/pk_extern.h>",
      "#include <netccitt/pk_var.h>",
      "#include <netccitt/pk.h>",
      "#include <netccitt/x25.h>",
      "#include <sys/socketvar.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/rnd.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\tsmc91cxx_mediachange",
      "int\tsmc91cxx_set_media"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "smc91cxx_set_media",
          "args": [
            "sc",
            "sc->sc_media.ifm_media"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "smc91cxx_set_media",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/smc91cxx.c",
          "lines": "293-331",
          "snippet": "int\nsmc91cxx_set_media(sc, media)\n\tstruct smc91cxx_softc *sc;\n\tint media;\n{\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tu_int16_t tmp;\n\n\t/*\n\t * If the interface is not currently powered on, just return.\n\t * When it is enabled later, smc91cxx_init() will properly set\n\t * up the media for us.\n\t */\n\tif (sc->sc_enabled == 0)\n\t\treturn (0);\n\n\tif (IFM_TYPE(media) != IFM_ETHER)\n\t\treturn (EINVAL);\n\n\tswitch (IFM_SUBTYPE(media)) {\n\tcase IFM_10_T:\n\tcase IFM_10_5:\n\t\tSMC_SELECT_BANK(sc, 1);\n\t\ttmp = bus_space_read_2(bst, bsh, CONFIG_REG_W);\n\t\tif (IFM_SUBTYPE(media) == IFM_10_5)\n\t\t\ttmp |= CR_AUI_SELECT;\n\t\telse\n\t\t\ttmp &= ~CR_AUI_SELECT;\n\t\tbus_space_write_2(bst, bsh, CONFIG_REG_W, tmp);\n\t\tdelay(20000);\t/* XXX is this needed? */\n\t\tbreak;\n\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/smc91cxxvar.h>",
            "#include <dev/ic/smc91cxxreg.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netccitt/pk_extern.h>",
            "#include <netccitt/pk_var.h>",
            "#include <netccitt/pk.h>",
            "#include <netccitt/x25.h>",
            "#include <sys/socketvar.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/rnd.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\tsmc91cxx_set_media"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/smc91cxxvar.h>\n#include <dev/ic/smc91cxxreg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netccitt/pk_extern.h>\n#include <netccitt/pk_var.h>\n#include <netccitt/pk.h>\n#include <netccitt/x25.h>\n#include <sys/socketvar.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/rnd.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\tsmc91cxx_set_media;\n\nint\nsmc91cxx_set_media(sc, media)\n\tstruct smc91cxx_softc *sc;\n\tint media;\n{\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tu_int16_t tmp;\n\n\t/*\n\t * If the interface is not currently powered on, just return.\n\t * When it is enabled later, smc91cxx_init() will properly set\n\t * up the media for us.\n\t */\n\tif (sc->sc_enabled == 0)\n\t\treturn (0);\n\n\tif (IFM_TYPE(media) != IFM_ETHER)\n\t\treturn (EINVAL);\n\n\tswitch (IFM_SUBTYPE(media)) {\n\tcase IFM_10_T:\n\tcase IFM_10_5:\n\t\tSMC_SELECT_BANK(sc, 1);\n\t\ttmp = bus_space_read_2(bst, bsh, CONFIG_REG_W);\n\t\tif (IFM_SUBTYPE(media) == IFM_10_5)\n\t\t\ttmp |= CR_AUI_SELECT;\n\t\telse\n\t\t\ttmp &= ~CR_AUI_SELECT;\n\t\tbus_space_write_2(bst, bsh, CONFIG_REG_W, tmp);\n\t\tdelay(20000);\t/* XXX is this needed? */\n\t\tbreak;\n\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\n\treturn (0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/smc91cxxvar.h>\n#include <dev/ic/smc91cxxreg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netccitt/pk_extern.h>\n#include <netccitt/pk_var.h>\n#include <netccitt/pk.h>\n#include <netccitt/x25.h>\n#include <sys/socketvar.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/rnd.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\tsmc91cxx_mediachange;\nint\tsmc91cxx_set_media;\n\nint\nsmc91cxx_mediachange(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct smc91cxx_softc *sc = ifp->if_softc;\n\n\treturn (smc91cxx_set_media(sc, sc->sc_media.ifm_media));\n}"
  },
  {
    "function_name": "smc91cxx_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/smc91cxx.c",
    "lines": "201-279",
    "snippet": "void\nsmc91cxx_attach(sc, myea)\n\tstruct smc91cxx_softc *sc;\n\tu_int8_t *myea;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tu_int16_t tmp;\n\tint i, aui;\n#ifdef SMC_DEBUG\n\tconst char *idstr;\n#endif\n\n\t/* Make sure the chip is stopped. */\n\tsmc91cxx_stop(sc);\n\n#ifdef SMC_DEBUG\n\tSMC_SELECT_BANK(sc, 3);\n\ttmp = bus_space_read_2(bst, bsh, REVISION_REG_W);\n\tidstr = smc91cxx_idstrs[RR_ID(tmp)];\n\tprintf(\"%s: \", sc->sc_dev.dv_xname);\n\tif (idstr != NULL)\n\t\tprintf(\"%s, \", idstr);\n\telse\n\t\tprintf(\"unknown chip id %d, \", RR_ID(tmp));\n\tprintf(\"revision %d\\n\", RR_REV(tmp));\n#endif\n\n\t/* Read the station address from the chip. */\n\tSMC_SELECT_BANK(sc, 1);\n\tif (myea == NULL) {\n\t\tfor (i = 0; i < ETHER_ADDR_LEN; i += 2) {\n\t\t\ttmp = bus_space_read_2(bst, bsh, IAR_ADDR0_REG_W + i);\n\t\t\tsc->sc_arpcom.ac_enaddr[i + 1] = (tmp >>8) & 0xff;\n\t\t\tsc->sc_arpcom.ac_enaddr[i] = tmp & 0xff;\n\t\t}\n\t} else {\n\t\tbcopy(myea, sc->sc_arpcom.ac_enaddr, ETHER_ADDR_LEN);\n\t}\n\n\tprintf(\": address %s, \",\n\t    ether_sprintf(sc->sc_arpcom.ac_enaddr));\n\n\t/* ..and default media. */\n\ttmp = bus_space_read_2(bst, bsh, CONFIG_REG_W);\n\tprintf(\"utp/aui (default %s)\\n\", (aui = (tmp & CR_AUI_SELECT)) ?\n\t    \"aui\" : \"utp\");\n\n\t/* Initialize the ifnet structure. */\n\tbcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\tifp->if_softc = sc;\n\tifp->if_start = smc91cxx_start;\n\tifp->if_ioctl = smc91cxx_ioctl;\n\tifp->if_watchdog = smc91cxx_watchdog;\n\tifp->if_flags =\n\t    IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS | IFF_MULTICAST;\n\tifp->if_snd.ifq_maxlen = IFQ_MAXLEN;\n\n\t/* Attach the interface. */\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n\n\t/* Initialize the media structures. */\n\tifmedia_init(&sc->sc_media, 0, smc91cxx_mediachange,\n\t    smc91cxx_mediastatus);\n\tfor (i = 0; i < NSMC91CxxMEDIA; i++)\n\t\tifmedia_add(&sc->sc_media, smc91cxx_media[i], 0, NULL);\n\tifmedia_set(&sc->sc_media, IFM_ETHER | (aui ? IFM_10_5 : IFM_10_T));\n\n#if NBPFILTER > 0\n\tbpfattach(&sc->sc_arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,\n\t\tsizeof(struct ether_header));\n#endif\n\n#if NRND > 0\n\trnd_attach_source(&sc->rnd_source, sc->sc_dev.dv_xname, RND_TYPE_NET);\n#endif\n}",
    "includes": [
      "#include <dev/ic/smc91cxxvar.h>",
      "#include <dev/ic/smc91cxxreg.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netccitt/pk_extern.h>",
      "#include <netccitt/pk_var.h>",
      "#include <netccitt/pk.h>",
      "#include <netccitt/x25.h>",
      "#include <sys/socketvar.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/rnd.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define\tNSMC91CxxMEDIA\t(sizeof(smc91cxx_media) / sizeof(smc91cxx_media[0]))",
      "#define ETHER_ADDR_LEN\t\t6"
    ],
    "globals_used": [
      "const int smc91cxx_media[] = {\n\tIFM_ETHER|IFM_10_T,\n\tIFM_ETHER|IFM_10_5,\n};",
      "int\tsmc91cxx_mediachange",
      "void\tsmc91cxx_mediastatus",
      "void\tsmc91cxx_start",
      "void\tsmc91cxx_watchdog",
      "int\tsmc91cxx_ioctl"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rnd_attach_source",
          "args": [
            "&sc->rnd_source",
            "sc->sc_dev.dv_xname",
            "RND_TYPE_NET"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpfattach",
          "args": [
            "&sc->sc_arpcom.ac_if.if_bpf",
            "ifp",
            "DLT_EN10MB",
            "sizeof(struct ether_header)"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_set",
          "args": [
            "&sc->sc_media",
            "IFM_ETHER | (aui ? IFM_10_5 : IFM_10_T)"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "&sc->sc_media",
            "smc91cxx_media[i]",
            "0",
            "NULL"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_init",
          "args": [
            "&sc->sc_media",
            "0",
            "smc91cxx_mediachange",
            "smc91cxx_mediastatus"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_ifattach",
          "args": [
            "ifp"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_attach",
          "args": [
            "ifp"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "sc->sc_dev.dv_xname",
            "ifp->if_xname",
            "IFNAMSIZ"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"utp/aui (default %s)\\n\"",
            "(aui = (tmp & CR_AUI_SELECT)) ?\n\t    \"aui\" : \"utp\""
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "bst",
            "bsh",
            "CONFIG_REG_W"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_sprintf",
          "args": [
            "sc->sc_arpcom.ac_enaddr"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "bst",
            "bsh",
            "IAR_ADDR0_REG_W + i"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SMC_SELECT_BANK",
          "args": [
            "sc",
            "1"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RR_REV",
          "args": [
            "tmp"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RR_ID",
          "args": [
            "tmp"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RR_ID",
          "args": [
            "tmp"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "bst",
            "bsh",
            "REVISION_REG_W"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SMC_SELECT_BANK",
          "args": [
            "sc",
            "3"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smc91cxx_stop",
          "args": [
            "sc"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "smc91cxx_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/smc91cxx.c",
          "lines": "1135-1159",
          "snippet": "void\nsmc91cxx_stop(sc)\n\tstruct smc91cxx_softc *sc;\n{\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\n\t/*\n\t * Clear interrupt mask; disable all interrupts.\n\t */\n\tSMC_SELECT_BANK(sc, 2);\n\tbus_space_write_1(bst, bsh, INTR_MASK_REG_B, 0);\n\n\t/*\n\t * Disable transmitter and receiver.\n\t */\n\tSMC_SELECT_BANK(sc, 0);\n\tbus_space_write_2(bst, bsh, RECV_CONTROL_REG_W, 0);\n\tbus_space_write_2(bst, bsh, TXMIT_CONTROL_REG_W, 0);\n\n\t/*\n\t * Cancel watchdog timer.\n\t */\n\tsc->sc_arpcom.ac_if.if_timer = 0;\n}",
          "includes": [
            "#include <dev/ic/smc91cxxvar.h>",
            "#include <dev/ic/smc91cxxreg.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netccitt/pk_extern.h>",
            "#include <netccitt/pk_var.h>",
            "#include <netccitt/pk.h>",
            "#include <netccitt/x25.h>",
            "#include <sys/socketvar.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/rnd.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/smc91cxxvar.h>\n#include <dev/ic/smc91cxxreg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netccitt/pk_extern.h>\n#include <netccitt/pk_var.h>\n#include <netccitt/pk.h>\n#include <netccitt/x25.h>\n#include <sys/socketvar.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/rnd.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\nsmc91cxx_stop(sc)\n\tstruct smc91cxx_softc *sc;\n{\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\n\t/*\n\t * Clear interrupt mask; disable all interrupts.\n\t */\n\tSMC_SELECT_BANK(sc, 2);\n\tbus_space_write_1(bst, bsh, INTR_MASK_REG_B, 0);\n\n\t/*\n\t * Disable transmitter and receiver.\n\t */\n\tSMC_SELECT_BANK(sc, 0);\n\tbus_space_write_2(bst, bsh, RECV_CONTROL_REG_W, 0);\n\tbus_space_write_2(bst, bsh, TXMIT_CONTROL_REG_W, 0);\n\n\t/*\n\t * Cancel watchdog timer.\n\t */\n\tsc->sc_arpcom.ac_if.if_timer = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/smc91cxxvar.h>\n#include <dev/ic/smc91cxxreg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netccitt/pk_extern.h>\n#include <netccitt/pk_var.h>\n#include <netccitt/pk.h>\n#include <netccitt/x25.h>\n#include <sys/socketvar.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/rnd.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tNSMC91CxxMEDIA\t(sizeof(smc91cxx_media) / sizeof(smc91cxx_media[0]))\n#define ETHER_ADDR_LEN\t\t6\n\nconst int smc91cxx_media[] = {\n\tIFM_ETHER|IFM_10_T,\n\tIFM_ETHER|IFM_10_5,\n};\nint\tsmc91cxx_mediachange;\nvoid\tsmc91cxx_mediastatus;\nvoid\tsmc91cxx_start;\nvoid\tsmc91cxx_watchdog;\nint\tsmc91cxx_ioctl;\n\nvoid\nsmc91cxx_attach(sc, myea)\n\tstruct smc91cxx_softc *sc;\n\tu_int8_t *myea;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tu_int16_t tmp;\n\tint i, aui;\n#ifdef SMC_DEBUG\n\tconst char *idstr;\n#endif\n\n\t/* Make sure the chip is stopped. */\n\tsmc91cxx_stop(sc);\n\n#ifdef SMC_DEBUG\n\tSMC_SELECT_BANK(sc, 3);\n\ttmp = bus_space_read_2(bst, bsh, REVISION_REG_W);\n\tidstr = smc91cxx_idstrs[RR_ID(tmp)];\n\tprintf(\"%s: \", sc->sc_dev.dv_xname);\n\tif (idstr != NULL)\n\t\tprintf(\"%s, \", idstr);\n\telse\n\t\tprintf(\"unknown chip id %d, \", RR_ID(tmp));\n\tprintf(\"revision %d\\n\", RR_REV(tmp));\n#endif\n\n\t/* Read the station address from the chip. */\n\tSMC_SELECT_BANK(sc, 1);\n\tif (myea == NULL) {\n\t\tfor (i = 0; i < ETHER_ADDR_LEN; i += 2) {\n\t\t\ttmp = bus_space_read_2(bst, bsh, IAR_ADDR0_REG_W + i);\n\t\t\tsc->sc_arpcom.ac_enaddr[i + 1] = (tmp >>8) & 0xff;\n\t\t\tsc->sc_arpcom.ac_enaddr[i] = tmp & 0xff;\n\t\t}\n\t} else {\n\t\tbcopy(myea, sc->sc_arpcom.ac_enaddr, ETHER_ADDR_LEN);\n\t}\n\n\tprintf(\": address %s, \",\n\t    ether_sprintf(sc->sc_arpcom.ac_enaddr));\n\n\t/* ..and default media. */\n\ttmp = bus_space_read_2(bst, bsh, CONFIG_REG_W);\n\tprintf(\"utp/aui (default %s)\\n\", (aui = (tmp & CR_AUI_SELECT)) ?\n\t    \"aui\" : \"utp\");\n\n\t/* Initialize the ifnet structure. */\n\tbcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\tifp->if_softc = sc;\n\tifp->if_start = smc91cxx_start;\n\tifp->if_ioctl = smc91cxx_ioctl;\n\tifp->if_watchdog = smc91cxx_watchdog;\n\tifp->if_flags =\n\t    IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS | IFF_MULTICAST;\n\tifp->if_snd.ifq_maxlen = IFQ_MAXLEN;\n\n\t/* Attach the interface. */\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n\n\t/* Initialize the media structures. */\n\tifmedia_init(&sc->sc_media, 0, smc91cxx_mediachange,\n\t    smc91cxx_mediastatus);\n\tfor (i = 0; i < NSMC91CxxMEDIA; i++)\n\t\tifmedia_add(&sc->sc_media, smc91cxx_media[i], 0, NULL);\n\tifmedia_set(&sc->sc_media, IFM_ETHER | (aui ? IFM_10_5 : IFM_10_T));\n\n#if NBPFILTER > 0\n\tbpfattach(&sc->sc_arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,\n\t\tsizeof(struct ether_header));\n#endif\n\n#if NRND > 0\n\trnd_attach_source(&sc->rnd_source, sc->sc_dev.dv_xname, RND_TYPE_NET);\n#endif\n}"
  },
  {
    "function_name": "ether_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/smc91cxx.c",
    "lines": "190-199",
    "snippet": "static __inline int\nether_cmp(va, vb)\n\tvoid *va, *vb;\n{\n\tu_int8_t *a = va;\n\tu_int8_t *b = vb;\n\n\treturn ((a[5] != b[5]) || (a[4] != b[4]) || (a[3] != b[3]) ||\n\t\t(a[2] != b[2]) || (a[1] != b[1]) || (a[0] != b[0]));\n}",
    "includes": [
      "#include <dev/ic/smc91cxxvar.h>",
      "#include <dev/ic/smc91cxxreg.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netccitt/pk_extern.h>",
      "#include <netccitt/pk_var.h>",
      "#include <netccitt/pk.h>",
      "#include <netccitt/x25.h>",
      "#include <sys/socketvar.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/rnd.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __inline int ether_cmp"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/ic/smc91cxxvar.h>\n#include <dev/ic/smc91cxxreg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netccitt/pk_extern.h>\n#include <netccitt/pk_var.h>\n#include <netccitt/pk.h>\n#include <netccitt/x25.h>\n#include <sys/socketvar.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/rnd.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic __inline int ether_cmp;\n\nstatic __inline int\nether_cmp(va, vb)\n\tvoid *va, *vb;\n{\n\tu_int8_t *a = va;\n\tu_int8_t *b = vb;\n\n\treturn ((a[5] != b[5]) || (a[4] != b[4]) || (a[3] != b[3]) ||\n\t\t(a[2] != b[2]) || (a[1] != b[1]) || (a[0] != b[0]));\n}"
  }
]