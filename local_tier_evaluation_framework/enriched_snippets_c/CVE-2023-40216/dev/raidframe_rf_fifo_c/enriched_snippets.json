[
  {
    "function_name": "rf_FifoPromote",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_fifo.c",
    "lines": "261-322",
    "snippet": "int \nrf_FifoPromote(q_in, parityStripeID, which_ru)\n\tvoid   *q_in;\n\tRF_StripeNum_t parityStripeID;\n\tRF_ReconUnitNum_t which_ru;\n{\n\tRF_FifoHeader_t *q = (RF_FifoHeader_t *) q_in;\n\tRF_DiskQueueData_t *lp = q->lq_head, *pt = NULL;\t/* lp = lo-pri queue\n\t\t\t\t\t\t\t\t * pointer, pt = trailer */\n\tint     retval = 0;\n\n\twhile (lp) {\n\n\t\t/* search for the indicated parity stripe in the low-pri queue */\n\t\tif (lp->parityStripeID == parityStripeID && lp->which_ru == which_ru) {\n\t\t\t/* printf(\"FifoPromote:  promoting access for psid\n\t\t\t * %ld\\n\",parityStripeID); */\n\t\t\tif (pt)\n\t\t\t\tpt->next = lp->next;\t/* delete an entry other\n\t\t\t\t\t\t\t * than the first */\n\t\t\telse\n\t\t\t\tq->lq_head = lp->next;\t/* delete the head entry */\n\n\t\t\tif (!q->lq_head)\n\t\t\t\tq->lq_tail = NULL;\t/* we deleted the only\n\t\t\t\t\t\t\t * entry */\n\t\t\telse\n\t\t\t\tif (lp == q->lq_tail)\n\t\t\t\t\tq->lq_tail = pt;\t/* we deleted the tail\n\t\t\t\t\t\t\t\t * entry */\n\n\t\t\tlp->next = NULL;\n\t\t\tq->lq_count--;\n\n\t\t\tif (q->hq_tail) {\n\t\t\t\tq->hq_tail->next = lp;\n\t\t\t\tq->hq_tail = lp;\n\t\t\t}\n\t\t\t /* append to hi-priority queue */ \n\t\t\telse {\n\t\t\t\tq->hq_head = q->hq_tail = lp;\n\t\t\t}\n\t\t\tq->hq_count++;\n\n\t\t\t/* UpdateShortestSeekFinishTimeForced(lp->requestPtr,\n\t\t\t * lp->diskState); *//* deal with this later, if ever */\n\n\t\t\tlp = (pt) ? pt->next : q->lq_head;\t/* reset low-pri pointer\n\t\t\t\t\t\t\t\t * and continue */\n\t\t\tretval++;\n\n\t\t} else {\n\t\t\tpt = lp;\n\t\t\tlp = lp->next;\n\t\t}\n\t}\n\n\t/* sanity check.  delete this if you ever put more than one entry in\n\t * the low-pri queue */\n\tRF_ASSERT(retval == 0 || retval == 1);\n\treturn (retval);\n}",
    "includes": [
      "#include \"rf_types.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_fifo.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_layout.h\"",
      "#include \"rf_stripelocks.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "RF_DiskQueueData_t *\nrf_FifoDequeue(q_in)\n\tvoid   *q_in;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "retval == 0 || retval == 1"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_types.h\"\n#include \"rf_raid.h\"\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_fifo.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_layout.h\"\n#include \"rf_stripelocks.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_types.h\"\n\nRF_DiskQueueData_t *\nrf_FifoDequeue(q_in)\n\tvoid   *q_in;\n\nint \nrf_FifoPromote(q_in, parityStripeID, which_ru)\n\tvoid   *q_in;\n\tRF_StripeNum_t parityStripeID;\n\tRF_ReconUnitNum_t which_ru;\n{\n\tRF_FifoHeader_t *q = (RF_FifoHeader_t *) q_in;\n\tRF_DiskQueueData_t *lp = q->lq_head, *pt = NULL;\t/* lp = lo-pri queue\n\t\t\t\t\t\t\t\t * pointer, pt = trailer */\n\tint     retval = 0;\n\n\twhile (lp) {\n\n\t\t/* search for the indicated parity stripe in the low-pri queue */\n\t\tif (lp->parityStripeID == parityStripeID && lp->which_ru == which_ru) {\n\t\t\t/* printf(\"FifoPromote:  promoting access for psid\n\t\t\t * %ld\\n\",parityStripeID); */\n\t\t\tif (pt)\n\t\t\t\tpt->next = lp->next;\t/* delete an entry other\n\t\t\t\t\t\t\t * than the first */\n\t\t\telse\n\t\t\t\tq->lq_head = lp->next;\t/* delete the head entry */\n\n\t\t\tif (!q->lq_head)\n\t\t\t\tq->lq_tail = NULL;\t/* we deleted the only\n\t\t\t\t\t\t\t * entry */\n\t\t\telse\n\t\t\t\tif (lp == q->lq_tail)\n\t\t\t\t\tq->lq_tail = pt;\t/* we deleted the tail\n\t\t\t\t\t\t\t\t * entry */\n\n\t\t\tlp->next = NULL;\n\t\t\tq->lq_count--;\n\n\t\t\tif (q->hq_tail) {\n\t\t\t\tq->hq_tail->next = lp;\n\t\t\t\tq->hq_tail = lp;\n\t\t\t}\n\t\t\t /* append to hi-priority queue */ \n\t\t\telse {\n\t\t\t\tq->hq_head = q->hq_tail = lp;\n\t\t\t}\n\t\t\tq->hq_count++;\n\n\t\t\t/* UpdateShortestSeekFinishTimeForced(lp->requestPtr,\n\t\t\t * lp->diskState); *//* deal with this later, if ever */\n\n\t\t\tlp = (pt) ? pt->next : q->lq_head;\t/* reset low-pri pointer\n\t\t\t\t\t\t\t\t * and continue */\n\t\t\tretval++;\n\n\t\t} else {\n\t\t\tpt = lp;\n\t\t\tlp = lp->next;\n\t\t}\n\t}\n\n\t/* sanity check.  delete this if you ever put more than one entry in\n\t * the low-pri queue */\n\tRF_ASSERT(retval == 0 || retval == 1);\n\treturn (retval);\n}"
  },
  {
    "function_name": "rf_FifoPeek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_fifo.c",
    "lines": "240-253",
    "snippet": "RF_DiskQueueData_t *\nrf_FifoPeek(void *q_in)\n{\n\tRF_DiskQueueData_t *headElement = NULL;\n\tRF_FifoHeader_t *q = (RF_FifoHeader_t *) q_in;\n\n\tRF_ASSERT(q);\n\tif (q->hq_head)\n\t\theadElement = q->hq_head;\n\telse\n\t\tif (q->lq_head)\n\t\t\theadElement = q->lq_head;\n\treturn (headElement);\n}",
    "includes": [
      "#include \"rf_types.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_fifo.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_layout.h\"",
      "#include \"rf_stripelocks.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "RF_DiskQueueData_t *\nrf_FifoDequeue(q_in)\n\tvoid   *q_in;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "q"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_types.h\"\n#include \"rf_raid.h\"\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_fifo.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_layout.h\"\n#include \"rf_stripelocks.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_types.h\"\n\nRF_DiskQueueData_t *\nrf_FifoDequeue(q_in)\n\tvoid   *q_in;\n\nRF_DiskQueueData_t *\nrf_FifoPeek(void *q_in)\n{\n\tRF_DiskQueueData_t *headElement = NULL;\n\tRF_FifoHeader_t *q = (RF_FifoHeader_t *) q_in;\n\n\tRF_ASSERT(q);\n\tif (q->hq_head)\n\t\theadElement = q->hq_head;\n\telse\n\t\tif (q->lq_head)\n\t\t\theadElement = q->lq_head;\n\treturn (headElement);\n}"
  },
  {
    "function_name": "rf_FifoEnqueue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_fifo.c",
    "lines": "66-113",
    "snippet": "void \nrf_FifoEnqueue(q_in, elem, priority)\n\tvoid   *q_in;\n\tRF_DiskQueueData_t *elem;\n\tint     priority;\n{\n\tRF_FifoHeader_t *q = (RF_FifoHeader_t *) q_in;\n\n\tRF_ASSERT(priority == RF_IO_NORMAL_PRIORITY || priority == RF_IO_LOW_PRIORITY);\n\n\telem->next = NULL;\n\tif (priority == RF_IO_NORMAL_PRIORITY) {\n\t\tif (!q->hq_tail) {\n\t\t\tRF_ASSERT(q->hq_count == 0 && q->hq_head == NULL);\n\t\t\tq->hq_head = q->hq_tail = elem;\n\t\t} else {\n\t\t\tRF_ASSERT(q->hq_count != 0 && q->hq_head != NULL);\n\t\t\tq->hq_tail->next = elem;\n\t\t\tq->hq_tail = elem;\n\t\t}\n\t\tq->hq_count++;\n\t} else {\n\t\tRF_ASSERT(elem->next == NULL);\n\t\tif (rf_fifoDebug) {\n\t\t\tprintf(\"raid%d: fifo: ENQ lopri\\n\", \n\t\t\t       elem->raidPtr->raidid);\n\t\t}\n\t\tif (!q->lq_tail) {\n\t\t\tRF_ASSERT(q->lq_count == 0 && q->lq_head == NULL);\n\t\t\tq->lq_head = q->lq_tail = elem;\n\t\t} else {\n\t\t\tRF_ASSERT(q->lq_count != 0 && q->lq_head != NULL);\n\t\t\tq->lq_tail->next = elem;\n\t\t\tq->lq_tail = elem;\n\t\t}\n\t\tq->lq_count++;\n\t}\n\tif ((q->hq_count + q->lq_count) != elem->queue->queueLength) {\n\t\tprintf(\"Queue lengths differ!: %d %d %d\\n\",\n\t\t    q->hq_count, q->lq_count, (int) elem->queue->queueLength);\n\t\tprintf(\"%d %d %d %d\\n\",\n\t\t    (int) elem->queue->numOutstanding,\n\t\t    (int) elem->queue->maxOutstanding,\n\t\t    (int) elem->queue->row,\n\t\t    (int) elem->queue->col);\n\t}\n\tRF_ASSERT((q->hq_count + q->lq_count) == elem->queue->queueLength);\n}",
    "includes": [
      "#include \"rf_types.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_fifo.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_layout.h\"",
      "#include \"rf_stripelocks.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "RF_DiskQueueData_t *\nrf_FifoDequeue(q_in)\n\tvoid   *q_in;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "(q->hq_count + q->lq_count) == elem->queue->queueLength"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%d %d %d %d\\n\"",
            "(int) elem->queue->numOutstanding",
            "(int) elem->queue->maxOutstanding",
            "(int) elem->queue->row",
            "(int) elem->queue->col"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "q->lq_count != 0 && q->lq_head != NULL"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "q->lq_count == 0 && q->lq_head == NULL"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "elem->next == NULL"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "q->hq_count != 0 && q->hq_head != NULL"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "q->hq_count == 0 && q->hq_head == NULL"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "priority == RF_IO_NORMAL_PRIORITY || priority == RF_IO_LOW_PRIORITY"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_types.h\"\n#include \"rf_raid.h\"\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_fifo.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_layout.h\"\n#include \"rf_stripelocks.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_types.h\"\n\nRF_DiskQueueData_t *\nrf_FifoDequeue(q_in)\n\tvoid   *q_in;\n\nvoid \nrf_FifoEnqueue(q_in, elem, priority)\n\tvoid   *q_in;\n\tRF_DiskQueueData_t *elem;\n\tint     priority;\n{\n\tRF_FifoHeader_t *q = (RF_FifoHeader_t *) q_in;\n\n\tRF_ASSERT(priority == RF_IO_NORMAL_PRIORITY || priority == RF_IO_LOW_PRIORITY);\n\n\telem->next = NULL;\n\tif (priority == RF_IO_NORMAL_PRIORITY) {\n\t\tif (!q->hq_tail) {\n\t\t\tRF_ASSERT(q->hq_count == 0 && q->hq_head == NULL);\n\t\t\tq->hq_head = q->hq_tail = elem;\n\t\t} else {\n\t\t\tRF_ASSERT(q->hq_count != 0 && q->hq_head != NULL);\n\t\t\tq->hq_tail->next = elem;\n\t\t\tq->hq_tail = elem;\n\t\t}\n\t\tq->hq_count++;\n\t} else {\n\t\tRF_ASSERT(elem->next == NULL);\n\t\tif (rf_fifoDebug) {\n\t\t\tprintf(\"raid%d: fifo: ENQ lopri\\n\", \n\t\t\t       elem->raidPtr->raidid);\n\t\t}\n\t\tif (!q->lq_tail) {\n\t\t\tRF_ASSERT(q->lq_count == 0 && q->lq_head == NULL);\n\t\t\tq->lq_head = q->lq_tail = elem;\n\t\t} else {\n\t\t\tRF_ASSERT(q->lq_count != 0 && q->lq_head != NULL);\n\t\t\tq->lq_tail->next = elem;\n\t\t\tq->lq_tail = elem;\n\t\t}\n\t\tq->lq_count++;\n\t}\n\tif ((q->hq_count + q->lq_count) != elem->queue->queueLength) {\n\t\tprintf(\"Queue lengths differ!: %d %d %d\\n\",\n\t\t    q->hq_count, q->lq_count, (int) elem->queue->queueLength);\n\t\tprintf(\"%d %d %d %d\\n\",\n\t\t    (int) elem->queue->numOutstanding,\n\t\t    (int) elem->queue->maxOutstanding,\n\t\t    (int) elem->queue->row,\n\t\t    (int) elem->queue->col);\n\t}\n\tRF_ASSERT((q->hq_count + q->lq_count) == elem->queue->queueLength);\n}"
  }
]