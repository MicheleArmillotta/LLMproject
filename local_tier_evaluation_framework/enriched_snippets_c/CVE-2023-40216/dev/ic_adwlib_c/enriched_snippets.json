[
  {
    "function_name": "AdvDelayMicroSecond",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adwlib.c",
    "lines": "2561-2567",
    "snippet": "static void\nAdvDelayMicroSecond(n)\nu_int32_t\tn;\n{\n\n\tDELAY(n);\n}",
    "includes": [
      "#include <dev/ic/adwmcode.h>",
      "#include <dev/ic/adw.h>",
      "#include <dev/ic/adwlib.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/queue.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void AdvDelayMicroSecond"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "n"
          ],
          "line": 2566
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/adwmcode.h>\n#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void AdvDelayMicroSecond;\n\nstatic void\nAdvDelayMicroSecond(n)\nu_int32_t\tn;\n{\n\n\tDELAY(n);\n}"
  },
  {
    "function_name": "AdvSleepMilliSecond",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adwlib.c",
    "lines": "2552-2558",
    "snippet": "static void\nAdvSleepMilliSecond(n)\nu_int32_t\tn;\n{\n\n\tDELAY(n * 1000);\n}",
    "includes": [
      "#include <dev/ic/adwmcode.h>",
      "#include <dev/ic/adw.h>",
      "#include <dev/ic/adwlib.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/queue.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void AdvSleepMilliSecond"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "n * 1000"
          ],
          "line": 2557
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/adwmcode.h>\n#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void AdvSleepMilliSecond;\n\nstatic void\nAdvSleepMilliSecond(n)\nu_int32_t\tn;\n{\n\n\tDELAY(n * 1000);\n}"
  },
  {
    "function_name": "AdvSendIdleCmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adwlib.c",
    "lines": "2334-2393",
    "snippet": "int\nAdvSendIdleCmd(sc, idle_cmd, idle_cmd_parameter)\nADW_SOFTC      *sc;\nu_int16_t       idle_cmd;\nu_int32_t       idle_cmd_parameter;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint\t\tresult;\n\tu_int32_t\ts, i, j;\n \n\ts = splbio();\n\n\t/*\n\t * Clear the idle command status which is set by the microcode\n\t * to a non-zero value to indicate when the command is completed.\n\t * The non-zero result is one of the IDLE_CMD_STATUS_* values\n\t * defined in a_advlib.h.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_IDLE_CMD_STATUS, (u_int16_t) 0);\n\n\t/*\n\t * Write the idle command value after the idle command parameter\n\t * has been written to avoid a race condition. If the order is not\n\t * followed, the microcode may process the idle command before the\n\t * parameters have been written to LRAM.\n\t */\n\tADW_WRITE_DWORD_LRAM(iot, ioh, ASC_MC_IDLE_CMD_PARAMETER,\n\t    idle_cmd_parameter);\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_IDLE_CMD, idle_cmd);\n\n\t/*\n\t * Tickle the RISC to tell it to process the idle command.\n\t */\n\tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_TICKLE, ADV_TICKLE_B);\n\tif (sc->chip_type == ADV_CHIP_ASC3550) {\n\t\t/*\n\t\t * Clear the tickle value. In the ASC-3550 the RISC flag\n\t\t * command 'clr_tickle_b' does not work unless the host\n\t\t * value is cleared.\n\t\t */\n\t\tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_TICKLE, ADV_TICKLE_NOP);\n\t}\n\n\t/* Wait for up to 100 millisecond for the idle command to timeout. */\n\tfor (i = 0; i < SCSI_WAIT_100_MSEC; i++) {\n\t\t/* Poll once each microsecond for command completion. */\n\t\tfor (j = 0; j < SCSI_US_PER_MSEC; j++) {\n\t\t\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_IDLE_CMD_STATUS, result);\n\t\t\tif (result != 0) {\n\t\t\t\tsplx(s);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tAdvDelayMicroSecond(1);\n\t\t}\n\t}\n\n\tsplx(s);\n\treturn ADW_ERROR;\n}",
    "includes": [
      "#include <dev/ic/adwmcode.h>",
      "#include <dev/ic/adw.h>",
      "#include <dev/ic/adwlib.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/queue.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void AdvDelayMicroSecond",
      "ADW_SOFTC\t*sc;",
      "bus_space_tag_t iot = sc->sc_iot;",
      "bus_space_handle_t ioh = sc->sc_ioh;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 2391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AdvDelayMicroSecond",
          "args": [
            "1"
          ],
          "line": 2387
        },
        "resolved": true,
        "details": {
          "function_name": "AdvDelayMicroSecond",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adwlib.c",
          "lines": "2561-2567",
          "snippet": "static void\nAdvDelayMicroSecond(n)\nu_int32_t\tn;\n{\n\n\tDELAY(n);\n}",
          "includes": [
            "#include <dev/ic/adwmcode.h>",
            "#include <dev/ic/adw.h>",
            "#include <dev/ic/adwlib.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/queue.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void AdvDelayMicroSecond"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/adwmcode.h>\n#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void AdvDelayMicroSecond;\n\nstatic void\nAdvDelayMicroSecond(n)\nu_int32_t\tn;\n{\n\n\tDELAY(n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 2384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_READ_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_IDLE_CMD_STATUS",
            "result"
          ],
          "line": 2382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_BYTE_REGISTER",
          "args": [
            "iot",
            "ioh",
            "IOPB_TICKLE",
            "ADV_TICKLE_NOP"
          ],
          "line": 2375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_BYTE_REGISTER",
          "args": [
            "iot",
            "ioh",
            "IOPB_TICKLE",
            "ADV_TICKLE_B"
          ],
          "line": 2368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_IDLE_CMD",
            "idle_cmd"
          ],
          "line": 2363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_DWORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_IDLE_CMD_PARAMETER",
            "idle_cmd_parameter"
          ],
          "line": 2361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_IDLE_CMD_STATUS",
            "(u_int16_t) 0"
          ],
          "line": 2353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 2345
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/adwmcode.h>\n#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void AdvDelayMicroSecond;\nADW_SOFTC\t*sc;\nbus_space_tag_t iot = sc->sc_iot;\nbus_space_handle_t ioh = sc->sc_ioh;\n\nint\nAdvSendIdleCmd(sc, idle_cmd, idle_cmd_parameter)\nADW_SOFTC      *sc;\nu_int16_t       idle_cmd;\nu_int32_t       idle_cmd_parameter;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint\t\tresult;\n\tu_int32_t\ts, i, j;\n \n\ts = splbio();\n\n\t/*\n\t * Clear the idle command status which is set by the microcode\n\t * to a non-zero value to indicate when the command is completed.\n\t * The non-zero result is one of the IDLE_CMD_STATUS_* values\n\t * defined in a_advlib.h.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_IDLE_CMD_STATUS, (u_int16_t) 0);\n\n\t/*\n\t * Write the idle command value after the idle command parameter\n\t * has been written to avoid a race condition. If the order is not\n\t * followed, the microcode may process the idle command before the\n\t * parameters have been written to LRAM.\n\t */\n\tADW_WRITE_DWORD_LRAM(iot, ioh, ASC_MC_IDLE_CMD_PARAMETER,\n\t    idle_cmd_parameter);\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_IDLE_CMD, idle_cmd);\n\n\t/*\n\t * Tickle the RISC to tell it to process the idle command.\n\t */\n\tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_TICKLE, ADV_TICKLE_B);\n\tif (sc->chip_type == ADV_CHIP_ASC3550) {\n\t\t/*\n\t\t * Clear the tickle value. In the ASC-3550 the RISC flag\n\t\t * command 'clr_tickle_b' does not work unless the host\n\t\t * value is cleared.\n\t\t */\n\t\tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_TICKLE, ADV_TICKLE_NOP);\n\t}\n\n\t/* Wait for up to 100 millisecond for the idle command to timeout. */\n\tfor (i = 0; i < SCSI_WAIT_100_MSEC; i++) {\n\t\t/* Poll once each microsecond for command completion. */\n\t\tfor (j = 0; j < SCSI_US_PER_MSEC; j++) {\n\t\t\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_IDLE_CMD_STATUS, result);\n\t\t\tif (result != 0) {\n\t\t\t\tsplx(s);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tAdvDelayMicroSecond(1);\n\t\t}\n\t}\n\n\tsplx(s);\n\treturn ADW_ERROR;\n}"
  },
  {
    "function_name": "AdvISR",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adwlib.c",
    "lines": "2176-2317",
    "snippet": "int\nAdvISR(sc)\nADW_SOFTC\t*sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tu_int8_t\tint_stat;\n\tu_int16_t\ttarget_bit;\n\tADW_CARRIER\t*free_carrp/*, *ccb_carr*/;\n\tu_int32_t\tirq_next_pa;\n\tADW_SCSI_REQ_Q\t*scsiq;\n\tADW_CCB\t\t*ccb;\n//\tint\t\ti;\n\n\n\t/* Reading the register clears the interrupt. */\n\tint_stat = ADW_READ_BYTE_REGISTER(iot, ioh, IOPB_INTR_STATUS_REG);\n\n\tif ((int_stat & (ADW_INTR_STATUS_INTRA | ADW_INTR_STATUS_INTRB |\n\t     ADW_INTR_STATUS_INTRC)) == 0) {\n\t\treturn ADW_FALSE;\n\t}\n\n\tbus_dmamap_sync(sc->sc_dmat, sc->sc_control->dmamap_xfer,\n\t\tBUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);\n\tbus_dmamap_unload(sc->sc_dmat, sc->sc_control->dmamap_xfer);\n\n/*\tccb_carr = sc->irq_sp;\n\tfor(i=0; i<2 && ccb_carr != ASC_CQ_STOPPER; i++) {\n\t\tbus_dmamap_sync(sc->sc_dmat, ccb_carr->dmamap_xfer, 0,\n\t\t\tccb_carr->dmamap_xfer->dm_mapsize,\n\t\t\tBUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);\n\t\tbus_dmamap_unload(sc->sc_dmat, ccb_carr->dmamap_xfer);\n\t\tccb_carr = adw_carrier_phys_kv(sc,\n\t\t\tASC_GET_CARRP(ccb_carr->next_vpa));\n\t}\n*/\n\t/*\n\t * Notify the driver of an asynchronous microcode condition by\n\t * calling the ADV_DVC_VAR.async_callback function. The function\n\t * is passed the microcode ASC_MC_INTRB_CODE byte value.\n\t */\n\tif (int_stat & ADW_INTR_STATUS_INTRB) {\n\t\tu_int8_t intrb_code;\n\n\t\tADW_READ_BYTE_LRAM(iot, ioh, ASC_MC_INTRB_CODE, intrb_code);\n\t\tif (intrb_code == ADV_ASYNC_CARRIER_READY_FAILURE &&\n\t\t    sc->carr_pending_cnt != 0) {\n\t\t    ADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_TICKLE, ADV_TICKLE_A);\n\t\t    if (sc->chip_type == ADV_CHIP_ASC3550) {\n\t\t    \tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_TICKLE, ADV_TICKLE_NOP);\n\t\t    }\n\t\t}\n\n\t\tif (sc->async_callback != 0) {\n\t\t    (*(ADW_ASYNC_CALLBACK)sc->async_callback)(sc, intrb_code);\n\t\t}\n\t}\n\n\t/*\n\t * Check if the IRQ stopper carrier contains a completed request.\n\t */\n\twhile (((irq_next_pa = sc->irq_sp->next_vpa) & ASC_RQ_DONE) != 0)\n\t{\n\t\t/*\n\t\t * Get a pointer to the newly completed ADW_SCSI_REQ_Q structure.\n\t\t * The RISC will have set 'areq_vpa' to a virtual address.\n\t\t *\n\t\t * The firmware will have copied the ASC_SCSI_REQ_Q.ccb_ptr\n\t\t * field to the carrier ADV_CARR_T.areq_vpa field. The conversion\n\t\t * below complements the conversion of ASC_SCSI_REQ_Q.scsiq_ptr'\n\t\t * in AdvExeScsiQueue().\n\t\t */\n\t\tccb = adw_ccb_phys_kv(sc, sc->irq_sp->areq_vpa);\n\t\tscsiq = &ccb->scsiq;\n\t\tscsiq->ccb_ptr = sc->irq_sp->areq_vpa;\n\n/*\t\tccb_carr = ccb->carr_list;\n\t\twhile(ccb_carr != ASC_CQ_STOPPER) {\n\t\t\tbus_dmamap_sync(sc->sc_dmat, ccb_carr->dmamap_xfer, 0,\n\t\t\t\tccb_carr->dmamap_xfer->dm_mapsize,\n\t\t\t\tBUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);\n\t\t\tbus_dmamap_unload(sc->sc_dmat, ccb_carr->dmamap_xfer);\n\t\t\tccb_carr = adw_carrier_phys_kv(sc,\n\t\t\t\tASC_GET_CARRP(ccb_carr->next_vpa));\n\t\t}\n\n\t\tbus_dmamap_sync(sc->sc_dmat, sc->irq_sp->dmamap_xfer, 0,\n\t\t\tsc->irq_sp->dmamap_xfer->dm_mapsize,\n\t\t\tBUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);\n\t\tbus_dmamap_unload(sc->sc_dmat, sc->irq_sp->dmamap_xfer);\n*/\n\t\t/*\n\t\t * Advance the stopper pointer to the next carrier\n\t\t * ignoring the lower four bits. Free the previous\n\t\t * stopper carrier.\n\t\t */\n\t\tfree_carrp = sc->irq_sp;\n\t\tsc->irq_sp = adw_carrier_phys_kv(sc, ASC_GET_CARRP(irq_next_pa));\n\n\t\tfree_carrp->next_vpa = sc->carr_freelist->carr_pa;\n\t\tsc->carr_freelist = free_carrp;\n\t\tsc->carr_pending_cnt--;\n\n\n\t\ttarget_bit = ADW_TID_TO_TIDMASK(scsiq->target_id);\n\n\t\t/*\n\t\t * Clear request microcode control flag.\n\t\t */\n\t\tscsiq->cntl = 0;\n\n\t\t/*\n\t\t * Check Condition handling\n\t\t */\n\t\t/*\n\t\t * If the command that completed was a SCSI INQUIRY and\n\t\t * LUN 0 was sent the command, then process the INQUIRY\n\t\t * command information for the device.\n\t\t */\n\t\tif (scsiq->done_status == QD_NO_ERROR &&\n\t\t    \t scsiq->cdb[0] == INQUIRY &&\n\t\t    \t scsiq->target_lun == 0) {\n\t\t\tAdvInquiryHandling(sc, scsiq);\n\t\t}\n\n\t\t/*\n\t\t * Notify the driver of the completed request by passing\n\t\t * the ADW_SCSI_REQ_Q pointer to its callback function.\n\t\t */\n\t\t(*(ADW_ISR_CALLBACK)sc->isr_callback)(sc, scsiq);\n\t\t/*\n\t\t * Note: After the driver callback function is called, 'scsiq'\n\t\t * can no longer be referenced.\n\t\t *\n\t\t * Fall through and continue processing other completed\n\t\t * requests...\n\t\t */\n\t}\n\n\treturn ADW_TRUE;\n}",
    "includes": [
      "#include <dev/ic/adwmcode.h>",
      "#include <dev/ic/adw.h>",
      "#include <dev/ic/adwlib.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/queue.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void AdvInquiryHandling",
      "ADW_SOFTC\t*sc;",
      "ADW_SCSI_REQ_Q *scsiq;",
      "bus_space_tag_t iot = sc->sc_iot;",
      "bus_space_handle_t ioh = sc->sc_ioh;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "scsiq"
          ],
          "line": 2306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AdvInquiryHandling",
          "args": [
            "sc",
            "scsiq"
          ],
          "line": 2299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_TID_TO_TIDMASK",
          "args": [
            "scsiq->target_id"
          ],
          "line": 2281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adw_carrier_phys_kv",
          "args": [
            "sc",
            "ASC_GET_CARRP(irq_next_pa)"
          ],
          "line": 2274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASC_GET_CARRP",
          "args": [
            "irq_next_pa"
          ],
          "line": 2274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adw_ccb_phys_kv",
          "args": [
            "sc",
            "sc->irq_sp->areq_vpa"
          ],
          "line": 2249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "intrb_code"
          ],
          "line": 2231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_BYTE_REGISTER",
          "args": [
            "iot",
            "ioh",
            "IOPB_TICKLE",
            "ADV_TICKLE_NOP"
          ],
          "line": 2226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_BYTE_REGISTER",
          "args": [
            "iot",
            "ioh",
            "IOPB_TICKLE",
            "ADV_TICKLE_A"
          ],
          "line": 2224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_READ_BYTE_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_INTRB_CODE",
            "intrb_code"
          ],
          "line": 2221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_unload",
          "args": [
            "sc->sc_dmat",
            "sc->sc_control->dmamap_xfer"
          ],
          "line": 2201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_sync",
          "args": [
            "sc->sc_dmat",
            "sc->sc_control->dmamap_xfer",
            "BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE"
          ],
          "line": 2199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_READ_BYTE_REGISTER",
          "args": [
            "iot",
            "ioh",
            "IOPB_INTR_STATUS_REG"
          ],
          "line": 2192
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/adwmcode.h>\n#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void AdvInquiryHandling;\nADW_SOFTC\t*sc;\nADW_SCSI_REQ_Q *scsiq;\nbus_space_tag_t iot = sc->sc_iot;\nbus_space_handle_t ioh = sc->sc_ioh;\n\nint\nAdvISR(sc)\nADW_SOFTC\t*sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tu_int8_t\tint_stat;\n\tu_int16_t\ttarget_bit;\n\tADW_CARRIER\t*free_carrp/*, *ccb_carr*/;\n\tu_int32_t\tirq_next_pa;\n\tADW_SCSI_REQ_Q\t*scsiq;\n\tADW_CCB\t\t*ccb;\n//\tint\t\ti;\n\n\n\t/* Reading the register clears the interrupt. */\n\tint_stat = ADW_READ_BYTE_REGISTER(iot, ioh, IOPB_INTR_STATUS_REG);\n\n\tif ((int_stat & (ADW_INTR_STATUS_INTRA | ADW_INTR_STATUS_INTRB |\n\t     ADW_INTR_STATUS_INTRC)) == 0) {\n\t\treturn ADW_FALSE;\n\t}\n\n\tbus_dmamap_sync(sc->sc_dmat, sc->sc_control->dmamap_xfer,\n\t\tBUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);\n\tbus_dmamap_unload(sc->sc_dmat, sc->sc_control->dmamap_xfer);\n\n/*\tccb_carr = sc->irq_sp;\n\tfor(i=0; i<2 && ccb_carr != ASC_CQ_STOPPER; i++) {\n\t\tbus_dmamap_sync(sc->sc_dmat, ccb_carr->dmamap_xfer, 0,\n\t\t\tccb_carr->dmamap_xfer->dm_mapsize,\n\t\t\tBUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);\n\t\tbus_dmamap_unload(sc->sc_dmat, ccb_carr->dmamap_xfer);\n\t\tccb_carr = adw_carrier_phys_kv(sc,\n\t\t\tASC_GET_CARRP(ccb_carr->next_vpa));\n\t}\n*/\n\t/*\n\t * Notify the driver of an asynchronous microcode condition by\n\t * calling the ADV_DVC_VAR.async_callback function. The function\n\t * is passed the microcode ASC_MC_INTRB_CODE byte value.\n\t */\n\tif (int_stat & ADW_INTR_STATUS_INTRB) {\n\t\tu_int8_t intrb_code;\n\n\t\tADW_READ_BYTE_LRAM(iot, ioh, ASC_MC_INTRB_CODE, intrb_code);\n\t\tif (intrb_code == ADV_ASYNC_CARRIER_READY_FAILURE &&\n\t\t    sc->carr_pending_cnt != 0) {\n\t\t    ADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_TICKLE, ADV_TICKLE_A);\n\t\t    if (sc->chip_type == ADV_CHIP_ASC3550) {\n\t\t    \tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_TICKLE, ADV_TICKLE_NOP);\n\t\t    }\n\t\t}\n\n\t\tif (sc->async_callback != 0) {\n\t\t    (*(ADW_ASYNC_CALLBACK)sc->async_callback)(sc, intrb_code);\n\t\t}\n\t}\n\n\t/*\n\t * Check if the IRQ stopper carrier contains a completed request.\n\t */\n\twhile (((irq_next_pa = sc->irq_sp->next_vpa) & ASC_RQ_DONE) != 0)\n\t{\n\t\t/*\n\t\t * Get a pointer to the newly completed ADW_SCSI_REQ_Q structure.\n\t\t * The RISC will have set 'areq_vpa' to a virtual address.\n\t\t *\n\t\t * The firmware will have copied the ASC_SCSI_REQ_Q.ccb_ptr\n\t\t * field to the carrier ADV_CARR_T.areq_vpa field. The conversion\n\t\t * below complements the conversion of ASC_SCSI_REQ_Q.scsiq_ptr'\n\t\t * in AdvExeScsiQueue().\n\t\t */\n\t\tccb = adw_ccb_phys_kv(sc, sc->irq_sp->areq_vpa);\n\t\tscsiq = &ccb->scsiq;\n\t\tscsiq->ccb_ptr = sc->irq_sp->areq_vpa;\n\n/*\t\tccb_carr = ccb->carr_list;\n\t\twhile(ccb_carr != ASC_CQ_STOPPER) {\n\t\t\tbus_dmamap_sync(sc->sc_dmat, ccb_carr->dmamap_xfer, 0,\n\t\t\t\tccb_carr->dmamap_xfer->dm_mapsize,\n\t\t\t\tBUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);\n\t\t\tbus_dmamap_unload(sc->sc_dmat, ccb_carr->dmamap_xfer);\n\t\t\tccb_carr = adw_carrier_phys_kv(sc,\n\t\t\t\tASC_GET_CARRP(ccb_carr->next_vpa));\n\t\t}\n\n\t\tbus_dmamap_sync(sc->sc_dmat, sc->irq_sp->dmamap_xfer, 0,\n\t\t\tsc->irq_sp->dmamap_xfer->dm_mapsize,\n\t\t\tBUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);\n\t\tbus_dmamap_unload(sc->sc_dmat, sc->irq_sp->dmamap_xfer);\n*/\n\t\t/*\n\t\t * Advance the stopper pointer to the next carrier\n\t\t * ignoring the lower four bits. Free the previous\n\t\t * stopper carrier.\n\t\t */\n\t\tfree_carrp = sc->irq_sp;\n\t\tsc->irq_sp = adw_carrier_phys_kv(sc, ASC_GET_CARRP(irq_next_pa));\n\n\t\tfree_carrp->next_vpa = sc->carr_freelist->carr_pa;\n\t\tsc->carr_freelist = free_carrp;\n\t\tsc->carr_pending_cnt--;\n\n\n\t\ttarget_bit = ADW_TID_TO_TIDMASK(scsiq->target_id);\n\n\t\t/*\n\t\t * Clear request microcode control flag.\n\t\t */\n\t\tscsiq->cntl = 0;\n\n\t\t/*\n\t\t * Check Condition handling\n\t\t */\n\t\t/*\n\t\t * If the command that completed was a SCSI INQUIRY and\n\t\t * LUN 0 was sent the command, then process the INQUIRY\n\t\t * command information for the device.\n\t\t */\n\t\tif (scsiq->done_status == QD_NO_ERROR &&\n\t\t    \t scsiq->cdb[0] == INQUIRY &&\n\t\t    \t scsiq->target_lun == 0) {\n\t\t\tAdvInquiryHandling(sc, scsiq);\n\t\t}\n\n\t\t/*\n\t\t * Notify the driver of the completed request by passing\n\t\t * the ADW_SCSI_REQ_Q pointer to its callback function.\n\t\t */\n\t\t(*(ADW_ISR_CALLBACK)sc->isr_callback)(sc, scsiq);\n\t\t/*\n\t\t * Note: After the driver callback function is called, 'scsiq'\n\t\t * can no longer be referenced.\n\t\t *\n\t\t * Fall through and continue processing other completed\n\t\t * requests...\n\t\t */\n\t}\n\n\treturn ADW_TRUE;\n}"
  },
  {
    "function_name": "AdvResetSCSIBus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adwlib.c",
    "lines": "2077-2154",
    "snippet": "int\nAdvResetSCSIBus(sc)\nADW_SOFTC\t*sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint\t\tstatus;\n\tu_int16_t\twdtr_able, sdtr_able, tagqng_able;\n\tu_int8_t\ttid, max_cmd[ADW_MAX_TID + 1];\n\tu_int16_t\tbios_sig;\n\n\n\t/*\n\t * Save current per TID negotiated values.\n\t */\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_WDTR_ABLE, wdtr_able);\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_SDTR_ABLE, sdtr_able);\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_TAGQNG_ABLE, tagqng_able);\n\tfor (tid = 0; tid <= ADW_MAX_TID; tid++)\n\t{\n\t\tADW_READ_BYTE_LRAM(iot, ioh, ASC_MC_NUMBER_OF_MAX_CMD + tid,\n\t\t\tmax_cmd[tid]);\n\t}\n\n\t/*\n\t * Force the AdvInitAsc3550/38C0800Driver() function to\n\t * perform a SCSI Bus Reset by clearing the BIOS signature word.\n\t * The initialization functions assumes a SCSI Bus Reset is not\n\t * needed if the BIOS signature word is present.\n\t */\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_BIOS_SIGNATURE, bios_sig);\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_BIOS_SIGNATURE, 0);\n\n\t/*\n\t * Stop chip and reset it.\n\t */\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_RISC_CSR, ADW_RISC_CSR_STOP);\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_CTRL_REG,\n\t\t\tADW_CTRL_REG_CMD_RESET);\n\tAdvSleepMilliSecond(100);\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_CTRL_REG,\n\t\t\tADW_CTRL_REG_CMD_WR_IO_REG);\n\n\t/*\n\t * Reset Adv Library error code, if any, and try\n\t * re-initializing the chip.\n\t */\n\tif (sc->chip_type == ADV_CHIP_ASC38C0800) {\n\t\tstatus = AdvInitAsc38C0800Driver(sc);\n\t} else {\n\t\tstatus = AdvInitAsc3550Driver(sc);\n\t}\n\n\t/* Translate initialization return value to status value. */\n\tif (status == 0) {\n\t\tstatus = ADW_TRUE;\n\t} else {\n\t\tstatus = ADW_FALSE;\n\t}\n\n\t/*\n\t * Restore the BIOS signature word.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_BIOS_SIGNATURE, bios_sig);\n\n\t/*\n\t * Restore per TID negotiated values.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_WDTR_ABLE, wdtr_able);\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_ABLE, sdtr_able);\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_TAGQNG_ABLE, tagqng_able);\n\tfor (tid = 0; tid <= ADW_MAX_TID; tid++) {\n\t\tADW_WRITE_BYTE_LRAM(iot, ioh, ASC_MC_NUMBER_OF_MAX_CMD + tid,\n\t\t\tmax_cmd[tid]);\n\t}\n\n\treturn status;\n}",
    "includes": [
      "#include <dev/ic/adwmcode.h>",
      "#include <dev/ic/adw.h>",
      "#include <dev/ic/adwlib.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/queue.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void AdvSleepMilliSecond",
      "ADW_SOFTC\t*sc;",
      "bus_space_tag_t iot = sc->sc_iot;",
      "bus_space_handle_t ioh = sc->sc_ioh;",
      "u_int8_t\t\ttid;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ADW_WRITE_BYTE_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_NUMBER_OF_MAX_CMD + tid",
            "max_cmd[tid]"
          ],
          "line": 2149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_TAGQNG_ABLE",
            "tagqng_able"
          ],
          "line": 2147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_SDTR_ABLE",
            "sdtr_able"
          ],
          "line": 2146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_WDTR_ABLE",
            "wdtr_able"
          ],
          "line": 2145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_BIOS_SIGNATURE",
            "bios_sig"
          ],
          "line": 2140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AdvInitAsc3550Driver",
          "args": [
            "sc"
          ],
          "line": 2127
        },
        "resolved": true,
        "details": {
          "function_name": "AdvInitAsc3550Driver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adwlib.c",
          "lines": "217-713",
          "snippet": "int\nAdvInitAsc3550Driver(sc)\nADW_SOFTC      *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tu_int16_t\twarn_code;\n\tu_int32_t\tsum;\n\tint\t\tbegin_addr;\n\tint\t\tend_addr;\n\tu_int16_t\tcode_sum;\n\tint\t\tword;\n\tint\t\ti, j;\n\tint\t\tadv_asc3550_expanded_size;\n\tu_int16_t\tscsi_cfg1;\n\tu_int8_t\ttid;\n\tu_int16_t\tbios_mem[ASC_MC_BIOSLEN/2];\t/* BIOS RISC Memory\n\t\t\t\t\t\t\t\t0x40-0x8F. */\n\tu_int16_t\twdtr_able = 0, sdtr_able, tagqng_able;\n\tu_int8_t\tmax_cmd[ADW_MAX_TID + 1];\n\n\n\twarn_code = 0;\n\n\t/*\n\t * Save the RISC memory BIOS region before writing the microcode.\n\t * The BIOS may already be loaded and using its RISC LRAM region\n\t * so its region must be saved and restored.\n\t *\n\t * Note: This code makes the assumption, which is currently true,\n\t * that a chip reset does not clear RISC LRAM.\n\t */\n\tfor (i = 0; i < ASC_MC_BIOSLEN/2; i++) {\n\t\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_BIOSMEM + (2*i), bios_mem[i]);\n\t}\n\n\t/*\n\t * Save current per TID negotiated values.\n\t */\n\tif (bios_mem[(ASC_MC_BIOS_SIGNATURE - ASC_MC_BIOSMEM)/2] == 0x55AA) {\n\n\t\tu_int16_t  bios_version, major, minor;\n\n\t\tbios_version = bios_mem[(ASC_MC_BIOS_VERSION-ASC_MC_BIOSMEM)/2];\n\t\tmajor = (bios_version  >> 12) & 0xF;\n\t\tminor = (bios_version  >> 8) & 0xF;\n\t\tif (major < 3 || (major == 3 && minor == 1)) {\n\t\t    /* BIOS 3.1 and earlier location of 'wdtr_able' variable. */\n\t\t    ADW_READ_WORD_LRAM(iot, ioh, 0x120, wdtr_able);\n\t\t} else {\n\t\t    ADW_READ_WORD_LRAM(iot, ioh, ASC_MC_WDTR_ABLE, wdtr_able);\n\t\t}\n\t}\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_SDTR_ABLE, sdtr_able);\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_TAGQNG_ABLE, tagqng_able);\n\tfor (tid = 0; tid <= ADW_MAX_TID; tid++) {\n\t\tADW_READ_BYTE_LRAM(iot, ioh, ASC_MC_NUMBER_OF_MAX_CMD + tid,\n\t\t\tmax_cmd[tid]);\n\t}\n\n\t/*\n\t * Load the Microcode\n\t *\n\t * Write the microcode image to RISC memory starting at address 0.\n\t */\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_RAM_ADDR, 0);\n\n\t/* Assume the following compressed format of the microcode buffer:\n\t *\n\t *  254 word (508 byte) table indexed by byte code followed\n\t *  by the following byte codes:\n\t *\n\t *    1-Byte Code:\n\t *\t00: Emit word 0 in table.\n\t *\t01: Emit word 1 in table.\n\t *\t.\n\t *\tFD: Emit word 253 in table.\n\t *\n\t *    Multi-Byte Code:\n\t *\tFE WW WW: (3 byte code) Word to emit is the next word WW WW.\n\t *\tFF BB WW WW: (4 byte code) Emit BB count times next word WW WW.\n\t */\n\tword = 0;\n\tfor (i = 253 * 2; i < adv_asc3550_mcode_size; i++) {\n\t\tif (adv_asc3550_mcode[i] == 0xff) {\n\t\t\tfor (j = 0; j < adv_asc3550_mcode[i + 1]; j++) {\n\t\t\t\tADW_WRITE_WORD_AUTO_INC_LRAM(iot, ioh,\n\t\t\t\t  (((u_int16_t)adv_asc3550_mcode[i + 3] << 8) |\n\t\t\t\t  adv_asc3550_mcode[i + 2]));\n\t\t\t\tword++;\n\t\t\t}\n\t\t\ti += 3;\n\t\t} else if (adv_asc3550_mcode[i] == 0xfe) {\n\t\t\tADW_WRITE_WORD_AUTO_INC_LRAM(iot, ioh,\n\t\t\t    (((u_int16_t)adv_asc3550_mcode[i + 2] << 8) |\n\t\t\t    adv_asc3550_mcode[i + 1]));\n\t\t\ti += 2;\n\t\t\tword++;\n\t\t} else {\n\t\t\tADW_WRITE_WORD_AUTO_INC_LRAM(iot, ioh, (((u_int16_t)\n\t\t\t adv_asc3550_mcode[(adv_asc3550_mcode[i] * 2) + 1] <<8) |\n\t\t\t adv_asc3550_mcode[adv_asc3550_mcode[i] * 2]));\n\t\t\tword++;\n\t\t}\n\t}\n\n\t/*\n\t * Set 'word' for later use to clear the rest of memory and save\n\t * the expanded mcode size.\n\t */\n\tword *= 2;\n\tadv_asc3550_expanded_size = word;\n\n\t/*\n\t * Clear the rest of ASC-3550 Internal RAM (8KB).\n\t */\n\tfor (; word < ADV_3550_MEMSIZE; word += 2) {\n\t\tADW_WRITE_WORD_AUTO_INC_LRAM(iot, ioh, 0);\n\t}\n\n\t/*\n\t * Verify the microcode checksum.\n\t */\n\tsum = 0;\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_RAM_ADDR, 0);\n\n\tfor (word = 0; word < adv_asc3550_expanded_size; word += 2) {\n\t\tsum += ADW_READ_WORD_AUTO_INC_LRAM(iot, ioh);\n\t}\n\n\tif (sum != adv_asc3550_mcode_chksum) {\n\t\treturn ASC_IERR_MCODE_CHKSUM;\n\t}\n\n\t/*\n\t * Restore the RISC memory BIOS region.\n\t */\n\tfor (i = 0; i < ASC_MC_BIOSLEN/2; i++) {\n\t\tADW_WRITE_BYTE_LRAM(iot, ioh, ASC_MC_BIOSMEM + (2 * i),\n\t\t\t\tbios_mem[i]);\n\t}\n\n\t/*\n\t * Calculate and write the microcode code checksum to the microcode\n\t * code checksum location ASC_MC_CODE_CHK_SUM (0x2C).\n\t */\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_CODE_BEGIN_ADDR, begin_addr);\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_CODE_END_ADDR, end_addr);\n\tcode_sum = 0;\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_RAM_ADDR, begin_addr);\n\tfor (word = begin_addr; word < end_addr; word += 2) {\n\t\tcode_sum += ADW_READ_WORD_AUTO_INC_LRAM(iot, ioh);\n\t}\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_CODE_CHK_SUM, code_sum);\n\n\t/*\n\t * Read and save microcode version and date.\n\t */\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_VERSION_DATE,\n\t\t\tsc->cfg.mcode_date);\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_VERSION_NUM,\n\t\t\tsc->cfg.mcode_version);\n\n\t/*\n\t * Set the chip type to indicate the ASC3550.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_CHIP_TYPE, ADV_CHIP_ASC3550);\n\n\t/*\n\t * If the PCI Configuration Command Register \"Parity Error Response\n\t * Control\" Bit was clear (0), then set the microcode variable\n\t * 'control_flag' CONTROL_FLAG_IGNORE_PERR flag to tell the microcode\n\t * to ignore DMA parity errors.\n\t */\n\tif (sc->cfg.control_flag & CONTROL_FLAG_IGNORE_PERR) {\n\t\t/*\n\t\t * Note: Don't remove the use of a temporary variable in\n\t\t * the following code, otherwise some  C compiler\n\t\t * might turn the following lines into a no-op.\n\t\t */\n\t\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_CONTROL_FLAG, word);\n\t\tword |= CONTROL_FLAG_IGNORE_PERR;\n\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_CONTROL_FLAG, word);\n\t}\n\n\t/*\n\t * For ASC-3550, setting the START_CTL_EMFU [3:2] bits sets a FIFO\n\t * threshold of 128 bytes. This register is only accessible to the host.\n\t */\n\tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_DMA_CFG0,\n\t\t\tSTART_CTL_EMFU | READ_CMD_MRM);\n\n\t/*\n\t * Microcode operating variables for WDTR, SDTR, and command tag\n\t * queuing will be set in AdvInquiryHandling() based on what a\n\t * device reports it is capable of in Inquiry byte 7.\n\t *\n\t * If SCSI Bus Resets haev been disabled, then directly set\n\t * SDTR and WDTR from the EEPROM configuration. This will allow\n\t * the BIOS and warm boot to work without a SCSI bus hang on\n\t * the Inquiry caused by host and target mismatched DTR values.\n\t * Without the SCSI Bus Reset, before an Inquiry a device can't\n\t * be assumed to be in Asynchronous, Narrow mode.\n\t */\n\tif ((sc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS) == 0) {\n\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_WDTR_ABLE,\n\t\t\t\tsc->wdtr_able);\n\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_ABLE,\n\t\t\t\tsc->sdtr_able);\n\t}\n\n\t/*\n\t * Set microcode operating variables for SDTR_SPEED1, SDTR_SPEED2,\n\t * SDTR_SPEED3, and SDTR_SPEED4 based on the ULTRA EEPROM per TID\n\t * bitmask. These values determine the maximum SDTR speed negotiated\n\t * with a device.\n\t *\n\t * The SDTR per TID bitmask overrides the SDTR_SPEED1, SDTR_SPEED2,\n\t * SDTR_SPEED3, and SDTR_SPEED4 values so it is safe to set them\n\t * without determining here whether the device supports SDTR.\n\t *\n\t * 4-bit speed  SDTR speed name\n\t * ===========  ===============\n\t * 0000b (0x0)  SDTR disabled\n\t * 0001b (0x1)  5 Mhz\n\t * 0010b (0x2)  10 Mhz\n\t * 0011b (0x3)  20 Mhz (Ultra)\n\t * 0100b (0x4)  40 Mhz (LVD/Ultra2)\n\t * 0101b (0x5)  80 Mhz (LVD2/Ultra3)\n\t * 0110b (0x6)  Undefined\n\t * .\n\t * 1111b (0xF)  Undefined\n\t */\n\tword = 0;\n\tfor (tid = 0; tid <= ADW_MAX_TID; tid++) {\n\t\tif (ADW_TID_TO_TIDMASK(tid) & sc->ultra_able) {\n\t\t\t/* Set Ultra speed for TID 'tid'. */\n\t\t\tword |= (0x3 << (4 * (tid % 4)));\n\t\t} else {\n\t\t\t/* Set Fast speed for TID 'tid'. */\n\t\t\tword |= (0x2 << (4 * (tid % 4)));\n\t\t}\n\t\t/* Check if done with sdtr_speed1. */\n\t\tif (tid == 3) {\n\t\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_SPEED1, word);\n\t\t\tword = 0;\n\t\t/* Check if done with sdtr_speed2. */\n\t\t} else if (tid == 7) {\n\t\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_SPEED2, word);\n\t\t\tword = 0;\n\t\t/* Check if done with sdtr_speed3. */\n\t\t} else if (tid == 11) {\n\t\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_SPEED3, word);\n\t\t\tword = 0;\n\t\t/* Check if done with sdtr_speed4. */\n\t\t} else if (tid == 15) {\n\t\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_SPEED4, word);\n\t\t\t/* End of loop. */\n\t\t}\n\t}\n\n\t/*\n\t * Set microcode operating variable for the disconnect per TID bitmask.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DISC_ENABLE, sc->cfg.disc_enable);\n\n\n\t/*\n\t * Set SCSI_CFG0 Microcode Default Value.\n\t *\n\t * The microcode will set the SCSI_CFG0 register using this value\n\t * after it is started below.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DEFAULT_SCSI_CFG0,\n\t\tADW_PARITY_EN | ADW_SEL_TMO_LONG | ADW_OUR_ID_EN |\n\t\t\tsc->chip_scsi_id);\n\n\t/*\n\t * Determine SCSI_CFG1 Microcode Default Value.\n\t *\n\t * The microcode will set the SCSI_CFG1 register using this value\n\t * after it is started below.\n\t */\n\n\t/* Read current SCSI_CFG1 Register value. */\n\tscsi_cfg1 = ADW_READ_WORD_REGISTER(iot, ioh, IOPW_SCSI_CFG1);\n\n\t/*\n\t * If all three connectors are in use, return an error.\n\t */\n\tif ((scsi_cfg1 & CABLE_ILLEGAL_A) == 0 ||\n\t\t(scsi_cfg1 & CABLE_ILLEGAL_B) == 0) {\n\t\treturn ASC_IERR_ILLEGAL_CONNECTION;\n\t}\n\n\t/*\n\t * If the internal narrow cable is reversed all of the SCSI_CTRL\n\t * register signals will be set. Check for and return an error if\n\t * this condition is found.\n\t */\n\tif ((ADW_READ_WORD_REGISTER(iot, ioh, IOPW_SCSI_CTRL) & 0x3F07) ==\n\t\t\t0x3F07) {\n\t\treturn ASC_IERR_REVERSED_CABLE;\n\t}\n\n\t/*\n\t * If this is a differential board and a single-ended device\n\t * is attached to one of the connectors, return an error.\n\t */\n\tif ((scsi_cfg1 & ADW_DIFF_MODE) && (scsi_cfg1 & ADW_DIFF_SENSE) == 0) {\n\t\treturn ASC_IERR_SINGLE_END_DEVICE;\n\t}\n\n\t/*\n\t * If automatic termination control is enabled, then set the\n\t * termination value based on a table listed in a_condor.h.\n\t *\n\t * If manual termination was specified with an EEPROM setting\n\t * then 'termination' was set-up in AdvInitFrom3550EEPROM() and\n\t * is ready to be 'ored' into SCSI_CFG1.\n\t */\n\tif (sc->cfg.termination == 0) {\n\t\t/*\n\t\t * The software always controls termination by setting TERM_CTL_SEL.\n\t\t * If TERM_CTL_SEL were set to 0, the hardware would set termination.\n\t\t */\n\t\tsc->cfg.termination |= ADW_TERM_CTL_SEL;\n\n\t\tswitch(scsi_cfg1 & ADW_CABLE_DETECT) {\n\t\t\t/* TERM_CTL_H: on, TERM_CTL_L: on */\n\t\t\tcase 0x3: case 0x7: case 0xB: case 0xD: case 0xE: case 0xF:\n\t\t\t\tsc->cfg.termination |= (ADW_TERM_CTL_H | ADW_TERM_CTL_L);\n\t\t\t\tbreak;\n\n\t\t\t/* TERM_CTL_H: on, TERM_CTL_L: off */\n\t\t\tcase 0x1: case 0x5: case 0x9: case 0xA: case 0xC:\n\t\t\t\tsc->cfg.termination |= ADW_TERM_CTL_H;\n\t\t\t\tbreak;\n\n\t\t\t/* TERM_CTL_H: off, TERM_CTL_L: off */\n\t\t\tcase 0x2: case 0x6:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * Clear any set TERM_CTL_H and TERM_CTL_L bits.\n\t */\n\tscsi_cfg1 &= ~ADW_TERM_CTL;\n\n\t/*\n\t * Invert the TERM_CTL_H and TERM_CTL_L bits and then\n\t * set 'scsi_cfg1'. The TERM_POL bit does not need to be\n\t * referenced, because the hardware internally inverts\n\t * the Termination High and Low bits if TERM_POL is set.\n\t */\n\tscsi_cfg1 |= (ADW_TERM_CTL_SEL | (~sc->cfg.termination & ADW_TERM_CTL));\n\n\t/*\n\t * Set SCSI_CFG1 Microcode Default Value\n\t *\n\t * Set filter value and possibly modified termination control\n\t * bits in the Microcode SCSI_CFG1 Register Value.\n\t *\n\t * The microcode will set the SCSI_CFG1 register using this value\n\t * after it is started below.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DEFAULT_SCSI_CFG1,\n\t\tADW_FLTR_DISABLE | scsi_cfg1);\n\n\t/*\n\t * Set MEM_CFG Microcode Default Value\n\t *\n\t * The microcode will set the MEM_CFG register using this value\n\t * after it is started below.\n\t *\n\t * MEM_CFG may be accessed as a word or byte, but only bits 0-7\n\t * are defined.\n\t *\n\t * ASC-3550 has 8KB internal memory.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DEFAULT_MEM_CFG,\n\t\tADW_BIOS_EN | ADW_RAM_SZ_8KB);\n\n\t/*\n\t * Set SEL_MASK Microcode Default Value\n\t *\n\t * The microcode will set the SEL_MASK register using this value\n\t * after it is started below.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DEFAULT_SEL_MASK,\n\t\tADW_TID_TO_TIDMASK(sc->chip_scsi_id));\n\n\n\t/*\n\t * Set-up the Host->RISC Initiator Command Queue (ICQ) if\n\t * one is not already set up, i.e. this is the first\n\t * time through as opposed to a bus reset.\n\t */\n\n\tif (sc->icq_sp == NULL) {\n\t\tsc->carr_pending_cnt = 0;\n\t\tif ((sc->icq_sp = sc->carr_freelist) == NULL) {\n\t\t\treturn ASC_IERR_NO_CARRIER;\n\t\t}\n\t\tsc->carr_freelist = adw_carrier_phys_kv(sc,\n\t\t\t\tASC_GET_CARRP(sc->icq_sp->next_vpa));\n\n\t\t/*\n\t \t * The first command issued will be placed in the stopper carrier.\n\t\t */\n\t\tsc->icq_sp->next_vpa = ASC_CQ_STOPPER;\n\t}\n\n\t/*\n\t * Set RISC ICQ physical address start value.\n\t */\n\tADW_WRITE_DWORD_LRAM(iot, ioh, ASC_MC_ICQ, sc->icq_sp->carr_pa);\n\n\t/*\n\t * Set-up the RISC->Host Initiator Response Queue (IRQ) if\n\t * one is not already set up, i.e. this is the first\n\t * time through as opposed to a bus reset.\n\t */\n\tif (sc->irq_sp == NULL) {\n\t\tif ((sc->irq_sp = sc->carr_freelist) == NULL) {\n\t\t\treturn ASC_IERR_NO_CARRIER;\n\t\t}\n\t\tsc->carr_freelist = adw_carrier_phys_kv(sc,\n\t\t\t\tASC_GET_CARRP(sc->irq_sp->next_vpa));\n\n\t\t/*\n \t \t * The first command completed by the RISC will be placed in\n \t \t * the stopper.\n \t \t *\n \t \t * Note: Set 'next_vpa' to ASC_CQ_STOPPER. When the request is\n \t \t * completed the RISC will set the ASC_RQ_DONE bit.\n \t \t */\n\t\tsc->irq_sp->next_vpa = ASC_CQ_STOPPER;\n\t}\n\n\t/*\n \t * Set RISC IRQ physical address start value.\n \t */\n\tADW_WRITE_DWORD_LRAM(iot, ioh, ASC_MC_IRQ, sc->irq_sp->carr_pa);\n\n\tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_INTR_ENABLES,\n\t\t(ADW_INTR_ENABLE_HOST_INTR | ADW_INTR_ENABLE_GLOBAL_INTR));\n\n\t/*\n\t * Note: Don't remove the use of a temporary variable in\n\t * the following code, otherwise some C compiler\n\t * might turn the following lines into a no-op.\n\t */\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_CODE_BEGIN_ADDR, word);\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_PC, word);\n\n\t/* finally, finally, gentlemen, start your engine */\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_RISC_CSR, ADW_RISC_CSR_RUN);\n\n\t/*\n\t * Reset the SCSI Bus if the EEPROM indicates that SCSI Bus\n\t * Resets should be performed. The RISC has to be running\n\t * to issue a SCSI Bus Reset.\n\t */\n\tif (sc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS)\n\t{\n\t\t/*\n\t\t * If the BIOS Signature is present in memory, restore the\n\t\t * BIOS Handshake Configuration Table and do not perform\n\t\t * a SCSI Bus Reset.\n\t\t */\n\t\tif (bios_mem[(ASC_MC_BIOS_SIGNATURE - ASC_MC_BIOSMEM)/2] ==\n\t\t\t\t0x55AA) {\n\t\t\t/*\n\t\t\t * Restore per TID negotiated values.\n\t\t\t */\n\t\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_WDTR_ABLE,\n\t\t\t\t\twdtr_able);\n\t\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_ABLE,\n\t\t\t\t\tsdtr_able);\n\t\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_TAGQNG_ABLE,\n\t\t\t\t\ttagqng_able);\n\t\t\tfor (tid = 0; tid <= ADW_MAX_TID; tid++) {\n\t\t\t\tADW_WRITE_BYTE_LRAM(iot, ioh,\n\t\t\t\t\tASC_MC_NUMBER_OF_MAX_CMD + tid,\n\t\t\t\t\tmax_cmd[tid]);\n\t\t\t}\n\t\t} else {\n\t\t\tif (AdvResetCCB(sc) != ADW_TRUE) {\n\t\t\t\twarn_code = ASC_WARN_BUSRESET_ERROR;\n\t\t\t}\n\t\t}\n\t}\n\n    return warn_code;\n}",
          "includes": [
            "#include <dev/ic/adwmcode.h>",
            "#include <dev/ic/adw.h>",
            "#include <dev/ic/adwlib.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/queue.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void AdvInquiryHandling",
            "ADW_SOFTC\t*sc;",
            "bus_space_tag_t iot = sc->sc_iot;",
            "bus_space_handle_t ioh = sc->sc_ioh;",
            "u_int8_t\t\ttid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/adwmcode.h>\n#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void AdvInquiryHandling;\nADW_SOFTC\t*sc;\nbus_space_tag_t iot = sc->sc_iot;\nbus_space_handle_t ioh = sc->sc_ioh;\nu_int8_t\t\ttid;\n\nint\nAdvInitAsc3550Driver(sc)\nADW_SOFTC      *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tu_int16_t\twarn_code;\n\tu_int32_t\tsum;\n\tint\t\tbegin_addr;\n\tint\t\tend_addr;\n\tu_int16_t\tcode_sum;\n\tint\t\tword;\n\tint\t\ti, j;\n\tint\t\tadv_asc3550_expanded_size;\n\tu_int16_t\tscsi_cfg1;\n\tu_int8_t\ttid;\n\tu_int16_t\tbios_mem[ASC_MC_BIOSLEN/2];\t/* BIOS RISC Memory\n\t\t\t\t\t\t\t\t0x40-0x8F. */\n\tu_int16_t\twdtr_able = 0, sdtr_able, tagqng_able;\n\tu_int8_t\tmax_cmd[ADW_MAX_TID + 1];\n\n\n\twarn_code = 0;\n\n\t/*\n\t * Save the RISC memory BIOS region before writing the microcode.\n\t * The BIOS may already be loaded and using its RISC LRAM region\n\t * so its region must be saved and restored.\n\t *\n\t * Note: This code makes the assumption, which is currently true,\n\t * that a chip reset does not clear RISC LRAM.\n\t */\n\tfor (i = 0; i < ASC_MC_BIOSLEN/2; i++) {\n\t\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_BIOSMEM + (2*i), bios_mem[i]);\n\t}\n\n\t/*\n\t * Save current per TID negotiated values.\n\t */\n\tif (bios_mem[(ASC_MC_BIOS_SIGNATURE - ASC_MC_BIOSMEM)/2] == 0x55AA) {\n\n\t\tu_int16_t  bios_version, major, minor;\n\n\t\tbios_version = bios_mem[(ASC_MC_BIOS_VERSION-ASC_MC_BIOSMEM)/2];\n\t\tmajor = (bios_version  >> 12) & 0xF;\n\t\tminor = (bios_version  >> 8) & 0xF;\n\t\tif (major < 3 || (major == 3 && minor == 1)) {\n\t\t    /* BIOS 3.1 and earlier location of 'wdtr_able' variable. */\n\t\t    ADW_READ_WORD_LRAM(iot, ioh, 0x120, wdtr_able);\n\t\t} else {\n\t\t    ADW_READ_WORD_LRAM(iot, ioh, ASC_MC_WDTR_ABLE, wdtr_able);\n\t\t}\n\t}\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_SDTR_ABLE, sdtr_able);\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_TAGQNG_ABLE, tagqng_able);\n\tfor (tid = 0; tid <= ADW_MAX_TID; tid++) {\n\t\tADW_READ_BYTE_LRAM(iot, ioh, ASC_MC_NUMBER_OF_MAX_CMD + tid,\n\t\t\tmax_cmd[tid]);\n\t}\n\n\t/*\n\t * Load the Microcode\n\t *\n\t * Write the microcode image to RISC memory starting at address 0.\n\t */\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_RAM_ADDR, 0);\n\n\t/* Assume the following compressed format of the microcode buffer:\n\t *\n\t *  254 word (508 byte) table indexed by byte code followed\n\t *  by the following byte codes:\n\t *\n\t *    1-Byte Code:\n\t *\t00: Emit word 0 in table.\n\t *\t01: Emit word 1 in table.\n\t *\t.\n\t *\tFD: Emit word 253 in table.\n\t *\n\t *    Multi-Byte Code:\n\t *\tFE WW WW: (3 byte code) Word to emit is the next word WW WW.\n\t *\tFF BB WW WW: (4 byte code) Emit BB count times next word WW WW.\n\t */\n\tword = 0;\n\tfor (i = 253 * 2; i < adv_asc3550_mcode_size; i++) {\n\t\tif (adv_asc3550_mcode[i] == 0xff) {\n\t\t\tfor (j = 0; j < adv_asc3550_mcode[i + 1]; j++) {\n\t\t\t\tADW_WRITE_WORD_AUTO_INC_LRAM(iot, ioh,\n\t\t\t\t  (((u_int16_t)adv_asc3550_mcode[i + 3] << 8) |\n\t\t\t\t  adv_asc3550_mcode[i + 2]));\n\t\t\t\tword++;\n\t\t\t}\n\t\t\ti += 3;\n\t\t} else if (adv_asc3550_mcode[i] == 0xfe) {\n\t\t\tADW_WRITE_WORD_AUTO_INC_LRAM(iot, ioh,\n\t\t\t    (((u_int16_t)adv_asc3550_mcode[i + 2] << 8) |\n\t\t\t    adv_asc3550_mcode[i + 1]));\n\t\t\ti += 2;\n\t\t\tword++;\n\t\t} else {\n\t\t\tADW_WRITE_WORD_AUTO_INC_LRAM(iot, ioh, (((u_int16_t)\n\t\t\t adv_asc3550_mcode[(adv_asc3550_mcode[i] * 2) + 1] <<8) |\n\t\t\t adv_asc3550_mcode[adv_asc3550_mcode[i] * 2]));\n\t\t\tword++;\n\t\t}\n\t}\n\n\t/*\n\t * Set 'word' for later use to clear the rest of memory and save\n\t * the expanded mcode size.\n\t */\n\tword *= 2;\n\tadv_asc3550_expanded_size = word;\n\n\t/*\n\t * Clear the rest of ASC-3550 Internal RAM (8KB).\n\t */\n\tfor (; word < ADV_3550_MEMSIZE; word += 2) {\n\t\tADW_WRITE_WORD_AUTO_INC_LRAM(iot, ioh, 0);\n\t}\n\n\t/*\n\t * Verify the microcode checksum.\n\t */\n\tsum = 0;\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_RAM_ADDR, 0);\n\n\tfor (word = 0; word < adv_asc3550_expanded_size; word += 2) {\n\t\tsum += ADW_READ_WORD_AUTO_INC_LRAM(iot, ioh);\n\t}\n\n\tif (sum != adv_asc3550_mcode_chksum) {\n\t\treturn ASC_IERR_MCODE_CHKSUM;\n\t}\n\n\t/*\n\t * Restore the RISC memory BIOS region.\n\t */\n\tfor (i = 0; i < ASC_MC_BIOSLEN/2; i++) {\n\t\tADW_WRITE_BYTE_LRAM(iot, ioh, ASC_MC_BIOSMEM + (2 * i),\n\t\t\t\tbios_mem[i]);\n\t}\n\n\t/*\n\t * Calculate and write the microcode code checksum to the microcode\n\t * code checksum location ASC_MC_CODE_CHK_SUM (0x2C).\n\t */\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_CODE_BEGIN_ADDR, begin_addr);\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_CODE_END_ADDR, end_addr);\n\tcode_sum = 0;\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_RAM_ADDR, begin_addr);\n\tfor (word = begin_addr; word < end_addr; word += 2) {\n\t\tcode_sum += ADW_READ_WORD_AUTO_INC_LRAM(iot, ioh);\n\t}\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_CODE_CHK_SUM, code_sum);\n\n\t/*\n\t * Read and save microcode version and date.\n\t */\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_VERSION_DATE,\n\t\t\tsc->cfg.mcode_date);\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_VERSION_NUM,\n\t\t\tsc->cfg.mcode_version);\n\n\t/*\n\t * Set the chip type to indicate the ASC3550.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_CHIP_TYPE, ADV_CHIP_ASC3550);\n\n\t/*\n\t * If the PCI Configuration Command Register \"Parity Error Response\n\t * Control\" Bit was clear (0), then set the microcode variable\n\t * 'control_flag' CONTROL_FLAG_IGNORE_PERR flag to tell the microcode\n\t * to ignore DMA parity errors.\n\t */\n\tif (sc->cfg.control_flag & CONTROL_FLAG_IGNORE_PERR) {\n\t\t/*\n\t\t * Note: Don't remove the use of a temporary variable in\n\t\t * the following code, otherwise some  C compiler\n\t\t * might turn the following lines into a no-op.\n\t\t */\n\t\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_CONTROL_FLAG, word);\n\t\tword |= CONTROL_FLAG_IGNORE_PERR;\n\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_CONTROL_FLAG, word);\n\t}\n\n\t/*\n\t * For ASC-3550, setting the START_CTL_EMFU [3:2] bits sets a FIFO\n\t * threshold of 128 bytes. This register is only accessible to the host.\n\t */\n\tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_DMA_CFG0,\n\t\t\tSTART_CTL_EMFU | READ_CMD_MRM);\n\n\t/*\n\t * Microcode operating variables for WDTR, SDTR, and command tag\n\t * queuing will be set in AdvInquiryHandling() based on what a\n\t * device reports it is capable of in Inquiry byte 7.\n\t *\n\t * If SCSI Bus Resets haev been disabled, then directly set\n\t * SDTR and WDTR from the EEPROM configuration. This will allow\n\t * the BIOS and warm boot to work without a SCSI bus hang on\n\t * the Inquiry caused by host and target mismatched DTR values.\n\t * Without the SCSI Bus Reset, before an Inquiry a device can't\n\t * be assumed to be in Asynchronous, Narrow mode.\n\t */\n\tif ((sc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS) == 0) {\n\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_WDTR_ABLE,\n\t\t\t\tsc->wdtr_able);\n\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_ABLE,\n\t\t\t\tsc->sdtr_able);\n\t}\n\n\t/*\n\t * Set microcode operating variables for SDTR_SPEED1, SDTR_SPEED2,\n\t * SDTR_SPEED3, and SDTR_SPEED4 based on the ULTRA EEPROM per TID\n\t * bitmask. These values determine the maximum SDTR speed negotiated\n\t * with a device.\n\t *\n\t * The SDTR per TID bitmask overrides the SDTR_SPEED1, SDTR_SPEED2,\n\t * SDTR_SPEED3, and SDTR_SPEED4 values so it is safe to set them\n\t * without determining here whether the device supports SDTR.\n\t *\n\t * 4-bit speed  SDTR speed name\n\t * ===========  ===============\n\t * 0000b (0x0)  SDTR disabled\n\t * 0001b (0x1)  5 Mhz\n\t * 0010b (0x2)  10 Mhz\n\t * 0011b (0x3)  20 Mhz (Ultra)\n\t * 0100b (0x4)  40 Mhz (LVD/Ultra2)\n\t * 0101b (0x5)  80 Mhz (LVD2/Ultra3)\n\t * 0110b (0x6)  Undefined\n\t * .\n\t * 1111b (0xF)  Undefined\n\t */\n\tword = 0;\n\tfor (tid = 0; tid <= ADW_MAX_TID; tid++) {\n\t\tif (ADW_TID_TO_TIDMASK(tid) & sc->ultra_able) {\n\t\t\t/* Set Ultra speed for TID 'tid'. */\n\t\t\tword |= (0x3 << (4 * (tid % 4)));\n\t\t} else {\n\t\t\t/* Set Fast speed for TID 'tid'. */\n\t\t\tword |= (0x2 << (4 * (tid % 4)));\n\t\t}\n\t\t/* Check if done with sdtr_speed1. */\n\t\tif (tid == 3) {\n\t\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_SPEED1, word);\n\t\t\tword = 0;\n\t\t/* Check if done with sdtr_speed2. */\n\t\t} else if (tid == 7) {\n\t\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_SPEED2, word);\n\t\t\tword = 0;\n\t\t/* Check if done with sdtr_speed3. */\n\t\t} else if (tid == 11) {\n\t\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_SPEED3, word);\n\t\t\tword = 0;\n\t\t/* Check if done with sdtr_speed4. */\n\t\t} else if (tid == 15) {\n\t\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_SPEED4, word);\n\t\t\t/* End of loop. */\n\t\t}\n\t}\n\n\t/*\n\t * Set microcode operating variable for the disconnect per TID bitmask.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DISC_ENABLE, sc->cfg.disc_enable);\n\n\n\t/*\n\t * Set SCSI_CFG0 Microcode Default Value.\n\t *\n\t * The microcode will set the SCSI_CFG0 register using this value\n\t * after it is started below.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DEFAULT_SCSI_CFG0,\n\t\tADW_PARITY_EN | ADW_SEL_TMO_LONG | ADW_OUR_ID_EN |\n\t\t\tsc->chip_scsi_id);\n\n\t/*\n\t * Determine SCSI_CFG1 Microcode Default Value.\n\t *\n\t * The microcode will set the SCSI_CFG1 register using this value\n\t * after it is started below.\n\t */\n\n\t/* Read current SCSI_CFG1 Register value. */\n\tscsi_cfg1 = ADW_READ_WORD_REGISTER(iot, ioh, IOPW_SCSI_CFG1);\n\n\t/*\n\t * If all three connectors are in use, return an error.\n\t */\n\tif ((scsi_cfg1 & CABLE_ILLEGAL_A) == 0 ||\n\t\t(scsi_cfg1 & CABLE_ILLEGAL_B) == 0) {\n\t\treturn ASC_IERR_ILLEGAL_CONNECTION;\n\t}\n\n\t/*\n\t * If the internal narrow cable is reversed all of the SCSI_CTRL\n\t * register signals will be set. Check for and return an error if\n\t * this condition is found.\n\t */\n\tif ((ADW_READ_WORD_REGISTER(iot, ioh, IOPW_SCSI_CTRL) & 0x3F07) ==\n\t\t\t0x3F07) {\n\t\treturn ASC_IERR_REVERSED_CABLE;\n\t}\n\n\t/*\n\t * If this is a differential board and a single-ended device\n\t * is attached to one of the connectors, return an error.\n\t */\n\tif ((scsi_cfg1 & ADW_DIFF_MODE) && (scsi_cfg1 & ADW_DIFF_SENSE) == 0) {\n\t\treturn ASC_IERR_SINGLE_END_DEVICE;\n\t}\n\n\t/*\n\t * If automatic termination control is enabled, then set the\n\t * termination value based on a table listed in a_condor.h.\n\t *\n\t * If manual termination was specified with an EEPROM setting\n\t * then 'termination' was set-up in AdvInitFrom3550EEPROM() and\n\t * is ready to be 'ored' into SCSI_CFG1.\n\t */\n\tif (sc->cfg.termination == 0) {\n\t\t/*\n\t\t * The software always controls termination by setting TERM_CTL_SEL.\n\t\t * If TERM_CTL_SEL were set to 0, the hardware would set termination.\n\t\t */\n\t\tsc->cfg.termination |= ADW_TERM_CTL_SEL;\n\n\t\tswitch(scsi_cfg1 & ADW_CABLE_DETECT) {\n\t\t\t/* TERM_CTL_H: on, TERM_CTL_L: on */\n\t\t\tcase 0x3: case 0x7: case 0xB: case 0xD: case 0xE: case 0xF:\n\t\t\t\tsc->cfg.termination |= (ADW_TERM_CTL_H | ADW_TERM_CTL_L);\n\t\t\t\tbreak;\n\n\t\t\t/* TERM_CTL_H: on, TERM_CTL_L: off */\n\t\t\tcase 0x1: case 0x5: case 0x9: case 0xA: case 0xC:\n\t\t\t\tsc->cfg.termination |= ADW_TERM_CTL_H;\n\t\t\t\tbreak;\n\n\t\t\t/* TERM_CTL_H: off, TERM_CTL_L: off */\n\t\t\tcase 0x2: case 0x6:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * Clear any set TERM_CTL_H and TERM_CTL_L bits.\n\t */\n\tscsi_cfg1 &= ~ADW_TERM_CTL;\n\n\t/*\n\t * Invert the TERM_CTL_H and TERM_CTL_L bits and then\n\t * set 'scsi_cfg1'. The TERM_POL bit does not need to be\n\t * referenced, because the hardware internally inverts\n\t * the Termination High and Low bits if TERM_POL is set.\n\t */\n\tscsi_cfg1 |= (ADW_TERM_CTL_SEL | (~sc->cfg.termination & ADW_TERM_CTL));\n\n\t/*\n\t * Set SCSI_CFG1 Microcode Default Value\n\t *\n\t * Set filter value and possibly modified termination control\n\t * bits in the Microcode SCSI_CFG1 Register Value.\n\t *\n\t * The microcode will set the SCSI_CFG1 register using this value\n\t * after it is started below.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DEFAULT_SCSI_CFG1,\n\t\tADW_FLTR_DISABLE | scsi_cfg1);\n\n\t/*\n\t * Set MEM_CFG Microcode Default Value\n\t *\n\t * The microcode will set the MEM_CFG register using this value\n\t * after it is started below.\n\t *\n\t * MEM_CFG may be accessed as a word or byte, but only bits 0-7\n\t * are defined.\n\t *\n\t * ASC-3550 has 8KB internal memory.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DEFAULT_MEM_CFG,\n\t\tADW_BIOS_EN | ADW_RAM_SZ_8KB);\n\n\t/*\n\t * Set SEL_MASK Microcode Default Value\n\t *\n\t * The microcode will set the SEL_MASK register using this value\n\t * after it is started below.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DEFAULT_SEL_MASK,\n\t\tADW_TID_TO_TIDMASK(sc->chip_scsi_id));\n\n\n\t/*\n\t * Set-up the Host->RISC Initiator Command Queue (ICQ) if\n\t * one is not already set up, i.e. this is the first\n\t * time through as opposed to a bus reset.\n\t */\n\n\tif (sc->icq_sp == NULL) {\n\t\tsc->carr_pending_cnt = 0;\n\t\tif ((sc->icq_sp = sc->carr_freelist) == NULL) {\n\t\t\treturn ASC_IERR_NO_CARRIER;\n\t\t}\n\t\tsc->carr_freelist = adw_carrier_phys_kv(sc,\n\t\t\t\tASC_GET_CARRP(sc->icq_sp->next_vpa));\n\n\t\t/*\n\t \t * The first command issued will be placed in the stopper carrier.\n\t\t */\n\t\tsc->icq_sp->next_vpa = ASC_CQ_STOPPER;\n\t}\n\n\t/*\n\t * Set RISC ICQ physical address start value.\n\t */\n\tADW_WRITE_DWORD_LRAM(iot, ioh, ASC_MC_ICQ, sc->icq_sp->carr_pa);\n\n\t/*\n\t * Set-up the RISC->Host Initiator Response Queue (IRQ) if\n\t * one is not already set up, i.e. this is the first\n\t * time through as opposed to a bus reset.\n\t */\n\tif (sc->irq_sp == NULL) {\n\t\tif ((sc->irq_sp = sc->carr_freelist) == NULL) {\n\t\t\treturn ASC_IERR_NO_CARRIER;\n\t\t}\n\t\tsc->carr_freelist = adw_carrier_phys_kv(sc,\n\t\t\t\tASC_GET_CARRP(sc->irq_sp->next_vpa));\n\n\t\t/*\n \t \t * The first command completed by the RISC will be placed in\n \t \t * the stopper.\n \t \t *\n \t \t * Note: Set 'next_vpa' to ASC_CQ_STOPPER. When the request is\n \t \t * completed the RISC will set the ASC_RQ_DONE bit.\n \t \t */\n\t\tsc->irq_sp->next_vpa = ASC_CQ_STOPPER;\n\t}\n\n\t/*\n \t * Set RISC IRQ physical address start value.\n \t */\n\tADW_WRITE_DWORD_LRAM(iot, ioh, ASC_MC_IRQ, sc->irq_sp->carr_pa);\n\n\tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_INTR_ENABLES,\n\t\t(ADW_INTR_ENABLE_HOST_INTR | ADW_INTR_ENABLE_GLOBAL_INTR));\n\n\t/*\n\t * Note: Don't remove the use of a temporary variable in\n\t * the following code, otherwise some C compiler\n\t * might turn the following lines into a no-op.\n\t */\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_CODE_BEGIN_ADDR, word);\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_PC, word);\n\n\t/* finally, finally, gentlemen, start your engine */\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_RISC_CSR, ADW_RISC_CSR_RUN);\n\n\t/*\n\t * Reset the SCSI Bus if the EEPROM indicates that SCSI Bus\n\t * Resets should be performed. The RISC has to be running\n\t * to issue a SCSI Bus Reset.\n\t */\n\tif (sc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS)\n\t{\n\t\t/*\n\t\t * If the BIOS Signature is present in memory, restore the\n\t\t * BIOS Handshake Configuration Table and do not perform\n\t\t * a SCSI Bus Reset.\n\t\t */\n\t\tif (bios_mem[(ASC_MC_BIOS_SIGNATURE - ASC_MC_BIOSMEM)/2] ==\n\t\t\t\t0x55AA) {\n\t\t\t/*\n\t\t\t * Restore per TID negotiated values.\n\t\t\t */\n\t\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_WDTR_ABLE,\n\t\t\t\t\twdtr_able);\n\t\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_ABLE,\n\t\t\t\t\tsdtr_able);\n\t\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_TAGQNG_ABLE,\n\t\t\t\t\ttagqng_able);\n\t\t\tfor (tid = 0; tid <= ADW_MAX_TID; tid++) {\n\t\t\t\tADW_WRITE_BYTE_LRAM(iot, ioh,\n\t\t\t\t\tASC_MC_NUMBER_OF_MAX_CMD + tid,\n\t\t\t\t\tmax_cmd[tid]);\n\t\t\t}\n\t\t} else {\n\t\t\tif (AdvResetCCB(sc) != ADW_TRUE) {\n\t\t\t\twarn_code = ASC_WARN_BUSRESET_ERROR;\n\t\t\t}\n\t\t}\n\t}\n\n    return warn_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AdvInitAsc38C0800Driver",
          "args": [
            "sc"
          ],
          "line": 2125
        },
        "resolved": true,
        "details": {
          "function_name": "AdvInitAsc38C0800Driver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adwlib.c",
          "lines": "723-1250",
          "snippet": "int\nAdvInitAsc38C0800Driver(sc)\nADW_SOFTC      *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tu_int16_t\twarn_code;\n\tu_int32_t\tsum;\n\tint\t  \tbegin_addr;\n\tint\t   \tend_addr;\n\tu_int16_t\tcode_sum;\n\tint\t   \tword;\n\tint\t   \ti, j;\n\tint\t   \tadv_asc38C0800_expanded_size;\n\tu_int16_t\tscsi_cfg1;\n\tu_int8_t\tbyte;\n\tu_int8_t\ttid;\n\tu_int16_t\tbios_mem[ASC_MC_BIOSLEN/2];\t/* BIOS RISC Memory\n\t\t\t\t\t\t\t\t0x40-0x8F. */\n\tu_int16_t\twdtr_able, sdtr_able, tagqng_able;\n\tu_int8_t\tmax_cmd[ADW_MAX_TID + 1];\n\n\n\twarn_code = 0;\n\n\t/*\n\t * Save the RISC memory BIOS region before writing the microcode.\n\t * The BIOS may already be loaded and using its RISC LRAM region\n\t * so its region must be saved and restored.\n\t *\n\t * Note: This code makes the assumption, which is currently true,\n\t * that a chip reset does not clear RISC LRAM.\n\t */\n\tfor (i = 0; i < ASC_MC_BIOSLEN/2; i++) {\n\t    ADW_READ_WORD_LRAM(iot, ioh, ASC_MC_BIOSMEM + (2 * i), bios_mem[i]);\n\t}\n\n\t/*\n\t * Save current per TID negotiated values.\n\t */\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_WDTR_ABLE, wdtr_able);\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_SDTR_ABLE, sdtr_able);\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_TAGQNG_ABLE, tagqng_able);\n\tfor (tid = 0; tid <= ADW_MAX_TID; tid++) {\n\t\tADW_READ_BYTE_LRAM(iot, ioh, ASC_MC_NUMBER_OF_MAX_CMD + tid,\n\t\t\tmax_cmd[tid]);\n\t}\n\n\t/*\n\t * RAM BIST (RAM Built-In Self Test)\n\t *\n\t * Address : I/O base + offset 0x38h register (byte).\n\t * Function: Bit 7-6(RW) : RAM mode\n\t *\t\t\t    Normal Mode   : 0x00\n\t *\t\t\t    Pre-test Mode : 0x40\n\t *\t\t\t    RAM Test Mode : 0x80\n\t *\t     Bit 5\t : unused\n\t *\t     Bit 4(RO)   : Done bit\n\t *\t     Bit 3-0(RO) : Status\n\t *\t\t\t    Host Error    : 0x08\n\t *\t\t\t    Int_RAM Error : 0x04\n\t *\t\t\t    RISC Error    : 0x02\n\t *\t\t\t    SCSI Error    : 0x01\n\t *\t\t\t    No Error\t  : 0x00\n\t *\n\t * Note: RAM BIST code should be put right here, before loading the\n\t * microcode and after saving the RISC memory BIOS region.\n\t */\n\n\t/*\n\t * LRAM Pre-test\n\t *\n\t * Write PRE_TEST_MODE (0x40) to register and wait for 10 milliseconds.\n\t * If Done bit not set or low nibble not PRE_TEST_VALUE (0x05), return\n\t * an error. Reset to NORMAL_MODE (0x00) and do again. If cannot reset\n\t * to NORMAL_MODE, return an error too.\n\t */\n\tfor (i = 0; i < 2; i++) {\n\t\tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_RAM_BIST, PRE_TEST_MODE);\n\t\tAdvSleepMilliSecond(10);  /* Wait for 10ms before reading back. */\n\t\tbyte = ADW_READ_BYTE_REGISTER(iot, ioh, IOPB_RAM_BIST);\n\t\tif ((byte & RAM_TEST_DONE) == 0 || (byte & 0x0F) !=\n\t\t\t\tPRE_TEST_VALUE) {\n\t\t\treturn ASC_IERR_BIST_PRE_TEST;\n\t\t}\n\n\t\tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_RAM_BIST, NORMAL_MODE);\n\t\tAdvSleepMilliSecond(10);  /* Wait for 10ms before reading back. */\n\t\tif (ADW_READ_BYTE_REGISTER(iot, ioh, IOPB_RAM_BIST)\n\t\t    != NORMAL_VALUE) {\n\t\t\treturn ASC_IERR_BIST_PRE_TEST;\n\t\t}\n\t}\n\n\t/*\n\t * LRAM Test - It takes about 1.5 ms to run through the test.\n\t *\n\t * Write RAM_TEST_MODE (0x80) to register and wait for 10 milliseconds.\n\t * If Done bit not set or Status not 0, save register byte, set the\n\t * err_code, and return an error.\n\t */\n\tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_RAM_BIST, RAM_TEST_MODE);\n\tAdvSleepMilliSecond(10);  /* Wait for 10ms before checking status. */\n\n\tbyte = ADW_READ_BYTE_REGISTER(iot, ioh, IOPB_RAM_BIST);\n\tif ((byte & RAM_TEST_DONE) == 0 || (byte & RAM_TEST_STATUS) != 0) {\n\t\t/* Get here if Done bit not set or Status not 0. */\n\t\treturn ASC_IERR_BIST_RAM_TEST;\n\t}\n\n\t/* We need to reset back to normal mode after LRAM test passes. */\n\tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_RAM_BIST, NORMAL_MODE);\n\n\t/*\n\t * Load the Microcode\n\t *\n\t * Write the microcode image to RISC memory starting at address 0.\n\t *\n\t */\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_RAM_ADDR, 0);\n\n\t/* Assume the following compressed format of the microcode buffer:\n\t *\n\t *  254 word (508 byte) table indexed by byte code followed\n\t *  by the following byte codes:\n\t *\n\t *    1-Byte Code:\n\t *\t00: Emit word 0 in table.\n\t *\t01: Emit word 1 in table.\n\t *\t.\n\t *\tFD: Emit word 253 in table.\n\t *\n\t *    Multi-Byte Code:\n\t *\tFE WW WW: (3 byte code) Word to emit is the next word WW WW.\n\t *\tFF BB WW WW: (4 byte code) Emit BB count times next word WW WW.\n\t */\n\tword = 0;\n\tfor (i = 253 * 2; i < adv_asc38C0800_mcode_size; i++) {\n\t\tif (adv_asc38C0800_mcode[i] == 0xff) {\n\t\t\tfor (j = 0; j < adv_asc38C0800_mcode[i + 1]; j++) {\n\t\t\t\tADW_WRITE_WORD_AUTO_INC_LRAM(iot, ioh,\n\t\t\t\t    (((u_int16_t)\n\t\t\t\t    adv_asc38C0800_mcode[i + 3] << 8) |\n\t\t\t\t    adv_asc38C0800_mcode[i + 2]));\n\t\t\t\tword++;\n\t\t\t}\n\t\t\ti += 3;\n\t\t} else if (adv_asc38C0800_mcode[i] == 0xfe) {\n\t\t\tADW_WRITE_WORD_AUTO_INC_LRAM(iot, ioh, (((u_int16_t)\n\t\t\t    adv_asc38C0800_mcode[i + 2] << 8) |\n\t\t\t    adv_asc38C0800_mcode[i + 1]));\n\t\t\ti += 2;\n\t\t\tword++;\n\t\t} else {\n\t\t\tADW_WRITE_WORD_AUTO_INC_LRAM(iot, ioh, (((u_int16_t)\n\t\t\t  adv_asc38C0800_mcode[(adv_asc38C0800_mcode[i] * 2) + 1] << 8) |\n\t\t\t  adv_asc38C0800_mcode[adv_asc38C0800_mcode[i] * 2]));\n\t\t\tword++;\n\t\t}\n\t}\n\n\t/*\n\t * Set 'word' for later use to clear the rest of memory and save\n\t * the expanded mcode size.\n\t */\n\tword *= 2;\n\tadv_asc38C0800_expanded_size = word;\n\n\t/*\n\t * Clear the rest of ASC-38C0800 Internal RAM (16KB).\n\t */\n\tfor (; word < ADV_38C0800_MEMSIZE; word += 2) {\n\t\tADW_WRITE_WORD_AUTO_INC_LRAM(iot, ioh, 0);\n\t}\n\n\t/*\n\t * Verify the microcode checksum.\n\t */\n\tsum = 0;\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_RAM_ADDR, 0);\n\n\tfor (word = 0; word < adv_asc38C0800_expanded_size; word += 2) {\n\t\tsum += ADW_READ_WORD_AUTO_INC_LRAM(iot, ioh);\n\t}\n\n\tif (sum != adv_asc38C0800_mcode_chksum) {\n\t    return ASC_IERR_MCODE_CHKSUM;\n\t}\n\n\t/*\n\t * Restore the RISC memory BIOS region.\n\t */\n\tfor (i = 0; i < ASC_MC_BIOSLEN/2; i++) {\n\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_BIOSMEM + (2 * i),\n\t\t\t\tbios_mem[i]);\n\t}\n\n\t/*\n\t * Calculate and write the microcode code checksum to the microcode\n\t * code checksum location ASC_MC_CODE_CHK_SUM (0x2C).\n\t */\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_CODE_BEGIN_ADDR, begin_addr);\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_CODE_END_ADDR, end_addr);\n\tcode_sum = 0;\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_RAM_ADDR, begin_addr);\n\tfor (word = begin_addr; word < end_addr; word += 2) {\n\t\tcode_sum += ADW_READ_WORD_AUTO_INC_LRAM(iot, ioh);\n\t}\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_CODE_CHK_SUM, code_sum);\n\n\t/*\n\t * Read microcode version and date.\n\t */\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_VERSION_DATE,\n\t\t\tsc->cfg.mcode_date);\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_VERSION_NUM,\n\t\t\tsc->cfg.mcode_version);\n\n\t/*\n\t * Set the chip type to indicate the ASC38C0800.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_CHIP_TYPE, ADV_CHIP_ASC38C0800);\n\n\t/*\n\t * Write 1 to bit 14 'DIS_TERM_DRV' in the SCSI_CFG1 register.\n\t * When DIS_TERM_DRV set to 1, C_DET[3:0] will reflect current\n\t * cable detection and then we are able to read C_DET[3:0].\n\t *\n\t * Note: We will reset DIS_TERM_DRV to 0 in the 'Set SCSI_CFG1\n\t * Microcode Default Value' section below.\n\t */\n\tscsi_cfg1 = ADW_READ_WORD_REGISTER(iot, ioh, IOPW_SCSI_CFG1);\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_SCSI_CFG1,\n\t\t\tscsi_cfg1 | ADW_DIS_TERM_DRV);\n\n\t/*\n\t * If the PCI Configuration Command Register \"Parity Error Response\n\t * Control\" Bit was clear (0), then set the microcode variable\n\t * 'control_flag' CONTROL_FLAG_IGNORE_PERR flag to tell the microcode\n\t * to ignore DMA parity errors.\n\t */\n\tif (sc->cfg.control_flag & CONTROL_FLAG_IGNORE_PERR) {\n\t\t/*\n\t\t * Note: Don't remove the use of a temporary variable in\n\t\t * the following code, otherwise some C compiler\n\t\t * might turn the following lines into a no-op.\n\t\t */\n\t\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_CONTROL_FLAG, word);\n\t\tword |= CONTROL_FLAG_IGNORE_PERR;\n\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_CONTROL_FLAG, word);\n\t}\n\n\t/*\n\t * For ASC-38C0800, set FIFO_THRESH_80B [6:4] bits and START_CTL_TH [3:2]\n\t * bits for the default FIFO threshold.\n\t *\n\t * Note: ASC-38C0800 FIFO threshold has been changed to 256 bytes.\n\t *\n\t * For DMA Errata #4 set the BC_THRESH_ENB bit.\n\t */\n\tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_DMA_CFG0,\n\t\tBC_THRESH_ENB | FIFO_THRESH_80B | START_CTL_TH | READ_CMD_MRM);\n\n\t/*\n\t * Microcode operating variables for WDTR, SDTR, and command tag\n\t * queuing will be set in AdvInquiryHandling() based on what a\n\t * device reports it is capable of in Inquiry byte 7.\n\t *\n\t * If SCSI Bus Resets have been disabled, then directly set\n\t * SDTR and WDTR from the EEPROM configuration. This will allow\n\t * the BIOS and warm boot to work without a SCSI bus hang on\n\t * the Inquiry caused by host and target mismatched DTR values.\n\t * Without the SCSI Bus Reset, before an Inquiry a device can't\n\t * be assumed to be in Asynchronous, Narrow mode.\n\t */\n\tif ((sc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS) == 0) {\n\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_WDTR_ABLE, sc->wdtr_able);\n\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_ABLE, sc->sdtr_able);\n\t}\n\n\t/*\n\t * Set microcode operating variables for DISC and SDTR_SPEED1,\n\t * SDTR_SPEED2, SDTR_SPEED3, and SDTR_SPEED4 based on the EEPROM\n\t * configuration values.\n\t *\n\t * The SDTR per TID bitmask overrides the SDTR_SPEED1, SDTR_SPEED2,\n\t * SDTR_SPEED3, and SDTR_SPEED4 values so it is safe to set them\n\t * without determining here whether the device supports SDTR.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DISC_ENABLE, sc->cfg.disc_enable);\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_SPEED1, sc->sdtr_speed1);\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_SPEED2, sc->sdtr_speed2);\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_SPEED3, sc->sdtr_speed3);\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_SPEED4, sc->sdtr_speed4);\n\n\t/*\n\t * Set SCSI_CFG0 Microcode Default Value.\n\t *\n\t * The microcode will set the SCSI_CFG0 register using this value\n\t * after it is started below.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DEFAULT_SCSI_CFG0,\n\t\tADW_PARITY_EN | ADW_SEL_TMO_LONG | ADW_OUR_ID_EN |\n\t\t\tsc->chip_scsi_id);\n\n\t/*\n\t * Determine SCSI_CFG1 Microcode Default Value.\n\t *\n\t * The microcode will set the SCSI_CFG1 register using this value\n\t * after it is started below.\n\t */\n\n\t/* Read current SCSI_CFG1 Register value. */\n\tscsi_cfg1 = ADW_READ_WORD_REGISTER(iot, ioh, IOPW_SCSI_CFG1);\n\n\t/*\n\t * If the internal narrow cable is reversed all of the SCSI_CTRL\n\t * register signals will be set. Check for and return an error if\n\t * this condition is found.\n\t */\n\tif ((ADW_READ_WORD_REGISTER(iot, ioh, IOPW_SCSI_CTRL) & 0x3F07) ==\n\t\t\t0x3F07) {\n\t\treturn ASC_IERR_REVERSED_CABLE;\n\t}\n\n\t/*\n\t * All kind of combinations of devices attached to one of four connectors\n\t * are acceptable except HVD device attached. For example, LVD device can\n\t * be attached to SE connector while SE device attached to LVD connector.\n\t * If LVD device attached to SE connector, it only runs up to Ultra speed.\n\t *\n\t * If an HVD device is attached to one of LVD connectors, return an error.\n\t * However, there is no way to detect HVD device attached to SE connectors.\n\t */\n\tif (scsi_cfg1 & ADW_HVD) {\n\t\treturn ASC_IERR_HVD_DEVICE;\n\t}\n\n\t/*\n\t * If either SE or LVD automatic termination control is enabled, then\n\t * set the termination value based on a table listed in a_condor.h.\n\t *\n\t * If manual termination was specified with an EEPROM setting then\n\t * 'termination' was set-up in AdvInitFrom38C0800EEPROM() and is ready to\n\t * be 'ored' into SCSI_CFG1.\n\t */\n\tif ((sc->cfg.termination & ADW_TERM_SE) == 0) {\n\t\t/* SE automatic termination control is enabled. */\n\t\tswitch(scsi_cfg1 & ADW_C_DET_SE) {\n\t\t\t/* TERM_SE_HI: on, TERM_SE_LO: on */\n\t\t\tcase 0x1: case 0x2: case 0x3:\n\t\t\t\tsc->cfg.termination |= ADW_TERM_SE;\n\t\t\t\tbreak;\n\n\t\t\t/* TERM_SE_HI: on, TERM_SE_LO: off */\n\t\t\tcase 0x0:\n\t\t\t\tsc->cfg.termination |= ADW_TERM_SE_HI;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ((sc->cfg.termination & ADW_TERM_LVD) == 0) {\n\t\t/* LVD automatic termination control is enabled. */\n\t\tswitch(scsi_cfg1 & ADW_C_DET_LVD) {\n\t\t\t/* TERM_LVD_HI: on, TERM_LVD_LO: on */\n\t\t\tcase 0x4: case 0x8: case 0xC:\n\t\t\t\tsc->cfg.termination |= ADW_TERM_LVD;\n\t\t\t\tbreak;\n\n\t\t\t/* TERM_LVD_HI: off, TERM_LVD_LO: off */\n\t\t\tcase 0x0:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * Clear any set TERM_SE and TERM_LVD bits.\n\t */\n\tscsi_cfg1 &= (~ADW_TERM_SE & ~ADW_TERM_LVD);\n\n\t/*\n\t * Invert the TERM_SE and TERM_LVD bits and then set 'scsi_cfg1'.\n\t */\n\tscsi_cfg1 |= (~sc->cfg.termination & 0xF0);\n\n\t/*\n\t * Clear BIG_ENDIAN, DIS_TERM_DRV, Terminator Polarity and HVD/LVD/SE bits\n\t * and set possibly modified termination control bits in the Microcode\n\t * SCSI_CFG1 Register Value.\n\t */\n\tscsi_cfg1 &= (~ADW_BIG_ENDIAN & ~ADW_DIS_TERM_DRV &\n\t\t\t~ADW_TERM_POL & ~ADW_HVD_LVD_SE);\n\n\t/*\n\t * Set SCSI_CFG1 Microcode Default Value\n\t *\n\t * Set possibly modified termination control and reset DIS_TERM_DRV\n\t * bits in the Microcode SCSI_CFG1 Register Value.\n\t *\n\t * The microcode will set the SCSI_CFG1 register using this value\n\t * after it is started below.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DEFAULT_SCSI_CFG1, scsi_cfg1);\n\n\t/*\n\t * Set MEM_CFG Microcode Default Value\n\t *\n\t * The microcode will set the MEM_CFG register using this value\n\t * after it is started below.\n\t *\n\t * MEM_CFG may be accessed as a word or byte, but only bits 0-7\n\t * are defined.\n\t *\n\t * ASC-38C0800 has 16KB internal memory.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DEFAULT_MEM_CFG,\n\t\tADW_BIOS_EN | ADW_RAM_SZ_16KB);\n\n\t/*\n\t * Set SEL_MASK Microcode Default Value\n\t *\n\t * The microcode will set the SEL_MASK register using this value\n\t * after it is started below.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DEFAULT_SEL_MASK,\n\t\tADW_TID_TO_TIDMASK(sc->chip_scsi_id));\n\n\n\t/*\n\t * Set-up the Host->RISC Initiator Command Queue (ICQ) if\n\t * one is not already set up, i.e. this is the first\n\t * time through as opposed to a bus reset.\n\t */\n\n\tif (sc->icq_sp == NULL) {\n\t\tsc->carr_pending_cnt = 0;\n\t\tif ((sc->icq_sp = sc->carr_freelist) == NULL) {\n\t\t\treturn ASC_IERR_NO_CARRIER;\n\t\t}\n\t\tsc->carr_freelist = adw_carrier_phys_kv(sc,\n\t\t\t\tASC_GET_CARRP(sc->icq_sp->next_vpa));\n\n\n\t\t/*\n\t \t * The first command issued will be placed in the stopper carrier.\n\t \t */\n\t\tsc->icq_sp->next_vpa = ASC_CQ_STOPPER;\n\t}\n\n\t/*\n\t * Set RISC ICQ physical address start value.\n\t */\n\tADW_WRITE_DWORD_LRAM(iot, ioh, ASC_MC_ICQ, sc->icq_sp->carr_pa);\n\n\t/*\n\t * Set-up the RISC->Host Initiator Response Queue (IRQ) if\n\t * one is not already set up, i.e. this is the first\n\t * time through as opposed to a bus reset.\n\t */\n\tif (sc->irq_sp == NULL) {\n\t\tif ((sc->irq_sp = sc->carr_freelist) == NULL) {\n\t\t\treturn ASC_IERR_NO_CARRIER;\n\t\t}\n\t\tsc->carr_freelist = adw_carrier_phys_kv(sc,\n\t\t\t\tASC_GET_CARRP(sc->irq_sp->next_vpa));\n\n\t\t/*\n\t \t * The first command completed by the RISC will be placed in\n\t \t * the stopper.\n\t \t *\n\t \t * Note: Set 'next_vpa' to ASC_CQ_STOPPER. When the request is\n\t \t * completed the RISC will set the ASC_RQ_DONE bit.\n\t \t */\n\t\tsc->irq_sp->next_vpa = ASC_CQ_STOPPER;\n\t}\n\n\t/*\n\t * Set RISC IRQ physical address start value.\n\t */\n\tADW_WRITE_DWORD_LRAM(iot, ioh, ASC_MC_IRQ, sc->irq_sp->carr_pa);\n\n\tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_INTR_ENABLES,\n\t\t(ADW_INTR_ENABLE_HOST_INTR | ADW_INTR_ENABLE_GLOBAL_INTR));\n\t/*\n\t * Note: Don't remove the use of a temporary variable in\n\t * the following code, otherwise some C compiler\n\t * might turn the following lines into a no-op.\n\t */\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_CODE_BEGIN_ADDR, word);\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_PC, word);\n\n\t/* finally, finally, gentlemen, start your engine */\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_RISC_CSR, ADW_RISC_CSR_RUN);\n\n\t/*\n\t * Reset the SCSI Bus if the EEPROM indicates that SCSI Bus\n\t * Resets should be performed. The RISC has to be running\n\t * to issue a SCSI Bus Reset.\n\t */\n\tif (sc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS) {\n\t\t/*\n\t\t * If the BIOS Signature is present in memory, restore the\n\t\t * BIOS Handshake Configuration Table and do not perform\n\t\t * a SCSI Bus Reset.\n\t\t */\n\t\tif (bios_mem[(ASC_MC_BIOS_SIGNATURE - ASC_MC_BIOSMEM)/2] ==\n\t\t\t\t0x55AA) {\n\t\t\t/*\n\t\t\t * Restore per TID negotiated values.\n\t\t\t */\n\t\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_WDTR_ABLE, wdtr_able);\n\t\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_ABLE, sdtr_able);\n\t\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_TAGQNG_ABLE,\n\t\t\t\t\ttagqng_able);\n\t\t\tfor (tid = 0; tid <= ADW_MAX_TID; tid++) {\n\t\t\t\tADW_WRITE_BYTE_LRAM(iot, ioh,\n\t\t\t\t\t\tASC_MC_NUMBER_OF_MAX_CMD + tid,\n\t\t\t\t\t\tmax_cmd[tid]);\n\t\t\t}\n\t\t} else {\n\t\t\tif (AdvResetCCB(sc) != ADW_TRUE) {\n\t\t\t\twarn_code = ASC_WARN_BUSRESET_ERROR;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn warn_code;\n}",
          "includes": [
            "#include <dev/ic/adwmcode.h>",
            "#include <dev/ic/adw.h>",
            "#include <dev/ic/adwlib.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/queue.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void AdvInquiryHandling",
            "static void AdvSleepMilliSecond",
            "ADW_SOFTC\t*sc;",
            "bus_space_tag_t iot = sc->sc_iot;",
            "bus_space_handle_t ioh = sc->sc_ioh;",
            "u_int8_t\t\ttid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/adwmcode.h>\n#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void AdvInquiryHandling;\nstatic void AdvSleepMilliSecond;\nADW_SOFTC\t*sc;\nbus_space_tag_t iot = sc->sc_iot;\nbus_space_handle_t ioh = sc->sc_ioh;\nu_int8_t\t\ttid;\n\nint\nAdvInitAsc38C0800Driver(sc)\nADW_SOFTC      *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tu_int16_t\twarn_code;\n\tu_int32_t\tsum;\n\tint\t  \tbegin_addr;\n\tint\t   \tend_addr;\n\tu_int16_t\tcode_sum;\n\tint\t   \tword;\n\tint\t   \ti, j;\n\tint\t   \tadv_asc38C0800_expanded_size;\n\tu_int16_t\tscsi_cfg1;\n\tu_int8_t\tbyte;\n\tu_int8_t\ttid;\n\tu_int16_t\tbios_mem[ASC_MC_BIOSLEN/2];\t/* BIOS RISC Memory\n\t\t\t\t\t\t\t\t0x40-0x8F. */\n\tu_int16_t\twdtr_able, sdtr_able, tagqng_able;\n\tu_int8_t\tmax_cmd[ADW_MAX_TID + 1];\n\n\n\twarn_code = 0;\n\n\t/*\n\t * Save the RISC memory BIOS region before writing the microcode.\n\t * The BIOS may already be loaded and using its RISC LRAM region\n\t * so its region must be saved and restored.\n\t *\n\t * Note: This code makes the assumption, which is currently true,\n\t * that a chip reset does not clear RISC LRAM.\n\t */\n\tfor (i = 0; i < ASC_MC_BIOSLEN/2; i++) {\n\t    ADW_READ_WORD_LRAM(iot, ioh, ASC_MC_BIOSMEM + (2 * i), bios_mem[i]);\n\t}\n\n\t/*\n\t * Save current per TID negotiated values.\n\t */\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_WDTR_ABLE, wdtr_able);\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_SDTR_ABLE, sdtr_able);\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_TAGQNG_ABLE, tagqng_able);\n\tfor (tid = 0; tid <= ADW_MAX_TID; tid++) {\n\t\tADW_READ_BYTE_LRAM(iot, ioh, ASC_MC_NUMBER_OF_MAX_CMD + tid,\n\t\t\tmax_cmd[tid]);\n\t}\n\n\t/*\n\t * RAM BIST (RAM Built-In Self Test)\n\t *\n\t * Address : I/O base + offset 0x38h register (byte).\n\t * Function: Bit 7-6(RW) : RAM mode\n\t *\t\t\t    Normal Mode   : 0x00\n\t *\t\t\t    Pre-test Mode : 0x40\n\t *\t\t\t    RAM Test Mode : 0x80\n\t *\t     Bit 5\t : unused\n\t *\t     Bit 4(RO)   : Done bit\n\t *\t     Bit 3-0(RO) : Status\n\t *\t\t\t    Host Error    : 0x08\n\t *\t\t\t    Int_RAM Error : 0x04\n\t *\t\t\t    RISC Error    : 0x02\n\t *\t\t\t    SCSI Error    : 0x01\n\t *\t\t\t    No Error\t  : 0x00\n\t *\n\t * Note: RAM BIST code should be put right here, before loading the\n\t * microcode and after saving the RISC memory BIOS region.\n\t */\n\n\t/*\n\t * LRAM Pre-test\n\t *\n\t * Write PRE_TEST_MODE (0x40) to register and wait for 10 milliseconds.\n\t * If Done bit not set or low nibble not PRE_TEST_VALUE (0x05), return\n\t * an error. Reset to NORMAL_MODE (0x00) and do again. If cannot reset\n\t * to NORMAL_MODE, return an error too.\n\t */\n\tfor (i = 0; i < 2; i++) {\n\t\tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_RAM_BIST, PRE_TEST_MODE);\n\t\tAdvSleepMilliSecond(10);  /* Wait for 10ms before reading back. */\n\t\tbyte = ADW_READ_BYTE_REGISTER(iot, ioh, IOPB_RAM_BIST);\n\t\tif ((byte & RAM_TEST_DONE) == 0 || (byte & 0x0F) !=\n\t\t\t\tPRE_TEST_VALUE) {\n\t\t\treturn ASC_IERR_BIST_PRE_TEST;\n\t\t}\n\n\t\tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_RAM_BIST, NORMAL_MODE);\n\t\tAdvSleepMilliSecond(10);  /* Wait for 10ms before reading back. */\n\t\tif (ADW_READ_BYTE_REGISTER(iot, ioh, IOPB_RAM_BIST)\n\t\t    != NORMAL_VALUE) {\n\t\t\treturn ASC_IERR_BIST_PRE_TEST;\n\t\t}\n\t}\n\n\t/*\n\t * LRAM Test - It takes about 1.5 ms to run through the test.\n\t *\n\t * Write RAM_TEST_MODE (0x80) to register and wait for 10 milliseconds.\n\t * If Done bit not set or Status not 0, save register byte, set the\n\t * err_code, and return an error.\n\t */\n\tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_RAM_BIST, RAM_TEST_MODE);\n\tAdvSleepMilliSecond(10);  /* Wait for 10ms before checking status. */\n\n\tbyte = ADW_READ_BYTE_REGISTER(iot, ioh, IOPB_RAM_BIST);\n\tif ((byte & RAM_TEST_DONE) == 0 || (byte & RAM_TEST_STATUS) != 0) {\n\t\t/* Get here if Done bit not set or Status not 0. */\n\t\treturn ASC_IERR_BIST_RAM_TEST;\n\t}\n\n\t/* We need to reset back to normal mode after LRAM test passes. */\n\tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_RAM_BIST, NORMAL_MODE);\n\n\t/*\n\t * Load the Microcode\n\t *\n\t * Write the microcode image to RISC memory starting at address 0.\n\t *\n\t */\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_RAM_ADDR, 0);\n\n\t/* Assume the following compressed format of the microcode buffer:\n\t *\n\t *  254 word (508 byte) table indexed by byte code followed\n\t *  by the following byte codes:\n\t *\n\t *    1-Byte Code:\n\t *\t00: Emit word 0 in table.\n\t *\t01: Emit word 1 in table.\n\t *\t.\n\t *\tFD: Emit word 253 in table.\n\t *\n\t *    Multi-Byte Code:\n\t *\tFE WW WW: (3 byte code) Word to emit is the next word WW WW.\n\t *\tFF BB WW WW: (4 byte code) Emit BB count times next word WW WW.\n\t */\n\tword = 0;\n\tfor (i = 253 * 2; i < adv_asc38C0800_mcode_size; i++) {\n\t\tif (adv_asc38C0800_mcode[i] == 0xff) {\n\t\t\tfor (j = 0; j < adv_asc38C0800_mcode[i + 1]; j++) {\n\t\t\t\tADW_WRITE_WORD_AUTO_INC_LRAM(iot, ioh,\n\t\t\t\t    (((u_int16_t)\n\t\t\t\t    adv_asc38C0800_mcode[i + 3] << 8) |\n\t\t\t\t    adv_asc38C0800_mcode[i + 2]));\n\t\t\t\tword++;\n\t\t\t}\n\t\t\ti += 3;\n\t\t} else if (adv_asc38C0800_mcode[i] == 0xfe) {\n\t\t\tADW_WRITE_WORD_AUTO_INC_LRAM(iot, ioh, (((u_int16_t)\n\t\t\t    adv_asc38C0800_mcode[i + 2] << 8) |\n\t\t\t    adv_asc38C0800_mcode[i + 1]));\n\t\t\ti += 2;\n\t\t\tword++;\n\t\t} else {\n\t\t\tADW_WRITE_WORD_AUTO_INC_LRAM(iot, ioh, (((u_int16_t)\n\t\t\t  adv_asc38C0800_mcode[(adv_asc38C0800_mcode[i] * 2) + 1] << 8) |\n\t\t\t  adv_asc38C0800_mcode[adv_asc38C0800_mcode[i] * 2]));\n\t\t\tword++;\n\t\t}\n\t}\n\n\t/*\n\t * Set 'word' for later use to clear the rest of memory and save\n\t * the expanded mcode size.\n\t */\n\tword *= 2;\n\tadv_asc38C0800_expanded_size = word;\n\n\t/*\n\t * Clear the rest of ASC-38C0800 Internal RAM (16KB).\n\t */\n\tfor (; word < ADV_38C0800_MEMSIZE; word += 2) {\n\t\tADW_WRITE_WORD_AUTO_INC_LRAM(iot, ioh, 0);\n\t}\n\n\t/*\n\t * Verify the microcode checksum.\n\t */\n\tsum = 0;\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_RAM_ADDR, 0);\n\n\tfor (word = 0; word < adv_asc38C0800_expanded_size; word += 2) {\n\t\tsum += ADW_READ_WORD_AUTO_INC_LRAM(iot, ioh);\n\t}\n\n\tif (sum != adv_asc38C0800_mcode_chksum) {\n\t    return ASC_IERR_MCODE_CHKSUM;\n\t}\n\n\t/*\n\t * Restore the RISC memory BIOS region.\n\t */\n\tfor (i = 0; i < ASC_MC_BIOSLEN/2; i++) {\n\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_BIOSMEM + (2 * i),\n\t\t\t\tbios_mem[i]);\n\t}\n\n\t/*\n\t * Calculate and write the microcode code checksum to the microcode\n\t * code checksum location ASC_MC_CODE_CHK_SUM (0x2C).\n\t */\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_CODE_BEGIN_ADDR, begin_addr);\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_CODE_END_ADDR, end_addr);\n\tcode_sum = 0;\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_RAM_ADDR, begin_addr);\n\tfor (word = begin_addr; word < end_addr; word += 2) {\n\t\tcode_sum += ADW_READ_WORD_AUTO_INC_LRAM(iot, ioh);\n\t}\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_CODE_CHK_SUM, code_sum);\n\n\t/*\n\t * Read microcode version and date.\n\t */\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_VERSION_DATE,\n\t\t\tsc->cfg.mcode_date);\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_VERSION_NUM,\n\t\t\tsc->cfg.mcode_version);\n\n\t/*\n\t * Set the chip type to indicate the ASC38C0800.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_CHIP_TYPE, ADV_CHIP_ASC38C0800);\n\n\t/*\n\t * Write 1 to bit 14 'DIS_TERM_DRV' in the SCSI_CFG1 register.\n\t * When DIS_TERM_DRV set to 1, C_DET[3:0] will reflect current\n\t * cable detection and then we are able to read C_DET[3:0].\n\t *\n\t * Note: We will reset DIS_TERM_DRV to 0 in the 'Set SCSI_CFG1\n\t * Microcode Default Value' section below.\n\t */\n\tscsi_cfg1 = ADW_READ_WORD_REGISTER(iot, ioh, IOPW_SCSI_CFG1);\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_SCSI_CFG1,\n\t\t\tscsi_cfg1 | ADW_DIS_TERM_DRV);\n\n\t/*\n\t * If the PCI Configuration Command Register \"Parity Error Response\n\t * Control\" Bit was clear (0), then set the microcode variable\n\t * 'control_flag' CONTROL_FLAG_IGNORE_PERR flag to tell the microcode\n\t * to ignore DMA parity errors.\n\t */\n\tif (sc->cfg.control_flag & CONTROL_FLAG_IGNORE_PERR) {\n\t\t/*\n\t\t * Note: Don't remove the use of a temporary variable in\n\t\t * the following code, otherwise some C compiler\n\t\t * might turn the following lines into a no-op.\n\t\t */\n\t\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_CONTROL_FLAG, word);\n\t\tword |= CONTROL_FLAG_IGNORE_PERR;\n\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_CONTROL_FLAG, word);\n\t}\n\n\t/*\n\t * For ASC-38C0800, set FIFO_THRESH_80B [6:4] bits and START_CTL_TH [3:2]\n\t * bits for the default FIFO threshold.\n\t *\n\t * Note: ASC-38C0800 FIFO threshold has been changed to 256 bytes.\n\t *\n\t * For DMA Errata #4 set the BC_THRESH_ENB bit.\n\t */\n\tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_DMA_CFG0,\n\t\tBC_THRESH_ENB | FIFO_THRESH_80B | START_CTL_TH | READ_CMD_MRM);\n\n\t/*\n\t * Microcode operating variables for WDTR, SDTR, and command tag\n\t * queuing will be set in AdvInquiryHandling() based on what a\n\t * device reports it is capable of in Inquiry byte 7.\n\t *\n\t * If SCSI Bus Resets have been disabled, then directly set\n\t * SDTR and WDTR from the EEPROM configuration. This will allow\n\t * the BIOS and warm boot to work without a SCSI bus hang on\n\t * the Inquiry caused by host and target mismatched DTR values.\n\t * Without the SCSI Bus Reset, before an Inquiry a device can't\n\t * be assumed to be in Asynchronous, Narrow mode.\n\t */\n\tif ((sc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS) == 0) {\n\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_WDTR_ABLE, sc->wdtr_able);\n\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_ABLE, sc->sdtr_able);\n\t}\n\n\t/*\n\t * Set microcode operating variables for DISC and SDTR_SPEED1,\n\t * SDTR_SPEED2, SDTR_SPEED3, and SDTR_SPEED4 based on the EEPROM\n\t * configuration values.\n\t *\n\t * The SDTR per TID bitmask overrides the SDTR_SPEED1, SDTR_SPEED2,\n\t * SDTR_SPEED3, and SDTR_SPEED4 values so it is safe to set them\n\t * without determining here whether the device supports SDTR.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DISC_ENABLE, sc->cfg.disc_enable);\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_SPEED1, sc->sdtr_speed1);\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_SPEED2, sc->sdtr_speed2);\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_SPEED3, sc->sdtr_speed3);\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_SPEED4, sc->sdtr_speed4);\n\n\t/*\n\t * Set SCSI_CFG0 Microcode Default Value.\n\t *\n\t * The microcode will set the SCSI_CFG0 register using this value\n\t * after it is started below.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DEFAULT_SCSI_CFG0,\n\t\tADW_PARITY_EN | ADW_SEL_TMO_LONG | ADW_OUR_ID_EN |\n\t\t\tsc->chip_scsi_id);\n\n\t/*\n\t * Determine SCSI_CFG1 Microcode Default Value.\n\t *\n\t * The microcode will set the SCSI_CFG1 register using this value\n\t * after it is started below.\n\t */\n\n\t/* Read current SCSI_CFG1 Register value. */\n\tscsi_cfg1 = ADW_READ_WORD_REGISTER(iot, ioh, IOPW_SCSI_CFG1);\n\n\t/*\n\t * If the internal narrow cable is reversed all of the SCSI_CTRL\n\t * register signals will be set. Check for and return an error if\n\t * this condition is found.\n\t */\n\tif ((ADW_READ_WORD_REGISTER(iot, ioh, IOPW_SCSI_CTRL) & 0x3F07) ==\n\t\t\t0x3F07) {\n\t\treturn ASC_IERR_REVERSED_CABLE;\n\t}\n\n\t/*\n\t * All kind of combinations of devices attached to one of four connectors\n\t * are acceptable except HVD device attached. For example, LVD device can\n\t * be attached to SE connector while SE device attached to LVD connector.\n\t * If LVD device attached to SE connector, it only runs up to Ultra speed.\n\t *\n\t * If an HVD device is attached to one of LVD connectors, return an error.\n\t * However, there is no way to detect HVD device attached to SE connectors.\n\t */\n\tif (scsi_cfg1 & ADW_HVD) {\n\t\treturn ASC_IERR_HVD_DEVICE;\n\t}\n\n\t/*\n\t * If either SE or LVD automatic termination control is enabled, then\n\t * set the termination value based on a table listed in a_condor.h.\n\t *\n\t * If manual termination was specified with an EEPROM setting then\n\t * 'termination' was set-up in AdvInitFrom38C0800EEPROM() and is ready to\n\t * be 'ored' into SCSI_CFG1.\n\t */\n\tif ((sc->cfg.termination & ADW_TERM_SE) == 0) {\n\t\t/* SE automatic termination control is enabled. */\n\t\tswitch(scsi_cfg1 & ADW_C_DET_SE) {\n\t\t\t/* TERM_SE_HI: on, TERM_SE_LO: on */\n\t\t\tcase 0x1: case 0x2: case 0x3:\n\t\t\t\tsc->cfg.termination |= ADW_TERM_SE;\n\t\t\t\tbreak;\n\n\t\t\t/* TERM_SE_HI: on, TERM_SE_LO: off */\n\t\t\tcase 0x0:\n\t\t\t\tsc->cfg.termination |= ADW_TERM_SE_HI;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ((sc->cfg.termination & ADW_TERM_LVD) == 0) {\n\t\t/* LVD automatic termination control is enabled. */\n\t\tswitch(scsi_cfg1 & ADW_C_DET_LVD) {\n\t\t\t/* TERM_LVD_HI: on, TERM_LVD_LO: on */\n\t\t\tcase 0x4: case 0x8: case 0xC:\n\t\t\t\tsc->cfg.termination |= ADW_TERM_LVD;\n\t\t\t\tbreak;\n\n\t\t\t/* TERM_LVD_HI: off, TERM_LVD_LO: off */\n\t\t\tcase 0x0:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * Clear any set TERM_SE and TERM_LVD bits.\n\t */\n\tscsi_cfg1 &= (~ADW_TERM_SE & ~ADW_TERM_LVD);\n\n\t/*\n\t * Invert the TERM_SE and TERM_LVD bits and then set 'scsi_cfg1'.\n\t */\n\tscsi_cfg1 |= (~sc->cfg.termination & 0xF0);\n\n\t/*\n\t * Clear BIG_ENDIAN, DIS_TERM_DRV, Terminator Polarity and HVD/LVD/SE bits\n\t * and set possibly modified termination control bits in the Microcode\n\t * SCSI_CFG1 Register Value.\n\t */\n\tscsi_cfg1 &= (~ADW_BIG_ENDIAN & ~ADW_DIS_TERM_DRV &\n\t\t\t~ADW_TERM_POL & ~ADW_HVD_LVD_SE);\n\n\t/*\n\t * Set SCSI_CFG1 Microcode Default Value\n\t *\n\t * Set possibly modified termination control and reset DIS_TERM_DRV\n\t * bits in the Microcode SCSI_CFG1 Register Value.\n\t *\n\t * The microcode will set the SCSI_CFG1 register using this value\n\t * after it is started below.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DEFAULT_SCSI_CFG1, scsi_cfg1);\n\n\t/*\n\t * Set MEM_CFG Microcode Default Value\n\t *\n\t * The microcode will set the MEM_CFG register using this value\n\t * after it is started below.\n\t *\n\t * MEM_CFG may be accessed as a word or byte, but only bits 0-7\n\t * are defined.\n\t *\n\t * ASC-38C0800 has 16KB internal memory.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DEFAULT_MEM_CFG,\n\t\tADW_BIOS_EN | ADW_RAM_SZ_16KB);\n\n\t/*\n\t * Set SEL_MASK Microcode Default Value\n\t *\n\t * The microcode will set the SEL_MASK register using this value\n\t * after it is started below.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DEFAULT_SEL_MASK,\n\t\tADW_TID_TO_TIDMASK(sc->chip_scsi_id));\n\n\n\t/*\n\t * Set-up the Host->RISC Initiator Command Queue (ICQ) if\n\t * one is not already set up, i.e. this is the first\n\t * time through as opposed to a bus reset.\n\t */\n\n\tif (sc->icq_sp == NULL) {\n\t\tsc->carr_pending_cnt = 0;\n\t\tif ((sc->icq_sp = sc->carr_freelist) == NULL) {\n\t\t\treturn ASC_IERR_NO_CARRIER;\n\t\t}\n\t\tsc->carr_freelist = adw_carrier_phys_kv(sc,\n\t\t\t\tASC_GET_CARRP(sc->icq_sp->next_vpa));\n\n\n\t\t/*\n\t \t * The first command issued will be placed in the stopper carrier.\n\t \t */\n\t\tsc->icq_sp->next_vpa = ASC_CQ_STOPPER;\n\t}\n\n\t/*\n\t * Set RISC ICQ physical address start value.\n\t */\n\tADW_WRITE_DWORD_LRAM(iot, ioh, ASC_MC_ICQ, sc->icq_sp->carr_pa);\n\n\t/*\n\t * Set-up the RISC->Host Initiator Response Queue (IRQ) if\n\t * one is not already set up, i.e. this is the first\n\t * time through as opposed to a bus reset.\n\t */\n\tif (sc->irq_sp == NULL) {\n\t\tif ((sc->irq_sp = sc->carr_freelist) == NULL) {\n\t\t\treturn ASC_IERR_NO_CARRIER;\n\t\t}\n\t\tsc->carr_freelist = adw_carrier_phys_kv(sc,\n\t\t\t\tASC_GET_CARRP(sc->irq_sp->next_vpa));\n\n\t\t/*\n\t \t * The first command completed by the RISC will be placed in\n\t \t * the stopper.\n\t \t *\n\t \t * Note: Set 'next_vpa' to ASC_CQ_STOPPER. When the request is\n\t \t * completed the RISC will set the ASC_RQ_DONE bit.\n\t \t */\n\t\tsc->irq_sp->next_vpa = ASC_CQ_STOPPER;\n\t}\n\n\t/*\n\t * Set RISC IRQ physical address start value.\n\t */\n\tADW_WRITE_DWORD_LRAM(iot, ioh, ASC_MC_IRQ, sc->irq_sp->carr_pa);\n\n\tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_INTR_ENABLES,\n\t\t(ADW_INTR_ENABLE_HOST_INTR | ADW_INTR_ENABLE_GLOBAL_INTR));\n\t/*\n\t * Note: Don't remove the use of a temporary variable in\n\t * the following code, otherwise some C compiler\n\t * might turn the following lines into a no-op.\n\t */\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_CODE_BEGIN_ADDR, word);\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_PC, word);\n\n\t/* finally, finally, gentlemen, start your engine */\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_RISC_CSR, ADW_RISC_CSR_RUN);\n\n\t/*\n\t * Reset the SCSI Bus if the EEPROM indicates that SCSI Bus\n\t * Resets should be performed. The RISC has to be running\n\t * to issue a SCSI Bus Reset.\n\t */\n\tif (sc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS) {\n\t\t/*\n\t\t * If the BIOS Signature is present in memory, restore the\n\t\t * BIOS Handshake Configuration Table and do not perform\n\t\t * a SCSI Bus Reset.\n\t\t */\n\t\tif (bios_mem[(ASC_MC_BIOS_SIGNATURE - ASC_MC_BIOSMEM)/2] ==\n\t\t\t\t0x55AA) {\n\t\t\t/*\n\t\t\t * Restore per TID negotiated values.\n\t\t\t */\n\t\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_WDTR_ABLE, wdtr_able);\n\t\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_ABLE, sdtr_able);\n\t\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_TAGQNG_ABLE,\n\t\t\t\t\ttagqng_able);\n\t\t\tfor (tid = 0; tid <= ADW_MAX_TID; tid++) {\n\t\t\t\tADW_WRITE_BYTE_LRAM(iot, ioh,\n\t\t\t\t\t\tASC_MC_NUMBER_OF_MAX_CMD + tid,\n\t\t\t\t\t\tmax_cmd[tid]);\n\t\t\t}\n\t\t} else {\n\t\t\tif (AdvResetCCB(sc) != ADW_TRUE) {\n\t\t\t\twarn_code = ASC_WARN_BUSRESET_ERROR;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn warn_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_REGISTER",
          "args": [
            "iot",
            "ioh",
            "IOPW_CTRL_REG",
            "ADW_CTRL_REG_CMD_WR_IO_REG"
          ],
          "line": 2117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AdvSleepMilliSecond",
          "args": [
            "100"
          ],
          "line": 2116
        },
        "resolved": true,
        "details": {
          "function_name": "AdvSleepMilliSecond",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adwlib.c",
          "lines": "2552-2558",
          "snippet": "static void\nAdvSleepMilliSecond(n)\nu_int32_t\tn;\n{\n\n\tDELAY(n * 1000);\n}",
          "includes": [
            "#include <dev/ic/adwmcode.h>",
            "#include <dev/ic/adw.h>",
            "#include <dev/ic/adwlib.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/queue.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void AdvSleepMilliSecond"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/adwmcode.h>\n#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void AdvSleepMilliSecond;\n\nstatic void\nAdvSleepMilliSecond(n)\nu_int32_t\tn;\n{\n\n\tDELAY(n * 1000);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_REGISTER",
          "args": [
            "iot",
            "ioh",
            "IOPW_CTRL_REG",
            "ADW_CTRL_REG_CMD_RESET"
          ],
          "line": 2114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_REGISTER",
          "args": [
            "iot",
            "ioh",
            "IOPW_RISC_CSR",
            "ADW_RISC_CSR_STOP"
          ],
          "line": 2113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_BIOS_SIGNATURE",
            "0"
          ],
          "line": 2108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_READ_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_BIOS_SIGNATURE",
            "bios_sig"
          ],
          "line": 2107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_READ_BYTE_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_NUMBER_OF_MAX_CMD + tid",
            "max_cmd[tid]"
          ],
          "line": 2097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_READ_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_TAGQNG_ABLE",
            "tagqng_able"
          ],
          "line": 2094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_READ_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_SDTR_ABLE",
            "sdtr_able"
          ],
          "line": 2093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_READ_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_WDTR_ABLE",
            "wdtr_able"
          ],
          "line": 2092
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/adwmcode.h>\n#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void AdvSleepMilliSecond;\nADW_SOFTC\t*sc;\nbus_space_tag_t iot = sc->sc_iot;\nbus_space_handle_t ioh = sc->sc_ioh;\nu_int8_t\t\ttid;\n\nint\nAdvResetSCSIBus(sc)\nADW_SOFTC\t*sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint\t\tstatus;\n\tu_int16_t\twdtr_able, sdtr_able, tagqng_able;\n\tu_int8_t\ttid, max_cmd[ADW_MAX_TID + 1];\n\tu_int16_t\tbios_sig;\n\n\n\t/*\n\t * Save current per TID negotiated values.\n\t */\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_WDTR_ABLE, wdtr_able);\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_SDTR_ABLE, sdtr_able);\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_TAGQNG_ABLE, tagqng_able);\n\tfor (tid = 0; tid <= ADW_MAX_TID; tid++)\n\t{\n\t\tADW_READ_BYTE_LRAM(iot, ioh, ASC_MC_NUMBER_OF_MAX_CMD + tid,\n\t\t\tmax_cmd[tid]);\n\t}\n\n\t/*\n\t * Force the AdvInitAsc3550/38C0800Driver() function to\n\t * perform a SCSI Bus Reset by clearing the BIOS signature word.\n\t * The initialization functions assumes a SCSI Bus Reset is not\n\t * needed if the BIOS signature word is present.\n\t */\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_BIOS_SIGNATURE, bios_sig);\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_BIOS_SIGNATURE, 0);\n\n\t/*\n\t * Stop chip and reset it.\n\t */\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_RISC_CSR, ADW_RISC_CSR_STOP);\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_CTRL_REG,\n\t\t\tADW_CTRL_REG_CMD_RESET);\n\tAdvSleepMilliSecond(100);\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_CTRL_REG,\n\t\t\tADW_CTRL_REG_CMD_WR_IO_REG);\n\n\t/*\n\t * Reset Adv Library error code, if any, and try\n\t * re-initializing the chip.\n\t */\n\tif (sc->chip_type == ADV_CHIP_ASC38C0800) {\n\t\tstatus = AdvInitAsc38C0800Driver(sc);\n\t} else {\n\t\tstatus = AdvInitAsc3550Driver(sc);\n\t}\n\n\t/* Translate initialization return value to status value. */\n\tif (status == 0) {\n\t\tstatus = ADW_TRUE;\n\t} else {\n\t\tstatus = ADW_FALSE;\n\t}\n\n\t/*\n\t * Restore the BIOS signature word.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_BIOS_SIGNATURE, bios_sig);\n\n\t/*\n\t * Restore per TID negotiated values.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_WDTR_ABLE, wdtr_able);\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_ABLE, sdtr_able);\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_TAGQNG_ABLE, tagqng_able);\n\tfor (tid = 0; tid <= ADW_MAX_TID; tid++) {\n\t\tADW_WRITE_BYTE_LRAM(iot, ioh, ASC_MC_NUMBER_OF_MAX_CMD + tid,\n\t\t\tmax_cmd[tid]);\n\t}\n\n\treturn status;\n}"
  },
  {
    "function_name": "AdvResetCCB",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adwlib.c",
    "lines": "2030-2067",
    "snippet": "int\nAdvResetCCB(sc)\nADW_SOFTC\t*sc;\n{\n\tint\t    status;\n\n\t/*\n\t * Send the SCSI Bus Reset idle start idle command which asserts\n\t * the SCSI Bus Reset signal.\n\t */\n\tstatus = AdvSendIdleCmd(sc, (u_int16_t) IDLE_CMD_SCSI_RESET_START, 0L);\n\tif (status != ADW_TRUE)\n\t{\n\t\treturn status;\n\t}\n\n\t/*\n\t * Delay for the specified SCSI Bus Reset hold time.\n\t *\n\t * The hold time delay is done on the host because the RISC has no\n\t * microsecond accurate timer.\n\t */\n\tAdvDelayMicroSecond((u_int16_t) ASC_SCSI_RESET_HOLD_TIME_US);\n\n\t/*\n\t * Send the SCSI Bus Reset end idle command which de-asserts\n\t * the SCSI Bus Reset signal and purges any pending requests.\n\t */\n\tstatus = AdvSendIdleCmd(sc, (u_int16_t) IDLE_CMD_SCSI_RESET_END, 0L);\n\tif (status != ADW_TRUE)\n\t{\n\t\treturn status;\n\t}\n\n\tAdvSleepMilliSecond((u_int32_t) sc->scsi_reset_wait * 1000);\n\n\treturn status;\n}",
    "includes": [
      "#include <dev/ic/adwmcode.h>",
      "#include <dev/ic/adw.h>",
      "#include <dev/ic/adwlib.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/queue.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void AdvSleepMilliSecond",
      "static void AdvDelayMicroSecond",
      "ADW_SOFTC\t*sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "AdvSleepMilliSecond",
          "args": [
            "(u_int32_t) sc->scsi_reset_wait * 1000"
          ],
          "line": 2064
        },
        "resolved": true,
        "details": {
          "function_name": "AdvSleepMilliSecond",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adwlib.c",
          "lines": "2552-2558",
          "snippet": "static void\nAdvSleepMilliSecond(n)\nu_int32_t\tn;\n{\n\n\tDELAY(n * 1000);\n}",
          "includes": [
            "#include <dev/ic/adwmcode.h>",
            "#include <dev/ic/adw.h>",
            "#include <dev/ic/adwlib.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/queue.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void AdvSleepMilliSecond"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/adwmcode.h>\n#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void AdvSleepMilliSecond;\n\nstatic void\nAdvSleepMilliSecond(n)\nu_int32_t\tn;\n{\n\n\tDELAY(n * 1000);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AdvSendIdleCmd",
          "args": [
            "sc",
            "(u_int16_t) IDLE_CMD_SCSI_RESET_END",
            "0L"
          ],
          "line": 2058
        },
        "resolved": true,
        "details": {
          "function_name": "AdvSendIdleCmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adwlib.c",
          "lines": "2334-2393",
          "snippet": "int\nAdvSendIdleCmd(sc, idle_cmd, idle_cmd_parameter)\nADW_SOFTC      *sc;\nu_int16_t       idle_cmd;\nu_int32_t       idle_cmd_parameter;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint\t\tresult;\n\tu_int32_t\ts, i, j;\n \n\ts = splbio();\n\n\t/*\n\t * Clear the idle command status which is set by the microcode\n\t * to a non-zero value to indicate when the command is completed.\n\t * The non-zero result is one of the IDLE_CMD_STATUS_* values\n\t * defined in a_advlib.h.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_IDLE_CMD_STATUS, (u_int16_t) 0);\n\n\t/*\n\t * Write the idle command value after the idle command parameter\n\t * has been written to avoid a race condition. If the order is not\n\t * followed, the microcode may process the idle command before the\n\t * parameters have been written to LRAM.\n\t */\n\tADW_WRITE_DWORD_LRAM(iot, ioh, ASC_MC_IDLE_CMD_PARAMETER,\n\t    idle_cmd_parameter);\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_IDLE_CMD, idle_cmd);\n\n\t/*\n\t * Tickle the RISC to tell it to process the idle command.\n\t */\n\tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_TICKLE, ADV_TICKLE_B);\n\tif (sc->chip_type == ADV_CHIP_ASC3550) {\n\t\t/*\n\t\t * Clear the tickle value. In the ASC-3550 the RISC flag\n\t\t * command 'clr_tickle_b' does not work unless the host\n\t\t * value is cleared.\n\t\t */\n\t\tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_TICKLE, ADV_TICKLE_NOP);\n\t}\n\n\t/* Wait for up to 100 millisecond for the idle command to timeout. */\n\tfor (i = 0; i < SCSI_WAIT_100_MSEC; i++) {\n\t\t/* Poll once each microsecond for command completion. */\n\t\tfor (j = 0; j < SCSI_US_PER_MSEC; j++) {\n\t\t\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_IDLE_CMD_STATUS, result);\n\t\t\tif (result != 0) {\n\t\t\t\tsplx(s);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tAdvDelayMicroSecond(1);\n\t\t}\n\t}\n\n\tsplx(s);\n\treturn ADW_ERROR;\n}",
          "includes": [
            "#include <dev/ic/adwmcode.h>",
            "#include <dev/ic/adw.h>",
            "#include <dev/ic/adwlib.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/queue.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void AdvDelayMicroSecond",
            "ADW_SOFTC\t*sc;",
            "bus_space_tag_t iot = sc->sc_iot;",
            "bus_space_handle_t ioh = sc->sc_ioh;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/adwmcode.h>\n#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void AdvDelayMicroSecond;\nADW_SOFTC\t*sc;\nbus_space_tag_t iot = sc->sc_iot;\nbus_space_handle_t ioh = sc->sc_ioh;\n\nint\nAdvSendIdleCmd(sc, idle_cmd, idle_cmd_parameter)\nADW_SOFTC      *sc;\nu_int16_t       idle_cmd;\nu_int32_t       idle_cmd_parameter;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint\t\tresult;\n\tu_int32_t\ts, i, j;\n \n\ts = splbio();\n\n\t/*\n\t * Clear the idle command status which is set by the microcode\n\t * to a non-zero value to indicate when the command is completed.\n\t * The non-zero result is one of the IDLE_CMD_STATUS_* values\n\t * defined in a_advlib.h.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_IDLE_CMD_STATUS, (u_int16_t) 0);\n\n\t/*\n\t * Write the idle command value after the idle command parameter\n\t * has been written to avoid a race condition. If the order is not\n\t * followed, the microcode may process the idle command before the\n\t * parameters have been written to LRAM.\n\t */\n\tADW_WRITE_DWORD_LRAM(iot, ioh, ASC_MC_IDLE_CMD_PARAMETER,\n\t    idle_cmd_parameter);\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_IDLE_CMD, idle_cmd);\n\n\t/*\n\t * Tickle the RISC to tell it to process the idle command.\n\t */\n\tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_TICKLE, ADV_TICKLE_B);\n\tif (sc->chip_type == ADV_CHIP_ASC3550) {\n\t\t/*\n\t\t * Clear the tickle value. In the ASC-3550 the RISC flag\n\t\t * command 'clr_tickle_b' does not work unless the host\n\t\t * value is cleared.\n\t\t */\n\t\tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_TICKLE, ADV_TICKLE_NOP);\n\t}\n\n\t/* Wait for up to 100 millisecond for the idle command to timeout. */\n\tfor (i = 0; i < SCSI_WAIT_100_MSEC; i++) {\n\t\t/* Poll once each microsecond for command completion. */\n\t\tfor (j = 0; j < SCSI_US_PER_MSEC; j++) {\n\t\t\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_IDLE_CMD_STATUS, result);\n\t\t\tif (result != 0) {\n\t\t\t\tsplx(s);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tAdvDelayMicroSecond(1);\n\t\t}\n\t}\n\n\tsplx(s);\n\treturn ADW_ERROR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AdvDelayMicroSecond",
          "args": [
            "(u_int16_t) ASC_SCSI_RESET_HOLD_TIME_US"
          ],
          "line": 2052
        },
        "resolved": true,
        "details": {
          "function_name": "AdvDelayMicroSecond",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adwlib.c",
          "lines": "2561-2567",
          "snippet": "static void\nAdvDelayMicroSecond(n)\nu_int32_t\tn;\n{\n\n\tDELAY(n);\n}",
          "includes": [
            "#include <dev/ic/adwmcode.h>",
            "#include <dev/ic/adw.h>",
            "#include <dev/ic/adwlib.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/queue.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void AdvDelayMicroSecond"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/adwmcode.h>\n#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void AdvDelayMicroSecond;\n\nstatic void\nAdvDelayMicroSecond(n)\nu_int32_t\tn;\n{\n\n\tDELAY(n);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/adwmcode.h>\n#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void AdvSleepMilliSecond;\nstatic void AdvDelayMicroSecond;\nADW_SOFTC\t*sc;\n\nint\nAdvResetCCB(sc)\nADW_SOFTC\t*sc;\n{\n\tint\t    status;\n\n\t/*\n\t * Send the SCSI Bus Reset idle start idle command which asserts\n\t * the SCSI Bus Reset signal.\n\t */\n\tstatus = AdvSendIdleCmd(sc, (u_int16_t) IDLE_CMD_SCSI_RESET_START, 0L);\n\tif (status != ADW_TRUE)\n\t{\n\t\treturn status;\n\t}\n\n\t/*\n\t * Delay for the specified SCSI Bus Reset hold time.\n\t *\n\t * The hold time delay is done on the host because the RISC has no\n\t * microsecond accurate timer.\n\t */\n\tAdvDelayMicroSecond((u_int16_t) ASC_SCSI_RESET_HOLD_TIME_US);\n\n\t/*\n\t * Send the SCSI Bus Reset end idle command which de-asserts\n\t * the SCSI Bus Reset signal and purges any pending requests.\n\t */\n\tstatus = AdvSendIdleCmd(sc, (u_int16_t) IDLE_CMD_SCSI_RESET_END, 0L);\n\tif (status != ADW_TRUE)\n\t{\n\t\treturn status;\n\t}\n\n\tAdvSleepMilliSecond((u_int32_t) sc->scsi_reset_wait * 1000);\n\n\treturn status;\n}"
  },
  {
    "function_name": "AdvResetChip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adwlib.c",
    "lines": "2004-2018",
    "snippet": "void\nAdvResetChip(iot, ioh)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n{\n\n\t/*\n\t * Reset Chip.\n\t */\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_CTRL_REG,\n\t\t\tADW_CTRL_REG_CMD_RESET);\n\tAdvSleepMilliSecond(100);\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_CTRL_REG,\n\t\t\tADW_CTRL_REG_CMD_WR_IO_REG);\n}",
    "includes": [
      "#include <dev/ic/adwmcode.h>",
      "#include <dev/ic/adw.h>",
      "#include <dev/ic/adwlib.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/queue.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void AdvSleepMilliSecond",
      "bus_space_tag_t iot = sc->sc_iot;",
      "bus_space_handle_t ioh = sc->sc_ioh;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_REGISTER",
          "args": [
            "iot",
            "ioh",
            "IOPW_CTRL_REG",
            "ADW_CTRL_REG_CMD_WR_IO_REG"
          ],
          "line": 2016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AdvSleepMilliSecond",
          "args": [
            "100"
          ],
          "line": 2015
        },
        "resolved": true,
        "details": {
          "function_name": "AdvSleepMilliSecond",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adwlib.c",
          "lines": "2552-2558",
          "snippet": "static void\nAdvSleepMilliSecond(n)\nu_int32_t\tn;\n{\n\n\tDELAY(n * 1000);\n}",
          "includes": [
            "#include <dev/ic/adwmcode.h>",
            "#include <dev/ic/adw.h>",
            "#include <dev/ic/adwlib.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/queue.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void AdvSleepMilliSecond"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/adwmcode.h>\n#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void AdvSleepMilliSecond;\n\nstatic void\nAdvSleepMilliSecond(n)\nu_int32_t\tn;\n{\n\n\tDELAY(n * 1000);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_REGISTER",
          "args": [
            "iot",
            "ioh",
            "IOPW_CTRL_REG",
            "ADW_CTRL_REG_CMD_RESET"
          ],
          "line": 2013
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/adwmcode.h>\n#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void AdvSleepMilliSecond;\nbus_space_tag_t iot = sc->sc_iot;\nbus_space_handle_t ioh = sc->sc_ioh;\n\nvoid\nAdvResetChip(iot, ioh)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n{\n\n\t/*\n\t * Reset Chip.\n\t */\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_CTRL_REG,\n\t\t\tADW_CTRL_REG_CMD_RESET);\n\tAdvSleepMilliSecond(100);\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_CTRL_REG,\n\t\t\tADW_CTRL_REG_CMD_WR_IO_REG);\n}"
  },
  {
    "function_name": "AdvExeScsiQueue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adwlib.c",
    "lines": "1876-2001",
    "snippet": "int\nAdvExeScsiQueue(sc, scsiq)\nADW_SOFTC\t*sc;\nADW_SCSI_REQ_Q\t*scsiq;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tADW_CCB\t\t*ccb;\n\tlong\t\treq_size;\n\tu_int32_t\treq_paddr;\n\tADW_CARRIER\t*new_carrp, *new_freep/*, *ccb_carr;\n\tint\t\ti*/;\n\n\n\t/*\n\t * The ADW_SCSI_REQ_Q 'target_id' field should never exceed ADW_MAX_TID.\n\t */\n\tif (scsiq->target_id > ADW_MAX_TID) {\n\t\tscsiq->host_status = QHSTA_M_INVALID_DEVICE;\n\t\tscsiq->done_status = QD_WITH_ERROR;\n\t\treturn ADW_ERROR;\n\t}\n\n\tccb = adw_ccb_phys_kv(sc, scsiq->ccb_ptr);\n\tccb->carr_list = sc->icq_sp;\n\n\t/*\n\t * Allocate a carrier ensuring at least one carrier always\n\t * remains on the freelist and initialize fields.\n\t */\n\tnew_carrp = sc->carr_freelist;\n        new_freep = adw_carrier_phys_kv( sc, \n\t\t\t\t\t ASC_GET_CARRP( new_carrp->next_vpa) );\n\n\tif (new_freep == NULL) {\n\t\treturn ADW_BUSY;\n\t}\n\tsc->carr_freelist = new_freep;\n\tsc->carr_pending_cnt++;\n\n\t/*\n\t * Set the carrier to be a stopper by setting 'next_vpa'\n\t * to the stopper value. The current stopper will be changed\n\t * below to point to the new stopper.\n\t */\n\tnew_carrp->next_vpa = ASC_CQ_STOPPER;\n\n\treq_size = sizeof(ADW_SCSI_REQ_Q);\n\treq_paddr = sc->sc_dmamap_control->dm_segs[0].ds_addr +\n\t\tADW_CCB_OFF(ccb) + offsetof(struct adw_ccb, scsiq);\n\n\t/* Save physical address of ADW_SCSI_REQ_Q and Carrier. */\n\tscsiq->scsiq_rptr = req_paddr;\n\n\t/*\n\t * Every ADV_CARR_T.carr_pa is byte swapped to little-endian\n\t * order during initialization.\n\t */\n\tscsiq->carr_pa = sc->icq_sp->carr_pa;\n\tscsiq->carr_va = sc->icq_sp->carr_pa;\n\n\t/*\n\t * Use the current stopper to send the ADW_SCSI_REQ_Q command to\n\t * the microcode. The newly allocated stopper will become the new\n\t * stopper.\n\t */\n\tsc->icq_sp->areq_vpa = req_paddr;\n\n\t/*\n\t * Set the 'next_vpa' pointer for the old stopper to be the\n\t * physical address of the new stopper. The RISC can only\n\t * follow physical addresses.\n\t */\n\tsc->icq_sp->next_vpa = new_carrp->carr_pa;\n\n\t/*\n\t * Set the host adapter stopper pointer to point to the new carrier.\n\t */\n\tsc->icq_sp = new_carrp;\n\n/*\tccb_carr = ccb->carr_list;\n\twhile(ccb_carr != ASC_CQ_STOPPER) {\n\t\tbus_dmamap_load(sc->sc_dmat, ccb_carr->dmamap_xfer,\n\t\t\t\tccb_carr, ADW_CARRIER_SIZE,\n\t\t\t\tNULL, BUS_DMA_NOWAIT);\n\t\tbus_dmamap_sync(sc->sc_dmat, ccb_carr->dmamap_xfer, 0,\n\t\t\t\tccb_carr->dmamap_xfer->dm_mapsize,\n\t\t\t\tBUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);\n\t\tccb_carr = adw_carrier_phys_kv(sc,\n\t\t\t\tASC_GET_CARRP(ccb_carr->next_vpa));\n\t}\n\n\tccb_carr = sc->irq_sp;\n\tfor(i=0; i<2 && ccb_carr != ASC_CQ_STOPPER; i++) {\n\t\tbus_dmamap_load(sc->sc_dmat, ccb_carr->dmamap_xfer,\n\t\t\t\tccb_carr, ADW_CARRIER_SIZE,\n\t\t\t\tNULL, BUS_DMA_NOWAIT);\n\t\tbus_dmamap_sync(sc->sc_dmat, ccb_carr->dmamap_xfer, 0,\n\t\t\t\tccb_carr->dmamap_xfer->dm_mapsize,\n\t\t\t\tBUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);\n\t\tccb_carr = adw_carrier_phys_kv(sc,\n\t\t\t\tASC_GET_CARRP(ccb_carr->next_vpa));\n\t}\n*/\n\tbus_dmamap_load(sc->sc_dmat, sc->sc_control->dmamap_xfer,\n\t\t\tsc->sc_control->carriers, ADW_CARRIER_SIZE * ADW_MAX_CARRIER,\n\t\t\tNULL, BUS_DMA_NOWAIT);\n\tbus_dmamap_sync(sc->sc_dmat, sc->sc_control->dmamap_xfer,\n\t\t\tBUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);\n\n\t/*\n\t * Tickle the RISC to tell it to read its Command Queue Head pointer.\n\t */\n\tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_TICKLE, ADV_TICKLE_A);\n\tif (sc->chip_type == ADV_CHIP_ASC3550)\n\t{\n\t\t/*\n\t\t * Clear the tickle value. In the ASC-3550 the RISC flag\n\t\t * command 'clr_tickle_a' does not work unless the host\n\t\t * value is cleared.\n\t\t */\n\t\tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_TICKLE, ADV_TICKLE_NOP);\n\t}\n\n\treturn ADW_SUCCESS;\n}",
    "includes": [
      "#include <dev/ic/adwmcode.h>",
      "#include <dev/ic/adw.h>",
      "#include <dev/ic/adwlib.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/queue.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "ADW_SOFTC\t*sc;",
      "ADW_SCSI_REQ_Q *scsiq;",
      "bus_space_tag_t iot = sc->sc_iot;",
      "bus_space_handle_t ioh = sc->sc_ioh;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ADW_WRITE_BYTE_REGISTER",
          "args": [
            "iot",
            "ioh",
            "IOPB_TICKLE",
            "ADV_TICKLE_NOP"
          ],
          "line": 1997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_BYTE_REGISTER",
          "args": [
            "iot",
            "ioh",
            "IOPB_TICKLE",
            "ADV_TICKLE_A"
          ],
          "line": 1989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_sync",
          "args": [
            "sc->sc_dmat",
            "sc->sc_control->dmamap_xfer",
            "BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE"
          ],
          "line": 1983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_load",
          "args": [
            "sc->sc_dmat",
            "sc->sc_control->dmamap_xfer",
            "sc->sc_control->carriers",
            "ADW_CARRIER_SIZE * ADW_MAX_CARRIER",
            "NULL",
            "BUS_DMA_NOWAIT"
          ],
          "line": 1980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_CCB_OFF",
          "args": [
            "ccb"
          ],
          "line": 1925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adw_carrier_phys_kv",
          "args": [
            "sc",
            "ASC_GET_CARRP( new_carrp->next_vpa)"
          ],
          "line": 1907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASC_GET_CARRP",
          "args": [
            "new_carrp->next_vpa"
          ],
          "line": 1908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adw_ccb_phys_kv",
          "args": [
            "sc",
            "scsiq->ccb_ptr"
          ],
          "line": 1899
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/adwmcode.h>\n#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nADW_SOFTC\t*sc;\nADW_SCSI_REQ_Q *scsiq;\nbus_space_tag_t iot = sc->sc_iot;\nbus_space_handle_t ioh = sc->sc_ioh;\n\nint\nAdvExeScsiQueue(sc, scsiq)\nADW_SOFTC\t*sc;\nADW_SCSI_REQ_Q\t*scsiq;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tADW_CCB\t\t*ccb;\n\tlong\t\treq_size;\n\tu_int32_t\treq_paddr;\n\tADW_CARRIER\t*new_carrp, *new_freep/*, *ccb_carr;\n\tint\t\ti*/;\n\n\n\t/*\n\t * The ADW_SCSI_REQ_Q 'target_id' field should never exceed ADW_MAX_TID.\n\t */\n\tif (scsiq->target_id > ADW_MAX_TID) {\n\t\tscsiq->host_status = QHSTA_M_INVALID_DEVICE;\n\t\tscsiq->done_status = QD_WITH_ERROR;\n\t\treturn ADW_ERROR;\n\t}\n\n\tccb = adw_ccb_phys_kv(sc, scsiq->ccb_ptr);\n\tccb->carr_list = sc->icq_sp;\n\n\t/*\n\t * Allocate a carrier ensuring at least one carrier always\n\t * remains on the freelist and initialize fields.\n\t */\n\tnew_carrp = sc->carr_freelist;\n        new_freep = adw_carrier_phys_kv( sc, \n\t\t\t\t\t ASC_GET_CARRP( new_carrp->next_vpa) );\n\n\tif (new_freep == NULL) {\n\t\treturn ADW_BUSY;\n\t}\n\tsc->carr_freelist = new_freep;\n\tsc->carr_pending_cnt++;\n\n\t/*\n\t * Set the carrier to be a stopper by setting 'next_vpa'\n\t * to the stopper value. The current stopper will be changed\n\t * below to point to the new stopper.\n\t */\n\tnew_carrp->next_vpa = ASC_CQ_STOPPER;\n\n\treq_size = sizeof(ADW_SCSI_REQ_Q);\n\treq_paddr = sc->sc_dmamap_control->dm_segs[0].ds_addr +\n\t\tADW_CCB_OFF(ccb) + offsetof(struct adw_ccb, scsiq);\n\n\t/* Save physical address of ADW_SCSI_REQ_Q and Carrier. */\n\tscsiq->scsiq_rptr = req_paddr;\n\n\t/*\n\t * Every ADV_CARR_T.carr_pa is byte swapped to little-endian\n\t * order during initialization.\n\t */\n\tscsiq->carr_pa = sc->icq_sp->carr_pa;\n\tscsiq->carr_va = sc->icq_sp->carr_pa;\n\n\t/*\n\t * Use the current stopper to send the ADW_SCSI_REQ_Q command to\n\t * the microcode. The newly allocated stopper will become the new\n\t * stopper.\n\t */\n\tsc->icq_sp->areq_vpa = req_paddr;\n\n\t/*\n\t * Set the 'next_vpa' pointer for the old stopper to be the\n\t * physical address of the new stopper. The RISC can only\n\t * follow physical addresses.\n\t */\n\tsc->icq_sp->next_vpa = new_carrp->carr_pa;\n\n\t/*\n\t * Set the host adapter stopper pointer to point to the new carrier.\n\t */\n\tsc->icq_sp = new_carrp;\n\n/*\tccb_carr = ccb->carr_list;\n\twhile(ccb_carr != ASC_CQ_STOPPER) {\n\t\tbus_dmamap_load(sc->sc_dmat, ccb_carr->dmamap_xfer,\n\t\t\t\tccb_carr, ADW_CARRIER_SIZE,\n\t\t\t\tNULL, BUS_DMA_NOWAIT);\n\t\tbus_dmamap_sync(sc->sc_dmat, ccb_carr->dmamap_xfer, 0,\n\t\t\t\tccb_carr->dmamap_xfer->dm_mapsize,\n\t\t\t\tBUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);\n\t\tccb_carr = adw_carrier_phys_kv(sc,\n\t\t\t\tASC_GET_CARRP(ccb_carr->next_vpa));\n\t}\n\n\tccb_carr = sc->irq_sp;\n\tfor(i=0; i<2 && ccb_carr != ASC_CQ_STOPPER; i++) {\n\t\tbus_dmamap_load(sc->sc_dmat, ccb_carr->dmamap_xfer,\n\t\t\t\tccb_carr, ADW_CARRIER_SIZE,\n\t\t\t\tNULL, BUS_DMA_NOWAIT);\n\t\tbus_dmamap_sync(sc->sc_dmat, ccb_carr->dmamap_xfer, 0,\n\t\t\t\tccb_carr->dmamap_xfer->dm_mapsize,\n\t\t\t\tBUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);\n\t\tccb_carr = adw_carrier_phys_kv(sc,\n\t\t\t\tASC_GET_CARRP(ccb_carr->next_vpa));\n\t}\n*/\n\tbus_dmamap_load(sc->sc_dmat, sc->sc_control->dmamap_xfer,\n\t\t\tsc->sc_control->carriers, ADW_CARRIER_SIZE * ADW_MAX_CARRIER,\n\t\t\tNULL, BUS_DMA_NOWAIT);\n\tbus_dmamap_sync(sc->sc_dmat, sc->sc_control->dmamap_xfer,\n\t\t\tBUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);\n\n\t/*\n\t * Tickle the RISC to tell it to read its Command Queue Head pointer.\n\t */\n\tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_TICKLE, ADV_TICKLE_A);\n\tif (sc->chip_type == ADV_CHIP_ASC3550)\n\t{\n\t\t/*\n\t\t * Clear the tickle value. In the ASC-3550 the RISC flag\n\t\t * command 'clr_tickle_a' does not work unless the host\n\t\t * value is cleared.\n\t\t */\n\t\tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_TICKLE, ADV_TICKLE_NOP);\n\t}\n\n\treturn ADW_SUCCESS;\n}"
  },
  {
    "function_name": "AdvSet38C0800EEPConfig",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adwlib.c",
    "lines": "1802-1856",
    "snippet": "static void\nAdvSet38C0800EEPConfig(iot, ioh, cfg_buf)\n\tbus_space_tag_t\t\tiot;\n\tbus_space_handle_t\tioh;\n\tADW_EEP_38C0800_CONFIG\t*cfg_buf;\n{\n\tu_int16_t *wbuf;\n\tu_int16_t addr, chksum;\n\n\n\twbuf = (u_int16_t *) cfg_buf;\n\tchksum = 0;\n\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_CMD, ASC_EEP_CMD_WRITE_ABLE);\n\tAdvWaitEEPCmd(iot, ioh);\n\n\t/*\n\t * Write EEPROM from word 0 to word 20\n\t */\n\tfor (addr = ASC_EEP_DVC_CFG_BEGIN;\n\t     addr < ASC_EEP_DVC_CFG_END; addr++, wbuf++) {\n\t\tchksum += *wbuf;\n\t\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_DATA, *wbuf);\n\t\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_CMD,\n\t\t\t\tASC_EEP_CMD_WRITE | addr);\n\t\tAdvWaitEEPCmd(iot, ioh);\n\t\tAdvSleepMilliSecond(ASC_EEP_DELAY_MS);\n\t}\n\n\t/*\n\t * Write EEPROM checksum at word 21\n\t */\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_DATA, chksum);\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_CMD,\n\t\t\tASC_EEP_CMD_WRITE | addr);\n\tAdvWaitEEPCmd(iot, ioh);\n\twbuf++;        /* skip over check_sum */\n\n\t/*\n\t * Write EEPROM OEM name at words 22 to 29\n\t */\n\tfor (addr = ASC_EEP_DVC_CTL_BEGIN;\n\t     addr < ASC_EEP_MAX_WORD_ADDR; addr++, wbuf++) {\n\t\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_DATA, *wbuf);\n\t\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_CMD,\n\t\t\t\tASC_EEP_CMD_WRITE | addr);\n\t\tAdvWaitEEPCmd(iot, ioh);\n\t}\n\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_CMD,\n\t\t\tASC_EEP_CMD_WRITE_DISABLE);\n\tAdvWaitEEPCmd(iot, ioh);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/ic/adwmcode.h>",
      "#include <dev/ic/adw.h>",
      "#include <dev/ic/adwlib.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/queue.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void AdvWaitEEPCmd",
      "static void AdvSet38C0800EEPConfig",
      "static void AdvSleepMilliSecond",
      "bus_space_tag_t iot = sc->sc_iot;",
      "bus_space_handle_t ioh = sc->sc_ioh;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "AdvWaitEEPCmd",
          "args": [
            "iot",
            "ioh"
          ],
          "line": 1853
        },
        "resolved": true,
        "details": {
          "function_name": "AdvWaitEEPCmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adwlib.c",
          "lines": "1719-1736",
          "snippet": "static void\nAdvWaitEEPCmd(iot, ioh)\n\tbus_space_tag_t\t\tiot;\n\tbus_space_handle_t\tioh;\n{\n\tint eep_delay_ms;\n\n\n\tfor (eep_delay_ms = 0; eep_delay_ms < ASC_EEP_DELAY_MS; eep_delay_ms++){\n\t\tif (ADW_READ_WORD_REGISTER(iot, ioh, IOPW_EE_CMD) &\n\t\t\t\tASC_EEP_CMD_DONE) {\n\t\t\tbreak;\n\t\t}\n\t\tAdvSleepMilliSecond(1);\n\t}\n\n\tADW_READ_WORD_REGISTER(iot, ioh, IOPW_EE_CMD);\n}",
          "includes": [
            "#include <dev/ic/adwmcode.h>",
            "#include <dev/ic/adw.h>",
            "#include <dev/ic/adwlib.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/queue.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void AdvWaitEEPCmd",
            "static void AdvSleepMilliSecond",
            "bus_space_tag_t iot = sc->sc_iot;",
            "bus_space_handle_t ioh = sc->sc_ioh;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/adwmcode.h>\n#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void AdvWaitEEPCmd;\nstatic void AdvSleepMilliSecond;\nbus_space_tag_t iot = sc->sc_iot;\nbus_space_handle_t ioh = sc->sc_ioh;\n\nstatic void\nAdvWaitEEPCmd(iot, ioh)\n\tbus_space_tag_t\t\tiot;\n\tbus_space_handle_t\tioh;\n{\n\tint eep_delay_ms;\n\n\n\tfor (eep_delay_ms = 0; eep_delay_ms < ASC_EEP_DELAY_MS; eep_delay_ms++){\n\t\tif (ADW_READ_WORD_REGISTER(iot, ioh, IOPW_EE_CMD) &\n\t\t\t\tASC_EEP_CMD_DONE) {\n\t\t\tbreak;\n\t\t}\n\t\tAdvSleepMilliSecond(1);\n\t}\n\n\tADW_READ_WORD_REGISTER(iot, ioh, IOPW_EE_CMD);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_REGISTER",
          "args": [
            "iot",
            "ioh",
            "IOPW_EE_CMD",
            "ASC_EEP_CMD_WRITE_DISABLE"
          ],
          "line": 1851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_REGISTER",
          "args": [
            "iot",
            "ioh",
            "IOPW_EE_CMD",
            "ASC_EEP_CMD_WRITE | addr"
          ],
          "line": 1846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_REGISTER",
          "args": [
            "iot",
            "ioh",
            "IOPW_EE_DATA",
            "*wbuf"
          ],
          "line": 1845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_REGISTER",
          "args": [
            "iot",
            "ioh",
            "IOPW_EE_CMD",
            "ASC_EEP_CMD_WRITE | addr"
          ],
          "line": 1835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_REGISTER",
          "args": [
            "iot",
            "ioh",
            "IOPW_EE_DATA",
            "chksum"
          ],
          "line": 1834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AdvSleepMilliSecond",
          "args": [
            "ASC_EEP_DELAY_MS"
          ],
          "line": 1828
        },
        "resolved": true,
        "details": {
          "function_name": "AdvSleepMilliSecond",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adwlib.c",
          "lines": "2552-2558",
          "snippet": "static void\nAdvSleepMilliSecond(n)\nu_int32_t\tn;\n{\n\n\tDELAY(n * 1000);\n}",
          "includes": [
            "#include <dev/ic/adwmcode.h>",
            "#include <dev/ic/adw.h>",
            "#include <dev/ic/adwlib.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/queue.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void AdvSleepMilliSecond"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/adwmcode.h>\n#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void AdvSleepMilliSecond;\n\nstatic void\nAdvSleepMilliSecond(n)\nu_int32_t\tn;\n{\n\n\tDELAY(n * 1000);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_REGISTER",
          "args": [
            "iot",
            "ioh",
            "IOPW_EE_CMD",
            "ASC_EEP_CMD_WRITE | addr"
          ],
          "line": 1825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_REGISTER",
          "args": [
            "iot",
            "ioh",
            "IOPW_EE_DATA",
            "*wbuf"
          ],
          "line": 1824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_REGISTER",
          "args": [
            "iot",
            "ioh",
            "IOPW_EE_CMD",
            "ASC_EEP_CMD_WRITE_ABLE"
          ],
          "line": 1815
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/adwmcode.h>\n#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void AdvWaitEEPCmd;\nstatic void AdvSet38C0800EEPConfig;\nstatic void AdvSleepMilliSecond;\nbus_space_tag_t iot = sc->sc_iot;\nbus_space_handle_t ioh = sc->sc_ioh;\n\nstatic void\nAdvSet38C0800EEPConfig(iot, ioh, cfg_buf)\n\tbus_space_tag_t\t\tiot;\n\tbus_space_handle_t\tioh;\n\tADW_EEP_38C0800_CONFIG\t*cfg_buf;\n{\n\tu_int16_t *wbuf;\n\tu_int16_t addr, chksum;\n\n\n\twbuf = (u_int16_t *) cfg_buf;\n\tchksum = 0;\n\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_CMD, ASC_EEP_CMD_WRITE_ABLE);\n\tAdvWaitEEPCmd(iot, ioh);\n\n\t/*\n\t * Write EEPROM from word 0 to word 20\n\t */\n\tfor (addr = ASC_EEP_DVC_CFG_BEGIN;\n\t     addr < ASC_EEP_DVC_CFG_END; addr++, wbuf++) {\n\t\tchksum += *wbuf;\n\t\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_DATA, *wbuf);\n\t\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_CMD,\n\t\t\t\tASC_EEP_CMD_WRITE | addr);\n\t\tAdvWaitEEPCmd(iot, ioh);\n\t\tAdvSleepMilliSecond(ASC_EEP_DELAY_MS);\n\t}\n\n\t/*\n\t * Write EEPROM checksum at word 21\n\t */\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_DATA, chksum);\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_CMD,\n\t\t\tASC_EEP_CMD_WRITE | addr);\n\tAdvWaitEEPCmd(iot, ioh);\n\twbuf++;        /* skip over check_sum */\n\n\t/*\n\t * Write EEPROM OEM name at words 22 to 29\n\t */\n\tfor (addr = ASC_EEP_DVC_CTL_BEGIN;\n\t     addr < ASC_EEP_MAX_WORD_ADDR; addr++, wbuf++) {\n\t\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_DATA, *wbuf);\n\t\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_CMD,\n\t\t\t\tASC_EEP_CMD_WRITE | addr);\n\t\tAdvWaitEEPCmd(iot, ioh);\n\t}\n\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_CMD,\n\t\t\tASC_EEP_CMD_WRITE_DISABLE);\n\tAdvWaitEEPCmd(iot, ioh);\n\n\treturn;\n}"
  },
  {
    "function_name": "AdvSet3550EEPConfig",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adwlib.c",
    "lines": "1742-1796",
    "snippet": "static void\nAdvSet3550EEPConfig(iot, ioh, cfg_buf)\n\tbus_space_tag_t\t\tiot;\n\tbus_space_handle_t\tioh;\n\tADW_EEP_3550_CONFIG\t*cfg_buf;\n{\n\tu_int16_t *wbuf;\n\tu_int16_t addr, chksum;\n\n\n\twbuf = (u_int16_t *) cfg_buf;\n\tchksum = 0;\n\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_CMD, ASC_EEP_CMD_WRITE_ABLE);\n\tAdvWaitEEPCmd(iot, ioh);\n\n\t/*\n\t * Write EEPROM from word 0 to word 20\n\t */\n\tfor (addr = ASC_EEP_DVC_CFG_BEGIN;\n\t     addr < ASC_EEP_DVC_CFG_END; addr++, wbuf++) {\n\t\tchksum += *wbuf;\n\t\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_DATA, *wbuf);\n\t\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_CMD,\n\t\t\t\tASC_EEP_CMD_WRITE | addr);\n\t\tAdvWaitEEPCmd(iot, ioh);\n\t\tAdvSleepMilliSecond(ASC_EEP_DELAY_MS);\n\t}\n\n\t/*\n\t * Write EEPROM checksum at word 21\n\t */\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_DATA, chksum);\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_CMD,\n\t\t\tASC_EEP_CMD_WRITE | addr);\n\tAdvWaitEEPCmd(iot, ioh);\n\twbuf++;        /* skip over check_sum */\n\n\t/*\n\t * Write EEPROM OEM name at words 22 to 29\n\t */\n\tfor (addr = ASC_EEP_DVC_CTL_BEGIN;\n\t     addr < ASC_EEP_MAX_WORD_ADDR; addr++, wbuf++) {\n\t\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_DATA, *wbuf);\n\t\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_CMD,\n\t\t\t\tASC_EEP_CMD_WRITE | addr);\n\t\tAdvWaitEEPCmd(iot, ioh);\n\t}\n\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_CMD,\n\t\t\tASC_EEP_CMD_WRITE_DISABLE);\n\tAdvWaitEEPCmd(iot, ioh);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/ic/adwmcode.h>",
      "#include <dev/ic/adw.h>",
      "#include <dev/ic/adwlib.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/queue.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void AdvWaitEEPCmd",
      "static void AdvSet3550EEPConfig",
      "static void AdvSleepMilliSecond",
      "bus_space_tag_t iot = sc->sc_iot;",
      "bus_space_handle_t ioh = sc->sc_ioh;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "AdvWaitEEPCmd",
          "args": [
            "iot",
            "ioh"
          ],
          "line": 1793
        },
        "resolved": true,
        "details": {
          "function_name": "AdvWaitEEPCmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adwlib.c",
          "lines": "1719-1736",
          "snippet": "static void\nAdvWaitEEPCmd(iot, ioh)\n\tbus_space_tag_t\t\tiot;\n\tbus_space_handle_t\tioh;\n{\n\tint eep_delay_ms;\n\n\n\tfor (eep_delay_ms = 0; eep_delay_ms < ASC_EEP_DELAY_MS; eep_delay_ms++){\n\t\tif (ADW_READ_WORD_REGISTER(iot, ioh, IOPW_EE_CMD) &\n\t\t\t\tASC_EEP_CMD_DONE) {\n\t\t\tbreak;\n\t\t}\n\t\tAdvSleepMilliSecond(1);\n\t}\n\n\tADW_READ_WORD_REGISTER(iot, ioh, IOPW_EE_CMD);\n}",
          "includes": [
            "#include <dev/ic/adwmcode.h>",
            "#include <dev/ic/adw.h>",
            "#include <dev/ic/adwlib.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/queue.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void AdvWaitEEPCmd",
            "static void AdvSleepMilliSecond",
            "bus_space_tag_t iot = sc->sc_iot;",
            "bus_space_handle_t ioh = sc->sc_ioh;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/adwmcode.h>\n#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void AdvWaitEEPCmd;\nstatic void AdvSleepMilliSecond;\nbus_space_tag_t iot = sc->sc_iot;\nbus_space_handle_t ioh = sc->sc_ioh;\n\nstatic void\nAdvWaitEEPCmd(iot, ioh)\n\tbus_space_tag_t\t\tiot;\n\tbus_space_handle_t\tioh;\n{\n\tint eep_delay_ms;\n\n\n\tfor (eep_delay_ms = 0; eep_delay_ms < ASC_EEP_DELAY_MS; eep_delay_ms++){\n\t\tif (ADW_READ_WORD_REGISTER(iot, ioh, IOPW_EE_CMD) &\n\t\t\t\tASC_EEP_CMD_DONE) {\n\t\t\tbreak;\n\t\t}\n\t\tAdvSleepMilliSecond(1);\n\t}\n\n\tADW_READ_WORD_REGISTER(iot, ioh, IOPW_EE_CMD);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_REGISTER",
          "args": [
            "iot",
            "ioh",
            "IOPW_EE_CMD",
            "ASC_EEP_CMD_WRITE_DISABLE"
          ],
          "line": 1791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_REGISTER",
          "args": [
            "iot",
            "ioh",
            "IOPW_EE_CMD",
            "ASC_EEP_CMD_WRITE | addr"
          ],
          "line": 1786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_REGISTER",
          "args": [
            "iot",
            "ioh",
            "IOPW_EE_DATA",
            "*wbuf"
          ],
          "line": 1785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_REGISTER",
          "args": [
            "iot",
            "ioh",
            "IOPW_EE_CMD",
            "ASC_EEP_CMD_WRITE | addr"
          ],
          "line": 1775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_REGISTER",
          "args": [
            "iot",
            "ioh",
            "IOPW_EE_DATA",
            "chksum"
          ],
          "line": 1774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AdvSleepMilliSecond",
          "args": [
            "ASC_EEP_DELAY_MS"
          ],
          "line": 1768
        },
        "resolved": true,
        "details": {
          "function_name": "AdvSleepMilliSecond",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adwlib.c",
          "lines": "2552-2558",
          "snippet": "static void\nAdvSleepMilliSecond(n)\nu_int32_t\tn;\n{\n\n\tDELAY(n * 1000);\n}",
          "includes": [
            "#include <dev/ic/adwmcode.h>",
            "#include <dev/ic/adw.h>",
            "#include <dev/ic/adwlib.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/queue.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void AdvSleepMilliSecond"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/adwmcode.h>\n#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void AdvSleepMilliSecond;\n\nstatic void\nAdvSleepMilliSecond(n)\nu_int32_t\tn;\n{\n\n\tDELAY(n * 1000);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_REGISTER",
          "args": [
            "iot",
            "ioh",
            "IOPW_EE_CMD",
            "ASC_EEP_CMD_WRITE | addr"
          ],
          "line": 1765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_REGISTER",
          "args": [
            "iot",
            "ioh",
            "IOPW_EE_DATA",
            "*wbuf"
          ],
          "line": 1764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_REGISTER",
          "args": [
            "iot",
            "ioh",
            "IOPW_EE_CMD",
            "ASC_EEP_CMD_WRITE_ABLE"
          ],
          "line": 1755
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/adwmcode.h>\n#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void AdvWaitEEPCmd;\nstatic void AdvSet3550EEPConfig;\nstatic void AdvSleepMilliSecond;\nbus_space_tag_t iot = sc->sc_iot;\nbus_space_handle_t ioh = sc->sc_ioh;\n\nstatic void\nAdvSet3550EEPConfig(iot, ioh, cfg_buf)\n\tbus_space_tag_t\t\tiot;\n\tbus_space_handle_t\tioh;\n\tADW_EEP_3550_CONFIG\t*cfg_buf;\n{\n\tu_int16_t *wbuf;\n\tu_int16_t addr, chksum;\n\n\n\twbuf = (u_int16_t *) cfg_buf;\n\tchksum = 0;\n\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_CMD, ASC_EEP_CMD_WRITE_ABLE);\n\tAdvWaitEEPCmd(iot, ioh);\n\n\t/*\n\t * Write EEPROM from word 0 to word 20\n\t */\n\tfor (addr = ASC_EEP_DVC_CFG_BEGIN;\n\t     addr < ASC_EEP_DVC_CFG_END; addr++, wbuf++) {\n\t\tchksum += *wbuf;\n\t\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_DATA, *wbuf);\n\t\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_CMD,\n\t\t\t\tASC_EEP_CMD_WRITE | addr);\n\t\tAdvWaitEEPCmd(iot, ioh);\n\t\tAdvSleepMilliSecond(ASC_EEP_DELAY_MS);\n\t}\n\n\t/*\n\t * Write EEPROM checksum at word 21\n\t */\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_DATA, chksum);\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_CMD,\n\t\t\tASC_EEP_CMD_WRITE | addr);\n\tAdvWaitEEPCmd(iot, ioh);\n\twbuf++;        /* skip over check_sum */\n\n\t/*\n\t * Write EEPROM OEM name at words 22 to 29\n\t */\n\tfor (addr = ASC_EEP_DVC_CTL_BEGIN;\n\t     addr < ASC_EEP_MAX_WORD_ADDR; addr++, wbuf++) {\n\t\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_DATA, *wbuf);\n\t\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_CMD,\n\t\t\t\tASC_EEP_CMD_WRITE | addr);\n\t\tAdvWaitEEPCmd(iot, ioh);\n\t}\n\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_CMD,\n\t\t\tASC_EEP_CMD_WRITE_DISABLE);\n\tAdvWaitEEPCmd(iot, ioh);\n\n\treturn;\n}"
  },
  {
    "function_name": "AdvWaitEEPCmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adwlib.c",
    "lines": "1719-1736",
    "snippet": "static void\nAdvWaitEEPCmd(iot, ioh)\n\tbus_space_tag_t\t\tiot;\n\tbus_space_handle_t\tioh;\n{\n\tint eep_delay_ms;\n\n\n\tfor (eep_delay_ms = 0; eep_delay_ms < ASC_EEP_DELAY_MS; eep_delay_ms++){\n\t\tif (ADW_READ_WORD_REGISTER(iot, ioh, IOPW_EE_CMD) &\n\t\t\t\tASC_EEP_CMD_DONE) {\n\t\t\tbreak;\n\t\t}\n\t\tAdvSleepMilliSecond(1);\n\t}\n\n\tADW_READ_WORD_REGISTER(iot, ioh, IOPW_EE_CMD);\n}",
    "includes": [
      "#include <dev/ic/adwmcode.h>",
      "#include <dev/ic/adw.h>",
      "#include <dev/ic/adwlib.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/queue.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void AdvWaitEEPCmd",
      "static void AdvSleepMilliSecond",
      "bus_space_tag_t iot = sc->sc_iot;",
      "bus_space_handle_t ioh = sc->sc_ioh;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ADW_READ_WORD_REGISTER",
          "args": [
            "iot",
            "ioh",
            "IOPW_EE_CMD"
          ],
          "line": 1735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AdvSleepMilliSecond",
          "args": [
            "1"
          ],
          "line": 1732
        },
        "resolved": true,
        "details": {
          "function_name": "AdvSleepMilliSecond",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adwlib.c",
          "lines": "2552-2558",
          "snippet": "static void\nAdvSleepMilliSecond(n)\nu_int32_t\tn;\n{\n\n\tDELAY(n * 1000);\n}",
          "includes": [
            "#include <dev/ic/adwmcode.h>",
            "#include <dev/ic/adw.h>",
            "#include <dev/ic/adwlib.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/queue.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void AdvSleepMilliSecond"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/adwmcode.h>\n#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void AdvSleepMilliSecond;\n\nstatic void\nAdvSleepMilliSecond(n)\nu_int32_t\tn;\n{\n\n\tDELAY(n * 1000);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ADW_READ_WORD_REGISTER",
          "args": [
            "iot",
            "ioh",
            "IOPW_EE_CMD"
          ],
          "line": 1728
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/adwmcode.h>\n#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void AdvWaitEEPCmd;\nstatic void AdvSleepMilliSecond;\nbus_space_tag_t iot = sc->sc_iot;\nbus_space_handle_t ioh = sc->sc_ioh;\n\nstatic void\nAdvWaitEEPCmd(iot, ioh)\n\tbus_space_tag_t\t\tiot;\n\tbus_space_handle_t\tioh;\n{\n\tint eep_delay_ms;\n\n\n\tfor (eep_delay_ms = 0; eep_delay_ms < ASC_EEP_DELAY_MS; eep_delay_ms++){\n\t\tif (ADW_READ_WORD_REGISTER(iot, ioh, IOPW_EE_CMD) &\n\t\t\t\tASC_EEP_CMD_DONE) {\n\t\t\tbreak;\n\t\t}\n\t\tAdvSleepMilliSecond(1);\n\t}\n\n\tADW_READ_WORD_REGISTER(iot, ioh, IOPW_EE_CMD);\n}"
  },
  {
    "function_name": "AdvReadEEPWord",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adwlib.c",
    "lines": "1702-1713",
    "snippet": "static u_int16_t\nAdvReadEEPWord(iot, ioh, eep_word_addr)\n\tbus_space_tag_t\t\tiot;\n\tbus_space_handle_t\tioh;\n\tint\t\t\teep_word_addr;\n{\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_CMD,\n\t\tASC_EEP_CMD_READ | eep_word_addr);\n\tAdvWaitEEPCmd(iot, ioh);\n\n\treturn ADW_READ_WORD_REGISTER(iot, ioh, IOPW_EE_DATA);\n}",
    "includes": [
      "#include <dev/ic/adwmcode.h>",
      "#include <dev/ic/adw.h>",
      "#include <dev/ic/adwlib.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/queue.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u_int16_t AdvReadEEPWord",
      "static void AdvWaitEEPCmd",
      "bus_space_tag_t iot = sc->sc_iot;",
      "bus_space_handle_t ioh = sc->sc_ioh;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ADW_READ_WORD_REGISTER",
          "args": [
            "iot",
            "ioh",
            "IOPW_EE_DATA"
          ],
          "line": 1712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AdvWaitEEPCmd",
          "args": [
            "iot",
            "ioh"
          ],
          "line": 1710
        },
        "resolved": true,
        "details": {
          "function_name": "AdvWaitEEPCmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adwlib.c",
          "lines": "1719-1736",
          "snippet": "static void\nAdvWaitEEPCmd(iot, ioh)\n\tbus_space_tag_t\t\tiot;\n\tbus_space_handle_t\tioh;\n{\n\tint eep_delay_ms;\n\n\n\tfor (eep_delay_ms = 0; eep_delay_ms < ASC_EEP_DELAY_MS; eep_delay_ms++){\n\t\tif (ADW_READ_WORD_REGISTER(iot, ioh, IOPW_EE_CMD) &\n\t\t\t\tASC_EEP_CMD_DONE) {\n\t\t\tbreak;\n\t\t}\n\t\tAdvSleepMilliSecond(1);\n\t}\n\n\tADW_READ_WORD_REGISTER(iot, ioh, IOPW_EE_CMD);\n}",
          "includes": [
            "#include <dev/ic/adwmcode.h>",
            "#include <dev/ic/adw.h>",
            "#include <dev/ic/adwlib.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/queue.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void AdvWaitEEPCmd",
            "static void AdvSleepMilliSecond",
            "bus_space_tag_t iot = sc->sc_iot;",
            "bus_space_handle_t ioh = sc->sc_ioh;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/adwmcode.h>\n#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void AdvWaitEEPCmd;\nstatic void AdvSleepMilliSecond;\nbus_space_tag_t iot = sc->sc_iot;\nbus_space_handle_t ioh = sc->sc_ioh;\n\nstatic void\nAdvWaitEEPCmd(iot, ioh)\n\tbus_space_tag_t\t\tiot;\n\tbus_space_handle_t\tioh;\n{\n\tint eep_delay_ms;\n\n\n\tfor (eep_delay_ms = 0; eep_delay_ms < ASC_EEP_DELAY_MS; eep_delay_ms++){\n\t\tif (ADW_READ_WORD_REGISTER(iot, ioh, IOPW_EE_CMD) &\n\t\t\t\tASC_EEP_CMD_DONE) {\n\t\t\tbreak;\n\t\t}\n\t\tAdvSleepMilliSecond(1);\n\t}\n\n\tADW_READ_WORD_REGISTER(iot, ioh, IOPW_EE_CMD);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_REGISTER",
          "args": [
            "iot",
            "ioh",
            "IOPW_EE_CMD",
            "ASC_EEP_CMD_READ | eep_word_addr"
          ],
          "line": 1708
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/adwmcode.h>\n#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic u_int16_t AdvReadEEPWord;\nstatic void AdvWaitEEPCmd;\nbus_space_tag_t iot = sc->sc_iot;\nbus_space_handle_t ioh = sc->sc_ioh;\n\nstatic u_int16_t\nAdvReadEEPWord(iot, ioh, eep_word_addr)\n\tbus_space_tag_t\t\tiot;\n\tbus_space_handle_t\tioh;\n\tint\t\t\teep_word_addr;\n{\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_CMD,\n\t\tASC_EEP_CMD_READ | eep_word_addr);\n\tAdvWaitEEPCmd(iot, ioh);\n\n\treturn ADW_READ_WORD_REGISTER(iot, ioh, IOPW_EE_DATA);\n}"
  },
  {
    "function_name": "AdvGet38C0800EEPConfig",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adwlib.c",
    "lines": "1665-1696",
    "snippet": "static u_int16_t\nAdvGet38C0800EEPConfig(iot, ioh, cfg_buf)\n\tbus_space_tag_t\t\tiot;\n\tbus_space_handle_t\tioh;\n\tADW_EEP_38C0800_CONFIG\t*cfg_buf;\n{\n\tu_int16_t\twval, chksum;\n\tu_int16_t\t*wbuf;\n\tint\t\teep_addr;\n\n\n\twbuf = (u_int16_t *) cfg_buf;\n\tchksum = 0;\n\n\tfor (eep_addr = ASC_EEP_DVC_CFG_BEGIN;\n\t\t\teep_addr < ASC_EEP_DVC_CFG_END;\n\t\t\teep_addr++, wbuf++) {\n\t\twval = AdvReadEEPWord(iot, ioh, eep_addr);\n\t\tchksum += wval;\n\t\t*wbuf = wval;\n\t}\n\n\t*wbuf = AdvReadEEPWord(iot, ioh, eep_addr);\n\twbuf++;\n\tfor (eep_addr = ASC_EEP_DVC_CTL_BEGIN;\n\t\t\teep_addr < ASC_EEP_MAX_WORD_ADDR;\n\t\t\teep_addr++, wbuf++) {\n\t\t*wbuf = AdvReadEEPWord(iot, ioh, eep_addr);\n\t}\n\n\treturn chksum;\n}",
    "includes": [
      "#include <dev/ic/adwmcode.h>",
      "#include <dev/ic/adw.h>",
      "#include <dev/ic/adwlib.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/queue.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u_int16_t AdvGet38C0800EEPConfig",
      "static u_int16_t AdvReadEEPWord",
      "bus_space_tag_t iot = sc->sc_iot;",
      "bus_space_handle_t ioh = sc->sc_ioh;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "AdvReadEEPWord",
          "args": [
            "iot",
            "ioh",
            "eep_addr"
          ],
          "line": 1692
        },
        "resolved": true,
        "details": {
          "function_name": "AdvReadEEPWord",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adwlib.c",
          "lines": "1702-1713",
          "snippet": "static u_int16_t\nAdvReadEEPWord(iot, ioh, eep_word_addr)\n\tbus_space_tag_t\t\tiot;\n\tbus_space_handle_t\tioh;\n\tint\t\t\teep_word_addr;\n{\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_CMD,\n\t\tASC_EEP_CMD_READ | eep_word_addr);\n\tAdvWaitEEPCmd(iot, ioh);\n\n\treturn ADW_READ_WORD_REGISTER(iot, ioh, IOPW_EE_DATA);\n}",
          "includes": [
            "#include <dev/ic/adwmcode.h>",
            "#include <dev/ic/adw.h>",
            "#include <dev/ic/adwlib.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/queue.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u_int16_t AdvReadEEPWord",
            "static void AdvWaitEEPCmd",
            "bus_space_tag_t iot = sc->sc_iot;",
            "bus_space_handle_t ioh = sc->sc_ioh;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/adwmcode.h>\n#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic u_int16_t AdvReadEEPWord;\nstatic void AdvWaitEEPCmd;\nbus_space_tag_t iot = sc->sc_iot;\nbus_space_handle_t ioh = sc->sc_ioh;\n\nstatic u_int16_t\nAdvReadEEPWord(iot, ioh, eep_word_addr)\n\tbus_space_tag_t\t\tiot;\n\tbus_space_handle_t\tioh;\n\tint\t\t\teep_word_addr;\n{\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_CMD,\n\t\tASC_EEP_CMD_READ | eep_word_addr);\n\tAdvWaitEEPCmd(iot, ioh);\n\n\treturn ADW_READ_WORD_REGISTER(iot, ioh, IOPW_EE_DATA);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/adwmcode.h>\n#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic u_int16_t AdvGet38C0800EEPConfig;\nstatic u_int16_t AdvReadEEPWord;\nbus_space_tag_t iot = sc->sc_iot;\nbus_space_handle_t ioh = sc->sc_ioh;\n\nstatic u_int16_t\nAdvGet38C0800EEPConfig(iot, ioh, cfg_buf)\n\tbus_space_tag_t\t\tiot;\n\tbus_space_handle_t\tioh;\n\tADW_EEP_38C0800_CONFIG\t*cfg_buf;\n{\n\tu_int16_t\twval, chksum;\n\tu_int16_t\t*wbuf;\n\tint\t\teep_addr;\n\n\n\twbuf = (u_int16_t *) cfg_buf;\n\tchksum = 0;\n\n\tfor (eep_addr = ASC_EEP_DVC_CFG_BEGIN;\n\t\t\teep_addr < ASC_EEP_DVC_CFG_END;\n\t\t\teep_addr++, wbuf++) {\n\t\twval = AdvReadEEPWord(iot, ioh, eep_addr);\n\t\tchksum += wval;\n\t\t*wbuf = wval;\n\t}\n\n\t*wbuf = AdvReadEEPWord(iot, ioh, eep_addr);\n\twbuf++;\n\tfor (eep_addr = ASC_EEP_DVC_CTL_BEGIN;\n\t\t\teep_addr < ASC_EEP_MAX_WORD_ADDR;\n\t\t\teep_addr++, wbuf++) {\n\t\t*wbuf = AdvReadEEPWord(iot, ioh, eep_addr);\n\t}\n\n\treturn chksum;\n}"
  },
  {
    "function_name": "AdvGet3550EEPConfig",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adwlib.c",
    "lines": "1626-1657",
    "snippet": "static u_int16_t\nAdvGet3550EEPConfig(iot, ioh, cfg_buf)\n\tbus_space_tag_t\t\tiot;\n\tbus_space_handle_t\tioh;\n\tADW_EEP_3550_CONFIG\t*cfg_buf;\n{\n\tu_int16_t\t       wval, chksum;\n\tu_int16_t\t       *wbuf;\n\tint\t\t    eep_addr;\n\n\n\twbuf = (u_int16_t *) cfg_buf;\n\tchksum = 0;\n\n\tfor (eep_addr = ASC_EEP_DVC_CFG_BEGIN;\n\t\t\teep_addr < ASC_EEP_DVC_CFG_END;\n\t\t\teep_addr++, wbuf++) {\n\t\twval = AdvReadEEPWord(iot, ioh, eep_addr);\n\t\tchksum += wval;\n\t\t*wbuf = wval;\n\t}\n\n\t*wbuf = AdvReadEEPWord(iot, ioh, eep_addr);\n\twbuf++;\n\tfor (eep_addr = ASC_EEP_DVC_CTL_BEGIN;\n\t\t\teep_addr < ASC_EEP_MAX_WORD_ADDR;\n\t\t\teep_addr++, wbuf++) {\n\t\t*wbuf = AdvReadEEPWord(iot, ioh, eep_addr);\n\t}\n\n\treturn chksum;\n}",
    "includes": [
      "#include <dev/ic/adwmcode.h>",
      "#include <dev/ic/adw.h>",
      "#include <dev/ic/adwlib.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/queue.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u_int16_t AdvGet3550EEPConfig",
      "static u_int16_t AdvReadEEPWord",
      "bus_space_tag_t iot = sc->sc_iot;",
      "bus_space_handle_t ioh = sc->sc_ioh;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "AdvReadEEPWord",
          "args": [
            "iot",
            "ioh",
            "eep_addr"
          ],
          "line": 1653
        },
        "resolved": true,
        "details": {
          "function_name": "AdvReadEEPWord",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adwlib.c",
          "lines": "1702-1713",
          "snippet": "static u_int16_t\nAdvReadEEPWord(iot, ioh, eep_word_addr)\n\tbus_space_tag_t\t\tiot;\n\tbus_space_handle_t\tioh;\n\tint\t\t\teep_word_addr;\n{\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_CMD,\n\t\tASC_EEP_CMD_READ | eep_word_addr);\n\tAdvWaitEEPCmd(iot, ioh);\n\n\treturn ADW_READ_WORD_REGISTER(iot, ioh, IOPW_EE_DATA);\n}",
          "includes": [
            "#include <dev/ic/adwmcode.h>",
            "#include <dev/ic/adw.h>",
            "#include <dev/ic/adwlib.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/queue.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u_int16_t AdvReadEEPWord",
            "static void AdvWaitEEPCmd",
            "bus_space_tag_t iot = sc->sc_iot;",
            "bus_space_handle_t ioh = sc->sc_ioh;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/adwmcode.h>\n#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic u_int16_t AdvReadEEPWord;\nstatic void AdvWaitEEPCmd;\nbus_space_tag_t iot = sc->sc_iot;\nbus_space_handle_t ioh = sc->sc_ioh;\n\nstatic u_int16_t\nAdvReadEEPWord(iot, ioh, eep_word_addr)\n\tbus_space_tag_t\t\tiot;\n\tbus_space_handle_t\tioh;\n\tint\t\t\teep_word_addr;\n{\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_CMD,\n\t\tASC_EEP_CMD_READ | eep_word_addr);\n\tAdvWaitEEPCmd(iot, ioh);\n\n\treturn ADW_READ_WORD_REGISTER(iot, ioh, IOPW_EE_DATA);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/adwmcode.h>\n#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic u_int16_t AdvGet3550EEPConfig;\nstatic u_int16_t AdvReadEEPWord;\nbus_space_tag_t iot = sc->sc_iot;\nbus_space_handle_t ioh = sc->sc_ioh;\n\nstatic u_int16_t\nAdvGet3550EEPConfig(iot, ioh, cfg_buf)\n\tbus_space_tag_t\t\tiot;\n\tbus_space_handle_t\tioh;\n\tADW_EEP_3550_CONFIG\t*cfg_buf;\n{\n\tu_int16_t\t       wval, chksum;\n\tu_int16_t\t       *wbuf;\n\tint\t\t    eep_addr;\n\n\n\twbuf = (u_int16_t *) cfg_buf;\n\tchksum = 0;\n\n\tfor (eep_addr = ASC_EEP_DVC_CFG_BEGIN;\n\t\t\teep_addr < ASC_EEP_DVC_CFG_END;\n\t\t\teep_addr++, wbuf++) {\n\t\twval = AdvReadEEPWord(iot, ioh, eep_addr);\n\t\tchksum += wval;\n\t\t*wbuf = wval;\n\t}\n\n\t*wbuf = AdvReadEEPWord(iot, ioh, eep_addr);\n\twbuf++;\n\tfor (eep_addr = ASC_EEP_DVC_CTL_BEGIN;\n\t\t\teep_addr < ASC_EEP_MAX_WORD_ADDR;\n\t\t\teep_addr++, wbuf++) {\n\t\t*wbuf = AdvReadEEPWord(iot, ioh, eep_addr);\n\t}\n\n\treturn chksum;\n}"
  },
  {
    "function_name": "AdvInitFrom38C0800EEP",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adwlib.c",
    "lines": "1424-1618",
    "snippet": "int\nAdvInitFrom38C0800EEP(sc)\nADW_SOFTC      *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tu_int16_t\t\twarn_code;\n\tADW_EEP_38C0800_CONFIG\teep_config;\n\tint\t\t\ti;\n\tu_int8_t\t\ttid, termination;\n\tu_int16_t\t\tsdtr_speed = 0;\n\n\n\twarn_code = 0;\n\n\t/*\n\t * Read the board's EEPROM configuration.\n\t *\n\t * Set default values if a bad checksum is found.\n\t */\n\tif (AdvGet38C0800EEPConfig(iot, ioh, &eep_config) != \n\t\t\teep_config.check_sum) {\n\t\twarn_code |= ASC_WARN_EEPROM_CHKSUM;\n\n\t\t/*\n\t\t * Set EEPROM default values.\n\t\t */\n\t\tfor (i = 0; i < sizeof(ADW_EEP_38C0800_CONFIG); i++) {\n\t\t\t*((u_int8_t *) &eep_config + i) =\n\t\t\t\t*((u_int8_t *)&Default_38C0800_EEPROM_Config+i);\n\t\t}\n\n\t\t/*\n\t\t * Assume the 6 byte board serial number that was read\n\t\t * from EEPROM is correct even if the EEPROM checksum\n\t\t * failed.\n\t\t */\n\t\teep_config.serial_number_word3 =\n\t\t\tAdvReadEEPWord(iot, ioh, ASC_EEP_DVC_CFG_END - 1);\n\n\t\teep_config.serial_number_word2 =\n\t\t\tAdvReadEEPWord(iot, ioh, ASC_EEP_DVC_CFG_END - 2);\n\n\t\teep_config.serial_number_word1 =\n\t\t\tAdvReadEEPWord(iot, ioh, ASC_EEP_DVC_CFG_END - 3);\n\n\t\tAdvSet38C0800EEPConfig(iot, ioh, &eep_config);\n\t}\n\t/*\n\t * Set ADV_DVC_VAR and ADV_DVC_CFG variables from the\n\t * EEPROM configuration that was read.\n\t *\n\t * This is the mapping of EEPROM fields to Adv Library fields.\n\t */\n\tsc->wdtr_able = eep_config.wdtr_able;\n\tsc->sdtr_speed1 = eep_config.sdtr_speed1;\n\tsc->sdtr_speed2 = eep_config.sdtr_speed2;\n\tsc->sdtr_speed3 = eep_config.sdtr_speed3;\n\tsc->sdtr_speed4 = eep_config.sdtr_speed4;\n\tsc->tagqng_able = eep_config.tagqng_able;\n\tsc->cfg.disc_enable = eep_config.disc_enable;\n\tsc->max_host_qng = eep_config.max_host_qng;\n\tsc->max_dvc_qng = eep_config.max_dvc_qng;\n\tsc->chip_scsi_id = (eep_config.adapter_scsi_id & ADW_MAX_TID);\n\tsc->start_motor = eep_config.start_motor;\n\tsc->scsi_reset_wait = eep_config.scsi_reset_delay;\n\tsc->bios_ctrl = eep_config.bios_ctrl;\n\tsc->no_scam = eep_config.scam_tolerant;\n\tsc->cfg.serial1 = eep_config.serial_number_word1;\n\tsc->cfg.serial2 = eep_config.serial_number_word2;\n\tsc->cfg.serial3 = eep_config.serial_number_word3;\n\n\t/*\n\t * For every Target ID if any of its 'sdtr_speed[1234]' bits\n\t * are set, then set an 'sdtr_able' bit for it.\n\t */\n\tsc->sdtr_able = 0;\n\tfor (tid = 0; tid <= ADW_MAX_TID; tid++) {\n\t\tif (tid == 0) {\n\t\t\tsdtr_speed = sc->sdtr_speed1;\n\t\t} else if (tid == 4) {\n\t\t\tsdtr_speed = sc->sdtr_speed2;\n\t\t} else if (tid == 8) {\n\t\t\tsdtr_speed = sc->sdtr_speed3;\n\t\t} else if (tid == 12) {\n\t\t\tsdtr_speed = sc->sdtr_speed4;\n\t\t}\n\t\tif (sdtr_speed & ADW_MAX_TID) {\n\t\t\tsc->sdtr_able |= (1 << tid);\n\t\t}\n\t\tsdtr_speed >>= 4;\n\t}\n\n\t/*\n\t * Set the host maximum queuing (max. 253, min. 16) and the per device\n\t * maximum queuing (max. 63, min. 4).\n\t */\n\tif (eep_config.max_host_qng > ASC_DEF_MAX_HOST_QNG) {\n\t\teep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;\n\t} else if (eep_config.max_host_qng < ASC_DEF_MIN_HOST_QNG) {\n\t\t/* If the value is zero, assume it is uninitialized. */\n\t\tif (eep_config.max_host_qng == 0) {\n\t\t\teep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;\n\t\t} else {\n\t\t\teep_config.max_host_qng = ASC_DEF_MIN_HOST_QNG;\n\t\t}\n\t}\n\n\tif (eep_config.max_dvc_qng > ASC_DEF_MAX_DVC_QNG) {\n\t\teep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;\n\t} else if (eep_config.max_dvc_qng < ASC_DEF_MIN_DVC_QNG) {\n\t\t/* If the value is zero, assume it is uninitialized. */\n\t\tif (eep_config.max_dvc_qng == 0) {\n\t\t\teep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;\n\t\t} else {\n\t\t\teep_config.max_dvc_qng = ASC_DEF_MIN_DVC_QNG;\n\t\t}\n\t}\n\n\t/*\n\t * If 'max_dvc_qng' is greater than 'max_host_qng', then\n\t * set 'max_dvc_qng' to 'max_host_qng'.\n\t */\n\tif (eep_config.max_dvc_qng > eep_config.max_host_qng) {\n\t\teep_config.max_dvc_qng = eep_config.max_host_qng;\n\t}\n\n\t/*\n\t * Set ADV_DVC_VAR 'max_host_qng' and ADV_DVC_VAR 'max_dvc_qng'\n\t * values based on possibly adjusted EEPROM values.\n\t */\n\tsc->max_host_qng = eep_config.max_host_qng;\n\tsc->max_dvc_qng = eep_config.max_dvc_qng;\n\n\t/*\n\t * If the EEPROM 'termination' field is set to automatic (0), then set\n\t * the ADV_DVC_CFG 'termination' field to automatic also.\n\t *\n\t * If the termination is specified with a non-zero 'termination'\n\t * value check that a legal value is set and set the ADV_DVC_CFG\n\t * 'termination' field appropriately.\n\t */\n\tif (eep_config.termination_se == 0) {\n\t\ttermination = 0;\t/* auto termination for SE */\n\t} else {\n\t\t/* Enable manual control with low off / high off. */\n\t\tif (eep_config.termination_se == 1) {\n\t\t\ttermination = 0;\n\n\t\t/* Enable manual control with low off / high on. */\n\t\t} else if (eep_config.termination_se == 2) {\n\t\t\ttermination = ADW_TERM_SE_HI;\n\n\t\t/* Enable manual control with low on / high on. */\n\t\t} else if (eep_config.termination_se == 3) {\n\t\t\ttermination = ADW_TERM_SE;\n\t\t} else {\n\t\t\t/*\n\t\t\t * The EEPROM 'termination_se' field contains \n\t\t\t * a bad value.\n\t\t\t * Use automatic termination instead.\n\t\t\t */\n\t\t\ttermination = 0;\n\t\t\twarn_code |= ASC_WARN_EEPROM_TERMINATION;\n\t\t}\n\t}\n\n\tif (eep_config.termination_lvd == 0) {\n\t\t/* auto termination for LVD */\n\t\tsc->cfg.termination = termination;\n\t} else\n\t{\n\t\t/* Enable manual control with low off / high off. */\n\t\tif (eep_config.termination_lvd == 1) {\n\t\t\tsc->cfg.termination = termination;\n\n\t\t/* Enable manual control with low off / high on. */\n\t\t} else if (eep_config.termination_lvd == 2) {\n\t\t\tsc->cfg.termination = termination | ADW_TERM_LVD_HI;\n\n\t\t/* Enable manual control with low on / high on. */\n\t\t} else if (eep_config.termination_lvd == 3) {\n\t\t\tsc->cfg.termination = termination | ADW_TERM_LVD;\n\t\t} else {\n\t\t\t/*\n\t\t\t * The EEPROM 'termination_lvd' field contains a bad value.\n\t\t\t * Use automatic termination instead.\n\t\t\t */\n\t\t\tsc->cfg.termination = termination;\n\t\t\twarn_code |= ASC_WARN_EEPROM_TERMINATION;\n\t\t}\n\t}\n\n\treturn warn_code;\n}",
    "includes": [
      "#include <dev/ic/adwmcode.h>",
      "#include <dev/ic/adw.h>",
      "#include <dev/ic/adwlib.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/queue.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u_int16_t AdvGet38C0800EEPConfig",
      "static u_int16_t AdvReadEEPWord",
      "static void AdvSet38C0800EEPConfig",
      "static ADW_EEP_38C0800_CONFIG\nDefault_38C0800_EEPROM_Config = {\n\tADW_EEPROM_BIOS_ENABLE,\t/* 00 cfg_lsw */\n\t0x0000,\t\t\t/* 01 cfg_msw */\n\t0xFFFF,\t\t\t/* 02 disc_enable */\n\t0xFFFF,\t\t\t/* 03 wdtr_able */\n\t0x4444,\t\t\t/* 04 sdtr_speed1 */\n\t0xFFFF,\t\t\t/* 05 start_motor */\n\t0xFFFF,\t\t\t/* 06 tagqng_able */\n\t0xFFFF,\t\t\t/* 07 bios_scan */\n\t0,\t\t\t/* 08 scam_tolerant */\n\t7,\t\t\t/* 09 adapter_scsi_id */\n\t0,\t\t\t/*    bios_boot_delay */\n\t3,\t\t\t/* 10 scsi_reset_delay */\n\t0,\t\t\t/*    bios_id_lun */\n\t0,\t\t\t/* 11 termination_se */\n\t0,\t\t\t/*    termination_lvd */\n\t0xFFE7,\t\t\t/* 12 bios_ctrl */\n\t0x4444,\t\t\t/* 13 sdtr_speed2 */\n\t0x4444,\t\t\t/* 14 sdtr_speed3 */\n\tASC_DEF_MAX_HOST_QNG,\t/* 15 max_host_qng */\n\tASC_DEF_MAX_DVC_QNG,\t/*    max_dvc_qng */\n\t0,\t\t\t/* 16 dvc_cntl */\n\t0x4444,\t\t\t/* 17 sdtr_speed4 */\n\t0,\t\t\t/* 18 serial_number_word1 */\n\t0,\t\t\t/* 19 serial_number_word2 */\n\t0,\t\t\t/* 20 serial_number_word3 */\n\t0,\t\t\t/* 21 check_sum */\n\t{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }, /* 22-29 oem_name[16] */\n\t0,\t\t\t/* 30 dvc_err_code */\n\t0,\t\t\t/* 31 adv_err_code */\n\t0,\t\t\t/* 32 adv_err_addr */\n\t0,\t\t\t/* 33 saved_dvc_err_code */\n\t0,\t\t\t/* 34 saved_adv_err_code */\n\t0,\t\t\t/* 35 saved_adv_err_addr */\n\t0,\t\t\t/* 36 reserved */\n\t0,\t\t\t/* 37 reserved */\n\t0,\t\t\t/* 38 reserved */\n\t0,\t\t\t/* 39 reserved */\n\t0,\t\t\t/* 40 reserved */\n\t0,\t\t\t/* 41 reserved */\n\t0,\t\t\t/* 42 reserved */\n\t0,\t\t\t/* 43 reserved */\n\t0,\t\t\t/* 44 reserved */\n\t0,\t\t\t/* 45 reserved */\n\t0,\t\t\t/* 46 reserved */\n\t0,\t\t\t/* 47 reserved */\n\t0,\t\t\t/* 48 reserved */\n\t0,\t\t\t/* 49 reserved */\n\t0,\t\t\t/* 50 reserved */\n\t0,\t\t\t/* 51 reserved */\n\t0,\t\t\t/* 52 reserved */\n\t0,\t\t\t/* 53 reserved */\n\t0,\t\t\t/* 54 reserved */\n\t0,\t\t\t/* 55 reserved */\n\t0,\t\t\t/* 56 cisptr_lsw */\n\t0,\t\t\t/* 57 cisprt_msw */\n\tPCI_VENDOR_ADVSYS,\t/* 58 subsysvid */\n\tPCI_PRODUCT_ADVSYS_U2W,\t/* 59 subsysid */\n\t0,\t\t\t/* 60 reserved */\n\t0,\t\t\t/* 61 reserved */\n\t0,\t\t\t/* 62 reserved */\n\t0\t\t\t/* 63 reserved */\n};",
      "ADW_SOFTC\t*sc;",
      "bus_space_tag_t iot = sc->sc_iot;",
      "bus_space_handle_t ioh = sc->sc_ioh;",
      "u_int8_t\t\ttid;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "AdvSet38C0800EEPConfig",
          "args": [
            "iot",
            "ioh",
            "&eep_config"
          ],
          "line": 1470
        },
        "resolved": true,
        "details": {
          "function_name": "AdvSet38C0800EEPConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adwlib.c",
          "lines": "1802-1856",
          "snippet": "static void\nAdvSet38C0800EEPConfig(iot, ioh, cfg_buf)\n\tbus_space_tag_t\t\tiot;\n\tbus_space_handle_t\tioh;\n\tADW_EEP_38C0800_CONFIG\t*cfg_buf;\n{\n\tu_int16_t *wbuf;\n\tu_int16_t addr, chksum;\n\n\n\twbuf = (u_int16_t *) cfg_buf;\n\tchksum = 0;\n\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_CMD, ASC_EEP_CMD_WRITE_ABLE);\n\tAdvWaitEEPCmd(iot, ioh);\n\n\t/*\n\t * Write EEPROM from word 0 to word 20\n\t */\n\tfor (addr = ASC_EEP_DVC_CFG_BEGIN;\n\t     addr < ASC_EEP_DVC_CFG_END; addr++, wbuf++) {\n\t\tchksum += *wbuf;\n\t\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_DATA, *wbuf);\n\t\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_CMD,\n\t\t\t\tASC_EEP_CMD_WRITE | addr);\n\t\tAdvWaitEEPCmd(iot, ioh);\n\t\tAdvSleepMilliSecond(ASC_EEP_DELAY_MS);\n\t}\n\n\t/*\n\t * Write EEPROM checksum at word 21\n\t */\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_DATA, chksum);\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_CMD,\n\t\t\tASC_EEP_CMD_WRITE | addr);\n\tAdvWaitEEPCmd(iot, ioh);\n\twbuf++;        /* skip over check_sum */\n\n\t/*\n\t * Write EEPROM OEM name at words 22 to 29\n\t */\n\tfor (addr = ASC_EEP_DVC_CTL_BEGIN;\n\t     addr < ASC_EEP_MAX_WORD_ADDR; addr++, wbuf++) {\n\t\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_DATA, *wbuf);\n\t\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_CMD,\n\t\t\t\tASC_EEP_CMD_WRITE | addr);\n\t\tAdvWaitEEPCmd(iot, ioh);\n\t}\n\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_CMD,\n\t\t\tASC_EEP_CMD_WRITE_DISABLE);\n\tAdvWaitEEPCmd(iot, ioh);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/adwmcode.h>",
            "#include <dev/ic/adw.h>",
            "#include <dev/ic/adwlib.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/queue.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void AdvWaitEEPCmd",
            "static void AdvSet38C0800EEPConfig",
            "static void AdvSleepMilliSecond",
            "bus_space_tag_t iot = sc->sc_iot;",
            "bus_space_handle_t ioh = sc->sc_ioh;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/adwmcode.h>\n#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void AdvWaitEEPCmd;\nstatic void AdvSet38C0800EEPConfig;\nstatic void AdvSleepMilliSecond;\nbus_space_tag_t iot = sc->sc_iot;\nbus_space_handle_t ioh = sc->sc_ioh;\n\nstatic void\nAdvSet38C0800EEPConfig(iot, ioh, cfg_buf)\n\tbus_space_tag_t\t\tiot;\n\tbus_space_handle_t\tioh;\n\tADW_EEP_38C0800_CONFIG\t*cfg_buf;\n{\n\tu_int16_t *wbuf;\n\tu_int16_t addr, chksum;\n\n\n\twbuf = (u_int16_t *) cfg_buf;\n\tchksum = 0;\n\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_CMD, ASC_EEP_CMD_WRITE_ABLE);\n\tAdvWaitEEPCmd(iot, ioh);\n\n\t/*\n\t * Write EEPROM from word 0 to word 20\n\t */\n\tfor (addr = ASC_EEP_DVC_CFG_BEGIN;\n\t     addr < ASC_EEP_DVC_CFG_END; addr++, wbuf++) {\n\t\tchksum += *wbuf;\n\t\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_DATA, *wbuf);\n\t\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_CMD,\n\t\t\t\tASC_EEP_CMD_WRITE | addr);\n\t\tAdvWaitEEPCmd(iot, ioh);\n\t\tAdvSleepMilliSecond(ASC_EEP_DELAY_MS);\n\t}\n\n\t/*\n\t * Write EEPROM checksum at word 21\n\t */\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_DATA, chksum);\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_CMD,\n\t\t\tASC_EEP_CMD_WRITE | addr);\n\tAdvWaitEEPCmd(iot, ioh);\n\twbuf++;        /* skip over check_sum */\n\n\t/*\n\t * Write EEPROM OEM name at words 22 to 29\n\t */\n\tfor (addr = ASC_EEP_DVC_CTL_BEGIN;\n\t     addr < ASC_EEP_MAX_WORD_ADDR; addr++, wbuf++) {\n\t\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_DATA, *wbuf);\n\t\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_CMD,\n\t\t\t\tASC_EEP_CMD_WRITE | addr);\n\t\tAdvWaitEEPCmd(iot, ioh);\n\t}\n\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_CMD,\n\t\t\tASC_EEP_CMD_WRITE_DISABLE);\n\tAdvWaitEEPCmd(iot, ioh);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AdvReadEEPWord",
          "args": [
            "iot",
            "ioh",
            "ASC_EEP_DVC_CFG_END - 3"
          ],
          "line": 1468
        },
        "resolved": true,
        "details": {
          "function_name": "AdvReadEEPWord",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adwlib.c",
          "lines": "1702-1713",
          "snippet": "static u_int16_t\nAdvReadEEPWord(iot, ioh, eep_word_addr)\n\tbus_space_tag_t\t\tiot;\n\tbus_space_handle_t\tioh;\n\tint\t\t\teep_word_addr;\n{\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_CMD,\n\t\tASC_EEP_CMD_READ | eep_word_addr);\n\tAdvWaitEEPCmd(iot, ioh);\n\n\treturn ADW_READ_WORD_REGISTER(iot, ioh, IOPW_EE_DATA);\n}",
          "includes": [
            "#include <dev/ic/adwmcode.h>",
            "#include <dev/ic/adw.h>",
            "#include <dev/ic/adwlib.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/queue.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u_int16_t AdvReadEEPWord",
            "static void AdvWaitEEPCmd",
            "bus_space_tag_t iot = sc->sc_iot;",
            "bus_space_handle_t ioh = sc->sc_ioh;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/adwmcode.h>\n#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic u_int16_t AdvReadEEPWord;\nstatic void AdvWaitEEPCmd;\nbus_space_tag_t iot = sc->sc_iot;\nbus_space_handle_t ioh = sc->sc_ioh;\n\nstatic u_int16_t\nAdvReadEEPWord(iot, ioh, eep_word_addr)\n\tbus_space_tag_t\t\tiot;\n\tbus_space_handle_t\tioh;\n\tint\t\t\teep_word_addr;\n{\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_CMD,\n\t\tASC_EEP_CMD_READ | eep_word_addr);\n\tAdvWaitEEPCmd(iot, ioh);\n\n\treturn ADW_READ_WORD_REGISTER(iot, ioh, IOPW_EE_DATA);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AdvGet38C0800EEPConfig",
          "args": [
            "iot",
            "ioh",
            "&eep_config"
          ],
          "line": 1444
        },
        "resolved": true,
        "details": {
          "function_name": "AdvGet38C0800EEPConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adwlib.c",
          "lines": "1665-1696",
          "snippet": "static u_int16_t\nAdvGet38C0800EEPConfig(iot, ioh, cfg_buf)\n\tbus_space_tag_t\t\tiot;\n\tbus_space_handle_t\tioh;\n\tADW_EEP_38C0800_CONFIG\t*cfg_buf;\n{\n\tu_int16_t\twval, chksum;\n\tu_int16_t\t*wbuf;\n\tint\t\teep_addr;\n\n\n\twbuf = (u_int16_t *) cfg_buf;\n\tchksum = 0;\n\n\tfor (eep_addr = ASC_EEP_DVC_CFG_BEGIN;\n\t\t\teep_addr < ASC_EEP_DVC_CFG_END;\n\t\t\teep_addr++, wbuf++) {\n\t\twval = AdvReadEEPWord(iot, ioh, eep_addr);\n\t\tchksum += wval;\n\t\t*wbuf = wval;\n\t}\n\n\t*wbuf = AdvReadEEPWord(iot, ioh, eep_addr);\n\twbuf++;\n\tfor (eep_addr = ASC_EEP_DVC_CTL_BEGIN;\n\t\t\teep_addr < ASC_EEP_MAX_WORD_ADDR;\n\t\t\teep_addr++, wbuf++) {\n\t\t*wbuf = AdvReadEEPWord(iot, ioh, eep_addr);\n\t}\n\n\treturn chksum;\n}",
          "includes": [
            "#include <dev/ic/adwmcode.h>",
            "#include <dev/ic/adw.h>",
            "#include <dev/ic/adwlib.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/queue.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u_int16_t AdvGet38C0800EEPConfig",
            "static u_int16_t AdvReadEEPWord",
            "bus_space_tag_t iot = sc->sc_iot;",
            "bus_space_handle_t ioh = sc->sc_ioh;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/adwmcode.h>\n#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic u_int16_t AdvGet38C0800EEPConfig;\nstatic u_int16_t AdvReadEEPWord;\nbus_space_tag_t iot = sc->sc_iot;\nbus_space_handle_t ioh = sc->sc_ioh;\n\nstatic u_int16_t\nAdvGet38C0800EEPConfig(iot, ioh, cfg_buf)\n\tbus_space_tag_t\t\tiot;\n\tbus_space_handle_t\tioh;\n\tADW_EEP_38C0800_CONFIG\t*cfg_buf;\n{\n\tu_int16_t\twval, chksum;\n\tu_int16_t\t*wbuf;\n\tint\t\teep_addr;\n\n\n\twbuf = (u_int16_t *) cfg_buf;\n\tchksum = 0;\n\n\tfor (eep_addr = ASC_EEP_DVC_CFG_BEGIN;\n\t\t\teep_addr < ASC_EEP_DVC_CFG_END;\n\t\t\teep_addr++, wbuf++) {\n\t\twval = AdvReadEEPWord(iot, ioh, eep_addr);\n\t\tchksum += wval;\n\t\t*wbuf = wval;\n\t}\n\n\t*wbuf = AdvReadEEPWord(iot, ioh, eep_addr);\n\twbuf++;\n\tfor (eep_addr = ASC_EEP_DVC_CTL_BEGIN;\n\t\t\teep_addr < ASC_EEP_MAX_WORD_ADDR;\n\t\t\teep_addr++, wbuf++) {\n\t\t*wbuf = AdvReadEEPWord(iot, ioh, eep_addr);\n\t}\n\n\treturn chksum;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/adwmcode.h>\n#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic u_int16_t AdvGet38C0800EEPConfig;\nstatic u_int16_t AdvReadEEPWord;\nstatic void AdvSet38C0800EEPConfig;\nstatic ADW_EEP_38C0800_CONFIG\nDefault_38C0800_EEPROM_Config = {\n\tADW_EEPROM_BIOS_ENABLE,\t/* 00 cfg_lsw */\n\t0x0000,\t\t\t/* 01 cfg_msw */\n\t0xFFFF,\t\t\t/* 02 disc_enable */\n\t0xFFFF,\t\t\t/* 03 wdtr_able */\n\t0x4444,\t\t\t/* 04 sdtr_speed1 */\n\t0xFFFF,\t\t\t/* 05 start_motor */\n\t0xFFFF,\t\t\t/* 06 tagqng_able */\n\t0xFFFF,\t\t\t/* 07 bios_scan */\n\t0,\t\t\t/* 08 scam_tolerant */\n\t7,\t\t\t/* 09 adapter_scsi_id */\n\t0,\t\t\t/*    bios_boot_delay */\n\t3,\t\t\t/* 10 scsi_reset_delay */\n\t0,\t\t\t/*    bios_id_lun */\n\t0,\t\t\t/* 11 termination_se */\n\t0,\t\t\t/*    termination_lvd */\n\t0xFFE7,\t\t\t/* 12 bios_ctrl */\n\t0x4444,\t\t\t/* 13 sdtr_speed2 */\n\t0x4444,\t\t\t/* 14 sdtr_speed3 */\n\tASC_DEF_MAX_HOST_QNG,\t/* 15 max_host_qng */\n\tASC_DEF_MAX_DVC_QNG,\t/*    max_dvc_qng */\n\t0,\t\t\t/* 16 dvc_cntl */\n\t0x4444,\t\t\t/* 17 sdtr_speed4 */\n\t0,\t\t\t/* 18 serial_number_word1 */\n\t0,\t\t\t/* 19 serial_number_word2 */\n\t0,\t\t\t/* 20 serial_number_word3 */\n\t0,\t\t\t/* 21 check_sum */\n\t{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }, /* 22-29 oem_name[16] */\n\t0,\t\t\t/* 30 dvc_err_code */\n\t0,\t\t\t/* 31 adv_err_code */\n\t0,\t\t\t/* 32 adv_err_addr */\n\t0,\t\t\t/* 33 saved_dvc_err_code */\n\t0,\t\t\t/* 34 saved_adv_err_code */\n\t0,\t\t\t/* 35 saved_adv_err_addr */\n\t0,\t\t\t/* 36 reserved */\n\t0,\t\t\t/* 37 reserved */\n\t0,\t\t\t/* 38 reserved */\n\t0,\t\t\t/* 39 reserved */\n\t0,\t\t\t/* 40 reserved */\n\t0,\t\t\t/* 41 reserved */\n\t0,\t\t\t/* 42 reserved */\n\t0,\t\t\t/* 43 reserved */\n\t0,\t\t\t/* 44 reserved */\n\t0,\t\t\t/* 45 reserved */\n\t0,\t\t\t/* 46 reserved */\n\t0,\t\t\t/* 47 reserved */\n\t0,\t\t\t/* 48 reserved */\n\t0,\t\t\t/* 49 reserved */\n\t0,\t\t\t/* 50 reserved */\n\t0,\t\t\t/* 51 reserved */\n\t0,\t\t\t/* 52 reserved */\n\t0,\t\t\t/* 53 reserved */\n\t0,\t\t\t/* 54 reserved */\n\t0,\t\t\t/* 55 reserved */\n\t0,\t\t\t/* 56 cisptr_lsw */\n\t0,\t\t\t/* 57 cisprt_msw */\n\tPCI_VENDOR_ADVSYS,\t/* 58 subsysvid */\n\tPCI_PRODUCT_ADVSYS_U2W,\t/* 59 subsysid */\n\t0,\t\t\t/* 60 reserved */\n\t0,\t\t\t/* 61 reserved */\n\t0,\t\t\t/* 62 reserved */\n\t0\t\t\t/* 63 reserved */\n};\nADW_SOFTC\t*sc;\nbus_space_tag_t iot = sc->sc_iot;\nbus_space_handle_t ioh = sc->sc_ioh;\nu_int8_t\t\ttid;\n\nint\nAdvInitFrom38C0800EEP(sc)\nADW_SOFTC      *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tu_int16_t\t\twarn_code;\n\tADW_EEP_38C0800_CONFIG\teep_config;\n\tint\t\t\ti;\n\tu_int8_t\t\ttid, termination;\n\tu_int16_t\t\tsdtr_speed = 0;\n\n\n\twarn_code = 0;\n\n\t/*\n\t * Read the board's EEPROM configuration.\n\t *\n\t * Set default values if a bad checksum is found.\n\t */\n\tif (AdvGet38C0800EEPConfig(iot, ioh, &eep_config) != \n\t\t\teep_config.check_sum) {\n\t\twarn_code |= ASC_WARN_EEPROM_CHKSUM;\n\n\t\t/*\n\t\t * Set EEPROM default values.\n\t\t */\n\t\tfor (i = 0; i < sizeof(ADW_EEP_38C0800_CONFIG); i++) {\n\t\t\t*((u_int8_t *) &eep_config + i) =\n\t\t\t\t*((u_int8_t *)&Default_38C0800_EEPROM_Config+i);\n\t\t}\n\n\t\t/*\n\t\t * Assume the 6 byte board serial number that was read\n\t\t * from EEPROM is correct even if the EEPROM checksum\n\t\t * failed.\n\t\t */\n\t\teep_config.serial_number_word3 =\n\t\t\tAdvReadEEPWord(iot, ioh, ASC_EEP_DVC_CFG_END - 1);\n\n\t\teep_config.serial_number_word2 =\n\t\t\tAdvReadEEPWord(iot, ioh, ASC_EEP_DVC_CFG_END - 2);\n\n\t\teep_config.serial_number_word1 =\n\t\t\tAdvReadEEPWord(iot, ioh, ASC_EEP_DVC_CFG_END - 3);\n\n\t\tAdvSet38C0800EEPConfig(iot, ioh, &eep_config);\n\t}\n\t/*\n\t * Set ADV_DVC_VAR and ADV_DVC_CFG variables from the\n\t * EEPROM configuration that was read.\n\t *\n\t * This is the mapping of EEPROM fields to Adv Library fields.\n\t */\n\tsc->wdtr_able = eep_config.wdtr_able;\n\tsc->sdtr_speed1 = eep_config.sdtr_speed1;\n\tsc->sdtr_speed2 = eep_config.sdtr_speed2;\n\tsc->sdtr_speed3 = eep_config.sdtr_speed3;\n\tsc->sdtr_speed4 = eep_config.sdtr_speed4;\n\tsc->tagqng_able = eep_config.tagqng_able;\n\tsc->cfg.disc_enable = eep_config.disc_enable;\n\tsc->max_host_qng = eep_config.max_host_qng;\n\tsc->max_dvc_qng = eep_config.max_dvc_qng;\n\tsc->chip_scsi_id = (eep_config.adapter_scsi_id & ADW_MAX_TID);\n\tsc->start_motor = eep_config.start_motor;\n\tsc->scsi_reset_wait = eep_config.scsi_reset_delay;\n\tsc->bios_ctrl = eep_config.bios_ctrl;\n\tsc->no_scam = eep_config.scam_tolerant;\n\tsc->cfg.serial1 = eep_config.serial_number_word1;\n\tsc->cfg.serial2 = eep_config.serial_number_word2;\n\tsc->cfg.serial3 = eep_config.serial_number_word3;\n\n\t/*\n\t * For every Target ID if any of its 'sdtr_speed[1234]' bits\n\t * are set, then set an 'sdtr_able' bit for it.\n\t */\n\tsc->sdtr_able = 0;\n\tfor (tid = 0; tid <= ADW_MAX_TID; tid++) {\n\t\tif (tid == 0) {\n\t\t\tsdtr_speed = sc->sdtr_speed1;\n\t\t} else if (tid == 4) {\n\t\t\tsdtr_speed = sc->sdtr_speed2;\n\t\t} else if (tid == 8) {\n\t\t\tsdtr_speed = sc->sdtr_speed3;\n\t\t} else if (tid == 12) {\n\t\t\tsdtr_speed = sc->sdtr_speed4;\n\t\t}\n\t\tif (sdtr_speed & ADW_MAX_TID) {\n\t\t\tsc->sdtr_able |= (1 << tid);\n\t\t}\n\t\tsdtr_speed >>= 4;\n\t}\n\n\t/*\n\t * Set the host maximum queuing (max. 253, min. 16) and the per device\n\t * maximum queuing (max. 63, min. 4).\n\t */\n\tif (eep_config.max_host_qng > ASC_DEF_MAX_HOST_QNG) {\n\t\teep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;\n\t} else if (eep_config.max_host_qng < ASC_DEF_MIN_HOST_QNG) {\n\t\t/* If the value is zero, assume it is uninitialized. */\n\t\tif (eep_config.max_host_qng == 0) {\n\t\t\teep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;\n\t\t} else {\n\t\t\teep_config.max_host_qng = ASC_DEF_MIN_HOST_QNG;\n\t\t}\n\t}\n\n\tif (eep_config.max_dvc_qng > ASC_DEF_MAX_DVC_QNG) {\n\t\teep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;\n\t} else if (eep_config.max_dvc_qng < ASC_DEF_MIN_DVC_QNG) {\n\t\t/* If the value is zero, assume it is uninitialized. */\n\t\tif (eep_config.max_dvc_qng == 0) {\n\t\t\teep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;\n\t\t} else {\n\t\t\teep_config.max_dvc_qng = ASC_DEF_MIN_DVC_QNG;\n\t\t}\n\t}\n\n\t/*\n\t * If 'max_dvc_qng' is greater than 'max_host_qng', then\n\t * set 'max_dvc_qng' to 'max_host_qng'.\n\t */\n\tif (eep_config.max_dvc_qng > eep_config.max_host_qng) {\n\t\teep_config.max_dvc_qng = eep_config.max_host_qng;\n\t}\n\n\t/*\n\t * Set ADV_DVC_VAR 'max_host_qng' and ADV_DVC_VAR 'max_dvc_qng'\n\t * values based on possibly adjusted EEPROM values.\n\t */\n\tsc->max_host_qng = eep_config.max_host_qng;\n\tsc->max_dvc_qng = eep_config.max_dvc_qng;\n\n\t/*\n\t * If the EEPROM 'termination' field is set to automatic (0), then set\n\t * the ADV_DVC_CFG 'termination' field to automatic also.\n\t *\n\t * If the termination is specified with a non-zero 'termination'\n\t * value check that a legal value is set and set the ADV_DVC_CFG\n\t * 'termination' field appropriately.\n\t */\n\tif (eep_config.termination_se == 0) {\n\t\ttermination = 0;\t/* auto termination for SE */\n\t} else {\n\t\t/* Enable manual control with low off / high off. */\n\t\tif (eep_config.termination_se == 1) {\n\t\t\ttermination = 0;\n\n\t\t/* Enable manual control with low off / high on. */\n\t\t} else if (eep_config.termination_se == 2) {\n\t\t\ttermination = ADW_TERM_SE_HI;\n\n\t\t/* Enable manual control with low on / high on. */\n\t\t} else if (eep_config.termination_se == 3) {\n\t\t\ttermination = ADW_TERM_SE;\n\t\t} else {\n\t\t\t/*\n\t\t\t * The EEPROM 'termination_se' field contains \n\t\t\t * a bad value.\n\t\t\t * Use automatic termination instead.\n\t\t\t */\n\t\t\ttermination = 0;\n\t\t\twarn_code |= ASC_WARN_EEPROM_TERMINATION;\n\t\t}\n\t}\n\n\tif (eep_config.termination_lvd == 0) {\n\t\t/* auto termination for LVD */\n\t\tsc->cfg.termination = termination;\n\t} else\n\t{\n\t\t/* Enable manual control with low off / high off. */\n\t\tif (eep_config.termination_lvd == 1) {\n\t\t\tsc->cfg.termination = termination;\n\n\t\t/* Enable manual control with low off / high on. */\n\t\t} else if (eep_config.termination_lvd == 2) {\n\t\t\tsc->cfg.termination = termination | ADW_TERM_LVD_HI;\n\n\t\t/* Enable manual control with low on / high on. */\n\t\t} else if (eep_config.termination_lvd == 3) {\n\t\t\tsc->cfg.termination = termination | ADW_TERM_LVD;\n\t\t} else {\n\t\t\t/*\n\t\t\t * The EEPROM 'termination_lvd' field contains a bad value.\n\t\t\t * Use automatic termination instead.\n\t\t\t */\n\t\t\tsc->cfg.termination = termination;\n\t\t\twarn_code |= ASC_WARN_EEPROM_TERMINATION;\n\t\t}\n\t}\n\n\treturn warn_code;\n}"
  },
  {
    "function_name": "AdvInitFrom3550EEP",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adwlib.c",
    "lines": "1265-1409",
    "snippet": "int\nAdvInitFrom3550EEP(sc)\nADW_SOFTC      *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tu_int16_t\t\twarn_code;\n\tADW_EEP_3550_CONFIG\teep_config;\n\tint\t\t\ti;\n\n\n\twarn_code = 0;\n\n\t/*\n\t * Read the board's EEPROM configuration.\n\t *\n\t * Set default values if a bad checksum is found.\n\t */\n\tif (AdvGet3550EEPConfig(iot, ioh, &eep_config) != eep_config.check_sum){\n\t\twarn_code |= ASC_WARN_EEPROM_CHKSUM;\n\n\t\t/*\n\t\t * Set EEPROM default values.\n\t\t */\n\t\tfor (i = 0; i < sizeof(ADW_EEP_3550_CONFIG); i++) {\n\t\t\t*((u_int8_t *) &eep_config + i) =\n\t\t\t\t*((u_int8_t *) &Default_3550_EEPROM_Config + i);\n\t\t}\n\n\t\t/*\n\t\t * Assume the 6 byte board serial number that was read\n\t\t * from EEPROM is correct even if the EEPROM checksum\n\t\t * failed.\n\t\t */\n\t\teep_config.serial_number_word3 =\n\t\t\tAdvReadEEPWord(iot, ioh, ASC_EEP_DVC_CFG_END - 1);\n\n\t\teep_config.serial_number_word2 =\n\t\t\tAdvReadEEPWord(iot, ioh, ASC_EEP_DVC_CFG_END - 2);\n\n\t\teep_config.serial_number_word1 =\n\t\t\tAdvReadEEPWord(iot, ioh, ASC_EEP_DVC_CFG_END - 3);\n\n\t\tAdvSet3550EEPConfig(iot, ioh, &eep_config);\n\t}\n\t/*\n\t * Set sc_VAR and sc_CFG variables from the\n\t * EEPROM configuration that was read.\n\t *\n\t * This is the mapping of EEPROM fields to Adv Library fields.\n\t */\n\tsc->wdtr_able = eep_config.wdtr_able;\n\tsc->sdtr_able = eep_config.sdtr_able;\n\tsc->ultra_able = eep_config.ultra_able;\n\tsc->tagqng_able = eep_config.tagqng_able;\n\tsc->cfg.disc_enable = eep_config.disc_enable;\n\tsc->max_host_qng = eep_config.max_host_qng;\n\tsc->max_dvc_qng = eep_config.max_dvc_qng;\n\tsc->chip_scsi_id = (eep_config.adapter_scsi_id & ADW_MAX_TID);\n\tsc->start_motor = eep_config.start_motor;\n\tsc->scsi_reset_wait = eep_config.scsi_reset_delay;\n\tsc->bios_ctrl = eep_config.bios_ctrl;\n\tsc->no_scam = eep_config.scam_tolerant;\n\tsc->cfg.serial1 = eep_config.serial_number_word1;\n\tsc->cfg.serial2 = eep_config.serial_number_word2;\n\tsc->cfg.serial3 = eep_config.serial_number_word3;\n\n\t/*\n\t * Set the host maximum queuing (max. 253, min. 16) and the per device\n\t * maximum queuing (max. 63, min. 4).\n\t */\n\tif (eep_config.max_host_qng > ASC_DEF_MAX_HOST_QNG) {\n\t\teep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;\n\t} else if (eep_config.max_host_qng < ASC_DEF_MIN_HOST_QNG)\n\t{\n\t\t/* If the value is zero, assume it is uninitialized. */\n\t\tif (eep_config.max_host_qng == 0) {\n\t\t\teep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;\n\t\t} else {\n\t\t\teep_config.max_host_qng = ASC_DEF_MIN_HOST_QNG;\n\t\t}\n\t}\n\n\tif (eep_config.max_dvc_qng > ASC_DEF_MAX_DVC_QNG) {\n\t\teep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;\n\t} else if (eep_config.max_dvc_qng < ASC_DEF_MIN_DVC_QNG) {\n\t\t/* If the value is zero, assume it is uninitialized. */\n\t\tif (eep_config.max_dvc_qng == 0) {\n\t\t\teep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;\n\t\t} else {\n\t\t\teep_config.max_dvc_qng = ASC_DEF_MIN_DVC_QNG;\n\t\t}\n\t}\n\n\t/*\n\t * If 'max_dvc_qng' is greater than 'max_host_qng', then\n\t * set 'max_dvc_qng' to 'max_host_qng'.\n\t */\n\tif (eep_config.max_dvc_qng > eep_config.max_host_qng) {\n\t\teep_config.max_dvc_qng = eep_config.max_host_qng;\n\t}\n\n\t/*\n\t * Set ADV_DVC_VAR 'max_host_qng' and ADV_DVC_VAR 'max_dvc_qng'\n\t * values based on possibly adjusted EEPROM values.\n\t */\n\tsc->max_host_qng = eep_config.max_host_qng;\n\tsc->max_dvc_qng = eep_config.max_dvc_qng;\n\n\n\t/*\n\t * If the EEPROM 'termination' field is set to automatic (0), then set\n\t * the ADV_DVC_CFG 'termination' field to automatic also.\n\t *\n\t * If the termination is specified with a non-zero 'termination'\n\t * value check that a legal value is set and set the ADV_DVC_CFG\n\t * 'termination' field appropriately.\n\t */\n\tif (eep_config.termination == 0) {\n\t\tsc->cfg.termination = 0;    /* auto termination */\n\t} else {\n\t\t/* Enable manual control with low off / high off. */\n\t\tif (eep_config.termination == 1) {\n\t\t\tsc->cfg.termination = ADW_TERM_CTL_SEL;\n\n\t\t/* Enable manual control with low off / high on. */\n\t\t} else if (eep_config.termination == 2) {\n\t\t\tsc->cfg.termination = ADW_TERM_CTL_SEL | ADW_TERM_CTL_H;\n\n\t\t/* Enable manual control with low on / high on. */\n\t\t} else if (eep_config.termination == 3) {\n\t\t\tsc->cfg.termination = ADW_TERM_CTL_SEL |\n\t\t\t\t\tADW_TERM_CTL_H | ADW_TERM_CTL_L;\n\t\t} else {\n\t\t\t/*\n\t\t\t * The EEPROM 'termination' field contains a bad value. Use\n\t\t\t * automatic termination instead.\n\t\t\t */\n\t\t\tsc->cfg.termination = 0;\n\t\t\twarn_code |= ASC_WARN_EEPROM_TERMINATION;\n\t\t}\n\t}\n\n\treturn warn_code;\n}",
    "includes": [
      "#include <dev/ic/adwmcode.h>",
      "#include <dev/ic/adw.h>",
      "#include <dev/ic/adwlib.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/queue.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u_int16_t AdvGet3550EEPConfig",
      "static u_int16_t AdvReadEEPWord",
      "static void AdvSet3550EEPConfig",
      "static ADW_EEP_3550_CONFIG\nDefault_3550_EEPROM_Config = {\n\tADW_EEPROM_BIOS_ENABLE,\t/* cfg_lsw */\n\t0x0000,\t\t\t/* cfg_msw */\n\t0xFFFF,\t\t\t/* disc_enable */\n\t0xFFFF,\t\t\t/* wdtr_able */\n\t0xFFFF,\t\t\t/* sdtr_able */\n\t0xFFFF,\t\t\t/* start_motor */\n\t0xFFFF,\t\t\t/* tagqng_able */\n\t0xFFFF,\t\t\t/* bios_scan */\n\t0,\t\t\t/* scam_tolerant */\n\t7,\t\t\t/* adapter_scsi_id */\n\t0,\t\t\t/* bios_boot_delay */\n\t3,\t\t\t/* scsi_reset_delay */\n\t0,\t\t\t/* bios_id_lun */\n\t0,\t\t\t/* termination */\n\t0,\t\t\t/* reserved1 */\n\t0xFFE7,\t\t\t/* bios_ctrl */\n\t0xFFFF,\t\t\t/* ultra_able */\n\t0,\t\t\t/* reserved2 */\n\tASC_DEF_MAX_HOST_QNG,\t/* max_host_qng */\n\tASC_DEF_MAX_DVC_QNG,\t/* max_dvc_qng */\n\t0,\t\t\t/* dvc_cntl */\n\t0,\t\t\t/* bug_fix */\n\t0,\t\t\t/* serial_number_word1 */\n\t0,\t\t\t/* serial_number_word2 */\n\t0,\t\t\t/* serial_number_word3 */\n\t0,\t\t\t/* check_sum */\n\t{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, /* oem_name[16] */\n\t0,\t\t\t/* dvc_err_code */\n\t0,\t\t\t/* adv_err_code */\n\t0,\t\t\t/* adv_err_addr */\n\t0,\t\t\t/* saved_dvc_err_code */\n\t0,\t\t\t/* saved_adv_err_code */\n\t0,\t\t\t/* saved_adv_err_addr */\n\t0\t\t\t/* num_of_err */\n};",
      "ADW_SOFTC\t*sc;",
      "bus_space_tag_t iot = sc->sc_iot;",
      "bus_space_handle_t ioh = sc->sc_ioh;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "AdvSet3550EEPConfig",
          "args": [
            "iot",
            "ioh",
            "&eep_config"
          ],
          "line": 1308
        },
        "resolved": true,
        "details": {
          "function_name": "AdvSet3550EEPConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adwlib.c",
          "lines": "1742-1796",
          "snippet": "static void\nAdvSet3550EEPConfig(iot, ioh, cfg_buf)\n\tbus_space_tag_t\t\tiot;\n\tbus_space_handle_t\tioh;\n\tADW_EEP_3550_CONFIG\t*cfg_buf;\n{\n\tu_int16_t *wbuf;\n\tu_int16_t addr, chksum;\n\n\n\twbuf = (u_int16_t *) cfg_buf;\n\tchksum = 0;\n\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_CMD, ASC_EEP_CMD_WRITE_ABLE);\n\tAdvWaitEEPCmd(iot, ioh);\n\n\t/*\n\t * Write EEPROM from word 0 to word 20\n\t */\n\tfor (addr = ASC_EEP_DVC_CFG_BEGIN;\n\t     addr < ASC_EEP_DVC_CFG_END; addr++, wbuf++) {\n\t\tchksum += *wbuf;\n\t\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_DATA, *wbuf);\n\t\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_CMD,\n\t\t\t\tASC_EEP_CMD_WRITE | addr);\n\t\tAdvWaitEEPCmd(iot, ioh);\n\t\tAdvSleepMilliSecond(ASC_EEP_DELAY_MS);\n\t}\n\n\t/*\n\t * Write EEPROM checksum at word 21\n\t */\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_DATA, chksum);\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_CMD,\n\t\t\tASC_EEP_CMD_WRITE | addr);\n\tAdvWaitEEPCmd(iot, ioh);\n\twbuf++;        /* skip over check_sum */\n\n\t/*\n\t * Write EEPROM OEM name at words 22 to 29\n\t */\n\tfor (addr = ASC_EEP_DVC_CTL_BEGIN;\n\t     addr < ASC_EEP_MAX_WORD_ADDR; addr++, wbuf++) {\n\t\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_DATA, *wbuf);\n\t\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_CMD,\n\t\t\t\tASC_EEP_CMD_WRITE | addr);\n\t\tAdvWaitEEPCmd(iot, ioh);\n\t}\n\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_CMD,\n\t\t\tASC_EEP_CMD_WRITE_DISABLE);\n\tAdvWaitEEPCmd(iot, ioh);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/adwmcode.h>",
            "#include <dev/ic/adw.h>",
            "#include <dev/ic/adwlib.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/queue.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void AdvWaitEEPCmd",
            "static void AdvSet3550EEPConfig",
            "static void AdvSleepMilliSecond",
            "bus_space_tag_t iot = sc->sc_iot;",
            "bus_space_handle_t ioh = sc->sc_ioh;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/adwmcode.h>\n#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void AdvWaitEEPCmd;\nstatic void AdvSet3550EEPConfig;\nstatic void AdvSleepMilliSecond;\nbus_space_tag_t iot = sc->sc_iot;\nbus_space_handle_t ioh = sc->sc_ioh;\n\nstatic void\nAdvSet3550EEPConfig(iot, ioh, cfg_buf)\n\tbus_space_tag_t\t\tiot;\n\tbus_space_handle_t\tioh;\n\tADW_EEP_3550_CONFIG\t*cfg_buf;\n{\n\tu_int16_t *wbuf;\n\tu_int16_t addr, chksum;\n\n\n\twbuf = (u_int16_t *) cfg_buf;\n\tchksum = 0;\n\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_CMD, ASC_EEP_CMD_WRITE_ABLE);\n\tAdvWaitEEPCmd(iot, ioh);\n\n\t/*\n\t * Write EEPROM from word 0 to word 20\n\t */\n\tfor (addr = ASC_EEP_DVC_CFG_BEGIN;\n\t     addr < ASC_EEP_DVC_CFG_END; addr++, wbuf++) {\n\t\tchksum += *wbuf;\n\t\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_DATA, *wbuf);\n\t\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_CMD,\n\t\t\t\tASC_EEP_CMD_WRITE | addr);\n\t\tAdvWaitEEPCmd(iot, ioh);\n\t\tAdvSleepMilliSecond(ASC_EEP_DELAY_MS);\n\t}\n\n\t/*\n\t * Write EEPROM checksum at word 21\n\t */\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_DATA, chksum);\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_CMD,\n\t\t\tASC_EEP_CMD_WRITE | addr);\n\tAdvWaitEEPCmd(iot, ioh);\n\twbuf++;        /* skip over check_sum */\n\n\t/*\n\t * Write EEPROM OEM name at words 22 to 29\n\t */\n\tfor (addr = ASC_EEP_DVC_CTL_BEGIN;\n\t     addr < ASC_EEP_MAX_WORD_ADDR; addr++, wbuf++) {\n\t\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_DATA, *wbuf);\n\t\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_CMD,\n\t\t\t\tASC_EEP_CMD_WRITE | addr);\n\t\tAdvWaitEEPCmd(iot, ioh);\n\t}\n\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_CMD,\n\t\t\tASC_EEP_CMD_WRITE_DISABLE);\n\tAdvWaitEEPCmd(iot, ioh);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AdvReadEEPWord",
          "args": [
            "iot",
            "ioh",
            "ASC_EEP_DVC_CFG_END - 3"
          ],
          "line": 1306
        },
        "resolved": true,
        "details": {
          "function_name": "AdvReadEEPWord",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adwlib.c",
          "lines": "1702-1713",
          "snippet": "static u_int16_t\nAdvReadEEPWord(iot, ioh, eep_word_addr)\n\tbus_space_tag_t\t\tiot;\n\tbus_space_handle_t\tioh;\n\tint\t\t\teep_word_addr;\n{\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_CMD,\n\t\tASC_EEP_CMD_READ | eep_word_addr);\n\tAdvWaitEEPCmd(iot, ioh);\n\n\treturn ADW_READ_WORD_REGISTER(iot, ioh, IOPW_EE_DATA);\n}",
          "includes": [
            "#include <dev/ic/adwmcode.h>",
            "#include <dev/ic/adw.h>",
            "#include <dev/ic/adwlib.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/queue.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u_int16_t AdvReadEEPWord",
            "static void AdvWaitEEPCmd",
            "bus_space_tag_t iot = sc->sc_iot;",
            "bus_space_handle_t ioh = sc->sc_ioh;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/adwmcode.h>\n#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic u_int16_t AdvReadEEPWord;\nstatic void AdvWaitEEPCmd;\nbus_space_tag_t iot = sc->sc_iot;\nbus_space_handle_t ioh = sc->sc_ioh;\n\nstatic u_int16_t\nAdvReadEEPWord(iot, ioh, eep_word_addr)\n\tbus_space_tag_t\t\tiot;\n\tbus_space_handle_t\tioh;\n\tint\t\t\teep_word_addr;\n{\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_EE_CMD,\n\t\tASC_EEP_CMD_READ | eep_word_addr);\n\tAdvWaitEEPCmd(iot, ioh);\n\n\treturn ADW_READ_WORD_REGISTER(iot, ioh, IOPW_EE_DATA);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AdvGet3550EEPConfig",
          "args": [
            "iot",
            "ioh",
            "&eep_config"
          ],
          "line": 1283
        },
        "resolved": true,
        "details": {
          "function_name": "AdvGet3550EEPConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adwlib.c",
          "lines": "1626-1657",
          "snippet": "static u_int16_t\nAdvGet3550EEPConfig(iot, ioh, cfg_buf)\n\tbus_space_tag_t\t\tiot;\n\tbus_space_handle_t\tioh;\n\tADW_EEP_3550_CONFIG\t*cfg_buf;\n{\n\tu_int16_t\t       wval, chksum;\n\tu_int16_t\t       *wbuf;\n\tint\t\t    eep_addr;\n\n\n\twbuf = (u_int16_t *) cfg_buf;\n\tchksum = 0;\n\n\tfor (eep_addr = ASC_EEP_DVC_CFG_BEGIN;\n\t\t\teep_addr < ASC_EEP_DVC_CFG_END;\n\t\t\teep_addr++, wbuf++) {\n\t\twval = AdvReadEEPWord(iot, ioh, eep_addr);\n\t\tchksum += wval;\n\t\t*wbuf = wval;\n\t}\n\n\t*wbuf = AdvReadEEPWord(iot, ioh, eep_addr);\n\twbuf++;\n\tfor (eep_addr = ASC_EEP_DVC_CTL_BEGIN;\n\t\t\teep_addr < ASC_EEP_MAX_WORD_ADDR;\n\t\t\teep_addr++, wbuf++) {\n\t\t*wbuf = AdvReadEEPWord(iot, ioh, eep_addr);\n\t}\n\n\treturn chksum;\n}",
          "includes": [
            "#include <dev/ic/adwmcode.h>",
            "#include <dev/ic/adw.h>",
            "#include <dev/ic/adwlib.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/queue.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u_int16_t AdvGet3550EEPConfig",
            "static u_int16_t AdvReadEEPWord",
            "bus_space_tag_t iot = sc->sc_iot;",
            "bus_space_handle_t ioh = sc->sc_ioh;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/adwmcode.h>\n#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic u_int16_t AdvGet3550EEPConfig;\nstatic u_int16_t AdvReadEEPWord;\nbus_space_tag_t iot = sc->sc_iot;\nbus_space_handle_t ioh = sc->sc_ioh;\n\nstatic u_int16_t\nAdvGet3550EEPConfig(iot, ioh, cfg_buf)\n\tbus_space_tag_t\t\tiot;\n\tbus_space_handle_t\tioh;\n\tADW_EEP_3550_CONFIG\t*cfg_buf;\n{\n\tu_int16_t\t       wval, chksum;\n\tu_int16_t\t       *wbuf;\n\tint\t\t    eep_addr;\n\n\n\twbuf = (u_int16_t *) cfg_buf;\n\tchksum = 0;\n\n\tfor (eep_addr = ASC_EEP_DVC_CFG_BEGIN;\n\t\t\teep_addr < ASC_EEP_DVC_CFG_END;\n\t\t\teep_addr++, wbuf++) {\n\t\twval = AdvReadEEPWord(iot, ioh, eep_addr);\n\t\tchksum += wval;\n\t\t*wbuf = wval;\n\t}\n\n\t*wbuf = AdvReadEEPWord(iot, ioh, eep_addr);\n\twbuf++;\n\tfor (eep_addr = ASC_EEP_DVC_CTL_BEGIN;\n\t\t\teep_addr < ASC_EEP_MAX_WORD_ADDR;\n\t\t\teep_addr++, wbuf++) {\n\t\t*wbuf = AdvReadEEPWord(iot, ioh, eep_addr);\n\t}\n\n\treturn chksum;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/adwmcode.h>\n#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic u_int16_t AdvGet3550EEPConfig;\nstatic u_int16_t AdvReadEEPWord;\nstatic void AdvSet3550EEPConfig;\nstatic ADW_EEP_3550_CONFIG\nDefault_3550_EEPROM_Config = {\n\tADW_EEPROM_BIOS_ENABLE,\t/* cfg_lsw */\n\t0x0000,\t\t\t/* cfg_msw */\n\t0xFFFF,\t\t\t/* disc_enable */\n\t0xFFFF,\t\t\t/* wdtr_able */\n\t0xFFFF,\t\t\t/* sdtr_able */\n\t0xFFFF,\t\t\t/* start_motor */\n\t0xFFFF,\t\t\t/* tagqng_able */\n\t0xFFFF,\t\t\t/* bios_scan */\n\t0,\t\t\t/* scam_tolerant */\n\t7,\t\t\t/* adapter_scsi_id */\n\t0,\t\t\t/* bios_boot_delay */\n\t3,\t\t\t/* scsi_reset_delay */\n\t0,\t\t\t/* bios_id_lun */\n\t0,\t\t\t/* termination */\n\t0,\t\t\t/* reserved1 */\n\t0xFFE7,\t\t\t/* bios_ctrl */\n\t0xFFFF,\t\t\t/* ultra_able */\n\t0,\t\t\t/* reserved2 */\n\tASC_DEF_MAX_HOST_QNG,\t/* max_host_qng */\n\tASC_DEF_MAX_DVC_QNG,\t/* max_dvc_qng */\n\t0,\t\t\t/* dvc_cntl */\n\t0,\t\t\t/* bug_fix */\n\t0,\t\t\t/* serial_number_word1 */\n\t0,\t\t\t/* serial_number_word2 */\n\t0,\t\t\t/* serial_number_word3 */\n\t0,\t\t\t/* check_sum */\n\t{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, /* oem_name[16] */\n\t0,\t\t\t/* dvc_err_code */\n\t0,\t\t\t/* adv_err_code */\n\t0,\t\t\t/* adv_err_addr */\n\t0,\t\t\t/* saved_dvc_err_code */\n\t0,\t\t\t/* saved_adv_err_code */\n\t0,\t\t\t/* saved_adv_err_addr */\n\t0\t\t\t/* num_of_err */\n};\nADW_SOFTC\t*sc;\nbus_space_tag_t iot = sc->sc_iot;\nbus_space_handle_t ioh = sc->sc_ioh;\n\nint\nAdvInitFrom3550EEP(sc)\nADW_SOFTC      *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tu_int16_t\t\twarn_code;\n\tADW_EEP_3550_CONFIG\teep_config;\n\tint\t\t\ti;\n\n\n\twarn_code = 0;\n\n\t/*\n\t * Read the board's EEPROM configuration.\n\t *\n\t * Set default values if a bad checksum is found.\n\t */\n\tif (AdvGet3550EEPConfig(iot, ioh, &eep_config) != eep_config.check_sum){\n\t\twarn_code |= ASC_WARN_EEPROM_CHKSUM;\n\n\t\t/*\n\t\t * Set EEPROM default values.\n\t\t */\n\t\tfor (i = 0; i < sizeof(ADW_EEP_3550_CONFIG); i++) {\n\t\t\t*((u_int8_t *) &eep_config + i) =\n\t\t\t\t*((u_int8_t *) &Default_3550_EEPROM_Config + i);\n\t\t}\n\n\t\t/*\n\t\t * Assume the 6 byte board serial number that was read\n\t\t * from EEPROM is correct even if the EEPROM checksum\n\t\t * failed.\n\t\t */\n\t\teep_config.serial_number_word3 =\n\t\t\tAdvReadEEPWord(iot, ioh, ASC_EEP_DVC_CFG_END - 1);\n\n\t\teep_config.serial_number_word2 =\n\t\t\tAdvReadEEPWord(iot, ioh, ASC_EEP_DVC_CFG_END - 2);\n\n\t\teep_config.serial_number_word1 =\n\t\t\tAdvReadEEPWord(iot, ioh, ASC_EEP_DVC_CFG_END - 3);\n\n\t\tAdvSet3550EEPConfig(iot, ioh, &eep_config);\n\t}\n\t/*\n\t * Set sc_VAR and sc_CFG variables from the\n\t * EEPROM configuration that was read.\n\t *\n\t * This is the mapping of EEPROM fields to Adv Library fields.\n\t */\n\tsc->wdtr_able = eep_config.wdtr_able;\n\tsc->sdtr_able = eep_config.sdtr_able;\n\tsc->ultra_able = eep_config.ultra_able;\n\tsc->tagqng_able = eep_config.tagqng_able;\n\tsc->cfg.disc_enable = eep_config.disc_enable;\n\tsc->max_host_qng = eep_config.max_host_qng;\n\tsc->max_dvc_qng = eep_config.max_dvc_qng;\n\tsc->chip_scsi_id = (eep_config.adapter_scsi_id & ADW_MAX_TID);\n\tsc->start_motor = eep_config.start_motor;\n\tsc->scsi_reset_wait = eep_config.scsi_reset_delay;\n\tsc->bios_ctrl = eep_config.bios_ctrl;\n\tsc->no_scam = eep_config.scam_tolerant;\n\tsc->cfg.serial1 = eep_config.serial_number_word1;\n\tsc->cfg.serial2 = eep_config.serial_number_word2;\n\tsc->cfg.serial3 = eep_config.serial_number_word3;\n\n\t/*\n\t * Set the host maximum queuing (max. 253, min. 16) and the per device\n\t * maximum queuing (max. 63, min. 4).\n\t */\n\tif (eep_config.max_host_qng > ASC_DEF_MAX_HOST_QNG) {\n\t\teep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;\n\t} else if (eep_config.max_host_qng < ASC_DEF_MIN_HOST_QNG)\n\t{\n\t\t/* If the value is zero, assume it is uninitialized. */\n\t\tif (eep_config.max_host_qng == 0) {\n\t\t\teep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;\n\t\t} else {\n\t\t\teep_config.max_host_qng = ASC_DEF_MIN_HOST_QNG;\n\t\t}\n\t}\n\n\tif (eep_config.max_dvc_qng > ASC_DEF_MAX_DVC_QNG) {\n\t\teep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;\n\t} else if (eep_config.max_dvc_qng < ASC_DEF_MIN_DVC_QNG) {\n\t\t/* If the value is zero, assume it is uninitialized. */\n\t\tif (eep_config.max_dvc_qng == 0) {\n\t\t\teep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;\n\t\t} else {\n\t\t\teep_config.max_dvc_qng = ASC_DEF_MIN_DVC_QNG;\n\t\t}\n\t}\n\n\t/*\n\t * If 'max_dvc_qng' is greater than 'max_host_qng', then\n\t * set 'max_dvc_qng' to 'max_host_qng'.\n\t */\n\tif (eep_config.max_dvc_qng > eep_config.max_host_qng) {\n\t\teep_config.max_dvc_qng = eep_config.max_host_qng;\n\t}\n\n\t/*\n\t * Set ADV_DVC_VAR 'max_host_qng' and ADV_DVC_VAR 'max_dvc_qng'\n\t * values based on possibly adjusted EEPROM values.\n\t */\n\tsc->max_host_qng = eep_config.max_host_qng;\n\tsc->max_dvc_qng = eep_config.max_dvc_qng;\n\n\n\t/*\n\t * If the EEPROM 'termination' field is set to automatic (0), then set\n\t * the ADV_DVC_CFG 'termination' field to automatic also.\n\t *\n\t * If the termination is specified with a non-zero 'termination'\n\t * value check that a legal value is set and set the ADV_DVC_CFG\n\t * 'termination' field appropriately.\n\t */\n\tif (eep_config.termination == 0) {\n\t\tsc->cfg.termination = 0;    /* auto termination */\n\t} else {\n\t\t/* Enable manual control with low off / high off. */\n\t\tif (eep_config.termination == 1) {\n\t\t\tsc->cfg.termination = ADW_TERM_CTL_SEL;\n\n\t\t/* Enable manual control with low off / high on. */\n\t\t} else if (eep_config.termination == 2) {\n\t\t\tsc->cfg.termination = ADW_TERM_CTL_SEL | ADW_TERM_CTL_H;\n\n\t\t/* Enable manual control with low on / high on. */\n\t\t} else if (eep_config.termination == 3) {\n\t\t\tsc->cfg.termination = ADW_TERM_CTL_SEL |\n\t\t\t\t\tADW_TERM_CTL_H | ADW_TERM_CTL_L;\n\t\t} else {\n\t\t\t/*\n\t\t\t * The EEPROM 'termination' field contains a bad value. Use\n\t\t\t * automatic termination instead.\n\t\t\t */\n\t\t\tsc->cfg.termination = 0;\n\t\t\twarn_code |= ASC_WARN_EEPROM_TERMINATION;\n\t\t}\n\t}\n\n\treturn warn_code;\n}"
  },
  {
    "function_name": "AdvInitAsc38C0800Driver",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adwlib.c",
    "lines": "723-1250",
    "snippet": "int\nAdvInitAsc38C0800Driver(sc)\nADW_SOFTC      *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tu_int16_t\twarn_code;\n\tu_int32_t\tsum;\n\tint\t  \tbegin_addr;\n\tint\t   \tend_addr;\n\tu_int16_t\tcode_sum;\n\tint\t   \tword;\n\tint\t   \ti, j;\n\tint\t   \tadv_asc38C0800_expanded_size;\n\tu_int16_t\tscsi_cfg1;\n\tu_int8_t\tbyte;\n\tu_int8_t\ttid;\n\tu_int16_t\tbios_mem[ASC_MC_BIOSLEN/2];\t/* BIOS RISC Memory\n\t\t\t\t\t\t\t\t0x40-0x8F. */\n\tu_int16_t\twdtr_able, sdtr_able, tagqng_able;\n\tu_int8_t\tmax_cmd[ADW_MAX_TID + 1];\n\n\n\twarn_code = 0;\n\n\t/*\n\t * Save the RISC memory BIOS region before writing the microcode.\n\t * The BIOS may already be loaded and using its RISC LRAM region\n\t * so its region must be saved and restored.\n\t *\n\t * Note: This code makes the assumption, which is currently true,\n\t * that a chip reset does not clear RISC LRAM.\n\t */\n\tfor (i = 0; i < ASC_MC_BIOSLEN/2; i++) {\n\t    ADW_READ_WORD_LRAM(iot, ioh, ASC_MC_BIOSMEM + (2 * i), bios_mem[i]);\n\t}\n\n\t/*\n\t * Save current per TID negotiated values.\n\t */\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_WDTR_ABLE, wdtr_able);\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_SDTR_ABLE, sdtr_able);\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_TAGQNG_ABLE, tagqng_able);\n\tfor (tid = 0; tid <= ADW_MAX_TID; tid++) {\n\t\tADW_READ_BYTE_LRAM(iot, ioh, ASC_MC_NUMBER_OF_MAX_CMD + tid,\n\t\t\tmax_cmd[tid]);\n\t}\n\n\t/*\n\t * RAM BIST (RAM Built-In Self Test)\n\t *\n\t * Address : I/O base + offset 0x38h register (byte).\n\t * Function: Bit 7-6(RW) : RAM mode\n\t *\t\t\t    Normal Mode   : 0x00\n\t *\t\t\t    Pre-test Mode : 0x40\n\t *\t\t\t    RAM Test Mode : 0x80\n\t *\t     Bit 5\t : unused\n\t *\t     Bit 4(RO)   : Done bit\n\t *\t     Bit 3-0(RO) : Status\n\t *\t\t\t    Host Error    : 0x08\n\t *\t\t\t    Int_RAM Error : 0x04\n\t *\t\t\t    RISC Error    : 0x02\n\t *\t\t\t    SCSI Error    : 0x01\n\t *\t\t\t    No Error\t  : 0x00\n\t *\n\t * Note: RAM BIST code should be put right here, before loading the\n\t * microcode and after saving the RISC memory BIOS region.\n\t */\n\n\t/*\n\t * LRAM Pre-test\n\t *\n\t * Write PRE_TEST_MODE (0x40) to register and wait for 10 milliseconds.\n\t * If Done bit not set or low nibble not PRE_TEST_VALUE (0x05), return\n\t * an error. Reset to NORMAL_MODE (0x00) and do again. If cannot reset\n\t * to NORMAL_MODE, return an error too.\n\t */\n\tfor (i = 0; i < 2; i++) {\n\t\tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_RAM_BIST, PRE_TEST_MODE);\n\t\tAdvSleepMilliSecond(10);  /* Wait for 10ms before reading back. */\n\t\tbyte = ADW_READ_BYTE_REGISTER(iot, ioh, IOPB_RAM_BIST);\n\t\tif ((byte & RAM_TEST_DONE) == 0 || (byte & 0x0F) !=\n\t\t\t\tPRE_TEST_VALUE) {\n\t\t\treturn ASC_IERR_BIST_PRE_TEST;\n\t\t}\n\n\t\tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_RAM_BIST, NORMAL_MODE);\n\t\tAdvSleepMilliSecond(10);  /* Wait for 10ms before reading back. */\n\t\tif (ADW_READ_BYTE_REGISTER(iot, ioh, IOPB_RAM_BIST)\n\t\t    != NORMAL_VALUE) {\n\t\t\treturn ASC_IERR_BIST_PRE_TEST;\n\t\t}\n\t}\n\n\t/*\n\t * LRAM Test - It takes about 1.5 ms to run through the test.\n\t *\n\t * Write RAM_TEST_MODE (0x80) to register and wait for 10 milliseconds.\n\t * If Done bit not set or Status not 0, save register byte, set the\n\t * err_code, and return an error.\n\t */\n\tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_RAM_BIST, RAM_TEST_MODE);\n\tAdvSleepMilliSecond(10);  /* Wait for 10ms before checking status. */\n\n\tbyte = ADW_READ_BYTE_REGISTER(iot, ioh, IOPB_RAM_BIST);\n\tif ((byte & RAM_TEST_DONE) == 0 || (byte & RAM_TEST_STATUS) != 0) {\n\t\t/* Get here if Done bit not set or Status not 0. */\n\t\treturn ASC_IERR_BIST_RAM_TEST;\n\t}\n\n\t/* We need to reset back to normal mode after LRAM test passes. */\n\tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_RAM_BIST, NORMAL_MODE);\n\n\t/*\n\t * Load the Microcode\n\t *\n\t * Write the microcode image to RISC memory starting at address 0.\n\t *\n\t */\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_RAM_ADDR, 0);\n\n\t/* Assume the following compressed format of the microcode buffer:\n\t *\n\t *  254 word (508 byte) table indexed by byte code followed\n\t *  by the following byte codes:\n\t *\n\t *    1-Byte Code:\n\t *\t00: Emit word 0 in table.\n\t *\t01: Emit word 1 in table.\n\t *\t.\n\t *\tFD: Emit word 253 in table.\n\t *\n\t *    Multi-Byte Code:\n\t *\tFE WW WW: (3 byte code) Word to emit is the next word WW WW.\n\t *\tFF BB WW WW: (4 byte code) Emit BB count times next word WW WW.\n\t */\n\tword = 0;\n\tfor (i = 253 * 2; i < adv_asc38C0800_mcode_size; i++) {\n\t\tif (adv_asc38C0800_mcode[i] == 0xff) {\n\t\t\tfor (j = 0; j < adv_asc38C0800_mcode[i + 1]; j++) {\n\t\t\t\tADW_WRITE_WORD_AUTO_INC_LRAM(iot, ioh,\n\t\t\t\t    (((u_int16_t)\n\t\t\t\t    adv_asc38C0800_mcode[i + 3] << 8) |\n\t\t\t\t    adv_asc38C0800_mcode[i + 2]));\n\t\t\t\tword++;\n\t\t\t}\n\t\t\ti += 3;\n\t\t} else if (adv_asc38C0800_mcode[i] == 0xfe) {\n\t\t\tADW_WRITE_WORD_AUTO_INC_LRAM(iot, ioh, (((u_int16_t)\n\t\t\t    adv_asc38C0800_mcode[i + 2] << 8) |\n\t\t\t    adv_asc38C0800_mcode[i + 1]));\n\t\t\ti += 2;\n\t\t\tword++;\n\t\t} else {\n\t\t\tADW_WRITE_WORD_AUTO_INC_LRAM(iot, ioh, (((u_int16_t)\n\t\t\t  adv_asc38C0800_mcode[(adv_asc38C0800_mcode[i] * 2) + 1] << 8) |\n\t\t\t  adv_asc38C0800_mcode[adv_asc38C0800_mcode[i] * 2]));\n\t\t\tword++;\n\t\t}\n\t}\n\n\t/*\n\t * Set 'word' for later use to clear the rest of memory and save\n\t * the expanded mcode size.\n\t */\n\tword *= 2;\n\tadv_asc38C0800_expanded_size = word;\n\n\t/*\n\t * Clear the rest of ASC-38C0800 Internal RAM (16KB).\n\t */\n\tfor (; word < ADV_38C0800_MEMSIZE; word += 2) {\n\t\tADW_WRITE_WORD_AUTO_INC_LRAM(iot, ioh, 0);\n\t}\n\n\t/*\n\t * Verify the microcode checksum.\n\t */\n\tsum = 0;\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_RAM_ADDR, 0);\n\n\tfor (word = 0; word < adv_asc38C0800_expanded_size; word += 2) {\n\t\tsum += ADW_READ_WORD_AUTO_INC_LRAM(iot, ioh);\n\t}\n\n\tif (sum != adv_asc38C0800_mcode_chksum) {\n\t    return ASC_IERR_MCODE_CHKSUM;\n\t}\n\n\t/*\n\t * Restore the RISC memory BIOS region.\n\t */\n\tfor (i = 0; i < ASC_MC_BIOSLEN/2; i++) {\n\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_BIOSMEM + (2 * i),\n\t\t\t\tbios_mem[i]);\n\t}\n\n\t/*\n\t * Calculate and write the microcode code checksum to the microcode\n\t * code checksum location ASC_MC_CODE_CHK_SUM (0x2C).\n\t */\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_CODE_BEGIN_ADDR, begin_addr);\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_CODE_END_ADDR, end_addr);\n\tcode_sum = 0;\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_RAM_ADDR, begin_addr);\n\tfor (word = begin_addr; word < end_addr; word += 2) {\n\t\tcode_sum += ADW_READ_WORD_AUTO_INC_LRAM(iot, ioh);\n\t}\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_CODE_CHK_SUM, code_sum);\n\n\t/*\n\t * Read microcode version and date.\n\t */\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_VERSION_DATE,\n\t\t\tsc->cfg.mcode_date);\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_VERSION_NUM,\n\t\t\tsc->cfg.mcode_version);\n\n\t/*\n\t * Set the chip type to indicate the ASC38C0800.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_CHIP_TYPE, ADV_CHIP_ASC38C0800);\n\n\t/*\n\t * Write 1 to bit 14 'DIS_TERM_DRV' in the SCSI_CFG1 register.\n\t * When DIS_TERM_DRV set to 1, C_DET[3:0] will reflect current\n\t * cable detection and then we are able to read C_DET[3:0].\n\t *\n\t * Note: We will reset DIS_TERM_DRV to 0 in the 'Set SCSI_CFG1\n\t * Microcode Default Value' section below.\n\t */\n\tscsi_cfg1 = ADW_READ_WORD_REGISTER(iot, ioh, IOPW_SCSI_CFG1);\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_SCSI_CFG1,\n\t\t\tscsi_cfg1 | ADW_DIS_TERM_DRV);\n\n\t/*\n\t * If the PCI Configuration Command Register \"Parity Error Response\n\t * Control\" Bit was clear (0), then set the microcode variable\n\t * 'control_flag' CONTROL_FLAG_IGNORE_PERR flag to tell the microcode\n\t * to ignore DMA parity errors.\n\t */\n\tif (sc->cfg.control_flag & CONTROL_FLAG_IGNORE_PERR) {\n\t\t/*\n\t\t * Note: Don't remove the use of a temporary variable in\n\t\t * the following code, otherwise some C compiler\n\t\t * might turn the following lines into a no-op.\n\t\t */\n\t\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_CONTROL_FLAG, word);\n\t\tword |= CONTROL_FLAG_IGNORE_PERR;\n\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_CONTROL_FLAG, word);\n\t}\n\n\t/*\n\t * For ASC-38C0800, set FIFO_THRESH_80B [6:4] bits and START_CTL_TH [3:2]\n\t * bits for the default FIFO threshold.\n\t *\n\t * Note: ASC-38C0800 FIFO threshold has been changed to 256 bytes.\n\t *\n\t * For DMA Errata #4 set the BC_THRESH_ENB bit.\n\t */\n\tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_DMA_CFG0,\n\t\tBC_THRESH_ENB | FIFO_THRESH_80B | START_CTL_TH | READ_CMD_MRM);\n\n\t/*\n\t * Microcode operating variables for WDTR, SDTR, and command tag\n\t * queuing will be set in AdvInquiryHandling() based on what a\n\t * device reports it is capable of in Inquiry byte 7.\n\t *\n\t * If SCSI Bus Resets have been disabled, then directly set\n\t * SDTR and WDTR from the EEPROM configuration. This will allow\n\t * the BIOS and warm boot to work without a SCSI bus hang on\n\t * the Inquiry caused by host and target mismatched DTR values.\n\t * Without the SCSI Bus Reset, before an Inquiry a device can't\n\t * be assumed to be in Asynchronous, Narrow mode.\n\t */\n\tif ((sc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS) == 0) {\n\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_WDTR_ABLE, sc->wdtr_able);\n\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_ABLE, sc->sdtr_able);\n\t}\n\n\t/*\n\t * Set microcode operating variables for DISC and SDTR_SPEED1,\n\t * SDTR_SPEED2, SDTR_SPEED3, and SDTR_SPEED4 based on the EEPROM\n\t * configuration values.\n\t *\n\t * The SDTR per TID bitmask overrides the SDTR_SPEED1, SDTR_SPEED2,\n\t * SDTR_SPEED3, and SDTR_SPEED4 values so it is safe to set them\n\t * without determining here whether the device supports SDTR.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DISC_ENABLE, sc->cfg.disc_enable);\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_SPEED1, sc->sdtr_speed1);\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_SPEED2, sc->sdtr_speed2);\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_SPEED3, sc->sdtr_speed3);\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_SPEED4, sc->sdtr_speed4);\n\n\t/*\n\t * Set SCSI_CFG0 Microcode Default Value.\n\t *\n\t * The microcode will set the SCSI_CFG0 register using this value\n\t * after it is started below.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DEFAULT_SCSI_CFG0,\n\t\tADW_PARITY_EN | ADW_SEL_TMO_LONG | ADW_OUR_ID_EN |\n\t\t\tsc->chip_scsi_id);\n\n\t/*\n\t * Determine SCSI_CFG1 Microcode Default Value.\n\t *\n\t * The microcode will set the SCSI_CFG1 register using this value\n\t * after it is started below.\n\t */\n\n\t/* Read current SCSI_CFG1 Register value. */\n\tscsi_cfg1 = ADW_READ_WORD_REGISTER(iot, ioh, IOPW_SCSI_CFG1);\n\n\t/*\n\t * If the internal narrow cable is reversed all of the SCSI_CTRL\n\t * register signals will be set. Check for and return an error if\n\t * this condition is found.\n\t */\n\tif ((ADW_READ_WORD_REGISTER(iot, ioh, IOPW_SCSI_CTRL) & 0x3F07) ==\n\t\t\t0x3F07) {\n\t\treturn ASC_IERR_REVERSED_CABLE;\n\t}\n\n\t/*\n\t * All kind of combinations of devices attached to one of four connectors\n\t * are acceptable except HVD device attached. For example, LVD device can\n\t * be attached to SE connector while SE device attached to LVD connector.\n\t * If LVD device attached to SE connector, it only runs up to Ultra speed.\n\t *\n\t * If an HVD device is attached to one of LVD connectors, return an error.\n\t * However, there is no way to detect HVD device attached to SE connectors.\n\t */\n\tif (scsi_cfg1 & ADW_HVD) {\n\t\treturn ASC_IERR_HVD_DEVICE;\n\t}\n\n\t/*\n\t * If either SE or LVD automatic termination control is enabled, then\n\t * set the termination value based on a table listed in a_condor.h.\n\t *\n\t * If manual termination was specified with an EEPROM setting then\n\t * 'termination' was set-up in AdvInitFrom38C0800EEPROM() and is ready to\n\t * be 'ored' into SCSI_CFG1.\n\t */\n\tif ((sc->cfg.termination & ADW_TERM_SE) == 0) {\n\t\t/* SE automatic termination control is enabled. */\n\t\tswitch(scsi_cfg1 & ADW_C_DET_SE) {\n\t\t\t/* TERM_SE_HI: on, TERM_SE_LO: on */\n\t\t\tcase 0x1: case 0x2: case 0x3:\n\t\t\t\tsc->cfg.termination |= ADW_TERM_SE;\n\t\t\t\tbreak;\n\n\t\t\t/* TERM_SE_HI: on, TERM_SE_LO: off */\n\t\t\tcase 0x0:\n\t\t\t\tsc->cfg.termination |= ADW_TERM_SE_HI;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ((sc->cfg.termination & ADW_TERM_LVD) == 0) {\n\t\t/* LVD automatic termination control is enabled. */\n\t\tswitch(scsi_cfg1 & ADW_C_DET_LVD) {\n\t\t\t/* TERM_LVD_HI: on, TERM_LVD_LO: on */\n\t\t\tcase 0x4: case 0x8: case 0xC:\n\t\t\t\tsc->cfg.termination |= ADW_TERM_LVD;\n\t\t\t\tbreak;\n\n\t\t\t/* TERM_LVD_HI: off, TERM_LVD_LO: off */\n\t\t\tcase 0x0:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * Clear any set TERM_SE and TERM_LVD bits.\n\t */\n\tscsi_cfg1 &= (~ADW_TERM_SE & ~ADW_TERM_LVD);\n\n\t/*\n\t * Invert the TERM_SE and TERM_LVD bits and then set 'scsi_cfg1'.\n\t */\n\tscsi_cfg1 |= (~sc->cfg.termination & 0xF0);\n\n\t/*\n\t * Clear BIG_ENDIAN, DIS_TERM_DRV, Terminator Polarity and HVD/LVD/SE bits\n\t * and set possibly modified termination control bits in the Microcode\n\t * SCSI_CFG1 Register Value.\n\t */\n\tscsi_cfg1 &= (~ADW_BIG_ENDIAN & ~ADW_DIS_TERM_DRV &\n\t\t\t~ADW_TERM_POL & ~ADW_HVD_LVD_SE);\n\n\t/*\n\t * Set SCSI_CFG1 Microcode Default Value\n\t *\n\t * Set possibly modified termination control and reset DIS_TERM_DRV\n\t * bits in the Microcode SCSI_CFG1 Register Value.\n\t *\n\t * The microcode will set the SCSI_CFG1 register using this value\n\t * after it is started below.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DEFAULT_SCSI_CFG1, scsi_cfg1);\n\n\t/*\n\t * Set MEM_CFG Microcode Default Value\n\t *\n\t * The microcode will set the MEM_CFG register using this value\n\t * after it is started below.\n\t *\n\t * MEM_CFG may be accessed as a word or byte, but only bits 0-7\n\t * are defined.\n\t *\n\t * ASC-38C0800 has 16KB internal memory.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DEFAULT_MEM_CFG,\n\t\tADW_BIOS_EN | ADW_RAM_SZ_16KB);\n\n\t/*\n\t * Set SEL_MASK Microcode Default Value\n\t *\n\t * The microcode will set the SEL_MASK register using this value\n\t * after it is started below.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DEFAULT_SEL_MASK,\n\t\tADW_TID_TO_TIDMASK(sc->chip_scsi_id));\n\n\n\t/*\n\t * Set-up the Host->RISC Initiator Command Queue (ICQ) if\n\t * one is not already set up, i.e. this is the first\n\t * time through as opposed to a bus reset.\n\t */\n\n\tif (sc->icq_sp == NULL) {\n\t\tsc->carr_pending_cnt = 0;\n\t\tif ((sc->icq_sp = sc->carr_freelist) == NULL) {\n\t\t\treturn ASC_IERR_NO_CARRIER;\n\t\t}\n\t\tsc->carr_freelist = adw_carrier_phys_kv(sc,\n\t\t\t\tASC_GET_CARRP(sc->icq_sp->next_vpa));\n\n\n\t\t/*\n\t \t * The first command issued will be placed in the stopper carrier.\n\t \t */\n\t\tsc->icq_sp->next_vpa = ASC_CQ_STOPPER;\n\t}\n\n\t/*\n\t * Set RISC ICQ physical address start value.\n\t */\n\tADW_WRITE_DWORD_LRAM(iot, ioh, ASC_MC_ICQ, sc->icq_sp->carr_pa);\n\n\t/*\n\t * Set-up the RISC->Host Initiator Response Queue (IRQ) if\n\t * one is not already set up, i.e. this is the first\n\t * time through as opposed to a bus reset.\n\t */\n\tif (sc->irq_sp == NULL) {\n\t\tif ((sc->irq_sp = sc->carr_freelist) == NULL) {\n\t\t\treturn ASC_IERR_NO_CARRIER;\n\t\t}\n\t\tsc->carr_freelist = adw_carrier_phys_kv(sc,\n\t\t\t\tASC_GET_CARRP(sc->irq_sp->next_vpa));\n\n\t\t/*\n\t \t * The first command completed by the RISC will be placed in\n\t \t * the stopper.\n\t \t *\n\t \t * Note: Set 'next_vpa' to ASC_CQ_STOPPER. When the request is\n\t \t * completed the RISC will set the ASC_RQ_DONE bit.\n\t \t */\n\t\tsc->irq_sp->next_vpa = ASC_CQ_STOPPER;\n\t}\n\n\t/*\n\t * Set RISC IRQ physical address start value.\n\t */\n\tADW_WRITE_DWORD_LRAM(iot, ioh, ASC_MC_IRQ, sc->irq_sp->carr_pa);\n\n\tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_INTR_ENABLES,\n\t\t(ADW_INTR_ENABLE_HOST_INTR | ADW_INTR_ENABLE_GLOBAL_INTR));\n\t/*\n\t * Note: Don't remove the use of a temporary variable in\n\t * the following code, otherwise some C compiler\n\t * might turn the following lines into a no-op.\n\t */\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_CODE_BEGIN_ADDR, word);\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_PC, word);\n\n\t/* finally, finally, gentlemen, start your engine */\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_RISC_CSR, ADW_RISC_CSR_RUN);\n\n\t/*\n\t * Reset the SCSI Bus if the EEPROM indicates that SCSI Bus\n\t * Resets should be performed. The RISC has to be running\n\t * to issue a SCSI Bus Reset.\n\t */\n\tif (sc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS) {\n\t\t/*\n\t\t * If the BIOS Signature is present in memory, restore the\n\t\t * BIOS Handshake Configuration Table and do not perform\n\t\t * a SCSI Bus Reset.\n\t\t */\n\t\tif (bios_mem[(ASC_MC_BIOS_SIGNATURE - ASC_MC_BIOSMEM)/2] ==\n\t\t\t\t0x55AA) {\n\t\t\t/*\n\t\t\t * Restore per TID negotiated values.\n\t\t\t */\n\t\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_WDTR_ABLE, wdtr_able);\n\t\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_ABLE, sdtr_able);\n\t\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_TAGQNG_ABLE,\n\t\t\t\t\ttagqng_able);\n\t\t\tfor (tid = 0; tid <= ADW_MAX_TID; tid++) {\n\t\t\t\tADW_WRITE_BYTE_LRAM(iot, ioh,\n\t\t\t\t\t\tASC_MC_NUMBER_OF_MAX_CMD + tid,\n\t\t\t\t\t\tmax_cmd[tid]);\n\t\t\t}\n\t\t} else {\n\t\t\tif (AdvResetCCB(sc) != ADW_TRUE) {\n\t\t\t\twarn_code = ASC_WARN_BUSRESET_ERROR;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn warn_code;\n}",
    "includes": [
      "#include <dev/ic/adwmcode.h>",
      "#include <dev/ic/adw.h>",
      "#include <dev/ic/adwlib.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/queue.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void AdvInquiryHandling",
      "static void AdvSleepMilliSecond",
      "ADW_SOFTC\t*sc;",
      "bus_space_tag_t iot = sc->sc_iot;",
      "bus_space_handle_t ioh = sc->sc_ioh;",
      "u_int8_t\t\ttid;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "AdvResetCCB",
          "args": [
            "sc"
          ],
          "line": 1243
        },
        "resolved": true,
        "details": {
          "function_name": "AdvResetCCB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adwlib.c",
          "lines": "2030-2067",
          "snippet": "int\nAdvResetCCB(sc)\nADW_SOFTC\t*sc;\n{\n\tint\t    status;\n\n\t/*\n\t * Send the SCSI Bus Reset idle start idle command which asserts\n\t * the SCSI Bus Reset signal.\n\t */\n\tstatus = AdvSendIdleCmd(sc, (u_int16_t) IDLE_CMD_SCSI_RESET_START, 0L);\n\tif (status != ADW_TRUE)\n\t{\n\t\treturn status;\n\t}\n\n\t/*\n\t * Delay for the specified SCSI Bus Reset hold time.\n\t *\n\t * The hold time delay is done on the host because the RISC has no\n\t * microsecond accurate timer.\n\t */\n\tAdvDelayMicroSecond((u_int16_t) ASC_SCSI_RESET_HOLD_TIME_US);\n\n\t/*\n\t * Send the SCSI Bus Reset end idle command which de-asserts\n\t * the SCSI Bus Reset signal and purges any pending requests.\n\t */\n\tstatus = AdvSendIdleCmd(sc, (u_int16_t) IDLE_CMD_SCSI_RESET_END, 0L);\n\tif (status != ADW_TRUE)\n\t{\n\t\treturn status;\n\t}\n\n\tAdvSleepMilliSecond((u_int32_t) sc->scsi_reset_wait * 1000);\n\n\treturn status;\n}",
          "includes": [
            "#include <dev/ic/adwmcode.h>",
            "#include <dev/ic/adw.h>",
            "#include <dev/ic/adwlib.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/queue.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void AdvSleepMilliSecond",
            "static void AdvDelayMicroSecond",
            "ADW_SOFTC\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/adwmcode.h>\n#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void AdvSleepMilliSecond;\nstatic void AdvDelayMicroSecond;\nADW_SOFTC\t*sc;\n\nint\nAdvResetCCB(sc)\nADW_SOFTC\t*sc;\n{\n\tint\t    status;\n\n\t/*\n\t * Send the SCSI Bus Reset idle start idle command which asserts\n\t * the SCSI Bus Reset signal.\n\t */\n\tstatus = AdvSendIdleCmd(sc, (u_int16_t) IDLE_CMD_SCSI_RESET_START, 0L);\n\tif (status != ADW_TRUE)\n\t{\n\t\treturn status;\n\t}\n\n\t/*\n\t * Delay for the specified SCSI Bus Reset hold time.\n\t *\n\t * The hold time delay is done on the host because the RISC has no\n\t * microsecond accurate timer.\n\t */\n\tAdvDelayMicroSecond((u_int16_t) ASC_SCSI_RESET_HOLD_TIME_US);\n\n\t/*\n\t * Send the SCSI Bus Reset end idle command which de-asserts\n\t * the SCSI Bus Reset signal and purges any pending requests.\n\t */\n\tstatus = AdvSendIdleCmd(sc, (u_int16_t) IDLE_CMD_SCSI_RESET_END, 0L);\n\tif (status != ADW_TRUE)\n\t{\n\t\treturn status;\n\t}\n\n\tAdvSleepMilliSecond((u_int32_t) sc->scsi_reset_wait * 1000);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_BYTE_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_NUMBER_OF_MAX_CMD + tid",
            "max_cmd[tid]"
          ],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_TAGQNG_ABLE",
            "tagqng_able"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_SDTR_ABLE",
            "sdtr_able"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_WDTR_ABLE",
            "wdtr_able"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_REGISTER",
          "args": [
            "iot",
            "ioh",
            "IOPW_RISC_CSR",
            "ADW_RISC_CSR_RUN"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_REGISTER",
          "args": [
            "iot",
            "ioh",
            "IOPW_PC",
            "word"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_READ_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_CODE_BEGIN_ADDR",
            "word"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_BYTE_REGISTER",
          "args": [
            "iot",
            "ioh",
            "IOPB_INTR_ENABLES",
            "(ADW_INTR_ENABLE_HOST_INTR | ADW_INTR_ENABLE_GLOBAL_INTR)"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_DWORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_IRQ",
            "sc->irq_sp->carr_pa"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adw_carrier_phys_kv",
          "args": [
            "sc",
            "ASC_GET_CARRP(sc->irq_sp->next_vpa)"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASC_GET_CARRP",
          "args": [
            "sc->irq_sp->next_vpa"
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_DWORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_ICQ",
            "sc->icq_sp->carr_pa"
          ],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adw_carrier_phys_kv",
          "args": [
            "sc",
            "ASC_GET_CARRP(sc->icq_sp->next_vpa)"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASC_GET_CARRP",
          "args": [
            "sc->icq_sp->next_vpa"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_DEFAULT_SEL_MASK",
            "ADW_TID_TO_TIDMASK(sc->chip_scsi_id)"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_TID_TO_TIDMASK",
          "args": [
            "sc->chip_scsi_id"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_DEFAULT_MEM_CFG",
            "ADW_BIOS_EN | ADW_RAM_SZ_16KB"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_DEFAULT_SCSI_CFG1",
            "scsi_cfg1"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_READ_WORD_REGISTER",
          "args": [
            "iot",
            "ioh",
            "IOPW_SCSI_CTRL"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_READ_WORD_REGISTER",
          "args": [
            "iot",
            "ioh",
            "IOPW_SCSI_CFG1"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_DEFAULT_SCSI_CFG0",
            "ADW_PARITY_EN | ADW_SEL_TMO_LONG | ADW_OUR_ID_EN |\n\t\t\tsc->chip_scsi_id"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_SDTR_SPEED4",
            "sc->sdtr_speed4"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_SDTR_SPEED3",
            "sc->sdtr_speed3"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_SDTR_SPEED2",
            "sc->sdtr_speed2"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_SDTR_SPEED1",
            "sc->sdtr_speed1"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_DISC_ENABLE",
            "sc->cfg.disc_enable"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_SDTR_ABLE",
            "sc->sdtr_able"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_WDTR_ABLE",
            "sc->wdtr_able"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_BYTE_REGISTER",
          "args": [
            "iot",
            "ioh",
            "IOPB_DMA_CFG0",
            "BC_THRESH_ENB | FIFO_THRESH_80B | START_CTL_TH | READ_CMD_MRM"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_CONTROL_FLAG",
            "word"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_READ_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_CONTROL_FLAG",
            "word"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_REGISTER",
          "args": [
            "iot",
            "ioh",
            "IOPW_SCSI_CFG1",
            "scsi_cfg1 | ADW_DIS_TERM_DRV"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_READ_WORD_REGISTER",
          "args": [
            "iot",
            "ioh",
            "IOPW_SCSI_CFG1"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_CHIP_TYPE",
            "ADV_CHIP_ASC38C0800"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_READ_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_VERSION_NUM",
            "sc->cfg.mcode_version"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_READ_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_VERSION_DATE",
            "sc->cfg.mcode_date"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_CODE_CHK_SUM",
            "code_sum"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_READ_WORD_AUTO_INC_LRAM",
          "args": [
            "iot",
            "ioh"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_REGISTER",
          "args": [
            "iot",
            "ioh",
            "IOPW_RAM_ADDR",
            "begin_addr"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_READ_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_CODE_END_ADDR",
            "end_addr"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_READ_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_CODE_BEGIN_ADDR",
            "begin_addr"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_BIOSMEM + (2 * i)",
            "bios_mem[i]"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_READ_WORD_AUTO_INC_LRAM",
          "args": [
            "iot",
            "ioh"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_REGISTER",
          "args": [
            "iot",
            "ioh",
            "IOPW_RAM_ADDR",
            "0"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_AUTO_INC_LRAM",
          "args": [
            "iot",
            "ioh",
            "0"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_AUTO_INC_LRAM",
          "args": [
            "iot",
            "ioh",
            "(((u_int16_t)\n\t\t\t  adv_asc38C0800_mcode[(adv_asc38C0800_mcode[i] * 2) + 1] << 8) |\n\t\t\t  adv_asc38C0800_mcode[adv_asc38C0800_mcode[i] * 2])"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_AUTO_INC_LRAM",
          "args": [
            "iot",
            "ioh",
            "(((u_int16_t)\n\t\t\t    adv_asc38C0800_mcode[i + 2] << 8) |\n\t\t\t    adv_asc38C0800_mcode[i + 1])"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_AUTO_INC_LRAM",
          "args": [
            "iot",
            "ioh",
            "(((u_int16_t)\n\t\t\t\t    adv_asc38C0800_mcode[i + 3] << 8) |\n\t\t\t\t    adv_asc38C0800_mcode[i + 2])"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_REGISTER",
          "args": [
            "iot",
            "ioh",
            "IOPW_RAM_ADDR",
            "0"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_BYTE_REGISTER",
          "args": [
            "iot",
            "ioh",
            "IOPB_RAM_BIST",
            "NORMAL_MODE"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_READ_BYTE_REGISTER",
          "args": [
            "iot",
            "ioh",
            "IOPB_RAM_BIST"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AdvSleepMilliSecond",
          "args": [
            "10"
          ],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "AdvSleepMilliSecond",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adwlib.c",
          "lines": "2552-2558",
          "snippet": "static void\nAdvSleepMilliSecond(n)\nu_int32_t\tn;\n{\n\n\tDELAY(n * 1000);\n}",
          "includes": [
            "#include <dev/ic/adwmcode.h>",
            "#include <dev/ic/adw.h>",
            "#include <dev/ic/adwlib.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/queue.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void AdvSleepMilliSecond"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/adwmcode.h>\n#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void AdvSleepMilliSecond;\n\nstatic void\nAdvSleepMilliSecond(n)\nu_int32_t\tn;\n{\n\n\tDELAY(n * 1000);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_BYTE_REGISTER",
          "args": [
            "iot",
            "ioh",
            "IOPB_RAM_BIST",
            "RAM_TEST_MODE"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_READ_BYTE_REGISTER",
          "args": [
            "iot",
            "ioh",
            "IOPB_RAM_BIST"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_BYTE_REGISTER",
          "args": [
            "iot",
            "ioh",
            "IOPB_RAM_BIST",
            "NORMAL_MODE"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_READ_BYTE_REGISTER",
          "args": [
            "iot",
            "ioh",
            "IOPB_RAM_BIST"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_BYTE_REGISTER",
          "args": [
            "iot",
            "ioh",
            "IOPB_RAM_BIST",
            "PRE_TEST_MODE"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_READ_BYTE_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_NUMBER_OF_MAX_CMD + tid",
            "max_cmd[tid]"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_READ_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_TAGQNG_ABLE",
            "tagqng_able"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_READ_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_SDTR_ABLE",
            "sdtr_able"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_READ_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_WDTR_ABLE",
            "wdtr_able"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_READ_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_BIOSMEM + (2 * i)",
            "bios_mem[i]"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/adwmcode.h>\n#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void AdvInquiryHandling;\nstatic void AdvSleepMilliSecond;\nADW_SOFTC\t*sc;\nbus_space_tag_t iot = sc->sc_iot;\nbus_space_handle_t ioh = sc->sc_ioh;\nu_int8_t\t\ttid;\n\nint\nAdvInitAsc38C0800Driver(sc)\nADW_SOFTC      *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tu_int16_t\twarn_code;\n\tu_int32_t\tsum;\n\tint\t  \tbegin_addr;\n\tint\t   \tend_addr;\n\tu_int16_t\tcode_sum;\n\tint\t   \tword;\n\tint\t   \ti, j;\n\tint\t   \tadv_asc38C0800_expanded_size;\n\tu_int16_t\tscsi_cfg1;\n\tu_int8_t\tbyte;\n\tu_int8_t\ttid;\n\tu_int16_t\tbios_mem[ASC_MC_BIOSLEN/2];\t/* BIOS RISC Memory\n\t\t\t\t\t\t\t\t0x40-0x8F. */\n\tu_int16_t\twdtr_able, sdtr_able, tagqng_able;\n\tu_int8_t\tmax_cmd[ADW_MAX_TID + 1];\n\n\n\twarn_code = 0;\n\n\t/*\n\t * Save the RISC memory BIOS region before writing the microcode.\n\t * The BIOS may already be loaded and using its RISC LRAM region\n\t * so its region must be saved and restored.\n\t *\n\t * Note: This code makes the assumption, which is currently true,\n\t * that a chip reset does not clear RISC LRAM.\n\t */\n\tfor (i = 0; i < ASC_MC_BIOSLEN/2; i++) {\n\t    ADW_READ_WORD_LRAM(iot, ioh, ASC_MC_BIOSMEM + (2 * i), bios_mem[i]);\n\t}\n\n\t/*\n\t * Save current per TID negotiated values.\n\t */\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_WDTR_ABLE, wdtr_able);\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_SDTR_ABLE, sdtr_able);\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_TAGQNG_ABLE, tagqng_able);\n\tfor (tid = 0; tid <= ADW_MAX_TID; tid++) {\n\t\tADW_READ_BYTE_LRAM(iot, ioh, ASC_MC_NUMBER_OF_MAX_CMD + tid,\n\t\t\tmax_cmd[tid]);\n\t}\n\n\t/*\n\t * RAM BIST (RAM Built-In Self Test)\n\t *\n\t * Address : I/O base + offset 0x38h register (byte).\n\t * Function: Bit 7-6(RW) : RAM mode\n\t *\t\t\t    Normal Mode   : 0x00\n\t *\t\t\t    Pre-test Mode : 0x40\n\t *\t\t\t    RAM Test Mode : 0x80\n\t *\t     Bit 5\t : unused\n\t *\t     Bit 4(RO)   : Done bit\n\t *\t     Bit 3-0(RO) : Status\n\t *\t\t\t    Host Error    : 0x08\n\t *\t\t\t    Int_RAM Error : 0x04\n\t *\t\t\t    RISC Error    : 0x02\n\t *\t\t\t    SCSI Error    : 0x01\n\t *\t\t\t    No Error\t  : 0x00\n\t *\n\t * Note: RAM BIST code should be put right here, before loading the\n\t * microcode and after saving the RISC memory BIOS region.\n\t */\n\n\t/*\n\t * LRAM Pre-test\n\t *\n\t * Write PRE_TEST_MODE (0x40) to register and wait for 10 milliseconds.\n\t * If Done bit not set or low nibble not PRE_TEST_VALUE (0x05), return\n\t * an error. Reset to NORMAL_MODE (0x00) and do again. If cannot reset\n\t * to NORMAL_MODE, return an error too.\n\t */\n\tfor (i = 0; i < 2; i++) {\n\t\tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_RAM_BIST, PRE_TEST_MODE);\n\t\tAdvSleepMilliSecond(10);  /* Wait for 10ms before reading back. */\n\t\tbyte = ADW_READ_BYTE_REGISTER(iot, ioh, IOPB_RAM_BIST);\n\t\tif ((byte & RAM_TEST_DONE) == 0 || (byte & 0x0F) !=\n\t\t\t\tPRE_TEST_VALUE) {\n\t\t\treturn ASC_IERR_BIST_PRE_TEST;\n\t\t}\n\n\t\tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_RAM_BIST, NORMAL_MODE);\n\t\tAdvSleepMilliSecond(10);  /* Wait for 10ms before reading back. */\n\t\tif (ADW_READ_BYTE_REGISTER(iot, ioh, IOPB_RAM_BIST)\n\t\t    != NORMAL_VALUE) {\n\t\t\treturn ASC_IERR_BIST_PRE_TEST;\n\t\t}\n\t}\n\n\t/*\n\t * LRAM Test - It takes about 1.5 ms to run through the test.\n\t *\n\t * Write RAM_TEST_MODE (0x80) to register and wait for 10 milliseconds.\n\t * If Done bit not set or Status not 0, save register byte, set the\n\t * err_code, and return an error.\n\t */\n\tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_RAM_BIST, RAM_TEST_MODE);\n\tAdvSleepMilliSecond(10);  /* Wait for 10ms before checking status. */\n\n\tbyte = ADW_READ_BYTE_REGISTER(iot, ioh, IOPB_RAM_BIST);\n\tif ((byte & RAM_TEST_DONE) == 0 || (byte & RAM_TEST_STATUS) != 0) {\n\t\t/* Get here if Done bit not set or Status not 0. */\n\t\treturn ASC_IERR_BIST_RAM_TEST;\n\t}\n\n\t/* We need to reset back to normal mode after LRAM test passes. */\n\tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_RAM_BIST, NORMAL_MODE);\n\n\t/*\n\t * Load the Microcode\n\t *\n\t * Write the microcode image to RISC memory starting at address 0.\n\t *\n\t */\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_RAM_ADDR, 0);\n\n\t/* Assume the following compressed format of the microcode buffer:\n\t *\n\t *  254 word (508 byte) table indexed by byte code followed\n\t *  by the following byte codes:\n\t *\n\t *    1-Byte Code:\n\t *\t00: Emit word 0 in table.\n\t *\t01: Emit word 1 in table.\n\t *\t.\n\t *\tFD: Emit word 253 in table.\n\t *\n\t *    Multi-Byte Code:\n\t *\tFE WW WW: (3 byte code) Word to emit is the next word WW WW.\n\t *\tFF BB WW WW: (4 byte code) Emit BB count times next word WW WW.\n\t */\n\tword = 0;\n\tfor (i = 253 * 2; i < adv_asc38C0800_mcode_size; i++) {\n\t\tif (adv_asc38C0800_mcode[i] == 0xff) {\n\t\t\tfor (j = 0; j < adv_asc38C0800_mcode[i + 1]; j++) {\n\t\t\t\tADW_WRITE_WORD_AUTO_INC_LRAM(iot, ioh,\n\t\t\t\t    (((u_int16_t)\n\t\t\t\t    adv_asc38C0800_mcode[i + 3] << 8) |\n\t\t\t\t    adv_asc38C0800_mcode[i + 2]));\n\t\t\t\tword++;\n\t\t\t}\n\t\t\ti += 3;\n\t\t} else if (adv_asc38C0800_mcode[i] == 0xfe) {\n\t\t\tADW_WRITE_WORD_AUTO_INC_LRAM(iot, ioh, (((u_int16_t)\n\t\t\t    adv_asc38C0800_mcode[i + 2] << 8) |\n\t\t\t    adv_asc38C0800_mcode[i + 1]));\n\t\t\ti += 2;\n\t\t\tword++;\n\t\t} else {\n\t\t\tADW_WRITE_WORD_AUTO_INC_LRAM(iot, ioh, (((u_int16_t)\n\t\t\t  adv_asc38C0800_mcode[(adv_asc38C0800_mcode[i] * 2) + 1] << 8) |\n\t\t\t  adv_asc38C0800_mcode[adv_asc38C0800_mcode[i] * 2]));\n\t\t\tword++;\n\t\t}\n\t}\n\n\t/*\n\t * Set 'word' for later use to clear the rest of memory and save\n\t * the expanded mcode size.\n\t */\n\tword *= 2;\n\tadv_asc38C0800_expanded_size = word;\n\n\t/*\n\t * Clear the rest of ASC-38C0800 Internal RAM (16KB).\n\t */\n\tfor (; word < ADV_38C0800_MEMSIZE; word += 2) {\n\t\tADW_WRITE_WORD_AUTO_INC_LRAM(iot, ioh, 0);\n\t}\n\n\t/*\n\t * Verify the microcode checksum.\n\t */\n\tsum = 0;\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_RAM_ADDR, 0);\n\n\tfor (word = 0; word < adv_asc38C0800_expanded_size; word += 2) {\n\t\tsum += ADW_READ_WORD_AUTO_INC_LRAM(iot, ioh);\n\t}\n\n\tif (sum != adv_asc38C0800_mcode_chksum) {\n\t    return ASC_IERR_MCODE_CHKSUM;\n\t}\n\n\t/*\n\t * Restore the RISC memory BIOS region.\n\t */\n\tfor (i = 0; i < ASC_MC_BIOSLEN/2; i++) {\n\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_BIOSMEM + (2 * i),\n\t\t\t\tbios_mem[i]);\n\t}\n\n\t/*\n\t * Calculate and write the microcode code checksum to the microcode\n\t * code checksum location ASC_MC_CODE_CHK_SUM (0x2C).\n\t */\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_CODE_BEGIN_ADDR, begin_addr);\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_CODE_END_ADDR, end_addr);\n\tcode_sum = 0;\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_RAM_ADDR, begin_addr);\n\tfor (word = begin_addr; word < end_addr; word += 2) {\n\t\tcode_sum += ADW_READ_WORD_AUTO_INC_LRAM(iot, ioh);\n\t}\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_CODE_CHK_SUM, code_sum);\n\n\t/*\n\t * Read microcode version and date.\n\t */\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_VERSION_DATE,\n\t\t\tsc->cfg.mcode_date);\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_VERSION_NUM,\n\t\t\tsc->cfg.mcode_version);\n\n\t/*\n\t * Set the chip type to indicate the ASC38C0800.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_CHIP_TYPE, ADV_CHIP_ASC38C0800);\n\n\t/*\n\t * Write 1 to bit 14 'DIS_TERM_DRV' in the SCSI_CFG1 register.\n\t * When DIS_TERM_DRV set to 1, C_DET[3:0] will reflect current\n\t * cable detection and then we are able to read C_DET[3:0].\n\t *\n\t * Note: We will reset DIS_TERM_DRV to 0 in the 'Set SCSI_CFG1\n\t * Microcode Default Value' section below.\n\t */\n\tscsi_cfg1 = ADW_READ_WORD_REGISTER(iot, ioh, IOPW_SCSI_CFG1);\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_SCSI_CFG1,\n\t\t\tscsi_cfg1 | ADW_DIS_TERM_DRV);\n\n\t/*\n\t * If the PCI Configuration Command Register \"Parity Error Response\n\t * Control\" Bit was clear (0), then set the microcode variable\n\t * 'control_flag' CONTROL_FLAG_IGNORE_PERR flag to tell the microcode\n\t * to ignore DMA parity errors.\n\t */\n\tif (sc->cfg.control_flag & CONTROL_FLAG_IGNORE_PERR) {\n\t\t/*\n\t\t * Note: Don't remove the use of a temporary variable in\n\t\t * the following code, otherwise some C compiler\n\t\t * might turn the following lines into a no-op.\n\t\t */\n\t\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_CONTROL_FLAG, word);\n\t\tword |= CONTROL_FLAG_IGNORE_PERR;\n\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_CONTROL_FLAG, word);\n\t}\n\n\t/*\n\t * For ASC-38C0800, set FIFO_THRESH_80B [6:4] bits and START_CTL_TH [3:2]\n\t * bits for the default FIFO threshold.\n\t *\n\t * Note: ASC-38C0800 FIFO threshold has been changed to 256 bytes.\n\t *\n\t * For DMA Errata #4 set the BC_THRESH_ENB bit.\n\t */\n\tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_DMA_CFG0,\n\t\tBC_THRESH_ENB | FIFO_THRESH_80B | START_CTL_TH | READ_CMD_MRM);\n\n\t/*\n\t * Microcode operating variables for WDTR, SDTR, and command tag\n\t * queuing will be set in AdvInquiryHandling() based on what a\n\t * device reports it is capable of in Inquiry byte 7.\n\t *\n\t * If SCSI Bus Resets have been disabled, then directly set\n\t * SDTR and WDTR from the EEPROM configuration. This will allow\n\t * the BIOS and warm boot to work without a SCSI bus hang on\n\t * the Inquiry caused by host and target mismatched DTR values.\n\t * Without the SCSI Bus Reset, before an Inquiry a device can't\n\t * be assumed to be in Asynchronous, Narrow mode.\n\t */\n\tif ((sc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS) == 0) {\n\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_WDTR_ABLE, sc->wdtr_able);\n\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_ABLE, sc->sdtr_able);\n\t}\n\n\t/*\n\t * Set microcode operating variables for DISC and SDTR_SPEED1,\n\t * SDTR_SPEED2, SDTR_SPEED3, and SDTR_SPEED4 based on the EEPROM\n\t * configuration values.\n\t *\n\t * The SDTR per TID bitmask overrides the SDTR_SPEED1, SDTR_SPEED2,\n\t * SDTR_SPEED3, and SDTR_SPEED4 values so it is safe to set them\n\t * without determining here whether the device supports SDTR.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DISC_ENABLE, sc->cfg.disc_enable);\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_SPEED1, sc->sdtr_speed1);\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_SPEED2, sc->sdtr_speed2);\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_SPEED3, sc->sdtr_speed3);\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_SPEED4, sc->sdtr_speed4);\n\n\t/*\n\t * Set SCSI_CFG0 Microcode Default Value.\n\t *\n\t * The microcode will set the SCSI_CFG0 register using this value\n\t * after it is started below.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DEFAULT_SCSI_CFG0,\n\t\tADW_PARITY_EN | ADW_SEL_TMO_LONG | ADW_OUR_ID_EN |\n\t\t\tsc->chip_scsi_id);\n\n\t/*\n\t * Determine SCSI_CFG1 Microcode Default Value.\n\t *\n\t * The microcode will set the SCSI_CFG1 register using this value\n\t * after it is started below.\n\t */\n\n\t/* Read current SCSI_CFG1 Register value. */\n\tscsi_cfg1 = ADW_READ_WORD_REGISTER(iot, ioh, IOPW_SCSI_CFG1);\n\n\t/*\n\t * If the internal narrow cable is reversed all of the SCSI_CTRL\n\t * register signals will be set. Check for and return an error if\n\t * this condition is found.\n\t */\n\tif ((ADW_READ_WORD_REGISTER(iot, ioh, IOPW_SCSI_CTRL) & 0x3F07) ==\n\t\t\t0x3F07) {\n\t\treturn ASC_IERR_REVERSED_CABLE;\n\t}\n\n\t/*\n\t * All kind of combinations of devices attached to one of four connectors\n\t * are acceptable except HVD device attached. For example, LVD device can\n\t * be attached to SE connector while SE device attached to LVD connector.\n\t * If LVD device attached to SE connector, it only runs up to Ultra speed.\n\t *\n\t * If an HVD device is attached to one of LVD connectors, return an error.\n\t * However, there is no way to detect HVD device attached to SE connectors.\n\t */\n\tif (scsi_cfg1 & ADW_HVD) {\n\t\treturn ASC_IERR_HVD_DEVICE;\n\t}\n\n\t/*\n\t * If either SE or LVD automatic termination control is enabled, then\n\t * set the termination value based on a table listed in a_condor.h.\n\t *\n\t * If manual termination was specified with an EEPROM setting then\n\t * 'termination' was set-up in AdvInitFrom38C0800EEPROM() and is ready to\n\t * be 'ored' into SCSI_CFG1.\n\t */\n\tif ((sc->cfg.termination & ADW_TERM_SE) == 0) {\n\t\t/* SE automatic termination control is enabled. */\n\t\tswitch(scsi_cfg1 & ADW_C_DET_SE) {\n\t\t\t/* TERM_SE_HI: on, TERM_SE_LO: on */\n\t\t\tcase 0x1: case 0x2: case 0x3:\n\t\t\t\tsc->cfg.termination |= ADW_TERM_SE;\n\t\t\t\tbreak;\n\n\t\t\t/* TERM_SE_HI: on, TERM_SE_LO: off */\n\t\t\tcase 0x0:\n\t\t\t\tsc->cfg.termination |= ADW_TERM_SE_HI;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ((sc->cfg.termination & ADW_TERM_LVD) == 0) {\n\t\t/* LVD automatic termination control is enabled. */\n\t\tswitch(scsi_cfg1 & ADW_C_DET_LVD) {\n\t\t\t/* TERM_LVD_HI: on, TERM_LVD_LO: on */\n\t\t\tcase 0x4: case 0x8: case 0xC:\n\t\t\t\tsc->cfg.termination |= ADW_TERM_LVD;\n\t\t\t\tbreak;\n\n\t\t\t/* TERM_LVD_HI: off, TERM_LVD_LO: off */\n\t\t\tcase 0x0:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * Clear any set TERM_SE and TERM_LVD bits.\n\t */\n\tscsi_cfg1 &= (~ADW_TERM_SE & ~ADW_TERM_LVD);\n\n\t/*\n\t * Invert the TERM_SE and TERM_LVD bits and then set 'scsi_cfg1'.\n\t */\n\tscsi_cfg1 |= (~sc->cfg.termination & 0xF0);\n\n\t/*\n\t * Clear BIG_ENDIAN, DIS_TERM_DRV, Terminator Polarity and HVD/LVD/SE bits\n\t * and set possibly modified termination control bits in the Microcode\n\t * SCSI_CFG1 Register Value.\n\t */\n\tscsi_cfg1 &= (~ADW_BIG_ENDIAN & ~ADW_DIS_TERM_DRV &\n\t\t\t~ADW_TERM_POL & ~ADW_HVD_LVD_SE);\n\n\t/*\n\t * Set SCSI_CFG1 Microcode Default Value\n\t *\n\t * Set possibly modified termination control and reset DIS_TERM_DRV\n\t * bits in the Microcode SCSI_CFG1 Register Value.\n\t *\n\t * The microcode will set the SCSI_CFG1 register using this value\n\t * after it is started below.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DEFAULT_SCSI_CFG1, scsi_cfg1);\n\n\t/*\n\t * Set MEM_CFG Microcode Default Value\n\t *\n\t * The microcode will set the MEM_CFG register using this value\n\t * after it is started below.\n\t *\n\t * MEM_CFG may be accessed as a word or byte, but only bits 0-7\n\t * are defined.\n\t *\n\t * ASC-38C0800 has 16KB internal memory.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DEFAULT_MEM_CFG,\n\t\tADW_BIOS_EN | ADW_RAM_SZ_16KB);\n\n\t/*\n\t * Set SEL_MASK Microcode Default Value\n\t *\n\t * The microcode will set the SEL_MASK register using this value\n\t * after it is started below.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DEFAULT_SEL_MASK,\n\t\tADW_TID_TO_TIDMASK(sc->chip_scsi_id));\n\n\n\t/*\n\t * Set-up the Host->RISC Initiator Command Queue (ICQ) if\n\t * one is not already set up, i.e. this is the first\n\t * time through as opposed to a bus reset.\n\t */\n\n\tif (sc->icq_sp == NULL) {\n\t\tsc->carr_pending_cnt = 0;\n\t\tif ((sc->icq_sp = sc->carr_freelist) == NULL) {\n\t\t\treturn ASC_IERR_NO_CARRIER;\n\t\t}\n\t\tsc->carr_freelist = adw_carrier_phys_kv(sc,\n\t\t\t\tASC_GET_CARRP(sc->icq_sp->next_vpa));\n\n\n\t\t/*\n\t \t * The first command issued will be placed in the stopper carrier.\n\t \t */\n\t\tsc->icq_sp->next_vpa = ASC_CQ_STOPPER;\n\t}\n\n\t/*\n\t * Set RISC ICQ physical address start value.\n\t */\n\tADW_WRITE_DWORD_LRAM(iot, ioh, ASC_MC_ICQ, sc->icq_sp->carr_pa);\n\n\t/*\n\t * Set-up the RISC->Host Initiator Response Queue (IRQ) if\n\t * one is not already set up, i.e. this is the first\n\t * time through as opposed to a bus reset.\n\t */\n\tif (sc->irq_sp == NULL) {\n\t\tif ((sc->irq_sp = sc->carr_freelist) == NULL) {\n\t\t\treturn ASC_IERR_NO_CARRIER;\n\t\t}\n\t\tsc->carr_freelist = adw_carrier_phys_kv(sc,\n\t\t\t\tASC_GET_CARRP(sc->irq_sp->next_vpa));\n\n\t\t/*\n\t \t * The first command completed by the RISC will be placed in\n\t \t * the stopper.\n\t \t *\n\t \t * Note: Set 'next_vpa' to ASC_CQ_STOPPER. When the request is\n\t \t * completed the RISC will set the ASC_RQ_DONE bit.\n\t \t */\n\t\tsc->irq_sp->next_vpa = ASC_CQ_STOPPER;\n\t}\n\n\t/*\n\t * Set RISC IRQ physical address start value.\n\t */\n\tADW_WRITE_DWORD_LRAM(iot, ioh, ASC_MC_IRQ, sc->irq_sp->carr_pa);\n\n\tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_INTR_ENABLES,\n\t\t(ADW_INTR_ENABLE_HOST_INTR | ADW_INTR_ENABLE_GLOBAL_INTR));\n\t/*\n\t * Note: Don't remove the use of a temporary variable in\n\t * the following code, otherwise some C compiler\n\t * might turn the following lines into a no-op.\n\t */\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_CODE_BEGIN_ADDR, word);\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_PC, word);\n\n\t/* finally, finally, gentlemen, start your engine */\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_RISC_CSR, ADW_RISC_CSR_RUN);\n\n\t/*\n\t * Reset the SCSI Bus if the EEPROM indicates that SCSI Bus\n\t * Resets should be performed. The RISC has to be running\n\t * to issue a SCSI Bus Reset.\n\t */\n\tif (sc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS) {\n\t\t/*\n\t\t * If the BIOS Signature is present in memory, restore the\n\t\t * BIOS Handshake Configuration Table and do not perform\n\t\t * a SCSI Bus Reset.\n\t\t */\n\t\tif (bios_mem[(ASC_MC_BIOS_SIGNATURE - ASC_MC_BIOSMEM)/2] ==\n\t\t\t\t0x55AA) {\n\t\t\t/*\n\t\t\t * Restore per TID negotiated values.\n\t\t\t */\n\t\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_WDTR_ABLE, wdtr_able);\n\t\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_ABLE, sdtr_able);\n\t\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_TAGQNG_ABLE,\n\t\t\t\t\ttagqng_able);\n\t\t\tfor (tid = 0; tid <= ADW_MAX_TID; tid++) {\n\t\t\t\tADW_WRITE_BYTE_LRAM(iot, ioh,\n\t\t\t\t\t\tASC_MC_NUMBER_OF_MAX_CMD + tid,\n\t\t\t\t\t\tmax_cmd[tid]);\n\t\t\t}\n\t\t} else {\n\t\t\tif (AdvResetCCB(sc) != ADW_TRUE) {\n\t\t\t\twarn_code = ASC_WARN_BUSRESET_ERROR;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn warn_code;\n}"
  },
  {
    "function_name": "AdvInitAsc3550Driver",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adwlib.c",
    "lines": "217-713",
    "snippet": "int\nAdvInitAsc3550Driver(sc)\nADW_SOFTC      *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tu_int16_t\twarn_code;\n\tu_int32_t\tsum;\n\tint\t\tbegin_addr;\n\tint\t\tend_addr;\n\tu_int16_t\tcode_sum;\n\tint\t\tword;\n\tint\t\ti, j;\n\tint\t\tadv_asc3550_expanded_size;\n\tu_int16_t\tscsi_cfg1;\n\tu_int8_t\ttid;\n\tu_int16_t\tbios_mem[ASC_MC_BIOSLEN/2];\t/* BIOS RISC Memory\n\t\t\t\t\t\t\t\t0x40-0x8F. */\n\tu_int16_t\twdtr_able = 0, sdtr_able, tagqng_able;\n\tu_int8_t\tmax_cmd[ADW_MAX_TID + 1];\n\n\n\twarn_code = 0;\n\n\t/*\n\t * Save the RISC memory BIOS region before writing the microcode.\n\t * The BIOS may already be loaded and using its RISC LRAM region\n\t * so its region must be saved and restored.\n\t *\n\t * Note: This code makes the assumption, which is currently true,\n\t * that a chip reset does not clear RISC LRAM.\n\t */\n\tfor (i = 0; i < ASC_MC_BIOSLEN/2; i++) {\n\t\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_BIOSMEM + (2*i), bios_mem[i]);\n\t}\n\n\t/*\n\t * Save current per TID negotiated values.\n\t */\n\tif (bios_mem[(ASC_MC_BIOS_SIGNATURE - ASC_MC_BIOSMEM)/2] == 0x55AA) {\n\n\t\tu_int16_t  bios_version, major, minor;\n\n\t\tbios_version = bios_mem[(ASC_MC_BIOS_VERSION-ASC_MC_BIOSMEM)/2];\n\t\tmajor = (bios_version  >> 12) & 0xF;\n\t\tminor = (bios_version  >> 8) & 0xF;\n\t\tif (major < 3 || (major == 3 && minor == 1)) {\n\t\t    /* BIOS 3.1 and earlier location of 'wdtr_able' variable. */\n\t\t    ADW_READ_WORD_LRAM(iot, ioh, 0x120, wdtr_able);\n\t\t} else {\n\t\t    ADW_READ_WORD_LRAM(iot, ioh, ASC_MC_WDTR_ABLE, wdtr_able);\n\t\t}\n\t}\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_SDTR_ABLE, sdtr_able);\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_TAGQNG_ABLE, tagqng_able);\n\tfor (tid = 0; tid <= ADW_MAX_TID; tid++) {\n\t\tADW_READ_BYTE_LRAM(iot, ioh, ASC_MC_NUMBER_OF_MAX_CMD + tid,\n\t\t\tmax_cmd[tid]);\n\t}\n\n\t/*\n\t * Load the Microcode\n\t *\n\t * Write the microcode image to RISC memory starting at address 0.\n\t */\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_RAM_ADDR, 0);\n\n\t/* Assume the following compressed format of the microcode buffer:\n\t *\n\t *  254 word (508 byte) table indexed by byte code followed\n\t *  by the following byte codes:\n\t *\n\t *    1-Byte Code:\n\t *\t00: Emit word 0 in table.\n\t *\t01: Emit word 1 in table.\n\t *\t.\n\t *\tFD: Emit word 253 in table.\n\t *\n\t *    Multi-Byte Code:\n\t *\tFE WW WW: (3 byte code) Word to emit is the next word WW WW.\n\t *\tFF BB WW WW: (4 byte code) Emit BB count times next word WW WW.\n\t */\n\tword = 0;\n\tfor (i = 253 * 2; i < adv_asc3550_mcode_size; i++) {\n\t\tif (adv_asc3550_mcode[i] == 0xff) {\n\t\t\tfor (j = 0; j < adv_asc3550_mcode[i + 1]; j++) {\n\t\t\t\tADW_WRITE_WORD_AUTO_INC_LRAM(iot, ioh,\n\t\t\t\t  (((u_int16_t)adv_asc3550_mcode[i + 3] << 8) |\n\t\t\t\t  adv_asc3550_mcode[i + 2]));\n\t\t\t\tword++;\n\t\t\t}\n\t\t\ti += 3;\n\t\t} else if (adv_asc3550_mcode[i] == 0xfe) {\n\t\t\tADW_WRITE_WORD_AUTO_INC_LRAM(iot, ioh,\n\t\t\t    (((u_int16_t)adv_asc3550_mcode[i + 2] << 8) |\n\t\t\t    adv_asc3550_mcode[i + 1]));\n\t\t\ti += 2;\n\t\t\tword++;\n\t\t} else {\n\t\t\tADW_WRITE_WORD_AUTO_INC_LRAM(iot, ioh, (((u_int16_t)\n\t\t\t adv_asc3550_mcode[(adv_asc3550_mcode[i] * 2) + 1] <<8) |\n\t\t\t adv_asc3550_mcode[adv_asc3550_mcode[i] * 2]));\n\t\t\tword++;\n\t\t}\n\t}\n\n\t/*\n\t * Set 'word' for later use to clear the rest of memory and save\n\t * the expanded mcode size.\n\t */\n\tword *= 2;\n\tadv_asc3550_expanded_size = word;\n\n\t/*\n\t * Clear the rest of ASC-3550 Internal RAM (8KB).\n\t */\n\tfor (; word < ADV_3550_MEMSIZE; word += 2) {\n\t\tADW_WRITE_WORD_AUTO_INC_LRAM(iot, ioh, 0);\n\t}\n\n\t/*\n\t * Verify the microcode checksum.\n\t */\n\tsum = 0;\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_RAM_ADDR, 0);\n\n\tfor (word = 0; word < adv_asc3550_expanded_size; word += 2) {\n\t\tsum += ADW_READ_WORD_AUTO_INC_LRAM(iot, ioh);\n\t}\n\n\tif (sum != adv_asc3550_mcode_chksum) {\n\t\treturn ASC_IERR_MCODE_CHKSUM;\n\t}\n\n\t/*\n\t * Restore the RISC memory BIOS region.\n\t */\n\tfor (i = 0; i < ASC_MC_BIOSLEN/2; i++) {\n\t\tADW_WRITE_BYTE_LRAM(iot, ioh, ASC_MC_BIOSMEM + (2 * i),\n\t\t\t\tbios_mem[i]);\n\t}\n\n\t/*\n\t * Calculate and write the microcode code checksum to the microcode\n\t * code checksum location ASC_MC_CODE_CHK_SUM (0x2C).\n\t */\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_CODE_BEGIN_ADDR, begin_addr);\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_CODE_END_ADDR, end_addr);\n\tcode_sum = 0;\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_RAM_ADDR, begin_addr);\n\tfor (word = begin_addr; word < end_addr; word += 2) {\n\t\tcode_sum += ADW_READ_WORD_AUTO_INC_LRAM(iot, ioh);\n\t}\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_CODE_CHK_SUM, code_sum);\n\n\t/*\n\t * Read and save microcode version and date.\n\t */\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_VERSION_DATE,\n\t\t\tsc->cfg.mcode_date);\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_VERSION_NUM,\n\t\t\tsc->cfg.mcode_version);\n\n\t/*\n\t * Set the chip type to indicate the ASC3550.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_CHIP_TYPE, ADV_CHIP_ASC3550);\n\n\t/*\n\t * If the PCI Configuration Command Register \"Parity Error Response\n\t * Control\" Bit was clear (0), then set the microcode variable\n\t * 'control_flag' CONTROL_FLAG_IGNORE_PERR flag to tell the microcode\n\t * to ignore DMA parity errors.\n\t */\n\tif (sc->cfg.control_flag & CONTROL_FLAG_IGNORE_PERR) {\n\t\t/*\n\t\t * Note: Don't remove the use of a temporary variable in\n\t\t * the following code, otherwise some  C compiler\n\t\t * might turn the following lines into a no-op.\n\t\t */\n\t\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_CONTROL_FLAG, word);\n\t\tword |= CONTROL_FLAG_IGNORE_PERR;\n\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_CONTROL_FLAG, word);\n\t}\n\n\t/*\n\t * For ASC-3550, setting the START_CTL_EMFU [3:2] bits sets a FIFO\n\t * threshold of 128 bytes. This register is only accessible to the host.\n\t */\n\tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_DMA_CFG0,\n\t\t\tSTART_CTL_EMFU | READ_CMD_MRM);\n\n\t/*\n\t * Microcode operating variables for WDTR, SDTR, and command tag\n\t * queuing will be set in AdvInquiryHandling() based on what a\n\t * device reports it is capable of in Inquiry byte 7.\n\t *\n\t * If SCSI Bus Resets haev been disabled, then directly set\n\t * SDTR and WDTR from the EEPROM configuration. This will allow\n\t * the BIOS and warm boot to work without a SCSI bus hang on\n\t * the Inquiry caused by host and target mismatched DTR values.\n\t * Without the SCSI Bus Reset, before an Inquiry a device can't\n\t * be assumed to be in Asynchronous, Narrow mode.\n\t */\n\tif ((sc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS) == 0) {\n\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_WDTR_ABLE,\n\t\t\t\tsc->wdtr_able);\n\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_ABLE,\n\t\t\t\tsc->sdtr_able);\n\t}\n\n\t/*\n\t * Set microcode operating variables for SDTR_SPEED1, SDTR_SPEED2,\n\t * SDTR_SPEED3, and SDTR_SPEED4 based on the ULTRA EEPROM per TID\n\t * bitmask. These values determine the maximum SDTR speed negotiated\n\t * with a device.\n\t *\n\t * The SDTR per TID bitmask overrides the SDTR_SPEED1, SDTR_SPEED2,\n\t * SDTR_SPEED3, and SDTR_SPEED4 values so it is safe to set them\n\t * without determining here whether the device supports SDTR.\n\t *\n\t * 4-bit speed  SDTR speed name\n\t * ===========  ===============\n\t * 0000b (0x0)  SDTR disabled\n\t * 0001b (0x1)  5 Mhz\n\t * 0010b (0x2)  10 Mhz\n\t * 0011b (0x3)  20 Mhz (Ultra)\n\t * 0100b (0x4)  40 Mhz (LVD/Ultra2)\n\t * 0101b (0x5)  80 Mhz (LVD2/Ultra3)\n\t * 0110b (0x6)  Undefined\n\t * .\n\t * 1111b (0xF)  Undefined\n\t */\n\tword = 0;\n\tfor (tid = 0; tid <= ADW_MAX_TID; tid++) {\n\t\tif (ADW_TID_TO_TIDMASK(tid) & sc->ultra_able) {\n\t\t\t/* Set Ultra speed for TID 'tid'. */\n\t\t\tword |= (0x3 << (4 * (tid % 4)));\n\t\t} else {\n\t\t\t/* Set Fast speed for TID 'tid'. */\n\t\t\tword |= (0x2 << (4 * (tid % 4)));\n\t\t}\n\t\t/* Check if done with sdtr_speed1. */\n\t\tif (tid == 3) {\n\t\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_SPEED1, word);\n\t\t\tword = 0;\n\t\t/* Check if done with sdtr_speed2. */\n\t\t} else if (tid == 7) {\n\t\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_SPEED2, word);\n\t\t\tword = 0;\n\t\t/* Check if done with sdtr_speed3. */\n\t\t} else if (tid == 11) {\n\t\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_SPEED3, word);\n\t\t\tword = 0;\n\t\t/* Check if done with sdtr_speed4. */\n\t\t} else if (tid == 15) {\n\t\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_SPEED4, word);\n\t\t\t/* End of loop. */\n\t\t}\n\t}\n\n\t/*\n\t * Set microcode operating variable for the disconnect per TID bitmask.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DISC_ENABLE, sc->cfg.disc_enable);\n\n\n\t/*\n\t * Set SCSI_CFG0 Microcode Default Value.\n\t *\n\t * The microcode will set the SCSI_CFG0 register using this value\n\t * after it is started below.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DEFAULT_SCSI_CFG0,\n\t\tADW_PARITY_EN | ADW_SEL_TMO_LONG | ADW_OUR_ID_EN |\n\t\t\tsc->chip_scsi_id);\n\n\t/*\n\t * Determine SCSI_CFG1 Microcode Default Value.\n\t *\n\t * The microcode will set the SCSI_CFG1 register using this value\n\t * after it is started below.\n\t */\n\n\t/* Read current SCSI_CFG1 Register value. */\n\tscsi_cfg1 = ADW_READ_WORD_REGISTER(iot, ioh, IOPW_SCSI_CFG1);\n\n\t/*\n\t * If all three connectors are in use, return an error.\n\t */\n\tif ((scsi_cfg1 & CABLE_ILLEGAL_A) == 0 ||\n\t\t(scsi_cfg1 & CABLE_ILLEGAL_B) == 0) {\n\t\treturn ASC_IERR_ILLEGAL_CONNECTION;\n\t}\n\n\t/*\n\t * If the internal narrow cable is reversed all of the SCSI_CTRL\n\t * register signals will be set. Check for and return an error if\n\t * this condition is found.\n\t */\n\tif ((ADW_READ_WORD_REGISTER(iot, ioh, IOPW_SCSI_CTRL) & 0x3F07) ==\n\t\t\t0x3F07) {\n\t\treturn ASC_IERR_REVERSED_CABLE;\n\t}\n\n\t/*\n\t * If this is a differential board and a single-ended device\n\t * is attached to one of the connectors, return an error.\n\t */\n\tif ((scsi_cfg1 & ADW_DIFF_MODE) && (scsi_cfg1 & ADW_DIFF_SENSE) == 0) {\n\t\treturn ASC_IERR_SINGLE_END_DEVICE;\n\t}\n\n\t/*\n\t * If automatic termination control is enabled, then set the\n\t * termination value based on a table listed in a_condor.h.\n\t *\n\t * If manual termination was specified with an EEPROM setting\n\t * then 'termination' was set-up in AdvInitFrom3550EEPROM() and\n\t * is ready to be 'ored' into SCSI_CFG1.\n\t */\n\tif (sc->cfg.termination == 0) {\n\t\t/*\n\t\t * The software always controls termination by setting TERM_CTL_SEL.\n\t\t * If TERM_CTL_SEL were set to 0, the hardware would set termination.\n\t\t */\n\t\tsc->cfg.termination |= ADW_TERM_CTL_SEL;\n\n\t\tswitch(scsi_cfg1 & ADW_CABLE_DETECT) {\n\t\t\t/* TERM_CTL_H: on, TERM_CTL_L: on */\n\t\t\tcase 0x3: case 0x7: case 0xB: case 0xD: case 0xE: case 0xF:\n\t\t\t\tsc->cfg.termination |= (ADW_TERM_CTL_H | ADW_TERM_CTL_L);\n\t\t\t\tbreak;\n\n\t\t\t/* TERM_CTL_H: on, TERM_CTL_L: off */\n\t\t\tcase 0x1: case 0x5: case 0x9: case 0xA: case 0xC:\n\t\t\t\tsc->cfg.termination |= ADW_TERM_CTL_H;\n\t\t\t\tbreak;\n\n\t\t\t/* TERM_CTL_H: off, TERM_CTL_L: off */\n\t\t\tcase 0x2: case 0x6:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * Clear any set TERM_CTL_H and TERM_CTL_L bits.\n\t */\n\tscsi_cfg1 &= ~ADW_TERM_CTL;\n\n\t/*\n\t * Invert the TERM_CTL_H and TERM_CTL_L bits and then\n\t * set 'scsi_cfg1'. The TERM_POL bit does not need to be\n\t * referenced, because the hardware internally inverts\n\t * the Termination High and Low bits if TERM_POL is set.\n\t */\n\tscsi_cfg1 |= (ADW_TERM_CTL_SEL | (~sc->cfg.termination & ADW_TERM_CTL));\n\n\t/*\n\t * Set SCSI_CFG1 Microcode Default Value\n\t *\n\t * Set filter value and possibly modified termination control\n\t * bits in the Microcode SCSI_CFG1 Register Value.\n\t *\n\t * The microcode will set the SCSI_CFG1 register using this value\n\t * after it is started below.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DEFAULT_SCSI_CFG1,\n\t\tADW_FLTR_DISABLE | scsi_cfg1);\n\n\t/*\n\t * Set MEM_CFG Microcode Default Value\n\t *\n\t * The microcode will set the MEM_CFG register using this value\n\t * after it is started below.\n\t *\n\t * MEM_CFG may be accessed as a word or byte, but only bits 0-7\n\t * are defined.\n\t *\n\t * ASC-3550 has 8KB internal memory.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DEFAULT_MEM_CFG,\n\t\tADW_BIOS_EN | ADW_RAM_SZ_8KB);\n\n\t/*\n\t * Set SEL_MASK Microcode Default Value\n\t *\n\t * The microcode will set the SEL_MASK register using this value\n\t * after it is started below.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DEFAULT_SEL_MASK,\n\t\tADW_TID_TO_TIDMASK(sc->chip_scsi_id));\n\n\n\t/*\n\t * Set-up the Host->RISC Initiator Command Queue (ICQ) if\n\t * one is not already set up, i.e. this is the first\n\t * time through as opposed to a bus reset.\n\t */\n\n\tif (sc->icq_sp == NULL) {\n\t\tsc->carr_pending_cnt = 0;\n\t\tif ((sc->icq_sp = sc->carr_freelist) == NULL) {\n\t\t\treturn ASC_IERR_NO_CARRIER;\n\t\t}\n\t\tsc->carr_freelist = adw_carrier_phys_kv(sc,\n\t\t\t\tASC_GET_CARRP(sc->icq_sp->next_vpa));\n\n\t\t/*\n\t \t * The first command issued will be placed in the stopper carrier.\n\t\t */\n\t\tsc->icq_sp->next_vpa = ASC_CQ_STOPPER;\n\t}\n\n\t/*\n\t * Set RISC ICQ physical address start value.\n\t */\n\tADW_WRITE_DWORD_LRAM(iot, ioh, ASC_MC_ICQ, sc->icq_sp->carr_pa);\n\n\t/*\n\t * Set-up the RISC->Host Initiator Response Queue (IRQ) if\n\t * one is not already set up, i.e. this is the first\n\t * time through as opposed to a bus reset.\n\t */\n\tif (sc->irq_sp == NULL) {\n\t\tif ((sc->irq_sp = sc->carr_freelist) == NULL) {\n\t\t\treturn ASC_IERR_NO_CARRIER;\n\t\t}\n\t\tsc->carr_freelist = adw_carrier_phys_kv(sc,\n\t\t\t\tASC_GET_CARRP(sc->irq_sp->next_vpa));\n\n\t\t/*\n \t \t * The first command completed by the RISC will be placed in\n \t \t * the stopper.\n \t \t *\n \t \t * Note: Set 'next_vpa' to ASC_CQ_STOPPER. When the request is\n \t \t * completed the RISC will set the ASC_RQ_DONE bit.\n \t \t */\n\t\tsc->irq_sp->next_vpa = ASC_CQ_STOPPER;\n\t}\n\n\t/*\n \t * Set RISC IRQ physical address start value.\n \t */\n\tADW_WRITE_DWORD_LRAM(iot, ioh, ASC_MC_IRQ, sc->irq_sp->carr_pa);\n\n\tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_INTR_ENABLES,\n\t\t(ADW_INTR_ENABLE_HOST_INTR | ADW_INTR_ENABLE_GLOBAL_INTR));\n\n\t/*\n\t * Note: Don't remove the use of a temporary variable in\n\t * the following code, otherwise some C compiler\n\t * might turn the following lines into a no-op.\n\t */\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_CODE_BEGIN_ADDR, word);\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_PC, word);\n\n\t/* finally, finally, gentlemen, start your engine */\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_RISC_CSR, ADW_RISC_CSR_RUN);\n\n\t/*\n\t * Reset the SCSI Bus if the EEPROM indicates that SCSI Bus\n\t * Resets should be performed. The RISC has to be running\n\t * to issue a SCSI Bus Reset.\n\t */\n\tif (sc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS)\n\t{\n\t\t/*\n\t\t * If the BIOS Signature is present in memory, restore the\n\t\t * BIOS Handshake Configuration Table and do not perform\n\t\t * a SCSI Bus Reset.\n\t\t */\n\t\tif (bios_mem[(ASC_MC_BIOS_SIGNATURE - ASC_MC_BIOSMEM)/2] ==\n\t\t\t\t0x55AA) {\n\t\t\t/*\n\t\t\t * Restore per TID negotiated values.\n\t\t\t */\n\t\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_WDTR_ABLE,\n\t\t\t\t\twdtr_able);\n\t\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_ABLE,\n\t\t\t\t\tsdtr_able);\n\t\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_TAGQNG_ABLE,\n\t\t\t\t\ttagqng_able);\n\t\t\tfor (tid = 0; tid <= ADW_MAX_TID; tid++) {\n\t\t\t\tADW_WRITE_BYTE_LRAM(iot, ioh,\n\t\t\t\t\tASC_MC_NUMBER_OF_MAX_CMD + tid,\n\t\t\t\t\tmax_cmd[tid]);\n\t\t\t}\n\t\t} else {\n\t\t\tif (AdvResetCCB(sc) != ADW_TRUE) {\n\t\t\t\twarn_code = ASC_WARN_BUSRESET_ERROR;\n\t\t\t}\n\t\t}\n\t}\n\n    return warn_code;\n}",
    "includes": [
      "#include <dev/ic/adwmcode.h>",
      "#include <dev/ic/adw.h>",
      "#include <dev/ic/adwlib.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/queue.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void AdvInquiryHandling",
      "ADW_SOFTC\t*sc;",
      "bus_space_tag_t iot = sc->sc_iot;",
      "bus_space_handle_t ioh = sc->sc_ioh;",
      "u_int8_t\t\ttid;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "AdvResetCCB",
          "args": [
            "sc"
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "AdvResetCCB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adwlib.c",
          "lines": "2030-2067",
          "snippet": "int\nAdvResetCCB(sc)\nADW_SOFTC\t*sc;\n{\n\tint\t    status;\n\n\t/*\n\t * Send the SCSI Bus Reset idle start idle command which asserts\n\t * the SCSI Bus Reset signal.\n\t */\n\tstatus = AdvSendIdleCmd(sc, (u_int16_t) IDLE_CMD_SCSI_RESET_START, 0L);\n\tif (status != ADW_TRUE)\n\t{\n\t\treturn status;\n\t}\n\n\t/*\n\t * Delay for the specified SCSI Bus Reset hold time.\n\t *\n\t * The hold time delay is done on the host because the RISC has no\n\t * microsecond accurate timer.\n\t */\n\tAdvDelayMicroSecond((u_int16_t) ASC_SCSI_RESET_HOLD_TIME_US);\n\n\t/*\n\t * Send the SCSI Bus Reset end idle command which de-asserts\n\t * the SCSI Bus Reset signal and purges any pending requests.\n\t */\n\tstatus = AdvSendIdleCmd(sc, (u_int16_t) IDLE_CMD_SCSI_RESET_END, 0L);\n\tif (status != ADW_TRUE)\n\t{\n\t\treturn status;\n\t}\n\n\tAdvSleepMilliSecond((u_int32_t) sc->scsi_reset_wait * 1000);\n\n\treturn status;\n}",
          "includes": [
            "#include <dev/ic/adwmcode.h>",
            "#include <dev/ic/adw.h>",
            "#include <dev/ic/adwlib.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/queue.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void AdvSleepMilliSecond",
            "static void AdvDelayMicroSecond",
            "ADW_SOFTC\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/adwmcode.h>\n#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void AdvSleepMilliSecond;\nstatic void AdvDelayMicroSecond;\nADW_SOFTC\t*sc;\n\nint\nAdvResetCCB(sc)\nADW_SOFTC\t*sc;\n{\n\tint\t    status;\n\n\t/*\n\t * Send the SCSI Bus Reset idle start idle command which asserts\n\t * the SCSI Bus Reset signal.\n\t */\n\tstatus = AdvSendIdleCmd(sc, (u_int16_t) IDLE_CMD_SCSI_RESET_START, 0L);\n\tif (status != ADW_TRUE)\n\t{\n\t\treturn status;\n\t}\n\n\t/*\n\t * Delay for the specified SCSI Bus Reset hold time.\n\t *\n\t * The hold time delay is done on the host because the RISC has no\n\t * microsecond accurate timer.\n\t */\n\tAdvDelayMicroSecond((u_int16_t) ASC_SCSI_RESET_HOLD_TIME_US);\n\n\t/*\n\t * Send the SCSI Bus Reset end idle command which de-asserts\n\t * the SCSI Bus Reset signal and purges any pending requests.\n\t */\n\tstatus = AdvSendIdleCmd(sc, (u_int16_t) IDLE_CMD_SCSI_RESET_END, 0L);\n\tif (status != ADW_TRUE)\n\t{\n\t\treturn status;\n\t}\n\n\tAdvSleepMilliSecond((u_int32_t) sc->scsi_reset_wait * 1000);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_BYTE_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_NUMBER_OF_MAX_CMD + tid",
            "max_cmd[tid]"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_TAGQNG_ABLE",
            "tagqng_able"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_SDTR_ABLE",
            "sdtr_able"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_WDTR_ABLE",
            "wdtr_able"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_REGISTER",
          "args": [
            "iot",
            "ioh",
            "IOPW_RISC_CSR",
            "ADW_RISC_CSR_RUN"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_REGISTER",
          "args": [
            "iot",
            "ioh",
            "IOPW_PC",
            "word"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_READ_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_CODE_BEGIN_ADDR",
            "word"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_BYTE_REGISTER",
          "args": [
            "iot",
            "ioh",
            "IOPB_INTR_ENABLES",
            "(ADW_INTR_ENABLE_HOST_INTR | ADW_INTR_ENABLE_GLOBAL_INTR)"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_DWORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_IRQ",
            "sc->irq_sp->carr_pa"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adw_carrier_phys_kv",
          "args": [
            "sc",
            "ASC_GET_CARRP(sc->irq_sp->next_vpa)"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASC_GET_CARRP",
          "args": [
            "sc->irq_sp->next_vpa"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_DWORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_ICQ",
            "sc->icq_sp->carr_pa"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adw_carrier_phys_kv",
          "args": [
            "sc",
            "ASC_GET_CARRP(sc->icq_sp->next_vpa)"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASC_GET_CARRP",
          "args": [
            "sc->icq_sp->next_vpa"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_DEFAULT_SEL_MASK",
            "ADW_TID_TO_TIDMASK(sc->chip_scsi_id)"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_TID_TO_TIDMASK",
          "args": [
            "sc->chip_scsi_id"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_DEFAULT_MEM_CFG",
            "ADW_BIOS_EN | ADW_RAM_SZ_8KB"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_DEFAULT_SCSI_CFG1",
            "ADW_FLTR_DISABLE | scsi_cfg1"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_READ_WORD_REGISTER",
          "args": [
            "iot",
            "ioh",
            "IOPW_SCSI_CTRL"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_READ_WORD_REGISTER",
          "args": [
            "iot",
            "ioh",
            "IOPW_SCSI_CFG1"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_DEFAULT_SCSI_CFG0",
            "ADW_PARITY_EN | ADW_SEL_TMO_LONG | ADW_OUR_ID_EN |\n\t\t\tsc->chip_scsi_id"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_DISC_ENABLE",
            "sc->cfg.disc_enable"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_SDTR_SPEED4",
            "word"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_SDTR_SPEED3",
            "word"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_SDTR_SPEED2",
            "word"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_SDTR_SPEED1",
            "word"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_TID_TO_TIDMASK",
          "args": [
            "tid"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_SDTR_ABLE",
            "sc->sdtr_able"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_WDTR_ABLE",
            "sc->wdtr_able"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_BYTE_REGISTER",
          "args": [
            "iot",
            "ioh",
            "IOPB_DMA_CFG0",
            "START_CTL_EMFU | READ_CMD_MRM"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_CONTROL_FLAG",
            "word"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_READ_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_CONTROL_FLAG",
            "word"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_CHIP_TYPE",
            "ADV_CHIP_ASC3550"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_READ_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_VERSION_NUM",
            "sc->cfg.mcode_version"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_READ_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_VERSION_DATE",
            "sc->cfg.mcode_date"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_CODE_CHK_SUM",
            "code_sum"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_READ_WORD_AUTO_INC_LRAM",
          "args": [
            "iot",
            "ioh"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_REGISTER",
          "args": [
            "iot",
            "ioh",
            "IOPW_RAM_ADDR",
            "begin_addr"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_READ_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_CODE_END_ADDR",
            "end_addr"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_READ_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_CODE_BEGIN_ADDR",
            "begin_addr"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_BYTE_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_BIOSMEM + (2 * i)",
            "bios_mem[i]"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_READ_WORD_AUTO_INC_LRAM",
          "args": [
            "iot",
            "ioh"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_REGISTER",
          "args": [
            "iot",
            "ioh",
            "IOPW_RAM_ADDR",
            "0"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_AUTO_INC_LRAM",
          "args": [
            "iot",
            "ioh",
            "0"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_AUTO_INC_LRAM",
          "args": [
            "iot",
            "ioh",
            "(((u_int16_t)\n\t\t\t adv_asc3550_mcode[(adv_asc3550_mcode[i] * 2) + 1] <<8) |\n\t\t\t adv_asc3550_mcode[adv_asc3550_mcode[i] * 2])"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_AUTO_INC_LRAM",
          "args": [
            "iot",
            "ioh",
            "(((u_int16_t)adv_asc3550_mcode[i + 2] << 8) |\n\t\t\t    adv_asc3550_mcode[i + 1])"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_AUTO_INC_LRAM",
          "args": [
            "iot",
            "ioh",
            "(((u_int16_t)adv_asc3550_mcode[i + 3] << 8) |\n\t\t\t\t  adv_asc3550_mcode[i + 2])"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_WRITE_WORD_REGISTER",
          "args": [
            "iot",
            "ioh",
            "IOPW_RAM_ADDR",
            "0"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_READ_BYTE_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_NUMBER_OF_MAX_CMD + tid",
            "max_cmd[tid]"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_READ_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_TAGQNG_ABLE",
            "tagqng_able"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_READ_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_SDTR_ABLE",
            "sdtr_able"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_READ_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_WDTR_ABLE",
            "wdtr_able"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_READ_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "0x120",
            "wdtr_able"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADW_READ_WORD_LRAM",
          "args": [
            "iot",
            "ioh",
            "ASC_MC_BIOSMEM + (2*i)",
            "bios_mem[i]"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/adwmcode.h>\n#include <dev/ic/adw.h>\n#include <dev/ic/adwlib.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void AdvInquiryHandling;\nADW_SOFTC\t*sc;\nbus_space_tag_t iot = sc->sc_iot;\nbus_space_handle_t ioh = sc->sc_ioh;\nu_int8_t\t\ttid;\n\nint\nAdvInitAsc3550Driver(sc)\nADW_SOFTC      *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tu_int16_t\twarn_code;\n\tu_int32_t\tsum;\n\tint\t\tbegin_addr;\n\tint\t\tend_addr;\n\tu_int16_t\tcode_sum;\n\tint\t\tword;\n\tint\t\ti, j;\n\tint\t\tadv_asc3550_expanded_size;\n\tu_int16_t\tscsi_cfg1;\n\tu_int8_t\ttid;\n\tu_int16_t\tbios_mem[ASC_MC_BIOSLEN/2];\t/* BIOS RISC Memory\n\t\t\t\t\t\t\t\t0x40-0x8F. */\n\tu_int16_t\twdtr_able = 0, sdtr_able, tagqng_able;\n\tu_int8_t\tmax_cmd[ADW_MAX_TID + 1];\n\n\n\twarn_code = 0;\n\n\t/*\n\t * Save the RISC memory BIOS region before writing the microcode.\n\t * The BIOS may already be loaded and using its RISC LRAM region\n\t * so its region must be saved and restored.\n\t *\n\t * Note: This code makes the assumption, which is currently true,\n\t * that a chip reset does not clear RISC LRAM.\n\t */\n\tfor (i = 0; i < ASC_MC_BIOSLEN/2; i++) {\n\t\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_BIOSMEM + (2*i), bios_mem[i]);\n\t}\n\n\t/*\n\t * Save current per TID negotiated values.\n\t */\n\tif (bios_mem[(ASC_MC_BIOS_SIGNATURE - ASC_MC_BIOSMEM)/2] == 0x55AA) {\n\n\t\tu_int16_t  bios_version, major, minor;\n\n\t\tbios_version = bios_mem[(ASC_MC_BIOS_VERSION-ASC_MC_BIOSMEM)/2];\n\t\tmajor = (bios_version  >> 12) & 0xF;\n\t\tminor = (bios_version  >> 8) & 0xF;\n\t\tif (major < 3 || (major == 3 && minor == 1)) {\n\t\t    /* BIOS 3.1 and earlier location of 'wdtr_able' variable. */\n\t\t    ADW_READ_WORD_LRAM(iot, ioh, 0x120, wdtr_able);\n\t\t} else {\n\t\t    ADW_READ_WORD_LRAM(iot, ioh, ASC_MC_WDTR_ABLE, wdtr_able);\n\t\t}\n\t}\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_SDTR_ABLE, sdtr_able);\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_TAGQNG_ABLE, tagqng_able);\n\tfor (tid = 0; tid <= ADW_MAX_TID; tid++) {\n\t\tADW_READ_BYTE_LRAM(iot, ioh, ASC_MC_NUMBER_OF_MAX_CMD + tid,\n\t\t\tmax_cmd[tid]);\n\t}\n\n\t/*\n\t * Load the Microcode\n\t *\n\t * Write the microcode image to RISC memory starting at address 0.\n\t */\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_RAM_ADDR, 0);\n\n\t/* Assume the following compressed format of the microcode buffer:\n\t *\n\t *  254 word (508 byte) table indexed by byte code followed\n\t *  by the following byte codes:\n\t *\n\t *    1-Byte Code:\n\t *\t00: Emit word 0 in table.\n\t *\t01: Emit word 1 in table.\n\t *\t.\n\t *\tFD: Emit word 253 in table.\n\t *\n\t *    Multi-Byte Code:\n\t *\tFE WW WW: (3 byte code) Word to emit is the next word WW WW.\n\t *\tFF BB WW WW: (4 byte code) Emit BB count times next word WW WW.\n\t */\n\tword = 0;\n\tfor (i = 253 * 2; i < adv_asc3550_mcode_size; i++) {\n\t\tif (adv_asc3550_mcode[i] == 0xff) {\n\t\t\tfor (j = 0; j < adv_asc3550_mcode[i + 1]; j++) {\n\t\t\t\tADW_WRITE_WORD_AUTO_INC_LRAM(iot, ioh,\n\t\t\t\t  (((u_int16_t)adv_asc3550_mcode[i + 3] << 8) |\n\t\t\t\t  adv_asc3550_mcode[i + 2]));\n\t\t\t\tword++;\n\t\t\t}\n\t\t\ti += 3;\n\t\t} else if (adv_asc3550_mcode[i] == 0xfe) {\n\t\t\tADW_WRITE_WORD_AUTO_INC_LRAM(iot, ioh,\n\t\t\t    (((u_int16_t)adv_asc3550_mcode[i + 2] << 8) |\n\t\t\t    adv_asc3550_mcode[i + 1]));\n\t\t\ti += 2;\n\t\t\tword++;\n\t\t} else {\n\t\t\tADW_WRITE_WORD_AUTO_INC_LRAM(iot, ioh, (((u_int16_t)\n\t\t\t adv_asc3550_mcode[(adv_asc3550_mcode[i] * 2) + 1] <<8) |\n\t\t\t adv_asc3550_mcode[adv_asc3550_mcode[i] * 2]));\n\t\t\tword++;\n\t\t}\n\t}\n\n\t/*\n\t * Set 'word' for later use to clear the rest of memory and save\n\t * the expanded mcode size.\n\t */\n\tword *= 2;\n\tadv_asc3550_expanded_size = word;\n\n\t/*\n\t * Clear the rest of ASC-3550 Internal RAM (8KB).\n\t */\n\tfor (; word < ADV_3550_MEMSIZE; word += 2) {\n\t\tADW_WRITE_WORD_AUTO_INC_LRAM(iot, ioh, 0);\n\t}\n\n\t/*\n\t * Verify the microcode checksum.\n\t */\n\tsum = 0;\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_RAM_ADDR, 0);\n\n\tfor (word = 0; word < adv_asc3550_expanded_size; word += 2) {\n\t\tsum += ADW_READ_WORD_AUTO_INC_LRAM(iot, ioh);\n\t}\n\n\tif (sum != adv_asc3550_mcode_chksum) {\n\t\treturn ASC_IERR_MCODE_CHKSUM;\n\t}\n\n\t/*\n\t * Restore the RISC memory BIOS region.\n\t */\n\tfor (i = 0; i < ASC_MC_BIOSLEN/2; i++) {\n\t\tADW_WRITE_BYTE_LRAM(iot, ioh, ASC_MC_BIOSMEM + (2 * i),\n\t\t\t\tbios_mem[i]);\n\t}\n\n\t/*\n\t * Calculate and write the microcode code checksum to the microcode\n\t * code checksum location ASC_MC_CODE_CHK_SUM (0x2C).\n\t */\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_CODE_BEGIN_ADDR, begin_addr);\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_CODE_END_ADDR, end_addr);\n\tcode_sum = 0;\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_RAM_ADDR, begin_addr);\n\tfor (word = begin_addr; word < end_addr; word += 2) {\n\t\tcode_sum += ADW_READ_WORD_AUTO_INC_LRAM(iot, ioh);\n\t}\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_CODE_CHK_SUM, code_sum);\n\n\t/*\n\t * Read and save microcode version and date.\n\t */\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_VERSION_DATE,\n\t\t\tsc->cfg.mcode_date);\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_VERSION_NUM,\n\t\t\tsc->cfg.mcode_version);\n\n\t/*\n\t * Set the chip type to indicate the ASC3550.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_CHIP_TYPE, ADV_CHIP_ASC3550);\n\n\t/*\n\t * If the PCI Configuration Command Register \"Parity Error Response\n\t * Control\" Bit was clear (0), then set the microcode variable\n\t * 'control_flag' CONTROL_FLAG_IGNORE_PERR flag to tell the microcode\n\t * to ignore DMA parity errors.\n\t */\n\tif (sc->cfg.control_flag & CONTROL_FLAG_IGNORE_PERR) {\n\t\t/*\n\t\t * Note: Don't remove the use of a temporary variable in\n\t\t * the following code, otherwise some  C compiler\n\t\t * might turn the following lines into a no-op.\n\t\t */\n\t\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_CONTROL_FLAG, word);\n\t\tword |= CONTROL_FLAG_IGNORE_PERR;\n\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_CONTROL_FLAG, word);\n\t}\n\n\t/*\n\t * For ASC-3550, setting the START_CTL_EMFU [3:2] bits sets a FIFO\n\t * threshold of 128 bytes. This register is only accessible to the host.\n\t */\n\tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_DMA_CFG0,\n\t\t\tSTART_CTL_EMFU | READ_CMD_MRM);\n\n\t/*\n\t * Microcode operating variables for WDTR, SDTR, and command tag\n\t * queuing will be set in AdvInquiryHandling() based on what a\n\t * device reports it is capable of in Inquiry byte 7.\n\t *\n\t * If SCSI Bus Resets haev been disabled, then directly set\n\t * SDTR and WDTR from the EEPROM configuration. This will allow\n\t * the BIOS and warm boot to work without a SCSI bus hang on\n\t * the Inquiry caused by host and target mismatched DTR values.\n\t * Without the SCSI Bus Reset, before an Inquiry a device can't\n\t * be assumed to be in Asynchronous, Narrow mode.\n\t */\n\tif ((sc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS) == 0) {\n\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_WDTR_ABLE,\n\t\t\t\tsc->wdtr_able);\n\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_ABLE,\n\t\t\t\tsc->sdtr_able);\n\t}\n\n\t/*\n\t * Set microcode operating variables for SDTR_SPEED1, SDTR_SPEED2,\n\t * SDTR_SPEED3, and SDTR_SPEED4 based on the ULTRA EEPROM per TID\n\t * bitmask. These values determine the maximum SDTR speed negotiated\n\t * with a device.\n\t *\n\t * The SDTR per TID bitmask overrides the SDTR_SPEED1, SDTR_SPEED2,\n\t * SDTR_SPEED3, and SDTR_SPEED4 values so it is safe to set them\n\t * without determining here whether the device supports SDTR.\n\t *\n\t * 4-bit speed  SDTR speed name\n\t * ===========  ===============\n\t * 0000b (0x0)  SDTR disabled\n\t * 0001b (0x1)  5 Mhz\n\t * 0010b (0x2)  10 Mhz\n\t * 0011b (0x3)  20 Mhz (Ultra)\n\t * 0100b (0x4)  40 Mhz (LVD/Ultra2)\n\t * 0101b (0x5)  80 Mhz (LVD2/Ultra3)\n\t * 0110b (0x6)  Undefined\n\t * .\n\t * 1111b (0xF)  Undefined\n\t */\n\tword = 0;\n\tfor (tid = 0; tid <= ADW_MAX_TID; tid++) {\n\t\tif (ADW_TID_TO_TIDMASK(tid) & sc->ultra_able) {\n\t\t\t/* Set Ultra speed for TID 'tid'. */\n\t\t\tword |= (0x3 << (4 * (tid % 4)));\n\t\t} else {\n\t\t\t/* Set Fast speed for TID 'tid'. */\n\t\t\tword |= (0x2 << (4 * (tid % 4)));\n\t\t}\n\t\t/* Check if done with sdtr_speed1. */\n\t\tif (tid == 3) {\n\t\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_SPEED1, word);\n\t\t\tword = 0;\n\t\t/* Check if done with sdtr_speed2. */\n\t\t} else if (tid == 7) {\n\t\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_SPEED2, word);\n\t\t\tword = 0;\n\t\t/* Check if done with sdtr_speed3. */\n\t\t} else if (tid == 11) {\n\t\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_SPEED3, word);\n\t\t\tword = 0;\n\t\t/* Check if done with sdtr_speed4. */\n\t\t} else if (tid == 15) {\n\t\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_SPEED4, word);\n\t\t\t/* End of loop. */\n\t\t}\n\t}\n\n\t/*\n\t * Set microcode operating variable for the disconnect per TID bitmask.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DISC_ENABLE, sc->cfg.disc_enable);\n\n\n\t/*\n\t * Set SCSI_CFG0 Microcode Default Value.\n\t *\n\t * The microcode will set the SCSI_CFG0 register using this value\n\t * after it is started below.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DEFAULT_SCSI_CFG0,\n\t\tADW_PARITY_EN | ADW_SEL_TMO_LONG | ADW_OUR_ID_EN |\n\t\t\tsc->chip_scsi_id);\n\n\t/*\n\t * Determine SCSI_CFG1 Microcode Default Value.\n\t *\n\t * The microcode will set the SCSI_CFG1 register using this value\n\t * after it is started below.\n\t */\n\n\t/* Read current SCSI_CFG1 Register value. */\n\tscsi_cfg1 = ADW_READ_WORD_REGISTER(iot, ioh, IOPW_SCSI_CFG1);\n\n\t/*\n\t * If all three connectors are in use, return an error.\n\t */\n\tif ((scsi_cfg1 & CABLE_ILLEGAL_A) == 0 ||\n\t\t(scsi_cfg1 & CABLE_ILLEGAL_B) == 0) {\n\t\treturn ASC_IERR_ILLEGAL_CONNECTION;\n\t}\n\n\t/*\n\t * If the internal narrow cable is reversed all of the SCSI_CTRL\n\t * register signals will be set. Check for and return an error if\n\t * this condition is found.\n\t */\n\tif ((ADW_READ_WORD_REGISTER(iot, ioh, IOPW_SCSI_CTRL) & 0x3F07) ==\n\t\t\t0x3F07) {\n\t\treturn ASC_IERR_REVERSED_CABLE;\n\t}\n\n\t/*\n\t * If this is a differential board and a single-ended device\n\t * is attached to one of the connectors, return an error.\n\t */\n\tif ((scsi_cfg1 & ADW_DIFF_MODE) && (scsi_cfg1 & ADW_DIFF_SENSE) == 0) {\n\t\treturn ASC_IERR_SINGLE_END_DEVICE;\n\t}\n\n\t/*\n\t * If automatic termination control is enabled, then set the\n\t * termination value based on a table listed in a_condor.h.\n\t *\n\t * If manual termination was specified with an EEPROM setting\n\t * then 'termination' was set-up in AdvInitFrom3550EEPROM() and\n\t * is ready to be 'ored' into SCSI_CFG1.\n\t */\n\tif (sc->cfg.termination == 0) {\n\t\t/*\n\t\t * The software always controls termination by setting TERM_CTL_SEL.\n\t\t * If TERM_CTL_SEL were set to 0, the hardware would set termination.\n\t\t */\n\t\tsc->cfg.termination |= ADW_TERM_CTL_SEL;\n\n\t\tswitch(scsi_cfg1 & ADW_CABLE_DETECT) {\n\t\t\t/* TERM_CTL_H: on, TERM_CTL_L: on */\n\t\t\tcase 0x3: case 0x7: case 0xB: case 0xD: case 0xE: case 0xF:\n\t\t\t\tsc->cfg.termination |= (ADW_TERM_CTL_H | ADW_TERM_CTL_L);\n\t\t\t\tbreak;\n\n\t\t\t/* TERM_CTL_H: on, TERM_CTL_L: off */\n\t\t\tcase 0x1: case 0x5: case 0x9: case 0xA: case 0xC:\n\t\t\t\tsc->cfg.termination |= ADW_TERM_CTL_H;\n\t\t\t\tbreak;\n\n\t\t\t/* TERM_CTL_H: off, TERM_CTL_L: off */\n\t\t\tcase 0x2: case 0x6:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * Clear any set TERM_CTL_H and TERM_CTL_L bits.\n\t */\n\tscsi_cfg1 &= ~ADW_TERM_CTL;\n\n\t/*\n\t * Invert the TERM_CTL_H and TERM_CTL_L bits and then\n\t * set 'scsi_cfg1'. The TERM_POL bit does not need to be\n\t * referenced, because the hardware internally inverts\n\t * the Termination High and Low bits if TERM_POL is set.\n\t */\n\tscsi_cfg1 |= (ADW_TERM_CTL_SEL | (~sc->cfg.termination & ADW_TERM_CTL));\n\n\t/*\n\t * Set SCSI_CFG1 Microcode Default Value\n\t *\n\t * Set filter value and possibly modified termination control\n\t * bits in the Microcode SCSI_CFG1 Register Value.\n\t *\n\t * The microcode will set the SCSI_CFG1 register using this value\n\t * after it is started below.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DEFAULT_SCSI_CFG1,\n\t\tADW_FLTR_DISABLE | scsi_cfg1);\n\n\t/*\n\t * Set MEM_CFG Microcode Default Value\n\t *\n\t * The microcode will set the MEM_CFG register using this value\n\t * after it is started below.\n\t *\n\t * MEM_CFG may be accessed as a word or byte, but only bits 0-7\n\t * are defined.\n\t *\n\t * ASC-3550 has 8KB internal memory.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DEFAULT_MEM_CFG,\n\t\tADW_BIOS_EN | ADW_RAM_SZ_8KB);\n\n\t/*\n\t * Set SEL_MASK Microcode Default Value\n\t *\n\t * The microcode will set the SEL_MASK register using this value\n\t * after it is started below.\n\t */\n\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_DEFAULT_SEL_MASK,\n\t\tADW_TID_TO_TIDMASK(sc->chip_scsi_id));\n\n\n\t/*\n\t * Set-up the Host->RISC Initiator Command Queue (ICQ) if\n\t * one is not already set up, i.e. this is the first\n\t * time through as opposed to a bus reset.\n\t */\n\n\tif (sc->icq_sp == NULL) {\n\t\tsc->carr_pending_cnt = 0;\n\t\tif ((sc->icq_sp = sc->carr_freelist) == NULL) {\n\t\t\treturn ASC_IERR_NO_CARRIER;\n\t\t}\n\t\tsc->carr_freelist = adw_carrier_phys_kv(sc,\n\t\t\t\tASC_GET_CARRP(sc->icq_sp->next_vpa));\n\n\t\t/*\n\t \t * The first command issued will be placed in the stopper carrier.\n\t\t */\n\t\tsc->icq_sp->next_vpa = ASC_CQ_STOPPER;\n\t}\n\n\t/*\n\t * Set RISC ICQ physical address start value.\n\t */\n\tADW_WRITE_DWORD_LRAM(iot, ioh, ASC_MC_ICQ, sc->icq_sp->carr_pa);\n\n\t/*\n\t * Set-up the RISC->Host Initiator Response Queue (IRQ) if\n\t * one is not already set up, i.e. this is the first\n\t * time through as opposed to a bus reset.\n\t */\n\tif (sc->irq_sp == NULL) {\n\t\tif ((sc->irq_sp = sc->carr_freelist) == NULL) {\n\t\t\treturn ASC_IERR_NO_CARRIER;\n\t\t}\n\t\tsc->carr_freelist = adw_carrier_phys_kv(sc,\n\t\t\t\tASC_GET_CARRP(sc->irq_sp->next_vpa));\n\n\t\t/*\n \t \t * The first command completed by the RISC will be placed in\n \t \t * the stopper.\n \t \t *\n \t \t * Note: Set 'next_vpa' to ASC_CQ_STOPPER. When the request is\n \t \t * completed the RISC will set the ASC_RQ_DONE bit.\n \t \t */\n\t\tsc->irq_sp->next_vpa = ASC_CQ_STOPPER;\n\t}\n\n\t/*\n \t * Set RISC IRQ physical address start value.\n \t */\n\tADW_WRITE_DWORD_LRAM(iot, ioh, ASC_MC_IRQ, sc->irq_sp->carr_pa);\n\n\tADW_WRITE_BYTE_REGISTER(iot, ioh, IOPB_INTR_ENABLES,\n\t\t(ADW_INTR_ENABLE_HOST_INTR | ADW_INTR_ENABLE_GLOBAL_INTR));\n\n\t/*\n\t * Note: Don't remove the use of a temporary variable in\n\t * the following code, otherwise some C compiler\n\t * might turn the following lines into a no-op.\n\t */\n\tADW_READ_WORD_LRAM(iot, ioh, ASC_MC_CODE_BEGIN_ADDR, word);\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_PC, word);\n\n\t/* finally, finally, gentlemen, start your engine */\n\tADW_WRITE_WORD_REGISTER(iot, ioh, IOPW_RISC_CSR, ADW_RISC_CSR_RUN);\n\n\t/*\n\t * Reset the SCSI Bus if the EEPROM indicates that SCSI Bus\n\t * Resets should be performed. The RISC has to be running\n\t * to issue a SCSI Bus Reset.\n\t */\n\tif (sc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS)\n\t{\n\t\t/*\n\t\t * If the BIOS Signature is present in memory, restore the\n\t\t * BIOS Handshake Configuration Table and do not perform\n\t\t * a SCSI Bus Reset.\n\t\t */\n\t\tif (bios_mem[(ASC_MC_BIOS_SIGNATURE - ASC_MC_BIOSMEM)/2] ==\n\t\t\t\t0x55AA) {\n\t\t\t/*\n\t\t\t * Restore per TID negotiated values.\n\t\t\t */\n\t\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_WDTR_ABLE,\n\t\t\t\t\twdtr_able);\n\t\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_SDTR_ABLE,\n\t\t\t\t\tsdtr_able);\n\t\t\tADW_WRITE_WORD_LRAM(iot, ioh, ASC_MC_TAGQNG_ABLE,\n\t\t\t\t\ttagqng_able);\n\t\t\tfor (tid = 0; tid <= ADW_MAX_TID; tid++) {\n\t\t\t\tADW_WRITE_BYTE_LRAM(iot, ioh,\n\t\t\t\t\tASC_MC_NUMBER_OF_MAX_CMD + tid,\n\t\t\t\t\tmax_cmd[tid]);\n\t\t\t}\n\t\t} else {\n\t\t\tif (AdvResetCCB(sc) != ADW_TRUE) {\n\t\t\t\twarn_code = ASC_WARN_BUSRESET_ERROR;\n\t\t\t}\n\t\t}\n\t}\n\n    return warn_code;\n}"
  }
]