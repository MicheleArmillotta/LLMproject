[
  {
    "function_name": "tcic_log2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
    "lines": "1387-1401",
    "snippet": "int\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}",
    "includes": [
      "#include <dev/ic/tcic2var.h>",
      "#include <dev/ic/tcic2reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <sys/kthread.h>",
      "#include <sys/malloc.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}"
  },
  {
    "function_name": "tcic_ns2wscnt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
    "lines": "1376-1385",
    "snippet": "int\ntcic_ns2wscnt(ns)\n\tint ns;\n{\n\tif (ns < 14) {\n\t\treturn 0;\n\t} else {\n\t\treturn (2*(ns-14))/70;\t/* XXX assumes 14.31818 MHz clock. */\n\t}\n}",
    "includes": [
      "#include <dev/ic/tcic2var.h>",
      "#include <dev/ic/tcic2reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <sys/kthread.h>",
      "#include <sys/malloc.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\ntcic_ns2wscnt(ns)\n\tint ns;\n{\n\tif (ns < 14) {\n\t\treturn 0;\n\t} else {\n\t\treturn (2*(ns-14))/70;\t/* XXX assumes 14.31818 MHz clock. */\n\t}\n}"
  },
  {
    "function_name": "tcic_chip_socket_disable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
    "lines": "1346-1370",
    "snippet": "void\ntcic_chip_socket_disable(pch)\n\tpcmcia_chipset_handle_t pch;\n{\n\tstruct tcic_handle *h = (struct tcic_handle *) pch;\n\tint val;\n\n\tDPRINTF((\"tcic_chip_socket_disable\\n\"));\n\n\ttcic_sel_sock(h);\n\n\t/* disable interrupts */\n\tval = tcic_read_ind_2(h, TCIC_IR_SCF1_N(h->sock));\n\tval &= TCIC_SCF1_IRQ_MASK;\n\ttcic_write_ind_2(h, TCIC_IR_SCF1_N(h->sock), val);\n\n\t/* disable the output signals */\n\ttcic_write_1(h, TCIC_R_SCTRL, 0);\n\tval = tcic_read_aux_2(h->sc->iot, h->sc->ioh, TCIC_AR_ILOCK);\n\tval &= ~TCIC_ILOCK_CRESENA;\n\ttcic_write_aux_2(h->sc->iot, h->sc->ioh, TCIC_AR_ILOCK, val);\n\n\t/* power down the socket */\n\ttcic_write_1(h, TCIC_R_PWR, 0);\n}",
    "includes": [
      "#include <dev/ic/tcic2var.h>",
      "#include <dev/ic/tcic2reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <sys/kthread.h>",
      "#include <sys/malloc.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tcic_write_1",
          "args": [
            "h",
            "TCIC_R_PWR",
            "0"
          ],
          "line": 1369
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_write_1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2var.h",
          "lines": "217-224",
          "snippet": "static __inline__ void\ntcic_write_1(h, reg, data)\n\tstruct tcic_handle *h;\n\tint reg;\n\tint data;\n{\n\tbus_space_write_1(h->sc->iot, h->sc->ioh, reg, (data));\n}",
          "includes": [
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/device.h>\n\nstatic __inline__ void\ntcic_write_1(h, reg, data)\n\tstruct tcic_handle *h;\n\tint reg;\n\tint data;\n{\n\tbus_space_write_1(h->sc->iot, h->sc->ioh, reg, (data));\n}"
        }
      },
      {
        "call_info": {
          "callee": "tcic_write_aux_2",
          "args": [
            "h->sc->iot",
            "h->sc->ioh",
            "TCIC_AR_ILOCK",
            "val"
          ],
          "line": 1366
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_write_aux_2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2var.h",
          "lines": "347-357",
          "snippet": "static __inline__ void\ntcic_write_aux_2(iot, ioh, auxreg, val)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tint auxreg, val;\n{\n\tint mode;\n\tmode = bus_space_read_1(iot, ioh, TCIC_R_MODE);\n\tbus_space_write_1(iot, ioh, TCIC_R_MODE, (mode & ~TCIC_AR_MASK)|auxreg);\n\tbus_space_write_2(iot, ioh, TCIC_R_AUX, val);\n}",
          "includes": [
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/device.h>\n\nstatic __inline__ void\ntcic_write_aux_2(iot, ioh, auxreg, val)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tint auxreg, val;\n{\n\tint mode;\n\tmode = bus_space_read_1(iot, ioh, TCIC_R_MODE);\n\tbus_space_write_1(iot, ioh, TCIC_R_MODE, (mode & ~TCIC_AR_MASK)|auxreg);\n\tbus_space_write_2(iot, ioh, TCIC_R_AUX, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tcic_read_aux_2",
          "args": [
            "h->sc->iot",
            "h->sc->ioh",
            "TCIC_AR_ILOCK"
          ],
          "line": 1364
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_read_aux_2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2var.h",
          "lines": "320-331",
          "snippet": "static __inline__ int\ntcic_read_aux_2(iot, ioh, auxreg)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tint auxreg;\n{\n\tint mode, val;\n\tmode = bus_space_read_1(iot, ioh, TCIC_R_MODE);\n\tbus_space_write_1(iot, ioh, TCIC_R_MODE, (mode & ~TCIC_AR_MASK)|auxreg);\n\tval = bus_space_read_2(iot, ioh, TCIC_R_AUX);\n\treturn val;\n}",
          "includes": [
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/device.h>\n\nstatic __inline__ int\ntcic_read_aux_2(iot, ioh, auxreg)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tint auxreg;\n{\n\tint mode, val;\n\tmode = bus_space_read_1(iot, ioh, TCIC_R_MODE);\n\tbus_space_write_1(iot, ioh, TCIC_R_MODE, (mode & ~TCIC_AR_MASK)|auxreg);\n\tval = bus_space_read_2(iot, ioh, TCIC_R_AUX);\n\treturn val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tcic_write_ind_2",
          "args": [
            "h",
            "TCIC_IR_SCF1_N(h->sock)",
            "val"
          ],
          "line": 1360
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_write_ind_2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2var.h",
          "lines": "262-273",
          "snippet": "static __inline__ void\ntcic_write_ind_2(h, reg, data)\n\tstruct tcic_handle *h;\n\tint reg;\n\tint data;\n{\n\tint r_addr;\n\tr_addr = tcic_read_4(h, TCIC_R_ADDR);\n\ttcic_write_4(h, TCIC_R_ADDR, reg|TCIC_ADDR_INDREG);\n\tbus_space_write_2(h->sc->iot, h->sc->ioh, TCIC_R_DATA, (data));\n\ttcic_write_4(h, TCIC_R_ADDR, r_addr);\n}",
          "includes": [
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/device.h>\n\nstatic __inline__ void\ntcic_write_ind_2(h, reg, data)\n\tstruct tcic_handle *h;\n\tint reg;\n\tint data;\n{\n\tint r_addr;\n\tr_addr = tcic_read_4(h, TCIC_R_ADDR);\n\ttcic_write_4(h, TCIC_R_ADDR, reg|TCIC_ADDR_INDREG);\n\tbus_space_write_2(h->sc->iot, h->sc->ioh, TCIC_R_DATA, (data));\n\ttcic_write_4(h, TCIC_R_ADDR, r_addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TCIC_IR_SCF1_N",
          "args": [
            "h->sock"
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcic_read_ind_2",
          "args": [
            "h",
            "TCIC_IR_SCF1_N(h->sock)"
          ],
          "line": 1358
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_read_ind_2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2var.h",
          "lines": "248-259",
          "snippet": "static __inline__ int\ntcic_read_ind_2(h, reg)\n\tstruct tcic_handle *h;\n\tint reg;\n{\n\tint r_addr, val;\n\tr_addr = tcic_read_4(h, TCIC_R_ADDR);\n\ttcic_write_4(h, TCIC_R_ADDR, reg|TCIC_ADDR_INDREG);\n\tval = bus_space_read_2(h->sc->iot, h->sc->ioh, TCIC_R_DATA);\n\ttcic_write_4(h, TCIC_R_ADDR, r_addr);\n\treturn val;\n}",
          "includes": [
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/device.h>\n\nstatic __inline__ int\ntcic_read_ind_2(h, reg)\n\tstruct tcic_handle *h;\n\tint reg;\n{\n\tint r_addr, val;\n\tr_addr = tcic_read_4(h, TCIC_R_ADDR);\n\ttcic_write_4(h, TCIC_R_ADDR, reg|TCIC_ADDR_INDREG);\n\tval = bus_space_read_2(h->sc->iot, h->sc->ioh, TCIC_R_DATA);\n\ttcic_write_4(h, TCIC_R_ADDR, r_addr);\n\treturn val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TCIC_IR_SCF1_N",
          "args": [
            "h->sock"
          ],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcic_sel_sock",
          "args": [
            "h"
          ],
          "line": 1355
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_sel_sock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2var.h",
          "lines": "276-284",
          "snippet": "static __inline__ void\ntcic_sel_sock(h)\n\tstruct tcic_handle *h;\n{\n\tint r_addr;\n\tr_addr = tcic_read_2(h, TCIC_R_ADDR2);\n\ttcic_write_2(h, TCIC_R_ADDR2,\n\t    (h->sock<<TCIC_ADDR2_SS_SHFT)|(r_addr & ~TCIC_ADDR2_SS_MASK));\n}",
          "includes": [
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/device.h>\n\nstatic __inline__ void\ntcic_sel_sock(h)\n\tstruct tcic_handle *h;\n{\n\tint r_addr;\n\tr_addr = tcic_read_2(h, TCIC_R_ADDR2);\n\ttcic_write_2(h, TCIC_R_ADDR2,\n\t    (h->sock<<TCIC_ADDR2_SS_SHFT)|(r_addr & ~TCIC_ADDR2_SS_MASK));\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"tcic_chip_socket_disable\\n\")"
          ],
          "line": 1353
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\ntcic_chip_socket_disable(pch)\n\tpcmcia_chipset_handle_t pch;\n{\n\tstruct tcic_handle *h = (struct tcic_handle *) pch;\n\tint val;\n\n\tDPRINTF((\"tcic_chip_socket_disable\\n\"));\n\n\ttcic_sel_sock(h);\n\n\t/* disable interrupts */\n\tval = tcic_read_ind_2(h, TCIC_IR_SCF1_N(h->sock));\n\tval &= TCIC_SCF1_IRQ_MASK;\n\ttcic_write_ind_2(h, TCIC_IR_SCF1_N(h->sock), val);\n\n\t/* disable the output signals */\n\ttcic_write_1(h, TCIC_R_SCTRL, 0);\n\tval = tcic_read_aux_2(h->sc->iot, h->sc->ioh, TCIC_AR_ILOCK);\n\tval &= ~TCIC_ILOCK_CRESENA;\n\ttcic_write_aux_2(h->sc->iot, h->sc->ioh, TCIC_AR_ILOCK, val);\n\n\t/* power down the socket */\n\ttcic_write_1(h, TCIC_R_PWR, 0);\n}"
  },
  {
    "function_name": "tcic_chip_socket_enable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
    "lines": "1251-1344",
    "snippet": "void\ntcic_chip_socket_enable(pch)\n\tpcmcia_chipset_handle_t pch;\n{\n\tstruct tcic_handle *h = (struct tcic_handle *) pch;\n\tint cardtype, reg, win;\n\n\ttcic_sel_sock(h);\n\n\t/*\n\t * power down the socket to reset it.\n\t * put card reset into high-z, put chip outputs to card into high-z\n\t */\n\n\ttcic_write_1(h, TCIC_R_PWR, 0);\n\treg = tcic_read_aux_2(h->sc->iot, h->sc->ioh, TCIC_AR_ILOCK);\n\treg |= TCIC_ILOCK_CWAIT;\n\treg &= ~(TCIC_ILOCK_CRESET|TCIC_ILOCK_CRESENA);\n\ttcic_write_aux_2(h->sc->iot, h->sc->ioh, TCIC_AR_ILOCK, reg);\n\ttcic_write_1(h, TCIC_R_SCTRL, 0);\t/* clear TCIC_SCTRL_ENA */\n\n\t/* power up the socket */\n\n\t/* turn on VCC, turn of VPP */\n\treg = TCIC_PWR_VCC_N(h->sock) | TCIC_PWR_VPP_N(h->sock) | h->sc->pwrena;\n\tif (h->sc->pwrena)\t\t/* this is a '84 type chip */\n\t\treg |= TCIC_PWR_VCC5V;\n\ttcic_write_1(h, TCIC_R_PWR, reg);\n\tdelay(10000);\n\n\t/* enable reset and wiggle it to reset the card */\n\treg = tcic_read_aux_2(h->sc->iot, h->sc->ioh, TCIC_AR_ILOCK);\n\treg |= TCIC_ILOCK_CRESENA;\n\ttcic_write_aux_2(h->sc->iot, h->sc->ioh, TCIC_AR_ILOCK, reg);\n\t/* XXX need bus_space_barrier here */\n\treg |= TCIC_ILOCK_CRESET;\n\ttcic_write_aux_2(h->sc->iot, h->sc->ioh, TCIC_AR_ILOCK, reg);\n\t/* enable card signals */\n\ttcic_write_1(h, TCIC_R_SCTRL, TCIC_SCTRL_ENA);\n\tdelay(10);\t/* wait 10 us */\n\n\t/* clear the reset flag */\n\treg = tcic_read_aux_2(h->sc->iot, h->sc->ioh, TCIC_AR_ILOCK);\n\treg &= ~(TCIC_ILOCK_CRESET);\n\ttcic_write_aux_2(h->sc->iot, h->sc->ioh, TCIC_AR_ILOCK, reg);\n\n\t/* wait 20ms as per pc card standard (r2.01) section 4.3.6 */\n\tdelay(20000);\n\n\t/* wait for the chip to finish initializing */\n\ttcic_wait_ready(h);\n\n\t/* WWW */\n\t/* zero out the address windows */\n\n\t/* writing to WR_MBASE_N disables the window */\n\tfor (win = 0; win < h->memwins; win++) {\n\t\ttcic_write_ind_2(h, TCIC_WR_MBASE_N((win<<1)+h->sock), 0);\n\t}\n\t/* writing to WR_IBASE_N disables the window */\n\tfor (win = 0; win < TCIC_IO_WINS; win++) {\n\t\ttcic_write_ind_2(h, TCIC_WR_IBASE_N((win<<1)+h->sock), 0);\n\t}\n\n\t/* set the card type */\n\n\tcardtype = pcmcia_card_gettype(h->pcmcia);\n\n#if 0\n\treg = tcic_read_ind_2(h, TCIC_IR_SCF1_N(h->sock));\n\treg &= ~TCIC_SCF1_IRQ_MASK;\n#else\n\treg = 0;\n#endif\n\treg |= ((cardtype == PCMCIA_IFTYPE_IO) ?\n\t\tTCIC_SCF1_IOSTS : 0);\n\treg |= tcic_irqmap[h->ih_irq];\t\t/* enable interrupts */\n\treg &= ~TCIC_SCF1_IRQOD;\n\ttcic_write_ind_2(h, TCIC_IR_SCF1_N(h->sock), reg);\n\n\tDPRINTF((\"%s: tcic_chip_socket_enable %d cardtype %s 0x%02x\\n\",\n\t    h->sc->dev.dv_xname, h->sock,\n\t    ((cardtype == PCMCIA_IFTYPE_IO) ? \"io\" : \"mem\"), reg));\n\n\t/* reinstall all the memory and io mappings */\n\n\tfor (win = 0; win < h->memwins; win++)\n\t\tif (h->memalloc & (1 << win))\n\t\t\ttcic_chip_do_mem_map(h, win);\n\n\tfor (win = 0; win < TCIC_IO_WINS; win++)\n\t\tif (h->ioalloc & (1 << win))\n\t\t\ttcic_chip_do_io_map(h, win);\n}",
    "includes": [
      "#include <dev/ic/tcic2var.h>",
      "#include <dev/ic/tcic2reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <sys/kthread.h>",
      "#include <sys/malloc.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\ttcic_chip_do_mem_map",
      "void\ttcic_chip_do_io_map"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tcic_chip_do_io_map",
          "args": [
            "h",
            "win"
          ],
          "line": 1343
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_chip_do_io_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
          "lines": "1119-1175",
          "snippet": "void \ntcic_chip_do_io_map(h, win)\n\tstruct tcic_handle *h;\n\tint win;\n{\n\tint reg, size2, iotiny, wbase, hwwin, wscnt;\n\n\tDPRINTF((\"tcic_chip_do_io_map win %d addr %lx size %lx width %d\\n\",\n\t    win, (long) h->io[win].addr, (long) h->io[win].size,\n\t    h->io[win].width * 8));\n\n\t/*\n\t * the even windows are used for socket 0,\n\t * the odd ones for socket 1.\n\t */\n\thwwin = (win << 1) + h->sock;\n\n\t/* set the WR_BASE register */\n\t/* XXX what if size isn't power of 2? -chb */\n\tsize2 = tcic_log2((u_int)h->io[win].size);\n\tDPRINTF((\"tcic_chip_do_io_map win %d size2 %d\\n\", win, size2));\n\tif (size2 < 1) {\n\t\tiotiny = TCIC_ICTL_TINY;\n\t\twbase = h->io[win].addr;\n\t} else {\n\t\tiotiny = 0;\n\t\t/* XXX we should do better -chb */\n\t\twbase = h->io[win].addr | (1 << (size2 - 1));\n\t}\n\ttcic_write_ind_2(h, TCIC_WR_IBASE_N(hwwin), wbase);\n\n\t/* set the WR_ICTL register */\n\treg = TCIC_ICTL_ENA | TCIC_ICTL_QUIET;\n\treg |= (h->sock << TCIC_ICTL_SS_SHIFT) & TCIC_ICTL_SS_MASK;\n\treg |= iotiny | tcic_iowidth_map[h->io[win].width];\n\tif (h->sc->chipid != TCIC_CHIPID_DB86082_1)\n\t\treg |= TCIC_ICTL_PASS16;\n#ifdef notyet\t/* XXX must get speed from CIS somehow. -chb */\n\twscnt = tcic_ns2wscnt(h->io[win].speed);\n#else\n\twscnt = tcic_ns2wscnt(tcic_io_speed);\t/* linux uses 0 as default */\n#endif\n\treg |= wscnt & TCIC_ICTL_WSCNT_MASK;\n\ttcic_write_ind_2(h, TCIC_WR_ICTL_N(hwwin), reg);\n\n#ifdef TCICDEBUG\n\t{\n\t\tint r1, r2;\n\n\t\tr1 = tcic_read_ind_2(h, TCIC_WR_IBASE_N(hwwin));\n\t\tr2 = tcic_read_ind_2(h, TCIC_WR_ICTL_N(hwwin));\n\n\t\tDPRINTF((\"tcic_chip_do_io_map window %d(%d): %04x %04x\\n\",\n\t\t    win, hwwin, r1, r2));\n\t}\n#endif\n}",
          "includes": [
            "#include <dev/ic/tcic2var.h>",
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttcic_chip_do_io_map",
            "int tcic_io_speed = 165;",
            "static int tcic_iowidth_map[] =\n    { TCIC_ICTL_AUTOSZ, TCIC_ICTL_B8, TCIC_ICTL_B16 };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\ttcic_chip_do_io_map;\nint tcic_io_speed = 165;\nstatic int tcic_iowidth_map[] =\n    { TCIC_ICTL_AUTOSZ, TCIC_ICTL_B8, TCIC_ICTL_B16 };\n\nvoid \ntcic_chip_do_io_map(h, win)\n\tstruct tcic_handle *h;\n\tint win;\n{\n\tint reg, size2, iotiny, wbase, hwwin, wscnt;\n\n\tDPRINTF((\"tcic_chip_do_io_map win %d addr %lx size %lx width %d\\n\",\n\t    win, (long) h->io[win].addr, (long) h->io[win].size,\n\t    h->io[win].width * 8));\n\n\t/*\n\t * the even windows are used for socket 0,\n\t * the odd ones for socket 1.\n\t */\n\thwwin = (win << 1) + h->sock;\n\n\t/* set the WR_BASE register */\n\t/* XXX what if size isn't power of 2? -chb */\n\tsize2 = tcic_log2((u_int)h->io[win].size);\n\tDPRINTF((\"tcic_chip_do_io_map win %d size2 %d\\n\", win, size2));\n\tif (size2 < 1) {\n\t\tiotiny = TCIC_ICTL_TINY;\n\t\twbase = h->io[win].addr;\n\t} else {\n\t\tiotiny = 0;\n\t\t/* XXX we should do better -chb */\n\t\twbase = h->io[win].addr | (1 << (size2 - 1));\n\t}\n\ttcic_write_ind_2(h, TCIC_WR_IBASE_N(hwwin), wbase);\n\n\t/* set the WR_ICTL register */\n\treg = TCIC_ICTL_ENA | TCIC_ICTL_QUIET;\n\treg |= (h->sock << TCIC_ICTL_SS_SHIFT) & TCIC_ICTL_SS_MASK;\n\treg |= iotiny | tcic_iowidth_map[h->io[win].width];\n\tif (h->sc->chipid != TCIC_CHIPID_DB86082_1)\n\t\treg |= TCIC_ICTL_PASS16;\n#ifdef notyet\t/* XXX must get speed from CIS somehow. -chb */\n\twscnt = tcic_ns2wscnt(h->io[win].speed);\n#else\n\twscnt = tcic_ns2wscnt(tcic_io_speed);\t/* linux uses 0 as default */\n#endif\n\treg |= wscnt & TCIC_ICTL_WSCNT_MASK;\n\ttcic_write_ind_2(h, TCIC_WR_ICTL_N(hwwin), reg);\n\n#ifdef TCICDEBUG\n\t{\n\t\tint r1, r2;\n\n\t\tr1 = tcic_read_ind_2(h, TCIC_WR_IBASE_N(hwwin));\n\t\tr2 = tcic_read_ind_2(h, TCIC_WR_ICTL_N(hwwin));\n\n\t\tDPRINTF((\"tcic_chip_do_io_map window %d(%d): %04x %04x\\n\",\n\t\t    win, hwwin, r1, r2));\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "tcic_chip_do_mem_map",
          "args": [
            "h",
            "win"
          ],
          "line": 1339
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_chip_do_mem_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
          "lines": "862-940",
          "snippet": "void \ntcic_chip_do_mem_map(h, win)\n\tstruct tcic_handle *h;\n\tint win;\n{\n\tint reg, hwwin, wscnt;\n\n\tint kind = h->mem[win].kind & ~PCMCIA_WIDTH_MEM_MASK;\n\tint mem8 = (h->mem[win].kind & PCMCIA_WIDTH_MEM_MASK) == PCMCIA_WIDTH_MEM8;\n\tDPRINTF((\"tcic_chip_do_mem_map window %d: 0x%lx+0x%lx 0x%lx\\n\",\n\t\twin, (u_long)h->mem[win].addr, (u_long)h->mem[win].size,\n\t\t(u_long)h->mem[win].offset));\n\t/*\n\t * the even windows are used for socket 0,\n\t * the odd ones for socket 1.\n\t */\n\thwwin = (win << 1) + h->sock;\n\n\t/* the WR_MEXT register is MBZ */\n\ttcic_write_ind_2(h, TCIC_WR_MEXT_N(hwwin), 0);\n\n\t/* set the host base address and window size */\n\tif (h->mem[win].size2 <= 1) {\n\t\treg = ((h->mem[win].addr >> TCIC_MEM_SHIFT) &\n\t\t    TCIC_MBASE_ADDR_MASK) | TCIC_MBASE_4K;\n\t} else {\n\t\treg = ((h->mem[win].addr >> TCIC_MEM_SHIFT) &\n\t\t    TCIC_MBASE_ADDR_MASK) | (h->mem[win].size2 >> 1);\n\t}\n\ttcic_write_ind_2(h, TCIC_WR_MBASE_N(hwwin), reg);\n\n\t/* set the card address and address space */\n\treg = 0;\n\treg = ((h->mem[win].offset >> TCIC_MEM_SHIFT) & TCIC_MMAP_ADDR_MASK);\n\treg |= (kind == PCMCIA_MEM_ATTR) ? TCIC_MMAP_ATTR : 0;\n\tDPRINTF((\"tcic_chip_do_map_mem window %d(%d) mmap 0x%04x\\n\",\n\t    win, hwwin, reg));\n\ttcic_write_ind_2(h, TCIC_WR_MMAP_N(hwwin), reg);\n\n\t/* set the MCTL register */\n\t/* must save WSCNT field in case this is a DB86082 rev 0 */\n\t/* XXX why can't I do the following two in one statement? */\n\treg = tcic_read_ind_2(h, TCIC_WR_MCTL_N(hwwin)) & TCIC_MCTL_WSCNT_MASK;\n\treg |= TCIC_MCTL_ENA|TCIC_MCTL_QUIET;\n\treg |= mem8 ? TCIC_MCTL_B8 : 0;\n\treg |= (h->sock << TCIC_MCTL_SS_SHIFT) & TCIC_MCTL_SS_MASK;\n#ifdef notyet\t/* XXX must get speed from CIS somehow. -chb */\n\twscnt = tcic_ns2wscnt(h->mem[win].speed);\n#else\n\twscnt = tcic_ns2wscnt(tcic_mem_speed);\t/*  300 is \"save\" default for CIS memory */\n#endif\n\tif (h->sc->chipid == TCIC_CHIPID_DB86082_1) {\n\t\t/*\n\t\t * this chip has the wait state count in window\n\t\t * register 7 - hwwin.\n\t\t */\n\t\tint reg2;\n\t\treg2 = tcic_read_ind_2(h, TCIC_WR_MCTL_N(7-hwwin));\n\t\treg2 &= ~TCIC_MCTL_WSCNT_MASK;\n\t\treg2 |= wscnt & TCIC_MCTL_WSCNT_MASK;\n\t\ttcic_write_ind_2(h, TCIC_WR_MCTL_N(7-hwwin), reg2);\n\t} else {\n\t\treg |= wscnt & TCIC_MCTL_WSCNT_MASK;\n\t}\n\ttcic_write_ind_2(h, TCIC_WR_MCTL_N(hwwin), reg);\n\n#ifdef TCICDEBUG\n\t{\n\t\tint r1, r2, r3;\n\n\t\tr1 = tcic_read_ind_2(h, TCIC_WR_MBASE_N(hwwin));\n\t\tr2 = tcic_read_ind_2(h, TCIC_WR_MMAP_N(hwwin));\n\t\tr3 = tcic_read_ind_2(h, TCIC_WR_MCTL_N(hwwin));\n\n\t\tDPRINTF((\"tcic_chip_do_mem_map window %d(%d): %04x %04x %04x\\n\",\n\t\t    win, hwwin, r1, r2, r3));\n\t}\n#endif\n}",
          "includes": [
            "#include <dev/ic/tcic2var.h>",
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttcic_chip_do_mem_map",
            "int tcic_mem_speed = 250;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\ttcic_chip_do_mem_map;\nint tcic_mem_speed = 250;\n\nvoid \ntcic_chip_do_mem_map(h, win)\n\tstruct tcic_handle *h;\n\tint win;\n{\n\tint reg, hwwin, wscnt;\n\n\tint kind = h->mem[win].kind & ~PCMCIA_WIDTH_MEM_MASK;\n\tint mem8 = (h->mem[win].kind & PCMCIA_WIDTH_MEM_MASK) == PCMCIA_WIDTH_MEM8;\n\tDPRINTF((\"tcic_chip_do_mem_map window %d: 0x%lx+0x%lx 0x%lx\\n\",\n\t\twin, (u_long)h->mem[win].addr, (u_long)h->mem[win].size,\n\t\t(u_long)h->mem[win].offset));\n\t/*\n\t * the even windows are used for socket 0,\n\t * the odd ones for socket 1.\n\t */\n\thwwin = (win << 1) + h->sock;\n\n\t/* the WR_MEXT register is MBZ */\n\ttcic_write_ind_2(h, TCIC_WR_MEXT_N(hwwin), 0);\n\n\t/* set the host base address and window size */\n\tif (h->mem[win].size2 <= 1) {\n\t\treg = ((h->mem[win].addr >> TCIC_MEM_SHIFT) &\n\t\t    TCIC_MBASE_ADDR_MASK) | TCIC_MBASE_4K;\n\t} else {\n\t\treg = ((h->mem[win].addr >> TCIC_MEM_SHIFT) &\n\t\t    TCIC_MBASE_ADDR_MASK) | (h->mem[win].size2 >> 1);\n\t}\n\ttcic_write_ind_2(h, TCIC_WR_MBASE_N(hwwin), reg);\n\n\t/* set the card address and address space */\n\treg = 0;\n\treg = ((h->mem[win].offset >> TCIC_MEM_SHIFT) & TCIC_MMAP_ADDR_MASK);\n\treg |= (kind == PCMCIA_MEM_ATTR) ? TCIC_MMAP_ATTR : 0;\n\tDPRINTF((\"tcic_chip_do_map_mem window %d(%d) mmap 0x%04x\\n\",\n\t    win, hwwin, reg));\n\ttcic_write_ind_2(h, TCIC_WR_MMAP_N(hwwin), reg);\n\n\t/* set the MCTL register */\n\t/* must save WSCNT field in case this is a DB86082 rev 0 */\n\t/* XXX why can't I do the following two in one statement? */\n\treg = tcic_read_ind_2(h, TCIC_WR_MCTL_N(hwwin)) & TCIC_MCTL_WSCNT_MASK;\n\treg |= TCIC_MCTL_ENA|TCIC_MCTL_QUIET;\n\treg |= mem8 ? TCIC_MCTL_B8 : 0;\n\treg |= (h->sock << TCIC_MCTL_SS_SHIFT) & TCIC_MCTL_SS_MASK;\n#ifdef notyet\t/* XXX must get speed from CIS somehow. -chb */\n\twscnt = tcic_ns2wscnt(h->mem[win].speed);\n#else\n\twscnt = tcic_ns2wscnt(tcic_mem_speed);\t/*  300 is \"save\" default for CIS memory */\n#endif\n\tif (h->sc->chipid == TCIC_CHIPID_DB86082_1) {\n\t\t/*\n\t\t * this chip has the wait state count in window\n\t\t * register 7 - hwwin.\n\t\t */\n\t\tint reg2;\n\t\treg2 = tcic_read_ind_2(h, TCIC_WR_MCTL_N(7-hwwin));\n\t\treg2 &= ~TCIC_MCTL_WSCNT_MASK;\n\t\treg2 |= wscnt & TCIC_MCTL_WSCNT_MASK;\n\t\ttcic_write_ind_2(h, TCIC_WR_MCTL_N(7-hwwin), reg2);\n\t} else {\n\t\treg |= wscnt & TCIC_MCTL_WSCNT_MASK;\n\t}\n\ttcic_write_ind_2(h, TCIC_WR_MCTL_N(hwwin), reg);\n\n#ifdef TCICDEBUG\n\t{\n\t\tint r1, r2, r3;\n\n\t\tr1 = tcic_read_ind_2(h, TCIC_WR_MBASE_N(hwwin));\n\t\tr2 = tcic_read_ind_2(h, TCIC_WR_MMAP_N(hwwin));\n\t\tr3 = tcic_read_ind_2(h, TCIC_WR_MCTL_N(hwwin));\n\n\t\tDPRINTF((\"tcic_chip_do_mem_map window %d(%d): %04x %04x %04x\\n\",\n\t\t    win, hwwin, r1, r2, r3));\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: tcic_chip_socket_enable %d cardtype %s 0x%02x\\n\",\n\t    h->sc->dev.dv_xname, h->sock,\n\t    ((cardtype == PCMCIA_IFTYPE_IO) ? \"io\" : \"mem\"), reg)"
          ],
          "line": 1331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcic_write_ind_2",
          "args": [
            "h",
            "TCIC_IR_SCF1_N(h->sock)",
            "reg"
          ],
          "line": 1329
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_write_ind_2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2var.h",
          "lines": "262-273",
          "snippet": "static __inline__ void\ntcic_write_ind_2(h, reg, data)\n\tstruct tcic_handle *h;\n\tint reg;\n\tint data;\n{\n\tint r_addr;\n\tr_addr = tcic_read_4(h, TCIC_R_ADDR);\n\ttcic_write_4(h, TCIC_R_ADDR, reg|TCIC_ADDR_INDREG);\n\tbus_space_write_2(h->sc->iot, h->sc->ioh, TCIC_R_DATA, (data));\n\ttcic_write_4(h, TCIC_R_ADDR, r_addr);\n}",
          "includes": [
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/device.h>\n\nstatic __inline__ void\ntcic_write_ind_2(h, reg, data)\n\tstruct tcic_handle *h;\n\tint reg;\n\tint data;\n{\n\tint r_addr;\n\tr_addr = tcic_read_4(h, TCIC_R_ADDR);\n\ttcic_write_4(h, TCIC_R_ADDR, reg|TCIC_ADDR_INDREG);\n\tbus_space_write_2(h->sc->iot, h->sc->ioh, TCIC_R_DATA, (data));\n\ttcic_write_4(h, TCIC_R_ADDR, r_addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TCIC_IR_SCF1_N",
          "args": [
            "h->sock"
          ],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcic_read_ind_2",
          "args": [
            "h",
            "TCIC_IR_SCF1_N(h->sock)"
          ],
          "line": 1320
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_read_ind_2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2var.h",
          "lines": "248-259",
          "snippet": "static __inline__ int\ntcic_read_ind_2(h, reg)\n\tstruct tcic_handle *h;\n\tint reg;\n{\n\tint r_addr, val;\n\tr_addr = tcic_read_4(h, TCIC_R_ADDR);\n\ttcic_write_4(h, TCIC_R_ADDR, reg|TCIC_ADDR_INDREG);\n\tval = bus_space_read_2(h->sc->iot, h->sc->ioh, TCIC_R_DATA);\n\ttcic_write_4(h, TCIC_R_ADDR, r_addr);\n\treturn val;\n}",
          "includes": [
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/device.h>\n\nstatic __inline__ int\ntcic_read_ind_2(h, reg)\n\tstruct tcic_handle *h;\n\tint reg;\n{\n\tint r_addr, val;\n\tr_addr = tcic_read_4(h, TCIC_R_ADDR);\n\ttcic_write_4(h, TCIC_R_ADDR, reg|TCIC_ADDR_INDREG);\n\tval = bus_space_read_2(h->sc->iot, h->sc->ioh, TCIC_R_DATA);\n\ttcic_write_4(h, TCIC_R_ADDR, r_addr);\n\treturn val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TCIC_IR_SCF1_N",
          "args": [
            "h->sock"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_card_gettype",
          "args": [
            "h->pcmcia"
          ],
          "line": 1317
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_card_gettype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "367-386",
          "snippet": "int \npcmcia_card_gettype(dev)\n\tstruct device  *dev;\n{\n\tstruct pcmcia_softc *sc = (struct pcmcia_softc *)dev;\n\tstruct pcmcia_function *pf;\n\n\t/*\n\t * Set the iftype to memory if this card has no functions (not yet\n\t * probed), or only one function, and that is not initialized yet or\n\t * that is memory.\n\t */\n\tpf = SIMPLEQ_FIRST(&sc->card.pf_head);\n\tif (pf == NULL || (SIMPLEQ_NEXT(pf, pf_list) == NULL &&\n\t    ((pf->pf_flags & PFF_FAKE) ||\n\t    pf->cfe == NULL || pf->cfe->iftype == PCMCIA_IFTYPE_MEMORY)))\n\t\treturn (PCMCIA_IFTYPE_MEMORY);\n\telse\n\t\treturn (PCMCIA_IFTYPE_IO);\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\n\nint \npcmcia_card_gettype(dev)\n\tstruct device  *dev;\n{\n\tstruct pcmcia_softc *sc = (struct pcmcia_softc *)dev;\n\tstruct pcmcia_function *pf;\n\n\t/*\n\t * Set the iftype to memory if this card has no functions (not yet\n\t * probed), or only one function, and that is not initialized yet or\n\t * that is memory.\n\t */\n\tpf = SIMPLEQ_FIRST(&sc->card.pf_head);\n\tif (pf == NULL || (SIMPLEQ_NEXT(pf, pf_list) == NULL &&\n\t    ((pf->pf_flags & PFF_FAKE) ||\n\t    pf->cfe == NULL || pf->cfe->iftype == PCMCIA_IFTYPE_MEMORY)))\n\t\treturn (PCMCIA_IFTYPE_MEMORY);\n\telse\n\t\treturn (PCMCIA_IFTYPE_IO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TCIC_WR_IBASE_N",
          "args": [
            "(win<<1)+h->sock"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TCIC_WR_MBASE_N",
          "args": [
            "(win<<1)+h->sock"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcic_wait_ready",
          "args": [
            "h"
          ],
          "line": 1301
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_wait_ready",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2var.h",
          "lines": "287-303",
          "snippet": "static __inline__ void\ntcic_wait_ready(h)\n\tstruct tcic_handle *h;\n{\n\tint i;\n\n\t/* XXX appropriate socket must have been selected already. */\n\tfor (i = 0; i < 10000; i++) {\n\t\tif (tcic_read_1(h, TCIC_R_SSTAT) & TCIC_SSTAT_RDY)\n\t\t\treturn;\n\t\tdelay(500);\n\t}\n\n#ifdef DIAGNOSTIC\n\tprintf(\"tcic_wait_ready ready never happened\\n\");\n#endif\n}",
          "includes": [
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/device.h>\n\nstatic __inline__ void\ntcic_wait_ready(h)\n\tstruct tcic_handle *h;\n{\n\tint i;\n\n\t/* XXX appropriate socket must have been selected already. */\n\tfor (i = 0; i < 10000; i++) {\n\t\tif (tcic_read_1(h, TCIC_R_SSTAT) & TCIC_SSTAT_RDY)\n\t\t\treturn;\n\t\tdelay(500);\n\t}\n\n#ifdef DIAGNOSTIC\n\tprintf(\"tcic_wait_ready ready never happened\\n\");\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "20000"
          ],
          "line": 1298
        },
        "resolved": true,
        "details": {
          "function_name": "dc_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "215-222",
          "snippet": "void dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_delay"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_delay;\n\nvoid dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tcic_write_aux_2",
          "args": [
            "h->sc->iot",
            "h->sc->ioh",
            "TCIC_AR_ILOCK",
            "reg"
          ],
          "line": 1295
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_write_aux_2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2var.h",
          "lines": "347-357",
          "snippet": "static __inline__ void\ntcic_write_aux_2(iot, ioh, auxreg, val)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tint auxreg, val;\n{\n\tint mode;\n\tmode = bus_space_read_1(iot, ioh, TCIC_R_MODE);\n\tbus_space_write_1(iot, ioh, TCIC_R_MODE, (mode & ~TCIC_AR_MASK)|auxreg);\n\tbus_space_write_2(iot, ioh, TCIC_R_AUX, val);\n}",
          "includes": [
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/device.h>\n\nstatic __inline__ void\ntcic_write_aux_2(iot, ioh, auxreg, val)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tint auxreg, val;\n{\n\tint mode;\n\tmode = bus_space_read_1(iot, ioh, TCIC_R_MODE);\n\tbus_space_write_1(iot, ioh, TCIC_R_MODE, (mode & ~TCIC_AR_MASK)|auxreg);\n\tbus_space_write_2(iot, ioh, TCIC_R_AUX, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tcic_read_aux_2",
          "args": [
            "h->sc->iot",
            "h->sc->ioh",
            "TCIC_AR_ILOCK"
          ],
          "line": 1293
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_read_aux_2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2var.h",
          "lines": "320-331",
          "snippet": "static __inline__ int\ntcic_read_aux_2(iot, ioh, auxreg)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tint auxreg;\n{\n\tint mode, val;\n\tmode = bus_space_read_1(iot, ioh, TCIC_R_MODE);\n\tbus_space_write_1(iot, ioh, TCIC_R_MODE, (mode & ~TCIC_AR_MASK)|auxreg);\n\tval = bus_space_read_2(iot, ioh, TCIC_R_AUX);\n\treturn val;\n}",
          "includes": [
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/device.h>\n\nstatic __inline__ int\ntcic_read_aux_2(iot, ioh, auxreg)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tint auxreg;\n{\n\tint mode, val;\n\tmode = bus_space_read_1(iot, ioh, TCIC_R_MODE);\n\tbus_space_write_1(iot, ioh, TCIC_R_MODE, (mode & ~TCIC_AR_MASK)|auxreg);\n\tval = bus_space_read_2(iot, ioh, TCIC_R_AUX);\n\treturn val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tcic_write_1",
          "args": [
            "h",
            "TCIC_R_SCTRL",
            "TCIC_SCTRL_ENA"
          ],
          "line": 1289
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_write_1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2var.h",
          "lines": "217-224",
          "snippet": "static __inline__ void\ntcic_write_1(h, reg, data)\n\tstruct tcic_handle *h;\n\tint reg;\n\tint data;\n{\n\tbus_space_write_1(h->sc->iot, h->sc->ioh, reg, (data));\n}",
          "includes": [
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/device.h>\n\nstatic __inline__ void\ntcic_write_1(h, reg, data)\n\tstruct tcic_handle *h;\n\tint reg;\n\tint data;\n{\n\tbus_space_write_1(h->sc->iot, h->sc->ioh, reg, (data));\n}"
        }
      },
      {
        "call_info": {
          "callee": "TCIC_PWR_VPP_N",
          "args": [
            "h->sock"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TCIC_PWR_VCC_N",
          "args": [
            "h->sock"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcic_sel_sock",
          "args": [
            "h"
          ],
          "line": 1258
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_sel_sock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2var.h",
          "lines": "276-284",
          "snippet": "static __inline__ void\ntcic_sel_sock(h)\n\tstruct tcic_handle *h;\n{\n\tint r_addr;\n\tr_addr = tcic_read_2(h, TCIC_R_ADDR2);\n\ttcic_write_2(h, TCIC_R_ADDR2,\n\t    (h->sock<<TCIC_ADDR2_SS_SHFT)|(r_addr & ~TCIC_ADDR2_SS_MASK));\n}",
          "includes": [
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/device.h>\n\nstatic __inline__ void\ntcic_sel_sock(h)\n\tstruct tcic_handle *h;\n{\n\tint r_addr;\n\tr_addr = tcic_read_2(h, TCIC_R_ADDR2);\n\ttcic_write_2(h, TCIC_R_ADDR2,\n\t    (h->sock<<TCIC_ADDR2_SS_SHFT)|(r_addr & ~TCIC_ADDR2_SS_MASK));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\ttcic_chip_do_mem_map;\nvoid\ttcic_chip_do_io_map;\n\nvoid\ntcic_chip_socket_enable(pch)\n\tpcmcia_chipset_handle_t pch;\n{\n\tstruct tcic_handle *h = (struct tcic_handle *) pch;\n\tint cardtype, reg, win;\n\n\ttcic_sel_sock(h);\n\n\t/*\n\t * power down the socket to reset it.\n\t * put card reset into high-z, put chip outputs to card into high-z\n\t */\n\n\ttcic_write_1(h, TCIC_R_PWR, 0);\n\treg = tcic_read_aux_2(h->sc->iot, h->sc->ioh, TCIC_AR_ILOCK);\n\treg |= TCIC_ILOCK_CWAIT;\n\treg &= ~(TCIC_ILOCK_CRESET|TCIC_ILOCK_CRESENA);\n\ttcic_write_aux_2(h->sc->iot, h->sc->ioh, TCIC_AR_ILOCK, reg);\n\ttcic_write_1(h, TCIC_R_SCTRL, 0);\t/* clear TCIC_SCTRL_ENA */\n\n\t/* power up the socket */\n\n\t/* turn on VCC, turn of VPP */\n\treg = TCIC_PWR_VCC_N(h->sock) | TCIC_PWR_VPP_N(h->sock) | h->sc->pwrena;\n\tif (h->sc->pwrena)\t\t/* this is a '84 type chip */\n\t\treg |= TCIC_PWR_VCC5V;\n\ttcic_write_1(h, TCIC_R_PWR, reg);\n\tdelay(10000);\n\n\t/* enable reset and wiggle it to reset the card */\n\treg = tcic_read_aux_2(h->sc->iot, h->sc->ioh, TCIC_AR_ILOCK);\n\treg |= TCIC_ILOCK_CRESENA;\n\ttcic_write_aux_2(h->sc->iot, h->sc->ioh, TCIC_AR_ILOCK, reg);\n\t/* XXX need bus_space_barrier here */\n\treg |= TCIC_ILOCK_CRESET;\n\ttcic_write_aux_2(h->sc->iot, h->sc->ioh, TCIC_AR_ILOCK, reg);\n\t/* enable card signals */\n\ttcic_write_1(h, TCIC_R_SCTRL, TCIC_SCTRL_ENA);\n\tdelay(10);\t/* wait 10 us */\n\n\t/* clear the reset flag */\n\treg = tcic_read_aux_2(h->sc->iot, h->sc->ioh, TCIC_AR_ILOCK);\n\treg &= ~(TCIC_ILOCK_CRESET);\n\ttcic_write_aux_2(h->sc->iot, h->sc->ioh, TCIC_AR_ILOCK, reg);\n\n\t/* wait 20ms as per pc card standard (r2.01) section 4.3.6 */\n\tdelay(20000);\n\n\t/* wait for the chip to finish initializing */\n\ttcic_wait_ready(h);\n\n\t/* WWW */\n\t/* zero out the address windows */\n\n\t/* writing to WR_MBASE_N disables the window */\n\tfor (win = 0; win < h->memwins; win++) {\n\t\ttcic_write_ind_2(h, TCIC_WR_MBASE_N((win<<1)+h->sock), 0);\n\t}\n\t/* writing to WR_IBASE_N disables the window */\n\tfor (win = 0; win < TCIC_IO_WINS; win++) {\n\t\ttcic_write_ind_2(h, TCIC_WR_IBASE_N((win<<1)+h->sock), 0);\n\t}\n\n\t/* set the card type */\n\n\tcardtype = pcmcia_card_gettype(h->pcmcia);\n\n#if 0\n\treg = tcic_read_ind_2(h, TCIC_IR_SCF1_N(h->sock));\n\treg &= ~TCIC_SCF1_IRQ_MASK;\n#else\n\treg = 0;\n#endif\n\treg |= ((cardtype == PCMCIA_IFTYPE_IO) ?\n\t\tTCIC_SCF1_IOSTS : 0);\n\treg |= tcic_irqmap[h->ih_irq];\t\t/* enable interrupts */\n\treg &= ~TCIC_SCF1_IRQOD;\n\ttcic_write_ind_2(h, TCIC_IR_SCF1_N(h->sock), reg);\n\n\tDPRINTF((\"%s: tcic_chip_socket_enable %d cardtype %s 0x%02x\\n\",\n\t    h->sc->dev.dv_xname, h->sock,\n\t    ((cardtype == PCMCIA_IFTYPE_IO) ? \"io\" : \"mem\"), reg));\n\n\t/* reinstall all the memory and io mappings */\n\n\tfor (win = 0; win < h->memwins; win++)\n\t\tif (h->memalloc & (1 << win))\n\t\t\ttcic_chip_do_mem_map(h, win);\n\n\tfor (win = 0; win < TCIC_IO_WINS; win++)\n\t\tif (h->ioalloc & (1 << win))\n\t\t\ttcic_chip_do_io_map(h, win);\n}"
  },
  {
    "function_name": "tcic_chip_io_unmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
    "lines": "1232-1249",
    "snippet": "void \ntcic_chip_io_unmap(pch, window)\n\tpcmcia_chipset_handle_t pch;\n\tint window;\n{\n\tstruct tcic_handle *h = (struct tcic_handle *) pch;\n\tint reg, hwwin;\n\n\tif (window >= TCIC_IO_WINS)\n\t\tpanic(\"tcic_chip_io_unmap: window out of range\");\n\n\thwwin = (window << 1) + h->sock;\n\treg = tcic_read_ind_2(h, TCIC_WR_ICTL_N(hwwin));\n\treg &= ~TCIC_ICTL_ENA;\n\ttcic_write_ind_2(h, TCIC_WR_ICTL_N(hwwin), reg);\n\n\th->ioalloc &= ~(1 << window);\n}",
    "includes": [
      "#include <dev/ic/tcic2var.h>",
      "#include <dev/ic/tcic2reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <sys/kthread.h>",
      "#include <sys/malloc.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tcic_write_ind_2",
          "args": [
            "h",
            "TCIC_WR_ICTL_N(hwwin)",
            "reg"
          ],
          "line": 1246
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_write_ind_2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2var.h",
          "lines": "262-273",
          "snippet": "static __inline__ void\ntcic_write_ind_2(h, reg, data)\n\tstruct tcic_handle *h;\n\tint reg;\n\tint data;\n{\n\tint r_addr;\n\tr_addr = tcic_read_4(h, TCIC_R_ADDR);\n\ttcic_write_4(h, TCIC_R_ADDR, reg|TCIC_ADDR_INDREG);\n\tbus_space_write_2(h->sc->iot, h->sc->ioh, TCIC_R_DATA, (data));\n\ttcic_write_4(h, TCIC_R_ADDR, r_addr);\n}",
          "includes": [
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/device.h>\n\nstatic __inline__ void\ntcic_write_ind_2(h, reg, data)\n\tstruct tcic_handle *h;\n\tint reg;\n\tint data;\n{\n\tint r_addr;\n\tr_addr = tcic_read_4(h, TCIC_R_ADDR);\n\ttcic_write_4(h, TCIC_R_ADDR, reg|TCIC_ADDR_INDREG);\n\tbus_space_write_2(h->sc->iot, h->sc->ioh, TCIC_R_DATA, (data));\n\ttcic_write_4(h, TCIC_R_ADDR, r_addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TCIC_WR_ICTL_N",
          "args": [
            "hwwin"
          ],
          "line": 1246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcic_read_ind_2",
          "args": [
            "h",
            "TCIC_WR_ICTL_N(hwwin)"
          ],
          "line": 1244
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_read_ind_2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2var.h",
          "lines": "248-259",
          "snippet": "static __inline__ int\ntcic_read_ind_2(h, reg)\n\tstruct tcic_handle *h;\n\tint reg;\n{\n\tint r_addr, val;\n\tr_addr = tcic_read_4(h, TCIC_R_ADDR);\n\ttcic_write_4(h, TCIC_R_ADDR, reg|TCIC_ADDR_INDREG);\n\tval = bus_space_read_2(h->sc->iot, h->sc->ioh, TCIC_R_DATA);\n\ttcic_write_4(h, TCIC_R_ADDR, r_addr);\n\treturn val;\n}",
          "includes": [
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/device.h>\n\nstatic __inline__ int\ntcic_read_ind_2(h, reg)\n\tstruct tcic_handle *h;\n\tint reg;\n{\n\tint r_addr, val;\n\tr_addr = tcic_read_4(h, TCIC_R_ADDR);\n\ttcic_write_4(h, TCIC_R_ADDR, reg|TCIC_ADDR_INDREG);\n\tval = bus_space_read_2(h->sc->iot, h->sc->ioh, TCIC_R_DATA);\n\ttcic_write_4(h, TCIC_R_ADDR, r_addr);\n\treturn val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TCIC_WR_ICTL_N",
          "args": [
            "hwwin"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"tcic_chip_io_unmap: window out of range\""
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid \ntcic_chip_io_unmap(pch, window)\n\tpcmcia_chipset_handle_t pch;\n\tint window;\n{\n\tstruct tcic_handle *h = (struct tcic_handle *) pch;\n\tint reg, hwwin;\n\n\tif (window >= TCIC_IO_WINS)\n\t\tpanic(\"tcic_chip_io_unmap: window out of range\");\n\n\thwwin = (window << 1) + h->sock;\n\treg = tcic_read_ind_2(h, TCIC_WR_ICTL_N(hwwin));\n\treg &= ~TCIC_ICTL_ENA;\n\ttcic_write_ind_2(h, TCIC_WR_ICTL_N(hwwin), reg);\n\n\th->ioalloc &= ~(1 << window);\n}"
  },
  {
    "function_name": "tcic_chip_io_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
    "lines": "1177-1230",
    "snippet": "int \ntcic_chip_io_map(pch, width, offset, size, pcihp, windowp)\n\tpcmcia_chipset_handle_t pch;\n\tint width;\n\tbus_addr_t offset;\n\tbus_size_t size;\n\tstruct pcmcia_io_handle *pcihp;\n\tint *windowp;\n{\n\tstruct tcic_handle *h = (struct tcic_handle *) pch;\n\tbus_addr_t ioaddr = pcihp->addr + offset;\n\tint i, win;\n#ifdef TCICDEBUG\n\tstatic char *width_names[] = { \"auto\", \"io8\", \"io16\" };\n#endif\n\n\t/* XXX Sanity check offset/size. */\n\n\twin = -1;\n\tfor (i = 0; i < TCIC_IO_WINS; i++) {\n\t\tif ((h->ioalloc & (1 << i)) == 0) {\n\t\t\twin = i;\n\t\t\th->ioalloc |= (1 << i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (win == -1)\n\t\treturn (1);\n\n\t*windowp = win;\n\n\t/* XXX this is pretty gross */\n\n\tif (h->sc->iot != pcihp->iot)\n\t\tpanic(\"tcic_chip_io_map iot is bogus\");\n\n\tDPRINTF((\"tcic_chip_io_map window %d %s port %lx+%lx\\n\",\n\t\t win, width_names[width], (u_long) ioaddr, (u_long) size));\n\n\t/* XXX wtf is this doing here? */\n\n\tprintf(\" port 0x%lx\", (u_long) ioaddr);\n\tif (size > 1)\n\t\tprintf(\"-0x%lx\", (u_long) ioaddr + (u_long) size - 1);\n\n\th->io[win].addr = ioaddr;\n\th->io[win].size = size;\n\th->io[win].width = width;\n\n\ttcic_chip_do_io_map(h, win);\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/ic/tcic2var.h>",
      "#include <dev/ic/tcic2reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <sys/kthread.h>",
      "#include <sys/malloc.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\ttcic_chip_do_io_map"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tcic_chip_do_io_map",
          "args": [
            "h",
            "win"
          ],
          "line": 1227
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_chip_do_io_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
          "lines": "1119-1175",
          "snippet": "void \ntcic_chip_do_io_map(h, win)\n\tstruct tcic_handle *h;\n\tint win;\n{\n\tint reg, size2, iotiny, wbase, hwwin, wscnt;\n\n\tDPRINTF((\"tcic_chip_do_io_map win %d addr %lx size %lx width %d\\n\",\n\t    win, (long) h->io[win].addr, (long) h->io[win].size,\n\t    h->io[win].width * 8));\n\n\t/*\n\t * the even windows are used for socket 0,\n\t * the odd ones for socket 1.\n\t */\n\thwwin = (win << 1) + h->sock;\n\n\t/* set the WR_BASE register */\n\t/* XXX what if size isn't power of 2? -chb */\n\tsize2 = tcic_log2((u_int)h->io[win].size);\n\tDPRINTF((\"tcic_chip_do_io_map win %d size2 %d\\n\", win, size2));\n\tif (size2 < 1) {\n\t\tiotiny = TCIC_ICTL_TINY;\n\t\twbase = h->io[win].addr;\n\t} else {\n\t\tiotiny = 0;\n\t\t/* XXX we should do better -chb */\n\t\twbase = h->io[win].addr | (1 << (size2 - 1));\n\t}\n\ttcic_write_ind_2(h, TCIC_WR_IBASE_N(hwwin), wbase);\n\n\t/* set the WR_ICTL register */\n\treg = TCIC_ICTL_ENA | TCIC_ICTL_QUIET;\n\treg |= (h->sock << TCIC_ICTL_SS_SHIFT) & TCIC_ICTL_SS_MASK;\n\treg |= iotiny | tcic_iowidth_map[h->io[win].width];\n\tif (h->sc->chipid != TCIC_CHIPID_DB86082_1)\n\t\treg |= TCIC_ICTL_PASS16;\n#ifdef notyet\t/* XXX must get speed from CIS somehow. -chb */\n\twscnt = tcic_ns2wscnt(h->io[win].speed);\n#else\n\twscnt = tcic_ns2wscnt(tcic_io_speed);\t/* linux uses 0 as default */\n#endif\n\treg |= wscnt & TCIC_ICTL_WSCNT_MASK;\n\ttcic_write_ind_2(h, TCIC_WR_ICTL_N(hwwin), reg);\n\n#ifdef TCICDEBUG\n\t{\n\t\tint r1, r2;\n\n\t\tr1 = tcic_read_ind_2(h, TCIC_WR_IBASE_N(hwwin));\n\t\tr2 = tcic_read_ind_2(h, TCIC_WR_ICTL_N(hwwin));\n\n\t\tDPRINTF((\"tcic_chip_do_io_map window %d(%d): %04x %04x\\n\",\n\t\t    win, hwwin, r1, r2));\n\t}\n#endif\n}",
          "includes": [
            "#include <dev/ic/tcic2var.h>",
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttcic_chip_do_io_map",
            "int tcic_io_speed = 165;",
            "static int tcic_iowidth_map[] =\n    { TCIC_ICTL_AUTOSZ, TCIC_ICTL_B8, TCIC_ICTL_B16 };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\ttcic_chip_do_io_map;\nint tcic_io_speed = 165;\nstatic int tcic_iowidth_map[] =\n    { TCIC_ICTL_AUTOSZ, TCIC_ICTL_B8, TCIC_ICTL_B16 };\n\nvoid \ntcic_chip_do_io_map(h, win)\n\tstruct tcic_handle *h;\n\tint win;\n{\n\tint reg, size2, iotiny, wbase, hwwin, wscnt;\n\n\tDPRINTF((\"tcic_chip_do_io_map win %d addr %lx size %lx width %d\\n\",\n\t    win, (long) h->io[win].addr, (long) h->io[win].size,\n\t    h->io[win].width * 8));\n\n\t/*\n\t * the even windows are used for socket 0,\n\t * the odd ones for socket 1.\n\t */\n\thwwin = (win << 1) + h->sock;\n\n\t/* set the WR_BASE register */\n\t/* XXX what if size isn't power of 2? -chb */\n\tsize2 = tcic_log2((u_int)h->io[win].size);\n\tDPRINTF((\"tcic_chip_do_io_map win %d size2 %d\\n\", win, size2));\n\tif (size2 < 1) {\n\t\tiotiny = TCIC_ICTL_TINY;\n\t\twbase = h->io[win].addr;\n\t} else {\n\t\tiotiny = 0;\n\t\t/* XXX we should do better -chb */\n\t\twbase = h->io[win].addr | (1 << (size2 - 1));\n\t}\n\ttcic_write_ind_2(h, TCIC_WR_IBASE_N(hwwin), wbase);\n\n\t/* set the WR_ICTL register */\n\treg = TCIC_ICTL_ENA | TCIC_ICTL_QUIET;\n\treg |= (h->sock << TCIC_ICTL_SS_SHIFT) & TCIC_ICTL_SS_MASK;\n\treg |= iotiny | tcic_iowidth_map[h->io[win].width];\n\tif (h->sc->chipid != TCIC_CHIPID_DB86082_1)\n\t\treg |= TCIC_ICTL_PASS16;\n#ifdef notyet\t/* XXX must get speed from CIS somehow. -chb */\n\twscnt = tcic_ns2wscnt(h->io[win].speed);\n#else\n\twscnt = tcic_ns2wscnt(tcic_io_speed);\t/* linux uses 0 as default */\n#endif\n\treg |= wscnt & TCIC_ICTL_WSCNT_MASK;\n\ttcic_write_ind_2(h, TCIC_WR_ICTL_N(hwwin), reg);\n\n#ifdef TCICDEBUG\n\t{\n\t\tint r1, r2;\n\n\t\tr1 = tcic_read_ind_2(h, TCIC_WR_IBASE_N(hwwin));\n\t\tr2 = tcic_read_ind_2(h, TCIC_WR_ICTL_N(hwwin));\n\n\t\tDPRINTF((\"tcic_chip_do_io_map window %d(%d): %04x %04x\\n\",\n\t\t    win, hwwin, r1, r2));\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"-0x%lx\"",
            "(u_long) ioaddr + (u_long) size - 1"
          ],
          "line": 1221
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"tcic_chip_io_map window %d %s port %lx+%lx\\n\",\n\t\t win, width_names[width], (u_long) ioaddr, (u_long) size)"
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"tcic_chip_io_map iot is bogus\""
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\ttcic_chip_do_io_map;\n\nint \ntcic_chip_io_map(pch, width, offset, size, pcihp, windowp)\n\tpcmcia_chipset_handle_t pch;\n\tint width;\n\tbus_addr_t offset;\n\tbus_size_t size;\n\tstruct pcmcia_io_handle *pcihp;\n\tint *windowp;\n{\n\tstruct tcic_handle *h = (struct tcic_handle *) pch;\n\tbus_addr_t ioaddr = pcihp->addr + offset;\n\tint i, win;\n#ifdef TCICDEBUG\n\tstatic char *width_names[] = { \"auto\", \"io8\", \"io16\" };\n#endif\n\n\t/* XXX Sanity check offset/size. */\n\n\twin = -1;\n\tfor (i = 0; i < TCIC_IO_WINS; i++) {\n\t\tif ((h->ioalloc & (1 << i)) == 0) {\n\t\t\twin = i;\n\t\t\th->ioalloc |= (1 << i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (win == -1)\n\t\treturn (1);\n\n\t*windowp = win;\n\n\t/* XXX this is pretty gross */\n\n\tif (h->sc->iot != pcihp->iot)\n\t\tpanic(\"tcic_chip_io_map iot is bogus\");\n\n\tDPRINTF((\"tcic_chip_io_map window %d %s port %lx+%lx\\n\",\n\t\t win, width_names[width], (u_long) ioaddr, (u_long) size));\n\n\t/* XXX wtf is this doing here? */\n\n\tprintf(\" port 0x%lx\", (u_long) ioaddr);\n\tif (size > 1)\n\t\tprintf(\"-0x%lx\", (u_long) ioaddr + (u_long) size - 1);\n\n\th->io[win].addr = ioaddr;\n\th->io[win].size = size;\n\th->io[win].width = width;\n\n\ttcic_chip_do_io_map(h, win);\n\n\treturn (0);\n}"
  },
  {
    "function_name": "tcic_chip_do_io_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
    "lines": "1119-1175",
    "snippet": "void \ntcic_chip_do_io_map(h, win)\n\tstruct tcic_handle *h;\n\tint win;\n{\n\tint reg, size2, iotiny, wbase, hwwin, wscnt;\n\n\tDPRINTF((\"tcic_chip_do_io_map win %d addr %lx size %lx width %d\\n\",\n\t    win, (long) h->io[win].addr, (long) h->io[win].size,\n\t    h->io[win].width * 8));\n\n\t/*\n\t * the even windows are used for socket 0,\n\t * the odd ones for socket 1.\n\t */\n\thwwin = (win << 1) + h->sock;\n\n\t/* set the WR_BASE register */\n\t/* XXX what if size isn't power of 2? -chb */\n\tsize2 = tcic_log2((u_int)h->io[win].size);\n\tDPRINTF((\"tcic_chip_do_io_map win %d size2 %d\\n\", win, size2));\n\tif (size2 < 1) {\n\t\tiotiny = TCIC_ICTL_TINY;\n\t\twbase = h->io[win].addr;\n\t} else {\n\t\tiotiny = 0;\n\t\t/* XXX we should do better -chb */\n\t\twbase = h->io[win].addr | (1 << (size2 - 1));\n\t}\n\ttcic_write_ind_2(h, TCIC_WR_IBASE_N(hwwin), wbase);\n\n\t/* set the WR_ICTL register */\n\treg = TCIC_ICTL_ENA | TCIC_ICTL_QUIET;\n\treg |= (h->sock << TCIC_ICTL_SS_SHIFT) & TCIC_ICTL_SS_MASK;\n\treg |= iotiny | tcic_iowidth_map[h->io[win].width];\n\tif (h->sc->chipid != TCIC_CHIPID_DB86082_1)\n\t\treg |= TCIC_ICTL_PASS16;\n#ifdef notyet\t/* XXX must get speed from CIS somehow. -chb */\n\twscnt = tcic_ns2wscnt(h->io[win].speed);\n#else\n\twscnt = tcic_ns2wscnt(tcic_io_speed);\t/* linux uses 0 as default */\n#endif\n\treg |= wscnt & TCIC_ICTL_WSCNT_MASK;\n\ttcic_write_ind_2(h, TCIC_WR_ICTL_N(hwwin), reg);\n\n#ifdef TCICDEBUG\n\t{\n\t\tint r1, r2;\n\n\t\tr1 = tcic_read_ind_2(h, TCIC_WR_IBASE_N(hwwin));\n\t\tr2 = tcic_read_ind_2(h, TCIC_WR_ICTL_N(hwwin));\n\n\t\tDPRINTF((\"tcic_chip_do_io_map window %d(%d): %04x %04x\\n\",\n\t\t    win, hwwin, r1, r2));\n\t}\n#endif\n}",
    "includes": [
      "#include <dev/ic/tcic2var.h>",
      "#include <dev/ic/tcic2reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <sys/kthread.h>",
      "#include <sys/malloc.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\ttcic_chip_do_io_map",
      "int tcic_io_speed = 165;",
      "static int tcic_iowidth_map[] =\n    { TCIC_ICTL_AUTOSZ, TCIC_ICTL_B8, TCIC_ICTL_B16 };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"tcic_chip_do_io_map window %d(%d): %04x %04x\\n\",\n\t\t    win, hwwin, r1, r2)"
          ],
          "line": 1171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcic_read_ind_2",
          "args": [
            "h",
            "TCIC_WR_ICTL_N(hwwin)"
          ],
          "line": 1169
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_read_ind_2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2var.h",
          "lines": "248-259",
          "snippet": "static __inline__ int\ntcic_read_ind_2(h, reg)\n\tstruct tcic_handle *h;\n\tint reg;\n{\n\tint r_addr, val;\n\tr_addr = tcic_read_4(h, TCIC_R_ADDR);\n\ttcic_write_4(h, TCIC_R_ADDR, reg|TCIC_ADDR_INDREG);\n\tval = bus_space_read_2(h->sc->iot, h->sc->ioh, TCIC_R_DATA);\n\ttcic_write_4(h, TCIC_R_ADDR, r_addr);\n\treturn val;\n}",
          "includes": [
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/device.h>\n\nstatic __inline__ int\ntcic_read_ind_2(h, reg)\n\tstruct tcic_handle *h;\n\tint reg;\n{\n\tint r_addr, val;\n\tr_addr = tcic_read_4(h, TCIC_R_ADDR);\n\ttcic_write_4(h, TCIC_R_ADDR, reg|TCIC_ADDR_INDREG);\n\tval = bus_space_read_2(h->sc->iot, h->sc->ioh, TCIC_R_DATA);\n\ttcic_write_4(h, TCIC_R_ADDR, r_addr);\n\treturn val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TCIC_WR_ICTL_N",
          "args": [
            "hwwin"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TCIC_WR_IBASE_N",
          "args": [
            "hwwin"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcic_write_ind_2",
          "args": [
            "h",
            "TCIC_WR_ICTL_N(hwwin)",
            "reg"
          ],
          "line": 1162
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_write_ind_2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2var.h",
          "lines": "262-273",
          "snippet": "static __inline__ void\ntcic_write_ind_2(h, reg, data)\n\tstruct tcic_handle *h;\n\tint reg;\n\tint data;\n{\n\tint r_addr;\n\tr_addr = tcic_read_4(h, TCIC_R_ADDR);\n\ttcic_write_4(h, TCIC_R_ADDR, reg|TCIC_ADDR_INDREG);\n\tbus_space_write_2(h->sc->iot, h->sc->ioh, TCIC_R_DATA, (data));\n\ttcic_write_4(h, TCIC_R_ADDR, r_addr);\n}",
          "includes": [
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/device.h>\n\nstatic __inline__ void\ntcic_write_ind_2(h, reg, data)\n\tstruct tcic_handle *h;\n\tint reg;\n\tint data;\n{\n\tint r_addr;\n\tr_addr = tcic_read_4(h, TCIC_R_ADDR);\n\ttcic_write_4(h, TCIC_R_ADDR, reg|TCIC_ADDR_INDREG);\n\tbus_space_write_2(h->sc->iot, h->sc->ioh, TCIC_R_DATA, (data));\n\ttcic_write_4(h, TCIC_R_ADDR, r_addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TCIC_WR_ICTL_N",
          "args": [
            "hwwin"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcic_ns2wscnt",
          "args": [
            "tcic_io_speed"
          ],
          "line": 1159
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_ns2wscnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
          "lines": "1376-1385",
          "snippet": "int\ntcic_ns2wscnt(ns)\n\tint ns;\n{\n\tif (ns < 14) {\n\t\treturn 0;\n\t} else {\n\t\treturn (2*(ns-14))/70;\t/* XXX assumes 14.31818 MHz clock. */\n\t}\n}",
          "includes": [
            "#include <dev/ic/tcic2var.h>",
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\ntcic_ns2wscnt(ns)\n\tint ns;\n{\n\tif (ns < 14) {\n\t\treturn 0;\n\t} else {\n\t\treturn (2*(ns-14))/70;\t/* XXX assumes 14.31818 MHz clock. */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "TCIC_WR_IBASE_N",
          "args": [
            "hwwin"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"tcic_chip_do_io_map win %d size2 %d\\n\", win, size2)"
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcic_log2",
          "args": [
            "(u_int)h->io[win].size"
          ],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_log2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
          "lines": "1387-1401",
          "snippet": "int\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}",
          "includes": [
            "#include <dev/ic/tcic2var.h>",
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"tcic_chip_do_io_map win %d addr %lx size %lx width %d\\n\",\n\t    win, (long) h->io[win].addr, (long) h->io[win].size,\n\t    h->io[win].width * 8)"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\ttcic_chip_do_io_map;\nint tcic_io_speed = 165;\nstatic int tcic_iowidth_map[] =\n    { TCIC_ICTL_AUTOSZ, TCIC_ICTL_B8, TCIC_ICTL_B16 };\n\nvoid \ntcic_chip_do_io_map(h, win)\n\tstruct tcic_handle *h;\n\tint win;\n{\n\tint reg, size2, iotiny, wbase, hwwin, wscnt;\n\n\tDPRINTF((\"tcic_chip_do_io_map win %d addr %lx size %lx width %d\\n\",\n\t    win, (long) h->io[win].addr, (long) h->io[win].size,\n\t    h->io[win].width * 8));\n\n\t/*\n\t * the even windows are used for socket 0,\n\t * the odd ones for socket 1.\n\t */\n\thwwin = (win << 1) + h->sock;\n\n\t/* set the WR_BASE register */\n\t/* XXX what if size isn't power of 2? -chb */\n\tsize2 = tcic_log2((u_int)h->io[win].size);\n\tDPRINTF((\"tcic_chip_do_io_map win %d size2 %d\\n\", win, size2));\n\tif (size2 < 1) {\n\t\tiotiny = TCIC_ICTL_TINY;\n\t\twbase = h->io[win].addr;\n\t} else {\n\t\tiotiny = 0;\n\t\t/* XXX we should do better -chb */\n\t\twbase = h->io[win].addr | (1 << (size2 - 1));\n\t}\n\ttcic_write_ind_2(h, TCIC_WR_IBASE_N(hwwin), wbase);\n\n\t/* set the WR_ICTL register */\n\treg = TCIC_ICTL_ENA | TCIC_ICTL_QUIET;\n\treg |= (h->sock << TCIC_ICTL_SS_SHIFT) & TCIC_ICTL_SS_MASK;\n\treg |= iotiny | tcic_iowidth_map[h->io[win].width];\n\tif (h->sc->chipid != TCIC_CHIPID_DB86082_1)\n\t\treg |= TCIC_ICTL_PASS16;\n#ifdef notyet\t/* XXX must get speed from CIS somehow. -chb */\n\twscnt = tcic_ns2wscnt(h->io[win].speed);\n#else\n\twscnt = tcic_ns2wscnt(tcic_io_speed);\t/* linux uses 0 as default */\n#endif\n\treg |= wscnt & TCIC_ICTL_WSCNT_MASK;\n\ttcic_write_ind_2(h, TCIC_WR_ICTL_N(hwwin), reg);\n\n#ifdef TCICDEBUG\n\t{\n\t\tint r1, r2;\n\n\t\tr1 = tcic_read_ind_2(h, TCIC_WR_IBASE_N(hwwin));\n\t\tr2 = tcic_read_ind_2(h, TCIC_WR_ICTL_N(hwwin));\n\n\t\tDPRINTF((\"tcic_chip_do_io_map window %d(%d): %04x %04x\\n\",\n\t\t    win, hwwin, r1, r2));\n\t}\n#endif\n}"
  },
  {
    "function_name": "tcic_chip_io_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
    "lines": "1101-1114",
    "snippet": "void \ntcic_chip_io_free(pch, pcihp)\n\tpcmcia_chipset_handle_t pch;\n\tstruct pcmcia_io_handle *pcihp;\n{\n\tbus_space_tag_t iot = pcihp->iot;\n\tbus_space_handle_t ioh = pcihp->ioh;\n\tbus_size_t size = pcihp->size;\n\n\tif (pcihp->flags & PCMCIA_IO_ALLOCATED)\n\t\tbus_space_free(iot, ioh, size);\n\telse\n\t\tbus_space_unmap(iot, ioh, size);\n}",
    "includes": [
      "#include <dev/ic/tcic2var.h>",
      "#include <dev/ic/tcic2reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <sys/kthread.h>",
      "#include <sys/malloc.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_unmap",
          "args": [
            "iot",
            "ioh",
            "size"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_free",
          "args": [
            "iot",
            "ioh",
            "size"
          ],
          "line": 1111
        },
        "resolved": true,
        "details": {
          "function_name": "rbus_space_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/rbus.c",
          "lines": "179-207",
          "snippet": "int\nrbus_space_free(rbt, bsh, size, addrp)\n     rbus_tag_t rbt;\n     bus_space_handle_t bsh;\n     bus_size_t size;\n     bus_addr_t *addrp;\n{\n  int exflags = EX_FAST | EX_NOWAIT;\n  bus_addr_t addr;\n  int status = 1;\n\n  if (rbt->rb_flags == RBUS_SPACE_ASK_PARENT) {\n    status = rbus_space_free(rbt->rb_parent, bsh, size, &addr);\n  } else if (rbt->rb_flags == RBUS_SPACE_SHARE ||\n\t     rbt->rb_flags == RBUS_SPACE_DEDICATE) {\n    md_space_unmap(rbt->rb_bt, bsh, size, &addr);\n\n    extent_free(rbt->rb_ext, addr, size, exflags);\n\n    status = 0;\n  } else {\n    /* error. INVALID rbustag */\n    status = 1;\n  }\n  if (addrp != NULL) {\n    *addrp = addr;\n  }\n  return status;\n}",
          "includes": [
            "#include <dev/cardbus/rbus.h>",
            "#include <machine/bus.h>",
            "#include <sys/extent.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/cardbus/rbus.h>\n#include <machine/bus.h>\n#include <sys/extent.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\nrbus_space_free(rbt, bsh, size, addrp)\n     rbus_tag_t rbt;\n     bus_space_handle_t bsh;\n     bus_size_t size;\n     bus_addr_t *addrp;\n{\n  int exflags = EX_FAST | EX_NOWAIT;\n  bus_addr_t addr;\n  int status = 1;\n\n  if (rbt->rb_flags == RBUS_SPACE_ASK_PARENT) {\n    status = rbus_space_free(rbt->rb_parent, bsh, size, &addr);\n  } else if (rbt->rb_flags == RBUS_SPACE_SHARE ||\n\t     rbt->rb_flags == RBUS_SPACE_DEDICATE) {\n    md_space_unmap(rbt->rb_bt, bsh, size, &addr);\n\n    extent_free(rbt->rb_ext, addr, size, exflags);\n\n    status = 0;\n  } else {\n    /* error. INVALID rbustag */\n    status = 1;\n  }\n  if (addrp != NULL) {\n    *addrp = addr;\n  }\n  return status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid \ntcic_chip_io_free(pch, pcihp)\n\tpcmcia_chipset_handle_t pch;\n\tstruct pcmcia_io_handle *pcihp;\n{\n\tbus_space_tag_t iot = pcihp->iot;\n\tbus_space_handle_t ioh = pcihp->ioh;\n\tbus_size_t size = pcihp->size;\n\n\tif (pcihp->flags & PCMCIA_IO_ALLOCATED)\n\t\tbus_space_free(iot, ioh, size);\n\telse\n\t\tbus_space_unmap(iot, ioh, size);\n}"
  },
  {
    "function_name": "tcic_chip_io_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
    "lines": "1035-1099",
    "snippet": "int \ntcic_chip_io_alloc(pch, start, size, align, pcihp)\n\tpcmcia_chipset_handle_t pch;\n\tbus_addr_t start;\n\tbus_size_t size;\n\tbus_size_t align;\n\tstruct pcmcia_io_handle *pcihp;\n{\n\tstruct tcic_handle *h = (struct tcic_handle *) pch;\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tbus_addr_t ioaddr;\n\tint size2, flags = 0;\n\n\t/*\n\t * Allocate some arbitrary I/O space.\n\t */\n\n\tDPRINTF((\"tcic_chip_io_alloc req 0x%lx %ld %ld\\n\",\n\t    (u_long) start, (u_long) size, (u_long) align));\n\t/*\n\t * The TCIC can map I/O space only in sizes that are\n\t * powers of two, aligned at the natural boundary for the size.\n\t */\n\tsize2 = tcic_log2((u_int)size);\n\tif ((1 << size2) < size)\n\t\tsize2++;\n\t/* can't allocate that much anyway */\n\tif (size2 > 16)\t/* XXX 64K -chb */\n\t\treturn 1;\n\tif (align) {\n\t\tif ((1 << size2) != align)\n\t\t\treturn 1;\t/* not suitably  aligned */\n\t} else {\n\t\talign = 1 << size2;\t/* no alignment given, make it natural */\n\t}\n\tif (start & (align - 1))\n\t\treturn 1;\t/* not suitably aligned */\n\n\tiot = h->sc->iot;\n\n\tif (start) {\n\t\tioaddr = start;\n\t\tif (bus_space_map(iot, start, size, 0, &ioh))\n\t\t\treturn (1);\n\t\tDPRINTF((\"tcic_chip_io_alloc map port %lx+%lx\\n\",\n\t\t    (u_long) ioaddr, (u_long) size));\n\t} else {\n\t\tflags |= PCMCIA_IO_ALLOCATED;\n\t\tif (bus_space_alloc(iot, h->sc->iobase,\n\t\t    h->sc->iobase + h->sc->iosize, size, align, 0, 0,\n\t\t    &ioaddr, &ioh))\n\t\t\treturn (1);\n\t\tDPRINTF((\"tcic_chip_io_alloc alloc port %lx+%lx\\n\",\n\t\t    (u_long) ioaddr, (u_long) size));\n\t}\n\n\tpcihp->iot = iot;\n\tpcihp->ioh = ioh;\n\tpcihp->addr = ioaddr;\n\tpcihp->size = size;\n\tpcihp->flags = flags;\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/ic/tcic2var.h>",
      "#include <dev/ic/tcic2reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <sys/kthread.h>",
      "#include <sys/malloc.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"tcic_chip_io_alloc alloc port %lx+%lx\\n\",\n\t\t    (u_long) ioaddr, (u_long) size)"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_alloc",
          "args": [
            "iot",
            "h->sc->iobase",
            "h->sc->iobase + h->sc->iosize",
            "size",
            "align",
            "0",
            "0",
            "&ioaddr",
            "&ioh"
          ],
          "line": 1084
        },
        "resolved": true,
        "details": {
          "function_name": "rbus_space_alloc_subregion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/rbus.c",
          "lines": "82-173",
          "snippet": "int\nrbus_space_alloc_subregion(rbt, substart, subend, addr, size, mask, align, flags, addrp, bshp)\n     rbus_tag_t rbt;\n     bus_addr_t addr;\n     bus_addr_t substart;\n     bus_addr_t subend;\n     bus_size_t size;\n     bus_addr_t mask, align;\n     int flags;\n     bus_addr_t *addrp;\n     bus_space_handle_t *bshp;\n{\n  bus_addr_t decodesize = mask + 1;\n  bus_addr_t boundary, search_addr;\n  int val = 0;\n  bus_addr_t result;\n  int exflags = EX_FAST | EX_NOWAIT;\n\n  DPRINTF((\"rbus_space_alloc: addr %lx, size %lx, mask %lx, align %lx\\n\",\n\t   addr, size, mask, align));\n\n  addr += rbt->rb_offset;\n\n  if (mask == 0) {\n    /* FULL Decode */\n    decodesize = 0;\n  }\n\n  if (rbt->rb_flags == RBUS_SPACE_ASK_PARENT) {\n    return rbus_space_alloc(rbt->rb_parent, addr, size, mask, align, flags,\n\t\t\t    addrp, bshp);\n  } else if (rbt->rb_flags == RBUS_SPACE_SHARE ||\n\t     rbt->rb_flags == RBUS_SPACE_DEDICATE) {\n    /* rbt has its own sh_extent */\n\n    /* sanity check: the subregion [substart, subend] should be\n       smaller than the region included in sh_extent */\n    if (substart < rbt->rb_ext->ex_start || subend > rbt->rb_ext->ex_end) {\n      return 1;\n    }\n\n    if (decodesize == align) {\n      if(extent_alloc_subregion(rbt->rb_ext, substart, subend, size, align, 0,\n\t\t\t\texflags, (u_long *)&result)) {\n\treturn 1;\n      }\n    } else if (decodesize == 0) {\n      /* maybe, the resister is overflowed. */\n      \n      if (extent_alloc_subregion(rbt->rb_ext, addr, addr + size, size,\n\t\t\t\t 0, 0, exflags, (u_long *)&result)) {\n\treturn 1;\n      }\n    } else {\n\n      boundary = decodesize > align ? decodesize : align;\n\n      search_addr = (substart & ~(boundary - 1)) + addr;\n\n      if (search_addr < substart) {\n\tsearch_addr += boundary;\n      }\n\n      for (; search_addr + size <= subend; search_addr += boundary) {\n\tval = extent_alloc_subregion(rbt->rb_ext,search_addr, search_addr+size,\n\t\t\t\tsize, align, 0, exflags, (u_long *)&result);\n\tif (val == 0) {\n\t  break;\n\t}\n      }\n      if (val) {\n\treturn 1;\n      }\n    }\n\n    if(md_space_map(rbt->rb_bt, result, size, flags, bshp)) {\n      /* map failed */\n      extent_free(rbt->rb_ext, result, size, exflags);\n      return 1;\n    }\n\n    if (addrp != NULL) {\n      *addrp = result + rbt->rb_offset;\n    }\n    return 0;\n\n  } else {\n    /* error!! */\n    return 1;\n  }\n  return 1;\n}",
          "includes": [
            "#include <dev/cardbus/rbus.h>",
            "#include <machine/bus.h>",
            "#include <sys/extent.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct extent *ex, bus_addr_t start,\n\t\t\t\t    bus_addr_t end, bus_addr_t offset,\n\t\t\t\t    int flags));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/cardbus/rbus.h>\n#include <machine/bus.h>\n#include <sys/extent.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstruct extent *ex, bus_addr_t start,\n\t\t\t\t    bus_addr_t end, bus_addr_t offset,\n\t\t\t\t    int flags));\n\nint\nrbus_space_alloc_subregion(rbt, substart, subend, addr, size, mask, align, flags, addrp, bshp)\n     rbus_tag_t rbt;\n     bus_addr_t addr;\n     bus_addr_t substart;\n     bus_addr_t subend;\n     bus_size_t size;\n     bus_addr_t mask, align;\n     int flags;\n     bus_addr_t *addrp;\n     bus_space_handle_t *bshp;\n{\n  bus_addr_t decodesize = mask + 1;\n  bus_addr_t boundary, search_addr;\n  int val = 0;\n  bus_addr_t result;\n  int exflags = EX_FAST | EX_NOWAIT;\n\n  DPRINTF((\"rbus_space_alloc: addr %lx, size %lx, mask %lx, align %lx\\n\",\n\t   addr, size, mask, align));\n\n  addr += rbt->rb_offset;\n\n  if (mask == 0) {\n    /* FULL Decode */\n    decodesize = 0;\n  }\n\n  if (rbt->rb_flags == RBUS_SPACE_ASK_PARENT) {\n    return rbus_space_alloc(rbt->rb_parent, addr, size, mask, align, flags,\n\t\t\t    addrp, bshp);\n  } else if (rbt->rb_flags == RBUS_SPACE_SHARE ||\n\t     rbt->rb_flags == RBUS_SPACE_DEDICATE) {\n    /* rbt has its own sh_extent */\n\n    /* sanity check: the subregion [substart, subend] should be\n       smaller than the region included in sh_extent */\n    if (substart < rbt->rb_ext->ex_start || subend > rbt->rb_ext->ex_end) {\n      return 1;\n    }\n\n    if (decodesize == align) {\n      if(extent_alloc_subregion(rbt->rb_ext, substart, subend, size, align, 0,\n\t\t\t\texflags, (u_long *)&result)) {\n\treturn 1;\n      }\n    } else if (decodesize == 0) {\n      /* maybe, the resister is overflowed. */\n      \n      if (extent_alloc_subregion(rbt->rb_ext, addr, addr + size, size,\n\t\t\t\t 0, 0, exflags, (u_long *)&result)) {\n\treturn 1;\n      }\n    } else {\n\n      boundary = decodesize > align ? decodesize : align;\n\n      search_addr = (substart & ~(boundary - 1)) + addr;\n\n      if (search_addr < substart) {\n\tsearch_addr += boundary;\n      }\n\n      for (; search_addr + size <= subend; search_addr += boundary) {\n\tval = extent_alloc_subregion(rbt->rb_ext,search_addr, search_addr+size,\n\t\t\t\tsize, align, 0, exflags, (u_long *)&result);\n\tif (val == 0) {\n\t  break;\n\t}\n      }\n      if (val) {\n\treturn 1;\n      }\n    }\n\n    if(md_space_map(rbt->rb_bt, result, size, flags, bshp)) {\n      /* map failed */\n      extent_free(rbt->rb_ext, result, size, exflags);\n      return 1;\n    }\n\n    if (addrp != NULL) {\n      *addrp = result + rbt->rb_offset;\n    }\n    return 0;\n\n  } else {\n    /* error!! */\n    return 1;\n  }\n  return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"tcic_chip_io_alloc map port %lx+%lx\\n\",\n\t\t    (u_long) ioaddr, (u_long) size)"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "iot",
            "start",
            "size",
            "0",
            "&ioh"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcic_log2",
          "args": [
            "(u_int)size"
          ],
          "line": 1059
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_log2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
          "lines": "1387-1401",
          "snippet": "int\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}",
          "includes": [
            "#include <dev/ic/tcic2var.h>",
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"tcic_chip_io_alloc req 0x%lx %ld %ld\\n\",\n\t    (u_long) start, (u_long) size, (u_long) align)"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint \ntcic_chip_io_alloc(pch, start, size, align, pcihp)\n\tpcmcia_chipset_handle_t pch;\n\tbus_addr_t start;\n\tbus_size_t size;\n\tbus_size_t align;\n\tstruct pcmcia_io_handle *pcihp;\n{\n\tstruct tcic_handle *h = (struct tcic_handle *) pch;\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tbus_addr_t ioaddr;\n\tint size2, flags = 0;\n\n\t/*\n\t * Allocate some arbitrary I/O space.\n\t */\n\n\tDPRINTF((\"tcic_chip_io_alloc req 0x%lx %ld %ld\\n\",\n\t    (u_long) start, (u_long) size, (u_long) align));\n\t/*\n\t * The TCIC can map I/O space only in sizes that are\n\t * powers of two, aligned at the natural boundary for the size.\n\t */\n\tsize2 = tcic_log2((u_int)size);\n\tif ((1 << size2) < size)\n\t\tsize2++;\n\t/* can't allocate that much anyway */\n\tif (size2 > 16)\t/* XXX 64K -chb */\n\t\treturn 1;\n\tif (align) {\n\t\tif ((1 << size2) != align)\n\t\t\treturn 1;\t/* not suitably  aligned */\n\t} else {\n\t\talign = 1 << size2;\t/* no alignment given, make it natural */\n\t}\n\tif (start & (align - 1))\n\t\treturn 1;\t/* not suitably aligned */\n\n\tiot = h->sc->iot;\n\n\tif (start) {\n\t\tioaddr = start;\n\t\tif (bus_space_map(iot, start, size, 0, &ioh))\n\t\t\treturn (1);\n\t\tDPRINTF((\"tcic_chip_io_alloc map port %lx+%lx\\n\",\n\t\t    (u_long) ioaddr, (u_long) size));\n\t} else {\n\t\tflags |= PCMCIA_IO_ALLOCATED;\n\t\tif (bus_space_alloc(iot, h->sc->iobase,\n\t\t    h->sc->iobase + h->sc->iosize, size, align, 0, 0,\n\t\t    &ioaddr, &ioh))\n\t\t\treturn (1);\n\t\tDPRINTF((\"tcic_chip_io_alloc alloc port %lx+%lx\\n\",\n\t\t    (u_long) ioaddr, (u_long) size));\n\t}\n\n\tpcihp->iot = iot;\n\tpcihp->ioh = ioh;\n\tpcihp->addr = ioaddr;\n\tpcihp->size = size;\n\tpcihp->flags = flags;\n\n\treturn (0);\n}"
  },
  {
    "function_name": "tcic_chip_mem_unmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
    "lines": "1016-1033",
    "snippet": "void \ntcic_chip_mem_unmap(pch, window)\n\tpcmcia_chipset_handle_t pch;\n\tint window;\n{\n\tstruct tcic_handle *h = (struct tcic_handle *) pch;\n\tint reg, hwwin;\n\n\tif (window >= h->memwins)\n\t\tpanic(\"tcic_chip_mem_unmap: window out of range\");\n\n\thwwin = (window << 1) + h->sock;\n\treg = tcic_read_ind_2(h, TCIC_WR_MCTL_N(hwwin));\n\treg &= ~TCIC_MCTL_ENA;\n\ttcic_write_ind_2(h, TCIC_WR_MCTL_N(hwwin), reg);\n\n\th->memalloc &= ~(1 << window);\n}",
    "includes": [
      "#include <dev/ic/tcic2var.h>",
      "#include <dev/ic/tcic2reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <sys/kthread.h>",
      "#include <sys/malloc.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tcic_write_ind_2",
          "args": [
            "h",
            "TCIC_WR_MCTL_N(hwwin)",
            "reg"
          ],
          "line": 1030
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_write_ind_2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2var.h",
          "lines": "262-273",
          "snippet": "static __inline__ void\ntcic_write_ind_2(h, reg, data)\n\tstruct tcic_handle *h;\n\tint reg;\n\tint data;\n{\n\tint r_addr;\n\tr_addr = tcic_read_4(h, TCIC_R_ADDR);\n\ttcic_write_4(h, TCIC_R_ADDR, reg|TCIC_ADDR_INDREG);\n\tbus_space_write_2(h->sc->iot, h->sc->ioh, TCIC_R_DATA, (data));\n\ttcic_write_4(h, TCIC_R_ADDR, r_addr);\n}",
          "includes": [
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/device.h>\n\nstatic __inline__ void\ntcic_write_ind_2(h, reg, data)\n\tstruct tcic_handle *h;\n\tint reg;\n\tint data;\n{\n\tint r_addr;\n\tr_addr = tcic_read_4(h, TCIC_R_ADDR);\n\ttcic_write_4(h, TCIC_R_ADDR, reg|TCIC_ADDR_INDREG);\n\tbus_space_write_2(h->sc->iot, h->sc->ioh, TCIC_R_DATA, (data));\n\ttcic_write_4(h, TCIC_R_ADDR, r_addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TCIC_WR_MCTL_N",
          "args": [
            "hwwin"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcic_read_ind_2",
          "args": [
            "h",
            "TCIC_WR_MCTL_N(hwwin)"
          ],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_read_ind_2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2var.h",
          "lines": "248-259",
          "snippet": "static __inline__ int\ntcic_read_ind_2(h, reg)\n\tstruct tcic_handle *h;\n\tint reg;\n{\n\tint r_addr, val;\n\tr_addr = tcic_read_4(h, TCIC_R_ADDR);\n\ttcic_write_4(h, TCIC_R_ADDR, reg|TCIC_ADDR_INDREG);\n\tval = bus_space_read_2(h->sc->iot, h->sc->ioh, TCIC_R_DATA);\n\ttcic_write_4(h, TCIC_R_ADDR, r_addr);\n\treturn val;\n}",
          "includes": [
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/device.h>\n\nstatic __inline__ int\ntcic_read_ind_2(h, reg)\n\tstruct tcic_handle *h;\n\tint reg;\n{\n\tint r_addr, val;\n\tr_addr = tcic_read_4(h, TCIC_R_ADDR);\n\ttcic_write_4(h, TCIC_R_ADDR, reg|TCIC_ADDR_INDREG);\n\tval = bus_space_read_2(h->sc->iot, h->sc->ioh, TCIC_R_DATA);\n\ttcic_write_4(h, TCIC_R_ADDR, r_addr);\n\treturn val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TCIC_WR_MCTL_N",
          "args": [
            "hwwin"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"tcic_chip_mem_unmap: window out of range\""
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid \ntcic_chip_mem_unmap(pch, window)\n\tpcmcia_chipset_handle_t pch;\n\tint window;\n{\n\tstruct tcic_handle *h = (struct tcic_handle *) pch;\n\tint reg, hwwin;\n\n\tif (window >= h->memwins)\n\t\tpanic(\"tcic_chip_mem_unmap: window out of range\");\n\n\thwwin = (window << 1) + h->sock;\n\treg = tcic_read_ind_2(h, TCIC_WR_MCTL_N(hwwin));\n\treg &= ~TCIC_MCTL_ENA;\n\ttcic_write_ind_2(h, TCIC_WR_MCTL_N(hwwin), reg);\n\n\th->memalloc &= ~(1 << window);\n}"
  },
  {
    "function_name": "tcic_chip_mem_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
    "lines": "943-1014",
    "snippet": "int \ntcic_chip_mem_map(pch, kind, card_addr, size, pcmhp, offsetp, windowp)\n\tpcmcia_chipset_handle_t pch;\n\tint kind;\n\tbus_addr_t card_addr;\n\tbus_size_t size;\n\tstruct pcmcia_mem_handle *pcmhp;\n\tbus_addr_t *offsetp;\n\tint *windowp;\n{\n\tstruct tcic_handle *h = (struct tcic_handle *) pch;\n\tbus_addr_t busaddr;\n\tlong card_offset;\n\tint i, win;\n\n\twin = -1;\n\tfor (i = 0; i < h->memwins; i++) {\n\t\tif ((h->memalloc & (1 << i)) == 0) {\n\t\t\twin = i;\n\t\t\th->memalloc |= (1 << i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (win == -1)\n\t\treturn (1);\n\n\t*windowp = win;\n\n\t/* XXX this is pretty gross */\n\n\tif (h->sc->memt != pcmhp->memt)\n\t\tpanic(\"tcic_chip_mem_map memt is bogus\");\n\n\tbusaddr = pcmhp->addr;\n\n\t/*\n\t * compute the address offset to the pcmcia address space for the\n\t * tcic.  this is intentionally signed.  The masks and shifts below\n\t * will cause TRT to happen in the tcic registers.  Deal with making\n\t * sure the address is aligned, and return the alignment offset.\n\t */\n\n\t*offsetp = card_addr % TCIC_MEM_ALIGN;\n\tcard_addr -= *offsetp;\n\n\tDPRINTF((\"tcic_chip_mem_map window %d bus %lx+%lx+%lx at card addr \"\n\t    \"%lx\\n\", win, (u_long) busaddr, (u_long) * offsetp, (u_long) size,\n\t    (u_long) card_addr));\n\n\t/* XXX we can't use size. -chb */\n\t/*\n\t * include the offset in the size, and decrement size by one, since\n\t * the hw wants start/stop\n\t */\n\tsize += *offsetp - 1;\n\n\tcard_offset = (((long) card_addr) - ((long) busaddr));\n\n\tDPRINTF((\"tcic_chip_mem_map window %d card_offset 0x%lx\\n\",\n\t    win, (u_long)card_offset));\n\n\th->mem[win].addr = busaddr;\n\th->mem[win].size = size;\n\th->mem[win].size2 = tcic_log2((u_int)pcmhp->realsize) - TCIC_MEM_SHIFT;\n\th->mem[win].offset = card_offset;\n\th->mem[win].kind = kind;\n\n\ttcic_chip_do_mem_map(h, win);\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/ic/tcic2var.h>",
      "#include <dev/ic/tcic2reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <sys/kthread.h>",
      "#include <sys/malloc.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define\tTCIC_MEM_ALIGN\tTCIC_MEM_PAGESIZE"
    ],
    "globals_used": [
      "void\ttcic_chip_do_mem_map"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tcic_chip_do_mem_map",
          "args": [
            "h",
            "win"
          ],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_chip_do_mem_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
          "lines": "862-940",
          "snippet": "void \ntcic_chip_do_mem_map(h, win)\n\tstruct tcic_handle *h;\n\tint win;\n{\n\tint reg, hwwin, wscnt;\n\n\tint kind = h->mem[win].kind & ~PCMCIA_WIDTH_MEM_MASK;\n\tint mem8 = (h->mem[win].kind & PCMCIA_WIDTH_MEM_MASK) == PCMCIA_WIDTH_MEM8;\n\tDPRINTF((\"tcic_chip_do_mem_map window %d: 0x%lx+0x%lx 0x%lx\\n\",\n\t\twin, (u_long)h->mem[win].addr, (u_long)h->mem[win].size,\n\t\t(u_long)h->mem[win].offset));\n\t/*\n\t * the even windows are used for socket 0,\n\t * the odd ones for socket 1.\n\t */\n\thwwin = (win << 1) + h->sock;\n\n\t/* the WR_MEXT register is MBZ */\n\ttcic_write_ind_2(h, TCIC_WR_MEXT_N(hwwin), 0);\n\n\t/* set the host base address and window size */\n\tif (h->mem[win].size2 <= 1) {\n\t\treg = ((h->mem[win].addr >> TCIC_MEM_SHIFT) &\n\t\t    TCIC_MBASE_ADDR_MASK) | TCIC_MBASE_4K;\n\t} else {\n\t\treg = ((h->mem[win].addr >> TCIC_MEM_SHIFT) &\n\t\t    TCIC_MBASE_ADDR_MASK) | (h->mem[win].size2 >> 1);\n\t}\n\ttcic_write_ind_2(h, TCIC_WR_MBASE_N(hwwin), reg);\n\n\t/* set the card address and address space */\n\treg = 0;\n\treg = ((h->mem[win].offset >> TCIC_MEM_SHIFT) & TCIC_MMAP_ADDR_MASK);\n\treg |= (kind == PCMCIA_MEM_ATTR) ? TCIC_MMAP_ATTR : 0;\n\tDPRINTF((\"tcic_chip_do_map_mem window %d(%d) mmap 0x%04x\\n\",\n\t    win, hwwin, reg));\n\ttcic_write_ind_2(h, TCIC_WR_MMAP_N(hwwin), reg);\n\n\t/* set the MCTL register */\n\t/* must save WSCNT field in case this is a DB86082 rev 0 */\n\t/* XXX why can't I do the following two in one statement? */\n\treg = tcic_read_ind_2(h, TCIC_WR_MCTL_N(hwwin)) & TCIC_MCTL_WSCNT_MASK;\n\treg |= TCIC_MCTL_ENA|TCIC_MCTL_QUIET;\n\treg |= mem8 ? TCIC_MCTL_B8 : 0;\n\treg |= (h->sock << TCIC_MCTL_SS_SHIFT) & TCIC_MCTL_SS_MASK;\n#ifdef notyet\t/* XXX must get speed from CIS somehow. -chb */\n\twscnt = tcic_ns2wscnt(h->mem[win].speed);\n#else\n\twscnt = tcic_ns2wscnt(tcic_mem_speed);\t/*  300 is \"save\" default for CIS memory */\n#endif\n\tif (h->sc->chipid == TCIC_CHIPID_DB86082_1) {\n\t\t/*\n\t\t * this chip has the wait state count in window\n\t\t * register 7 - hwwin.\n\t\t */\n\t\tint reg2;\n\t\treg2 = tcic_read_ind_2(h, TCIC_WR_MCTL_N(7-hwwin));\n\t\treg2 &= ~TCIC_MCTL_WSCNT_MASK;\n\t\treg2 |= wscnt & TCIC_MCTL_WSCNT_MASK;\n\t\ttcic_write_ind_2(h, TCIC_WR_MCTL_N(7-hwwin), reg2);\n\t} else {\n\t\treg |= wscnt & TCIC_MCTL_WSCNT_MASK;\n\t}\n\ttcic_write_ind_2(h, TCIC_WR_MCTL_N(hwwin), reg);\n\n#ifdef TCICDEBUG\n\t{\n\t\tint r1, r2, r3;\n\n\t\tr1 = tcic_read_ind_2(h, TCIC_WR_MBASE_N(hwwin));\n\t\tr2 = tcic_read_ind_2(h, TCIC_WR_MMAP_N(hwwin));\n\t\tr3 = tcic_read_ind_2(h, TCIC_WR_MCTL_N(hwwin));\n\n\t\tDPRINTF((\"tcic_chip_do_mem_map window %d(%d): %04x %04x %04x\\n\",\n\t\t    win, hwwin, r1, r2, r3));\n\t}\n#endif\n}",
          "includes": [
            "#include <dev/ic/tcic2var.h>",
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttcic_chip_do_mem_map",
            "int tcic_mem_speed = 250;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\ttcic_chip_do_mem_map;\nint tcic_mem_speed = 250;\n\nvoid \ntcic_chip_do_mem_map(h, win)\n\tstruct tcic_handle *h;\n\tint win;\n{\n\tint reg, hwwin, wscnt;\n\n\tint kind = h->mem[win].kind & ~PCMCIA_WIDTH_MEM_MASK;\n\tint mem8 = (h->mem[win].kind & PCMCIA_WIDTH_MEM_MASK) == PCMCIA_WIDTH_MEM8;\n\tDPRINTF((\"tcic_chip_do_mem_map window %d: 0x%lx+0x%lx 0x%lx\\n\",\n\t\twin, (u_long)h->mem[win].addr, (u_long)h->mem[win].size,\n\t\t(u_long)h->mem[win].offset));\n\t/*\n\t * the even windows are used for socket 0,\n\t * the odd ones for socket 1.\n\t */\n\thwwin = (win << 1) + h->sock;\n\n\t/* the WR_MEXT register is MBZ */\n\ttcic_write_ind_2(h, TCIC_WR_MEXT_N(hwwin), 0);\n\n\t/* set the host base address and window size */\n\tif (h->mem[win].size2 <= 1) {\n\t\treg = ((h->mem[win].addr >> TCIC_MEM_SHIFT) &\n\t\t    TCIC_MBASE_ADDR_MASK) | TCIC_MBASE_4K;\n\t} else {\n\t\treg = ((h->mem[win].addr >> TCIC_MEM_SHIFT) &\n\t\t    TCIC_MBASE_ADDR_MASK) | (h->mem[win].size2 >> 1);\n\t}\n\ttcic_write_ind_2(h, TCIC_WR_MBASE_N(hwwin), reg);\n\n\t/* set the card address and address space */\n\treg = 0;\n\treg = ((h->mem[win].offset >> TCIC_MEM_SHIFT) & TCIC_MMAP_ADDR_MASK);\n\treg |= (kind == PCMCIA_MEM_ATTR) ? TCIC_MMAP_ATTR : 0;\n\tDPRINTF((\"tcic_chip_do_map_mem window %d(%d) mmap 0x%04x\\n\",\n\t    win, hwwin, reg));\n\ttcic_write_ind_2(h, TCIC_WR_MMAP_N(hwwin), reg);\n\n\t/* set the MCTL register */\n\t/* must save WSCNT field in case this is a DB86082 rev 0 */\n\t/* XXX why can't I do the following two in one statement? */\n\treg = tcic_read_ind_2(h, TCIC_WR_MCTL_N(hwwin)) & TCIC_MCTL_WSCNT_MASK;\n\treg |= TCIC_MCTL_ENA|TCIC_MCTL_QUIET;\n\treg |= mem8 ? TCIC_MCTL_B8 : 0;\n\treg |= (h->sock << TCIC_MCTL_SS_SHIFT) & TCIC_MCTL_SS_MASK;\n#ifdef notyet\t/* XXX must get speed from CIS somehow. -chb */\n\twscnt = tcic_ns2wscnt(h->mem[win].speed);\n#else\n\twscnt = tcic_ns2wscnt(tcic_mem_speed);\t/*  300 is \"save\" default for CIS memory */\n#endif\n\tif (h->sc->chipid == TCIC_CHIPID_DB86082_1) {\n\t\t/*\n\t\t * this chip has the wait state count in window\n\t\t * register 7 - hwwin.\n\t\t */\n\t\tint reg2;\n\t\treg2 = tcic_read_ind_2(h, TCIC_WR_MCTL_N(7-hwwin));\n\t\treg2 &= ~TCIC_MCTL_WSCNT_MASK;\n\t\treg2 |= wscnt & TCIC_MCTL_WSCNT_MASK;\n\t\ttcic_write_ind_2(h, TCIC_WR_MCTL_N(7-hwwin), reg2);\n\t} else {\n\t\treg |= wscnt & TCIC_MCTL_WSCNT_MASK;\n\t}\n\ttcic_write_ind_2(h, TCIC_WR_MCTL_N(hwwin), reg);\n\n#ifdef TCICDEBUG\n\t{\n\t\tint r1, r2, r3;\n\n\t\tr1 = tcic_read_ind_2(h, TCIC_WR_MBASE_N(hwwin));\n\t\tr2 = tcic_read_ind_2(h, TCIC_WR_MMAP_N(hwwin));\n\t\tr3 = tcic_read_ind_2(h, TCIC_WR_MCTL_N(hwwin));\n\n\t\tDPRINTF((\"tcic_chip_do_mem_map window %d(%d): %04x %04x %04x\\n\",\n\t\t    win, hwwin, r1, r2, r3));\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "tcic_log2",
          "args": [
            "(u_int)pcmhp->realsize"
          ],
          "line": 1007
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_log2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
          "lines": "1387-1401",
          "snippet": "int\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}",
          "includes": [
            "#include <dev/ic/tcic2var.h>",
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"tcic_chip_mem_map window %d card_offset 0x%lx\\n\",\n\t    win, (u_long)card_offset)"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"tcic_chip_mem_map window %d bus %lx+%lx+%lx at card addr \"\n\t    \"%lx\\n\", win, (u_long) busaddr, (u_long) * offsetp, (u_long) size,\n\t    (u_long) card_addr)"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"tcic_chip_mem_map memt is bogus\""
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tTCIC_MEM_ALIGN\tTCIC_MEM_PAGESIZE\n\nvoid\ttcic_chip_do_mem_map;\n\nint \ntcic_chip_mem_map(pch, kind, card_addr, size, pcmhp, offsetp, windowp)\n\tpcmcia_chipset_handle_t pch;\n\tint kind;\n\tbus_addr_t card_addr;\n\tbus_size_t size;\n\tstruct pcmcia_mem_handle *pcmhp;\n\tbus_addr_t *offsetp;\n\tint *windowp;\n{\n\tstruct tcic_handle *h = (struct tcic_handle *) pch;\n\tbus_addr_t busaddr;\n\tlong card_offset;\n\tint i, win;\n\n\twin = -1;\n\tfor (i = 0; i < h->memwins; i++) {\n\t\tif ((h->memalloc & (1 << i)) == 0) {\n\t\t\twin = i;\n\t\t\th->memalloc |= (1 << i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (win == -1)\n\t\treturn (1);\n\n\t*windowp = win;\n\n\t/* XXX this is pretty gross */\n\n\tif (h->sc->memt != pcmhp->memt)\n\t\tpanic(\"tcic_chip_mem_map memt is bogus\");\n\n\tbusaddr = pcmhp->addr;\n\n\t/*\n\t * compute the address offset to the pcmcia address space for the\n\t * tcic.  this is intentionally signed.  The masks and shifts below\n\t * will cause TRT to happen in the tcic registers.  Deal with making\n\t * sure the address is aligned, and return the alignment offset.\n\t */\n\n\t*offsetp = card_addr % TCIC_MEM_ALIGN;\n\tcard_addr -= *offsetp;\n\n\tDPRINTF((\"tcic_chip_mem_map window %d bus %lx+%lx+%lx at card addr \"\n\t    \"%lx\\n\", win, (u_long) busaddr, (u_long) * offsetp, (u_long) size,\n\t    (u_long) card_addr));\n\n\t/* XXX we can't use size. -chb */\n\t/*\n\t * include the offset in the size, and decrement size by one, since\n\t * the hw wants start/stop\n\t */\n\tsize += *offsetp - 1;\n\n\tcard_offset = (((long) card_addr) - ((long) busaddr));\n\n\tDPRINTF((\"tcic_chip_mem_map window %d card_offset 0x%lx\\n\",\n\t    win, (u_long)card_offset));\n\n\th->mem[win].addr = busaddr;\n\th->mem[win].size = size;\n\th->mem[win].size2 = tcic_log2((u_int)pcmhp->realsize) - TCIC_MEM_SHIFT;\n\th->mem[win].offset = card_offset;\n\th->mem[win].kind = kind;\n\n\ttcic_chip_do_mem_map(h, win);\n\n\treturn (0);\n}"
  },
  {
    "function_name": "tcic_chip_do_mem_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
    "lines": "862-940",
    "snippet": "void \ntcic_chip_do_mem_map(h, win)\n\tstruct tcic_handle *h;\n\tint win;\n{\n\tint reg, hwwin, wscnt;\n\n\tint kind = h->mem[win].kind & ~PCMCIA_WIDTH_MEM_MASK;\n\tint mem8 = (h->mem[win].kind & PCMCIA_WIDTH_MEM_MASK) == PCMCIA_WIDTH_MEM8;\n\tDPRINTF((\"tcic_chip_do_mem_map window %d: 0x%lx+0x%lx 0x%lx\\n\",\n\t\twin, (u_long)h->mem[win].addr, (u_long)h->mem[win].size,\n\t\t(u_long)h->mem[win].offset));\n\t/*\n\t * the even windows are used for socket 0,\n\t * the odd ones for socket 1.\n\t */\n\thwwin = (win << 1) + h->sock;\n\n\t/* the WR_MEXT register is MBZ */\n\ttcic_write_ind_2(h, TCIC_WR_MEXT_N(hwwin), 0);\n\n\t/* set the host base address and window size */\n\tif (h->mem[win].size2 <= 1) {\n\t\treg = ((h->mem[win].addr >> TCIC_MEM_SHIFT) &\n\t\t    TCIC_MBASE_ADDR_MASK) | TCIC_MBASE_4K;\n\t} else {\n\t\treg = ((h->mem[win].addr >> TCIC_MEM_SHIFT) &\n\t\t    TCIC_MBASE_ADDR_MASK) | (h->mem[win].size2 >> 1);\n\t}\n\ttcic_write_ind_2(h, TCIC_WR_MBASE_N(hwwin), reg);\n\n\t/* set the card address and address space */\n\treg = 0;\n\treg = ((h->mem[win].offset >> TCIC_MEM_SHIFT) & TCIC_MMAP_ADDR_MASK);\n\treg |= (kind == PCMCIA_MEM_ATTR) ? TCIC_MMAP_ATTR : 0;\n\tDPRINTF((\"tcic_chip_do_map_mem window %d(%d) mmap 0x%04x\\n\",\n\t    win, hwwin, reg));\n\ttcic_write_ind_2(h, TCIC_WR_MMAP_N(hwwin), reg);\n\n\t/* set the MCTL register */\n\t/* must save WSCNT field in case this is a DB86082 rev 0 */\n\t/* XXX why can't I do the following two in one statement? */\n\treg = tcic_read_ind_2(h, TCIC_WR_MCTL_N(hwwin)) & TCIC_MCTL_WSCNT_MASK;\n\treg |= TCIC_MCTL_ENA|TCIC_MCTL_QUIET;\n\treg |= mem8 ? TCIC_MCTL_B8 : 0;\n\treg |= (h->sock << TCIC_MCTL_SS_SHIFT) & TCIC_MCTL_SS_MASK;\n#ifdef notyet\t/* XXX must get speed from CIS somehow. -chb */\n\twscnt = tcic_ns2wscnt(h->mem[win].speed);\n#else\n\twscnt = tcic_ns2wscnt(tcic_mem_speed);\t/*  300 is \"save\" default for CIS memory */\n#endif\n\tif (h->sc->chipid == TCIC_CHIPID_DB86082_1) {\n\t\t/*\n\t\t * this chip has the wait state count in window\n\t\t * register 7 - hwwin.\n\t\t */\n\t\tint reg2;\n\t\treg2 = tcic_read_ind_2(h, TCIC_WR_MCTL_N(7-hwwin));\n\t\treg2 &= ~TCIC_MCTL_WSCNT_MASK;\n\t\treg2 |= wscnt & TCIC_MCTL_WSCNT_MASK;\n\t\ttcic_write_ind_2(h, TCIC_WR_MCTL_N(7-hwwin), reg2);\n\t} else {\n\t\treg |= wscnt & TCIC_MCTL_WSCNT_MASK;\n\t}\n\ttcic_write_ind_2(h, TCIC_WR_MCTL_N(hwwin), reg);\n\n#ifdef TCICDEBUG\n\t{\n\t\tint r1, r2, r3;\n\n\t\tr1 = tcic_read_ind_2(h, TCIC_WR_MBASE_N(hwwin));\n\t\tr2 = tcic_read_ind_2(h, TCIC_WR_MMAP_N(hwwin));\n\t\tr3 = tcic_read_ind_2(h, TCIC_WR_MCTL_N(hwwin));\n\n\t\tDPRINTF((\"tcic_chip_do_mem_map window %d(%d): %04x %04x %04x\\n\",\n\t\t    win, hwwin, r1, r2, r3));\n\t}\n#endif\n}",
    "includes": [
      "#include <dev/ic/tcic2var.h>",
      "#include <dev/ic/tcic2reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <sys/kthread.h>",
      "#include <sys/malloc.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\ttcic_chip_do_mem_map",
      "int tcic_mem_speed = 250;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"tcic_chip_do_mem_map window %d(%d): %04x %04x %04x\\n\",\n\t\t    win, hwwin, r1, r2, r3)"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcic_read_ind_2",
          "args": [
            "h",
            "TCIC_WR_MCTL_N(hwwin)"
          ],
          "line": 934
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_read_ind_2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2var.h",
          "lines": "248-259",
          "snippet": "static __inline__ int\ntcic_read_ind_2(h, reg)\n\tstruct tcic_handle *h;\n\tint reg;\n{\n\tint r_addr, val;\n\tr_addr = tcic_read_4(h, TCIC_R_ADDR);\n\ttcic_write_4(h, TCIC_R_ADDR, reg|TCIC_ADDR_INDREG);\n\tval = bus_space_read_2(h->sc->iot, h->sc->ioh, TCIC_R_DATA);\n\ttcic_write_4(h, TCIC_R_ADDR, r_addr);\n\treturn val;\n}",
          "includes": [
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/device.h>\n\nstatic __inline__ int\ntcic_read_ind_2(h, reg)\n\tstruct tcic_handle *h;\n\tint reg;\n{\n\tint r_addr, val;\n\tr_addr = tcic_read_4(h, TCIC_R_ADDR);\n\ttcic_write_4(h, TCIC_R_ADDR, reg|TCIC_ADDR_INDREG);\n\tval = bus_space_read_2(h->sc->iot, h->sc->ioh, TCIC_R_DATA);\n\ttcic_write_4(h, TCIC_R_ADDR, r_addr);\n\treturn val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TCIC_WR_MCTL_N",
          "args": [
            "hwwin"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TCIC_WR_MMAP_N",
          "args": [
            "hwwin"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TCIC_WR_MBASE_N",
          "args": [
            "hwwin"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcic_write_ind_2",
          "args": [
            "h",
            "TCIC_WR_MCTL_N(hwwin)",
            "reg"
          ],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_write_ind_2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2var.h",
          "lines": "262-273",
          "snippet": "static __inline__ void\ntcic_write_ind_2(h, reg, data)\n\tstruct tcic_handle *h;\n\tint reg;\n\tint data;\n{\n\tint r_addr;\n\tr_addr = tcic_read_4(h, TCIC_R_ADDR);\n\ttcic_write_4(h, TCIC_R_ADDR, reg|TCIC_ADDR_INDREG);\n\tbus_space_write_2(h->sc->iot, h->sc->ioh, TCIC_R_DATA, (data));\n\ttcic_write_4(h, TCIC_R_ADDR, r_addr);\n}",
          "includes": [
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/device.h>\n\nstatic __inline__ void\ntcic_write_ind_2(h, reg, data)\n\tstruct tcic_handle *h;\n\tint reg;\n\tint data;\n{\n\tint r_addr;\n\tr_addr = tcic_read_4(h, TCIC_R_ADDR);\n\ttcic_write_4(h, TCIC_R_ADDR, reg|TCIC_ADDR_INDREG);\n\tbus_space_write_2(h->sc->iot, h->sc->ioh, TCIC_R_DATA, (data));\n\ttcic_write_4(h, TCIC_R_ADDR, r_addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TCIC_WR_MCTL_N",
          "args": [
            "hwwin"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TCIC_WR_MCTL_N",
          "args": [
            "7-hwwin"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TCIC_WR_MCTL_N",
          "args": [
            "7-hwwin"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcic_ns2wscnt",
          "args": [
            "tcic_mem_speed"
          ],
          "line": 911
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_ns2wscnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
          "lines": "1376-1385",
          "snippet": "int\ntcic_ns2wscnt(ns)\n\tint ns;\n{\n\tif (ns < 14) {\n\t\treturn 0;\n\t} else {\n\t\treturn (2*(ns-14))/70;\t/* XXX assumes 14.31818 MHz clock. */\n\t}\n}",
          "includes": [
            "#include <dev/ic/tcic2var.h>",
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\ntcic_ns2wscnt(ns)\n\tint ns;\n{\n\tif (ns < 14) {\n\t\treturn 0;\n\t} else {\n\t\treturn (2*(ns-14))/70;\t/* XXX assumes 14.31818 MHz clock. */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "TCIC_WR_MCTL_N",
          "args": [
            "hwwin"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TCIC_WR_MMAP_N",
          "args": [
            "hwwin"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"tcic_chip_do_map_mem window %d(%d) mmap 0x%04x\\n\",\n\t    win, hwwin, reg)"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TCIC_WR_MBASE_N",
          "args": [
            "hwwin"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TCIC_WR_MEXT_N",
          "args": [
            "hwwin"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"tcic_chip_do_mem_map window %d: 0x%lx+0x%lx 0x%lx\\n\",\n\t\twin, (u_long)h->mem[win].addr, (u_long)h->mem[win].size,\n\t\t(u_long)h->mem[win].offset)"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\ttcic_chip_do_mem_map;\nint tcic_mem_speed = 250;\n\nvoid \ntcic_chip_do_mem_map(h, win)\n\tstruct tcic_handle *h;\n\tint win;\n{\n\tint reg, hwwin, wscnt;\n\n\tint kind = h->mem[win].kind & ~PCMCIA_WIDTH_MEM_MASK;\n\tint mem8 = (h->mem[win].kind & PCMCIA_WIDTH_MEM_MASK) == PCMCIA_WIDTH_MEM8;\n\tDPRINTF((\"tcic_chip_do_mem_map window %d: 0x%lx+0x%lx 0x%lx\\n\",\n\t\twin, (u_long)h->mem[win].addr, (u_long)h->mem[win].size,\n\t\t(u_long)h->mem[win].offset));\n\t/*\n\t * the even windows are used for socket 0,\n\t * the odd ones for socket 1.\n\t */\n\thwwin = (win << 1) + h->sock;\n\n\t/* the WR_MEXT register is MBZ */\n\ttcic_write_ind_2(h, TCIC_WR_MEXT_N(hwwin), 0);\n\n\t/* set the host base address and window size */\n\tif (h->mem[win].size2 <= 1) {\n\t\treg = ((h->mem[win].addr >> TCIC_MEM_SHIFT) &\n\t\t    TCIC_MBASE_ADDR_MASK) | TCIC_MBASE_4K;\n\t} else {\n\t\treg = ((h->mem[win].addr >> TCIC_MEM_SHIFT) &\n\t\t    TCIC_MBASE_ADDR_MASK) | (h->mem[win].size2 >> 1);\n\t}\n\ttcic_write_ind_2(h, TCIC_WR_MBASE_N(hwwin), reg);\n\n\t/* set the card address and address space */\n\treg = 0;\n\treg = ((h->mem[win].offset >> TCIC_MEM_SHIFT) & TCIC_MMAP_ADDR_MASK);\n\treg |= (kind == PCMCIA_MEM_ATTR) ? TCIC_MMAP_ATTR : 0;\n\tDPRINTF((\"tcic_chip_do_map_mem window %d(%d) mmap 0x%04x\\n\",\n\t    win, hwwin, reg));\n\ttcic_write_ind_2(h, TCIC_WR_MMAP_N(hwwin), reg);\n\n\t/* set the MCTL register */\n\t/* must save WSCNT field in case this is a DB86082 rev 0 */\n\t/* XXX why can't I do the following two in one statement? */\n\treg = tcic_read_ind_2(h, TCIC_WR_MCTL_N(hwwin)) & TCIC_MCTL_WSCNT_MASK;\n\treg |= TCIC_MCTL_ENA|TCIC_MCTL_QUIET;\n\treg |= mem8 ? TCIC_MCTL_B8 : 0;\n\treg |= (h->sock << TCIC_MCTL_SS_SHIFT) & TCIC_MCTL_SS_MASK;\n#ifdef notyet\t/* XXX must get speed from CIS somehow. -chb */\n\twscnt = tcic_ns2wscnt(h->mem[win].speed);\n#else\n\twscnt = tcic_ns2wscnt(tcic_mem_speed);\t/*  300 is \"save\" default for CIS memory */\n#endif\n\tif (h->sc->chipid == TCIC_CHIPID_DB86082_1) {\n\t\t/*\n\t\t * this chip has the wait state count in window\n\t\t * register 7 - hwwin.\n\t\t */\n\t\tint reg2;\n\t\treg2 = tcic_read_ind_2(h, TCIC_WR_MCTL_N(7-hwwin));\n\t\treg2 &= ~TCIC_MCTL_WSCNT_MASK;\n\t\treg2 |= wscnt & TCIC_MCTL_WSCNT_MASK;\n\t\ttcic_write_ind_2(h, TCIC_WR_MCTL_N(7-hwwin), reg2);\n\t} else {\n\t\treg |= wscnt & TCIC_MCTL_WSCNT_MASK;\n\t}\n\ttcic_write_ind_2(h, TCIC_WR_MCTL_N(hwwin), reg);\n\n#ifdef TCICDEBUG\n\t{\n\t\tint r1, r2, r3;\n\n\t\tr1 = tcic_read_ind_2(h, TCIC_WR_MBASE_N(hwwin));\n\t\tr2 = tcic_read_ind_2(h, TCIC_WR_MMAP_N(hwwin));\n\t\tr3 = tcic_read_ind_2(h, TCIC_WR_MCTL_N(hwwin));\n\n\t\tDPRINTF((\"tcic_chip_do_mem_map window %d(%d): %04x %04x %04x\\n\",\n\t\t    win, hwwin, r1, r2, r3));\n\t}\n#endif\n}"
  },
  {
    "function_name": "tcic_chip_mem_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
    "lines": "852-860",
    "snippet": "void \ntcic_chip_mem_free(pch, pcmhp)\n\tpcmcia_chipset_handle_t pch;\n\tstruct pcmcia_mem_handle *pcmhp;\n{\n\tstruct tcic_handle *h = (struct tcic_handle *) pch;\n\n\th->sc->subregionmask |= pcmhp->mhandle;\n}",
    "includes": [
      "#include <dev/ic/tcic2var.h>",
      "#include <dev/ic/tcic2reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <sys/kthread.h>",
      "#include <sys/malloc.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid \ntcic_chip_mem_free(pch, pcmhp)\n\tpcmcia_chipset_handle_t pch;\n\tstruct pcmcia_mem_handle *pcmhp;\n{\n\tstruct tcic_handle *h = (struct tcic_handle *) pch;\n\n\th->sc->subregionmask |= pcmhp->mhandle;\n}"
  },
  {
    "function_name": "tcic_chip_mem_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
    "lines": "787-849",
    "snippet": "int \ntcic_chip_mem_alloc(pch, size, pcmhp)\n\tpcmcia_chipset_handle_t pch;\n\tbus_size_t size;\n\tstruct pcmcia_mem_handle *pcmhp;\n{\n\tstruct tcic_handle *h = (struct tcic_handle *) pch;\n\tbus_space_handle_t memh;\n\tbus_addr_t addr;\n\tbus_size_t sizepg;\n\tint i, mask, mhandle;\n\n\t/* out of sc->memh, allocate as many pages as necessary */\n\n\t/*\n\t * The TCIC can map memory only in sizes that are\n\t * powers of two, aligned at the natural boundary for the size.\n\t */\n\ti = tcic_log2((u_int)size);\n\tif ((1<<i) < size)\n\t\ti++;\n\tsizepg = max(i, TCIC_MEM_SHIFT) - (TCIC_MEM_SHIFT-1);\n\n\tDPRINTF((\"tcic_chip_mem_alloc: size %ld sizepg %ld\\n\", size, sizepg));\n\n\t/* can't allocate that much anyway */\n\tif (sizepg > TCIC_MEM_PAGES)\t/* XXX -chb */\n\t\treturn 1;\n\n\tmask = (1 << sizepg) - 1;\n\n\taddr = 0;\t\t/* XXX gcc -Wuninitialized */\n\tmhandle = 0;\t\t/* XXX gcc -Wuninitialized */\n\n\t/* XXX i should be initialised to always lay on boundary. -chb */\n\tfor (i = 0; i < (TCIC_MEM_PAGES + 1 - sizepg); i += sizepg) {\n\t\tif ((h->sc->subregionmask & (mask << i)) == (mask << i)) {\n\t\t\tif (bus_space_subregion(h->sc->memt, h->sc->memh,\n\t\t\t    i * TCIC_MEM_PAGESIZE,\n\t\t\t    sizepg * TCIC_MEM_PAGESIZE, &memh))\n\t\t\t\treturn (1);\n\t\t\tmhandle = mask << i;\n\t\t\taddr = h->sc->membase + (i * TCIC_MEM_PAGESIZE);\n\t\t\th->sc->subregionmask &= ~(mhandle);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == (TCIC_MEM_PAGES + 1 - sizepg))\n\t\treturn (1);\n\n\tDPRINTF((\"tcic_chip_mem_alloc bus addr 0x%lx+0x%lx\\n\", (u_long) addr,\n\t\t (u_long) size));\n\n\tpcmhp->memt = h->sc->memt;\n\tpcmhp->memh = memh;\n\tpcmhp->addr = addr;\n\tpcmhp->size = size;\n\tpcmhp->mhandle = mhandle;\n\tpcmhp->realsize = sizepg * TCIC_MEM_PAGESIZE;\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/ic/tcic2var.h>",
      "#include <dev/ic/tcic2reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <sys/kthread.h>",
      "#include <sys/malloc.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"tcic_chip_mem_alloc bus addr 0x%lx+0x%lx\\n\", (u_long) addr,\n\t\t (u_long) size)"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_subregion",
          "args": [
            "h->sc->memt",
            "h->sc->memh",
            "i * TCIC_MEM_PAGESIZE",
            "sizepg * TCIC_MEM_PAGESIZE",
            "&memh"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"tcic_chip_mem_alloc: size %ld sizepg %ld\\n\", size, sizepg)"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "i",
            "TCIC_MEM_SHIFT"
          ],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_setmaxtags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "5620-5630",
          "snippet": "static void ncr_setmaxtags (tcb_p tp, u_long usrtags)\n{\n\tint l;\n\tfor (l=0; l<MAX_LUN; l++) {\n\t\tlcb_p lp;\n\t\tif (!tp) break;\n\t\tlp=tp->lp[l];\n\t\tif (!lp) continue;\n\t\tncr_settags (tp, lp, usrtags);\n\t};\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [
            "#define MAX_LUN     (8)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\n#define MAX_LUN     (8)\n\nstatic void ncr_setmaxtags (tcb_p tp, u_long usrtags)\n{\n\tint l;\n\tfor (l=0; l<MAX_LUN; l++) {\n\t\tlcb_p lp;\n\t\tif (!tp) break;\n\t\tlp=tp->lp[l];\n\t\tif (!lp) continue;\n\t\tncr_settags (tp, lp, usrtags);\n\t};\n}"
        }
      },
      {
        "call_info": {
          "callee": "tcic_log2",
          "args": [
            "(u_int)size"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_log2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
          "lines": "1387-1401",
          "snippet": "int\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}",
          "includes": [
            "#include <dev/ic/tcic2var.h>",
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint \ntcic_chip_mem_alloc(pch, size, pcmhp)\n\tpcmcia_chipset_handle_t pch;\n\tbus_size_t size;\n\tstruct pcmcia_mem_handle *pcmhp;\n{\n\tstruct tcic_handle *h = (struct tcic_handle *) pch;\n\tbus_space_handle_t memh;\n\tbus_addr_t addr;\n\tbus_size_t sizepg;\n\tint i, mask, mhandle;\n\n\t/* out of sc->memh, allocate as many pages as necessary */\n\n\t/*\n\t * The TCIC can map memory only in sizes that are\n\t * powers of two, aligned at the natural boundary for the size.\n\t */\n\ti = tcic_log2((u_int)size);\n\tif ((1<<i) < size)\n\t\ti++;\n\tsizepg = max(i, TCIC_MEM_SHIFT) - (TCIC_MEM_SHIFT-1);\n\n\tDPRINTF((\"tcic_chip_mem_alloc: size %ld sizepg %ld\\n\", size, sizepg));\n\n\t/* can't allocate that much anyway */\n\tif (sizepg > TCIC_MEM_PAGES)\t/* XXX -chb */\n\t\treturn 1;\n\n\tmask = (1 << sizepg) - 1;\n\n\taddr = 0;\t\t/* XXX gcc -Wuninitialized */\n\tmhandle = 0;\t\t/* XXX gcc -Wuninitialized */\n\n\t/* XXX i should be initialised to always lay on boundary. -chb */\n\tfor (i = 0; i < (TCIC_MEM_PAGES + 1 - sizepg); i += sizepg) {\n\t\tif ((h->sc->subregionmask & (mask << i)) == (mask << i)) {\n\t\t\tif (bus_space_subregion(h->sc->memt, h->sc->memh,\n\t\t\t    i * TCIC_MEM_PAGESIZE,\n\t\t\t    sizepg * TCIC_MEM_PAGESIZE, &memh))\n\t\t\t\treturn (1);\n\t\t\tmhandle = mask << i;\n\t\t\taddr = h->sc->membase + (i * TCIC_MEM_PAGESIZE);\n\t\t\th->sc->subregionmask &= ~(mhandle);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == (TCIC_MEM_PAGES + 1 - sizepg))\n\t\treturn (1);\n\n\tDPRINTF((\"tcic_chip_mem_alloc bus addr 0x%lx+0x%lx\\n\", (u_long) addr,\n\t\t (u_long) size));\n\n\tpcmhp->memt = h->sc->memt;\n\tpcmhp->memh = memh;\n\tpcmhp->addr = addr;\n\tpcmhp->size = size;\n\tpcmhp->mhandle = mhandle;\n\tpcmhp->realsize = sizepg * TCIC_MEM_PAGESIZE;\n\n\treturn (0);\n}"
  },
  {
    "function_name": "tcic_deactivate_card",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
    "lines": "754-784",
    "snippet": "void\ntcic_deactivate_card(h)\n\tstruct tcic_handle *h;\n{\n\tint val, reg;\n\n\tif (!(h->flags & TCIC_FLAG_CARDP))\n\t\t panic(\"tcic_deactivate_card: already detached\");\n\n\t/* call the MI deactivate function */\n\tpcmcia_card_deactivate(h->pcmcia);\n\n\ttcic_sel_sock(h);\n\n\t/* XXX disable card detect resume and configuration reset??? */\n\n\t/* power down the socket */\n\ttcic_write_1(h, TCIC_R_PWR, 0);\n\n\t/* reset the card XXX ? -chb */\n\n\t/* turn off irq's for this socket */\n\treg = TCIC_IR_SCF1_N(h->sock);\n\tval = tcic_read_ind_2(h, reg);\n\ttcic_write_ind_2(h, reg, (val & ~TCIC_SCF1_IRQ_MASK)|TCIC_SCF1_IRQOFF);\n\treg = TCIC_IR_SCF2_N(h->sock);\n\tval = tcic_read_ind_2(h, reg);\n\ttcic_write_ind_2(h, reg,\n\t    (val | (TCIC_SCF2_MLBAT1|TCIC_SCF2_MLBAT2|TCIC_SCF2_MRDY\n\t\t|TCIC_SCF2_MWP|TCIC_SCF2_MCD)));\n}",
    "includes": [
      "#include <dev/ic/tcic2var.h>",
      "#include <dev/ic/tcic2reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <sys/kthread.h>",
      "#include <sys/malloc.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\ttcic_deactivate_card"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tcic_write_ind_2",
          "args": [
            "h",
            "reg",
            "(val | (TCIC_SCF2_MLBAT1|TCIC_SCF2_MLBAT2|TCIC_SCF2_MRDY\n\t\t|TCIC_SCF2_MWP|TCIC_SCF2_MCD))"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_write_ind_2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2var.h",
          "lines": "262-273",
          "snippet": "static __inline__ void\ntcic_write_ind_2(h, reg, data)\n\tstruct tcic_handle *h;\n\tint reg;\n\tint data;\n{\n\tint r_addr;\n\tr_addr = tcic_read_4(h, TCIC_R_ADDR);\n\ttcic_write_4(h, TCIC_R_ADDR, reg|TCIC_ADDR_INDREG);\n\tbus_space_write_2(h->sc->iot, h->sc->ioh, TCIC_R_DATA, (data));\n\ttcic_write_4(h, TCIC_R_ADDR, r_addr);\n}",
          "includes": [
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/device.h>\n\nstatic __inline__ void\ntcic_write_ind_2(h, reg, data)\n\tstruct tcic_handle *h;\n\tint reg;\n\tint data;\n{\n\tint r_addr;\n\tr_addr = tcic_read_4(h, TCIC_R_ADDR);\n\ttcic_write_4(h, TCIC_R_ADDR, reg|TCIC_ADDR_INDREG);\n\tbus_space_write_2(h->sc->iot, h->sc->ioh, TCIC_R_DATA, (data));\n\ttcic_write_4(h, TCIC_R_ADDR, r_addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tcic_read_ind_2",
          "args": [
            "h",
            "reg"
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_read_ind_2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2var.h",
          "lines": "248-259",
          "snippet": "static __inline__ int\ntcic_read_ind_2(h, reg)\n\tstruct tcic_handle *h;\n\tint reg;\n{\n\tint r_addr, val;\n\tr_addr = tcic_read_4(h, TCIC_R_ADDR);\n\ttcic_write_4(h, TCIC_R_ADDR, reg|TCIC_ADDR_INDREG);\n\tval = bus_space_read_2(h->sc->iot, h->sc->ioh, TCIC_R_DATA);\n\ttcic_write_4(h, TCIC_R_ADDR, r_addr);\n\treturn val;\n}",
          "includes": [
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/device.h>\n\nstatic __inline__ int\ntcic_read_ind_2(h, reg)\n\tstruct tcic_handle *h;\n\tint reg;\n{\n\tint r_addr, val;\n\tr_addr = tcic_read_4(h, TCIC_R_ADDR);\n\ttcic_write_4(h, TCIC_R_ADDR, reg|TCIC_ADDR_INDREG);\n\tval = bus_space_read_2(h->sc->iot, h->sc->ioh, TCIC_R_DATA);\n\ttcic_write_4(h, TCIC_R_ADDR, r_addr);\n\treturn val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TCIC_IR_SCF2_N",
          "args": [
            "h->sock"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TCIC_IR_SCF1_N",
          "args": [
            "h->sock"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcic_write_1",
          "args": [
            "h",
            "TCIC_R_PWR",
            "0"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_write_1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2var.h",
          "lines": "217-224",
          "snippet": "static __inline__ void\ntcic_write_1(h, reg, data)\n\tstruct tcic_handle *h;\n\tint reg;\n\tint data;\n{\n\tbus_space_write_1(h->sc->iot, h->sc->ioh, reg, (data));\n}",
          "includes": [
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/device.h>\n\nstatic __inline__ void\ntcic_write_1(h, reg, data)\n\tstruct tcic_handle *h;\n\tint reg;\n\tint data;\n{\n\tbus_space_write_1(h->sc->iot, h->sc->ioh, reg, (data));\n}"
        }
      },
      {
        "call_info": {
          "callee": "tcic_sel_sock",
          "args": [
            "h"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_sel_sock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2var.h",
          "lines": "276-284",
          "snippet": "static __inline__ void\ntcic_sel_sock(h)\n\tstruct tcic_handle *h;\n{\n\tint r_addr;\n\tr_addr = tcic_read_2(h, TCIC_R_ADDR2);\n\ttcic_write_2(h, TCIC_R_ADDR2,\n\t    (h->sock<<TCIC_ADDR2_SS_SHFT)|(r_addr & ~TCIC_ADDR2_SS_MASK));\n}",
          "includes": [
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/device.h>\n\nstatic __inline__ void\ntcic_sel_sock(h)\n\tstruct tcic_handle *h;\n{\n\tint r_addr;\n\tr_addr = tcic_read_2(h, TCIC_R_ADDR2);\n\ttcic_write_2(h, TCIC_R_ADDR2,\n\t    (h->sock<<TCIC_ADDR2_SS_SHFT)|(r_addr & ~TCIC_ADDR2_SS_MASK));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_card_deactivate",
          "args": [
            "h->pcmcia"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_card_deactivate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "282-304",
          "snippet": "void\npcmcia_card_deactivate(dev)\n\tstruct device *dev;\n{\n\tstruct pcmcia_softc *sc = (struct pcmcia_softc *) dev;\n\tstruct pcmcia_function *pf;\n\n\t/*\n\t * We're in the chip's card removal interrupt handler.\n\t * Deactivate the child driver.  The PCMCIA socket's\n\t * event thread will run later to finish the detach.\n\t */\n\tfor (pf = SIMPLEQ_FIRST(&sc->card.pf_head); pf != NULL;\n\t     pf = SIMPLEQ_NEXT(pf, pf_list)) {\n\t\tif (SIMPLEQ_FIRST(&pf->cfe_head) == NULL)\n\t\t\tcontinue;\n\t\tif (pf->child == NULL)\n\t\t\tcontinue;\n\t\tDPRINTF((\"%s: deactivating %s (function %d)\\n\",\n\t\t    sc->dev.dv_xname, pf->child->dv_xname, pf->number));\n\t\tconfig_deactivate(pf->child);\n\t}\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\n\nvoid\npcmcia_card_deactivate(dev)\n\tstruct device *dev;\n{\n\tstruct pcmcia_softc *sc = (struct pcmcia_softc *) dev;\n\tstruct pcmcia_function *pf;\n\n\t/*\n\t * We're in the chip's card removal interrupt handler.\n\t * Deactivate the child driver.  The PCMCIA socket's\n\t * event thread will run later to finish the detach.\n\t */\n\tfor (pf = SIMPLEQ_FIRST(&sc->card.pf_head); pf != NULL;\n\t     pf = SIMPLEQ_NEXT(pf, pf_list)) {\n\t\tif (SIMPLEQ_FIRST(&pf->cfe_head) == NULL)\n\t\t\tcontinue;\n\t\tif (pf->child == NULL)\n\t\t\tcontinue;\n\t\tDPRINTF((\"%s: deactivating %s (function %d)\\n\",\n\t\t    sc->dev.dv_xname, pf->child->dv_xname, pf->number));\n\t\tconfig_deactivate(pf->child);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"tcic_deactivate_card: already detached\""
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\ttcic_deactivate_card;\n\nvoid\ntcic_deactivate_card(h)\n\tstruct tcic_handle *h;\n{\n\tint val, reg;\n\n\tif (!(h->flags & TCIC_FLAG_CARDP))\n\t\t panic(\"tcic_deactivate_card: already detached\");\n\n\t/* call the MI deactivate function */\n\tpcmcia_card_deactivate(h->pcmcia);\n\n\ttcic_sel_sock(h);\n\n\t/* XXX disable card detect resume and configuration reset??? */\n\n\t/* power down the socket */\n\ttcic_write_1(h, TCIC_R_PWR, 0);\n\n\t/* reset the card XXX ? -chb */\n\n\t/* turn off irq's for this socket */\n\treg = TCIC_IR_SCF1_N(h->sock);\n\tval = tcic_read_ind_2(h, reg);\n\ttcic_write_ind_2(h, reg, (val & ~TCIC_SCF1_IRQ_MASK)|TCIC_SCF1_IRQOFF);\n\treg = TCIC_IR_SCF2_N(h->sock);\n\tval = tcic_read_ind_2(h, reg);\n\ttcic_write_ind_2(h, reg,\n\t    (val | (TCIC_SCF2_MLBAT1|TCIC_SCF2_MLBAT2|TCIC_SCF2_MRDY\n\t\t|TCIC_SCF2_MWP|TCIC_SCF2_MCD)));\n}"
  },
  {
    "function_name": "tcic_detach_card",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
    "lines": "736-752",
    "snippet": "void\ntcic_detach_card(h, flags)\n\tstruct tcic_handle *h;\n\tint flags;\t\t/* DETACH_* */\n{\n\tDPRINTF((\"tcic_detach_card\\n\"));\n\n\tif (!(h->flags & TCIC_FLAG_CARDP))\n\t\tpanic(\"tcic_detach_card: already detached\");\n\n\th->flags &= ~TCIC_FLAG_CARDP;\n\n\t/* call the MI detach function */\n\n\tpcmcia_card_detach(h->pcmcia, flags);\n\n}",
    "includes": [
      "#include <dev/ic/tcic2var.h>",
      "#include <dev/ic/tcic2reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <sys/kthread.h>",
      "#include <sys/malloc.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\ttcic_detach_card"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcmcia_card_detach",
          "args": [
            "h->pcmcia",
            "flags"
          ],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_card_detach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "252-280",
          "snippet": "void\npcmcia_card_detach(dev, flags)\n\tstruct device *dev;\n\tint flags;\t\t/* DETACH_* flags */\n{\n\tstruct pcmcia_softc *sc = (struct pcmcia_softc *) dev;\n\tstruct pcmcia_function *pf;\n\tint error;\n\n\t/*\n\t * We are running on either the PCMCIA socket's event thread\n\t * or in user context detaching a device by user request.\n\t */\n\tfor (pf = SIMPLEQ_FIRST(&sc->card.pf_head); pf != NULL;\n\t     pf = SIMPLEQ_NEXT(pf, pf_list)) {\n\t\tif (SIMPLEQ_FIRST(&pf->cfe_head) == NULL)\n\t\t\tcontinue;\n\t\tif (pf->child == NULL)\n\t\t\tcontinue;\n\t\tDPRINTF((\"%s: detaching %s (function %d)\\n\",\n\t\t    sc->dev.dv_xname, pf->child->dv_xname, pf->number));\n\t\tif ((error = config_detach(pf->child, flags)) != 0) {\n\t\t\tprintf(\"%s: error %d detaching %s (function %d)\\n\",\n\t\t\t    sc->dev.dv_xname, error, pf->child->dv_xname,\n\t\t\t    pf->number);\n\t\t} else\n\t\t\tpf->child = NULL;\n\t}\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\n\nvoid\npcmcia_card_detach(dev, flags)\n\tstruct device *dev;\n\tint flags;\t\t/* DETACH_* flags */\n{\n\tstruct pcmcia_softc *sc = (struct pcmcia_softc *) dev;\n\tstruct pcmcia_function *pf;\n\tint error;\n\n\t/*\n\t * We are running on either the PCMCIA socket's event thread\n\t * or in user context detaching a device by user request.\n\t */\n\tfor (pf = SIMPLEQ_FIRST(&sc->card.pf_head); pf != NULL;\n\t     pf = SIMPLEQ_NEXT(pf, pf_list)) {\n\t\tif (SIMPLEQ_FIRST(&pf->cfe_head) == NULL)\n\t\t\tcontinue;\n\t\tif (pf->child == NULL)\n\t\t\tcontinue;\n\t\tDPRINTF((\"%s: detaching %s (function %d)\\n\",\n\t\t    sc->dev.dv_xname, pf->child->dv_xname, pf->number));\n\t\tif ((error = config_detach(pf->child, flags)) != 0) {\n\t\t\tprintf(\"%s: error %d detaching %s (function %d)\\n\",\n\t\t\t    sc->dev.dv_xname, error, pf->child->dv_xname,\n\t\t\t    pf->number);\n\t\t} else\n\t\t\tpf->child = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"tcic_detach_card: already detached\""
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"tcic_detach_card\\n\")"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\ttcic_detach_card;\n\nvoid\ntcic_detach_card(h, flags)\n\tstruct tcic_handle *h;\n\tint flags;\t\t/* DETACH_* */\n{\n\tDPRINTF((\"tcic_detach_card\\n\"));\n\n\tif (!(h->flags & TCIC_FLAG_CARDP))\n\t\tpanic(\"tcic_detach_card: already detached\");\n\n\th->flags &= ~TCIC_FLAG_CARDP;\n\n\t/* call the MI detach function */\n\n\tpcmcia_card_detach(h->pcmcia, flags);\n\n}"
  },
  {
    "function_name": "tcic_attach_card",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
    "lines": "720-734",
    "snippet": "void\ntcic_attach_card(h)\n\tstruct tcic_handle *h;\n{\n\tDPRINTF((\"tcic_attach_card\\n\"));\n\n\tif (h->flags & TCIC_FLAG_CARDP)\n\t\tpanic(\"tcic_attach_card: already attached\");\n\n\t/* call the MI attach function */\n\n\tpcmcia_card_attach(h->pcmcia);\n\n\th->flags |= TCIC_FLAG_CARDP;\n}",
    "includes": [
      "#include <dev/ic/tcic2var.h>",
      "#include <dev/ic/tcic2reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <sys/kthread.h>",
      "#include <sys/malloc.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\ttcic_attach_card"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcmcia_card_attach",
          "args": [
            "h->pcmcia"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_card_attach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "159-250",
          "snippet": "int\npcmcia_card_attach(dev)\n\tstruct device *dev;\n{\n\tstruct pcmcia_softc *sc = (struct pcmcia_softc *) dev;\n\tstruct pcmcia_function *pf;\n\tstruct pcmcia_attach_args paa;\n\tint attached;\n\n\t/*\n\t * this is here so that when socket_enable calls gettype, trt happens\n\t */\n\tsc->card.pf_head.sqh_first = NULL;\n\n\tpcmcia_chip_socket_enable(sc->pct, sc->pch);\n\n\tpcmcia_read_cis(sc);\n\n\tpcmcia_chip_socket_disable(sc->pct, sc->pch);\n\n\tpcmcia_check_cis_quirks(sc);\n\n#if 1\n\t/*\n\t * Bail now if the card has no functions, or if there was an error in\n\t * the CIS.\n\t */\n\n\tif (sc->card.error)\n\t\treturn (1);\n\tif (sc->card.pf_head.sqh_first == NULL)\n\t\treturn (1);\n#endif\n\n\tif (pcmcia_verbose)\n\t\tpcmcia_print_cis(sc);\n\n\t/*\n\t * If there was no function, this might be CIS-less card we still\n\t * want to probe.  Fixup a function element for it.\n\t */\n\tif (SIMPLEQ_FIRST(&sc->card.pf_head) == NULL) {\n\t\tpf = malloc(sizeof *pf, M_DEVBUF, M_NOWAIT);\n\t\tbzero(pf, sizeof *pf);\n\t\tpf->number = 0;\n\t\tpf->pf_flags = PFF_FAKE;\n\t\tpf->last_config_index = -1;\n\t\tSIMPLEQ_INIT(&pf->cfe_head);\n\t\tSIMPLEQ_INSERT_TAIL(&sc->card.pf_head, pf, pf_list);\n\t}\n\n\tattached = 0;\n\n\tfor (pf = SIMPLEQ_FIRST(&sc->card.pf_head); pf != NULL;\n\t    pf = SIMPLEQ_NEXT(pf, pf_list)) {\n\t\tpf->sc = sc;\n\t\tpf->child = NULL;\n\t\tpf->cfe = NULL;\n\t\tpf->ih_fct = NULL;\n\t\tpf->ih_arg = NULL;\n\t}\n\n\tfor (pf = SIMPLEQ_FIRST(&sc->card.pf_head); pf != NULL;\n\t    pf = SIMPLEQ_NEXT(pf, pf_list)) {\n\t\tpaa.manufacturer = sc->card.manufacturer;\n\t\tpaa.product = sc->card.product;\n\t\tpaa.card = &sc->card;\n\t\tpaa.pf = pf;\n\n\t\tpf->child = config_found_sm(&sc->dev, &paa, pcmcia_print,\n\t\t    pcmcia_submatch);\n\t\tif (pf->child) {\n\t\t\tattached++;\n\n\t\t\tif ((pf->pf_flags & PFF_FAKE) == 0)\n\t\t\t\tDPRINTF((\"%s: function %d CCR at %d offset %lx\"\n\t\t\t\t\t\": %x %x %x %x, %x %x %x %x, %x\\n\",\n\t\t\t\t\tsc->dev.dv_xname, pf->number,\n\t\t\t\t\tpf->pf_ccr_window, pf->pf_ccr_offset,\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x00),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x02),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x04),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x06),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x0A),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x0C),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x0E),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x10),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x12)));\n\t\t}\n\t}\n\treturn (attached ? 0 : 1);\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tpcmcia_submatch",
            "int\tpcmcia_print",
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;",
            "int (*ih_fct)",
            "void *ih_arg;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\tpcmcia_submatch;\nint\tpcmcia_print;\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\nint (*ih_fct);\nvoid *ih_arg;\n\nint\npcmcia_card_attach(dev)\n\tstruct device *dev;\n{\n\tstruct pcmcia_softc *sc = (struct pcmcia_softc *) dev;\n\tstruct pcmcia_function *pf;\n\tstruct pcmcia_attach_args paa;\n\tint attached;\n\n\t/*\n\t * this is here so that when socket_enable calls gettype, trt happens\n\t */\n\tsc->card.pf_head.sqh_first = NULL;\n\n\tpcmcia_chip_socket_enable(sc->pct, sc->pch);\n\n\tpcmcia_read_cis(sc);\n\n\tpcmcia_chip_socket_disable(sc->pct, sc->pch);\n\n\tpcmcia_check_cis_quirks(sc);\n\n#if 1\n\t/*\n\t * Bail now if the card has no functions, or if there was an error in\n\t * the CIS.\n\t */\n\n\tif (sc->card.error)\n\t\treturn (1);\n\tif (sc->card.pf_head.sqh_first == NULL)\n\t\treturn (1);\n#endif\n\n\tif (pcmcia_verbose)\n\t\tpcmcia_print_cis(sc);\n\n\t/*\n\t * If there was no function, this might be CIS-less card we still\n\t * want to probe.  Fixup a function element for it.\n\t */\n\tif (SIMPLEQ_FIRST(&sc->card.pf_head) == NULL) {\n\t\tpf = malloc(sizeof *pf, M_DEVBUF, M_NOWAIT);\n\t\tbzero(pf, sizeof *pf);\n\t\tpf->number = 0;\n\t\tpf->pf_flags = PFF_FAKE;\n\t\tpf->last_config_index = -1;\n\t\tSIMPLEQ_INIT(&pf->cfe_head);\n\t\tSIMPLEQ_INSERT_TAIL(&sc->card.pf_head, pf, pf_list);\n\t}\n\n\tattached = 0;\n\n\tfor (pf = SIMPLEQ_FIRST(&sc->card.pf_head); pf != NULL;\n\t    pf = SIMPLEQ_NEXT(pf, pf_list)) {\n\t\tpf->sc = sc;\n\t\tpf->child = NULL;\n\t\tpf->cfe = NULL;\n\t\tpf->ih_fct = NULL;\n\t\tpf->ih_arg = NULL;\n\t}\n\n\tfor (pf = SIMPLEQ_FIRST(&sc->card.pf_head); pf != NULL;\n\t    pf = SIMPLEQ_NEXT(pf, pf_list)) {\n\t\tpaa.manufacturer = sc->card.manufacturer;\n\t\tpaa.product = sc->card.product;\n\t\tpaa.card = &sc->card;\n\t\tpaa.pf = pf;\n\n\t\tpf->child = config_found_sm(&sc->dev, &paa, pcmcia_print,\n\t\t    pcmcia_submatch);\n\t\tif (pf->child) {\n\t\t\tattached++;\n\n\t\t\tif ((pf->pf_flags & PFF_FAKE) == 0)\n\t\t\t\tDPRINTF((\"%s: function %d CCR at %d offset %lx\"\n\t\t\t\t\t\": %x %x %x %x, %x %x %x %x, %x\\n\",\n\t\t\t\t\tsc->dev.dv_xname, pf->number,\n\t\t\t\t\tpf->pf_ccr_window, pf->pf_ccr_offset,\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x00),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x02),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x04),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x06),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x0A),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x0C),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x0E),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x10),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x12)));\n\t\t}\n\t}\n\treturn (attached ? 0 : 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"tcic_attach_card: already attached\""
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"tcic_attach_card\\n\")"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\ttcic_attach_card;\n\nvoid\ntcic_attach_card(h)\n\tstruct tcic_handle *h;\n{\n\tDPRINTF((\"tcic_attach_card\\n\"));\n\n\tif (h->flags & TCIC_FLAG_CARDP)\n\t\tpanic(\"tcic_attach_card: already attached\");\n\n\t/* call the MI attach function */\n\n\tpcmcia_card_attach(h->pcmcia);\n\n\th->flags |= TCIC_FLAG_CARDP;\n}"
  },
  {
    "function_name": "tcic_queue_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
    "lines": "702-719",
    "snippet": "void\ntcic_queue_event(h, event)\n\tstruct tcic_handle *h;\n\tint event;\n{\n\tstruct tcic_event *pe;\n\tint s;\n\n\tpe = malloc(sizeof(*pe), M_TEMP, M_NOWAIT);\n\tif (pe == NULL)\n\t\tpanic(\"tcic_queue_event: can't allocate event\");\n\n\tpe->pe_type = event;\n\ts = splhigh();\n\tSIMPLEQ_INSERT_TAIL(&h->events, pe, pe_q);\n\tsplx(s);\n\twakeup(&h->events);\n}",
    "includes": [
      "#include <dev/ic/tcic2var.h>",
      "#include <dev/ic/tcic2reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <sys/kthread.h>",
      "#include <sys/malloc.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\ttcic_queue_event"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "&h->events"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "rln_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
          "lines": "171-214",
          "snippet": "u_int8_t\nrln_wakeup(sc, wnew)\n\tstruct rln_softc *\tsc;\n\tu_int8_t\t\twnew;\n{\n\tu_int8_t\t\twold, s;\n\tint\t\t\ti;\n\n\t/* Save what the last-written values were. */\n\twold = (sc->sc_status & RLN_STATUS_WAKEUP) |\n\t    (sc->sc_control & RLN_CONTROL_RESET);\n\n\tif (wnew == RLN_WAKEUP_SET) {\n\t\t/* SetWakeupBit() */\n\t\tdprintf(\" Ws[\");\n\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\tif (0/*LLDInactivityTimeOut &&\n\t\t    (sc->sc_cardtype & RLN_CTYPE_OEM)*/) {\n\t\t\tdprintf (\" 167ms\");\n\t\t\tDELAY(167000);\n\t\t} else {\n\t\t\tdprintf (\" .1ms\");\n\t\t\tDELAY(100);\n\t\t}\n\t\ts = rln_status_read(sc);\n\t\trln_control_set(sc, RLN_CONTROL_RESET);\n\t\tif ((s & RLN_STATUS_WAKEUP) != 0)\n\t\t\tfor (i = 0; i < 9; i++) {\n\t\t\t\tdprintf(\" 2ms\");\n\t\t\t\tDELAY(2000);\n\t\t\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\t\t}\n\t\tdprintf(\"]\");\n\t} else {\n\t\t/* ClearWakeupBit() */\n\t\tdprintf(\" Wc[\");\n\t\tif ((wnew & RLN_STATUS_WAKEUP) == 0)\n\t\t\trln_status_clear(sc, RLN_STATUS_WAKEUP);\n\t\tif ((wnew & RLN_CONTROL_RESET) == 0)\n\t\t\trln_control_clear(sc, RLN_CONTROL_RESET);\n\t\tdprintf(\"]\");\n\t}\n\treturn (wold);\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_int8_t\nrln_wakeup(sc, wnew)\n\tstruct rln_softc *\tsc;\n\tu_int8_t\t\twnew;\n{\n\tu_int8_t\t\twold, s;\n\tint\t\t\ti;\n\n\t/* Save what the last-written values were. */\n\twold = (sc->sc_status & RLN_STATUS_WAKEUP) |\n\t    (sc->sc_control & RLN_CONTROL_RESET);\n\n\tif (wnew == RLN_WAKEUP_SET) {\n\t\t/* SetWakeupBit() */\n\t\tdprintf(\" Ws[\");\n\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\tif (0/*LLDInactivityTimeOut &&\n\t\t    (sc->sc_cardtype & RLN_CTYPE_OEM)*/) {\n\t\t\tdprintf (\" 167ms\");\n\t\t\tDELAY(167000);\n\t\t} else {\n\t\t\tdprintf (\" .1ms\");\n\t\t\tDELAY(100);\n\t\t}\n\t\ts = rln_status_read(sc);\n\t\trln_control_set(sc, RLN_CONTROL_RESET);\n\t\tif ((s & RLN_STATUS_WAKEUP) != 0)\n\t\t\tfor (i = 0; i < 9; i++) {\n\t\t\t\tdprintf(\" 2ms\");\n\t\t\t\tDELAY(2000);\n\t\t\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\t\t}\n\t\tdprintf(\"]\");\n\t} else {\n\t\t/* ClearWakeupBit() */\n\t\tdprintf(\" Wc[\");\n\t\tif ((wnew & RLN_STATUS_WAKEUP) == 0)\n\t\t\trln_status_clear(sc, RLN_STATUS_WAKEUP);\n\t\tif ((wnew & RLN_CONTROL_RESET) == 0)\n\t\t\trln_control_clear(sc, RLN_CONTROL_RESET);\n\t\tdprintf(\"]\");\n\t}\n\treturn (wold);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_INSERT_TAIL",
          "args": [
            "&h->events",
            "pe",
            "pe_q"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splhigh",
          "args": [],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"tcic_queue_event: can't allocate event\""
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(*pe)",
            "M_TEMP",
            "M_NOWAIT"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\ttcic_queue_event;\n\nvoid\ntcic_queue_event(h, event)\n\tstruct tcic_handle *h;\n\tint event;\n{\n\tstruct tcic_event *pe;\n\tint s;\n\n\tpe = malloc(sizeof(*pe), M_TEMP, M_NOWAIT);\n\tif (pe == NULL)\n\t\tpanic(\"tcic_queue_event: can't allocate event\");\n\n\tpe->pe_type = event;\n\ts = splhigh();\n\tSIMPLEQ_INSERT_TAIL(&h->events, pe, pe_q);\n\tsplx(s);\n\twakeup(&h->events);\n}"
  },
  {
    "function_name": "tcic_intr_socket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
    "lines": "620-700",
    "snippet": "int\ntcic_intr_socket(h)\n\tstruct tcic_handle *h;\n{\n\tint icsr, rv;\n\n\trv = 0;\n\ttcic_sel_sock(h);\n\ticsr = tcic_read_1(h, TCIC_R_ICSR);\n\n\tDPRINTF((\"%s: %d icsr: 0x%02x \\n\", h->sc->dev.dv_xname, h->sock, icsr));\n\n\t/* XXX or should the next three be handled in tcic_intr? -chb */\n\tif (icsr & TCIC_ICSR_PROGTIME) {\n\t\tDPRINTF((\"%s: %02x PROGTIME\\n\", h->sc->dev.dv_xname, h->sock));\n\t\trv = 1;\n\t}\n\tif (icsr & TCIC_ICSR_ILOCK) {\n\t\tDPRINTF((\"%s: %02x ILOCK\\n\", h->sc->dev.dv_xname, h->sock));\n\t\trv = 1;\n\t}\n\tif (icsr & TCIC_ICSR_ERR) {\n\t\tDPRINTF((\"%s: %02x ERR\\n\", h->sc->dev.dv_xname, h->sock));\n\t\trv = 1;\n\t}\n\tif (icsr & TCIC_ICSR_CDCHG) {\n\t\tint sstat, delta;\n\n\t\t/* compute what changed since last interrupt */\n\t\tsstat = tcic_read_aux_1(h->sc->iot, h->sc->ioh,\n\t\t    TCIC_AR_WCTL, TCIC_R_WCTL_XCSR) & TCIC_XCSR_STAT_MASK;\n\t\tdelta = h->sstat ^ sstat;\n\t\th->sstat = sstat;\n\n\t\tif (delta)\n\t\t\trv = 1;\n\n\t\tDPRINTF((\"%s: %02x CDCHG %x\\n\", h->sc->dev.dv_xname, h->sock,\n\t\t    delta));\n\n\t\t/*\n\t\t * XXX This should probably schedule something to happen\n\t\t * after the interrupt handler completes\n\t\t */\n\n\t\tif (delta & TCIC_SSTAT_CD) {\n\t\t\tif (sstat & TCIC_SSTAT_CD) {\n\t\t\t\tif (!(h->flags & TCIC_FLAG_CARDP)) {\n\t\t\t\t\tDPRINTF((\"%s: enqueing INSERTION event\\n\",\n\t\t\t\t\t    h->sc->dev.dv_xname));\n\t\t\t\t\ttcic_queue_event(h, TCIC_EVENT_INSERTION);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (h->flags & TCIC_FLAG_CARDP) {\n\t\t\t\t\t/* Deactivate the card now. */\n\t\t\t\t\tDPRINTF((\"%s: deactivating card\\n\",\n\t\t\t\t\t    h->sc->dev.dv_xname));\n\t\t\t\t\ttcic_deactivate_card(h);\n\n\t\t\t\t\tDPRINTF((\"%s: enqueing REMOVAL event\\n\",\n\t\t\t\t\t    h->sc->dev.dv_xname));\n\t\t\t\t\ttcic_queue_event(h, TCIC_EVENT_REMOVAL);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (delta & TCIC_SSTAT_RDY) {\n\t\t\tDPRINTF((\"%s: %02x READY\\n\", h->sc->dev.dv_xname, h->sock));\n\t\t\t/* shouldn't happen */\n\t\t}\n\t\tif (delta & TCIC_SSTAT_LBAT1) {\n\t\t\tDPRINTF((\"%s: %02x LBAT1\\n\", h->sc->dev.dv_xname, h->sock));\n\t\t}\n\t\tif (delta & TCIC_SSTAT_LBAT2) {\n\t\t\tDPRINTF((\"%s: %02x LBAT2\\n\", h->sc->dev.dv_xname, h->sock));\n\t\t}\n\t\tif (delta & TCIC_SSTAT_WP) {\n\t\t\tDPRINTF((\"%s: %02x WP\\n\", h->sc->dev.dv_xname, h->sock));\n\t\t}\n\t}\n\treturn rv;\n}",
    "includes": [
      "#include <dev/ic/tcic2var.h>",
      "#include <dev/ic/tcic2reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <sys/kthread.h>",
      "#include <sys/malloc.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\ttcic_intr_socket",
      "void\ttcic_deactivate_card",
      "void\ttcic_queue_event"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: %02x WP\\n\", h->sc->dev.dv_xname, h->sock)"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: %02x LBAT2\\n\", h->sc->dev.dv_xname, h->sock)"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: %02x LBAT1\\n\", h->sc->dev.dv_xname, h->sock)"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: %02x READY\\n\", h->sc->dev.dv_xname, h->sock)"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcic_queue_event",
          "args": [
            "h",
            "TCIC_EVENT_REMOVAL"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_queue_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
          "lines": "702-719",
          "snippet": "void\ntcic_queue_event(h, event)\n\tstruct tcic_handle *h;\n\tint event;\n{\n\tstruct tcic_event *pe;\n\tint s;\n\n\tpe = malloc(sizeof(*pe), M_TEMP, M_NOWAIT);\n\tif (pe == NULL)\n\t\tpanic(\"tcic_queue_event: can't allocate event\");\n\n\tpe->pe_type = event;\n\ts = splhigh();\n\tSIMPLEQ_INSERT_TAIL(&h->events, pe, pe_q);\n\tsplx(s);\n\twakeup(&h->events);\n}",
          "includes": [
            "#include <dev/ic/tcic2var.h>",
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttcic_queue_event"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\ttcic_queue_event;\n\nvoid\ntcic_queue_event(h, event)\n\tstruct tcic_handle *h;\n\tint event;\n{\n\tstruct tcic_event *pe;\n\tint s;\n\n\tpe = malloc(sizeof(*pe), M_TEMP, M_NOWAIT);\n\tif (pe == NULL)\n\t\tpanic(\"tcic_queue_event: can't allocate event\");\n\n\tpe->pe_type = event;\n\ts = splhigh();\n\tSIMPLEQ_INSERT_TAIL(&h->events, pe, pe_q);\n\tsplx(s);\n\twakeup(&h->events);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: enqueing REMOVAL event\\n\",\n\t\t\t\t\t    h->sc->dev.dv_xname)"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcic_deactivate_card",
          "args": [
            "h"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_deactivate_card",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
          "lines": "754-784",
          "snippet": "void\ntcic_deactivate_card(h)\n\tstruct tcic_handle *h;\n{\n\tint val, reg;\n\n\tif (!(h->flags & TCIC_FLAG_CARDP))\n\t\t panic(\"tcic_deactivate_card: already detached\");\n\n\t/* call the MI deactivate function */\n\tpcmcia_card_deactivate(h->pcmcia);\n\n\ttcic_sel_sock(h);\n\n\t/* XXX disable card detect resume and configuration reset??? */\n\n\t/* power down the socket */\n\ttcic_write_1(h, TCIC_R_PWR, 0);\n\n\t/* reset the card XXX ? -chb */\n\n\t/* turn off irq's for this socket */\n\treg = TCIC_IR_SCF1_N(h->sock);\n\tval = tcic_read_ind_2(h, reg);\n\ttcic_write_ind_2(h, reg, (val & ~TCIC_SCF1_IRQ_MASK)|TCIC_SCF1_IRQOFF);\n\treg = TCIC_IR_SCF2_N(h->sock);\n\tval = tcic_read_ind_2(h, reg);\n\ttcic_write_ind_2(h, reg,\n\t    (val | (TCIC_SCF2_MLBAT1|TCIC_SCF2_MLBAT2|TCIC_SCF2_MRDY\n\t\t|TCIC_SCF2_MWP|TCIC_SCF2_MCD)));\n}",
          "includes": [
            "#include <dev/ic/tcic2var.h>",
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttcic_deactivate_card"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\ttcic_deactivate_card;\n\nvoid\ntcic_deactivate_card(h)\n\tstruct tcic_handle *h;\n{\n\tint val, reg;\n\n\tif (!(h->flags & TCIC_FLAG_CARDP))\n\t\t panic(\"tcic_deactivate_card: already detached\");\n\n\t/* call the MI deactivate function */\n\tpcmcia_card_deactivate(h->pcmcia);\n\n\ttcic_sel_sock(h);\n\n\t/* XXX disable card detect resume and configuration reset??? */\n\n\t/* power down the socket */\n\ttcic_write_1(h, TCIC_R_PWR, 0);\n\n\t/* reset the card XXX ? -chb */\n\n\t/* turn off irq's for this socket */\n\treg = TCIC_IR_SCF1_N(h->sock);\n\tval = tcic_read_ind_2(h, reg);\n\ttcic_write_ind_2(h, reg, (val & ~TCIC_SCF1_IRQ_MASK)|TCIC_SCF1_IRQOFF);\n\treg = TCIC_IR_SCF2_N(h->sock);\n\tval = tcic_read_ind_2(h, reg);\n\ttcic_write_ind_2(h, reg,\n\t    (val | (TCIC_SCF2_MLBAT1|TCIC_SCF2_MLBAT2|TCIC_SCF2_MRDY\n\t\t|TCIC_SCF2_MWP|TCIC_SCF2_MCD)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: deactivating card\\n\",\n\t\t\t\t\t    h->sc->dev.dv_xname)"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: enqueing INSERTION event\\n\",\n\t\t\t\t\t    h->sc->dev.dv_xname)"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: %02x CDCHG %x\\n\", h->sc->dev.dv_xname, h->sock,\n\t\t    delta)"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcic_read_aux_1",
          "args": [
            "h->sc->iot",
            "h->sc->ioh",
            "TCIC_AR_WCTL",
            "TCIC_R_WCTL_XCSR"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_read_aux_1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2var.h",
          "lines": "306-317",
          "snippet": "static __inline__ int\ntcic_read_aux_1(iot, ioh, auxreg, reg)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tint auxreg;\n{\n\tint mode, val;\n\tmode = bus_space_read_1(iot, ioh, TCIC_R_MODE);\n\tbus_space_write_1(iot, ioh, TCIC_R_MODE, (mode & ~TCIC_AR_MASK)|auxreg);\n\tval = bus_space_read_1(iot, ioh, reg);\n\treturn val;\n}",
          "includes": [
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/device.h>\n\nstatic __inline__ int\ntcic_read_aux_1(iot, ioh, auxreg, reg)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tint auxreg;\n{\n\tint mode, val;\n\tmode = bus_space_read_1(iot, ioh, TCIC_R_MODE);\n\tbus_space_write_1(iot, ioh, TCIC_R_MODE, (mode & ~TCIC_AR_MASK)|auxreg);\n\tval = bus_space_read_1(iot, ioh, reg);\n\treturn val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: %02x ERR\\n\", h->sc->dev.dv_xname, h->sock)"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: %02x ILOCK\\n\", h->sc->dev.dv_xname, h->sock)"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: %02x PROGTIME\\n\", h->sc->dev.dv_xname, h->sock)"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: %d icsr: 0x%02x \\n\", h->sc->dev.dv_xname, h->sock, icsr)"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcic_read_1",
          "args": [
            "h",
            "TCIC_R_ICSR"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_read_1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2var.h",
          "lines": "187-193",
          "snippet": "static __inline__ int\ntcic_read_1(h, reg)\n\tstruct tcic_handle *h;\n\tint reg;\n{\n\treturn (bus_space_read_1(h->sc->iot, h->sc->ioh, reg));\n}",
          "includes": [
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/device.h>\n\nstatic __inline__ int\ntcic_read_1(h, reg)\n\tstruct tcic_handle *h;\n\tint reg;\n{\n\treturn (bus_space_read_1(h->sc->iot, h->sc->ioh, reg));\n}"
        }
      },
      {
        "call_info": {
          "callee": "tcic_sel_sock",
          "args": [
            "h"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_sel_sock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2var.h",
          "lines": "276-284",
          "snippet": "static __inline__ void\ntcic_sel_sock(h)\n\tstruct tcic_handle *h;\n{\n\tint r_addr;\n\tr_addr = tcic_read_2(h, TCIC_R_ADDR2);\n\ttcic_write_2(h, TCIC_R_ADDR2,\n\t    (h->sock<<TCIC_ADDR2_SS_SHFT)|(r_addr & ~TCIC_ADDR2_SS_MASK));\n}",
          "includes": [
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/device.h>\n\nstatic __inline__ void\ntcic_sel_sock(h)\n\tstruct tcic_handle *h;\n{\n\tint r_addr;\n\tr_addr = tcic_read_2(h, TCIC_R_ADDR2);\n\ttcic_write_2(h, TCIC_R_ADDR2,\n\t    (h->sock<<TCIC_ADDR2_SS_SHFT)|(r_addr & ~TCIC_ADDR2_SS_MASK));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\ttcic_intr_socket;\nvoid\ttcic_deactivate_card;\nvoid\ttcic_queue_event;\n\nint\ntcic_intr_socket(h)\n\tstruct tcic_handle *h;\n{\n\tint icsr, rv;\n\n\trv = 0;\n\ttcic_sel_sock(h);\n\ticsr = tcic_read_1(h, TCIC_R_ICSR);\n\n\tDPRINTF((\"%s: %d icsr: 0x%02x \\n\", h->sc->dev.dv_xname, h->sock, icsr));\n\n\t/* XXX or should the next three be handled in tcic_intr? -chb */\n\tif (icsr & TCIC_ICSR_PROGTIME) {\n\t\tDPRINTF((\"%s: %02x PROGTIME\\n\", h->sc->dev.dv_xname, h->sock));\n\t\trv = 1;\n\t}\n\tif (icsr & TCIC_ICSR_ILOCK) {\n\t\tDPRINTF((\"%s: %02x ILOCK\\n\", h->sc->dev.dv_xname, h->sock));\n\t\trv = 1;\n\t}\n\tif (icsr & TCIC_ICSR_ERR) {\n\t\tDPRINTF((\"%s: %02x ERR\\n\", h->sc->dev.dv_xname, h->sock));\n\t\trv = 1;\n\t}\n\tif (icsr & TCIC_ICSR_CDCHG) {\n\t\tint sstat, delta;\n\n\t\t/* compute what changed since last interrupt */\n\t\tsstat = tcic_read_aux_1(h->sc->iot, h->sc->ioh,\n\t\t    TCIC_AR_WCTL, TCIC_R_WCTL_XCSR) & TCIC_XCSR_STAT_MASK;\n\t\tdelta = h->sstat ^ sstat;\n\t\th->sstat = sstat;\n\n\t\tif (delta)\n\t\t\trv = 1;\n\n\t\tDPRINTF((\"%s: %02x CDCHG %x\\n\", h->sc->dev.dv_xname, h->sock,\n\t\t    delta));\n\n\t\t/*\n\t\t * XXX This should probably schedule something to happen\n\t\t * after the interrupt handler completes\n\t\t */\n\n\t\tif (delta & TCIC_SSTAT_CD) {\n\t\t\tif (sstat & TCIC_SSTAT_CD) {\n\t\t\t\tif (!(h->flags & TCIC_FLAG_CARDP)) {\n\t\t\t\t\tDPRINTF((\"%s: enqueing INSERTION event\\n\",\n\t\t\t\t\t    h->sc->dev.dv_xname));\n\t\t\t\t\ttcic_queue_event(h, TCIC_EVENT_INSERTION);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (h->flags & TCIC_FLAG_CARDP) {\n\t\t\t\t\t/* Deactivate the card now. */\n\t\t\t\t\tDPRINTF((\"%s: deactivating card\\n\",\n\t\t\t\t\t    h->sc->dev.dv_xname));\n\t\t\t\t\ttcic_deactivate_card(h);\n\n\t\t\t\t\tDPRINTF((\"%s: enqueing REMOVAL event\\n\",\n\t\t\t\t\t    h->sc->dev.dv_xname));\n\t\t\t\t\ttcic_queue_event(h, TCIC_EVENT_REMOVAL);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (delta & TCIC_SSTAT_RDY) {\n\t\t\tDPRINTF((\"%s: %02x READY\\n\", h->sc->dev.dv_xname, h->sock));\n\t\t\t/* shouldn't happen */\n\t\t}\n\t\tif (delta & TCIC_SSTAT_LBAT1) {\n\t\t\tDPRINTF((\"%s: %02x LBAT1\\n\", h->sc->dev.dv_xname, h->sock));\n\t\t}\n\t\tif (delta & TCIC_SSTAT_LBAT2) {\n\t\t\tDPRINTF((\"%s: %02x LBAT2\\n\", h->sc->dev.dv_xname, h->sock));\n\t\t}\n\t\tif (delta & TCIC_SSTAT_WP) {\n\t\t\tDPRINTF((\"%s: %02x WP\\n\", h->sc->dev.dv_xname, h->sock));\n\t\t}\n\t}\n\treturn rv;\n}"
  },
  {
    "function_name": "tcic_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
    "lines": "604-618",
    "snippet": "int\ntcic_intr(arg)\n\tvoid *arg;\n{\n\tstruct tcic_softc *sc = arg;\n\tint i, ret = 0;\n\n\tDPRINTF((\"%s: intr\\n\", sc->dev.dv_xname));\n\n\tfor (i = 0; i < TCIC_NSLOTS; i++)\n\t\tif (sc->handle[i].flags & TCIC_FLAG_SOCKETP)\n\t\t\tret += tcic_intr_socket(&sc->handle[i]);\n\n\treturn (ret ? 1 : 0);\n}",
    "includes": [
      "#include <dev/ic/tcic2var.h>",
      "#include <dev/ic/tcic2reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <sys/kthread.h>",
      "#include <sys/malloc.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\ttcic_intr_socket"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tcic_intr_socket",
          "args": [
            "&sc->handle[i]"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_intr_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
          "lines": "620-700",
          "snippet": "int\ntcic_intr_socket(h)\n\tstruct tcic_handle *h;\n{\n\tint icsr, rv;\n\n\trv = 0;\n\ttcic_sel_sock(h);\n\ticsr = tcic_read_1(h, TCIC_R_ICSR);\n\n\tDPRINTF((\"%s: %d icsr: 0x%02x \\n\", h->sc->dev.dv_xname, h->sock, icsr));\n\n\t/* XXX or should the next three be handled in tcic_intr? -chb */\n\tif (icsr & TCIC_ICSR_PROGTIME) {\n\t\tDPRINTF((\"%s: %02x PROGTIME\\n\", h->sc->dev.dv_xname, h->sock));\n\t\trv = 1;\n\t}\n\tif (icsr & TCIC_ICSR_ILOCK) {\n\t\tDPRINTF((\"%s: %02x ILOCK\\n\", h->sc->dev.dv_xname, h->sock));\n\t\trv = 1;\n\t}\n\tif (icsr & TCIC_ICSR_ERR) {\n\t\tDPRINTF((\"%s: %02x ERR\\n\", h->sc->dev.dv_xname, h->sock));\n\t\trv = 1;\n\t}\n\tif (icsr & TCIC_ICSR_CDCHG) {\n\t\tint sstat, delta;\n\n\t\t/* compute what changed since last interrupt */\n\t\tsstat = tcic_read_aux_1(h->sc->iot, h->sc->ioh,\n\t\t    TCIC_AR_WCTL, TCIC_R_WCTL_XCSR) & TCIC_XCSR_STAT_MASK;\n\t\tdelta = h->sstat ^ sstat;\n\t\th->sstat = sstat;\n\n\t\tif (delta)\n\t\t\trv = 1;\n\n\t\tDPRINTF((\"%s: %02x CDCHG %x\\n\", h->sc->dev.dv_xname, h->sock,\n\t\t    delta));\n\n\t\t/*\n\t\t * XXX This should probably schedule something to happen\n\t\t * after the interrupt handler completes\n\t\t */\n\n\t\tif (delta & TCIC_SSTAT_CD) {\n\t\t\tif (sstat & TCIC_SSTAT_CD) {\n\t\t\t\tif (!(h->flags & TCIC_FLAG_CARDP)) {\n\t\t\t\t\tDPRINTF((\"%s: enqueing INSERTION event\\n\",\n\t\t\t\t\t    h->sc->dev.dv_xname));\n\t\t\t\t\ttcic_queue_event(h, TCIC_EVENT_INSERTION);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (h->flags & TCIC_FLAG_CARDP) {\n\t\t\t\t\t/* Deactivate the card now. */\n\t\t\t\t\tDPRINTF((\"%s: deactivating card\\n\",\n\t\t\t\t\t    h->sc->dev.dv_xname));\n\t\t\t\t\ttcic_deactivate_card(h);\n\n\t\t\t\t\tDPRINTF((\"%s: enqueing REMOVAL event\\n\",\n\t\t\t\t\t    h->sc->dev.dv_xname));\n\t\t\t\t\ttcic_queue_event(h, TCIC_EVENT_REMOVAL);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (delta & TCIC_SSTAT_RDY) {\n\t\t\tDPRINTF((\"%s: %02x READY\\n\", h->sc->dev.dv_xname, h->sock));\n\t\t\t/* shouldn't happen */\n\t\t}\n\t\tif (delta & TCIC_SSTAT_LBAT1) {\n\t\t\tDPRINTF((\"%s: %02x LBAT1\\n\", h->sc->dev.dv_xname, h->sock));\n\t\t}\n\t\tif (delta & TCIC_SSTAT_LBAT2) {\n\t\t\tDPRINTF((\"%s: %02x LBAT2\\n\", h->sc->dev.dv_xname, h->sock));\n\t\t}\n\t\tif (delta & TCIC_SSTAT_WP) {\n\t\t\tDPRINTF((\"%s: %02x WP\\n\", h->sc->dev.dv_xname, h->sock));\n\t\t}\n\t}\n\treturn rv;\n}",
          "includes": [
            "#include <dev/ic/tcic2var.h>",
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\ttcic_intr_socket",
            "void\ttcic_deactivate_card",
            "void\ttcic_queue_event"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\ttcic_intr_socket;\nvoid\ttcic_deactivate_card;\nvoid\ttcic_queue_event;\n\nint\ntcic_intr_socket(h)\n\tstruct tcic_handle *h;\n{\n\tint icsr, rv;\n\n\trv = 0;\n\ttcic_sel_sock(h);\n\ticsr = tcic_read_1(h, TCIC_R_ICSR);\n\n\tDPRINTF((\"%s: %d icsr: 0x%02x \\n\", h->sc->dev.dv_xname, h->sock, icsr));\n\n\t/* XXX or should the next three be handled in tcic_intr? -chb */\n\tif (icsr & TCIC_ICSR_PROGTIME) {\n\t\tDPRINTF((\"%s: %02x PROGTIME\\n\", h->sc->dev.dv_xname, h->sock));\n\t\trv = 1;\n\t}\n\tif (icsr & TCIC_ICSR_ILOCK) {\n\t\tDPRINTF((\"%s: %02x ILOCK\\n\", h->sc->dev.dv_xname, h->sock));\n\t\trv = 1;\n\t}\n\tif (icsr & TCIC_ICSR_ERR) {\n\t\tDPRINTF((\"%s: %02x ERR\\n\", h->sc->dev.dv_xname, h->sock));\n\t\trv = 1;\n\t}\n\tif (icsr & TCIC_ICSR_CDCHG) {\n\t\tint sstat, delta;\n\n\t\t/* compute what changed since last interrupt */\n\t\tsstat = tcic_read_aux_1(h->sc->iot, h->sc->ioh,\n\t\t    TCIC_AR_WCTL, TCIC_R_WCTL_XCSR) & TCIC_XCSR_STAT_MASK;\n\t\tdelta = h->sstat ^ sstat;\n\t\th->sstat = sstat;\n\n\t\tif (delta)\n\t\t\trv = 1;\n\n\t\tDPRINTF((\"%s: %02x CDCHG %x\\n\", h->sc->dev.dv_xname, h->sock,\n\t\t    delta));\n\n\t\t/*\n\t\t * XXX This should probably schedule something to happen\n\t\t * after the interrupt handler completes\n\t\t */\n\n\t\tif (delta & TCIC_SSTAT_CD) {\n\t\t\tif (sstat & TCIC_SSTAT_CD) {\n\t\t\t\tif (!(h->flags & TCIC_FLAG_CARDP)) {\n\t\t\t\t\tDPRINTF((\"%s: enqueing INSERTION event\\n\",\n\t\t\t\t\t    h->sc->dev.dv_xname));\n\t\t\t\t\ttcic_queue_event(h, TCIC_EVENT_INSERTION);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (h->flags & TCIC_FLAG_CARDP) {\n\t\t\t\t\t/* Deactivate the card now. */\n\t\t\t\t\tDPRINTF((\"%s: deactivating card\\n\",\n\t\t\t\t\t    h->sc->dev.dv_xname));\n\t\t\t\t\ttcic_deactivate_card(h);\n\n\t\t\t\t\tDPRINTF((\"%s: enqueing REMOVAL event\\n\",\n\t\t\t\t\t    h->sc->dev.dv_xname));\n\t\t\t\t\ttcic_queue_event(h, TCIC_EVENT_REMOVAL);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (delta & TCIC_SSTAT_RDY) {\n\t\t\tDPRINTF((\"%s: %02x READY\\n\", h->sc->dev.dv_xname, h->sock));\n\t\t\t/* shouldn't happen */\n\t\t}\n\t\tif (delta & TCIC_SSTAT_LBAT1) {\n\t\t\tDPRINTF((\"%s: %02x LBAT1\\n\", h->sc->dev.dv_xname, h->sock));\n\t\t}\n\t\tif (delta & TCIC_SSTAT_LBAT2) {\n\t\t\tDPRINTF((\"%s: %02x LBAT2\\n\", h->sc->dev.dv_xname, h->sock));\n\t\t}\n\t\tif (delta & TCIC_SSTAT_WP) {\n\t\t\tDPRINTF((\"%s: %02x WP\\n\", h->sc->dev.dv_xname, h->sock));\n\t\t}\n\t}\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: intr\\n\", sc->dev.dv_xname)"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\ttcic_intr_socket;\n\nint\ntcic_intr(arg)\n\tvoid *arg;\n{\n\tstruct tcic_softc *sc = arg;\n\tint i, ret = 0;\n\n\tDPRINTF((\"%s: intr\\n\", sc->dev.dv_xname));\n\n\tfor (i = 0; i < TCIC_NSLOTS; i++)\n\t\tif (sc->handle[i].flags & TCIC_FLAG_SOCKETP)\n\t\t\tret += tcic_intr_socket(&sc->handle[i]);\n\n\treturn (ret ? 1 : 0);\n}"
  },
  {
    "function_name": "tcic_print",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
    "lines": "579-602",
    "snippet": "int\ntcic_print(arg, pnp)\n\tvoid *arg;\n\tconst char *pnp;\n{\n\tstruct pcmciabus_attach_args *paa = arg;\n\tstruct tcic_handle *h = (struct tcic_handle *) paa->pch;\n\n\t/* Only \"pcmcia\"s can attach to \"tcic\"s... easy. */\n\tif (pnp)\n\t\tprintf(\"pcmcia at %s\", pnp);\n\n\tswitch (h->sock) {\n\tcase 0:\n\t\tprintf(\" socket 0\");\n\t\tbreak;\n\tcase 1:\n\t\tprintf(\" socket 1\");\n\t\tbreak;\n\tdefault:\n\t\tpanic(\"unknown tcic socket\");\n\t}\n\treturn (UNCONF);\n}",
    "includes": [
      "#include <dev/ic/tcic2var.h>",
      "#include <dev/ic/tcic2reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <sys/kthread.h>",
      "#include <sys/malloc.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\ttcic_print"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"unknown tcic socket\""
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" socket 1\""
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\ttcic_print;\n\nint\ntcic_print(arg, pnp)\n\tvoid *arg;\n\tconst char *pnp;\n{\n\tstruct pcmciabus_attach_args *paa = arg;\n\tstruct tcic_handle *h = (struct tcic_handle *) paa->pch;\n\n\t/* Only \"pcmcia\"s can attach to \"tcic\"s... easy. */\n\tif (pnp)\n\t\tprintf(\"pcmcia at %s\", pnp);\n\n\tswitch (h->sock) {\n\tcase 0:\n\t\tprintf(\" socket 0\");\n\t\tbreak;\n\tcase 1:\n\t\tprintf(\" socket 1\");\n\t\tbreak;\n\tdefault:\n\t\tpanic(\"unknown tcic socket\");\n\t}\n\treturn (UNCONF);\n}"
  },
  {
    "function_name": "tcic_submatch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
    "lines": "538-577",
    "snippet": "int\ntcic_submatch(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match;\n\tvoid *aux;\n{\n\tstruct cfdata *cf = match;\n\n\tstruct pcmciabus_attach_args *paa = aux;\n\tstruct tcic_handle *h = (struct tcic_handle *) paa->pch;\n\n\tswitch (h->sock) {\n\tcase 0:\n\t\tif (cf->cf_loc[0 /* PCMCIABUSCF_CONTROLLER */] !=\n\t\t    -1 /* PCMCIABUSCF_CONTROLLER_DEFAULT */ &&\n\t\t    cf->cf_loc[0 /* PCMCIABUSCF_CONTROLLER */] != 0)\n\t\t\treturn 0;\n\t\tif (cf->cf_loc[1 /* PCMCIABUSCF_SOCKET */] !=\n\t\t    -1 /* PCMCIABUSCF_SOCKET_DEFAULT */ &&\n\t\t    cf->cf_loc[1 /* PCMCIABUSCF_SOCKET */] != 0)\n\t\t\treturn 0;\n\n\t\tbreak;\n\tcase 1:\n\t\tif (cf->cf_loc[0 /* PCMCIABUSCF_CONTROLLER */] !=\n\t\t    -1 /* PCMCIABUSCF_CONTROLLER_DEFAULT */ &&\n\t\t    cf->cf_loc[0 /* PCMCIABUSCF_CONTROLLER */] != 0)\n\t\t\treturn 0;\n\t\tif (cf->cf_loc[1 /* PCMCIABUSCF_SOCKET */] !=\n\t\t    -1 /* PCMCIABUSCF_SOCKET_DEFAULT */ &&\n\t\t    cf->cf_loc[1 /* PCMCIABUSCF_SOCKET */] != 1)\n\t\t\treturn 0;\n\n\t\tbreak;\n\tdefault:\n\t\tpanic(\"unknown tcic socket\");\n\t}\n\n\treturn ((*cf->cf_attach->ca_match)(parent, cf, aux));\n}",
    "includes": [
      "#include <dev/ic/tcic2var.h>",
      "#include <dev/ic/tcic2reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <sys/kthread.h>",
      "#include <sys/malloc.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\ttcic_submatch"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "parent",
            "cf",
            "aux"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"unknown tcic socket\""
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\ttcic_submatch;\n\nint\ntcic_submatch(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match;\n\tvoid *aux;\n{\n\tstruct cfdata *cf = match;\n\n\tstruct pcmciabus_attach_args *paa = aux;\n\tstruct tcic_handle *h = (struct tcic_handle *) paa->pch;\n\n\tswitch (h->sock) {\n\tcase 0:\n\t\tif (cf->cf_loc[0 /* PCMCIABUSCF_CONTROLLER */] !=\n\t\t    -1 /* PCMCIABUSCF_CONTROLLER_DEFAULT */ &&\n\t\t    cf->cf_loc[0 /* PCMCIABUSCF_CONTROLLER */] != 0)\n\t\t\treturn 0;\n\t\tif (cf->cf_loc[1 /* PCMCIABUSCF_SOCKET */] !=\n\t\t    -1 /* PCMCIABUSCF_SOCKET_DEFAULT */ &&\n\t\t    cf->cf_loc[1 /* PCMCIABUSCF_SOCKET */] != 0)\n\t\t\treturn 0;\n\n\t\tbreak;\n\tcase 1:\n\t\tif (cf->cf_loc[0 /* PCMCIABUSCF_CONTROLLER */] !=\n\t\t    -1 /* PCMCIABUSCF_CONTROLLER_DEFAULT */ &&\n\t\t    cf->cf_loc[0 /* PCMCIABUSCF_CONTROLLER */] != 0)\n\t\t\treturn 0;\n\t\tif (cf->cf_loc[1 /* PCMCIABUSCF_SOCKET */] !=\n\t\t    -1 /* PCMCIABUSCF_SOCKET_DEFAULT */ &&\n\t\t    cf->cf_loc[1 /* PCMCIABUSCF_SOCKET */] != 1)\n\t\t\treturn 0;\n\n\t\tbreak;\n\tdefault:\n\t\tpanic(\"unknown tcic socket\");\n\t}\n\n\treturn ((*cf->cf_attach->ca_match)(parent, cf, aux));\n}"
  },
  {
    "function_name": "tcic_init_socket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
    "lines": "515-536",
    "snippet": "void\ntcic_init_socket(h)\n\tstruct tcic_handle *h;\n{\n\tint reg;\n\n\t/* select this socket's config registers */\n\ttcic_sel_sock(h);\n\n\t/* set up the socket to interrupt on card detect */\n\treg = tcic_read_ind_2(h, TCIC_IR_SCF2_N(h->sock));\n\ttcic_write_ind_2(h, TCIC_IR_SCF2_N(h->sock), reg & ~TCIC_SCF2_MCD);\n\n\t/* enable CD irq in R_IENA */\n\treg = tcic_read_2(h, TCIC_R_IENA);\n\ttcic_write_2(h, TCIC_R_IENA, reg |= TCIC_IENA_CDCHG);\n\n\t/* if there's a card there, then attach it. also save sstat */\n\th->sstat = reg = tcic_read_1(h, TCIC_R_SSTAT) & TCIC_SSTAT_STAT_MASK;\n\tif (reg & TCIC_SSTAT_CD)\n\t\ttcic_attach_card(h);\n}",
    "includes": [
      "#include <dev/ic/tcic2var.h>",
      "#include <dev/ic/tcic2reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <sys/kthread.h>",
      "#include <sys/malloc.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\ttcic_init_socket",
      "void\ttcic_attach_card"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tcic_attach_card",
          "args": [
            "h"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_attach_card",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
          "lines": "720-734",
          "snippet": "void\ntcic_attach_card(h)\n\tstruct tcic_handle *h;\n{\n\tDPRINTF((\"tcic_attach_card\\n\"));\n\n\tif (h->flags & TCIC_FLAG_CARDP)\n\t\tpanic(\"tcic_attach_card: already attached\");\n\n\t/* call the MI attach function */\n\n\tpcmcia_card_attach(h->pcmcia);\n\n\th->flags |= TCIC_FLAG_CARDP;\n}",
          "includes": [
            "#include <dev/ic/tcic2var.h>",
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttcic_attach_card"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\ttcic_attach_card;\n\nvoid\ntcic_attach_card(h)\n\tstruct tcic_handle *h;\n{\n\tDPRINTF((\"tcic_attach_card\\n\"));\n\n\tif (h->flags & TCIC_FLAG_CARDP)\n\t\tpanic(\"tcic_attach_card: already attached\");\n\n\t/* call the MI attach function */\n\n\tpcmcia_card_attach(h->pcmcia);\n\n\th->flags |= TCIC_FLAG_CARDP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tcic_read_1",
          "args": [
            "h",
            "TCIC_R_SSTAT"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_read_1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2var.h",
          "lines": "187-193",
          "snippet": "static __inline__ int\ntcic_read_1(h, reg)\n\tstruct tcic_handle *h;\n\tint reg;\n{\n\treturn (bus_space_read_1(h->sc->iot, h->sc->ioh, reg));\n}",
          "includes": [
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/device.h>\n\nstatic __inline__ int\ntcic_read_1(h, reg)\n\tstruct tcic_handle *h;\n\tint reg;\n{\n\treturn (bus_space_read_1(h->sc->iot, h->sc->ioh, reg));\n}"
        }
      },
      {
        "call_info": {
          "callee": "tcic_write_2",
          "args": [
            "h",
            "TCIC_R_IENA",
            "reg |= TCIC_IENA_CDCHG"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_write_2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2var.h",
          "lines": "227-234",
          "snippet": "static __inline__ void\ntcic_write_2(h, reg, data)\n\tstruct tcic_handle *h;\n\tint reg;\n\tint data;\n{\n\tbus_space_write_2(h->sc->iot, h->sc->ioh, reg, (data));\n}",
          "includes": [
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/device.h>\n\nstatic __inline__ void\ntcic_write_2(h, reg, data)\n\tstruct tcic_handle *h;\n\tint reg;\n\tint data;\n{\n\tbus_space_write_2(h->sc->iot, h->sc->ioh, reg, (data));\n}"
        }
      },
      {
        "call_info": {
          "callee": "tcic_read_2",
          "args": [
            "h",
            "TCIC_R_IENA"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_read_2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2var.h",
          "lines": "196-202",
          "snippet": "static __inline__ int\ntcic_read_2(h, reg)\n\tstruct tcic_handle *h;\n\tint reg;\n{\n\treturn (bus_space_read_2(h->sc->iot, h->sc->ioh, reg));\n}",
          "includes": [
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/device.h>\n\nstatic __inline__ int\ntcic_read_2(h, reg)\n\tstruct tcic_handle *h;\n\tint reg;\n{\n\treturn (bus_space_read_2(h->sc->iot, h->sc->ioh, reg));\n}"
        }
      },
      {
        "call_info": {
          "callee": "tcic_write_ind_2",
          "args": [
            "h",
            "TCIC_IR_SCF2_N(h->sock)",
            "reg & ~TCIC_SCF2_MCD"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_write_ind_2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2var.h",
          "lines": "262-273",
          "snippet": "static __inline__ void\ntcic_write_ind_2(h, reg, data)\n\tstruct tcic_handle *h;\n\tint reg;\n\tint data;\n{\n\tint r_addr;\n\tr_addr = tcic_read_4(h, TCIC_R_ADDR);\n\ttcic_write_4(h, TCIC_R_ADDR, reg|TCIC_ADDR_INDREG);\n\tbus_space_write_2(h->sc->iot, h->sc->ioh, TCIC_R_DATA, (data));\n\ttcic_write_4(h, TCIC_R_ADDR, r_addr);\n}",
          "includes": [
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/device.h>\n\nstatic __inline__ void\ntcic_write_ind_2(h, reg, data)\n\tstruct tcic_handle *h;\n\tint reg;\n\tint data;\n{\n\tint r_addr;\n\tr_addr = tcic_read_4(h, TCIC_R_ADDR);\n\ttcic_write_4(h, TCIC_R_ADDR, reg|TCIC_ADDR_INDREG);\n\tbus_space_write_2(h->sc->iot, h->sc->ioh, TCIC_R_DATA, (data));\n\ttcic_write_4(h, TCIC_R_ADDR, r_addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TCIC_IR_SCF2_N",
          "args": [
            "h->sock"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcic_read_ind_2",
          "args": [
            "h",
            "TCIC_IR_SCF2_N(h->sock)"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_read_ind_2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2var.h",
          "lines": "248-259",
          "snippet": "static __inline__ int\ntcic_read_ind_2(h, reg)\n\tstruct tcic_handle *h;\n\tint reg;\n{\n\tint r_addr, val;\n\tr_addr = tcic_read_4(h, TCIC_R_ADDR);\n\ttcic_write_4(h, TCIC_R_ADDR, reg|TCIC_ADDR_INDREG);\n\tval = bus_space_read_2(h->sc->iot, h->sc->ioh, TCIC_R_DATA);\n\ttcic_write_4(h, TCIC_R_ADDR, r_addr);\n\treturn val;\n}",
          "includes": [
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/device.h>\n\nstatic __inline__ int\ntcic_read_ind_2(h, reg)\n\tstruct tcic_handle *h;\n\tint reg;\n{\n\tint r_addr, val;\n\tr_addr = tcic_read_4(h, TCIC_R_ADDR);\n\ttcic_write_4(h, TCIC_R_ADDR, reg|TCIC_ADDR_INDREG);\n\tval = bus_space_read_2(h->sc->iot, h->sc->ioh, TCIC_R_DATA);\n\ttcic_write_4(h, TCIC_R_ADDR, r_addr);\n\treturn val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TCIC_IR_SCF2_N",
          "args": [
            "h->sock"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcic_sel_sock",
          "args": [
            "h"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_sel_sock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2var.h",
          "lines": "276-284",
          "snippet": "static __inline__ void\ntcic_sel_sock(h)\n\tstruct tcic_handle *h;\n{\n\tint r_addr;\n\tr_addr = tcic_read_2(h, TCIC_R_ADDR2);\n\ttcic_write_2(h, TCIC_R_ADDR2,\n\t    (h->sock<<TCIC_ADDR2_SS_SHFT)|(r_addr & ~TCIC_ADDR2_SS_MASK));\n}",
          "includes": [
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/device.h>\n\nstatic __inline__ void\ntcic_sel_sock(h)\n\tstruct tcic_handle *h;\n{\n\tint r_addr;\n\tr_addr = tcic_read_2(h, TCIC_R_ADDR2);\n\ttcic_write_2(h, TCIC_R_ADDR2,\n\t    (h->sock<<TCIC_ADDR2_SS_SHFT)|(r_addr & ~TCIC_ADDR2_SS_MASK));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\ttcic_init_socket;\nvoid\ttcic_attach_card;\n\nvoid\ntcic_init_socket(h)\n\tstruct tcic_handle *h;\n{\n\tint reg;\n\n\t/* select this socket's config registers */\n\ttcic_sel_sock(h);\n\n\t/* set up the socket to interrupt on card detect */\n\treg = tcic_read_ind_2(h, TCIC_IR_SCF2_N(h->sock));\n\ttcic_write_ind_2(h, TCIC_IR_SCF2_N(h->sock), reg & ~TCIC_SCF2_MCD);\n\n\t/* enable CD irq in R_IENA */\n\treg = tcic_read_2(h, TCIC_R_IENA);\n\ttcic_write_2(h, TCIC_R_IENA, reg |= TCIC_IENA_CDCHG);\n\n\t/* if there's a card there, then attach it. also save sstat */\n\th->sstat = reg = tcic_read_1(h, TCIC_R_SSTAT) & TCIC_SSTAT_STAT_MASK;\n\tif (reg & TCIC_SSTAT_CD)\n\t\ttcic_attach_card(h);\n}"
  },
  {
    "function_name": "tcic_event_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
    "lines": "470-512",
    "snippet": "void\ntcic_event_thread(arg)\n\tvoid *arg;\n{\n\tstruct tcic_handle *h = arg;\n\tstruct tcic_event *pe;\n\tint s;\n\n\twhile (h->shutdown == 0) {\n\t\ts = splhigh();\n\t\tif ((pe = SIMPLEQ_FIRST(&h->events)) == NULL) {\n\t\t\tsplx(s);\n\t\t\t(void) tsleep(&h->events, PWAIT, \"tcicev\", 0);\n\t\t\tcontinue;\n\t\t}\n\t\tSIMPLEQ_REMOVE_HEAD(&h->events, pe, pe_q);\n\t\tsplx(s);\n\n\t\tswitch (pe->pe_type) {\n\t\tcase TCIC_EVENT_INSERTION:\n\t\t\tDPRINTF((\"%s: insertion event\\n\", h->sc->dev.dv_xname));\n\t\t\ttcic_attach_card(h);\n\t\t\tbreak;\n\n\t\tcase TCIC_EVENT_REMOVAL:\n\t\t\tDPRINTF((\"%s: removal event\\n\", h->sc->dev.dv_xname));\n\t\t\ttcic_detach_card(h, DETACH_FORCE);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tpanic(\"tcic_event_thread: unknown event %d\",\n\t\t\t    pe->pe_type);\n\t\t}\n\t\tfree(pe, M_TEMP);\n\t}\n\n\th->event_thread = NULL;\n\n\t/* In case parent is waiting for us to exit. */\n\twakeup(h->sc);\n\n\tkthread_exit(0);\n}",
    "includes": [
      "#include <dev/ic/tcic2var.h>",
      "#include <dev/ic/tcic2reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <sys/kthread.h>",
      "#include <sys/malloc.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\ttcic_attach_card",
      "void\ttcic_detach_card",
      "void\ttcic_event_thread"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kthread_exit",
          "args": [
            "0"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "h->sc"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "rln_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
          "lines": "171-214",
          "snippet": "u_int8_t\nrln_wakeup(sc, wnew)\n\tstruct rln_softc *\tsc;\n\tu_int8_t\t\twnew;\n{\n\tu_int8_t\t\twold, s;\n\tint\t\t\ti;\n\n\t/* Save what the last-written values were. */\n\twold = (sc->sc_status & RLN_STATUS_WAKEUP) |\n\t    (sc->sc_control & RLN_CONTROL_RESET);\n\n\tif (wnew == RLN_WAKEUP_SET) {\n\t\t/* SetWakeupBit() */\n\t\tdprintf(\" Ws[\");\n\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\tif (0/*LLDInactivityTimeOut &&\n\t\t    (sc->sc_cardtype & RLN_CTYPE_OEM)*/) {\n\t\t\tdprintf (\" 167ms\");\n\t\t\tDELAY(167000);\n\t\t} else {\n\t\t\tdprintf (\" .1ms\");\n\t\t\tDELAY(100);\n\t\t}\n\t\ts = rln_status_read(sc);\n\t\trln_control_set(sc, RLN_CONTROL_RESET);\n\t\tif ((s & RLN_STATUS_WAKEUP) != 0)\n\t\t\tfor (i = 0; i < 9; i++) {\n\t\t\t\tdprintf(\" 2ms\");\n\t\t\t\tDELAY(2000);\n\t\t\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\t\t}\n\t\tdprintf(\"]\");\n\t} else {\n\t\t/* ClearWakeupBit() */\n\t\tdprintf(\" Wc[\");\n\t\tif ((wnew & RLN_STATUS_WAKEUP) == 0)\n\t\t\trln_status_clear(sc, RLN_STATUS_WAKEUP);\n\t\tif ((wnew & RLN_CONTROL_RESET) == 0)\n\t\t\trln_control_clear(sc, RLN_CONTROL_RESET);\n\t\tdprintf(\"]\");\n\t}\n\treturn (wold);\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_int8_t\nrln_wakeup(sc, wnew)\n\tstruct rln_softc *\tsc;\n\tu_int8_t\t\twnew;\n{\n\tu_int8_t\t\twold, s;\n\tint\t\t\ti;\n\n\t/* Save what the last-written values were. */\n\twold = (sc->sc_status & RLN_STATUS_WAKEUP) |\n\t    (sc->sc_control & RLN_CONTROL_RESET);\n\n\tif (wnew == RLN_WAKEUP_SET) {\n\t\t/* SetWakeupBit() */\n\t\tdprintf(\" Ws[\");\n\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\tif (0/*LLDInactivityTimeOut &&\n\t\t    (sc->sc_cardtype & RLN_CTYPE_OEM)*/) {\n\t\t\tdprintf (\" 167ms\");\n\t\t\tDELAY(167000);\n\t\t} else {\n\t\t\tdprintf (\" .1ms\");\n\t\t\tDELAY(100);\n\t\t}\n\t\ts = rln_status_read(sc);\n\t\trln_control_set(sc, RLN_CONTROL_RESET);\n\t\tif ((s & RLN_STATUS_WAKEUP) != 0)\n\t\t\tfor (i = 0; i < 9; i++) {\n\t\t\t\tdprintf(\" 2ms\");\n\t\t\t\tDELAY(2000);\n\t\t\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\t\t}\n\t\tdprintf(\"]\");\n\t} else {\n\t\t/* ClearWakeupBit() */\n\t\tdprintf(\" Wc[\");\n\t\tif ((wnew & RLN_STATUS_WAKEUP) == 0)\n\t\t\trln_status_clear(sc, RLN_STATUS_WAKEUP);\n\t\tif ((wnew & RLN_CONTROL_RESET) == 0)\n\t\t\trln_control_clear(sc, RLN_CONTROL_RESET);\n\t\tdprintf(\"]\");\n\t}\n\treturn (wold);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "pe",
            "M_TEMP"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_chip_io_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
          "lines": "1101-1114",
          "snippet": "void \ntcic_chip_io_free(pch, pcihp)\n\tpcmcia_chipset_handle_t pch;\n\tstruct pcmcia_io_handle *pcihp;\n{\n\tbus_space_tag_t iot = pcihp->iot;\n\tbus_space_handle_t ioh = pcihp->ioh;\n\tbus_size_t size = pcihp->size;\n\n\tif (pcihp->flags & PCMCIA_IO_ALLOCATED)\n\t\tbus_space_free(iot, ioh, size);\n\telse\n\t\tbus_space_unmap(iot, ioh, size);\n}",
          "includes": [
            "#include <dev/ic/tcic2var.h>",
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid \ntcic_chip_io_free(pch, pcihp)\n\tpcmcia_chipset_handle_t pch;\n\tstruct pcmcia_io_handle *pcihp;\n{\n\tbus_space_tag_t iot = pcihp->iot;\n\tbus_space_handle_t ioh = pcihp->ioh;\n\tbus_size_t size = pcihp->size;\n\n\tif (pcihp->flags & PCMCIA_IO_ALLOCATED)\n\t\tbus_space_free(iot, ioh, size);\n\telse\n\t\tbus_space_unmap(iot, ioh, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"tcic_event_thread: unknown event %d\"",
            "pe->pe_type"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcic_detach_card",
          "args": [
            "h",
            "DETACH_FORCE"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_detach_card",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
          "lines": "736-752",
          "snippet": "void\ntcic_detach_card(h, flags)\n\tstruct tcic_handle *h;\n\tint flags;\t\t/* DETACH_* */\n{\n\tDPRINTF((\"tcic_detach_card\\n\"));\n\n\tif (!(h->flags & TCIC_FLAG_CARDP))\n\t\tpanic(\"tcic_detach_card: already detached\");\n\n\th->flags &= ~TCIC_FLAG_CARDP;\n\n\t/* call the MI detach function */\n\n\tpcmcia_card_detach(h->pcmcia, flags);\n\n}",
          "includes": [
            "#include <dev/ic/tcic2var.h>",
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttcic_detach_card"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\ttcic_detach_card;\n\nvoid\ntcic_detach_card(h, flags)\n\tstruct tcic_handle *h;\n\tint flags;\t\t/* DETACH_* */\n{\n\tDPRINTF((\"tcic_detach_card\\n\"));\n\n\tif (!(h->flags & TCIC_FLAG_CARDP))\n\t\tpanic(\"tcic_detach_card: already detached\");\n\n\th->flags &= ~TCIC_FLAG_CARDP;\n\n\t/* call the MI detach function */\n\n\tpcmcia_card_detach(h->pcmcia, flags);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: removal event\\n\", h->sc->dev.dv_xname)"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcic_attach_card",
          "args": [
            "h"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_attach_card",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
          "lines": "720-734",
          "snippet": "void\ntcic_attach_card(h)\n\tstruct tcic_handle *h;\n{\n\tDPRINTF((\"tcic_attach_card\\n\"));\n\n\tif (h->flags & TCIC_FLAG_CARDP)\n\t\tpanic(\"tcic_attach_card: already attached\");\n\n\t/* call the MI attach function */\n\n\tpcmcia_card_attach(h->pcmcia);\n\n\th->flags |= TCIC_FLAG_CARDP;\n}",
          "includes": [
            "#include <dev/ic/tcic2var.h>",
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttcic_attach_card"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\ttcic_attach_card;\n\nvoid\ntcic_attach_card(h)\n\tstruct tcic_handle *h;\n{\n\tDPRINTF((\"tcic_attach_card\\n\"));\n\n\tif (h->flags & TCIC_FLAG_CARDP)\n\t\tpanic(\"tcic_attach_card: already attached\");\n\n\t/* call the MI attach function */\n\n\tpcmcia_card_attach(h->pcmcia);\n\n\th->flags |= TCIC_FLAG_CARDP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: insertion event\\n\", h->sc->dev.dv_xname)"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_REMOVE_HEAD",
          "args": [
            "&h->events",
            "pe",
            "pe_q"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tsleep",
          "args": [
            "&h->events",
            "PWAIT",
            "\"tcicev\"",
            "0"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_FIRST",
          "args": [
            "&h->events"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splhigh",
          "args": [],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\ttcic_attach_card;\nvoid\ttcic_detach_card;\nvoid\ttcic_event_thread;\n\nvoid\ntcic_event_thread(arg)\n\tvoid *arg;\n{\n\tstruct tcic_handle *h = arg;\n\tstruct tcic_event *pe;\n\tint s;\n\n\twhile (h->shutdown == 0) {\n\t\ts = splhigh();\n\t\tif ((pe = SIMPLEQ_FIRST(&h->events)) == NULL) {\n\t\t\tsplx(s);\n\t\t\t(void) tsleep(&h->events, PWAIT, \"tcicev\", 0);\n\t\t\tcontinue;\n\t\t}\n\t\tSIMPLEQ_REMOVE_HEAD(&h->events, pe, pe_q);\n\t\tsplx(s);\n\n\t\tswitch (pe->pe_type) {\n\t\tcase TCIC_EVENT_INSERTION:\n\t\t\tDPRINTF((\"%s: insertion event\\n\", h->sc->dev.dv_xname));\n\t\t\ttcic_attach_card(h);\n\t\t\tbreak;\n\n\t\tcase TCIC_EVENT_REMOVAL:\n\t\t\tDPRINTF((\"%s: removal event\\n\", h->sc->dev.dv_xname));\n\t\t\ttcic_detach_card(h, DETACH_FORCE);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tpanic(\"tcic_event_thread: unknown event %d\",\n\t\t\t    pe->pe_type);\n\t\t}\n\t\tfree(pe, M_TEMP);\n\t}\n\n\th->event_thread = NULL;\n\n\t/* In case parent is waiting for us to exit. */\n\twakeup(h->sc);\n\n\tkthread_exit(0);\n}"
  },
  {
    "function_name": "tcic_create_event_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
    "lines": "444-468",
    "snippet": "void\ntcic_create_event_thread(arg)\n\tvoid *arg;\n{\n\tstruct tcic_handle *h = arg;\n\tconst char *cs;\n\n\tswitch (h->sock) {\n\tcase 0:\n\t\tcs = \"0\";\n\t\tbreak;\n\tcase 1:\n\t\tcs = \"1\";\n\t\tbreak;\n\tdefault:\n\t\tpanic(\"tcic_create_event_thread: unknown tcic socket\");\n\t}\n\n\tif (kthread_create(tcic_event_thread, h, &h->event_thread,\n\t    \"%s,%s\", h->sc->dev.dv_xname, cs)) {\n\t\tprintf(\"%s: unable to create event thread for sock 0x%02x\\n\",\n\t\t    h->sc->dev.dv_xname, h->sock);\n\t\tpanic(\"tcic_create_event_thread\");\n\t}\n}",
    "includes": [
      "#include <dev/ic/tcic2var.h>",
      "#include <dev/ic/tcic2reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <sys/kthread.h>",
      "#include <sys/malloc.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\ttcic_create_event_thread",
      "void\ttcic_event_thread"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"tcic_create_event_thread\""
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: unable to create event thread for sock 0x%02x\\n\"",
            "h->sc->dev.dv_xname",
            "h->sock"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_create",
          "args": [
            "tcic_event_thread",
            "h",
            "&h->event_thread",
            "\"%s,%s\"",
            "h->sc->dev.dv_xname",
            "cs"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"tcic_create_event_thread: unknown tcic socket\""
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\ttcic_create_event_thread;\nvoid\ttcic_event_thread;\n\nvoid\ntcic_create_event_thread(arg)\n\tvoid *arg;\n{\n\tstruct tcic_handle *h = arg;\n\tconst char *cs;\n\n\tswitch (h->sock) {\n\tcase 0:\n\t\tcs = \"0\";\n\t\tbreak;\n\tcase 1:\n\t\tcs = \"1\";\n\t\tbreak;\n\tdefault:\n\t\tpanic(\"tcic_create_event_thread: unknown tcic socket\");\n\t}\n\n\tif (kthread_create(tcic_event_thread, h, &h->event_thread,\n\t    \"%s,%s\", h->sc->dev.dv_xname, cs)) {\n\t\tprintf(\"%s: unable to create event thread for sock 0x%02x\\n\",\n\t\t    h->sc->dev.dv_xname, h->sock);\n\t\tpanic(\"tcic_create_event_thread\");\n\t}\n}"
  },
  {
    "function_name": "tcic_attach_socket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
    "lines": "412-442",
    "snippet": "void\ntcic_attach_socket(h)\n\tstruct tcic_handle *h;\n{\n\tstruct pcmciabus_attach_args paa;\n\n\t/* initialize the rest of the handle */\n\n\th->shutdown = 0;\n\th->memalloc = 0;\n\th->ioalloc = 0;\n\th->ih_irq = 0;\n\n\t/* now, config one pcmcia device per socket */\n\n\tpaa.paa_busname = \"pcmcia\";\n\tpaa.pct = (pcmcia_chipset_tag_t) h->sc->pct;\n\tpaa.pch = (pcmcia_chipset_handle_t) h;\n\tpaa.iobase = h->sc->iobase;\n\tpaa.iosize = h->sc->iosize;\n\n\th->pcmcia = config_found_sm(&h->sc->dev, &paa, tcic_print,\n\t    tcic_submatch);\n\n\t/* if there's actually a pcmcia device attached, initialize the slot */\n\n\tif (h->pcmcia)\n\t\ttcic_init_socket(h);\n\telse\n\t\th->flags &= ~TCIC_FLAG_SOCKETP;\n}",
    "includes": [
      "#include <dev/ic/tcic2var.h>",
      "#include <dev/ic/tcic2reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <sys/kthread.h>",
      "#include <sys/malloc.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\ttcic_attach_socket",
      "void\ttcic_init_socket",
      "int\ttcic_submatch",
      "int\ttcic_print"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tcic_init_socket",
          "args": [
            "h"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_init_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
          "lines": "515-536",
          "snippet": "void\ntcic_init_socket(h)\n\tstruct tcic_handle *h;\n{\n\tint reg;\n\n\t/* select this socket's config registers */\n\ttcic_sel_sock(h);\n\n\t/* set up the socket to interrupt on card detect */\n\treg = tcic_read_ind_2(h, TCIC_IR_SCF2_N(h->sock));\n\ttcic_write_ind_2(h, TCIC_IR_SCF2_N(h->sock), reg & ~TCIC_SCF2_MCD);\n\n\t/* enable CD irq in R_IENA */\n\treg = tcic_read_2(h, TCIC_R_IENA);\n\ttcic_write_2(h, TCIC_R_IENA, reg |= TCIC_IENA_CDCHG);\n\n\t/* if there's a card there, then attach it. also save sstat */\n\th->sstat = reg = tcic_read_1(h, TCIC_R_SSTAT) & TCIC_SSTAT_STAT_MASK;\n\tif (reg & TCIC_SSTAT_CD)\n\t\ttcic_attach_card(h);\n}",
          "includes": [
            "#include <dev/ic/tcic2var.h>",
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttcic_init_socket",
            "void\ttcic_attach_card"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\ttcic_init_socket;\nvoid\ttcic_attach_card;\n\nvoid\ntcic_init_socket(h)\n\tstruct tcic_handle *h;\n{\n\tint reg;\n\n\t/* select this socket's config registers */\n\ttcic_sel_sock(h);\n\n\t/* set up the socket to interrupt on card detect */\n\treg = tcic_read_ind_2(h, TCIC_IR_SCF2_N(h->sock));\n\ttcic_write_ind_2(h, TCIC_IR_SCF2_N(h->sock), reg & ~TCIC_SCF2_MCD);\n\n\t/* enable CD irq in R_IENA */\n\treg = tcic_read_2(h, TCIC_R_IENA);\n\ttcic_write_2(h, TCIC_R_IENA, reg |= TCIC_IENA_CDCHG);\n\n\t/* if there's a card there, then attach it. also save sstat */\n\th->sstat = reg = tcic_read_1(h, TCIC_R_SSTAT) & TCIC_SSTAT_STAT_MASK;\n\tif (reg & TCIC_SSTAT_CD)\n\t\ttcic_attach_card(h);\n}"
        }
      },
      {
        "call_info": {
          "callee": "config_found_sm",
          "args": [
            "&h->sc->dev",
            "&paa",
            "tcic_print",
            "tcic_submatch"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\ttcic_attach_socket;\nvoid\ttcic_init_socket;\nint\ttcic_submatch;\nint\ttcic_print;\n\nvoid\ntcic_attach_socket(h)\n\tstruct tcic_handle *h;\n{\n\tstruct pcmciabus_attach_args paa;\n\n\t/* initialize the rest of the handle */\n\n\th->shutdown = 0;\n\th->memalloc = 0;\n\th->ioalloc = 0;\n\th->ih_irq = 0;\n\n\t/* now, config one pcmcia device per socket */\n\n\tpaa.paa_busname = \"pcmcia\";\n\tpaa.pct = (pcmcia_chipset_tag_t) h->sc->pct;\n\tpaa.pch = (pcmcia_chipset_handle_t) h;\n\tpaa.iobase = h->sc->iobase;\n\tpaa.iosize = h->sc->iosize;\n\n\th->pcmcia = config_found_sm(&h->sc->dev, &paa, tcic_print,\n\t    tcic_submatch);\n\n\t/* if there's actually a pcmcia device attached, initialize the slot */\n\n\tif (h->pcmcia)\n\t\ttcic_init_socket(h);\n\telse\n\t\th->flags &= ~TCIC_FLAG_SOCKETP;\n}"
  },
  {
    "function_name": "tcic_attach_sockets",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
    "lines": "401-410",
    "snippet": "void\ntcic_attach_sockets(sc)\n\tstruct tcic_softc *sc;\n{\n\tint i;\n\n\tfor (i = 0; i < TCIC_NSLOTS; i++)\n\t\tif (sc->handle[i].flags & TCIC_FLAG_SOCKETP)\n\t\t\ttcic_attach_socket(&sc->handle[i]);\n}",
    "includes": [
      "#include <dev/ic/tcic2var.h>",
      "#include <dev/ic/tcic2reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <sys/kthread.h>",
      "#include <sys/malloc.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\ttcic_attach_socket"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tcic_attach_socket",
          "args": [
            "&sc->handle[i]"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_attach_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
          "lines": "412-442",
          "snippet": "void\ntcic_attach_socket(h)\n\tstruct tcic_handle *h;\n{\n\tstruct pcmciabus_attach_args paa;\n\n\t/* initialize the rest of the handle */\n\n\th->shutdown = 0;\n\th->memalloc = 0;\n\th->ioalloc = 0;\n\th->ih_irq = 0;\n\n\t/* now, config one pcmcia device per socket */\n\n\tpaa.paa_busname = \"pcmcia\";\n\tpaa.pct = (pcmcia_chipset_tag_t) h->sc->pct;\n\tpaa.pch = (pcmcia_chipset_handle_t) h;\n\tpaa.iobase = h->sc->iobase;\n\tpaa.iosize = h->sc->iosize;\n\n\th->pcmcia = config_found_sm(&h->sc->dev, &paa, tcic_print,\n\t    tcic_submatch);\n\n\t/* if there's actually a pcmcia device attached, initialize the slot */\n\n\tif (h->pcmcia)\n\t\ttcic_init_socket(h);\n\telse\n\t\th->flags &= ~TCIC_FLAG_SOCKETP;\n}",
          "includes": [
            "#include <dev/ic/tcic2var.h>",
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttcic_attach_socket",
            "void\ttcic_init_socket",
            "int\ttcic_submatch",
            "int\ttcic_print"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\ttcic_attach_socket;\nvoid\ttcic_init_socket;\nint\ttcic_submatch;\nint\ttcic_print;\n\nvoid\ntcic_attach_socket(h)\n\tstruct tcic_handle *h;\n{\n\tstruct pcmciabus_attach_args paa;\n\n\t/* initialize the rest of the handle */\n\n\th->shutdown = 0;\n\th->memalloc = 0;\n\th->ioalloc = 0;\n\th->ih_irq = 0;\n\n\t/* now, config one pcmcia device per socket */\n\n\tpaa.paa_busname = \"pcmcia\";\n\tpaa.pct = (pcmcia_chipset_tag_t) h->sc->pct;\n\tpaa.pch = (pcmcia_chipset_handle_t) h;\n\tpaa.iobase = h->sc->iobase;\n\tpaa.iosize = h->sc->iosize;\n\n\th->pcmcia = config_found_sm(&h->sc->dev, &paa, tcic_print,\n\t    tcic_submatch);\n\n\t/* if there's actually a pcmcia device attached, initialize the slot */\n\n\tif (h->pcmcia)\n\t\ttcic_init_socket(h);\n\telse\n\t\th->flags &= ~TCIC_FLAG_SOCKETP;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\ttcic_attach_socket;\n\nvoid\ntcic_attach_sockets(sc)\n\tstruct tcic_softc *sc;\n{\n\tint i;\n\n\tfor (i = 0; i < TCIC_NSLOTS; i++)\n\t\tif (sc->handle[i].flags & TCIC_FLAG_SOCKETP)\n\t\t\ttcic_attach_socket(&sc->handle[i]);\n}"
  },
  {
    "function_name": "tcic_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
    "lines": "319-399",
    "snippet": "void\ntcic_attach(sc)\n\tstruct tcic_softc *sc;\n{\n\tint i, reg;\n\n\t/* set more chipset dependend parameters in the softc. */\n\tswitch (sc->chipid) {\n\tcase TCIC_CHIPID_DB86084_1:\n\tcase TCIC_CHIPID_DB86084A:\n\tcase TCIC_CHIPID_DB86184_1:\n\t\tsc->pwrena = TCIC_PWR_ENA;\n\t\tbreak;\n\tdefault:\n\t\tsc->pwrena = 0;\n\t\tbreak;\n\t}\n\n\t/* set up global config registers */\n\treg = TCIC_WAIT_SYNC | TCIC_WAIT_CCLK | TCIC_WAIT_RISING;\n\treg |= (tcic_ns2wscnt(250) & TCIC_WAIT_COUNT_MASK);\n\ttcic_write_aux_1(sc->iot, sc->ioh, TCIC_AR_WCTL, TCIC_R_WCTL_WAIT, reg);\n\treg = TCIC_SYSCFG_MPSEL_RI | TCIC_SYSCFG_MCSFULL;\n\ttcic_write_aux_2(sc->iot, sc->ioh, TCIC_AR_SYSCFG, reg);\n\treg = tcic_read_aux_2(sc->iot, sc->ioh, TCIC_AR_ILOCK);\n\treg |= TCIC_ILOCK_HOLD_CCLK;\n\ttcic_write_aux_2(sc->iot, sc->ioh, TCIC_AR_ILOCK, reg);\n\n\t/* the TCIC has two sockets */\n\t/* XXX should i check for actual presence of sockets? -chb */\n\tfor (i = 0; i < TCIC_NSLOTS; i++) {\n\t\tsc->handle[i].sc = sc;\n\t\tsc->handle[i].sock = i;\n\t\tsc->handle[i].flags = TCIC_FLAG_SOCKETP;\n\t\tsc->handle[i].memwins\n\t\t    = sc->chipid == TCIC_CHIPID_DB86082_1 ?  4 : 5;\n\t}\n\n\t/* establish the interrupt */\n\treg = tcic_read_1(&sc->handle[0], TCIC_R_IENA);\n\ttcic_write_1(&sc->handle[0], TCIC_R_IENA,\n\t    (reg & ~TCIC_IENA_CFG_MASK) | TCIC_IENA_CFG_HIGH);\n\treg = tcic_read_aux_2(sc->iot, sc->ioh, TCIC_AR_SYSCFG);\n\ttcic_write_aux_2(sc->iot, sc->ioh, TCIC_AR_SYSCFG,\n\t    (reg & ~TCIC_SYSCFG_IRQ_MASK) | tcic_irqmap[sc->irq]);\n\n\t/* XXX block interrupts? */\n\n\tfor (i = 0; i < TCIC_NSLOTS; i++) {\n\t\t/* XXX make more clear what happens here -chb */\n\t\ttcic_sel_sock(&sc->handle[i]);\n\t\ttcic_write_ind_2(&sc->handle[i], TCIC_IR_SCF1_N(i), 0);\n\t\ttcic_write_ind_2(&sc->handle[i], TCIC_IR_SCF2_N(i), \n\t\t    (TCIC_SCF2_MCD|TCIC_SCF2_MWP|TCIC_SCF2_MRDY\n#if 1\t\t/* XXX explain byte routing issue */\n\t\t    |TCIC_SCF2_MLBAT2|TCIC_SCF2_MLBAT1|TCIC_SCF2_IDBR));\n#else\n\t\t    |TCIC_SCF2_MLBAT2|TCIC_SCF2_MLBAT1));\n#endif\n\t\ttcic_write_1(&sc->handle[i], TCIC_R_MODE, 0);\n\t\treg = tcic_read_aux_2(sc->iot, sc->ioh, TCIC_AR_SYSCFG);\n\t\treg &= ~TCIC_SYSCFG_AUTOBUSY;\n\t\ttcic_write_aux_2(sc->iot, sc->ioh, TCIC_AR_SYSCFG, reg);\n\t\tSIMPLEQ_INIT(&sc->handle[i].events);\n\t}\n\n\tif ((sc->handle[0].flags & TCIC_FLAG_SOCKETP) ||\n\t    (sc->handle[1].flags & TCIC_FLAG_SOCKETP)) {\n\t\tprintf(\"%s: %s has \", sc->dev.dv_xname,\n\t\t       tcic_chipid_to_string(sc->chipid));\n\n\t\tif ((sc->handle[0].flags & TCIC_FLAG_SOCKETP) &&\n\t\t    (sc->handle[1].flags & TCIC_FLAG_SOCKETP))\n\t\t\tprintf(\"sockets A and B\\n\");\n\t\telse if (sc->handle[0].flags & TCIC_FLAG_SOCKETP)\n\t\t\tprintf(\"socket A only\\n\");\n\t\telse\n\t\t\tprintf(\"socket B only\\n\");\n\n\t}\n}",
    "includes": [
      "#include <dev/ic/tcic2var.h>",
      "#include <dev/ic/tcic2reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <sys/kthread.h>",
      "#include <sys/malloc.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"socket B only\\n\""
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tcic_chipid_to_string",
          "args": [
            "sc->chipid"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_INIT",
          "args": [
            "&sc->handle[i].events"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcic_write_aux_2",
          "args": [
            "sc->iot",
            "sc->ioh",
            "TCIC_AR_SYSCFG",
            "reg"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_write_aux_2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2var.h",
          "lines": "347-357",
          "snippet": "static __inline__ void\ntcic_write_aux_2(iot, ioh, auxreg, val)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tint auxreg, val;\n{\n\tint mode;\n\tmode = bus_space_read_1(iot, ioh, TCIC_R_MODE);\n\tbus_space_write_1(iot, ioh, TCIC_R_MODE, (mode & ~TCIC_AR_MASK)|auxreg);\n\tbus_space_write_2(iot, ioh, TCIC_R_AUX, val);\n}",
          "includes": [
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/device.h>\n\nstatic __inline__ void\ntcic_write_aux_2(iot, ioh, auxreg, val)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tint auxreg, val;\n{\n\tint mode;\n\tmode = bus_space_read_1(iot, ioh, TCIC_R_MODE);\n\tbus_space_write_1(iot, ioh, TCIC_R_MODE, (mode & ~TCIC_AR_MASK)|auxreg);\n\tbus_space_write_2(iot, ioh, TCIC_R_AUX, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tcic_read_aux_2",
          "args": [
            "sc->iot",
            "sc->ioh",
            "TCIC_AR_SYSCFG"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_read_aux_2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2var.h",
          "lines": "320-331",
          "snippet": "static __inline__ int\ntcic_read_aux_2(iot, ioh, auxreg)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tint auxreg;\n{\n\tint mode, val;\n\tmode = bus_space_read_1(iot, ioh, TCIC_R_MODE);\n\tbus_space_write_1(iot, ioh, TCIC_R_MODE, (mode & ~TCIC_AR_MASK)|auxreg);\n\tval = bus_space_read_2(iot, ioh, TCIC_R_AUX);\n\treturn val;\n}",
          "includes": [
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/device.h>\n\nstatic __inline__ int\ntcic_read_aux_2(iot, ioh, auxreg)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tint auxreg;\n{\n\tint mode, val;\n\tmode = bus_space_read_1(iot, ioh, TCIC_R_MODE);\n\tbus_space_write_1(iot, ioh, TCIC_R_MODE, (mode & ~TCIC_AR_MASK)|auxreg);\n\tval = bus_space_read_2(iot, ioh, TCIC_R_AUX);\n\treturn val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tcic_write_1",
          "args": [
            "&sc->handle[i]",
            "TCIC_R_MODE",
            "0"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_write_1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2var.h",
          "lines": "217-224",
          "snippet": "static __inline__ void\ntcic_write_1(h, reg, data)\n\tstruct tcic_handle *h;\n\tint reg;\n\tint data;\n{\n\tbus_space_write_1(h->sc->iot, h->sc->ioh, reg, (data));\n}",
          "includes": [
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/device.h>\n\nstatic __inline__ void\ntcic_write_1(h, reg, data)\n\tstruct tcic_handle *h;\n\tint reg;\n\tint data;\n{\n\tbus_space_write_1(h->sc->iot, h->sc->ioh, reg, (data));\n}"
        }
      },
      {
        "call_info": {
          "callee": "tcic_write_ind_2",
          "args": [
            "&sc->handle[i]",
            "TCIC_IR_SCF2_N(i)",
            "(TCIC_SCF2_MCD|TCIC_SCF2_MWP|TCIC_SCF2_MRDY\n#if 1\t\t/* XXX explain byte routing issue */\n\t\t    |TCIC_SCF2_MLBAT2|TCIC_SCF2_MLBAT1|TCIC_SCF2_IDBR)"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_write_ind_2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2var.h",
          "lines": "262-273",
          "snippet": "static __inline__ void\ntcic_write_ind_2(h, reg, data)\n\tstruct tcic_handle *h;\n\tint reg;\n\tint data;\n{\n\tint r_addr;\n\tr_addr = tcic_read_4(h, TCIC_R_ADDR);\n\ttcic_write_4(h, TCIC_R_ADDR, reg|TCIC_ADDR_INDREG);\n\tbus_space_write_2(h->sc->iot, h->sc->ioh, TCIC_R_DATA, (data));\n\ttcic_write_4(h, TCIC_R_ADDR, r_addr);\n}",
          "includes": [
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/device.h>\n\nstatic __inline__ void\ntcic_write_ind_2(h, reg, data)\n\tstruct tcic_handle *h;\n\tint reg;\n\tint data;\n{\n\tint r_addr;\n\tr_addr = tcic_read_4(h, TCIC_R_ADDR);\n\ttcic_write_4(h, TCIC_R_ADDR, reg|TCIC_ADDR_INDREG);\n\tbus_space_write_2(h->sc->iot, h->sc->ioh, TCIC_R_DATA, (data));\n\ttcic_write_4(h, TCIC_R_ADDR, r_addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TCIC_IR_SCF2_N",
          "args": [
            "i"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TCIC_IR_SCF1_N",
          "args": [
            "i"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcic_sel_sock",
          "args": [
            "&sc->handle[i]"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_sel_sock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2var.h",
          "lines": "276-284",
          "snippet": "static __inline__ void\ntcic_sel_sock(h)\n\tstruct tcic_handle *h;\n{\n\tint r_addr;\n\tr_addr = tcic_read_2(h, TCIC_R_ADDR2);\n\ttcic_write_2(h, TCIC_R_ADDR2,\n\t    (h->sock<<TCIC_ADDR2_SS_SHFT)|(r_addr & ~TCIC_ADDR2_SS_MASK));\n}",
          "includes": [
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/device.h>\n\nstatic __inline__ void\ntcic_sel_sock(h)\n\tstruct tcic_handle *h;\n{\n\tint r_addr;\n\tr_addr = tcic_read_2(h, TCIC_R_ADDR2);\n\ttcic_write_2(h, TCIC_R_ADDR2,\n\t    (h->sock<<TCIC_ADDR2_SS_SHFT)|(r_addr & ~TCIC_ADDR2_SS_MASK));\n}"
        }
      },
      {
        "call_info": {
          "callee": "tcic_read_1",
          "args": [
            "&sc->handle[0]",
            "TCIC_R_IENA"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_read_1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2var.h",
          "lines": "187-193",
          "snippet": "static __inline__ int\ntcic_read_1(h, reg)\n\tstruct tcic_handle *h;\n\tint reg;\n{\n\treturn (bus_space_read_1(h->sc->iot, h->sc->ioh, reg));\n}",
          "includes": [
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/device.h>\n\nstatic __inline__ int\ntcic_read_1(h, reg)\n\tstruct tcic_handle *h;\n\tint reg;\n{\n\treturn (bus_space_read_1(h->sc->iot, h->sc->ioh, reg));\n}"
        }
      },
      {
        "call_info": {
          "callee": "tcic_write_aux_1",
          "args": [
            "sc->iot",
            "sc->ioh",
            "TCIC_AR_WCTL",
            "TCIC_R_WCTL_WAIT",
            "reg"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_write_aux_1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2var.h",
          "lines": "334-344",
          "snippet": "static __inline__ void\ntcic_write_aux_1(iot, ioh, auxreg, reg, val)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tint auxreg, reg, val;\n{\n\tint mode;\n\tmode = bus_space_read_1(iot, ioh, TCIC_R_MODE);\n\tbus_space_write_1(iot, ioh, TCIC_R_MODE, (mode & ~TCIC_AR_MASK)|auxreg);\n\tbus_space_write_1(iot, ioh, reg, val);\n}",
          "includes": [
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/device.h>\n\nstatic __inline__ void\ntcic_write_aux_1(iot, ioh, auxreg, reg, val)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tint auxreg, reg, val;\n{\n\tint mode;\n\tmode = bus_space_read_1(iot, ioh, TCIC_R_MODE);\n\tbus_space_write_1(iot, ioh, TCIC_R_MODE, (mode & ~TCIC_AR_MASK)|auxreg);\n\tbus_space_write_1(iot, ioh, reg, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tcic_ns2wscnt",
          "args": [
            "250"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_ns2wscnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
          "lines": "1376-1385",
          "snippet": "int\ntcic_ns2wscnt(ns)\n\tint ns;\n{\n\tif (ns < 14) {\n\t\treturn 0;\n\t} else {\n\t\treturn (2*(ns-14))/70;\t/* XXX assumes 14.31818 MHz clock. */\n\t}\n}",
          "includes": [
            "#include <dev/ic/tcic2var.h>",
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\ntcic_ns2wscnt(ns)\n\tint ns;\n{\n\tif (ns < 14) {\n\t\treturn 0;\n\t} else {\n\t\treturn (2*(ns-14))/70;\t/* XXX assumes 14.31818 MHz clock. */\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\ntcic_attach(sc)\n\tstruct tcic_softc *sc;\n{\n\tint i, reg;\n\n\t/* set more chipset dependend parameters in the softc. */\n\tswitch (sc->chipid) {\n\tcase TCIC_CHIPID_DB86084_1:\n\tcase TCIC_CHIPID_DB86084A:\n\tcase TCIC_CHIPID_DB86184_1:\n\t\tsc->pwrena = TCIC_PWR_ENA;\n\t\tbreak;\n\tdefault:\n\t\tsc->pwrena = 0;\n\t\tbreak;\n\t}\n\n\t/* set up global config registers */\n\treg = TCIC_WAIT_SYNC | TCIC_WAIT_CCLK | TCIC_WAIT_RISING;\n\treg |= (tcic_ns2wscnt(250) & TCIC_WAIT_COUNT_MASK);\n\ttcic_write_aux_1(sc->iot, sc->ioh, TCIC_AR_WCTL, TCIC_R_WCTL_WAIT, reg);\n\treg = TCIC_SYSCFG_MPSEL_RI | TCIC_SYSCFG_MCSFULL;\n\ttcic_write_aux_2(sc->iot, sc->ioh, TCIC_AR_SYSCFG, reg);\n\treg = tcic_read_aux_2(sc->iot, sc->ioh, TCIC_AR_ILOCK);\n\treg |= TCIC_ILOCK_HOLD_CCLK;\n\ttcic_write_aux_2(sc->iot, sc->ioh, TCIC_AR_ILOCK, reg);\n\n\t/* the TCIC has two sockets */\n\t/* XXX should i check for actual presence of sockets? -chb */\n\tfor (i = 0; i < TCIC_NSLOTS; i++) {\n\t\tsc->handle[i].sc = sc;\n\t\tsc->handle[i].sock = i;\n\t\tsc->handle[i].flags = TCIC_FLAG_SOCKETP;\n\t\tsc->handle[i].memwins\n\t\t    = sc->chipid == TCIC_CHIPID_DB86082_1 ?  4 : 5;\n\t}\n\n\t/* establish the interrupt */\n\treg = tcic_read_1(&sc->handle[0], TCIC_R_IENA);\n\ttcic_write_1(&sc->handle[0], TCIC_R_IENA,\n\t    (reg & ~TCIC_IENA_CFG_MASK) | TCIC_IENA_CFG_HIGH);\n\treg = tcic_read_aux_2(sc->iot, sc->ioh, TCIC_AR_SYSCFG);\n\ttcic_write_aux_2(sc->iot, sc->ioh, TCIC_AR_SYSCFG,\n\t    (reg & ~TCIC_SYSCFG_IRQ_MASK) | tcic_irqmap[sc->irq]);\n\n\t/* XXX block interrupts? */\n\n\tfor (i = 0; i < TCIC_NSLOTS; i++) {\n\t\t/* XXX make more clear what happens here -chb */\n\t\ttcic_sel_sock(&sc->handle[i]);\n\t\ttcic_write_ind_2(&sc->handle[i], TCIC_IR_SCF1_N(i), 0);\n\t\ttcic_write_ind_2(&sc->handle[i], TCIC_IR_SCF2_N(i), \n\t\t    (TCIC_SCF2_MCD|TCIC_SCF2_MWP|TCIC_SCF2_MRDY\n#if 1\t\t/* XXX explain byte routing issue */\n\t\t    |TCIC_SCF2_MLBAT2|TCIC_SCF2_MLBAT1|TCIC_SCF2_IDBR));\n#else\n\t\t    |TCIC_SCF2_MLBAT2|TCIC_SCF2_MLBAT1));\n#endif\n\t\ttcic_write_1(&sc->handle[i], TCIC_R_MODE, 0);\n\t\treg = tcic_read_aux_2(sc->iot, sc->ioh, TCIC_AR_SYSCFG);\n\t\treg &= ~TCIC_SYSCFG_AUTOBUSY;\n\t\ttcic_write_aux_2(sc->iot, sc->ioh, TCIC_AR_SYSCFG, reg);\n\t\tSIMPLEQ_INIT(&sc->handle[i].events);\n\t}\n\n\tif ((sc->handle[0].flags & TCIC_FLAG_SOCKETP) ||\n\t    (sc->handle[1].flags & TCIC_FLAG_SOCKETP)) {\n\t\tprintf(\"%s: %s has \", sc->dev.dv_xname,\n\t\t       tcic_chipid_to_string(sc->chipid));\n\n\t\tif ((sc->handle[0].flags & TCIC_FLAG_SOCKETP) &&\n\t\t    (sc->handle[1].flags & TCIC_FLAG_SOCKETP))\n\t\t\tprintf(\"sockets A and B\\n\");\n\t\telse if (sc->handle[0].flags & TCIC_FLAG_SOCKETP)\n\t\t\tprintf(\"socket A only\\n\");\n\t\telse\n\t\t\tprintf(\"socket B only\\n\");\n\n\t}\n}"
  },
  {
    "function_name": "tcic_validirqs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
    "lines": "300-317",
    "snippet": "int\ntcic_validirqs(chipid)\n\tint chipid;\n{\n\tswitch (chipid) {\n\tcase TCIC_CHIPID_DB86082_1:\n\tcase TCIC_CHIPID_DB86082A:\n\tcase TCIC_CHIPID_DB86082B_ES:\n\tcase TCIC_CHIPID_DB86082B:\n\tcase TCIC_CHIPID_DB86084_1:\n\tcase TCIC_CHIPID_DB86084A:\n\tcase TCIC_CHIPID_DB86184_1:\n\tcase TCIC_CHIPID_DB86072_1_ES:\n\tcase TCIC_CHIPID_DB86072_1:\n\t\treturn tcic_valid_irqs;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <dev/ic/tcic2var.h>",
      "#include <dev/ic/tcic2reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <sys/kthread.h>",
      "#include <sys/malloc.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\ntcic_validirqs(chipid)\n\tint chipid;\n{\n\tswitch (chipid) {\n\tcase TCIC_CHIPID_DB86082_1:\n\tcase TCIC_CHIPID_DB86082A:\n\tcase TCIC_CHIPID_DB86082B_ES:\n\tcase TCIC_CHIPID_DB86082B:\n\tcase TCIC_CHIPID_DB86084_1:\n\tcase TCIC_CHIPID_DB86084A:\n\tcase TCIC_CHIPID_DB86184_1:\n\tcase TCIC_CHIPID_DB86072_1_ES:\n\tcase TCIC_CHIPID_DB86072_1:\n\t\treturn tcic_valid_irqs;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "tcic_chipid_known",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
    "lines": "248-267",
    "snippet": "int\ntcic_chipid_known(id)\n\tint id;\n{\n\t/* XXX only know how to handle DB86082 -chb */\n\tswitch (id) {\n\tcase TCIC_CHIPID_DB86082_1:\n\tcase TCIC_CHIPID_DB86082A:\n\tcase TCIC_CHIPID_DB86082B_ES:\n\tcase TCIC_CHIPID_DB86082B:\n\tcase TCIC_CHIPID_DB86084_1:\n\tcase TCIC_CHIPID_DB86084A:\n\tcase TCIC_CHIPID_DB86184_1:\n\tcase TCIC_CHIPID_DB86072_1_ES:\n\tcase TCIC_CHIPID_DB86072_1:\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <dev/ic/tcic2var.h>",
      "#include <dev/ic/tcic2reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <sys/kthread.h>",
      "#include <sys/malloc.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "char *\ntcic_chipid_to_string(id)\n\tint id;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nchar *\ntcic_chipid_to_string(id)\n\tint id;\n\nint\ntcic_chipid_known(id)\n\tint id;\n{\n\t/* XXX only know how to handle DB86082 -chb */\n\tswitch (id) {\n\tcase TCIC_CHIPID_DB86082_1:\n\tcase TCIC_CHIPID_DB86082A:\n\tcase TCIC_CHIPID_DB86082B_ES:\n\tcase TCIC_CHIPID_DB86082B:\n\tcase TCIC_CHIPID_DB86084_1:\n\tcase TCIC_CHIPID_DB86084A:\n\tcase TCIC_CHIPID_DB86184_1:\n\tcase TCIC_CHIPID_DB86072_1_ES:\n\tcase TCIC_CHIPID_DB86072_1:\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "tcic_chipid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
    "lines": "225-244",
    "snippet": "int\ntcic_chipid(iot, ioh)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n{\n\tunsigned id, otest;\n\n\totest = tcic_read_aux_2(iot, ioh, TCIC_AR_TEST);\n\ttcic_write_aux_2(iot, ioh, TCIC_AR_TEST, TCIC_TEST_DIAG);\n\tid = tcic_read_aux_2(iot, ioh, TCIC_AR_ILOCK);\n\ttcic_write_aux_2(iot, ioh, TCIC_AR_TEST, otest);\n\tid &= TCIC_ILOCKTEST_ID_MASK;\n\tid >>= TCIC_ILOCKTEST_ID_SHFT;\n\n\t/* clear up IRQs inside tcic. XXX -chb */\n\twhile (bus_space_read_1(iot, ioh, TCIC_R_ICSR))\n\t\tbus_space_write_1(iot, ioh, TCIC_R_ICSR, TCIC_ICSR_JAM);\n\n\treturn id;\n}",
    "includes": [
      "#include <dev/ic/tcic2var.h>",
      "#include <dev/ic/tcic2reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <sys/kthread.h>",
      "#include <sys/malloc.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "char *\ntcic_chipid_to_string(id)\n\tint id;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "TCIC_R_ICSR",
            "TCIC_ICSR_JAM"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "TCIC_R_ICSR"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcic_write_aux_2",
          "args": [
            "iot",
            "ioh",
            "TCIC_AR_TEST",
            "otest"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_write_aux_2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2var.h",
          "lines": "347-357",
          "snippet": "static __inline__ void\ntcic_write_aux_2(iot, ioh, auxreg, val)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tint auxreg, val;\n{\n\tint mode;\n\tmode = bus_space_read_1(iot, ioh, TCIC_R_MODE);\n\tbus_space_write_1(iot, ioh, TCIC_R_MODE, (mode & ~TCIC_AR_MASK)|auxreg);\n\tbus_space_write_2(iot, ioh, TCIC_R_AUX, val);\n}",
          "includes": [
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/device.h>\n\nstatic __inline__ void\ntcic_write_aux_2(iot, ioh, auxreg, val)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tint auxreg, val;\n{\n\tint mode;\n\tmode = bus_space_read_1(iot, ioh, TCIC_R_MODE);\n\tbus_space_write_1(iot, ioh, TCIC_R_MODE, (mode & ~TCIC_AR_MASK)|auxreg);\n\tbus_space_write_2(iot, ioh, TCIC_R_AUX, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tcic_read_aux_2",
          "args": [
            "iot",
            "ioh",
            "TCIC_AR_ILOCK"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_read_aux_2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2var.h",
          "lines": "320-331",
          "snippet": "static __inline__ int\ntcic_read_aux_2(iot, ioh, auxreg)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tint auxreg;\n{\n\tint mode, val;\n\tmode = bus_space_read_1(iot, ioh, TCIC_R_MODE);\n\tbus_space_write_1(iot, ioh, TCIC_R_MODE, (mode & ~TCIC_AR_MASK)|auxreg);\n\tval = bus_space_read_2(iot, ioh, TCIC_R_AUX);\n\treturn val;\n}",
          "includes": [
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/device.h>\n\nstatic __inline__ int\ntcic_read_aux_2(iot, ioh, auxreg)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tint auxreg;\n{\n\tint mode, val;\n\tmode = bus_space_read_1(iot, ioh, TCIC_R_MODE);\n\tbus_space_write_1(iot, ioh, TCIC_R_MODE, (mode & ~TCIC_AR_MASK)|auxreg);\n\tval = bus_space_read_2(iot, ioh, TCIC_R_AUX);\n\treturn val;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nchar *\ntcic_chipid_to_string(id)\n\tint id;\n\nint\ntcic_chipid(iot, ioh)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n{\n\tunsigned id, otest;\n\n\totest = tcic_read_aux_2(iot, ioh, TCIC_AR_TEST);\n\ttcic_write_aux_2(iot, ioh, TCIC_AR_TEST, TCIC_TEST_DIAG);\n\tid = tcic_read_aux_2(iot, ioh, TCIC_AR_ILOCK);\n\ttcic_write_aux_2(iot, ioh, TCIC_AR_TEST, otest);\n\tid &= TCIC_ILOCKTEST_ID_MASK;\n\tid >>= TCIC_ILOCKTEST_ID_SHFT;\n\n\t/* clear up IRQs inside tcic. XXX -chb */\n\twhile (bus_space_read_1(iot, ioh, TCIC_R_ICSR))\n\t\tbus_space_write_1(iot, ioh, TCIC_R_ICSR, TCIC_ICSR_JAM);\n\n\treturn id;\n}"
  },
  {
    "function_name": "tcic_check_reserved_bits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
    "lines": "109-220",
    "snippet": "int\ntcic_check_reserved_bits(iot, ioh)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n{\n\tint val, auxreg;\n\n\tDPRINTF((\"tcic: chkrsvd 1\\n\"));\n\t/* R_ADDR bit 30:28 have a restricted range. */\n\tval = (bus_space_read_2(iot, ioh, TCIC_R_ADDR2) & TCIC_SS_MASK)\n\t    >> TCIC_SS_SHIFT;\n\tif (val > 1)\n\t\treturn 0;\n\n\tDPRINTF((\"tcic: chkrsvd 2\\n\"));\n\t/* R_SCTRL bits 6,2,1 are reserved. */\n\tval = bus_space_read_1(iot, ioh, TCIC_R_SCTRL);\n\tif (val & TCIC_SCTRL_RSVD)\n\t\treturn 0;\n\n\tDPRINTF((\"tcic: chkrsvd 3\\n\"));\n\t/* R_ICSR bit 2 must be same as bit 3. */\n\tval = bus_space_read_1(iot, ioh, TCIC_R_ICSR);\n\tif (((val >> 1) & 1) != ((val >> 2) & 1))\n\t\treturn 0;\n\n\tDPRINTF((\"tcic: chkrsvd 4\\n\"));\n\t/* R_IENA bits 7,2 are reserverd. */\n\tval = bus_space_read_1(iot, ioh, TCIC_R_IENA);\n\tif (val & TCIC_IENA_RSVD)\n\t\treturn 0;\n\n\tDPRINTF((\"tcic: chkrsvd 5\\n\"));\n\t/* Some aux registers have reserved bits. */\n\t/* Which are we looking at? */\n\tauxreg = bus_space_read_1(iot, ioh, TCIC_R_MODE)\n\t    & TCIC_AR_MASK;\n\tval = bus_space_read_2(iot, ioh, TCIC_R_AUX);\n\tDPRINTF((\"tcic: auxreg 0x%02x val 0x%04x\\n\", auxreg, val));\n\tswitch (auxreg) {\n\tcase TCIC_AR_SYSCFG:\n\t\tif (INVALID_AR_SYSCFG(val))\n\t\t\treturn 0;\n\t\tbreak;\n\tcase TCIC_AR_ILOCK:\n\t\tif (INVALID_AR_ILOCK(val))\n\t\t\treturn 0;\n\t\tbreak;\n\tcase TCIC_AR_TEST:\n\t\tif (INVALID_AR_TEST(val))\n\t\t\treturn 0;\n\t\tbreak;\n\t}\n\n\tDPRINTF((\"tcic: chkrsvd 6\\n\"));\n\t/* XXX fails if pcmcia bios is enabled. */\n\t/* Various bits set or not depending if in RESET mode. */\n\tval = bus_space_read_1(iot, ioh, TCIC_R_SCTRL);\n\tif (val & TCIC_SCTRL_RESET) {\n\t\tDPRINTF((\"tcic: chkrsvd 7\\n\"));\n\t\t/* Address bits must be 0 */\n\t\tval = bus_space_read_2(iot, ioh, TCIC_R_ADDR);\n\t\tif (val != 0)\n\t\t\treturn 0;\n\t\tval = bus_space_read_2(iot, ioh, TCIC_R_ADDR2);\n\t\tif (val != 0)\n\t\t\treturn 0;\n\t\tDPRINTF((\"tcic: chkrsvd 8\\n\"));\n\t\t/* EDC bits must be 0 */\n\t\tval = bus_space_read_2(iot, ioh, TCIC_R_EDC);\n\t\tif (val != 0)\n\t\t\treturn 0;\n\t\t/* We're OK, so take it out of reset. XXX -chb */\n\t\tbus_space_write_1(iot, ioh, TCIC_R_SCTRL, 0);\n\t}\n\telse {\t/* not in RESET mode */\n\t\tint omode;\n\t\tint val1, val2;\n\t\tDPRINTF((\"tcic: chkrsvd 9\\n\"));\n\t\t/* Programming timers must have expired. */\n\t\tval = bus_space_read_1(iot, ioh, TCIC_R_SSTAT);\n\t\tif ((val & (TCIC_SSTAT_6US|TCIC_SSTAT_10US|TCIC_SSTAT_PROGTIME))\n\t\t    != (TCIC_SSTAT_6US|TCIC_SSTAT_10US|TCIC_SSTAT_PROGTIME))\n\t\t\treturn 0;\n\t\tDPRINTF((\"tcic: chkrsvd 10\\n\"));\n\t\t/*\n\t\t * EDC bits should change on read from data space\n\t\t * as long as either EDC or the data are nonzero.\n\t\t */\n\t\t if ((bus_space_read_2(iot, ioh, TCIC_R_ADDR2)\n\t\t     & TCIC_ADDR2_INDREG) != 0) {\n\t\t\tval1 = bus_space_read_2(iot, ioh, TCIC_R_EDC);\n\t\t\tval2 = bus_space_read_2(iot, ioh, TCIC_R_DATA);\n\t\t\tif (val1 | val2) {\n\t\t\t\tval1 = bus_space_read_2(iot, ioh, TCIC_R_EDC);\n\t\t\t\tif (val1 == val2)\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tDPRINTF((\"tcic: chkrsvd 11\\n\"));\n\t\t/* XXX what does this check? -chb */\n\t\tomode = bus_space_read_1(iot, ioh, TCIC_R_MODE);\n\t\tval1 = omode ^ TCIC_AR_MASK;\n\t\tbus_space_write_1(iot, ioh, TCIC_R_MODE, val1);\n\t\tval2 = bus_space_read_1(iot, ioh, TCIC_R_MODE);\n\t\tbus_space_write_1(iot, ioh, TCIC_R_MODE, omode);\n\t\tif ( val1 != val2)\n\t\t\treturn 0;\n\t}\n\t/* All tests passed */\n\treturn 1;\n}",
    "includes": [
      "#include <dev/ic/tcic2var.h>",
      "#include <dev/ic/tcic2reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <sys/kthread.h>",
      "#include <sys/malloc.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "TCIC_R_MODE",
            "omode"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "TCIC_R_MODE"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "TCIC_R_MODE",
            "val1"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "TCIC_R_MODE"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"tcic: chkrsvd 11\\n\")"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "iot",
            "ioh",
            "TCIC_R_EDC"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "iot",
            "ioh",
            "TCIC_R_DATA"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "iot",
            "ioh",
            "TCIC_R_EDC"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "iot",
            "ioh",
            "TCIC_R_ADDR2"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"tcic: chkrsvd 10\\n\")"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "TCIC_R_SSTAT"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"tcic: chkrsvd 9\\n\")"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "TCIC_R_SCTRL",
            "0"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "iot",
            "ioh",
            "TCIC_R_EDC"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"tcic: chkrsvd 8\\n\")"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "iot",
            "ioh",
            "TCIC_R_ADDR2"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "iot",
            "ioh",
            "TCIC_R_ADDR"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"tcic: chkrsvd 7\\n\")"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "TCIC_R_SCTRL"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"tcic: chkrsvd 6\\n\")"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INVALID_AR_TEST",
          "args": [
            "val"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INVALID_AR_ILOCK",
          "args": [
            "val"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INVALID_AR_SYSCFG",
          "args": [
            "val"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"tcic: auxreg 0x%02x val 0x%04x\\n\", auxreg, val)"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "iot",
            "ioh",
            "TCIC_R_AUX"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "TCIC_R_MODE"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"tcic: chkrsvd 5\\n\")"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "TCIC_R_IENA"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"tcic: chkrsvd 4\\n\")"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "TCIC_R_ICSR"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"tcic: chkrsvd 3\\n\")"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "TCIC_R_SCTRL"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"tcic: chkrsvd 2\\n\")"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "iot",
            "ioh",
            "TCIC_R_ADDR2"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"tcic: chkrsvd 1\\n\")"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\ntcic_check_reserved_bits(iot, ioh)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n{\n\tint val, auxreg;\n\n\tDPRINTF((\"tcic: chkrsvd 1\\n\"));\n\t/* R_ADDR bit 30:28 have a restricted range. */\n\tval = (bus_space_read_2(iot, ioh, TCIC_R_ADDR2) & TCIC_SS_MASK)\n\t    >> TCIC_SS_SHIFT;\n\tif (val > 1)\n\t\treturn 0;\n\n\tDPRINTF((\"tcic: chkrsvd 2\\n\"));\n\t/* R_SCTRL bits 6,2,1 are reserved. */\n\tval = bus_space_read_1(iot, ioh, TCIC_R_SCTRL);\n\tif (val & TCIC_SCTRL_RSVD)\n\t\treturn 0;\n\n\tDPRINTF((\"tcic: chkrsvd 3\\n\"));\n\t/* R_ICSR bit 2 must be same as bit 3. */\n\tval = bus_space_read_1(iot, ioh, TCIC_R_ICSR);\n\tif (((val >> 1) & 1) != ((val >> 2) & 1))\n\t\treturn 0;\n\n\tDPRINTF((\"tcic: chkrsvd 4\\n\"));\n\t/* R_IENA bits 7,2 are reserverd. */\n\tval = bus_space_read_1(iot, ioh, TCIC_R_IENA);\n\tif (val & TCIC_IENA_RSVD)\n\t\treturn 0;\n\n\tDPRINTF((\"tcic: chkrsvd 5\\n\"));\n\t/* Some aux registers have reserved bits. */\n\t/* Which are we looking at? */\n\tauxreg = bus_space_read_1(iot, ioh, TCIC_R_MODE)\n\t    & TCIC_AR_MASK;\n\tval = bus_space_read_2(iot, ioh, TCIC_R_AUX);\n\tDPRINTF((\"tcic: auxreg 0x%02x val 0x%04x\\n\", auxreg, val));\n\tswitch (auxreg) {\n\tcase TCIC_AR_SYSCFG:\n\t\tif (INVALID_AR_SYSCFG(val))\n\t\t\treturn 0;\n\t\tbreak;\n\tcase TCIC_AR_ILOCK:\n\t\tif (INVALID_AR_ILOCK(val))\n\t\t\treturn 0;\n\t\tbreak;\n\tcase TCIC_AR_TEST:\n\t\tif (INVALID_AR_TEST(val))\n\t\t\treturn 0;\n\t\tbreak;\n\t}\n\n\tDPRINTF((\"tcic: chkrsvd 6\\n\"));\n\t/* XXX fails if pcmcia bios is enabled. */\n\t/* Various bits set or not depending if in RESET mode. */\n\tval = bus_space_read_1(iot, ioh, TCIC_R_SCTRL);\n\tif (val & TCIC_SCTRL_RESET) {\n\t\tDPRINTF((\"tcic: chkrsvd 7\\n\"));\n\t\t/* Address bits must be 0 */\n\t\tval = bus_space_read_2(iot, ioh, TCIC_R_ADDR);\n\t\tif (val != 0)\n\t\t\treturn 0;\n\t\tval = bus_space_read_2(iot, ioh, TCIC_R_ADDR2);\n\t\tif (val != 0)\n\t\t\treturn 0;\n\t\tDPRINTF((\"tcic: chkrsvd 8\\n\"));\n\t\t/* EDC bits must be 0 */\n\t\tval = bus_space_read_2(iot, ioh, TCIC_R_EDC);\n\t\tif (val != 0)\n\t\t\treturn 0;\n\t\t/* We're OK, so take it out of reset. XXX -chb */\n\t\tbus_space_write_1(iot, ioh, TCIC_R_SCTRL, 0);\n\t}\n\telse {\t/* not in RESET mode */\n\t\tint omode;\n\t\tint val1, val2;\n\t\tDPRINTF((\"tcic: chkrsvd 9\\n\"));\n\t\t/* Programming timers must have expired. */\n\t\tval = bus_space_read_1(iot, ioh, TCIC_R_SSTAT);\n\t\tif ((val & (TCIC_SSTAT_6US|TCIC_SSTAT_10US|TCIC_SSTAT_PROGTIME))\n\t\t    != (TCIC_SSTAT_6US|TCIC_SSTAT_10US|TCIC_SSTAT_PROGTIME))\n\t\t\treturn 0;\n\t\tDPRINTF((\"tcic: chkrsvd 10\\n\"));\n\t\t/*\n\t\t * EDC bits should change on read from data space\n\t\t * as long as either EDC or the data are nonzero.\n\t\t */\n\t\t if ((bus_space_read_2(iot, ioh, TCIC_R_ADDR2)\n\t\t     & TCIC_ADDR2_INDREG) != 0) {\n\t\t\tval1 = bus_space_read_2(iot, ioh, TCIC_R_EDC);\n\t\t\tval2 = bus_space_read_2(iot, ioh, TCIC_R_DATA);\n\t\t\tif (val1 | val2) {\n\t\t\t\tval1 = bus_space_read_2(iot, ioh, TCIC_R_EDC);\n\t\t\t\tif (val1 == val2)\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tDPRINTF((\"tcic: chkrsvd 11\\n\"));\n\t\t/* XXX what does this check? -chb */\n\t\tomode = bus_space_read_1(iot, ioh, TCIC_R_MODE);\n\t\tval1 = omode ^ TCIC_AR_MASK;\n\t\tbus_space_write_1(iot, ioh, TCIC_R_MODE, val1);\n\t\tval2 = bus_space_read_1(iot, ioh, TCIC_R_MODE);\n\t\tbus_space_write_1(iot, ioh, TCIC_R_MODE, omode);\n\t\tif ( val1 != val2)\n\t\t\treturn 0;\n\t}\n\t/* All tests passed */\n\treturn 1;\n}"
  }
]