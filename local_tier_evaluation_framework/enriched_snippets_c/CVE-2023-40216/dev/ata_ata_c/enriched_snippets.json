[
  {
    "function_name": "ata_perror",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/ata.c",
    "lines": "177-210",
    "snippet": "void\nata_perror(drvp, errno, buf)\n\tstruct ata_drive_datas *drvp;\n\tint errno;\n\tchar *buf;\n{\n\tstatic char *errstr0_3[] = {\"address mark not found\",\n\t    \"track 0 not found\", \"aborted command\", \"media change requested\",\n\t    \"id not found\", \"media changed\", \"uncorrectable data error\",\n\t    \"bad block detected\"};\n\tstatic char *errstr4_5[] = {\"\",\n\t    \"no media/write protected\", \"aborted command\",\n\t    \"media change requested\", \"id not found\", \"media changed\",\n\t    \"uncorrectable data error\", \"interface CRC error\"};\n\tchar **errstr;\n\tint i;\n\tchar *sep = \"\";\n\n\tif (drvp->ata_vers >= 4)\n\t\terrstr = errstr4_5;\n\telse\n\t\terrstr = errstr0_3;\n\n\tif (errno == 0) {\n\t\tsprintf(buf, \"error not notified\");\n\t}\n\n\tfor (i = 0; i < 8; i++) {\n\t\tif (errno & (1 << i)) {\n\t\t\tbuf += sprintf(buf, \"%s %s\", sep, errstr[i]);\n\t\t\tsep = \",\";\n\t\t}\n\t}\n}",
    "includes": [
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <sys/syslog.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%s %s\"",
            "sep",
            "errstr[i]"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"error not notified\""
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <dev/ic/wdcreg.h>\n#include <sys/syslog.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nata_perror(drvp, errno, buf)\n\tstruct ata_drive_datas *drvp;\n\tint errno;\n\tchar *buf;\n{\n\tstatic char *errstr0_3[] = {\"address mark not found\",\n\t    \"track 0 not found\", \"aborted command\", \"media change requested\",\n\t    \"id not found\", \"media changed\", \"uncorrectable data error\",\n\t    \"bad block detected\"};\n\tstatic char *errstr4_5[] = {\"\",\n\t    \"no media/write protected\", \"aborted command\",\n\t    \"media change requested\", \"id not found\", \"media changed\",\n\t    \"uncorrectable data error\", \"interface CRC error\"};\n\tchar **errstr;\n\tint i;\n\tchar *sep = \"\";\n\n\tif (drvp->ata_vers >= 4)\n\t\terrstr = errstr4_5;\n\telse\n\t\terrstr = errstr0_3;\n\n\tif (errno == 0) {\n\t\tsprintf(buf, \"error not notified\");\n\t}\n\n\tfor (i = 0; i < 8; i++) {\n\t\tif (errno & (1 << i)) {\n\t\t\tbuf += sprintf(buf, \"%s %s\", sep, errstr[i]);\n\t\t\tsep = \",\";\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "ata_set_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/ata.c",
    "lines": "151-175",
    "snippet": "int\nata_set_mode(drvp, mode, flags)\n\tstruct ata_drive_datas *drvp;\n\tu_int8_t mode;\n\tu_int8_t flags;\n{\n\tstruct wdc_command wdc_c;\n\n\tWDCDEBUG_PRINT((\"ata_set_mode=0x%x\\n\", mode), DEBUG_FUNCS);\n\tbzero(&wdc_c, sizeof(struct wdc_command));\n\n\twdc_c.r_command = SET_FEATURES;\n\twdc_c.r_st_bmask = 0;\n\twdc_c.r_st_pmask = 0;\n\twdc_c.r_precomp = WDSF_SET_MODE;\n\twdc_c.r_count = mode;\n\twdc_c.flags = AT_READ | flags;\n\twdc_c.timeout = 1000; /* 1s */\n\tif (wdc_exec_command(drvp, &wdc_c) != WDC_COMPLETE)\n\t\treturn CMD_AGAIN;\n\tif (wdc_c.flags & (AT_ERROR | AT_TIMEOU | AT_DF)) {\n\t\treturn CMD_ERR;\n\t}\n\treturn CMD_OK;\n}",
    "includes": [
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <sys/syslog.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define DEBUG_FUNCS  0x08"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wdc_exec_command",
          "args": [
            "drvp",
            "&wdc_c"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_exec_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "1306-1369",
          "snippet": "int\nwdc_exec_command(drvp, wdc_c)\n\tstruct ata_drive_datas *drvp;\n\tstruct wdc_command *wdc_c;\n{\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\tstruct wdc_xfer *xfer;\n\tint s, ret;\n\n\tWDCDEBUG_PRINT((\"wdc_exec_command %s:%d:%d\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, drvp->drive),\n\t    DEBUG_FUNCS);\n\n\t/* set up an xfer and queue. Wait for completion */\n\txfer = wdc_get_xfer(wdc_c->flags & AT_WAIT ? WDC_CANSLEEP :\n\t    WDC_NOSLEEP);\n\tif (xfer == NULL) {\n\t\treturn WDC_TRY_AGAIN;\n\t }\n\n\tif (wdc_c->flags & AT_POLL)\n\t\txfer->c_flags |= C_POLL;\n\txfer->drive = drvp->drive;\n\txfer->databuf = wdc_c->data;\n\txfer->c_bcount = wdc_c->bcount;\n\txfer->cmd = wdc_c;\n\txfer->c_start = __wdccommand_start;\n\txfer->c_intr = __wdccommand_intr;\n\txfer->c_kill_xfer = __wdccommand_done;\n\n\ts = splbio();\n\twdc_exec_xfer(chp, xfer);\n#ifdef DIAGNOSTIC\n\tif ((wdc_c->flags & AT_POLL) != 0 &&\n\t    (wdc_c->flags & AT_DONE) == 0)\n\t\tpanic(\"wdc_exec_command: polled command not done\\n\");\n#endif\n\tif (wdc_c->flags & AT_DONE) {\n\t\tret = WDC_COMPLETE;\n\t} else {\n\t\tif (wdc_c->flags & AT_WAIT) {\n\t\t\tWDCDEBUG_PRINT((\"wdc_exec_command sleeping\"),\n\t\t\t\t       DEBUG_FUNCS);\n\n\t\t\twhile (!(wdc_c->flags & AT_DONE)) {\n\t\t\t\tint error;\n\t\t\t\terror = tsleep(wdc_c, PRIBIO, \"wdccmd\", 0);\n\n\t\t\t\tif (error) {\n\t\t\t\t\tprintf (\"tsleep error: %d\\n\", error);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tWDCDEBUG_PRINT((\"wdc_exec_command waking\"),\n\t\t\t\t       DEBUG_FUNCS);\n\n\t\t\tret = WDC_COMPLETE;\n\t\t} else {\n\t\t\tret = WDC_QUEUED;\n\t\t}\n\t}\n\tsplx(s);\n\treturn ret;\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_FUNCS  0x08"
          ],
          "globals_used": [
            "void  __wdccommand_done",
            "void  __wdccommand_start",
            "int   __wdccommand_intr",
            "struct wdc_xfer *\nwdc_get_xfer(flags)\n\tint flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_FUNCS  0x08\n\nvoid  __wdccommand_done;\nvoid  __wdccommand_start;\nint   __wdccommand_intr;\nstruct wdc_xfer *\nwdc_get_xfer(flags)\n\tint flags;\n\nint\nwdc_exec_command(drvp, wdc_c)\n\tstruct ata_drive_datas *drvp;\n\tstruct wdc_command *wdc_c;\n{\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\tstruct wdc_xfer *xfer;\n\tint s, ret;\n\n\tWDCDEBUG_PRINT((\"wdc_exec_command %s:%d:%d\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, drvp->drive),\n\t    DEBUG_FUNCS);\n\n\t/* set up an xfer and queue. Wait for completion */\n\txfer = wdc_get_xfer(wdc_c->flags & AT_WAIT ? WDC_CANSLEEP :\n\t    WDC_NOSLEEP);\n\tif (xfer == NULL) {\n\t\treturn WDC_TRY_AGAIN;\n\t }\n\n\tif (wdc_c->flags & AT_POLL)\n\t\txfer->c_flags |= C_POLL;\n\txfer->drive = drvp->drive;\n\txfer->databuf = wdc_c->data;\n\txfer->c_bcount = wdc_c->bcount;\n\txfer->cmd = wdc_c;\n\txfer->c_start = __wdccommand_start;\n\txfer->c_intr = __wdccommand_intr;\n\txfer->c_kill_xfer = __wdccommand_done;\n\n\ts = splbio();\n\twdc_exec_xfer(chp, xfer);\n#ifdef DIAGNOSTIC\n\tif ((wdc_c->flags & AT_POLL) != 0 &&\n\t    (wdc_c->flags & AT_DONE) == 0)\n\t\tpanic(\"wdc_exec_command: polled command not done\\n\");\n#endif\n\tif (wdc_c->flags & AT_DONE) {\n\t\tret = WDC_COMPLETE;\n\t} else {\n\t\tif (wdc_c->flags & AT_WAIT) {\n\t\t\tWDCDEBUG_PRINT((\"wdc_exec_command sleeping\"),\n\t\t\t\t       DEBUG_FUNCS);\n\n\t\t\twhile (!(wdc_c->flags & AT_DONE)) {\n\t\t\t\tint error;\n\t\t\t\terror = tsleep(wdc_c, PRIBIO, \"wdccmd\", 0);\n\n\t\t\t\tif (error) {\n\t\t\t\t\tprintf (\"tsleep error: %d\\n\", error);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tWDCDEBUG_PRINT((\"wdc_exec_command waking\"),\n\t\t\t\t       DEBUG_FUNCS);\n\n\t\t\tret = WDC_COMPLETE;\n\t\t} else {\n\t\t\tret = WDC_QUEUED;\n\t\t}\n\t}\n\tsplx(s);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "&wdc_c",
            "sizeof(struct wdc_command)"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"ata_set_mode=0x%x\\n\", mode)",
            "DEBUG_FUNCS"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <dev/ic/wdcreg.h>\n#include <sys/syslog.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_FUNCS  0x08\n\nint\nata_set_mode(drvp, mode, flags)\n\tstruct ata_drive_datas *drvp;\n\tu_int8_t mode;\n\tu_int8_t flags;\n{\n\tstruct wdc_command wdc_c;\n\n\tWDCDEBUG_PRINT((\"ata_set_mode=0x%x\\n\", mode), DEBUG_FUNCS);\n\tbzero(&wdc_c, sizeof(struct wdc_command));\n\n\twdc_c.r_command = SET_FEATURES;\n\twdc_c.r_st_bmask = 0;\n\twdc_c.r_st_pmask = 0;\n\twdc_c.r_precomp = WDSF_SET_MODE;\n\twdc_c.r_count = mode;\n\twdc_c.flags = AT_READ | flags;\n\twdc_c.timeout = 1000; /* 1s */\n\tif (wdc_exec_command(drvp, &wdc_c) != WDC_COMPLETE)\n\t\treturn CMD_AGAIN;\n\tif (wdc_c.flags & (AT_ERROR | AT_TIMEOU | AT_DF)) {\n\t\treturn CMD_ERR;\n\t}\n\treturn CMD_OK;\n}"
  },
  {
    "function_name": "ata_get_params",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/ata.c",
    "lines": "59-149",
    "snippet": "int\nata_get_params(drvp, flags, prms)\n\tstruct ata_drive_datas *drvp;\n\tu_int8_t flags;\n\tstruct ataparams *prms;\n{\n\tchar tb[ATAPARAMS_SIZE];\n\tstruct wdc_command wdc_c;\n\n\tint i;\n\tu_int16_t *p;\n\n\tWDCDEBUG_PRINT((\"ata_get_parms\\n\"), DEBUG_FUNCS);\n\n\tbzero(tb, sizeof(tb));\n\tbzero(prms, sizeof(struct ataparams));\n\tbzero(&wdc_c, sizeof(struct wdc_command));\n\n\tif (drvp->drive_flags & DRIVE_ATA) {\n\t\twdc_c.r_command = WDCC_IDENTIFY;\n\t\twdc_c.r_st_bmask = WDCS_DRDY;\n\t\twdc_c.r_st_pmask = WDCS_DRQ;\n\t\twdc_c.timeout = 1000; /* 1s */\n\t} else if (drvp->drive_flags & DRIVE_ATAPI) {\n\t\twdc_c.r_command = ATAPI_IDENTIFY_DEVICE;\n\t\twdc_c.r_st_bmask = 0;\n\t\twdc_c.r_st_pmask = WDCS_DRQ;\n\t\twdc_c.timeout = 10000; /* 10s */\n\t} else {\n\t\treturn CMD_ERR;\n\t}\n\twdc_c.flags = AT_READ | flags;\n\twdc_c.data = tb;\n\twdc_c.bcount = ATAPARAMS_SIZE;\n\n\t{\n\t\tint ret;\n\t\tif ((ret = wdc_exec_command(drvp, &wdc_c)) != WDC_COMPLETE) {\n\t\t\tprintf (\"WDC_EXEC_COMMAND: %d\\n\");\n\t\t\treturn CMD_AGAIN;\n\t\t}\n\t}\n\n\tif (wdc_c.flags & (AT_ERROR | AT_TIMEOU | AT_DF)) {\n\t\treturn CMD_ERR;\n\t} else {\n#if BYTE_ORDER == BIG_ENDIAN\n\t\t/* All the fields in the params structure are 16-bit\n\t\t   integers except for the ID strings which are char\n\t\t   strings.  The 16-bit integers are currently in\n\t\t   memory in little-endian, regardless of architecture.\n\t\t   So, they need to be swapped on big-endian architectures\n\t\t   before they are accessed through the ataparams structure.\n\n\t\t   The swaps below avoid touching the char strings.\n\t\t*/\n\t\t  \n\t\tswap16_multi((u_int16_t *)tb, 10);\n\t\tswap16_multi((u_int16_t *)tb + 20, 3);\n\t\tswap16_multi((u_int16_t *)tb + 47, ATAPARAMS_SIZE / 2 - 47);\n#endif\n\t\t/* Read in parameter block. */\n\t\tbcopy(tb, prms, sizeof(struct ataparams));\n\n\t\t/*\n\t\t * Shuffle string byte order.\n\t\t * ATAPI Mitsumi and NEC drives don't need this.\n\t\t */\n\t\tif ((prms->atap_config & WDC_CFG_ATAPI_MASK) ==\n\t\t    WDC_CFG_ATAPI &&\n\t\t    ((prms->atap_model[0] == 'N' &&\n\t\t\tprms->atap_model[1] == 'E') ||\n\t\t     (prms->atap_model[0] == 'F' &&\n\t\t\t prms->atap_model[1] == 'X')))\n\t\t\treturn 0;\n\t\tfor (i = 0; i < sizeof(prms->atap_model); i += 2) {\n\t\t\tp = (u_short *)(prms->atap_model + i);\n\t\t\t*p = swap16(*p);\n\t\t}\n\t\tfor (i = 0; i < sizeof(prms->atap_serial); i += 2) {\n\t\t\tp = (u_short *)(prms->atap_serial + i);\n\t\t\t*p = swap16(*p);\n\t\t}\n\t\tfor (i = 0; i < sizeof(prms->atap_revision); i += 2) {\n\t\t\tp = (u_short *)(prms->atap_revision + i);\n\t\t\t*p = swap16(*p);\n\t\t}\n\n\t\treturn CMD_OK;\n\t}\n}",
    "includes": [
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <sys/syslog.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define ATAPARAMS_SIZE 512",
      "#define DEBUG_FUNCS  0x08"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "swap16",
          "args": [
            "*p"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap16",
          "args": [
            "*p"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap16",
          "args": [
            "*p"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "tb",
            "prms",
            "sizeof(struct ataparams)"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "swap16_multi",
          "args": [
            "(u_int16_t *)tb + 47",
            "ATAPARAMS_SIZE / 2 - 47"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap16_multi",
          "args": [
            "(u_int16_t *)tb + 20",
            "3"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap16_multi",
          "args": [
            "(u_int16_t *)tb",
            "10"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"WDC_EXEC_COMMAND: %d\\n\""
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wdc_exec_command",
          "args": [
            "drvp",
            "&wdc_c"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_exec_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "1306-1369",
          "snippet": "int\nwdc_exec_command(drvp, wdc_c)\n\tstruct ata_drive_datas *drvp;\n\tstruct wdc_command *wdc_c;\n{\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\tstruct wdc_xfer *xfer;\n\tint s, ret;\n\n\tWDCDEBUG_PRINT((\"wdc_exec_command %s:%d:%d\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, drvp->drive),\n\t    DEBUG_FUNCS);\n\n\t/* set up an xfer and queue. Wait for completion */\n\txfer = wdc_get_xfer(wdc_c->flags & AT_WAIT ? WDC_CANSLEEP :\n\t    WDC_NOSLEEP);\n\tif (xfer == NULL) {\n\t\treturn WDC_TRY_AGAIN;\n\t }\n\n\tif (wdc_c->flags & AT_POLL)\n\t\txfer->c_flags |= C_POLL;\n\txfer->drive = drvp->drive;\n\txfer->databuf = wdc_c->data;\n\txfer->c_bcount = wdc_c->bcount;\n\txfer->cmd = wdc_c;\n\txfer->c_start = __wdccommand_start;\n\txfer->c_intr = __wdccommand_intr;\n\txfer->c_kill_xfer = __wdccommand_done;\n\n\ts = splbio();\n\twdc_exec_xfer(chp, xfer);\n#ifdef DIAGNOSTIC\n\tif ((wdc_c->flags & AT_POLL) != 0 &&\n\t    (wdc_c->flags & AT_DONE) == 0)\n\t\tpanic(\"wdc_exec_command: polled command not done\\n\");\n#endif\n\tif (wdc_c->flags & AT_DONE) {\n\t\tret = WDC_COMPLETE;\n\t} else {\n\t\tif (wdc_c->flags & AT_WAIT) {\n\t\t\tWDCDEBUG_PRINT((\"wdc_exec_command sleeping\"),\n\t\t\t\t       DEBUG_FUNCS);\n\n\t\t\twhile (!(wdc_c->flags & AT_DONE)) {\n\t\t\t\tint error;\n\t\t\t\terror = tsleep(wdc_c, PRIBIO, \"wdccmd\", 0);\n\n\t\t\t\tif (error) {\n\t\t\t\t\tprintf (\"tsleep error: %d\\n\", error);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tWDCDEBUG_PRINT((\"wdc_exec_command waking\"),\n\t\t\t\t       DEBUG_FUNCS);\n\n\t\t\tret = WDC_COMPLETE;\n\t\t} else {\n\t\t\tret = WDC_QUEUED;\n\t\t}\n\t}\n\tsplx(s);\n\treturn ret;\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_FUNCS  0x08"
          ],
          "globals_used": [
            "void  __wdccommand_done",
            "void  __wdccommand_start",
            "int   __wdccommand_intr",
            "struct wdc_xfer *\nwdc_get_xfer(flags)\n\tint flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_FUNCS  0x08\n\nvoid  __wdccommand_done;\nvoid  __wdccommand_start;\nint   __wdccommand_intr;\nstruct wdc_xfer *\nwdc_get_xfer(flags)\n\tint flags;\n\nint\nwdc_exec_command(drvp, wdc_c)\n\tstruct ata_drive_datas *drvp;\n\tstruct wdc_command *wdc_c;\n{\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\tstruct wdc_xfer *xfer;\n\tint s, ret;\n\n\tWDCDEBUG_PRINT((\"wdc_exec_command %s:%d:%d\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, drvp->drive),\n\t    DEBUG_FUNCS);\n\n\t/* set up an xfer and queue. Wait for completion */\n\txfer = wdc_get_xfer(wdc_c->flags & AT_WAIT ? WDC_CANSLEEP :\n\t    WDC_NOSLEEP);\n\tif (xfer == NULL) {\n\t\treturn WDC_TRY_AGAIN;\n\t }\n\n\tif (wdc_c->flags & AT_POLL)\n\t\txfer->c_flags |= C_POLL;\n\txfer->drive = drvp->drive;\n\txfer->databuf = wdc_c->data;\n\txfer->c_bcount = wdc_c->bcount;\n\txfer->cmd = wdc_c;\n\txfer->c_start = __wdccommand_start;\n\txfer->c_intr = __wdccommand_intr;\n\txfer->c_kill_xfer = __wdccommand_done;\n\n\ts = splbio();\n\twdc_exec_xfer(chp, xfer);\n#ifdef DIAGNOSTIC\n\tif ((wdc_c->flags & AT_POLL) != 0 &&\n\t    (wdc_c->flags & AT_DONE) == 0)\n\t\tpanic(\"wdc_exec_command: polled command not done\\n\");\n#endif\n\tif (wdc_c->flags & AT_DONE) {\n\t\tret = WDC_COMPLETE;\n\t} else {\n\t\tif (wdc_c->flags & AT_WAIT) {\n\t\t\tWDCDEBUG_PRINT((\"wdc_exec_command sleeping\"),\n\t\t\t\t       DEBUG_FUNCS);\n\n\t\t\twhile (!(wdc_c->flags & AT_DONE)) {\n\t\t\t\tint error;\n\t\t\t\terror = tsleep(wdc_c, PRIBIO, \"wdccmd\", 0);\n\n\t\t\t\tif (error) {\n\t\t\t\t\tprintf (\"tsleep error: %d\\n\", error);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tWDCDEBUG_PRINT((\"wdc_exec_command waking\"),\n\t\t\t\t       DEBUG_FUNCS);\n\n\t\t\tret = WDC_COMPLETE;\n\t\t} else {\n\t\t\tret = WDC_QUEUED;\n\t\t}\n\t}\n\tsplx(s);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "&wdc_c",
            "sizeof(struct wdc_command)"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "prms",
            "sizeof(struct ataparams)"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "tb",
            "sizeof(tb)"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"ata_get_parms\\n\")",
            "DEBUG_FUNCS"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <dev/ic/wdcreg.h>\n#include <sys/syslog.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define ATAPARAMS_SIZE 512\n#define DEBUG_FUNCS  0x08\n\nint\nata_get_params(drvp, flags, prms)\n\tstruct ata_drive_datas *drvp;\n\tu_int8_t flags;\n\tstruct ataparams *prms;\n{\n\tchar tb[ATAPARAMS_SIZE];\n\tstruct wdc_command wdc_c;\n\n\tint i;\n\tu_int16_t *p;\n\n\tWDCDEBUG_PRINT((\"ata_get_parms\\n\"), DEBUG_FUNCS);\n\n\tbzero(tb, sizeof(tb));\n\tbzero(prms, sizeof(struct ataparams));\n\tbzero(&wdc_c, sizeof(struct wdc_command));\n\n\tif (drvp->drive_flags & DRIVE_ATA) {\n\t\twdc_c.r_command = WDCC_IDENTIFY;\n\t\twdc_c.r_st_bmask = WDCS_DRDY;\n\t\twdc_c.r_st_pmask = WDCS_DRQ;\n\t\twdc_c.timeout = 1000; /* 1s */\n\t} else if (drvp->drive_flags & DRIVE_ATAPI) {\n\t\twdc_c.r_command = ATAPI_IDENTIFY_DEVICE;\n\t\twdc_c.r_st_bmask = 0;\n\t\twdc_c.r_st_pmask = WDCS_DRQ;\n\t\twdc_c.timeout = 10000; /* 10s */\n\t} else {\n\t\treturn CMD_ERR;\n\t}\n\twdc_c.flags = AT_READ | flags;\n\twdc_c.data = tb;\n\twdc_c.bcount = ATAPARAMS_SIZE;\n\n\t{\n\t\tint ret;\n\t\tif ((ret = wdc_exec_command(drvp, &wdc_c)) != WDC_COMPLETE) {\n\t\t\tprintf (\"WDC_EXEC_COMMAND: %d\\n\");\n\t\t\treturn CMD_AGAIN;\n\t\t}\n\t}\n\n\tif (wdc_c.flags & (AT_ERROR | AT_TIMEOU | AT_DF)) {\n\t\treturn CMD_ERR;\n\t} else {\n#if BYTE_ORDER == BIG_ENDIAN\n\t\t/* All the fields in the params structure are 16-bit\n\t\t   integers except for the ID strings which are char\n\t\t   strings.  The 16-bit integers are currently in\n\t\t   memory in little-endian, regardless of architecture.\n\t\t   So, they need to be swapped on big-endian architectures\n\t\t   before they are accessed through the ataparams structure.\n\n\t\t   The swaps below avoid touching the char strings.\n\t\t*/\n\t\t  \n\t\tswap16_multi((u_int16_t *)tb, 10);\n\t\tswap16_multi((u_int16_t *)tb + 20, 3);\n\t\tswap16_multi((u_int16_t *)tb + 47, ATAPARAMS_SIZE / 2 - 47);\n#endif\n\t\t/* Read in parameter block. */\n\t\tbcopy(tb, prms, sizeof(struct ataparams));\n\n\t\t/*\n\t\t * Shuffle string byte order.\n\t\t * ATAPI Mitsumi and NEC drives don't need this.\n\t\t */\n\t\tif ((prms->atap_config & WDC_CFG_ATAPI_MASK) ==\n\t\t    WDC_CFG_ATAPI &&\n\t\t    ((prms->atap_model[0] == 'N' &&\n\t\t\tprms->atap_model[1] == 'E') ||\n\t\t     (prms->atap_model[0] == 'F' &&\n\t\t\t prms->atap_model[1] == 'X')))\n\t\t\treturn 0;\n\t\tfor (i = 0; i < sizeof(prms->atap_model); i += 2) {\n\t\t\tp = (u_short *)(prms->atap_model + i);\n\t\t\t*p = swap16(*p);\n\t\t}\n\t\tfor (i = 0; i < sizeof(prms->atap_serial); i += 2) {\n\t\t\tp = (u_short *)(prms->atap_serial + i);\n\t\t\t*p = swap16(*p);\n\t\t}\n\t\tfor (i = 0; i < sizeof(prms->atap_revision); i += 2) {\n\t\t\tp = (u_short *)(prms->atap_revision + i);\n\t\t\t*p = swap16(*p);\n\t\t}\n\n\t\treturn CMD_OK;\n\t}\n}"
  }
]