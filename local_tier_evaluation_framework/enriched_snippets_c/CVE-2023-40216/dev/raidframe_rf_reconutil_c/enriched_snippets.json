[
  {
    "function_name": "rf_CheckFloatingRbufCount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconutil.c",
    "lines": "272-336",
    "snippet": "void \nrf_CheckFloatingRbufCount(raidPtr, dolock)\n\tRF_Raid_t *raidPtr;\n\tint     dolock;\n{\n\tRF_ReconParityStripeStatus_t *p;\n\tRF_PSStatusHeader_t *pssTable;\n\tRF_ReconBuffer_t *rbuf;\n\tint     i, j, sum = 0;\n\tRF_RowCol_t frow = 0;\n\n\tfor (i = 0; i < raidPtr->numRow; i++)\n\t\tif (raidPtr->reconControl[i]) {\n\t\t\tfrow = i;\n\t\t\tbreak;\n\t\t}\n\tRF_ASSERT(frow >= 0);\n\n\tif (dolock)\n\t\tRF_LOCK_MUTEX(raidPtr->reconControl[frow]->rb_mutex);\n\tpssTable = raidPtr->reconControl[frow]->pssTable;\n\n\tfor (i = 0; i < raidPtr->pssTableSize; i++) {\n\t\tRF_LOCK_MUTEX(pssTable[i].mutex);\n\t\tfor (p = pssTable[i].chain; p; p = p->next) {\n\t\t\trbuf = (RF_ReconBuffer_t *) p->rbuf;\n\t\t\tif (rbuf && rbuf->type == RF_RBUF_TYPE_FLOATING)\n\t\t\t\tsum++;\n\n\t\t\trbuf = (RF_ReconBuffer_t *) p->writeRbuf;\n\t\t\tif (rbuf && rbuf->type == RF_RBUF_TYPE_FLOATING)\n\t\t\t\tsum++;\n\n\t\t\tfor (j = 0; j < p->xorBufCount; j++) {\n\t\t\t\trbuf = (RF_ReconBuffer_t *) p->rbufsForXor[j];\n\t\t\t\tRF_ASSERT(rbuf);\n\t\t\t\tif (rbuf->type == RF_RBUF_TYPE_FLOATING)\n\t\t\t\t\tsum++;\n\t\t\t}\n\t\t}\n\t\tRF_UNLOCK_MUTEX(pssTable[i].mutex);\n\t}\n\n\tfor (rbuf = raidPtr->reconControl[frow]->floatingRbufs; rbuf; rbuf = rbuf->next) {\n\t\tif (rbuf->type == RF_RBUF_TYPE_FLOATING)\n\t\t\tsum++;\n\t}\n\tfor (rbuf = raidPtr->reconControl[frow]->committedRbufs; rbuf; rbuf = rbuf->next) {\n\t\tif (rbuf->type == RF_RBUF_TYPE_FLOATING)\n\t\t\tsum++;\n\t}\n\tfor (rbuf = raidPtr->reconControl[frow]->fullBufferList; rbuf; rbuf = rbuf->next) {\n\t\tif (rbuf->type == RF_RBUF_TYPE_FLOATING)\n\t\t\tsum++;\n\t}\n\tfor (rbuf = raidPtr->reconControl[frow]->priorityList; rbuf; rbuf = rbuf->next) {\n\t\tif (rbuf->type == RF_RBUF_TYPE_FLOATING)\n\t\t\tsum++;\n\t}\n\n\tRF_ASSERT(sum == raidPtr->numFloatingReconBufs);\n\n\tif (dolock)\n\t\tRF_UNLOCK_MUTEX(raidPtr->reconControl[frow]->rb_mutex);\n}",
    "includes": [
      "#include \"rf_chaindecluster.h\"",
      "#include \"rf_interdecluster.h\"",
      "#include \"rf_raid5_rotatedspare.h\"",
      "#include \"rf_decluster.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_reconbuffer.h\"",
      "#include \"rf_reconutil.h\"",
      "#include \"rf_desc.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "RF_RowCol_t frow;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_UNLOCK_MUTEX",
          "args": [
            "raidPtr->reconControl[frow]->rb_mutex"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "sum == raidPtr->numFloatingReconBufs"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_UNLOCK_MUTEX",
          "args": [
            "pssTable[i].mutex"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "rbuf"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_LOCK_MUTEX",
          "args": [
            "pssTable[i].mutex"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_LOCK_MUTEX",
          "args": [
            "raidPtr->reconControl[frow]->rb_mutex"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "frow >= 0"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_chaindecluster.h\"\n#include \"rf_interdecluster.h\"\n#include \"rf_raid5_rotatedspare.h\"\n#include \"rf_decluster.h\"\n#include \"rf_general.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_reconutil.h\"\n#include \"rf_desc.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nRF_RowCol_t frow;\n\nvoid \nrf_CheckFloatingRbufCount(raidPtr, dolock)\n\tRF_Raid_t *raidPtr;\n\tint     dolock;\n{\n\tRF_ReconParityStripeStatus_t *p;\n\tRF_PSStatusHeader_t *pssTable;\n\tRF_ReconBuffer_t *rbuf;\n\tint     i, j, sum = 0;\n\tRF_RowCol_t frow = 0;\n\n\tfor (i = 0; i < raidPtr->numRow; i++)\n\t\tif (raidPtr->reconControl[i]) {\n\t\t\tfrow = i;\n\t\t\tbreak;\n\t\t}\n\tRF_ASSERT(frow >= 0);\n\n\tif (dolock)\n\t\tRF_LOCK_MUTEX(raidPtr->reconControl[frow]->rb_mutex);\n\tpssTable = raidPtr->reconControl[frow]->pssTable;\n\n\tfor (i = 0; i < raidPtr->pssTableSize; i++) {\n\t\tRF_LOCK_MUTEX(pssTable[i].mutex);\n\t\tfor (p = pssTable[i].chain; p; p = p->next) {\n\t\t\trbuf = (RF_ReconBuffer_t *) p->rbuf;\n\t\t\tif (rbuf && rbuf->type == RF_RBUF_TYPE_FLOATING)\n\t\t\t\tsum++;\n\n\t\t\trbuf = (RF_ReconBuffer_t *) p->writeRbuf;\n\t\t\tif (rbuf && rbuf->type == RF_RBUF_TYPE_FLOATING)\n\t\t\t\tsum++;\n\n\t\t\tfor (j = 0; j < p->xorBufCount; j++) {\n\t\t\t\trbuf = (RF_ReconBuffer_t *) p->rbufsForXor[j];\n\t\t\t\tRF_ASSERT(rbuf);\n\t\t\t\tif (rbuf->type == RF_RBUF_TYPE_FLOATING)\n\t\t\t\t\tsum++;\n\t\t\t}\n\t\t}\n\t\tRF_UNLOCK_MUTEX(pssTable[i].mutex);\n\t}\n\n\tfor (rbuf = raidPtr->reconControl[frow]->floatingRbufs; rbuf; rbuf = rbuf->next) {\n\t\tif (rbuf->type == RF_RBUF_TYPE_FLOATING)\n\t\t\tsum++;\n\t}\n\tfor (rbuf = raidPtr->reconControl[frow]->committedRbufs; rbuf; rbuf = rbuf->next) {\n\t\tif (rbuf->type == RF_RBUF_TYPE_FLOATING)\n\t\t\tsum++;\n\t}\n\tfor (rbuf = raidPtr->reconControl[frow]->fullBufferList; rbuf; rbuf = rbuf->next) {\n\t\tif (rbuf->type == RF_RBUF_TYPE_FLOATING)\n\t\t\tsum++;\n\t}\n\tfor (rbuf = raidPtr->reconControl[frow]->priorityList; rbuf; rbuf = rbuf->next) {\n\t\tif (rbuf->type == RF_RBUF_TYPE_FLOATING)\n\t\t\tsum++;\n\t}\n\n\tRF_ASSERT(sum == raidPtr->numFloatingReconBufs);\n\n\tif (dolock)\n\t\tRF_UNLOCK_MUTEX(raidPtr->reconControl[frow]->rb_mutex);\n}"
  },
  {
    "function_name": "rf_FreeReconBuffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconutil.c",
    "lines": "256-266",
    "snippet": "void \nrf_FreeReconBuffer(rbuf)\n\tRF_ReconBuffer_t *rbuf;\n{\n\tRF_Raid_t *raidPtr = rbuf->raidPtr;\n\tu_int   recon_buffer_size = rf_RaidAddressToByte(raidPtr, raidPtr->Layout.SUsPerRU * raidPtr->Layout.sectorsPerStripeUnit);\n\n\tRF_Free(rbuf->arrived, raidPtr->numCol * sizeof(char));\n\tRF_Free(rbuf->buffer, recon_buffer_size);\n\tRF_Free(rbuf, sizeof(*rbuf));\n}",
    "includes": [
      "#include \"rf_chaindecluster.h\"",
      "#include \"rf_interdecluster.h\"",
      "#include \"rf_raid5_rotatedspare.h\"",
      "#include \"rf_decluster.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_reconbuffer.h\"",
      "#include \"rf_reconutil.h\"",
      "#include \"rf_desc.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "rbuf",
            "sizeof(*rbuf)"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "rbuf->buffer",
            "recon_buffer_size"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "rbuf->arrived",
            "raidPtr->numCol * sizeof(char)"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToByte",
          "args": [
            "raidPtr",
            "raidPtr->Layout.SUsPerRU * raidPtr->Layout.sectorsPerStripeUnit"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_chaindecluster.h\"\n#include \"rf_interdecluster.h\"\n#include \"rf_raid5_rotatedspare.h\"\n#include \"rf_decluster.h\"\n#include \"rf_general.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_reconutil.h\"\n#include \"rf_desc.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid \nrf_FreeReconBuffer(rbuf)\n\tRF_ReconBuffer_t *rbuf;\n{\n\tRF_Raid_t *raidPtr = rbuf->raidPtr;\n\tu_int   recon_buffer_size = rf_RaidAddressToByte(raidPtr, raidPtr->Layout.SUsPerRU * raidPtr->Layout.sectorsPerStripeUnit);\n\n\tRF_Free(rbuf->arrived, raidPtr->numCol * sizeof(char));\n\tRF_Free(rbuf->buffer, recon_buffer_size);\n\tRF_Free(rbuf, sizeof(*rbuf));\n}"
  },
  {
    "function_name": "rf_MakeReconBuffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconutil.c",
    "lines": "230-252",
    "snippet": "RF_ReconBuffer_t *\nrf_MakeReconBuffer(\n    RF_Raid_t * raidPtr,\n    RF_RowCol_t row,\n    RF_RowCol_t col,\n    RF_RbufType_t type)\n{\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\tRF_ReconBuffer_t *t;\n\tu_int   recon_buffer_size = rf_RaidAddressToByte(raidPtr, layoutPtr->SUsPerRU * layoutPtr->sectorsPerStripeUnit);\n\n\tRF_Malloc(t, sizeof(RF_ReconBuffer_t), (RF_ReconBuffer_t *));\n\tRF_Malloc(t->buffer, recon_buffer_size, (caddr_t));\n\tRF_Malloc(t->arrived, raidPtr->numCol * sizeof(char), (char *));\n\tt->raidPtr = raidPtr;\n\tt->row = row;\n\tt->col = col;\n\tt->priority = RF_IO_RECON_PRIORITY;\n\tt->type = type;\n\tt->pssPtr = NULL;\n\tt->next = NULL;\n\treturn (t);\n}",
    "includes": [
      "#include \"rf_chaindecluster.h\"",
      "#include \"rf_interdecluster.h\"",
      "#include \"rf_raid5_rotatedspare.h\"",
      "#include \"rf_decluster.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_reconbuffer.h\"",
      "#include \"rf_reconutil.h\"",
      "#include \"rf_desc.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_Malloc",
          "args": [
            "t->arrived",
            "raidPtr->numCol * sizeof(char)",
            "(char *)"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Malloc",
          "args": [
            "t->buffer",
            "recon_buffer_size",
            "(caddr_t)"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Malloc",
          "args": [
            "t",
            "sizeof(RF_ReconBuffer_t)",
            "(RF_ReconBuffer_t *)"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToByte",
          "args": [
            "raidPtr",
            "layoutPtr->SUsPerRU * layoutPtr->sectorsPerStripeUnit"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_chaindecluster.h\"\n#include \"rf_interdecluster.h\"\n#include \"rf_raid5_rotatedspare.h\"\n#include \"rf_decluster.h\"\n#include \"rf_general.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_reconutil.h\"\n#include \"rf_desc.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nRF_ReconBuffer_t *\nrf_MakeReconBuffer(\n    RF_Raid_t * raidPtr,\n    RF_RowCol_t row,\n    RF_RowCol_t col,\n    RF_RbufType_t type)\n{\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\tRF_ReconBuffer_t *t;\n\tu_int   recon_buffer_size = rf_RaidAddressToByte(raidPtr, layoutPtr->SUsPerRU * layoutPtr->sectorsPerStripeUnit);\n\n\tRF_Malloc(t, sizeof(RF_ReconBuffer_t), (RF_ReconBuffer_t *));\n\tRF_Malloc(t->buffer, recon_buffer_size, (caddr_t));\n\tRF_Malloc(t->arrived, raidPtr->numCol * sizeof(char), (char *));\n\tt->raidPtr = raidPtr;\n\tt->row = row;\n\tt->col = col;\n\tt->priority = RF_IO_RECON_PRIORITY;\n\tt->type = type;\n\tt->pssPtr = NULL;\n\tt->next = NULL;\n\treturn (t);\n}"
  },
  {
    "function_name": "rf_GetDefaultNumFloatingReconBuffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconutil.c",
    "lines": "212-224",
    "snippet": "int \nrf_GetDefaultNumFloatingReconBuffers(raidPtr)\n\tRF_Raid_t *raidPtr;\n{\n\tRF_LayoutSW_t *lp;\n\tint     nrb;\n\n\tlp = raidPtr->Layout.map;\n\tif (lp->GetDefaultNumFloatingReconBuffers == NULL)\n\t\treturn (3 * raidPtr->numCol);\n\tnrb = lp->GetDefaultNumFloatingReconBuffers(raidPtr);\n\treturn (nrb);\n}",
    "includes": [
      "#include \"rf_chaindecluster.h\"",
      "#include \"rf_interdecluster.h\"",
      "#include \"rf_raid5_rotatedspare.h\"",
      "#include \"rf_decluster.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_reconbuffer.h\"",
      "#include \"rf_reconutil.h\"",
      "#include \"rf_desc.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lp->GetDefaultNumFloatingReconBuffers",
          "args": [
            "raidPtr"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_chaindecluster.h\"\n#include \"rf_interdecluster.h\"\n#include \"rf_raid5_rotatedspare.h\"\n#include \"rf_decluster.h\"\n#include \"rf_general.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_reconutil.h\"\n#include \"rf_desc.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nint \nrf_GetDefaultNumFloatingReconBuffers(raidPtr)\n\tRF_Raid_t *raidPtr;\n{\n\tRF_LayoutSW_t *lp;\n\tint     nrb;\n\n\tlp = raidPtr->Layout.map;\n\tif (lp->GetDefaultNumFloatingReconBuffers == NULL)\n\t\treturn (3 * raidPtr->numCol);\n\tnrb = lp->GetDefaultNumFloatingReconBuffers(raidPtr);\n\treturn (nrb);\n}"
  },
  {
    "function_name": "rf_GetDefaultHeadSepLimit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconutil.c",
    "lines": "194-206",
    "snippet": "RF_HeadSepLimit_t \nrf_GetDefaultHeadSepLimit(raidPtr)\n\tRF_Raid_t *raidPtr;\n{\n\tRF_HeadSepLimit_t hsl;\n\tRF_LayoutSW_t *lp;\n\n\tlp = raidPtr->Layout.map;\n\tif (lp->GetDefaultHeadSepLimit == NULL)\n\t\treturn (-1);\n\thsl = lp->GetDefaultHeadSepLimit(raidPtr);\n\treturn (hsl);\n}",
    "includes": [
      "#include \"rf_chaindecluster.h\"",
      "#include \"rf_interdecluster.h\"",
      "#include \"rf_raid5_rotatedspare.h\"",
      "#include \"rf_decluster.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_reconbuffer.h\"",
      "#include \"rf_reconutil.h\"",
      "#include \"rf_desc.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lp->GetDefaultHeadSepLimit",
          "args": [
            "raidPtr"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_chaindecluster.h\"\n#include \"rf_interdecluster.h\"\n#include \"rf_raid5_rotatedspare.h\"\n#include \"rf_decluster.h\"\n#include \"rf_general.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_reconutil.h\"\n#include \"rf_desc.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nRF_HeadSepLimit_t \nrf_GetDefaultHeadSepLimit(raidPtr)\n\tRF_Raid_t *raidPtr;\n{\n\tRF_HeadSepLimit_t hsl;\n\tRF_LayoutSW_t *lp;\n\n\tlp = raidPtr->Layout.map;\n\tif (lp->GetDefaultHeadSepLimit == NULL)\n\t\treturn (-1);\n\thsl = lp->GetDefaultHeadSepLimit(raidPtr);\n\treturn (hsl);\n}"
  },
  {
    "function_name": "rf_FreeReconControl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconutil.c",
    "lines": "162-188",
    "snippet": "void \nrf_FreeReconControl(raidPtr, row)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n{\n\tRF_ReconCtrl_t *reconCtrlPtr = raidPtr->reconControl[row];\n\tRF_ReconBuffer_t *t;\n\tRF_ReconUnitNum_t i;\n\n\tRF_ASSERT(reconCtrlPtr);\n\tfor (i = 0; i < raidPtr->numCol; i++)\n\t\tif (reconCtrlPtr->perDiskInfo[i].rbuf)\n\t\t\trf_FreeReconBuffer(reconCtrlPtr->perDiskInfo[i].rbuf);\n\tfor (i = 0; i < raidPtr->numFloatingReconBufs; i++) {\n\t\tt = reconCtrlPtr->floatingRbufs;\n\t\tRF_ASSERT(t);\n\t\treconCtrlPtr->floatingRbufs = t->next;\n\t\trf_FreeReconBuffer(t);\n\t}\n\trf_mutex_destroy(&reconCtrlPtr->rb_mutex);\n\trf_mutex_destroy(&reconCtrlPtr->eq_mutex);\n\trf_cond_destroy(&reconCtrlPtr->eq_cond);\n\trf_FreeReconMap(reconCtrlPtr->reconMap);\n\trf_FreeParityStripeStatusTable(raidPtr, reconCtrlPtr->pssTable);\n\tRF_Free(reconCtrlPtr->perDiskInfo, raidPtr->numCol * sizeof(RF_PerDiskReconCtrl_t));\n\tRF_Free(reconCtrlPtr, sizeof(*reconCtrlPtr));\n}",
    "includes": [
      "#include \"rf_chaindecluster.h\"",
      "#include \"rf_interdecluster.h\"",
      "#include \"rf_raid5_rotatedspare.h\"",
      "#include \"rf_decluster.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_reconbuffer.h\"",
      "#include \"rf_reconutil.h\"",
      "#include \"rf_desc.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "reconCtrlPtr",
            "sizeof(*reconCtrlPtr)"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "reconCtrlPtr->perDiskInfo",
            "raidPtr->numCol * sizeof(RF_PerDiskReconCtrl_t)"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_FreeParityStripeStatusTable",
          "args": [
            "raidPtr",
            "reconCtrlPtr->pssTable"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "rf_FreeParityStripeStatusTable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_psstatus.c",
          "lines": "145-161",
          "snippet": "void \nrf_FreeParityStripeStatusTable(raidPtr, pssTable)\n\tRF_Raid_t *raidPtr;\n\tRF_PSStatusHeader_t *pssTable;\n{\n\tint     i;\n\n\tif (rf_pssDebug)\n\t\tRealPrintPSStatusTable(raidPtr, pssTable);\n\tfor (i = 0; i < raidPtr->pssTableSize; i++) {\n\t\tif (pssTable[i].chain) {\n\t\t\tprintf(\"ERROR: pss hash chain not null at recon shutdown\\n\");\n\t\t}\n\t\trf_mutex_destroy(&pssTable[i].mutex);\n\t}\n\tRF_Free(pssTable, raidPtr->pssTableSize * sizeof(RF_PSStatusHeader_t));\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_psstatus.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void \nRealPrintPSStatusTable(RF_Raid_t * raidPtr,\n    RF_PSStatusHeader_t * pssTable);",
            "static int init_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);",
            "static void clean_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);",
            "RF_PSStatusHeader_t *\nrf_MakeParityStripeStatusTable(raidPtr)\n\tRF_Raid_t *raidPtr;",
            "RF_ReconParityStripeStatus_t *\nrf_AllocPSStatus(raidPtr)\n\tRF_Raid_t *raidPtr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_psstatus.h\"\n#include \"rf_freelist.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_general.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nstatic void \nRealPrintPSStatusTable(RF_Raid_t * raidPtr,\n    RF_PSStatusHeader_t * pssTable);\nstatic int init_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);\nstatic void clean_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);\nRF_PSStatusHeader_t *\nrf_MakeParityStripeStatusTable(raidPtr)\n\tRF_Raid_t *raidPtr;\nRF_ReconParityStripeStatus_t *\nrf_AllocPSStatus(raidPtr)\n\tRF_Raid_t *raidPtr;\n\nvoid \nrf_FreeParityStripeStatusTable(raidPtr, pssTable)\n\tRF_Raid_t *raidPtr;\n\tRF_PSStatusHeader_t *pssTable;\n{\n\tint     i;\n\n\tif (rf_pssDebug)\n\t\tRealPrintPSStatusTable(raidPtr, pssTable);\n\tfor (i = 0; i < raidPtr->pssTableSize; i++) {\n\t\tif (pssTable[i].chain) {\n\t\t\tprintf(\"ERROR: pss hash chain not null at recon shutdown\\n\");\n\t\t}\n\t\trf_mutex_destroy(&pssTable[i].mutex);\n\t}\n\tRF_Free(pssTable, raidPtr->pssTableSize * sizeof(RF_PSStatusHeader_t));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_FreeReconMap",
          "args": [
            "reconCtrlPtr->reconMap"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "rf_FreeReconMap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconmap.c",
          "lines": "278-301",
          "snippet": "void \nrf_FreeReconMap(mapPtr)\n\tRF_ReconMap_t *mapPtr;\n{\n\tRF_ReconMapListElem_t *p, *q;\n\tRF_ReconUnitCount_t numRUs;\n\tRF_ReconUnitNum_t i;\n\n\tnumRUs = mapPtr->sectorsInDisk / mapPtr->sectorsPerReconUnit;\n\tif (mapPtr->sectorsInDisk % mapPtr->sectorsPerReconUnit)\n\t\tnumRUs++;\n\n\tfor (i = 0; i < numRUs; i++) {\n\t\tp = mapPtr->status[i];\n\t\twhile (p != RU_NOTHING && p != RU_ALL) {\n\t\t\tq = p;\n\t\t\tp = p->next;\n\t\t\tRF_Free(q, sizeof(*q));\n\t\t}\n\t}\n\trf_mutex_destroy(&mapPtr->mutex);\n\tRF_Free(mapPtr->status, mapPtr->totalRUs * sizeof(RF_ReconMapListElem_t *));\n\tRF_Free(mapPtr, sizeof(RF_ReconMap_t));\n}",
          "includes": [
            "#include \"rf_utils.h\"",
            "#include \"rf_general.h\"",
            "#include <sys/time.h>",
            "#include \"rf_raid.h\""
          ],
          "macros_used": [
            "#define RU_NOTHING  ((RF_ReconMapListElem_t *) 0)",
            "#define RU_ALL      ((RF_ReconMapListElem_t *) -1)"
          ],
          "globals_used": [
            "static void \ncompact_stat_entry(RF_Raid_t * raidPtr, RF_ReconMap_t * mapPtr,\n    int i);",
            "static RF_ReconMapListElem_t *\nMakeReconMapListElem(RF_SectorNum_t startSector,\n    RF_SectorNum_t stopSector, RF_ReconMapListElem_t * next);",
            "static void \nFreeReconMapListElem(RF_ReconMap_t * mapPtr,\n    RF_ReconMapListElem_t * p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_utils.h\"\n#include \"rf_general.h\"\n#include <sys/time.h>\n#include \"rf_raid.h\"\n\n#define RU_NOTHING  ((RF_ReconMapListElem_t *) 0)\n#define RU_ALL      ((RF_ReconMapListElem_t *) -1)\n\nstatic void \ncompact_stat_entry(RF_Raid_t * raidPtr, RF_ReconMap_t * mapPtr,\n    int i);\nstatic RF_ReconMapListElem_t *\nMakeReconMapListElem(RF_SectorNum_t startSector,\n    RF_SectorNum_t stopSector, RF_ReconMapListElem_t * next);\nstatic void \nFreeReconMapListElem(RF_ReconMap_t * mapPtr,\n    RF_ReconMapListElem_t * p);\n\nvoid \nrf_FreeReconMap(mapPtr)\n\tRF_ReconMap_t *mapPtr;\n{\n\tRF_ReconMapListElem_t *p, *q;\n\tRF_ReconUnitCount_t numRUs;\n\tRF_ReconUnitNum_t i;\n\n\tnumRUs = mapPtr->sectorsInDisk / mapPtr->sectorsPerReconUnit;\n\tif (mapPtr->sectorsInDisk % mapPtr->sectorsPerReconUnit)\n\t\tnumRUs++;\n\n\tfor (i = 0; i < numRUs; i++) {\n\t\tp = mapPtr->status[i];\n\t\twhile (p != RU_NOTHING && p != RU_ALL) {\n\t\t\tq = p;\n\t\t\tp = p->next;\n\t\t\tRF_Free(q, sizeof(*q));\n\t\t}\n\t}\n\trf_mutex_destroy(&mapPtr->mutex);\n\tRF_Free(mapPtr->status, mapPtr->totalRUs * sizeof(RF_ReconMapListElem_t *));\n\tRF_Free(mapPtr, sizeof(RF_ReconMap_t));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_cond_destroy",
          "args": [
            "&reconCtrlPtr->eq_cond"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_mutex_destroy",
          "args": [
            "&reconCtrlPtr->eq_mutex"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_mutex_destroy",
          "args": [
            "&reconCtrlPtr->rb_mutex"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_FreeReconBuffer",
          "args": [
            "t"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "rf_FreeReconBuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconutil.c",
          "lines": "256-266",
          "snippet": "void \nrf_FreeReconBuffer(rbuf)\n\tRF_ReconBuffer_t *rbuf;\n{\n\tRF_Raid_t *raidPtr = rbuf->raidPtr;\n\tu_int   recon_buffer_size = rf_RaidAddressToByte(raidPtr, raidPtr->Layout.SUsPerRU * raidPtr->Layout.sectorsPerStripeUnit);\n\n\tRF_Free(rbuf->arrived, raidPtr->numCol * sizeof(char));\n\tRF_Free(rbuf->buffer, recon_buffer_size);\n\tRF_Free(rbuf, sizeof(*rbuf));\n}",
          "includes": [
            "#include \"rf_chaindecluster.h\"",
            "#include \"rf_interdecluster.h\"",
            "#include \"rf_raid5_rotatedspare.h\"",
            "#include \"rf_decluster.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_reconbuffer.h\"",
            "#include \"rf_reconutil.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_chaindecluster.h\"\n#include \"rf_interdecluster.h\"\n#include \"rf_raid5_rotatedspare.h\"\n#include \"rf_decluster.h\"\n#include \"rf_general.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_reconutil.h\"\n#include \"rf_desc.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid \nrf_FreeReconBuffer(rbuf)\n\tRF_ReconBuffer_t *rbuf;\n{\n\tRF_Raid_t *raidPtr = rbuf->raidPtr;\n\tu_int   recon_buffer_size = rf_RaidAddressToByte(raidPtr, raidPtr->Layout.SUsPerRU * raidPtr->Layout.sectorsPerStripeUnit);\n\n\tRF_Free(rbuf->arrived, raidPtr->numCol * sizeof(char));\n\tRF_Free(rbuf->buffer, recon_buffer_size);\n\tRF_Free(rbuf, sizeof(*rbuf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "t"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "reconCtrlPtr"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_chaindecluster.h\"\n#include \"rf_interdecluster.h\"\n#include \"rf_raid5_rotatedspare.h\"\n#include \"rf_decluster.h\"\n#include \"rf_general.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_reconutil.h\"\n#include \"rf_desc.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid \nrf_FreeReconControl(raidPtr, row)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n{\n\tRF_ReconCtrl_t *reconCtrlPtr = raidPtr->reconControl[row];\n\tRF_ReconBuffer_t *t;\n\tRF_ReconUnitNum_t i;\n\n\tRF_ASSERT(reconCtrlPtr);\n\tfor (i = 0; i < raidPtr->numCol; i++)\n\t\tif (reconCtrlPtr->perDiskInfo[i].rbuf)\n\t\t\trf_FreeReconBuffer(reconCtrlPtr->perDiskInfo[i].rbuf);\n\tfor (i = 0; i < raidPtr->numFloatingReconBufs; i++) {\n\t\tt = reconCtrlPtr->floatingRbufs;\n\t\tRF_ASSERT(t);\n\t\treconCtrlPtr->floatingRbufs = t->next;\n\t\trf_FreeReconBuffer(t);\n\t}\n\trf_mutex_destroy(&reconCtrlPtr->rb_mutex);\n\trf_mutex_destroy(&reconCtrlPtr->eq_mutex);\n\trf_cond_destroy(&reconCtrlPtr->eq_cond);\n\trf_FreeReconMap(reconCtrlPtr->reconMap);\n\trf_FreeParityStripeStatusTable(raidPtr, reconCtrlPtr->pssTable);\n\tRF_Free(reconCtrlPtr->perDiskInfo, raidPtr->numCol * sizeof(RF_PerDiskReconCtrl_t));\n\tRF_Free(reconCtrlPtr, sizeof(*reconCtrlPtr));\n}"
  }
]